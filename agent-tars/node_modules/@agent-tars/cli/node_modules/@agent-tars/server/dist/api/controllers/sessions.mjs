/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
import { nanoid } from "nanoid";
import { ensureWorkingDirectory } from "../../utils/workspace.mjs";
import { AgentSession } from "../../core/index.mjs";
import { ShareService } from "../../services/index.mjs";
async function getAllSessions(req, res) {
    try {
        const server = req.app.locals.server;
        if (!server.storageProvider) {
            const activeSessions = Object.keys(server.sessions).map((id)=>({
                    id,
                    createdAt: Date.now(),
                    updatedAt: Date.now()
                }));
            return res.status(200).json({
                sessions: activeSessions
            });
        }
        const sessions = await server.storageProvider.getAllSessions();
        res.status(200).json({
            sessions
        });
    } catch (error) {
        console.error('Failed to get sessions:', error);
        res.status(500).json({
            error: 'Failed to get sessions'
        });
    }
}
async function createSession(req, res) {
    try {
        var _server_appConfig_workspace;
        const server = req.app.locals.server;
        const sessionId = nanoid();
        await cleanupBrowserPagesForExistingSessions(server);
        const isolateSessions = (null == (_server_appConfig_workspace = server.appConfig.workspace) ? void 0 : _server_appConfig_workspace.isolateSessions) ?? false;
        const workingDirectory = ensureWorkingDirectory(sessionId, server.workspacePath, isolateSessions);
        const session = new AgentSession(server, sessionId, server.getCustomAgioProvider());
        server.sessions[sessionId] = session;
        const { storageUnsubscribe } = await session.initialize();
        if (storageUnsubscribe) server.storageUnsubscribes[sessionId] = storageUnsubscribe;
        if (server.storageProvider) {
            const metadata = {
                id: sessionId,
                createdAt: Date.now(),
                updatedAt: Date.now(),
                workingDirectory
            };
            await server.storageProvider.createSession(metadata);
        }
        res.status(201).json({
            sessionId
        });
    } catch (error) {
        console.error('Failed to create session:', error);
        res.status(500).json({
            error: 'Failed to create session'
        });
    }
}
async function cleanupBrowserPagesForExistingSessions(server) {
    try {
        const activeSessions = Object.values(server.sessions);
        for (const session of activeSessions)if (session && session.agent) {
            var _session_agent_getBrowserManager, _session_agent;
            const browserManager = null == (_session_agent_getBrowserManager = (_session_agent = session.agent).getBrowserManager) ? void 0 : _session_agent_getBrowserManager.call(_session_agent);
            if (browserManager && browserManager.isLaunchingComplete()) {
                console.log("Closing browser pages for session before creating new session");
                await browserManager.closeAllPages();
            }
        }
    } catch (error) {
        console.warn(`Failed to cleanup browser pages for existing sessions: ${error instanceof Error ? error.message : String(error)}`);
    }
}
async function getSessionDetails(req, res) {
    const sessionId = req.query.sessionId;
    if (!sessionId) return res.status(400).json({
        error: 'Session ID is required'
    });
    try {
        const server = req.app.locals.server;
        if (server.storageProvider) {
            const metadata = await server.storageProvider.getSessionMetadata(sessionId);
            if (metadata) return res.status(200).json({
                session: metadata
            });
        }
        if (server.sessions[sessionId]) return res.status(200).json({
            session: {
                id: sessionId,
                createdAt: Date.now(),
                updatedAt: Date.now(),
                workingDirectory: server.sessions[sessionId].agent.getWorkingDirectory()
            }
        });
        return res.status(404).json({
            error: 'Session not found'
        });
    } catch (error) {
        console.error(`Error getting session details for ${sessionId}:`, error);
        res.status(500).json({
            error: 'Failed to get session details'
        });
    }
}
async function getSessionEvents(req, res) {
    const sessionId = req.query.sessionId;
    if (!sessionId) return res.status(400).json({
        error: 'Session ID is required'
    });
    try {
        const server = req.app.locals.server;
        if (!server.storageProvider) return res.status(404).json({
            error: 'Storage not configured, no events available'
        });
        const events = await server.storageProvider.getSessionEvents(sessionId);
        res.status(200).json({
            events
        });
    } catch (error) {
        console.error(`Error getting events for session ${sessionId}:`, error);
        res.status(500).json({
            error: 'Failed to get session events'
        });
    }
}
async function getSessionStatus(req, res) {
    const sessionId = req.query.sessionId;
    if (!sessionId) return res.status(400).json({
        error: 'Session ID is required'
    });
    try {
        const server = req.app.locals.server;
        let session = server.sessions[sessionId];
        if (!session && server.storageProvider) {
            const metadata = await server.storageProvider.getSessionMetadata(sessionId);
            if (metadata) try {
                session = new AgentSession(server, sessionId, server.getCustomAgioProvider());
                server.sessions[sessionId] = session;
                const { storageUnsubscribe } = await session.initialize();
                if (storageUnsubscribe) server.storageUnsubscribes[sessionId] = storageUnsubscribe;
            } catch (error) {
                console.error(`Failed to restore session ${sessionId}:`, error);
                return res.status(200).json({
                    sessionId,
                    status: {
                        isProcessing: false,
                        state: 'stored'
                    }
                });
            }
        }
        if (!session) return res.status(404).json({
            error: 'Session not found'
        });
        const isProcessing = session.getProcessingStatus();
        res.status(200).json({
            sessionId,
            status: {
                isProcessing,
                state: session.agent.status()
            }
        });
    } catch (error) {
        console.error(`Error getting session status (${sessionId}):`, error);
        res.status(500).json({
            error: 'Failed to get session status'
        });
    }
}
async function updateSession(req, res) {
    const { sessionId, name, tags } = req.body;
    if (!sessionId) return res.status(400).json({
        error: 'Session ID is required'
    });
    try {
        const server = req.app.locals.server;
        if (!server.storageProvider) return res.status(404).json({
            error: 'Storage not configured, cannot update session'
        });
        const metadata = await server.storageProvider.getSessionMetadata(sessionId);
        if (!metadata) return res.status(404).json({
            error: 'Session not found'
        });
        const updatedMetadata = await server.storageProvider.updateSessionMetadata(sessionId, {
            name,
            tags,
            updatedAt: Date.now()
        });
        res.status(200).json({
            session: updatedMetadata
        });
    } catch (error) {
        console.error(`Error updating session ${sessionId}:`, error);
        res.status(500).json({
            error: 'Failed to update session'
        });
    }
}
async function deleteSession(req, res) {
    const { sessionId } = req.body;
    if (!sessionId) return res.status(400).json({
        error: 'Session ID is required'
    });
    try {
        const server = req.app.locals.server;
        if (server.sessions[sessionId]) {
            try {
                var _server_sessions_sessionId_agent_getBrowserManager, _server_sessions_sessionId_agent;
                const browserManager = null == (_server_sessions_sessionId_agent_getBrowserManager = (_server_sessions_sessionId_agent = server.sessions[sessionId].agent).getBrowserManager) ? void 0 : _server_sessions_sessionId_agent_getBrowserManager.call(_server_sessions_sessionId_agent);
                if (browserManager && browserManager.isLaunchingComplete()) {
                    console.log(`Closing browser pages for session ${sessionId} before deletion`);
                    await browserManager.closeAllPages();
                }
            } catch (error) {
                console.warn(`Failed to cleanup browser pages for session ${sessionId}: ${error instanceof Error ? error.message : String(error)}`);
            }
            await server.sessions[sessionId].cleanup();
            delete server.sessions[sessionId];
            if (server.storageUnsubscribes[sessionId]) {
                server.storageUnsubscribes[sessionId]();
                delete server.storageUnsubscribes[sessionId];
            }
        }
        if (server.storageProvider) {
            const deleted = await server.storageProvider.deleteSession(sessionId);
            if (!deleted) return res.status(404).json({
                error: 'Session not found in storage'
            });
        }
        res.status(200).json({
            success: true
        });
    } catch (error) {
        console.error(`Error deleting session ${sessionId}:`, error);
        res.status(500).json({
            error: 'Failed to delete session'
        });
    }
}
async function generateSummary(req, res) {
    const { sessionId, messages, model, provider } = req.body;
    if (!sessionId) return res.status(400).json({
        error: 'Session ID is required'
    });
    if (!Array.isArray(messages) || 0 === messages.length) return res.status(400).json({
        error: 'Messages are required'
    });
    try {
        const server = req.app.locals.server;
        const session = server.sessions[sessionId];
        if (!session) return res.status(404).json({
            error: 'Session not found'
        });
        const summaryResponse = await session.agent.generateSummary({
            messages,
            model,
            provider
        });
        res.status(200).json(summaryResponse);
    } catch (error) {
        console.error(`Error generating summary for session ${sessionId}:`, error);
        res.status(500).json({
            error: 'Failed to generate summary',
            message: error instanceof Error ? error.message : String(error)
        });
    }
}
async function getBrowserControlInfo(req, res) {
    const sessionId = req.query.sessionId;
    if (!sessionId) return res.status(400).json({
        error: 'Session ID is required'
    });
    try {
        const server = req.app.locals.server;
        const session = server.sessions[sessionId];
        if (!session) return res.status(404).json({
            error: 'Session not found'
        });
        const browserControlInfo = await session.agent.getBrowserControlInfo();
        res.status(200).json(browserControlInfo);
    } catch (error) {
        console.error(`Error getting browser control info (${sessionId}):`, error);
        res.status(500).json({
            error: 'Failed to get browser control info'
        });
    }
}
async function shareSession(req, res) {
    const { sessionId, upload } = req.body;
    if (!sessionId) return res.status(400).json({
        error: 'Session ID is required'
    });
    try {
        var _server_sessions_sessionId;
        const server = req.app.locals.server;
        const shareService = new ShareService(server.appConfig, server.storageProvider);
        const agent = null == (_server_sessions_sessionId = server.sessions[sessionId]) ? void 0 : _server_sessions_sessionId.agent;
        const result = await shareService.shareSession(sessionId, upload, agent);
        if (result.success) return res.status(200).json(result);
        return res.status(500).json({
            error: result.error || 'Failed to share session'
        });
    } catch (error) {
        console.error(`Error sharing session ${sessionId}:`, error);
        return res.status(500).json({
            error: 'Failed to share session'
        });
    }
}
async function getLatestSessionEvents(req, res) {
    try {
        const server = req.app.locals.server;
        if (!server.storageProvider) return res.status(404).json({
            error: 'Storage not configured, cannot get latest session events'
        });
        const sessions = await server.storageProvider.getAllSessions();
        if (0 === sessions.length) return res.status(404).json({
            error: 'No sessions found'
        });
        const latestSession = sessions.reduce((latest, current)=>current.updatedAt > latest.updatedAt ? current : latest);
        const events = await server.storageProvider.getSessionEvents(latestSession.id);
        res.status(200).json({
            sessionId: latestSession.id,
            sessionMetadata: latestSession,
            events
        });
    } catch (error) {
        console.error('Error getting latest session events:', error);
        res.status(500).json({
            error: 'Failed to get latest session events'
        });
    }
}
export { createSession, deleteSession, generateSummary, getAllSessions, getBrowserControlInfo, getLatestSessionEvents, getSessionDetails, getSessionEvents, getSessionStatus, shareSession, updateSession };

//# sourceMappingURL=sessions.mjs.map