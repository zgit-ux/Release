/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    FileStorageProvider: ()=>FileStorageProvider
});
const external_path_namespaceObject = require("path");
var external_path_default = /*#__PURE__*/ __webpack_require__.n(external_path_namespaceObject);
const external_fs_namespaceObject = require("fs");
var external_fs_default = /*#__PURE__*/ __webpack_require__.n(external_fs_namespaceObject);
const external_lowdb_namespaceObject = require("lowdb");
const node_namespaceObject = require("lowdb/node");
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
class FileStorageProvider {
    async initialize() {
        if (!this.initialized) try {
            await this.db.read();
            this.db.data = this.db.data || {
                sessions: {},
                events: {}
            };
            this.initialized = true;
        } catch (error) {
            this.db.data = {
                sessions: {},
                events: {}
            };
            await this.db.write();
            this.initialized = true;
        }
    }
    async createSession(metadata) {
        await this.ensureInitialized();
        const sessionData = {
            ...metadata,
            createdAt: metadata.createdAt || Date.now(),
            updatedAt: metadata.updatedAt || Date.now()
        };
        this.db.data.sessions[metadata.id] = sessionData;
        this.db.data.events[metadata.id] = [];
        await this.db.write();
        return sessionData;
    }
    async updateSessionMetadata(sessionId, metadata) {
        await this.ensureInitialized();
        const session = this.db.data.sessions[sessionId];
        if (!session) throw new Error(`Session not found: ${sessionId}`);
        const updatedSession = {
            ...session,
            ...metadata,
            updatedAt: Date.now()
        };
        this.db.data.sessions[sessionId] = updatedSession;
        await this.db.write();
        return updatedSession;
    }
    async getSessionMetadata(sessionId) {
        await this.ensureInitialized();
        return this.db.data.sessions[sessionId] || null;
    }
    async getAllSessions() {
        await this.ensureInitialized();
        return Object.values(this.db.data.sessions);
    }
    async deleteSession(sessionId) {
        await this.ensureInitialized();
        if (!this.db.data.sessions[sessionId]) return false;
        delete this.db.data.sessions[sessionId];
        delete this.db.data.events[sessionId];
        await this.db.write();
        return true;
    }
    async saveEvent(sessionId, event) {
        await this.ensureInitialized();
        if (!this.db.data.sessions[sessionId]) throw new Error(`Session not found: ${sessionId}`);
        if (!this.db.data.events[sessionId]) this.db.data.events[sessionId] = [];
        this.db.data.events[sessionId].push(event);
        this.db.data.sessions[sessionId].updatedAt = Date.now();
        await this.db.write();
    }
    async getSessionEvents(sessionId) {
        await this.ensureInitialized();
        if (!this.db.data.sessions[sessionId]) throw new Error(`Session not found: ${sessionId}`);
        return this.db.data.events[sessionId] || [];
    }
    async close() {
        if (this.initialized) await this.db.write();
    }
    async ensureInitialized() {
        if (!this.initialized) await this.initialize();
    }
    constructor(storagePath){
        _define_property(this, "db", void 0);
        _define_property(this, "initialized", false);
        _define_property(this, "dbPath", void 0);
        const defaultPath = process.env.HOME || process.env.USERPROFILE || '.';
        const baseDir = storagePath || external_path_default().join(defaultPath, '.agent-tars');
        if (!external_fs_default().existsSync(baseDir)) external_fs_default().mkdirSync(baseDir, {
            recursive: true
        });
        this.dbPath = external_path_default().join(baseDir, 'storage.json');
        const adapter = new node_namespaceObject.JSONFile(this.dbPath);
        this.db = new external_lowdb_namespaceObject.Low(adapter, {
            sessions: {},
            events: {}
        });
    }
}
exports.FileStorageProvider = __webpack_exports__.FileStorageProvider;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "FileStorageProvider"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});

//# sourceMappingURL=FileStorageProvider.js.map