/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    getSessionEvents: ()=>getSessionEvents,
    deleteSession: ()=>deleteSession,
    generateSummary: ()=>generateSummary,
    getBrowserControlInfo: ()=>getBrowserControlInfo,
    getSessionStatus: ()=>getSessionStatus,
    shareSession: ()=>shareSession,
    getAllSessions: ()=>getAllSessions,
    getSessionDetails: ()=>getSessionDetails,
    getLatestSessionEvents: ()=>getLatestSessionEvents,
    updateSession: ()=>updateSession,
    createSession: ()=>createSession
});
const external_nanoid_namespaceObject = require("nanoid");
const workspace_js_namespaceObject = require("../../utils/workspace.js");
const index_js_namespaceObject = require("../../core/index.js");
const external_services_index_js_namespaceObject = require("../../services/index.js");
async function getAllSessions(req, res) {
    try {
        const server = req.app.locals.server;
        if (!server.storageProvider) {
            const activeSessions = Object.keys(server.sessions).map((id)=>({
                    id,
                    createdAt: Date.now(),
                    updatedAt: Date.now()
                }));
            return res.status(200).json({
                sessions: activeSessions
            });
        }
        const sessions = await server.storageProvider.getAllSessions();
        res.status(200).json({
            sessions
        });
    } catch (error) {
        console.error('Failed to get sessions:', error);
        res.status(500).json({
            error: 'Failed to get sessions'
        });
    }
}
async function createSession(req, res) {
    try {
        var _server_appConfig_workspace;
        const server = req.app.locals.server;
        const sessionId = (0, external_nanoid_namespaceObject.nanoid)();
        await cleanupBrowserPagesForExistingSessions(server);
        const isolateSessions = (null == (_server_appConfig_workspace = server.appConfig.workspace) ? void 0 : _server_appConfig_workspace.isolateSessions) ?? false;
        const workingDirectory = (0, workspace_js_namespaceObject.ensureWorkingDirectory)(sessionId, server.workspacePath, isolateSessions);
        const session = new index_js_namespaceObject.AgentSession(server, sessionId, server.getCustomAgioProvider());
        server.sessions[sessionId] = session;
        const { storageUnsubscribe } = await session.initialize();
        if (storageUnsubscribe) server.storageUnsubscribes[sessionId] = storageUnsubscribe;
        if (server.storageProvider) {
            const metadata = {
                id: sessionId,
                createdAt: Date.now(),
                updatedAt: Date.now(),
                workingDirectory
            };
            await server.storageProvider.createSession(metadata);
        }
        res.status(201).json({
            sessionId
        });
    } catch (error) {
        console.error('Failed to create session:', error);
        res.status(500).json({
            error: 'Failed to create session'
        });
    }
}
async function cleanupBrowserPagesForExistingSessions(server) {
    try {
        const activeSessions = Object.values(server.sessions);
        for (const session of activeSessions)if (session && session.agent) {
            var _session_agent_getBrowserManager, _session_agent;
            const browserManager = null == (_session_agent_getBrowserManager = (_session_agent = session.agent).getBrowserManager) ? void 0 : _session_agent_getBrowserManager.call(_session_agent);
            if (browserManager && browserManager.isLaunchingComplete()) {
                console.log("Closing browser pages for session before creating new session");
                await browserManager.closeAllPages();
            }
        }
    } catch (error) {
        console.warn(`Failed to cleanup browser pages for existing sessions: ${error instanceof Error ? error.message : String(error)}`);
    }
}
async function getSessionDetails(req, res) {
    const sessionId = req.query.sessionId;
    if (!sessionId) return res.status(400).json({
        error: 'Session ID is required'
    });
    try {
        const server = req.app.locals.server;
        if (server.storageProvider) {
            const metadata = await server.storageProvider.getSessionMetadata(sessionId);
            if (metadata) return res.status(200).json({
                session: metadata
            });
        }
        if (server.sessions[sessionId]) return res.status(200).json({
            session: {
                id: sessionId,
                createdAt: Date.now(),
                updatedAt: Date.now(),
                workingDirectory: server.sessions[sessionId].agent.getWorkingDirectory()
            }
        });
        return res.status(404).json({
            error: 'Session not found'
        });
    } catch (error) {
        console.error(`Error getting session details for ${sessionId}:`, error);
        res.status(500).json({
            error: 'Failed to get session details'
        });
    }
}
async function getSessionEvents(req, res) {
    const sessionId = req.query.sessionId;
    if (!sessionId) return res.status(400).json({
        error: 'Session ID is required'
    });
    try {
        const server = req.app.locals.server;
        if (!server.storageProvider) return res.status(404).json({
            error: 'Storage not configured, no events available'
        });
        const events = await server.storageProvider.getSessionEvents(sessionId);
        res.status(200).json({
            events
        });
    } catch (error) {
        console.error(`Error getting events for session ${sessionId}:`, error);
        res.status(500).json({
            error: 'Failed to get session events'
        });
    }
}
async function getSessionStatus(req, res) {
    const sessionId = req.query.sessionId;
    if (!sessionId) return res.status(400).json({
        error: 'Session ID is required'
    });
    try {
        const server = req.app.locals.server;
        let session = server.sessions[sessionId];
        if (!session && server.storageProvider) {
            const metadata = await server.storageProvider.getSessionMetadata(sessionId);
            if (metadata) try {
                session = new index_js_namespaceObject.AgentSession(server, sessionId, server.getCustomAgioProvider());
                server.sessions[sessionId] = session;
                const { storageUnsubscribe } = await session.initialize();
                if (storageUnsubscribe) server.storageUnsubscribes[sessionId] = storageUnsubscribe;
            } catch (error) {
                console.error(`Failed to restore session ${sessionId}:`, error);
                return res.status(200).json({
                    sessionId,
                    status: {
                        isProcessing: false,
                        state: 'stored'
                    }
                });
            }
        }
        if (!session) return res.status(404).json({
            error: 'Session not found'
        });
        const isProcessing = session.getProcessingStatus();
        res.status(200).json({
            sessionId,
            status: {
                isProcessing,
                state: session.agent.status()
            }
        });
    } catch (error) {
        console.error(`Error getting session status (${sessionId}):`, error);
        res.status(500).json({
            error: 'Failed to get session status'
        });
    }
}
async function updateSession(req, res) {
    const { sessionId, name, tags } = req.body;
    if (!sessionId) return res.status(400).json({
        error: 'Session ID is required'
    });
    try {
        const server = req.app.locals.server;
        if (!server.storageProvider) return res.status(404).json({
            error: 'Storage not configured, cannot update session'
        });
        const metadata = await server.storageProvider.getSessionMetadata(sessionId);
        if (!metadata) return res.status(404).json({
            error: 'Session not found'
        });
        const updatedMetadata = await server.storageProvider.updateSessionMetadata(sessionId, {
            name,
            tags,
            updatedAt: Date.now()
        });
        res.status(200).json({
            session: updatedMetadata
        });
    } catch (error) {
        console.error(`Error updating session ${sessionId}:`, error);
        res.status(500).json({
            error: 'Failed to update session'
        });
    }
}
async function deleteSession(req, res) {
    const { sessionId } = req.body;
    if (!sessionId) return res.status(400).json({
        error: 'Session ID is required'
    });
    try {
        const server = req.app.locals.server;
        if (server.sessions[sessionId]) {
            try {
                var _server_sessions_sessionId_agent_getBrowserManager, _server_sessions_sessionId_agent;
                const browserManager = null == (_server_sessions_sessionId_agent_getBrowserManager = (_server_sessions_sessionId_agent = server.sessions[sessionId].agent).getBrowserManager) ? void 0 : _server_sessions_sessionId_agent_getBrowserManager.call(_server_sessions_sessionId_agent);
                if (browserManager && browserManager.isLaunchingComplete()) {
                    console.log(`Closing browser pages for session ${sessionId} before deletion`);
                    await browserManager.closeAllPages();
                }
            } catch (error) {
                console.warn(`Failed to cleanup browser pages for session ${sessionId}: ${error instanceof Error ? error.message : String(error)}`);
            }
            await server.sessions[sessionId].cleanup();
            delete server.sessions[sessionId];
            if (server.storageUnsubscribes[sessionId]) {
                server.storageUnsubscribes[sessionId]();
                delete server.storageUnsubscribes[sessionId];
            }
        }
        if (server.storageProvider) {
            const deleted = await server.storageProvider.deleteSession(sessionId);
            if (!deleted) return res.status(404).json({
                error: 'Session not found in storage'
            });
        }
        res.status(200).json({
            success: true
        });
    } catch (error) {
        console.error(`Error deleting session ${sessionId}:`, error);
        res.status(500).json({
            error: 'Failed to delete session'
        });
    }
}
async function generateSummary(req, res) {
    const { sessionId, messages, model, provider } = req.body;
    if (!sessionId) return res.status(400).json({
        error: 'Session ID is required'
    });
    if (!Array.isArray(messages) || 0 === messages.length) return res.status(400).json({
        error: 'Messages are required'
    });
    try {
        const server = req.app.locals.server;
        const session = server.sessions[sessionId];
        if (!session) return res.status(404).json({
            error: 'Session not found'
        });
        const summaryResponse = await session.agent.generateSummary({
            messages,
            model,
            provider
        });
        res.status(200).json(summaryResponse);
    } catch (error) {
        console.error(`Error generating summary for session ${sessionId}:`, error);
        res.status(500).json({
            error: 'Failed to generate summary',
            message: error instanceof Error ? error.message : String(error)
        });
    }
}
async function getBrowserControlInfo(req, res) {
    const sessionId = req.query.sessionId;
    if (!sessionId) return res.status(400).json({
        error: 'Session ID is required'
    });
    try {
        const server = req.app.locals.server;
        const session = server.sessions[sessionId];
        if (!session) return res.status(404).json({
            error: 'Session not found'
        });
        const browserControlInfo = await session.agent.getBrowserControlInfo();
        res.status(200).json(browserControlInfo);
    } catch (error) {
        console.error(`Error getting browser control info (${sessionId}):`, error);
        res.status(500).json({
            error: 'Failed to get browser control info'
        });
    }
}
async function shareSession(req, res) {
    const { sessionId, upload } = req.body;
    if (!sessionId) return res.status(400).json({
        error: 'Session ID is required'
    });
    try {
        var _server_sessions_sessionId;
        const server = req.app.locals.server;
        const shareService = new external_services_index_js_namespaceObject.ShareService(server.appConfig, server.storageProvider);
        const agent = null == (_server_sessions_sessionId = server.sessions[sessionId]) ? void 0 : _server_sessions_sessionId.agent;
        const result = await shareService.shareSession(sessionId, upload, agent);
        if (result.success) return res.status(200).json(result);
        return res.status(500).json({
            error: result.error || 'Failed to share session'
        });
    } catch (error) {
        console.error(`Error sharing session ${sessionId}:`, error);
        return res.status(500).json({
            error: 'Failed to share session'
        });
    }
}
async function getLatestSessionEvents(req, res) {
    try {
        const server = req.app.locals.server;
        if (!server.storageProvider) return res.status(404).json({
            error: 'Storage not configured, cannot get latest session events'
        });
        const sessions = await server.storageProvider.getAllSessions();
        if (0 === sessions.length) return res.status(404).json({
            error: 'No sessions found'
        });
        const latestSession = sessions.reduce((latest, current)=>current.updatedAt > latest.updatedAt ? current : latest);
        const events = await server.storageProvider.getSessionEvents(latestSession.id);
        res.status(200).json({
            sessionId: latestSession.id,
            sessionMetadata: latestSession,
            events
        });
    } catch (error) {
        console.error('Error getting latest session events:', error);
        res.status(500).json({
            error: 'Failed to get latest session events'
        });
    }
}
exports.createSession = __webpack_exports__.createSession;
exports.deleteSession = __webpack_exports__.deleteSession;
exports.generateSummary = __webpack_exports__.generateSummary;
exports.getAllSessions = __webpack_exports__.getAllSessions;
exports.getBrowserControlInfo = __webpack_exports__.getBrowserControlInfo;
exports.getLatestSessionEvents = __webpack_exports__.getLatestSessionEvents;
exports.getSessionDetails = __webpack_exports__.getSessionDetails;
exports.getSessionEvents = __webpack_exports__.getSessionEvents;
exports.getSessionStatus = __webpack_exports__.getSessionStatus;
exports.shareSession = __webpack_exports__.shareSession;
exports.updateSession = __webpack_exports__.updateSession;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "createSession",
    "deleteSession",
    "generateSummary",
    "getAllSessions",
    "getBrowserControlInfo",
    "getLatestSessionEvents",
    "getSessionDetails",
    "getSessionEvents",
    "getSessionStatus",
    "shareSession",
    "updateSession"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});

//# sourceMappingURL=sessions.js.map