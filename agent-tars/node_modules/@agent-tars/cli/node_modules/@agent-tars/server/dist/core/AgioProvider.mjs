/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
import { AgioEvent } from "@multimodal/agio";
import { AgentStatus } from "@agent-tars/core";
import { AgioBatchProcessor } from "./AgioBatchProcessor.mjs";
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
class AgioProvider {
    calculateCounts() {
        var _this_appConfig_model;
        const toolsCount = this.agent.getTools().length;
        const modelProviders = null == (_this_appConfig_model = this.appConfig.model) ? void 0 : _this_appConfig_model.providers;
        const modelProvidersCount = Array.isArray(modelProviders) ? modelProviders.length : 1;
        const mcpServersConfig = this.appConfig.mcpServers || {};
        const mcpServersCount = Object.keys(mcpServersConfig).length;
        return {
            mcpServersCount,
            toolsCount,
            modelProvidersCount
        };
    }
    async sendAgentInitialized() {
        var _this_appConfig_browser, _this_appConfig_thinking, _this_appConfig_snapshot;
        if (this.hasInitialized) return;
        this.hasInitialized = true;
        const resolvedModel = this.agent.getCurrentResolvedModel();
        const counts = this.calculateCounts();
        this.modelName = null == resolvedModel ? void 0 : resolvedModel.id;
        const event = AgioEvent.createEvent('agent_initialized', this.sessionId, {
            config: {
                modelProvider: null == resolvedModel ? void 0 : resolvedModel.provider,
                modelName: null == resolvedModel ? void 0 : resolvedModel.id,
                toolCallEngine: this.appConfig.toolCallEngine,
                maxTokens: this.appConfig.maxTokens,
                temperature: this.appConfig.temperature,
                maxIterations: this.appConfig.maxIterations,
                browserControl: null == (_this_appConfig_browser = this.appConfig.browser) ? void 0 : _this_appConfig_browser.control,
                plannerEnabled: 'object' == typeof this.appConfig.planner ? this.appConfig.planner.enabled : Boolean(this.appConfig.planner),
                thinkingEnabled: (null == (_this_appConfig_thinking = this.appConfig.thinking) ? void 0 : _this_appConfig_thinking.type) === 'enabled',
                snapshotEnabled: null == (_this_appConfig_snapshot = this.appConfig.snapshot) ? void 0 : _this_appConfig_snapshot.enable,
                researchEnabled: 'object' == typeof this.appConfig.planner ? this.appConfig.planner.enabled : Boolean(this.appConfig.planner),
                customMcpServers: Boolean(this.appConfig.mcpServers && Object.keys(this.appConfig.mcpServers).length > 0)
            },
            count: counts
        });
        this.agentInitializedEvent = event;
    }
    async processAgentEvent(event) {
        try {
            switch(event.type){
                case 'agent_run_start':
                    await this.handleRunStart(event);
                    break;
                case 'agent_run_end':
                    await this.handleRunEnd(event);
                    break;
                case 'assistant_streaming_message':
                    await this.handleFirstToken(event);
                    break;
                case 'tool_call':
                    await this.handleToolCall(event);
                    break;
                case 'tool_result':
                    await this.handleToolResult(event);
                    break;
                case 'user_message':
                    await this.handleLoopStart();
                    break;
                case 'assistant_message':
                    await this.handleLoopEnd(event);
                    break;
                default:
                    break;
            }
        } catch (error) {
            console.error('Failed to process AGIO event:', error);
        }
    }
    isInputMultimodal(input) {
        if (!Array.isArray(input)) return false;
        return input.some((part)=>{
            if ('object' == typeof part && null !== part) {
                if ('image_url' === part.type || 'image' === part.type) return true;
                if (part.type && 'text' !== part.type) return true;
            }
            return false;
        });
    }
    async handleRunStart(event) {
        var _event_runOptions, _event_runOptions1, _event_runOptions2;
        if (this.agentInitializedEvent) {
            await this.queueEvent(this.agentInitializedEvent);
            this.agentInitializedEvent = null;
        }
        this.runId = event.sessionId;
        this.runStartTime = Date.now();
        this.firstTokenTime = void 0;
        this.currentIteration = 0;
        this.loopStartTimes.clear();
        const isMultimodalInput = this.isInputMultimodal((null == (_event_runOptions = event.runOptions) ? void 0 : _event_runOptions.input) || '');
        const agioEvent = AgioEvent.createEvent('agent_run_start', this.sessionId, {
            runId: this.runId,
            input: (null == (_event_runOptions1 = event.runOptions) ? void 0 : _event_runOptions1.input) || '',
            isMultimodalInput,
            streaming: Boolean(null == (_event_runOptions2 = event.runOptions) ? void 0 : _event_runOptions2.stream)
        });
        await this.queueEvent(agioEvent);
    }
    async handleRunEnd(event) {
        if (!this.runStartTime || !this.runId) return;
        const executionTimeMs = Date.now() - this.runStartTime;
        const successful = event.status !== AgentStatus.ERROR;
        const isError = event.status === AgentStatus.ERROR;
        const agioEvent = AgioEvent.createEvent('agent_run_end', this.sessionId, {
            runId: this.runId,
            executionTimeMs,
            loopCount: event.iterations || this.currentIteration,
            successful,
            error: isError ? 'AgentRunError' : ''
        });
        await this.queueEvent(agioEvent);
        await this.batchProcessor.flush();
        this.runId = void 0;
        this.runStartTime = void 0;
    }
    async handleFirstToken(event) {
        if (!this.firstTokenTime && this.runStartTime && event.content) {
            this.firstTokenTime = Date.now();
            const ttftMs = this.firstTokenTime - this.runStartTime;
            const agioEvent = AgioEvent.createEvent('agent_ttft', this.sessionId, {
                runId: this.runId,
                modelName: this.modelName,
                ttftMs
            });
            await this.queueEvent(agioEvent);
        }
    }
    async handleToolCall(event) {
        const sanitizedArgs = this.sanitizeArguments(event.arguments);
        const agioEvent = AgioEvent.createEvent('tool_call', this.sessionId, {
            runId: this.runId,
            toolName: event.name,
            toolCallId: event.toolCallId,
            arguments: sanitizedArgs,
            argumentsSize: JSON.stringify(event.arguments).length,
            mcpServer: this.extractMCPServer(event.name)
        });
        await this.queueEvent(agioEvent);
    }
    async handleToolResult(event) {
        const agioEvent = AgioEvent.createEvent('tool_result', this.sessionId, {
            runId: this.runId,
            toolName: event.name,
            toolCallId: event.toolCallId,
            executionTimeMs: event.elapsedMs || 0,
            successful: !event.error,
            resultSize: this.calculateResultSize(event.content),
            contentType: this.determineContentType(event.content)
        });
        await this.queueEvent(agioEvent);
    }
    async handleLoopStart() {
        this.currentIteration++;
        this.loopStartTimes.set(this.currentIteration, Date.now());
        const agioEvent = AgioEvent.createEvent('agent_loop_start', this.sessionId, {
            runId: this.runId,
            iteration: this.currentIteration
        });
        await this.queueEvent(agioEvent);
    }
    async handleLoopEnd(event) {
        const startTime = this.loopStartTimes.get(this.currentIteration);
        if (!startTime) return;
        const durationMs = Date.now() - startTime;
        const agioEvent = AgioEvent.createEvent('agent_loop_end', this.sessionId, {
            runId: this.runId,
            iteration: this.currentIteration,
            durationMs
        });
        await this.queueEvent(agioEvent);
        this.loopStartTimes.delete(this.currentIteration);
    }
    queueEvent(event) {
        this.batchProcessor.addEvent(event);
    }
    sanitizeArguments(args) {
        if (!args || 'object' != typeof args) return {};
        const sanitized = {};
        const sensitiveKeys = [
            'password',
            'token',
            'key',
            'secret',
            'apikey',
            'auth'
        ];
        for (const [key, value] of Object.entries(args)){
            const keyLower = key.toLowerCase();
            if (sensitiveKeys.some((sensitive)=>keyLower.includes(sensitive))) sanitized[key] = '[REDACTED]';
            else if ('string' == typeof value && value.length > 1000) sanitized[key] = value.substring(0, 100) + '...[TRUNCATED]';
            else sanitized[key] = value;
        }
        return sanitized;
    }
    extractMCPServer(toolName) {
        if (toolName.startsWith('browser_')) return 'browser';
        if (toolName.startsWith('filesystem_')) return 'filesystem';
        if ('web_search' === toolName) return 'search';
        if (toolName.startsWith('commands_')) return 'commands';
    }
    calculateResultSize(content) {
        if (!content) return 0;
        try {
            return JSON.stringify(content).length;
        } catch  {
            return String(content).length;
        }
    }
    determineContentType(content) {
        if (!content) return 'empty';
        if ('string' == typeof content) return 'text';
        if (Array.isArray(content)) return 'array';
        if ('object' == typeof content) return 'object';
        return 'unknown';
    }
    async cleanup() {
        await this.batchProcessor.flush();
    }
    constructor(providerUrl, appConfig, sessionId, agent){
        _define_property(this, "providerUrl", void 0);
        _define_property(this, "appConfig", void 0);
        _define_property(this, "sessionId", void 0);
        _define_property(this, "agent", void 0);
        _define_property(this, "runId", void 0);
        _define_property(this, "runStartTime", void 0);
        _define_property(this, "firstTokenTime", void 0);
        _define_property(this, "loopStartTimes", void 0);
        _define_property(this, "currentIteration", void 0);
        _define_property(this, "hasInitialized", void 0);
        _define_property(this, "modelName", void 0);
        _define_property(this, "batchProcessor", void 0);
        _define_property(this, "agentInitializedEvent", void 0);
        this.providerUrl = providerUrl;
        this.appConfig = appConfig;
        this.sessionId = sessionId;
        this.agent = agent;
        this.loopStartTimes = new Map();
        this.currentIteration = 0;
        this.hasInitialized = false;
        this.agentInitializedEvent = null;
        this.sessionId = sessionId;
        this.agent = agent;
        this.appConfig = agent.getOptions();
        this.batchProcessor = new AgioBatchProcessor({
            providerUrl: this.providerUrl,
            maxBatchSize: 3
        });
    }
}
export { AgioProvider };

//# sourceMappingURL=AgioProvider.mjs.map