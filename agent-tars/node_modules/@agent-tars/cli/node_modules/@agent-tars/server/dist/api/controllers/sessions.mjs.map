{"version":3,"file":"api/controllers/sessions.mjs","sources":["webpack://@agent-tars/server/./src/api/controllers/sessions.ts"],"sourcesContent":["/*\n * Copyright (c) 2025 Bytedance, Inc. and its affiliates.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Request, Response } from 'express';\nimport { nanoid } from 'nanoid';\nimport { AgentTARSServer } from '../../server';\nimport { ensureWorkingDirectory } from '../../utils/workspace';\nimport { SessionMetadata } from '../../storage';\nimport { AgentSession } from '../../core';\nimport { ShareService } from '../../services';\n\n/**\n * Get all sessions\n */\nexport async function getAllSessions(req: Request, res: Response) {\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n\n    if (!server.storageProvider) {\n      // If no storage, return only active sessions\n      const activeSessions = Object.keys(server.sessions).map((id) => ({\n        id,\n        createdAt: Date.now(),\n        updatedAt: Date.now(),\n      }));\n      return res.status(200).json({ sessions: activeSessions });\n    }\n\n    // Get all sessions from storage\n    const sessions = await server.storageProvider.getAllSessions();\n\n    res.status(200).json({ sessions });\n  } catch (error) {\n    console.error('Failed to get sessions:', error);\n    res.status(500).json({ error: 'Failed to get sessions' });\n  }\n}\n\n/**\n * Create a new session\n */\nexport async function createSession(req: Request, res: Response) {\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n\n    const sessionId = nanoid();\n\n    await cleanupBrowserPagesForExistingSessions(server);\n\n    // Use config.workspace?.isolateSessions (defaulting to false) to determine directory isolation\n    const isolateSessions = server.appConfig.workspace?.isolateSessions ?? false;\n    const workingDirectory = ensureWorkingDirectory(\n      sessionId,\n      server.workspacePath,\n      isolateSessions,\n    );\n\n    // Pass custom AGIO provider if available\n    const session = new AgentSession(server, sessionId, server.getCustomAgioProvider());\n    server.sessions[sessionId] = session;\n\n    const { storageUnsubscribe } = await session.initialize();\n\n    // Save unsubscribe function for cleanup\n    if (storageUnsubscribe) {\n      server.storageUnsubscribes[sessionId] = storageUnsubscribe;\n    }\n\n    // Store session metadata if we have storage\n    if (server.storageProvider) {\n      const metadata: SessionMetadata = {\n        id: sessionId,\n        createdAt: Date.now(),\n        updatedAt: Date.now(),\n        workingDirectory,\n      };\n\n      await server.storageProvider.createSession(metadata);\n    }\n\n    res.status(201).json({ sessionId });\n  } catch (error) {\n    console.error('Failed to create session:', error);\n    res.status(500).json({ error: 'Failed to create session' });\n  }\n}\n\n/**\n * Clean up browser pages for all existing sessions\n * Called when creating a new session to ensure that browser resources for the old session are properly released\n */\nasync function cleanupBrowserPagesForExistingSessions(server: AgentTARSServer): Promise<void> {\n  try {\n    // Get all active sessions\n    const activeSessions = Object.values(server.sessions);\n\n    // Call the method to clean up browser pages for each session\n    for (const session of activeSessions) {\n      if (session && session.agent) {\n        const browserManager = session.agent.getBrowserManager?.();\n        if (browserManager && browserManager.isLaunchingComplete()) {\n          console.log(`Closing browser pages for session before creating new session`);\n          await browserManager.closeAllPages();\n        }\n      }\n    }\n  } catch (error) {\n    console.warn(\n      `Failed to cleanup browser pages for existing sessions: ${error instanceof Error ? error.message : String(error)}`,\n    );\n    // Don't throw an error, as this shouldn't prevent the creation of a new session\n  }\n}\n\n/**\n * Get session details\n */\nexport async function getSessionDetails(req: Request, res: Response) {\n  const sessionId = req.query.sessionId as string;\n\n  if (!sessionId) {\n    return res.status(400).json({ error: 'Session ID is required' });\n  }\n\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n\n    // Check storage first\n    if (server.storageProvider) {\n      const metadata = await server.storageProvider.getSessionMetadata(sessionId);\n      if (metadata) {\n        return res.status(200).json({\n          session: metadata,\n        });\n      }\n    }\n\n    // Check active sessions\n    if (server.sessions[sessionId]) {\n      return res.status(200).json({\n        session: {\n          id: sessionId,\n          createdAt: Date.now(),\n          updatedAt: Date.now(),\n          workingDirectory: server.sessions[sessionId].agent.getWorkingDirectory(),\n        },\n      });\n    }\n\n    return res.status(404).json({ error: 'Session not found' });\n  } catch (error) {\n    console.error(`Error getting session details for ${sessionId}:`, error);\n    res.status(500).json({ error: 'Failed to get session details' });\n  }\n}\n\n/**\n * Get session events\n */\nexport async function getSessionEvents(req: Request, res: Response) {\n  const sessionId = req.query.sessionId as string;\n\n  if (!sessionId) {\n    return res.status(400).json({ error: 'Session ID is required' });\n  }\n\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n\n    if (!server.storageProvider) {\n      return res.status(404).json({ error: 'Storage not configured, no events available' });\n    }\n\n    const events = await server.storageProvider.getSessionEvents(sessionId);\n    res.status(200).json({ events });\n  } catch (error) {\n    console.error(`Error getting events for session ${sessionId}:`, error);\n    res.status(500).json({ error: 'Failed to get session events' });\n  }\n}\n\n/**\n * Get session status\n */\nexport async function getSessionStatus(req: Request, res: Response) {\n  const sessionId = req.query.sessionId as string;\n\n  if (!sessionId) {\n    return res.status(400).json({ error: 'Session ID is required' });\n  }\n\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n    let session = server.sessions[sessionId];\n\n    // If session not in memory but storage is available, try to restore it\n    if (!session && server.storageProvider) {\n      const metadata = await server.storageProvider.getSessionMetadata(sessionId);\n      if (metadata) {\n        try {\n          // Restore session from storage with custom AGIO provider\n          session = new AgentSession(server, sessionId, server.getCustomAgioProvider());\n          server.sessions[sessionId] = session;\n\n          const { storageUnsubscribe } = await session.initialize();\n\n          // Save unsubscribe function for cleanup\n          if (storageUnsubscribe) {\n            server.storageUnsubscribes[sessionId] = storageUnsubscribe;\n          }\n\n          // FIXME: migrate to logger\n          // console.log(`Session ${sessionId} restored from storage`);\n        } catch (error) {\n          console.error(`Failed to restore session ${sessionId}:`, error);\n          // Return session exists but not active status\n          return res.status(200).json({\n            sessionId,\n            status: {\n              isProcessing: false,\n              state: 'stored', // Special state indicating session exists in storage but not active\n            },\n          });\n        }\n      }\n    }\n\n    if (!session) {\n      return res.status(404).json({ error: 'Session not found' });\n    }\n\n    const isProcessing = session.getProcessingStatus();\n\n    res.status(200).json({\n      sessionId,\n      status: {\n        isProcessing,\n        state: session.agent.status(),\n      },\n    });\n  } catch (error) {\n    console.error(`Error getting session status (${sessionId}):`, error);\n    res.status(500).json({ error: 'Failed to get session status' });\n  }\n}\n\n/**\n * Update session metadata\n */\nexport async function updateSession(req: Request, res: Response) {\n  const { sessionId, name, tags } = req.body;\n\n  if (!sessionId) {\n    return res.status(400).json({ error: 'Session ID is required' });\n  }\n\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n\n    if (!server.storageProvider) {\n      return res.status(404).json({ error: 'Storage not configured, cannot update session' });\n    }\n\n    const metadata = await server.storageProvider.getSessionMetadata(sessionId);\n    if (!metadata) {\n      return res.status(404).json({ error: 'Session not found' });\n    }\n\n    const updatedMetadata = await server.storageProvider.updateSessionMetadata(sessionId, {\n      name,\n      tags,\n      updatedAt: Date.now(),\n    });\n\n    res.status(200).json({ session: updatedMetadata });\n  } catch (error) {\n    console.error(`Error updating session ${sessionId}:`, error);\n    res.status(500).json({ error: 'Failed to update session' });\n  }\n}\n\n/**\n * Delete a session\n */\nexport async function deleteSession(req: Request, res: Response) {\n  const { sessionId } = req.body;\n\n  if (!sessionId) {\n    return res.status(400).json({ error: 'Session ID is required' });\n  }\n\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n\n    // Close active session if exists\n    if (server.sessions[sessionId]) {\n      // Before clearing the session, try clearing the browser page first\n      try {\n        const browserManager = server.sessions[sessionId].agent.getBrowserManager?.();\n        if (browserManager && browserManager.isLaunchingComplete()) {\n          console.log(`Closing browser pages for session ${sessionId} before deletion`);\n          await browserManager.closeAllPages();\n        }\n      } catch (error) {\n        console.warn(\n          `Failed to cleanup browser pages for session ${sessionId}: ${error instanceof Error ? error.message : String(error)}`,\n        );\n        // Continue deleting sessions even if browser page cleanup fails\n      }\n\n      await server.sessions[sessionId].cleanup();\n      delete server.sessions[sessionId];\n\n      // Clean up storage unsubscribe\n      if (server.storageUnsubscribes[sessionId]) {\n        server.storageUnsubscribes[sessionId]();\n        delete server.storageUnsubscribes[sessionId];\n      }\n    }\n\n    // Delete from storage if configured\n    if (server.storageProvider) {\n      const deleted = await server.storageProvider.deleteSession(sessionId);\n      if (!deleted) {\n        return res.status(404).json({ error: 'Session not found in storage' });\n      }\n    }\n\n    res.status(200).json({ success: true });\n  } catch (error) {\n    console.error(`Error deleting session ${sessionId}:`, error);\n    res.status(500).json({ error: 'Failed to delete session' });\n  }\n}\n\n/**\n * Generate summary for a session\n */\nexport async function generateSummary(req: Request, res: Response) {\n  const { sessionId, messages, model, provider } = req.body;\n\n  if (!sessionId) {\n    return res.status(400).json({ error: 'Session ID is required' });\n  }\n\n  if (!Array.isArray(messages) || messages.length === 0) {\n    return res.status(400).json({ error: 'Messages are required' });\n  }\n\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n    const session = server.sessions[sessionId];\n\n    if (!session) {\n      return res.status(404).json({ error: 'Session not found' });\n    }\n\n    // FIXME: Use smaller messages to generate summaries\n    // Generate summary using the agent's method\n    const summaryResponse = await session.agent.generateSummary({\n      messages,\n      model,\n      provider,\n    });\n\n    // Return the summary\n    res.status(200).json(summaryResponse);\n  } catch (error) {\n    console.error(`Error generating summary for session ${sessionId}:`, error);\n    res.status(500).json({\n      error: 'Failed to generate summary',\n      message: error instanceof Error ? error.message : String(error),\n    });\n  }\n}\n\n/**\n * Get browser control information\n */\nexport async function getBrowserControlInfo(req: Request, res: Response) {\n  const sessionId = req.query.sessionId as string;\n\n  if (!sessionId) {\n    return res.status(400).json({ error: 'Session ID is required' });\n  }\n\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n    const session = server.sessions[sessionId];\n\n    if (!session) {\n      return res.status(404).json({ error: 'Session not found' });\n    }\n\n    // 获取浏览器控制模式信息 - 这需要在Agent中添加方法\n    const browserControlInfo = await session.agent.getBrowserControlInfo();\n\n    res.status(200).json(browserControlInfo);\n  } catch (error) {\n    console.error(`Error getting browser control info (${sessionId}):`, error);\n    res.status(500).json({ error: 'Failed to get browser control info' });\n  }\n}\n\n/**\n * Share a session\n */\nexport async function shareSession(req: Request, res: Response) {\n  const { sessionId, upload } = req.body;\n\n  if (!sessionId) {\n    return res.status(400).json({ error: 'Session ID is required' });\n  }\n\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n    const shareService = new ShareService(server.appConfig, server.storageProvider);\n\n    // Get agent instance if session is active (for slug generation)\n    const agent = server.sessions[sessionId]?.agent;\n    const result = await shareService.shareSession(sessionId, upload, agent);\n    if (result.success) {\n      return res.status(200).json(result);\n    } else {\n      return res.status(500).json({\n        error: result.error || 'Failed to share session',\n      });\n    }\n  } catch (error) {\n    console.error(`Error sharing session ${sessionId}:`, error);\n    return res.status(500).json({ error: 'Failed to share session' });\n  }\n}\n\n/**\n * Get events from the latest updated session\n */\nexport async function getLatestSessionEvents(req: Request, res: Response) {\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n\n    if (!server.storageProvider) {\n      return res\n        .status(404)\n        .json({ error: 'Storage not configured, cannot get latest session events' });\n    }\n\n    // Get all sessions\n    const sessions = await server.storageProvider.getAllSessions();\n\n    if (sessions.length === 0) {\n      return res.status(404).json({ error: 'No sessions found' });\n    }\n\n    // Find the session with the most recent updatedAt timestamp\n    const latestSession = sessions.reduce((latest, current) => {\n      return current.updatedAt > latest.updatedAt ? current : latest;\n    });\n\n    // Get events for the latest session\n    const events = await server.storageProvider.getSessionEvents(latestSession.id);\n\n    res.status(200).json({\n      sessionId: latestSession.id,\n      sessionMetadata: latestSession,\n      events,\n    });\n  } catch (error) {\n    console.error('Error getting latest session events:', error);\n    res.status(500).json({ error: 'Failed to get latest session events' });\n  }\n}\n"],"names":["getAllSessions","req","res","server","activeSessions","Object","id","Date","sessions","error","console","createSession","_server_appConfig_workspace","sessionId","nanoid","cleanupBrowserPagesForExistingSessions","isolateSessions","workingDirectory","ensureWorkingDirectory","session","AgentSession","storageUnsubscribe","metadata","_session_agent","browserManager","Error","String","getSessionDetails","getSessionEvents","events","getSessionStatus","isProcessing","updateSession","name","tags","updatedMetadata","deleteSession","_server_sessions_sessionId_agent","deleted","generateSummary","messages","model","provider","Array","summaryResponse","getBrowserControlInfo","browserControlInfo","shareSession","upload","_server_sessions_sessionId","shareService","ShareService","agent","result","getLatestSessionEvents","latestSession","latest","current"],"mappings":"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"}