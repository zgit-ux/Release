/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    SQLiteStorageProvider: ()=>SQLiteStorageProvider
});
const external_path_namespaceObject = require("path");
var external_path_default = /*#__PURE__*/ __webpack_require__.n(external_path_namespaceObject);
const external_fs_namespaceObject = require("fs");
var external_fs_default = /*#__PURE__*/ __webpack_require__.n(external_fs_namespaceObject);
const external_node_sqlite_namespaceObject = require("node:sqlite");
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
class SQLiteStorageProvider {
    async initialize() {
        if (!this.initialized) try {
            this.db.open();
            this.db.exec('PRAGMA journal_mode = WAL');
            this.db.exec(`
          CREATE TABLE IF NOT EXISTS sessions (
            id TEXT PRIMARY KEY,
            createdAt INTEGER NOT NULL,
            updatedAt INTEGER NOT NULL,
            name TEXT,
            workingDirectory TEXT NOT NULL,
            tags TEXT
          )
        `);
            this.db.exec(`
          CREATE TABLE IF NOT EXISTS events (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            sessionId TEXT NOT NULL,
            timestamp INTEGER NOT NULL,
            eventData TEXT NOT NULL,
            FOREIGN KEY (sessionId) REFERENCES sessions (id) ON DELETE CASCADE
          )
        `);
            this.db.exec(`
          CREATE INDEX IF NOT EXISTS idx_events_sessionId ON events (sessionId)
        `);
            this.db.exec('PRAGMA foreign_keys = ON');
            this.initialized = true;
        } catch (error) {
            console.error('Failed to initialize SQLite database:', error);
            throw error;
        }
    }
    async createSession(metadata) {
        await this.ensureInitialized();
        const sessionData = {
            ...metadata,
            createdAt: metadata.createdAt || Date.now(),
            updatedAt: metadata.updatedAt || Date.now()
        };
        const tagsJson = sessionData.tags ? JSON.stringify(sessionData.tags) : null;
        try {
            const stmt = this.db.prepare(`
        INSERT INTO sessions (id, createdAt, updatedAt, name, workingDirectory, tags)
        VALUES (?, ?, ?, ?, ?, ?)
      `);
            stmt.run(sessionData.id, sessionData.createdAt, sessionData.updatedAt, sessionData.name || null, sessionData.workingDirectory, tagsJson);
            return sessionData;
        } catch (error) {
            console.error(`Failed to create session ${sessionData.id}:`, error);
            throw new Error(`Failed to create session: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async updateSessionMetadata(sessionId, metadata) {
        await this.ensureInitialized();
        const session = await this.getSessionMetadata(sessionId);
        if (!session) throw new Error(`Session not found: ${sessionId}`);
        const updatedSession = {
            ...session,
            ...metadata,
            updatedAt: Date.now()
        };
        try {
            const params = [];
            const setClauses = [];
            if (void 0 !== metadata.name) {
                setClauses.push('name = ?');
                params.push(metadata.name || null);
            }
            if (void 0 !== metadata.workingDirectory) {
                setClauses.push('workingDirectory = ?');
                params.push(metadata.workingDirectory);
            }
            if (void 0 !== metadata.tags) {
                setClauses.push('tags = ?');
                params.push(metadata.tags ? JSON.stringify(metadata.tags) : null);
            }
            setClauses.push('updatedAt = ?');
            params.push(updatedSession.updatedAt);
            params.push(sessionId);
            if (0 === setClauses.length) return updatedSession;
            const updateQuery = `
        UPDATE sessions
        SET ${setClauses.join(', ')}
        WHERE id = ?
      `;
            const updateStmt = this.db.prepare(updateQuery);
            updateStmt.run(...params);
            return updatedSession;
        } catch (error) {
            console.error(`Failed to update session ${sessionId}:`, error);
            throw new Error(`Failed to update session: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async getSessionMetadata(sessionId) {
        await this.ensureInitialized();
        try {
            const stmt = this.db.prepare(`
        SELECT id, createdAt, updatedAt, name, workingDirectory, tags
        FROM sessions
        WHERE id = ?
      `);
            const row = stmt.get(sessionId);
            if (!row) return null;
            return {
                id: row.id,
                createdAt: row.createdAt,
                updatedAt: row.updatedAt,
                name: row.name || void 0,
                workingDirectory: row.workingDirectory,
                tags: row.tags ? JSON.parse(row.tags) : void 0
            };
        } catch (error) {
            console.error(`Failed to get session ${sessionId}:`, error);
            throw new Error(`Failed to get session: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async getAllSessions() {
        await this.ensureInitialized();
        try {
            const stmt = this.db.prepare(`
        SELECT id, createdAt, updatedAt, name, workingDirectory, tags
        FROM sessions
        ORDER BY updatedAt DESC
      `);
            const rows = stmt.all();
            return rows.map((row)=>({
                    id: row.id,
                    createdAt: row.createdAt,
                    updatedAt: row.updatedAt,
                    name: row.name || void 0,
                    workingDirectory: row.workingDirectory,
                    tags: row.tags ? JSON.parse(row.tags) : void 0
                }));
        } catch (error) {
            console.error('Failed to get all sessions:', error);
            throw new Error(`Failed to get all sessions: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async deleteSession(sessionId) {
        await this.ensureInitialized();
        try {
            const deleteEventsStmt = this.db.prepare('DELETE FROM events WHERE sessionId = ?');
            deleteEventsStmt.run(sessionId);
            const deleteSessionStmt = this.db.prepare('DELETE FROM sessions WHERE id = ?');
            const result = deleteSessionStmt.run(sessionId);
            return result.changes > 0;
        } catch (error) {
            console.error(`Failed to delete session ${sessionId}:`, error);
            throw new Error(`Failed to delete session: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async saveEvent(sessionId, event) {
        await this.ensureInitialized();
        try {
            const sessionExistsStmt = this.db.prepare(`
        SELECT 1 as existsFlag FROM sessions WHERE id = ?
      `);
            const sessionExists = sessionExistsStmt.get(sessionId);
            if (!sessionExists || !sessionExists.existsFlag) throw new Error(`Session not found: ${sessionId}`);
            const timestamp = Date.now();
            const eventData = JSON.stringify(event);
            const insertEventStmt = this.db.prepare(`
        INSERT INTO events (sessionId, timestamp, eventData)
        VALUES (?, ?, ?)
      `);
            insertEventStmt.run(sessionId, timestamp, eventData);
            const updateSessionStmt = this.db.prepare(`
        UPDATE sessions SET updatedAt = ? WHERE id = ?
      `);
            updateSessionStmt.run(timestamp, sessionId);
        } catch (error) {
            console.error(`Failed to save event for session ${sessionId}:`, error);
            throw new Error(`Failed to save event: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async getSessionEvents(sessionId) {
        await this.ensureInitialized();
        try {
            const sessionExistsStmt = this.db.prepare(`
        SELECT 1 as existsFlag FROM sessions WHERE id = ?
      `);
            const sessionExists = sessionExistsStmt.get(sessionId);
            if (!sessionExists || !sessionExists.existsFlag) throw new Error(`Session not found: ${sessionId}`);
            const stmt = this.db.prepare(`
        SELECT eventData
        FROM events
        WHERE sessionId = ?
        ORDER BY timestamp ASC, id ASC
      `);
            const rows = stmt.all(sessionId);
            return rows.map((row)=>{
                try {
                    return JSON.parse(row.eventData);
                } catch (error) {
                    console.error(`Failed to parse event data: ${row.eventData}`);
                    return {
                        type: 'system',
                        message: 'Failed to parse event data',
                        timestamp: Date.now()
                    };
                }
            });
        } catch (error) {
            console.error(`Failed to get events for session ${sessionId}:`, error);
            throw new Error(`Failed to get session events: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async close() {
        if (this.db && this.db.isOpen) this.db.close();
    }
    async ensureInitialized() {
        if (!this.initialized) await this.initialize();
    }
    constructor(storagePath){
        _define_property(this, "db", void 0);
        _define_property(this, "initialized", false);
        _define_property(this, "dbPath", void 0);
        const defaultPath = process.env.HOME || process.env.USERPROFILE || '.';
        const baseDir = storagePath || external_path_default().join(defaultPath, '.agent-tars');
        if (!external_fs_default().existsSync(baseDir)) external_fs_default().mkdirSync(baseDir, {
            recursive: true
        });
        this.dbPath = external_path_default().join(baseDir, 'agent-tars.db');
        this.db = new external_node_sqlite_namespaceObject.DatabaseSync(this.dbPath, {
            open: false
        });
    }
}
exports.SQLiteStorageProvider = __webpack_exports__.SQLiteStorageProvider;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "SQLiteStorageProvider"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});

//# sourceMappingURL=SQLiteStorageProvider.js.map