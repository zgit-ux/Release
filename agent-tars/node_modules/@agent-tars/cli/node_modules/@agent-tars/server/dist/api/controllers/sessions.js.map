{"version":3,"file":"api/controllers/sessions.js","sources":["webpack://@agent-tars/server/webpack/runtime/define_property_getters","webpack://@agent-tars/server/webpack/runtime/has_own_property","webpack://@agent-tars/server/webpack/runtime/make_namespace_object","webpack://@agent-tars/server/./src/api/controllers/sessions.ts"],"sourcesContent":["__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n        }\n    }\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/*\n * Copyright (c) 2025 Bytedance, Inc. and its affiliates.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Request, Response } from 'express';\nimport { nanoid } from 'nanoid';\nimport { AgentTARSServer } from '../../server';\nimport { ensureWorkingDirectory } from '../../utils/workspace';\nimport { SessionMetadata } from '../../storage';\nimport { AgentSession } from '../../core';\nimport { ShareService } from '../../services';\n\n/**\n * Get all sessions\n */\nexport async function getAllSessions(req: Request, res: Response) {\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n\n    if (!server.storageProvider) {\n      // If no storage, return only active sessions\n      const activeSessions = Object.keys(server.sessions).map((id) => ({\n        id,\n        createdAt: Date.now(),\n        updatedAt: Date.now(),\n      }));\n      return res.status(200).json({ sessions: activeSessions });\n    }\n\n    // Get all sessions from storage\n    const sessions = await server.storageProvider.getAllSessions();\n\n    res.status(200).json({ sessions });\n  } catch (error) {\n    console.error('Failed to get sessions:', error);\n    res.status(500).json({ error: 'Failed to get sessions' });\n  }\n}\n\n/**\n * Create a new session\n */\nexport async function createSession(req: Request, res: Response) {\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n\n    const sessionId = nanoid();\n\n    await cleanupBrowserPagesForExistingSessions(server);\n\n    // Use config.workspace?.isolateSessions (defaulting to false) to determine directory isolation\n    const isolateSessions = server.appConfig.workspace?.isolateSessions ?? false;\n    const workingDirectory = ensureWorkingDirectory(\n      sessionId,\n      server.workspacePath,\n      isolateSessions,\n    );\n\n    // Pass custom AGIO provider if available\n    const session = new AgentSession(server, sessionId, server.getCustomAgioProvider());\n    server.sessions[sessionId] = session;\n\n    const { storageUnsubscribe } = await session.initialize();\n\n    // Save unsubscribe function for cleanup\n    if (storageUnsubscribe) {\n      server.storageUnsubscribes[sessionId] = storageUnsubscribe;\n    }\n\n    // Store session metadata if we have storage\n    if (server.storageProvider) {\n      const metadata: SessionMetadata = {\n        id: sessionId,\n        createdAt: Date.now(),\n        updatedAt: Date.now(),\n        workingDirectory,\n      };\n\n      await server.storageProvider.createSession(metadata);\n    }\n\n    res.status(201).json({ sessionId });\n  } catch (error) {\n    console.error('Failed to create session:', error);\n    res.status(500).json({ error: 'Failed to create session' });\n  }\n}\n\n/**\n * Clean up browser pages for all existing sessions\n * Called when creating a new session to ensure that browser resources for the old session are properly released\n */\nasync function cleanupBrowserPagesForExistingSessions(server: AgentTARSServer): Promise<void> {\n  try {\n    // Get all active sessions\n    const activeSessions = Object.values(server.sessions);\n\n    // Call the method to clean up browser pages for each session\n    for (const session of activeSessions) {\n      if (session && session.agent) {\n        const browserManager = session.agent.getBrowserManager?.();\n        if (browserManager && browserManager.isLaunchingComplete()) {\n          console.log(`Closing browser pages for session before creating new session`);\n          await browserManager.closeAllPages();\n        }\n      }\n    }\n  } catch (error) {\n    console.warn(\n      `Failed to cleanup browser pages for existing sessions: ${error instanceof Error ? error.message : String(error)}`,\n    );\n    // Don't throw an error, as this shouldn't prevent the creation of a new session\n  }\n}\n\n/**\n * Get session details\n */\nexport async function getSessionDetails(req: Request, res: Response) {\n  const sessionId = req.query.sessionId as string;\n\n  if (!sessionId) {\n    return res.status(400).json({ error: 'Session ID is required' });\n  }\n\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n\n    // Check storage first\n    if (server.storageProvider) {\n      const metadata = await server.storageProvider.getSessionMetadata(sessionId);\n      if (metadata) {\n        return res.status(200).json({\n          session: metadata,\n        });\n      }\n    }\n\n    // Check active sessions\n    if (server.sessions[sessionId]) {\n      return res.status(200).json({\n        session: {\n          id: sessionId,\n          createdAt: Date.now(),\n          updatedAt: Date.now(),\n          workingDirectory: server.sessions[sessionId].agent.getWorkingDirectory(),\n        },\n      });\n    }\n\n    return res.status(404).json({ error: 'Session not found' });\n  } catch (error) {\n    console.error(`Error getting session details for ${sessionId}:`, error);\n    res.status(500).json({ error: 'Failed to get session details' });\n  }\n}\n\n/**\n * Get session events\n */\nexport async function getSessionEvents(req: Request, res: Response) {\n  const sessionId = req.query.sessionId as string;\n\n  if (!sessionId) {\n    return res.status(400).json({ error: 'Session ID is required' });\n  }\n\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n\n    if (!server.storageProvider) {\n      return res.status(404).json({ error: 'Storage not configured, no events available' });\n    }\n\n    const events = await server.storageProvider.getSessionEvents(sessionId);\n    res.status(200).json({ events });\n  } catch (error) {\n    console.error(`Error getting events for session ${sessionId}:`, error);\n    res.status(500).json({ error: 'Failed to get session events' });\n  }\n}\n\n/**\n * Get session status\n */\nexport async function getSessionStatus(req: Request, res: Response) {\n  const sessionId = req.query.sessionId as string;\n\n  if (!sessionId) {\n    return res.status(400).json({ error: 'Session ID is required' });\n  }\n\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n    let session = server.sessions[sessionId];\n\n    // If session not in memory but storage is available, try to restore it\n    if (!session && server.storageProvider) {\n      const metadata = await server.storageProvider.getSessionMetadata(sessionId);\n      if (metadata) {\n        try {\n          // Restore session from storage with custom AGIO provider\n          session = new AgentSession(server, sessionId, server.getCustomAgioProvider());\n          server.sessions[sessionId] = session;\n\n          const { storageUnsubscribe } = await session.initialize();\n\n          // Save unsubscribe function for cleanup\n          if (storageUnsubscribe) {\n            server.storageUnsubscribes[sessionId] = storageUnsubscribe;\n          }\n\n          // FIXME: migrate to logger\n          // console.log(`Session ${sessionId} restored from storage`);\n        } catch (error) {\n          console.error(`Failed to restore session ${sessionId}:`, error);\n          // Return session exists but not active status\n          return res.status(200).json({\n            sessionId,\n            status: {\n              isProcessing: false,\n              state: 'stored', // Special state indicating session exists in storage but not active\n            },\n          });\n        }\n      }\n    }\n\n    if (!session) {\n      return res.status(404).json({ error: 'Session not found' });\n    }\n\n    const isProcessing = session.getProcessingStatus();\n\n    res.status(200).json({\n      sessionId,\n      status: {\n        isProcessing,\n        state: session.agent.status(),\n      },\n    });\n  } catch (error) {\n    console.error(`Error getting session status (${sessionId}):`, error);\n    res.status(500).json({ error: 'Failed to get session status' });\n  }\n}\n\n/**\n * Update session metadata\n */\nexport async function updateSession(req: Request, res: Response) {\n  const { sessionId, name, tags } = req.body;\n\n  if (!sessionId) {\n    return res.status(400).json({ error: 'Session ID is required' });\n  }\n\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n\n    if (!server.storageProvider) {\n      return res.status(404).json({ error: 'Storage not configured, cannot update session' });\n    }\n\n    const metadata = await server.storageProvider.getSessionMetadata(sessionId);\n    if (!metadata) {\n      return res.status(404).json({ error: 'Session not found' });\n    }\n\n    const updatedMetadata = await server.storageProvider.updateSessionMetadata(sessionId, {\n      name,\n      tags,\n      updatedAt: Date.now(),\n    });\n\n    res.status(200).json({ session: updatedMetadata });\n  } catch (error) {\n    console.error(`Error updating session ${sessionId}:`, error);\n    res.status(500).json({ error: 'Failed to update session' });\n  }\n}\n\n/**\n * Delete a session\n */\nexport async function deleteSession(req: Request, res: Response) {\n  const { sessionId } = req.body;\n\n  if (!sessionId) {\n    return res.status(400).json({ error: 'Session ID is required' });\n  }\n\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n\n    // Close active session if exists\n    if (server.sessions[sessionId]) {\n      // Before clearing the session, try clearing the browser page first\n      try {\n        const browserManager = server.sessions[sessionId].agent.getBrowserManager?.();\n        if (browserManager && browserManager.isLaunchingComplete()) {\n          console.log(`Closing browser pages for session ${sessionId} before deletion`);\n          await browserManager.closeAllPages();\n        }\n      } catch (error) {\n        console.warn(\n          `Failed to cleanup browser pages for session ${sessionId}: ${error instanceof Error ? error.message : String(error)}`,\n        );\n        // Continue deleting sessions even if browser page cleanup fails\n      }\n\n      await server.sessions[sessionId].cleanup();\n      delete server.sessions[sessionId];\n\n      // Clean up storage unsubscribe\n      if (server.storageUnsubscribes[sessionId]) {\n        server.storageUnsubscribes[sessionId]();\n        delete server.storageUnsubscribes[sessionId];\n      }\n    }\n\n    // Delete from storage if configured\n    if (server.storageProvider) {\n      const deleted = await server.storageProvider.deleteSession(sessionId);\n      if (!deleted) {\n        return res.status(404).json({ error: 'Session not found in storage' });\n      }\n    }\n\n    res.status(200).json({ success: true });\n  } catch (error) {\n    console.error(`Error deleting session ${sessionId}:`, error);\n    res.status(500).json({ error: 'Failed to delete session' });\n  }\n}\n\n/**\n * Generate summary for a session\n */\nexport async function generateSummary(req: Request, res: Response) {\n  const { sessionId, messages, model, provider } = req.body;\n\n  if (!sessionId) {\n    return res.status(400).json({ error: 'Session ID is required' });\n  }\n\n  if (!Array.isArray(messages) || messages.length === 0) {\n    return res.status(400).json({ error: 'Messages are required' });\n  }\n\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n    const session = server.sessions[sessionId];\n\n    if (!session) {\n      return res.status(404).json({ error: 'Session not found' });\n    }\n\n    // FIXME: Use smaller messages to generate summaries\n    // Generate summary using the agent's method\n    const summaryResponse = await session.agent.generateSummary({\n      messages,\n      model,\n      provider,\n    });\n\n    // Return the summary\n    res.status(200).json(summaryResponse);\n  } catch (error) {\n    console.error(`Error generating summary for session ${sessionId}:`, error);\n    res.status(500).json({\n      error: 'Failed to generate summary',\n      message: error instanceof Error ? error.message : String(error),\n    });\n  }\n}\n\n/**\n * Get browser control information\n */\nexport async function getBrowserControlInfo(req: Request, res: Response) {\n  const sessionId = req.query.sessionId as string;\n\n  if (!sessionId) {\n    return res.status(400).json({ error: 'Session ID is required' });\n  }\n\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n    const session = server.sessions[sessionId];\n\n    if (!session) {\n      return res.status(404).json({ error: 'Session not found' });\n    }\n\n    // 获取浏览器控制模式信息 - 这需要在Agent中添加方法\n    const browserControlInfo = await session.agent.getBrowserControlInfo();\n\n    res.status(200).json(browserControlInfo);\n  } catch (error) {\n    console.error(`Error getting browser control info (${sessionId}):`, error);\n    res.status(500).json({ error: 'Failed to get browser control info' });\n  }\n}\n\n/**\n * Share a session\n */\nexport async function shareSession(req: Request, res: Response) {\n  const { sessionId, upload } = req.body;\n\n  if (!sessionId) {\n    return res.status(400).json({ error: 'Session ID is required' });\n  }\n\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n    const shareService = new ShareService(server.appConfig, server.storageProvider);\n\n    // Get agent instance if session is active (for slug generation)\n    const agent = server.sessions[sessionId]?.agent;\n    const result = await shareService.shareSession(sessionId, upload, agent);\n    if (result.success) {\n      return res.status(200).json(result);\n    } else {\n      return res.status(500).json({\n        error: result.error || 'Failed to share session',\n      });\n    }\n  } catch (error) {\n    console.error(`Error sharing session ${sessionId}:`, error);\n    return res.status(500).json({ error: 'Failed to share session' });\n  }\n}\n\n/**\n * Get events from the latest updated session\n */\nexport async function getLatestSessionEvents(req: Request, res: Response) {\n  try {\n    const server = req.app.locals.server as AgentTARSServer;\n\n    if (!server.storageProvider) {\n      return res\n        .status(404)\n        .json({ error: 'Storage not configured, cannot get latest session events' });\n    }\n\n    // Get all sessions\n    const sessions = await server.storageProvider.getAllSessions();\n\n    if (sessions.length === 0) {\n      return res.status(404).json({ error: 'No sessions found' });\n    }\n\n    // Find the session with the most recent updatedAt timestamp\n    const latestSession = sessions.reduce((latest, current) => {\n      return current.updatedAt > latest.updatedAt ? current : latest;\n    });\n\n    // Get events for the latest session\n    const events = await server.storageProvider.getSessionEvents(latestSession.id);\n\n    res.status(200).json({\n      sessionId: latestSession.id,\n      sessionMetadata: latestSession,\n      events,\n    });\n  } catch (error) {\n    console.error('Error getting latest session events:', error);\n    res.status(500).json({ error: 'Failed to get latest session events' });\n  }\n}\n"],"names":["__webpack_require__","definition","key","Object","obj","prop","Symbol","getAllSessions","req","res","server","activeSessions","id","Date","sessions","error","console","createSession","_server_appConfig_workspace","sessionId","nanoid","cleanupBrowserPagesForExistingSessions","isolateSessions","workingDirectory","ensureWorkingDirectory","session","AgentSession","storageUnsubscribe","metadata","_session_agent","browserManager","Error","String","getSessionDetails","getSessionEvents","events","getSessionStatus","isProcessing","updateSession","name","tags","updatedMetadata","deleteSession","_server_sessions_sessionId_agent","deleted","generateSummary","messages","model","provider","Array","summaryResponse","getBrowserControlInfo","browserControlInfo","shareSession","upload","_server_sessions_sessionId","shareService","ShareService","agent","result","getLatestSessionEvents","latestSession","latest","current"],"mappings":"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"}