/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
/*! For license information please see index.js.LICENSE.txt */
var __webpack_modules__ = {
    "../node_modules/.pnpm/accepts@1.3.8/node_modules/accepts/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Negotiator = __webpack_require__("../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/index.js");
        var mime = __webpack_require__("../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js");
        module.exports = Accepts;
        function Accepts(req) {
            if (!(this instanceof Accepts)) return new Accepts(req);
            this.headers = req.headers;
            this.negotiator = new Negotiator(req);
        }
        Accepts.prototype.type = Accepts.prototype.types = function(types_) {
            var types = types_;
            if (types && !Array.isArray(types)) {
                types = new Array(arguments.length);
                for(var i = 0; i < types.length; i++)types[i] = arguments[i];
            }
            if (!types || 0 === types.length) return this.negotiator.mediaTypes();
            if (!this.headers.accept) return types[0];
            var mimes = types.map(extToMime);
            var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
            var first = accepts[0];
            return first ? types[mimes.indexOf(first)] : false;
        };
        Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
            var encodings = encodings_;
            if (encodings && !Array.isArray(encodings)) {
                encodings = new Array(arguments.length);
                for(var i = 0; i < encodings.length; i++)encodings[i] = arguments[i];
            }
            if (!encodings || 0 === encodings.length) return this.negotiator.encodings();
            return this.negotiator.encodings(encodings)[0] || false;
        };
        Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
            var charsets = charsets_;
            if (charsets && !Array.isArray(charsets)) {
                charsets = new Array(arguments.length);
                for(var i = 0; i < charsets.length; i++)charsets[i] = arguments[i];
            }
            if (!charsets || 0 === charsets.length) return this.negotiator.charsets();
            return this.negotiator.charsets(charsets)[0] || false;
        };
        Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
            var languages = languages_;
            if (languages && !Array.isArray(languages)) {
                languages = new Array(arguments.length);
                for(var i = 0; i < languages.length; i++)languages[i] = arguments[i];
            }
            if (!languages || 0 === languages.length) return this.negotiator.languages();
            return this.negotiator.languages(languages)[0] || false;
        };
        function extToMime(type) {
            return -1 === type.indexOf('/') ? mime.lookup(type) : type;
        }
        function validMime(type) {
            return 'string' == typeof type;
        }
    },
    "../node_modules/.pnpm/array-flatten@1.1.1/node_modules/array-flatten/array-flatten.js": function(module) {
        "use strict";
        module.exports = arrayFlatten;
        function flattenWithDepth(array, result, depth) {
            for(var i = 0; i < array.length; i++){
                var value = array[i];
                if (depth > 0 && Array.isArray(value)) flattenWithDepth(value, result, depth - 1);
                else result.push(value);
            }
            return result;
        }
        function flattenForever(array, result) {
            for(var i = 0; i < array.length; i++){
                var value = array[i];
                if (Array.isArray(value)) flattenForever(value, result);
                else result.push(value);
            }
            return result;
        }
        function arrayFlatten(array, depth) {
            if (null == depth) return flattenForever(array, []);
            return flattenWithDepth(array, [], depth);
        }
    },
    "../node_modules/.pnpm/base64id@2.0.0/node_modules/base64id/lib/base64id.js": function(module, exports1, __webpack_require__) {
        /*!
 * base64id v0.1.0
 */ var crypto = __webpack_require__("crypto");
        var Base64Id = function() {};
        Base64Id.prototype.getRandomBytes = function(bytes) {
            var BUFFER_SIZE = 4096;
            var self = this;
            bytes = bytes || 12;
            if (bytes > BUFFER_SIZE) return crypto.randomBytes(bytes);
            var bytesInBuffer = parseInt(BUFFER_SIZE / bytes);
            var threshold = parseInt(0.85 * bytesInBuffer);
            if (!threshold) return crypto.randomBytes(bytes);
            if (null == this.bytesBufferIndex) this.bytesBufferIndex = -1;
            if (this.bytesBufferIndex == bytesInBuffer) {
                this.bytesBuffer = null;
                this.bytesBufferIndex = -1;
            }
            if (-1 == this.bytesBufferIndex || this.bytesBufferIndex > threshold) {
                if (!this.isGeneratingBytes) {
                    this.isGeneratingBytes = true;
                    crypto.randomBytes(BUFFER_SIZE, function(err, bytes) {
                        self.bytesBuffer = bytes;
                        self.bytesBufferIndex = 0;
                        self.isGeneratingBytes = false;
                    });
                }
                if (-1 == this.bytesBufferIndex) return crypto.randomBytes(bytes);
            }
            var result = this.bytesBuffer.slice(bytes * this.bytesBufferIndex, bytes * (this.bytesBufferIndex + 1));
            this.bytesBufferIndex++;
            return result;
        };
        Base64Id.prototype.generateId = function() {
            var rand = Buffer.alloc(15);
            if (!rand.writeInt32BE) return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString() + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();
            this.sequenceNumber = this.sequenceNumber + 1 | 0;
            rand.writeInt32BE(this.sequenceNumber, 11);
            if (crypto.randomBytes) this.getRandomBytes(12).copy(rand);
            else [
                0,
                4,
                8
            ].forEach(function(i) {
                rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i);
            });
            return rand.toString('base64').replace(/\//g, '_').replace(/\+/g, '-');
        };
        module.exports = new Base64Id();
    },
    "../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/index.js": function(module, exports1, __webpack_require__) {
        "use strict";
        /*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var deprecate = __webpack_require__("../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('body-parser');
        var parsers = Object.create(null);
        exports1 = module.exports = deprecate.function(bodyParser, 'bodyParser: use individual json/urlencoded middlewares');
        Object.defineProperty(exports1, "json", {
            configurable: true,
            enumerable: true,
            get: createParserGetter('json')
        });
        Object.defineProperty(exports1, "raw", {
            configurable: true,
            enumerable: true,
            get: createParserGetter('raw')
        });
        Object.defineProperty(exports1, "text", {
            configurable: true,
            enumerable: true,
            get: createParserGetter('text')
        });
        Object.defineProperty(exports1, "urlencoded", {
            configurable: true,
            enumerable: true,
            get: createParserGetter('urlencoded')
        });
        function bodyParser(options) {
            var opts = Object.create(options || null, {
                type: {
                    configurable: true,
                    enumerable: true,
                    value: void 0,
                    writable: true
                }
            });
            var _urlencoded = exports1.urlencoded(opts);
            var _json = exports1.json(opts);
            return function(req, res, next) {
                _json(req, res, function(err) {
                    if (err) return next(err);
                    _urlencoded(req, res, next);
                });
            };
        }
        function createParserGetter(name) {
            return function() {
                return loadParser(name);
            };
        }
        function loadParser(parserName) {
            var parser = parsers[parserName];
            if (void 0 !== parser) return parser;
            switch(parserName){
                case 'json':
                    parser = __webpack_require__("../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/json.js");
                    break;
                case 'raw':
                    parser = __webpack_require__("../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/raw.js");
                    break;
                case 'text':
                    parser = __webpack_require__("../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/text.js");
                    break;
                case 'urlencoded':
                    parser = __webpack_require__("../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/urlencoded.js");
                    break;
            }
            return parsers[parserName] = parser;
        }
    },
    "../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/read.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var createError = __webpack_require__("../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js");
        var destroy = __webpack_require__("../node_modules/.pnpm/destroy@1.2.0/node_modules/destroy/index.js");
        var getBody = __webpack_require__("../node_modules/.pnpm/raw-body@2.5.2/node_modules/raw-body/index.js");
        var iconv = __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/index.js");
        var onFinished = __webpack_require__("../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js");
        var unpipe = __webpack_require__("../node_modules/.pnpm/unpipe@1.0.0/node_modules/unpipe/index.js");
        var zlib = __webpack_require__("zlib");
        module.exports = read;
        function read(req, res, next, parse, debug, options) {
            var length;
            var opts = options;
            var stream;
            req._body = true;
            var encoding = null !== opts.encoding ? opts.encoding : null;
            var verify = opts.verify;
            try {
                stream = contentstream(req, debug, opts.inflate);
                length = stream.length;
                stream.length = void 0;
            } catch (err) {
                return next(err);
            }
            opts.length = length;
            opts.encoding = verify ? null : encoding;
            if (null === opts.encoding && null !== encoding && !iconv.encodingExists(encoding)) return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
                charset: encoding.toLowerCase(),
                type: 'charset.unsupported'
            }));
            debug('read body');
            getBody(stream, opts, function(error, body) {
                if (error) {
                    var _error;
                    _error = 'encoding.unsupported' === error.type ? createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
                        charset: encoding.toLowerCase(),
                        type: 'charset.unsupported'
                    }) : createError(400, error);
                    if (stream !== req) {
                        unpipe(req);
                        destroy(stream, true);
                    }
                    dump(req, function() {
                        next(createError(400, _error));
                    });
                    return;
                }
                if (verify) try {
                    debug('verify body');
                    verify(req, res, body, encoding);
                } catch (err) {
                    next(createError(403, err, {
                        body: body,
                        type: err.type || 'entity.verify.failed'
                    }));
                    return;
                }
                var str = body;
                try {
                    debug('parse body');
                    str = 'string' != typeof body && null !== encoding ? iconv.decode(body, encoding) : body;
                    req.body = parse(str);
                } catch (err) {
                    next(createError(400, err, {
                        body: str,
                        type: err.type || 'entity.parse.failed'
                    }));
                    return;
                }
                next();
            });
        }
        function contentstream(req, debug, inflate) {
            var encoding = (req.headers['content-encoding'] || 'identity').toLowerCase();
            var length = req.headers['content-length'];
            var stream;
            debug('content-encoding "%s"', encoding);
            if (false === inflate && 'identity' !== encoding) throw createError(415, 'content encoding unsupported', {
                encoding: encoding,
                type: 'encoding.unsupported'
            });
            switch(encoding){
                case 'deflate':
                    stream = zlib.createInflate();
                    debug('inflate body');
                    req.pipe(stream);
                    break;
                case 'gzip':
                    stream = zlib.createGunzip();
                    debug('gunzip body');
                    req.pipe(stream);
                    break;
                case 'identity':
                    stream = req;
                    stream.length = length;
                    break;
                default:
                    throw createError(415, 'unsupported content encoding "' + encoding + '"', {
                        encoding: encoding,
                        type: 'encoding.unsupported'
                    });
            }
            return stream;
        }
        function dump(req, callback) {
            if (onFinished.isFinished(req)) callback(null);
            else {
                onFinished(req, callback);
                req.resume();
            }
        }
    },
    "../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/json.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var bytes = __webpack_require__("../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js");
        var contentType = __webpack_require__("../node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js");
        var createError = __webpack_require__("../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js");
        var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('body-parser:json');
        var read = __webpack_require__("../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/read.js");
        var typeis = __webpack_require__("../node_modules/.pnpm/type-is@1.6.18/node_modules/type-is/index.js");
        module.exports = json;
        var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
        var JSON_SYNTAX_CHAR = '#';
        var JSON_SYNTAX_REGEXP = /#+/g;
        function json(options) {
            var opts = options || {};
            var limit = 'number' != typeof opts.limit ? bytes.parse(opts.limit || '100kb') : opts.limit;
            var inflate = false !== opts.inflate;
            var reviver = opts.reviver;
            var strict = false !== opts.strict;
            var type = opts.type || 'application/json';
            var verify = opts.verify || false;
            if (false !== verify && 'function' != typeof verify) throw new TypeError('option verify must be function');
            var shouldParse = 'function' != typeof type ? typeChecker(type) : type;
            function parse(body) {
                if (0 === body.length) return {};
                if (strict) {
                    var first = firstchar(body);
                    if ('{' !== first && '[' !== first) {
                        debug('strict violation');
                        throw createStrictSyntaxError(body, first);
                    }
                }
                try {
                    debug('parse json');
                    return JSON.parse(body, reviver);
                } catch (e) {
                    throw normalizeJsonSyntaxError(e, {
                        message: e.message,
                        stack: e.stack
                    });
                }
            }
            return function(req, res, next) {
                if (req._body) {
                    debug('body already parsed');
                    next();
                    return;
                }
                req.body = req.body || {};
                if (!typeis.hasBody(req)) {
                    debug('skip empty body');
                    next();
                    return;
                }
                debug('content-type %j', req.headers['content-type']);
                if (!shouldParse(req)) {
                    debug('skip parsing');
                    next();
                    return;
                }
                var charset = getCharset(req) || 'utf-8';
                if ('utf-' !== charset.slice(0, 4)) {
                    debug('invalid charset');
                    next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
                        charset: charset,
                        type: 'charset.unsupported'
                    }));
                    return;
                }
                read(req, res, next, parse, debug, {
                    encoding: charset,
                    inflate: inflate,
                    limit: limit,
                    verify: verify
                });
            };
        }
        function createStrictSyntaxError(str, char) {
            var index = str.indexOf(char);
            var partial = '';
            if (-1 !== index) {
                partial = str.substring(0, index) + JSON_SYNTAX_CHAR;
                for(var i = index + 1; i < str.length; i++)partial += JSON_SYNTAX_CHAR;
            }
            try {
                JSON.parse(partial);
                throw new SyntaxError('strict violation');
            } catch (e) {
                return normalizeJsonSyntaxError(e, {
                    message: e.message.replace(JSON_SYNTAX_REGEXP, function(placeholder) {
                        return str.substring(index, index + placeholder.length);
                    }),
                    stack: e.stack
                });
            }
        }
        function firstchar(str) {
            var match = FIRST_CHAR_REGEXP.exec(str);
            return match ? match[1] : void 0;
        }
        function getCharset(req) {
            try {
                return (contentType.parse(req).parameters.charset || '').toLowerCase();
            } catch (e) {
                return;
            }
        }
        function normalizeJsonSyntaxError(error, obj) {
            var keys = Object.getOwnPropertyNames(error);
            for(var i = 0; i < keys.length; i++){
                var key = keys[i];
                if ('stack' !== key && 'message' !== key) delete error[key];
            }
            error.stack = obj.stack.replace(error.message, obj.message);
            error.message = obj.message;
            return error;
        }
        function typeChecker(type) {
            return function(req) {
                return Boolean(typeis(req, type));
            };
        }
    },
    "../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/raw.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var bytes = __webpack_require__("../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js");
        var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('body-parser:raw');
        var read = __webpack_require__("../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/read.js");
        var typeis = __webpack_require__("../node_modules/.pnpm/type-is@1.6.18/node_modules/type-is/index.js");
        module.exports = raw;
        function raw(options) {
            var opts = options || {};
            var inflate = false !== opts.inflate;
            var limit = 'number' != typeof opts.limit ? bytes.parse(opts.limit || '100kb') : opts.limit;
            var type = opts.type || 'application/octet-stream';
            var verify = opts.verify || false;
            if (false !== verify && 'function' != typeof verify) throw new TypeError('option verify must be function');
            var shouldParse = 'function' != typeof type ? typeChecker(type) : type;
            function parse(buf) {
                return buf;
            }
            return function(req, res, next) {
                if (req._body) {
                    debug('body already parsed');
                    next();
                    return;
                }
                req.body = req.body || {};
                if (!typeis.hasBody(req)) {
                    debug('skip empty body');
                    next();
                    return;
                }
                debug('content-type %j', req.headers['content-type']);
                if (!shouldParse(req)) {
                    debug('skip parsing');
                    next();
                    return;
                }
                read(req, res, next, parse, debug, {
                    encoding: null,
                    inflate: inflate,
                    limit: limit,
                    verify: verify
                });
            };
        }
        function typeChecker(type) {
            return function(req) {
                return Boolean(typeis(req, type));
            };
        }
    },
    "../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/text.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var bytes = __webpack_require__("../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js");
        var contentType = __webpack_require__("../node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js");
        var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('body-parser:text');
        var read = __webpack_require__("../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/read.js");
        var typeis = __webpack_require__("../node_modules/.pnpm/type-is@1.6.18/node_modules/type-is/index.js");
        module.exports = text;
        function text(options) {
            var opts = options || {};
            var defaultCharset = opts.defaultCharset || 'utf-8';
            var inflate = false !== opts.inflate;
            var limit = 'number' != typeof opts.limit ? bytes.parse(opts.limit || '100kb') : opts.limit;
            var type = opts.type || 'text/plain';
            var verify = opts.verify || false;
            if (false !== verify && 'function' != typeof verify) throw new TypeError('option verify must be function');
            var shouldParse = 'function' != typeof type ? typeChecker(type) : type;
            function parse(buf) {
                return buf;
            }
            return function(req, res, next) {
                if (req._body) {
                    debug('body already parsed');
                    next();
                    return;
                }
                req.body = req.body || {};
                if (!typeis.hasBody(req)) {
                    debug('skip empty body');
                    next();
                    return;
                }
                debug('content-type %j', req.headers['content-type']);
                if (!shouldParse(req)) {
                    debug('skip parsing');
                    next();
                    return;
                }
                var charset = getCharset(req) || defaultCharset;
                read(req, res, next, parse, debug, {
                    encoding: charset,
                    inflate: inflate,
                    limit: limit,
                    verify: verify
                });
            };
        }
        function getCharset(req) {
            try {
                return (contentType.parse(req).parameters.charset || '').toLowerCase();
            } catch (e) {
                return;
            }
        }
        function typeChecker(type) {
            return function(req) {
                return Boolean(typeis(req, type));
            };
        }
    },
    "../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/urlencoded.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var bytes = __webpack_require__("../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js");
        var contentType = __webpack_require__("../node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js");
        var createError = __webpack_require__("../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js");
        var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('body-parser:urlencoded');
        var deprecate = __webpack_require__("../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('body-parser');
        var read = __webpack_require__("../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/read.js");
        var typeis = __webpack_require__("../node_modules/.pnpm/type-is@1.6.18/node_modules/type-is/index.js");
        module.exports = urlencoded;
        var parsers = Object.create(null);
        function urlencoded(options) {
            var opts = options || {};
            if (void 0 === opts.extended) deprecate('undefined extended: provide extended option');
            var extended = false !== opts.extended;
            var inflate = false !== opts.inflate;
            var limit = 'number' != typeof opts.limit ? bytes.parse(opts.limit || '100kb') : opts.limit;
            var type = opts.type || 'application/x-www-form-urlencoded';
            var verify = opts.verify || false;
            var depth = 'number' != typeof opts.depth ? Number(opts.depth || 32) : opts.depth;
            if (false !== verify && 'function' != typeof verify) throw new TypeError('option verify must be function');
            var queryparse = extended ? extendedparser(opts) : simpleparser(opts);
            var shouldParse = 'function' != typeof type ? typeChecker(type) : type;
            function parse(body) {
                return body.length ? queryparse(body) : {};
            }
            return function(req, res, next) {
                if (req._body) {
                    debug('body already parsed');
                    next();
                    return;
                }
                req.body = req.body || {};
                if (!typeis.hasBody(req)) {
                    debug('skip empty body');
                    next();
                    return;
                }
                debug('content-type %j', req.headers['content-type']);
                if (!shouldParse(req)) {
                    debug('skip parsing');
                    next();
                    return;
                }
                var charset = getCharset(req) || 'utf-8';
                if ('utf-8' !== charset) {
                    debug('invalid charset');
                    next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
                        charset: charset,
                        type: 'charset.unsupported'
                    }));
                    return;
                }
                read(req, res, next, parse, debug, {
                    debug: debug,
                    encoding: charset,
                    inflate: inflate,
                    limit: limit,
                    verify: verify,
                    depth: depth
                });
            };
        }
        function extendedparser(options) {
            var parameterLimit = void 0 !== options.parameterLimit ? options.parameterLimit : 1000;
            var depth = 'number' != typeof options.depth ? Number(options.depth || 32) : options.depth;
            var parse = parser('qs');
            if (isNaN(parameterLimit) || parameterLimit < 1) throw new TypeError('option parameterLimit must be a positive number');
            if (isNaN(depth) || depth < 0) throw new TypeError('option depth must be a zero or a positive number');
            if (isFinite(parameterLimit)) parameterLimit |= 0;
            return function(body) {
                var paramCount = parameterCount(body, parameterLimit);
                if (void 0 === paramCount) {
                    debug('too many parameters');
                    throw createError(413, 'too many parameters', {
                        type: 'parameters.too.many'
                    });
                }
                var arrayLimit = Math.max(100, paramCount);
                debug('parse extended urlencoding');
                try {
                    return parse(body, {
                        allowPrototypes: true,
                        arrayLimit: arrayLimit,
                        depth: depth,
                        strictDepth: true,
                        parameterLimit: parameterLimit
                    });
                } catch (err) {
                    if (err instanceof RangeError) throw createError(400, 'The input exceeded the depth', {
                        type: 'querystring.parse.rangeError'
                    });
                    throw err;
                }
            };
        }
        function getCharset(req) {
            try {
                return (contentType.parse(req).parameters.charset || '').toLowerCase();
            } catch (e) {
                return;
            }
        }
        function parameterCount(body, limit) {
            var count = 0;
            var index = 0;
            while(-1 !== (index = body.indexOf('&', index))){
                count++;
                index++;
                if (count === limit) return;
            }
            return count;
        }
        function parser(name) {
            var mod = parsers[name];
            if (void 0 !== mod) return mod.parse;
            switch(name){
                case 'qs':
                    mod = __webpack_require__("../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/index.js");
                    break;
                case 'querystring':
                    mod = __webpack_require__("querystring");
                    break;
            }
            parsers[name] = mod;
            return mod.parse;
        }
        function simpleparser(options) {
            var parameterLimit = void 0 !== options.parameterLimit ? options.parameterLimit : 1000;
            var parse = parser('querystring');
            if (isNaN(parameterLimit) || parameterLimit < 1) throw new TypeError('option parameterLimit must be a positive number');
            if (isFinite(parameterLimit)) parameterLimit |= 0;
            return function(body) {
                var paramCount = parameterCount(body, parameterLimit);
                if (void 0 === paramCount) {
                    debug('too many parameters');
                    throw createError(413, 'too many parameters', {
                        type: 'parameters.too.many'
                    });
                }
                debug('parse urlencoding');
                return parse(body, void 0, void 0, {
                    maxKeys: parameterLimit
                });
            };
        }
        function typeChecker(type) {
            return function(req) {
                return Boolean(typeis(req, type));
            };
        }
    },
    "../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js": function(module) {
        "use strict";
        /*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */ module.exports = bytes;
        module.exports.format = format;
        module.exports.parse = parse;
        var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
        var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
        var map = {
            b: 1,
            kb: 1024,
            mb: 1048576,
            gb: 1073741824,
            tb: Math.pow(1024, 4),
            pb: Math.pow(1024, 5)
        };
        var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
        function bytes(value, options) {
            if ('string' == typeof value) return parse(value);
            if ('number' == typeof value) return format(value, options);
            return null;
        }
        function format(value, options) {
            if (!Number.isFinite(value)) return null;
            var mag = Math.abs(value);
            var thousandsSeparator = options && options.thousandsSeparator || '';
            var unitSeparator = options && options.unitSeparator || '';
            var decimalPlaces = options && void 0 !== options.decimalPlaces ? options.decimalPlaces : 2;
            var fixedDecimals = Boolean(options && options.fixedDecimals);
            var unit = options && options.unit || '';
            if (!unit || !map[unit.toLowerCase()]) unit = mag >= map.pb ? 'PB' : mag >= map.tb ? 'TB' : mag >= map.gb ? 'GB' : mag >= map.mb ? 'MB' : mag >= map.kb ? 'KB' : 'B';
            var val = value / map[unit.toLowerCase()];
            var str = val.toFixed(decimalPlaces);
            if (!fixedDecimals) str = str.replace(formatDecimalsRegExp, '$1');
            if (thousandsSeparator) str = str.split('.').map(function(s, i) {
                return 0 === i ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
            }).join('.');
            return str + unitSeparator + unit;
        }
        function parse(val) {
            if ('number' == typeof val && !isNaN(val)) return val;
            if ('string' != typeof val) return null;
            var results = parseRegExp.exec(val);
            var floatValue;
            var unit = 'b';
            if (results) {
                floatValue = parseFloat(results[1]);
                unit = results[4].toLowerCase();
            } else {
                floatValue = parseInt(val, 10);
                unit = 'b';
            }
            if (isNaN(floatValue)) return null;
            return Math.floor(map[unit] * floatValue);
        }
    },
    "../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var bind = __webpack_require__("../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
        var $apply = __webpack_require__("../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js");
        var $call = __webpack_require__("../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js");
        var $reflectApply = __webpack_require__("../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js");
        module.exports = $reflectApply || bind.call($call, $apply);
    },
    "../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js": function(module) {
        "use strict";
        module.exports = Function.prototype.apply;
    },
    "../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js": function(module) {
        "use strict";
        module.exports = Function.prototype.call;
    },
    "../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var bind = __webpack_require__("../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
        var $TypeError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
        var $call = __webpack_require__("../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js");
        var $actualApply = __webpack_require__("../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js");
        module.exports = function(args) {
            if (args.length < 1 || 'function' != typeof args[0]) throw new $TypeError('a function is required');
            return $actualApply(bind, $call, args);
        };
    },
    "../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js": function(module) {
        "use strict";
        module.exports = 'undefined' != typeof Reflect && Reflect && Reflect.apply;
    },
    "../node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var GetIntrinsic = __webpack_require__("../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js");
        var callBindBasic = __webpack_require__("../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js");
        var $indexOf = callBindBasic([
            GetIntrinsic('%String.prototype.indexOf%')
        ]);
        module.exports = function(name, allowMissing) {
            var intrinsic = GetIntrinsic(name, !!allowMissing);
            if ('function' == typeof intrinsic && $indexOf(name, '.prototype.') > -1) return callBindBasic([
                intrinsic
            ]);
            return intrinsic;
        };
    },
    "../node_modules/.pnpm/content-disposition@0.5.4/node_modules/content-disposition/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = contentDisposition;
        module.exports.parse = parse;
        var basename = __webpack_require__("path").basename;
        var Buffer1 = __webpack_require__("../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer;
        var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
        var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
        var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
        var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
        var QESC_REGEXP = /\\([\u0000-\u007f])/g;
        var QUOTE_REGEXP = /([\\"])/g;
        var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
        var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
        var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
        var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
        var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
        function contentDisposition(filename, options) {
            var opts = options || {};
            var type = opts.type || 'attachment';
            var params = createparams(filename, opts.fallback);
            return format(new ContentDisposition(type, params));
        }
        function createparams(filename, fallback) {
            if (void 0 === filename) return;
            var params = {};
            if ('string' != typeof filename) throw new TypeError('filename must be a string');
            if (void 0 === fallback) fallback = true;
            if ('string' != typeof fallback && 'boolean' != typeof fallback) throw new TypeError('fallback must be a string or boolean');
            if ('string' == typeof fallback && NON_LATIN1_REGEXP.test(fallback)) throw new TypeError('fallback must be ISO-8859-1 string');
            var name = basename(filename);
            var isQuotedString = TEXT_REGEXP.test(name);
            var fallbackName = 'string' != typeof fallback ? fallback && getlatin1(name) : basename(fallback);
            var hasFallback = 'string' == typeof fallbackName && fallbackName !== name;
            if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) params['filename*'] = name;
            if (isQuotedString || hasFallback) params.filename = hasFallback ? fallbackName : name;
            return params;
        }
        function format(obj) {
            var parameters = obj.parameters;
            var type = obj.type;
            if (!type || 'string' != typeof type || !TOKEN_REGEXP.test(type)) throw new TypeError('invalid type');
            var string = String(type).toLowerCase();
            if (parameters && 'object' == typeof parameters) {
                var param;
                var params = Object.keys(parameters).sort();
                for(var i = 0; i < params.length; i++){
                    param = params[i];
                    var val = '*' === param.substr(-1) ? ustring(parameters[param]) : qstring(parameters[param]);
                    string += '; ' + param + '=' + val;
                }
            }
            return string;
        }
        function decodefield(str) {
            var match = EXT_VALUE_REGEXP.exec(str);
            if (!match) throw new TypeError('invalid extended field value');
            var charset = match[1].toLowerCase();
            var encoded = match[2];
            var value;
            var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
            switch(charset){
                case 'iso-8859-1':
                    value = getlatin1(binary);
                    break;
                case 'utf-8':
                    value = Buffer1.from(binary, 'binary').toString('utf8');
                    break;
                default:
                    throw new TypeError('unsupported charset in extended field');
            }
            return value;
        }
        function getlatin1(val) {
            return String(val).replace(NON_LATIN1_REGEXP, '?');
        }
        function parse(string) {
            if (!string || 'string' != typeof string) throw new TypeError('argument string is required');
            var match = DISPOSITION_TYPE_REGEXP.exec(string);
            if (!match) throw new TypeError('invalid type format');
            var index = match[0].length;
            var type = match[1].toLowerCase();
            var key;
            var names = [];
            var params = {};
            var value;
            index = PARAM_REGEXP.lastIndex = ';' === match[0].substr(-1) ? index - 1 : index;
            while(match = PARAM_REGEXP.exec(string)){
                if (match.index !== index) throw new TypeError('invalid parameter format');
                index += match[0].length;
                key = match[1].toLowerCase();
                value = match[2];
                if (-1 !== names.indexOf(key)) throw new TypeError('invalid duplicate parameter');
                names.push(key);
                if (key.indexOf('*') + 1 === key.length) {
                    key = key.slice(0, -1);
                    value = decodefield(value);
                    params[key] = value;
                    continue;
                }
                if ('string' == typeof params[key]) continue;
                if ('"' === value[0]) value = value.substr(1, value.length - 2).replace(QESC_REGEXP, '$1');
                params[key] = value;
            }
            if (-1 !== index && index !== string.length) throw new TypeError('invalid parameter format');
            return new ContentDisposition(type, params);
        }
        function pdecode(str, hex) {
            return String.fromCharCode(parseInt(hex, 16));
        }
        function pencode(char) {
            return '%' + String(char).charCodeAt(0).toString(16).toUpperCase();
        }
        function qstring(val) {
            var str = String(val);
            return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"';
        }
        function ustring(val) {
            var str = String(val);
            var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
            return 'UTF-8\'\'' + encoded;
        }
        function ContentDisposition(type, parameters) {
            this.type = type;
            this.parameters = parameters;
        }
    },
    "../node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js": function(__unused_webpack_module, exports1) {
        "use strict";
        /*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
        var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
        var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
        var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
        var QUOTE_REGEXP = /([\\"])/g;
        var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
        exports1.format = format;
        exports1.parse = parse;
        function format(obj) {
            if (!obj || 'object' != typeof obj) throw new TypeError('argument obj is required');
            var parameters = obj.parameters;
            var type = obj.type;
            if (!type || !TYPE_REGEXP.test(type)) throw new TypeError('invalid type');
            var string = type;
            if (parameters && 'object' == typeof parameters) {
                var param;
                var params = Object.keys(parameters).sort();
                for(var i = 0; i < params.length; i++){
                    param = params[i];
                    if (!TOKEN_REGEXP.test(param)) throw new TypeError('invalid parameter name');
                    string += '; ' + param + '=' + qstring(parameters[param]);
                }
            }
            return string;
        }
        function parse(string) {
            if (!string) throw new TypeError('argument string is required');
            var header = 'object' == typeof string ? getcontenttype(string) : string;
            if ('string' != typeof header) throw new TypeError('argument string is required to be a string');
            var index = header.indexOf(';');
            var type = -1 !== index ? header.slice(0, index).trim() : header.trim();
            if (!TYPE_REGEXP.test(type)) throw new TypeError('invalid media type');
            var obj = new ContentType(type.toLowerCase());
            if (-1 !== index) {
                var key;
                var match;
                var value;
                PARAM_REGEXP.lastIndex = index;
                while(match = PARAM_REGEXP.exec(header)){
                    if (match.index !== index) throw new TypeError('invalid parameter format');
                    index += match[0].length;
                    key = match[1].toLowerCase();
                    value = match[2];
                    if (0x22 === value.charCodeAt(0)) {
                        value = value.slice(1, -1);
                        if (-1 !== value.indexOf('\\')) value = value.replace(QESC_REGEXP, '$1');
                    }
                    obj.parameters[key] = value;
                }
                if (index !== header.length) throw new TypeError('invalid parameter format');
            }
            return obj;
        }
        function getcontenttype(obj) {
            var header;
            if ('function' == typeof obj.getHeader) header = obj.getHeader('content-type');
            else if ('object' == typeof obj.headers) header = obj.headers && obj.headers['content-type'];
            if ('string' != typeof header) throw new TypeError('content-type header is missing from object');
            return header;
        }
        function qstring(val) {
            var str = String(val);
            if (TOKEN_REGEXP.test(str)) return str;
            if (str.length > 0 && !TEXT_REGEXP.test(str)) throw new TypeError('invalid parameter value');
            return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"';
        }
        function ContentType(type) {
            this.parameters = Object.create(null);
            this.type = type;
        }
    },
    "../node_modules/.pnpm/cookie-signature@1.0.6/node_modules/cookie-signature/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        var crypto = __webpack_require__("crypto");
        exports1.sign = function(val, secret) {
            if ('string' != typeof val) throw new TypeError("Cookie value must be provided as a string.");
            if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
            return val + '.' + crypto.createHmac('sha256', secret).update(val).digest('base64').replace(/\=+$/, '');
        };
        exports1.unsign = function(val, secret) {
            if ('string' != typeof val) throw new TypeError("Signed cookie string must be provided.");
            if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
            var str = val.slice(0, val.lastIndexOf('.')), mac = exports1.sign(str, secret);
            return sha1(mac) == sha1(val) ? str : false;
        };
        function sha1(str) {
            return crypto.createHash('sha1').update(str).digest('hex');
        }
    },
    "../node_modules/.pnpm/cookie@0.7.1/node_modules/cookie/index.js": function(__unused_webpack_module, exports1) {
        "use strict";
        /*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ exports1.parse = parse;
        exports1.serialize = serialize;
        var __toString = Object.prototype.toString;
        var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
        var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;
        var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
        var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
        function parse(str, opt) {
            if ('string' != typeof str) throw new TypeError('argument str must be a string');
            var obj = {};
            var len = str.length;
            if (len < 2) return obj;
            var dec = opt && opt.decode || decode;
            var index = 0;
            var eqIdx = 0;
            var endIdx = 0;
            do {
                eqIdx = str.indexOf('=', index);
                if (-1 === eqIdx) break;
                endIdx = str.indexOf(';', index);
                if (-1 === endIdx) endIdx = len;
                else if (eqIdx > endIdx) {
                    index = str.lastIndexOf(';', eqIdx - 1) + 1;
                    continue;
                }
                var keyStartIdx = startIndex(str, index, eqIdx);
                var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
                var key = str.slice(keyStartIdx, keyEndIdx);
                if (!obj.hasOwnProperty(key)) {
                    var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
                    var valEndIdx = endIndex(str, endIdx, valStartIdx);
                    if (0x22 === str.charCodeAt(valStartIdx) && 0x22 === str.charCodeAt(valEndIdx - 1)) {
                        valStartIdx++;
                        valEndIdx--;
                    }
                    var val = str.slice(valStartIdx, valEndIdx);
                    obj[key] = tryDecode(val, dec);
                }
                index = endIdx + 1;
            }while (index < len);
            return obj;
        }
        function startIndex(str, index, max) {
            do {
                var code = str.charCodeAt(index);
                if (0x20 !== code && 0x09 !== code) return index;
            }while (++index < max);
            return max;
        }
        function endIndex(str, index, min) {
            while(index > min){
                var code = str.charCodeAt(--index);
                if (0x20 !== code && 0x09 !== code) return index + 1;
            }
            return min;
        }
        function serialize(name, val, opt) {
            var enc = opt && opt.encode || encodeURIComponent;
            if ('function' != typeof enc) throw new TypeError('option encode is invalid');
            if (!cookieNameRegExp.test(name)) throw new TypeError('argument name is invalid');
            var value = enc(val);
            if (!cookieValueRegExp.test(value)) throw new TypeError('argument val is invalid');
            var str = name + '=' + value;
            if (!opt) return str;
            if (null != opt.maxAge) {
                var maxAge = Math.floor(opt.maxAge);
                if (!isFinite(maxAge)) throw new TypeError('option maxAge is invalid');
                str += '; Max-Age=' + maxAge;
            }
            if (opt.domain) {
                if (!domainValueRegExp.test(opt.domain)) throw new TypeError('option domain is invalid');
                str += '; Domain=' + opt.domain;
            }
            if (opt.path) {
                if (!pathValueRegExp.test(opt.path)) throw new TypeError('option path is invalid');
                str += '; Path=' + opt.path;
            }
            if (opt.expires) {
                var expires = opt.expires;
                if (!isDate(expires) || isNaN(expires.valueOf())) throw new TypeError('option expires is invalid');
                str += '; Expires=' + expires.toUTCString();
            }
            if (opt.httpOnly) str += '; HttpOnly';
            if (opt.secure) str += '; Secure';
            if (opt.partitioned) str += '; Partitioned';
            if (opt.priority) {
                var priority = 'string' == typeof opt.priority ? opt.priority.toLowerCase() : opt.priority;
                switch(priority){
                    case 'low':
                        str += '; Priority=Low';
                        break;
                    case 'medium':
                        str += '; Priority=Medium';
                        break;
                    case 'high':
                        str += '; Priority=High';
                        break;
                    default:
                        throw new TypeError('option priority is invalid');
                }
            }
            if (opt.sameSite) {
                var sameSite = 'string' == typeof opt.sameSite ? opt.sameSite.toLowerCase() : opt.sameSite;
                switch(sameSite){
                    case true:
                        str += '; SameSite=Strict';
                        break;
                    case 'lax':
                        str += '; SameSite=Lax';
                        break;
                    case 'strict':
                        str += '; SameSite=Strict';
                        break;
                    case 'none':
                        str += '; SameSite=None';
                        break;
                    default:
                        throw new TypeError('option sameSite is invalid');
                }
            }
            return str;
        }
        function decode(str) {
            return -1 !== str.indexOf('%') ? decodeURIComponent(str) : str;
        }
        function isDate(val) {
            return '[object Date]' === __toString.call(val);
        }
        function tryDecode(str, decode) {
            try {
                return decode(str);
            } catch (e) {
                return str;
            }
        }
    },
    "../node_modules/.pnpm/cookie@0.7.2/node_modules/cookie/index.js": function(__unused_webpack_module, exports1) {
        "use strict";
        /*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ exports1.parse = parse;
        exports1.serialize = serialize;
        var __toString = Object.prototype.toString;
        var __hasOwnProperty = Object.prototype.hasOwnProperty;
        var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
        var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;
        var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
        var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
        function parse(str, opt) {
            if ('string' != typeof str) throw new TypeError('argument str must be a string');
            var obj = {};
            var len = str.length;
            if (len < 2) return obj;
            var dec = opt && opt.decode || decode;
            var index = 0;
            var eqIdx = 0;
            var endIdx = 0;
            do {
                eqIdx = str.indexOf('=', index);
                if (-1 === eqIdx) break;
                endIdx = str.indexOf(';', index);
                if (-1 === endIdx) endIdx = len;
                else if (eqIdx > endIdx) {
                    index = str.lastIndexOf(';', eqIdx - 1) + 1;
                    continue;
                }
                var keyStartIdx = startIndex(str, index, eqIdx);
                var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
                var key = str.slice(keyStartIdx, keyEndIdx);
                if (!__hasOwnProperty.call(obj, key)) {
                    var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
                    var valEndIdx = endIndex(str, endIdx, valStartIdx);
                    if (0x22 === str.charCodeAt(valStartIdx) && 0x22 === str.charCodeAt(valEndIdx - 1)) {
                        valStartIdx++;
                        valEndIdx--;
                    }
                    var val = str.slice(valStartIdx, valEndIdx);
                    obj[key] = tryDecode(val, dec);
                }
                index = endIdx + 1;
            }while (index < len);
            return obj;
        }
        function startIndex(str, index, max) {
            do {
                var code = str.charCodeAt(index);
                if (0x20 !== code && 0x09 !== code) return index;
            }while (++index < max);
            return max;
        }
        function endIndex(str, index, min) {
            while(index > min){
                var code = str.charCodeAt(--index);
                if (0x20 !== code && 0x09 !== code) return index + 1;
            }
            return min;
        }
        function serialize(name, val, opt) {
            var enc = opt && opt.encode || encodeURIComponent;
            if ('function' != typeof enc) throw new TypeError('option encode is invalid');
            if (!cookieNameRegExp.test(name)) throw new TypeError('argument name is invalid');
            var value = enc(val);
            if (!cookieValueRegExp.test(value)) throw new TypeError('argument val is invalid');
            var str = name + '=' + value;
            if (!opt) return str;
            if (null != opt.maxAge) {
                var maxAge = Math.floor(opt.maxAge);
                if (!isFinite(maxAge)) throw new TypeError('option maxAge is invalid');
                str += '; Max-Age=' + maxAge;
            }
            if (opt.domain) {
                if (!domainValueRegExp.test(opt.domain)) throw new TypeError('option domain is invalid');
                str += '; Domain=' + opt.domain;
            }
            if (opt.path) {
                if (!pathValueRegExp.test(opt.path)) throw new TypeError('option path is invalid');
                str += '; Path=' + opt.path;
            }
            if (opt.expires) {
                var expires = opt.expires;
                if (!isDate(expires) || isNaN(expires.valueOf())) throw new TypeError('option expires is invalid');
                str += '; Expires=' + expires.toUTCString();
            }
            if (opt.httpOnly) str += '; HttpOnly';
            if (opt.secure) str += '; Secure';
            if (opt.partitioned) str += '; Partitioned';
            if (opt.priority) {
                var priority = 'string' == typeof opt.priority ? opt.priority.toLowerCase() : opt.priority;
                switch(priority){
                    case 'low':
                        str += '; Priority=Low';
                        break;
                    case 'medium':
                        str += '; Priority=Medium';
                        break;
                    case 'high':
                        str += '; Priority=High';
                        break;
                    default:
                        throw new TypeError('option priority is invalid');
                }
            }
            if (opt.sameSite) {
                var sameSite = 'string' == typeof opt.sameSite ? opt.sameSite.toLowerCase() : opt.sameSite;
                switch(sameSite){
                    case true:
                        str += '; SameSite=Strict';
                        break;
                    case 'lax':
                        str += '; SameSite=Lax';
                        break;
                    case 'strict':
                        str += '; SameSite=Strict';
                        break;
                    case 'none':
                        str += '; SameSite=None';
                        break;
                    default:
                        throw new TypeError('option sameSite is invalid');
                }
            }
            return str;
        }
        function decode(str) {
            return -1 !== str.indexOf('%') ? decodeURIComponent(str) : str;
        }
        function isDate(val) {
            return '[object Date]' === __toString.call(val);
        }
        function tryDecode(str, decode) {
            try {
                return decode(str);
            } catch (e) {
                return str;
            }
        }
    },
    "../node_modules/.pnpm/cors@2.8.5/node_modules/cors/lib/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        (function() {
            'use strict';
            var assign = __webpack_require__("../node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js");
            var vary = __webpack_require__("../node_modules/.pnpm/vary@1.1.2/node_modules/vary/index.js");
            var defaults = {
                origin: '*',
                methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
                preflightContinue: false,
                optionsSuccessStatus: 204
            };
            function isString(s) {
                return 'string' == typeof s || s instanceof String;
            }
            function isOriginAllowed(origin, allowedOrigin) {
                if (Array.isArray(allowedOrigin)) {
                    for(var i = 0; i < allowedOrigin.length; ++i)if (isOriginAllowed(origin, allowedOrigin[i])) return true;
                    return false;
                }
                if (isString(allowedOrigin)) return origin === allowedOrigin;
                if (allowedOrigin instanceof RegExp) return allowedOrigin.test(origin);
                return !!allowedOrigin;
            }
            function configureOrigin(options, req) {
                var requestOrigin = req.headers.origin, headers = [], isAllowed;
                if (options.origin && '*' !== options.origin) if (isString(options.origin)) {
                    headers.push([
                        {
                            key: 'Access-Control-Allow-Origin',
                            value: options.origin
                        }
                    ]);
                    headers.push([
                        {
                            key: 'Vary',
                            value: 'Origin'
                        }
                    ]);
                } else {
                    isAllowed = isOriginAllowed(requestOrigin, options.origin);
                    headers.push([
                        {
                            key: 'Access-Control-Allow-Origin',
                            value: isAllowed ? requestOrigin : false
                        }
                    ]);
                    headers.push([
                        {
                            key: 'Vary',
                            value: 'Origin'
                        }
                    ]);
                }
                else headers.push([
                    {
                        key: 'Access-Control-Allow-Origin',
                        value: '*'
                    }
                ]);
                return headers;
            }
            function configureMethods(options) {
                var methods = options.methods;
                if (methods.join) methods = options.methods.join(',');
                return {
                    key: 'Access-Control-Allow-Methods',
                    value: methods
                };
            }
            function configureCredentials(options) {
                if (true === options.credentials) return {
                    key: 'Access-Control-Allow-Credentials',
                    value: 'true'
                };
                return null;
            }
            function configureAllowedHeaders(options, req) {
                var allowedHeaders = options.allowedHeaders || options.headers;
                var headers = [];
                if (allowedHeaders) {
                    if (allowedHeaders.join) allowedHeaders = allowedHeaders.join(',');
                } else {
                    allowedHeaders = req.headers['access-control-request-headers'];
                    headers.push([
                        {
                            key: 'Vary',
                            value: 'Access-Control-Request-Headers'
                        }
                    ]);
                }
                if (allowedHeaders && allowedHeaders.length) headers.push([
                    {
                        key: 'Access-Control-Allow-Headers',
                        value: allowedHeaders
                    }
                ]);
                return headers;
            }
            function configureExposedHeaders(options) {
                var headers = options.exposedHeaders;
                if (!headers) return null;
                if (headers.join) headers = headers.join(',');
                if (headers && headers.length) return {
                    key: 'Access-Control-Expose-Headers',
                    value: headers
                };
                return null;
            }
            function configureMaxAge(options) {
                var maxAge = ('number' == typeof options.maxAge || options.maxAge) && options.maxAge.toString();
                if (maxAge && maxAge.length) return {
                    key: 'Access-Control-Max-Age',
                    value: maxAge
                };
                return null;
            }
            function applyHeaders(headers, res) {
                for(var i = 0, n = headers.length; i < n; i++){
                    var header = headers[i];
                    if (header) {
                        if (Array.isArray(header)) applyHeaders(header, res);
                        else if ('Vary' === header.key && header.value) vary(res, header.value);
                        else if (header.value) res.setHeader(header.key, header.value);
                    }
                }
            }
            function cors(options, req, res, next) {
                var headers = [], method = req.method && req.method.toUpperCase && req.method.toUpperCase();
                if ('OPTIONS' === method) {
                    headers.push(configureOrigin(options, req));
                    headers.push(configureCredentials(options, req));
                    headers.push(configureMethods(options, req));
                    headers.push(configureAllowedHeaders(options, req));
                    headers.push(configureMaxAge(options, req));
                    headers.push(configureExposedHeaders(options, req));
                    applyHeaders(headers, res);
                    if (options.preflightContinue) next();
                    else {
                        res.statusCode = options.optionsSuccessStatus;
                        res.setHeader('Content-Length', '0');
                        res.end();
                    }
                } else {
                    headers.push(configureOrigin(options, req));
                    headers.push(configureCredentials(options, req));
                    headers.push(configureExposedHeaders(options, req));
                    applyHeaders(headers, res);
                    next();
                }
            }
            function middlewareWrapper(o) {
                var optionsCallback = null;
                optionsCallback = 'function' == typeof o ? o : function(req, cb) {
                    cb(null, o);
                };
                return function(req, res, next) {
                    optionsCallback(req, function(err, options) {
                        if (err) next(err);
                        else {
                            var corsOptions = assign({}, defaults, options);
                            var originCallback = null;
                            if (corsOptions.origin && 'function' == typeof corsOptions.origin) originCallback = corsOptions.origin;
                            else if (corsOptions.origin) originCallback = function(origin, cb) {
                                cb(null, corsOptions.origin);
                            };
                            if (originCallback) originCallback(req.headers.origin, function(err2, origin) {
                                if (err2 || !origin) next(err2);
                                else {
                                    corsOptions.origin = origin;
                                    cors(corsOptions, req, res, next);
                                }
                            });
                            else next();
                        }
                    });
                };
            }
            module.exports = middlewareWrapper;
        })();
    },
    "../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/browser.js": function(module, exports1, __webpack_require__) {
        exports1 = module.exports = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/debug.js");
        exports1.log = log;
        exports1.formatArgs = formatArgs;
        exports1.save = save;
        exports1.load = load;
        exports1.useColors = useColors;
        exports1.storage = 'undefined' != typeof chrome && void 0 !== chrome.storage ? chrome.storage.local : localstorage();
        exports1.colors = [
            'lightseagreen',
            'forestgreen',
            'goldenrod',
            'dodgerblue',
            'darkorchid',
            'crimson'
        ];
        function useColors() {
            if ('undefined' != typeof window && window.process && 'renderer' === window.process.type) return true;
            return 'undefined' != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || 'undefined' != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || 'undefined' != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || 'undefined' != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        exports1.formatters.j = function(v) {
            try {
                return JSON.stringify(v);
            } catch (err) {
                return '[UnexpectedJSONParseError]: ' + err.message;
            }
        };
        function formatArgs(args) {
            var useColors = this.useColors;
            args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports1.humanize(this.diff);
            if (!useColors) return;
            var c = 'color: ' + this.color;
            args.splice(1, 0, c, 'color: inherit');
            var index = 0;
            var lastC = 0;
            args[0].replace(/%[a-zA-Z%]/g, function(match) {
                if ('%%' === match) return;
                index++;
                if ('%c' === match) lastC = index;
            });
            args.splice(lastC, 0, c);
        }
        function log() {
            return 'object' == typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
        }
        function save(namespaces) {
            try {
                if (null == namespaces) exports1.storage.removeItem('debug');
                else exports1.storage.debug = namespaces;
            } catch (e) {}
        }
        function load() {
            var r;
            try {
                r = exports1.storage.debug;
            } catch (e) {}
            if (!r && 'undefined' != typeof process && 'env' in process) r = process.env.DEBUG;
            return r;
        }
        exports1.enable(load());
        function localstorage() {
            try {
                return window.localStorage;
            } catch (e) {}
        }
    },
    "../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/debug.js": function(module, exports1, __webpack_require__) {
        exports1 = module.exports = createDebug.debug = createDebug['default'] = createDebug;
        exports1.coerce = coerce;
        exports1.disable = disable;
        exports1.enable = enable;
        exports1.enabled = enabled;
        exports1.humanize = __webpack_require__("../node_modules/.pnpm/ms@2.0.0/node_modules/ms/index.js");
        exports1.names = [];
        exports1.skips = [];
        exports1.formatters = {};
        var prevTime;
        function selectColor(namespace) {
            var hash = 0, i;
            for(i in namespace){
                hash = (hash << 5) - hash + namespace.charCodeAt(i);
                hash |= 0;
            }
            return exports1.colors[Math.abs(hash) % exports1.colors.length];
        }
        function createDebug(namespace) {
            function debug() {
                if (!debug.enabled) return;
                var self = debug;
                var curr = +new Date();
                var ms = curr - (prevTime || curr);
                self.diff = ms;
                self.prev = prevTime;
                self.curr = curr;
                prevTime = curr;
                var args = new Array(arguments.length);
                for(var i = 0; i < args.length; i++)args[i] = arguments[i];
                args[0] = exports1.coerce(args[0]);
                if ('string' != typeof args[0]) args.unshift('%O');
                var index = 0;
                args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
                    if ('%%' === match) return match;
                    index++;
                    var formatter = exports1.formatters[format];
                    if ('function' == typeof formatter) {
                        var val = args[index];
                        match = formatter.call(self, val);
                        args.splice(index, 1);
                        index--;
                    }
                    return match;
                });
                exports1.formatArgs.call(self, args);
                var logFn = debug.log || exports1.log || console.log.bind(console);
                logFn.apply(self, args);
            }
            debug.namespace = namespace;
            debug.enabled = exports1.enabled(namespace);
            debug.useColors = exports1.useColors();
            debug.color = selectColor(namespace);
            if ('function' == typeof exports1.init) exports1.init(debug);
            return debug;
        }
        function enable(namespaces) {
            exports1.save(namespaces);
            exports1.names = [];
            exports1.skips = [];
            var split = ('string' == typeof namespaces ? namespaces : '').split(/[\s,]+/);
            var len = split.length;
            for(var i = 0; i < len; i++)if (split[i]) {
                namespaces = split[i].replace(/\*/g, '.*?');
                if ('-' === namespaces[0]) exports1.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
                else exports1.names.push(new RegExp('^' + namespaces + '$'));
            }
        }
        function disable() {
            exports1.enable('');
        }
        function enabled(name) {
            var i, len;
            for(i = 0, len = exports1.skips.length; i < len; i++)if (exports1.skips[i].test(name)) return false;
            for(i = 0, len = exports1.names.length; i < len; i++)if (exports1.names[i].test(name)) return true;
            return false;
        }
        function coerce(val) {
            if (val instanceof Error) return val.stack || val.message;
            return val;
        }
    },
    "../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        if ('undefined' != typeof process && 'renderer' === process.type) module.exports = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/browser.js");
        else module.exports = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/node.js");
    },
    "../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/node.js": function(module, exports1, __webpack_require__) {
        var tty = __webpack_require__("tty");
        var util = __webpack_require__("util");
        exports1 = module.exports = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/debug.js");
        exports1.init = init;
        exports1.log = log;
        exports1.formatArgs = formatArgs;
        exports1.save = save;
        exports1.load = load;
        exports1.useColors = useColors;
        exports1.colors = [
            6,
            2,
            3,
            4,
            5,
            1
        ];
        exports1.inspectOpts = Object.keys(process.env).filter(function(key) {
            return /^debug_/i.test(key);
        }).reduce(function(obj, key) {
            var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
                return k.toUpperCase();
            });
            var val = process.env[key];
            val = /^(yes|on|true|enabled)$/i.test(val) ? true : /^(no|off|false|disabled)$/i.test(val) ? false : 'null' === val ? null : Number(val);
            obj[prop] = val;
            return obj;
        }, {});
        var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
        if (1 !== fd && 2 !== fd) util.deprecate(function() {}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();
        var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
        function useColors() {
            return 'colors' in exports1.inspectOpts ? Boolean(exports1.inspectOpts.colors) : tty.isatty(fd);
        }
        exports1.formatters.o = function(v) {
            this.inspectOpts.colors = this.useColors;
            return util.inspect(v, this.inspectOpts).split('\n').map(function(str) {
                return str.trim();
            }).join(' ');
        };
        exports1.formatters.O = function(v) {
            this.inspectOpts.colors = this.useColors;
            return util.inspect(v, this.inspectOpts);
        };
        function formatArgs(args) {
            var name = this.namespace;
            var useColors = this.useColors;
            if (useColors) {
                var c = this.color;
                var prefix = '  \u001b[3' + c + ';1m' + name + " \x1b[0m";
                args[0] = prefix + args[0].split('\n').join('\n' + prefix);
                args.push('\u001b[3' + c + 'm+' + exports1.humanize(this.diff) + '\u001b[0m');
            } else args[0] = new Date().toUTCString() + ' ' + name + ' ' + args[0];
        }
        function log() {
            return stream.write(util.format.apply(util, arguments) + '\n');
        }
        function save(namespaces) {
            if (null == namespaces) delete process.env.DEBUG;
            else process.env.DEBUG = namespaces;
        }
        function load() {
            return process.env.DEBUG;
        }
        function createWritableStdioStream(fd) {
            var stream;
            var tty_wrap = process.binding('tty_wrap');
            switch(tty_wrap.guessHandleType(fd)){
                case 'TTY':
                    stream = new tty.WriteStream(fd);
                    stream._type = 'tty';
                    if (stream._handle && stream._handle.unref) stream._handle.unref();
                    break;
                case 'FILE':
                    var fs = __webpack_require__("fs");
                    stream = new fs.SyncWriteStream(fd, {
                        autoClose: false
                    });
                    stream._type = 'fs';
                    break;
                case 'PIPE':
                case 'TCP':
                    var net = __webpack_require__("net");
                    stream = new net.Socket({
                        fd: fd,
                        readable: false,
                        writable: true
                    });
                    stream.readable = false;
                    stream.read = null;
                    stream._type = 'pipe';
                    if (stream._handle && stream._handle.unref) stream._handle.unref();
                    break;
                default:
                    throw new Error('Implement me. Unknown stream file type!');
            }
            stream.fd = fd;
            stream._isStdio = true;
            return stream;
        }
        function init(debug) {
            debug.inspectOpts = {};
            var keys = Object.keys(exports1.inspectOpts);
            for(var i = 0; i < keys.length; i++)debug.inspectOpts[keys[i]] = exports1.inspectOpts[keys[i]];
        }
        exports1.enable(load());
    },
    "../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/browser.js": function(module, exports1, __webpack_require__) {
        exports1.formatArgs = formatArgs;
        exports1.save = save;
        exports1.load = load;
        exports1.useColors = useColors;
        exports1.storage = localstorage();
        exports1.destroy = (()=>{
            let warned = false;
            return ()=>{
                if (!warned) {
                    warned = true;
                    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
                }
            };
        })();
        exports1.colors = [
            '#0000CC',
            '#0000FF',
            '#0033CC',
            '#0033FF',
            '#0066CC',
            '#0066FF',
            '#0099CC',
            '#0099FF',
            '#00CC00',
            '#00CC33',
            '#00CC66',
            '#00CC99',
            '#00CCCC',
            '#00CCFF',
            '#3300CC',
            '#3300FF',
            '#3333CC',
            '#3333FF',
            '#3366CC',
            '#3366FF',
            '#3399CC',
            '#3399FF',
            '#33CC00',
            '#33CC33',
            '#33CC66',
            '#33CC99',
            '#33CCCC',
            '#33CCFF',
            '#6600CC',
            '#6600FF',
            '#6633CC',
            '#6633FF',
            '#66CC00',
            '#66CC33',
            '#9900CC',
            '#9900FF',
            '#9933CC',
            '#9933FF',
            '#99CC00',
            '#99CC33',
            '#CC0000',
            '#CC0033',
            '#CC0066',
            '#CC0099',
            '#CC00CC',
            '#CC00FF',
            '#CC3300',
            '#CC3333',
            '#CC3366',
            '#CC3399',
            '#CC33CC',
            '#CC33FF',
            '#CC6600',
            '#CC6633',
            '#CC9900',
            '#CC9933',
            '#CCCC00',
            '#CCCC33',
            '#FF0000',
            '#FF0033',
            '#FF0066',
            '#FF0099',
            '#FF00CC',
            '#FF00FF',
            '#FF3300',
            '#FF3333',
            '#FF3366',
            '#FF3399',
            '#FF33CC',
            '#FF33FF',
            '#FF6600',
            '#FF6633',
            '#FF9900',
            '#FF9933',
            '#FFCC00',
            '#FFCC33'
        ];
        function useColors() {
            if ('undefined' != typeof window && window.process && ('renderer' === window.process.type || window.process.__nwjs)) return true;
            if ('undefined' != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
            let m;
            return 'undefined' != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || 'undefined' != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || 'undefined' != typeof navigator && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || 'undefined' != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        function formatArgs(args) {
            args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
            if (!this.useColors) return;
            const c = 'color: ' + this.color;
            args.splice(1, 0, c, 'color: inherit');
            let index = 0;
            let lastC = 0;
            args[0].replace(/%[a-zA-Z%]/g, (match)=>{
                if ('%%' === match) return;
                index++;
                if ('%c' === match) lastC = index;
            });
            args.splice(lastC, 0, c);
        }
        exports1.log = console.debug || console.log || (()=>{});
        function save(namespaces) {
            try {
                if (namespaces) exports1.storage.setItem('debug', namespaces);
                else exports1.storage.removeItem('debug');
            } catch (error) {}
        }
        function load() {
            let r;
            try {
                r = exports1.storage.getItem('debug');
            } catch (error) {}
            if (!r && 'undefined' != typeof process && 'env' in process) r = process.env.DEBUG;
            return r;
        }
        function localstorage() {
            try {
                return localStorage;
            } catch (error) {}
        }
        module.exports = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/common.js")(exports1);
        const { formatters } = module.exports;
        formatters.j = function(v) {
            try {
                return JSON.stringify(v);
            } catch (error) {
                return '[UnexpectedJSONParseError]: ' + error.message;
            }
        };
    },
    "../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/common.js": function(module, __unused_webpack_exports, __webpack_require__) {
        function setup(env) {
            createDebug.debug = createDebug;
            createDebug.default = createDebug;
            createDebug.coerce = coerce;
            createDebug.disable = disable;
            createDebug.enable = enable;
            createDebug.enabled = enabled;
            createDebug.humanize = __webpack_require__("../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js");
            createDebug.destroy = destroy;
            Object.keys(env).forEach((key)=>{
                createDebug[key] = env[key];
            });
            createDebug.names = [];
            createDebug.skips = [];
            createDebug.formatters = {};
            function selectColor(namespace) {
                let hash = 0;
                for(let i = 0; i < namespace.length; i++){
                    hash = (hash << 5) - hash + namespace.charCodeAt(i);
                    hash |= 0;
                }
                return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
            }
            createDebug.selectColor = selectColor;
            function createDebug(namespace) {
                let prevTime;
                let enableOverride = null;
                let namespacesCache;
                let enabledCache;
                function debug(...args) {
                    if (!debug.enabled) return;
                    const self = debug;
                    const curr = Number(new Date());
                    const ms = curr - (prevTime || curr);
                    self.diff = ms;
                    self.prev = prevTime;
                    self.curr = curr;
                    prevTime = curr;
                    args[0] = createDebug.coerce(args[0]);
                    if ('string' != typeof args[0]) args.unshift('%O');
                    let index = 0;
                    args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                        if ('%%' === match) return '%';
                        index++;
                        const formatter = createDebug.formatters[format];
                        if ('function' == typeof formatter) {
                            const val = args[index];
                            match = formatter.call(self, val);
                            args.splice(index, 1);
                            index--;
                        }
                        return match;
                    });
                    createDebug.formatArgs.call(self, args);
                    const logFn = self.log || createDebug.log;
                    logFn.apply(self, args);
                }
                debug.namespace = namespace;
                debug.useColors = createDebug.useColors();
                debug.color = createDebug.selectColor(namespace);
                debug.extend = extend;
                debug.destroy = createDebug.destroy;
                Object.defineProperty(debug, 'enabled', {
                    enumerable: true,
                    configurable: false,
                    get: ()=>{
                        if (null !== enableOverride) return enableOverride;
                        if (namespacesCache !== createDebug.namespaces) {
                            namespacesCache = createDebug.namespaces;
                            enabledCache = createDebug.enabled(namespace);
                        }
                        return enabledCache;
                    },
                    set: (v)=>{
                        enableOverride = v;
                    }
                });
                if ('function' == typeof createDebug.init) createDebug.init(debug);
                return debug;
            }
            function extend(namespace, delimiter) {
                const newDebug = createDebug(this.namespace + (void 0 === delimiter ? ':' : delimiter) + namespace);
                newDebug.log = this.log;
                return newDebug;
            }
            function enable(namespaces) {
                createDebug.save(namespaces);
                createDebug.namespaces = namespaces;
                createDebug.names = [];
                createDebug.skips = [];
                let i;
                const split = ('string' == typeof namespaces ? namespaces : '').split(/[\s,]+/);
                const len = split.length;
                for(i = 0; i < len; i++)if (split[i]) {
                    namespaces = split[i].replace(/\*/g, '.*?');
                    if ('-' === namespaces[0]) createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
                    else createDebug.names.push(new RegExp('^' + namespaces + '$'));
                }
            }
            function disable() {
                const namespaces = [
                    ...createDebug.names.map(toNamespace),
                    ...createDebug.skips.map(toNamespace).map((namespace)=>'-' + namespace)
                ].join(',');
                createDebug.enable('');
                return namespaces;
            }
            function enabled(name) {
                if ('*' === name[name.length - 1]) return true;
                let i;
                let len;
                for(i = 0, len = createDebug.skips.length; i < len; i++)if (createDebug.skips[i].test(name)) return false;
                for(i = 0, len = createDebug.names.length; i < len; i++)if (createDebug.names[i].test(name)) return true;
                return false;
            }
            function toNamespace(regexp) {
                return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
            }
            function coerce(val) {
                if (val instanceof Error) return val.stack || val.message;
                return val;
            }
            function destroy() {
                console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
            }
            createDebug.enable(createDebug.load());
            return createDebug;
        }
        module.exports = setup;
    },
    "../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        if ('undefined' == typeof process || 'renderer' === process.type || true === process.browser || process.__nwjs) module.exports = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/browser.js");
        else module.exports = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/node.js");
    },
    "../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/node.js": function(module, exports1, __webpack_require__) {
        const tty = __webpack_require__("tty");
        const util = __webpack_require__("util");
        exports1.init = init;
        exports1.log = log;
        exports1.formatArgs = formatArgs;
        exports1.save = save;
        exports1.load = load;
        exports1.useColors = useColors;
        exports1.destroy = util.deprecate(()=>{}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        exports1.colors = [
            6,
            2,
            3,
            4,
            5,
            1
        ];
        try {
            const supportsColor = __webpack_require__("../node_modules/.pnpm/supports-color@5.5.0/node_modules/supports-color/index.js");
            if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) exports1.colors = [
                20,
                21,
                26,
                27,
                32,
                33,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                56,
                57,
                62,
                63,
                68,
                69,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                92,
                93,
                98,
                99,
                112,
                113,
                128,
                129,
                134,
                135,
                148,
                149,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                178,
                179,
                184,
                185,
                196,
                197,
                198,
                199,
                200,
                201,
                202,
                203,
                204,
                205,
                206,
                207,
                208,
                209,
                214,
                215,
                220,
                221
            ];
        } catch (error) {}
        exports1.inspectOpts = Object.keys(process.env).filter((key)=>/^debug_/i.test(key)).reduce((obj, key)=>{
            const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>k.toUpperCase());
            let val = process.env[key];
            val = /^(yes|on|true|enabled)$/i.test(val) ? true : /^(no|off|false|disabled)$/i.test(val) ? false : 'null' === val ? null : Number(val);
            obj[prop] = val;
            return obj;
        }, {});
        function useColors() {
            return 'colors' in exports1.inspectOpts ? Boolean(exports1.inspectOpts.colors) : tty.isatty(process.stderr.fd);
        }
        function formatArgs(args) {
            const { namespace: name, useColors } = this;
            if (useColors) {
                const c = this.color;
                const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
                const prefix = `  ${colorCode};1m${name} \u001B[0m`;
                args[0] = prefix + args[0].split('\n').join('\n' + prefix);
                args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
            } else args[0] = getDate() + name + ' ' + args[0];
        }
        function getDate() {
            if (exports1.inspectOpts.hideDate) return '';
            return new Date().toISOString() + ' ';
        }
        function log(...args) {
            return process.stderr.write(util.formatWithOptions(exports1.inspectOpts, ...args) + '\n');
        }
        function save(namespaces) {
            if (namespaces) process.env.DEBUG = namespaces;
            else delete process.env.DEBUG;
        }
        function load() {
            return process.env.DEBUG;
        }
        function init(debug) {
            debug.inspectOpts = {};
            const keys = Object.keys(exports1.inspectOpts);
            for(let i = 0; i < keys.length; i++)debug.inspectOpts[keys[i]] = exports1.inspectOpts[keys[i]];
        }
        module.exports = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/common.js")(exports1);
        const { formatters } = module.exports;
        formatters.o = function(v) {
            this.inspectOpts.colors = this.useColors;
            return util.inspect(v, this.inspectOpts).split('\n').map((str)=>str.trim()).join(' ');
        };
        formatters.O = function(v) {
            this.inspectOpts.colors = this.useColors;
            return util.inspect(v, this.inspectOpts);
        };
    },
    "../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        /*!
 * depd
 * Copyright(c) 2014-2018 Douglas Christopher Wilson
 * MIT Licensed
 */ var relative = __webpack_require__("path").relative;
        module.exports = depd;
        var basePath = process.cwd();
        function containsNamespace(str, namespace) {
            var vals = str.split(/[ ,]+/);
            var ns = String(namespace).toLowerCase();
            for(var i = 0; i < vals.length; i++){
                var val = vals[i];
                if (val && ('*' === val || val.toLowerCase() === ns)) return true;
            }
            return false;
        }
        function convertDataDescriptorToAccessor(obj, prop, message) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            var value = descriptor.value;
            descriptor.get = function() {
                return value;
            };
            if (descriptor.writable) descriptor.set = function(val) {
                return value = val;
            };
            delete descriptor.value;
            delete descriptor.writable;
            Object.defineProperty(obj, prop, descriptor);
            return descriptor;
        }
        function createArgumentsString(arity) {
            var str = '';
            for(var i = 0; i < arity; i++)str += ', arg' + i;
            return str.substr(2);
        }
        function createStackString(stack) {
            var str = this.name + ': ' + this.namespace;
            if (this.message) str += ' deprecated ' + this.message;
            for(var i = 0; i < stack.length; i++)str += '\n    at ' + stack[i].toString();
            return str;
        }
        function depd(namespace) {
            if (!namespace) throw new TypeError('argument namespace is required');
            var stack = getStack();
            var site = callSiteLocation(stack[1]);
            var file = site[0];
            function deprecate(message) {
                log.call(deprecate, message);
            }
            deprecate._file = file;
            deprecate._ignored = isignored(namespace);
            deprecate._namespace = namespace;
            deprecate._traced = istraced(namespace);
            deprecate._warned = Object.create(null);
            deprecate.function = wrapfunction;
            deprecate.property = wrapproperty;
            return deprecate;
        }
        function eehaslisteners(emitter, type) {
            var count = 'function' != typeof emitter.listenerCount ? emitter.listeners(type).length : emitter.listenerCount(type);
            return count > 0;
        }
        function isignored(namespace) {
            if (process.noDeprecation) return true;
            var str = process.env.NO_DEPRECATION || '';
            return containsNamespace(str, namespace);
        }
        function istraced(namespace) {
            if (process.traceDeprecation) return true;
            var str = process.env.TRACE_DEPRECATION || '';
            return containsNamespace(str, namespace);
        }
        function log(message, site) {
            var haslisteners = eehaslisteners(process, 'deprecation');
            if (!haslisteners && this._ignored) return;
            var caller;
            var callFile;
            var callSite;
            var depSite;
            var i = 0;
            var seen = false;
            var stack = getStack();
            var file = this._file;
            if (site) {
                depSite = site;
                callSite = callSiteLocation(stack[1]);
                callSite.name = depSite.name;
                file = callSite[0];
            } else {
                i = 2;
                depSite = callSiteLocation(stack[i]);
                callSite = depSite;
            }
            for(; i < stack.length; i++){
                caller = callSiteLocation(stack[i]);
                callFile = caller[0];
                if (callFile === file) seen = true;
                else if (callFile === this._file) file = this._file;
                else if (seen) break;
            }
            var key = caller ? depSite.join(':') + '__' + caller.join(':') : void 0;
            if (void 0 !== key && key in this._warned) return;
            this._warned[key] = true;
            var msg = message;
            if (!msg) msg = callSite !== depSite && callSite.name ? defaultMessage(callSite) : defaultMessage(depSite);
            if (haslisteners) {
                var err = DeprecationError(this._namespace, msg, stack.slice(i));
                process.emit('deprecation', err);
                return;
            }
            var format = process.stderr.isTTY ? formatColor : formatPlain;
            var output = format.call(this, msg, caller, stack.slice(i));
            process.stderr.write(output + '\n', 'utf8');
        }
        function callSiteLocation(callSite) {
            var file = callSite.getFileName() || '<anonymous>';
            var line = callSite.getLineNumber();
            var colm = callSite.getColumnNumber();
            if (callSite.isEval()) file = callSite.getEvalOrigin() + ', ' + file;
            var site = [
                file,
                line,
                colm
            ];
            site.callSite = callSite;
            site.name = callSite.getFunctionName();
            return site;
        }
        function defaultMessage(site) {
            var callSite = site.callSite;
            var funcName = site.name;
            if (!funcName) funcName = '<anonymous@' + formatLocation(site) + '>';
            var context = callSite.getThis();
            var typeName = context && callSite.getTypeName();
            if ('Object' === typeName) typeName = void 0;
            if ('Function' === typeName) typeName = context.name || typeName;
            return typeName && callSite.getMethodName() ? typeName + '.' + funcName : funcName;
        }
        function formatPlain(msg, caller, stack) {
            var timestamp = new Date().toUTCString();
            var formatted = timestamp + ' ' + this._namespace + ' deprecated ' + msg;
            if (this._traced) {
                for(var i = 0; i < stack.length; i++)formatted += '\n    at ' + stack[i].toString();
                return formatted;
            }
            if (caller) formatted += ' at ' + formatLocation(caller);
            return formatted;
        }
        function formatColor(msg, caller, stack) {
            var formatted = '\x1b[36;1m' + this._namespace + "\x1b[22;39m \x1b[33;1mdeprecated\x1b[22;39m \x1b[0m" + msg + '\x1b[39m';
            if (this._traced) {
                for(var i = 0; i < stack.length; i++)formatted += '\n    \x1b[36mat ' + stack[i].toString() + '\x1b[39m';
                return formatted;
            }
            if (caller) formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m';
            return formatted;
        }
        function formatLocation(callSite) {
            return relative(basePath, callSite[0]) + ':' + callSite[1] + ':' + callSite[2];
        }
        function getStack() {
            var limit = Error.stackTraceLimit;
            var obj = {};
            var prep = Error.prepareStackTrace;
            Error.prepareStackTrace = prepareObjectStackTrace;
            Error.stackTraceLimit = Math.max(10, limit);
            Error.captureStackTrace(obj);
            var stack = obj.stack.slice(1);
            Error.prepareStackTrace = prep;
            Error.stackTraceLimit = limit;
            return stack;
        }
        function prepareObjectStackTrace(obj, stack) {
            return stack;
        }
        function wrapfunction(fn, message) {
            if ('function' != typeof fn) throw new TypeError('argument fn must be a function');
            var args = createArgumentsString(fn.length);
            var stack = getStack();
            var site = callSiteLocation(stack[1]);
            site.name = fn.name;
            var deprecatedfn = new Function('fn', 'log', 'deprecate', 'message', 'site', '"use strict"\nreturn function (' + args + ") {log.call(deprecate, message, site)\nreturn fn.apply(this, arguments)\n}")(fn, log, this, message, site);
            return deprecatedfn;
        }
        function wrapproperty(obj, prop, message) {
            if (!obj || 'object' != typeof obj && 'function' != typeof obj) throw new TypeError('argument obj must be object');
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            if (!descriptor) throw new TypeError('must call property on owner object');
            if (!descriptor.configurable) throw new TypeError('property must be configurable');
            var deprecate = this;
            var stack = getStack();
            var site = callSiteLocation(stack[1]);
            site.name = prop;
            if ('value' in descriptor) descriptor = convertDataDescriptorToAccessor(obj, prop, message);
            var get = descriptor.get;
            var set = descriptor.set;
            if ('function' == typeof get) descriptor.get = function() {
                log.call(deprecate, message, site);
                return get.apply(this, arguments);
            };
            if ('function' == typeof set) descriptor.set = function() {
                log.call(deprecate, message, site);
                return set.apply(this, arguments);
            };
            Object.defineProperty(obj, prop, descriptor);
        }
        function DeprecationError(namespace, message, stack) {
            var error = new Error();
            var stackString;
            Object.defineProperty(error, 'constructor', {
                value: DeprecationError
            });
            Object.defineProperty(error, 'message', {
                configurable: true,
                enumerable: false,
                value: message,
                writable: true
            });
            Object.defineProperty(error, 'name', {
                enumerable: false,
                configurable: true,
                value: 'DeprecationError',
                writable: true
            });
            Object.defineProperty(error, 'namespace', {
                configurable: true,
                enumerable: false,
                value: namespace,
                writable: true
            });
            Object.defineProperty(error, 'stack', {
                configurable: true,
                enumerable: false,
                get: function() {
                    if (void 0 !== stackString) return stackString;
                    return stackString = createStackString.call(this, stack);
                },
                set: function(val) {
                    stackString = val;
                }
            });
            return error;
        }
    },
    "../node_modules/.pnpm/destroy@1.2.0/node_modules/destroy/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * destroy
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var EventEmitter = __webpack_require__("events").EventEmitter;
        var ReadStream = __webpack_require__("fs").ReadStream;
        var Stream = __webpack_require__("stream");
        var Zlib = __webpack_require__("zlib");
        module.exports = destroy;
        function destroy(stream, suppress) {
            if (isFsReadStream(stream)) destroyReadStream(stream);
            else if (isZlibStream(stream)) destroyZlibStream(stream);
            else if (hasDestroy(stream)) stream.destroy();
            if (isEventEmitter(stream) && suppress) {
                stream.removeAllListeners('error');
                stream.addListener('error', noop);
            }
            return stream;
        }
        function destroyReadStream(stream) {
            stream.destroy();
            if ('function' == typeof stream.close) stream.on('open', onOpenClose);
        }
        function closeZlibStream(stream) {
            if (true === stream._hadError) {
                var prop = null === stream._binding ? '_binding' : '_handle';
                stream[prop] = {
                    close: function() {
                        this[prop] = null;
                    }
                };
            }
            stream.close();
        }
        function destroyZlibStream(stream) {
            if ('function' == typeof stream.destroy) if (stream._binding) {
                stream.destroy();
                if (stream._processing) {
                    stream._needDrain = true;
                    stream.once('drain', onDrainClearBinding);
                } else stream._binding.clear();
            } else if (stream._destroy && stream._destroy !== Stream.Transform.prototype._destroy) stream.destroy();
            else if (stream._destroy && 'function' == typeof stream.close) {
                stream.destroyed = true;
                stream.close();
            } else stream.destroy();
            else if ('function' == typeof stream.close) closeZlibStream(stream);
        }
        function hasDestroy(stream) {
            return stream instanceof Stream && 'function' == typeof stream.destroy;
        }
        function isEventEmitter(val) {
            return val instanceof EventEmitter;
        }
        function isFsReadStream(stream) {
            return stream instanceof ReadStream;
        }
        function isZlibStream(stream) {
            return stream instanceof Zlib.Gzip || stream instanceof Zlib.Gunzip || stream instanceof Zlib.Deflate || stream instanceof Zlib.DeflateRaw || stream instanceof Zlib.Inflate || stream instanceof Zlib.InflateRaw || stream instanceof Zlib.Unzip;
        }
        function noop() {}
        function onDrainClearBinding() {
            this._binding.clear();
        }
        function onOpenClose() {
            if ('number' == typeof this.fd) this.close();
        }
    },
    "../node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var callBind = __webpack_require__("../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js");
        var gOPD = __webpack_require__("../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");
        var hasProtoAccessor;
        try {
            hasProtoAccessor = [].__proto__ === Array.prototype;
        } catch (e) {
            if (!e || 'object' != typeof e || !('code' in e) || 'ERR_PROTO_ACCESS' !== e.code) throw e;
        }
        var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, '__proto__');
        var $Object = Object;
        var $getPrototypeOf = $Object.getPrototypeOf;
        module.exports = desc && 'function' == typeof desc.get ? callBind([
            desc.get
        ]) : 'function' == typeof $getPrototypeOf ? function(value) {
            return $getPrototypeOf(null == value ? value : $Object(value));
        } : false;
    },
    "../node_modules/.pnpm/ee-first@1.1.1/node_modules/ee-first/index.js": function(module) {
        "use strict";
        /*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */ module.exports = first;
        function first(stuff, done) {
            if (!Array.isArray(stuff)) throw new TypeError('arg must be an array of [ee, events...] arrays');
            var cleanups = [];
            for(var i = 0; i < stuff.length; i++){
                var arr = stuff[i];
                if (!Array.isArray(arr) || arr.length < 2) throw new TypeError('each array member must be [ee, events...]');
                var ee = arr[0];
                for(var j = 1; j < arr.length; j++){
                    var event = arr[j];
                    var fn = listener(event, callback);
                    ee.on(event, fn);
                    cleanups.push({
                        ee: ee,
                        event: event,
                        fn: fn
                    });
                }
            }
            function callback() {
                cleanup();
                done.apply(null, arguments);
            }
            function cleanup() {
                var x;
                for(var i = 0; i < cleanups.length; i++){
                    x = cleanups[i];
                    x.ee.removeListener(x.event, x.fn);
                }
            }
            function thunk(fn) {
                done = fn;
            }
            thunk.cancel = cleanup;
            return thunk;
        }
        function listener(event, done) {
            return function(arg1) {
                var args = new Array(arguments.length);
                var ee = this;
                var err = 'error' === event ? arg1 : null;
                for(var i = 0; i < args.length; i++)args[i] = arguments[i];
                done(err, ee, event, args);
            };
        }
    },
    "../node_modules/.pnpm/encodeurl@1.0.2/node_modules/encodeurl/index.js": function(module) {
        "use strict";
        /*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = encodeUrl;
        var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
        var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
        var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2';
        function encodeUrl(url) {
            return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
        }
    },
    "../node_modules/.pnpm/encodeurl@2.0.0/node_modules/encodeurl/index.js": function(module) {
        "use strict";
        /*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = encodeUrl;
        var ENCODE_CHARS_REGEXP = /(?:[^\x21\x23-\x3B\x3D\x3F-\x5F\x61-\x7A\x7C\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
        var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
        var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2';
        function encodeUrl(url) {
            return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
        }
    },
    "../node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js": function(module) {
        "use strict";
        var $defineProperty = Object.defineProperty || false;
        if ($defineProperty) try {
            $defineProperty({}, 'a', {
                value: 1
            });
        } catch (e) {
            $defineProperty = false;
        }
        module.exports = $defineProperty;
    },
    "../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js": function(module) {
        "use strict";
        module.exports = EvalError;
    },
    "../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js": function(module) {
        "use strict";
        module.exports = Error;
    },
    "../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js": function(module) {
        "use strict";
        module.exports = RangeError;
    },
    "../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js": function(module) {
        "use strict";
        module.exports = ReferenceError;
    },
    "../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js": function(module) {
        "use strict";
        module.exports = SyntaxError;
    },
    "../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js": function(module) {
        "use strict";
        module.exports = TypeError;
    },
    "../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js": function(module) {
        "use strict";
        module.exports = URIError;
    },
    "../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js": function(module) {
        "use strict";
        module.exports = Object;
    },
    "../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js": function(module) {
        "use strict";
        /*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */ var matchHtmlRegExp = /["'&<>]/;
        module.exports = escapeHtml;
        function escapeHtml(string) {
            var str = '' + string;
            var match = matchHtmlRegExp.exec(str);
            if (!match) return str;
            var escape1;
            var html = '';
            var index = 0;
            var lastIndex = 0;
            for(index = match.index; index < str.length; index++){
                switch(str.charCodeAt(index)){
                    case 34:
                        escape1 = '&quot;';
                        break;
                    case 38:
                        escape1 = '&amp;';
                        break;
                    case 39:
                        escape1 = '&#39;';
                        break;
                    case 60:
                        escape1 = '&lt;';
                        break;
                    case 62:
                        escape1 = '&gt;';
                        break;
                    default:
                        continue;
                }
                if (lastIndex !== index) html += str.substring(lastIndex, index);
                lastIndex = index + 1;
                html += escape1;
            }
            return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
        }
    },
    "../node_modules/.pnpm/etag@1.8.1/node_modules/etag/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = etag;
        var crypto = __webpack_require__("crypto");
        var Stats = __webpack_require__("fs").Stats;
        var toString = Object.prototype.toString;
        function entitytag(entity) {
            if (0 === entity.length) return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
            var hash = crypto.createHash('sha1').update(entity, 'utf8').digest('base64').substring(0, 27);
            var len = 'string' == typeof entity ? Buffer.byteLength(entity, 'utf8') : entity.length;
            return '"' + len.toString(16) + '-' + hash + '"';
        }
        function etag(entity, options) {
            if (null == entity) throw new TypeError('argument entity is required');
            var isStats = isstats(entity);
            var weak = options && 'boolean' == typeof options.weak ? options.weak : isStats;
            if (!isStats && 'string' != typeof entity && !Buffer.isBuffer(entity)) throw new TypeError('argument entity must be string, Buffer, or fs.Stats');
            var tag = isStats ? stattag(entity) : entitytag(entity);
            return weak ? 'W/' + tag : tag;
        }
        function isstats(obj) {
            if ('function' == typeof Stats && obj instanceof Stats) return true;
            return obj && 'object' == typeof obj && 'ctime' in obj && '[object Date]' === toString.call(obj.ctime) && 'mtime' in obj && '[object Date]' === toString.call(obj.mtime) && 'ino' in obj && 'number' == typeof obj.ino && 'size' in obj && 'number' == typeof obj.size;
        }
        function stattag(stat) {
            var mtime = stat.mtime.getTime().toString(16);
            var size = stat.size.toString(16);
            return '"' + size + '-' + mtime + '"';
        }
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/express.js");
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/application.js": function(module, exports1, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var finalhandler = __webpack_require__("../node_modules/.pnpm/finalhandler@1.3.1/node_modules/finalhandler/index.js");
        var Router = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/index.js");
        var methods = __webpack_require__("../node_modules/.pnpm/methods@1.1.2/node_modules/methods/index.js");
        var middleware = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/middleware/init.js");
        var query = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/middleware/query.js");
        var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('express:application');
        var View = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/view.js");
        var http = __webpack_require__("http");
        var compileETag = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/utils.js").compileETag;
        var compileQueryParser = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/utils.js").compileQueryParser;
        var compileTrust = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/utils.js").compileTrust;
        var deprecate = __webpack_require__("../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('express');
        var flatten = __webpack_require__("../node_modules/.pnpm/array-flatten@1.1.1/node_modules/array-flatten/array-flatten.js");
        var merge = __webpack_require__("../node_modules/.pnpm/utils-merge@1.0.1/node_modules/utils-merge/index.js");
        var resolve = __webpack_require__("path").resolve;
        var setPrototypeOf = __webpack_require__("../node_modules/.pnpm/setprototypeof@1.2.0/node_modules/setprototypeof/index.js");
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var slice = Array.prototype.slice;
        var app = module.exports = {};
        var trustProxyDefaultSymbol = '@@symbol:trust_proxy_default';
        app.init = function() {
            this.cache = {};
            this.engines = {};
            this.settings = {};
            this.defaultConfiguration();
        };
        app.defaultConfiguration = function() {
            var env = process.env.NODE_ENV || 'development';
            this.enable('x-powered-by');
            this.set('etag', 'weak');
            this.set('env', env);
            this.set('query parser', 'extended');
            this.set('subdomain offset', 2);
            this.set('trust proxy', false);
            Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
                configurable: true,
                value: true
            });
            debug('booting in %s mode', env);
            this.on('mount', function(parent) {
                if (true === this.settings[trustProxyDefaultSymbol] && 'function' == typeof parent.settings['trust proxy fn']) {
                    delete this.settings['trust proxy'];
                    delete this.settings['trust proxy fn'];
                }
                setPrototypeOf(this.request, parent.request);
                setPrototypeOf(this.response, parent.response);
                setPrototypeOf(this.engines, parent.engines);
                setPrototypeOf(this.settings, parent.settings);
            });
            this.locals = Object.create(null);
            this.mountpath = '/';
            this.locals.settings = this.settings;
            this.set('view', View);
            this.set('views', resolve('views'));
            this.set('jsonp callback name', 'callback');
            if ('production' === env) this.enable('view cache');
            Object.defineProperty(this, 'router', {
                get: function() {
                    throw new Error('\'app.router\' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.');
                }
            });
        };
        app.lazyrouter = function() {
            if (!this._router) {
                this._router = new Router({
                    caseSensitive: this.enabled('case sensitive routing'),
                    strict: this.enabled('strict routing')
                });
                this._router.use(query(this.get('query parser fn')));
                this._router.use(middleware.init(this));
            }
        };
        app.handle = function(req, res, callback) {
            var router = this._router;
            var done = callback || finalhandler(req, res, {
                env: this.get('env'),
                onerror: logerror.bind(this)
            });
            if (!router) {
                debug('no routes defined on app');
                done();
                return;
            }
            router.handle(req, res, done);
        };
        app.use = function(fn) {
            var offset = 0;
            var path = '/';
            if ('function' != typeof fn) {
                var arg = fn;
                while(Array.isArray(arg) && 0 !== arg.length)arg = arg[0];
                if ('function' != typeof arg) {
                    offset = 1;
                    path = fn;
                }
            }
            var fns = flatten(slice.call(arguments, offset));
            if (0 === fns.length) throw new TypeError('app.use() requires a middleware function');
            this.lazyrouter();
            var router = this._router;
            fns.forEach(function(fn) {
                if (!fn || !fn.handle || !fn.set) return router.use(path, fn);
                debug('.use app under %s', path);
                fn.mountpath = path;
                fn.parent = this;
                router.use(path, function(req, res, next) {
                    var orig = req.app;
                    fn.handle(req, res, function(err) {
                        setPrototypeOf(req, orig.request);
                        setPrototypeOf(res, orig.response);
                        next(err);
                    });
                });
                fn.emit('mount', this);
            }, this);
            return this;
        };
        app.route = function(path) {
            this.lazyrouter();
            return this._router.route(path);
        };
        app.engine = function(ext, fn) {
            if ('function' != typeof fn) throw new Error('callback function required');
            var extension = '.' !== ext[0] ? '.' + ext : ext;
            this.engines[extension] = fn;
            return this;
        };
        app.param = function(name, fn) {
            this.lazyrouter();
            if (Array.isArray(name)) {
                for(var i = 0; i < name.length; i++)this.param(name[i], fn);
                return this;
            }
            this._router.param(name, fn);
            return this;
        };
        app.set = function(setting, val) {
            if (1 === arguments.length) {
                var settings = this.settings;
                while(settings && settings !== Object.prototype){
                    if (hasOwnProperty.call(settings, setting)) return settings[setting];
                    settings = Object.getPrototypeOf(settings);
                }
                return;
            }
            debug('set "%s" to %o', setting, val);
            this.settings[setting] = val;
            switch(setting){
                case 'etag':
                    this.set('etag fn', compileETag(val));
                    break;
                case 'query parser':
                    this.set('query parser fn', compileQueryParser(val));
                    break;
                case 'trust proxy':
                    this.set('trust proxy fn', compileTrust(val));
                    Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
                        configurable: true,
                        value: false
                    });
                    break;
            }
            return this;
        };
        app.path = function() {
            return this.parent ? this.parent.path() + this.mountpath : '';
        };
        app.enabled = function(setting) {
            return Boolean(this.set(setting));
        };
        app.disabled = function(setting) {
            return !this.set(setting);
        };
        app.enable = function(setting) {
            return this.set(setting, true);
        };
        app.disable = function(setting) {
            return this.set(setting, false);
        };
        methods.forEach(function(method) {
            app[method] = function(path) {
                if ('get' === method && 1 === arguments.length) return this.set(path);
                this.lazyrouter();
                var route = this._router.route(path);
                route[method].apply(route, slice.call(arguments, 1));
                return this;
            };
        });
        app.all = function(path) {
            this.lazyrouter();
            var route = this._router.route(path);
            var args = slice.call(arguments, 1);
            for(var i = 0; i < methods.length; i++)route[methods[i]].apply(route, args);
            return this;
        };
        app.del = deprecate.function(app.delete, 'app.del: Use app.delete instead');
        app.render = function(name, options, callback) {
            var cache = this.cache;
            var done = callback;
            var engines = this.engines;
            var opts = options;
            var renderOptions = {};
            var view;
            if ('function' == typeof options) {
                done = options;
                opts = {};
            }
            merge(renderOptions, this.locals);
            if (opts._locals) merge(renderOptions, opts._locals);
            merge(renderOptions, opts);
            if (null == renderOptions.cache) renderOptions.cache = this.enabled('view cache');
            if (renderOptions.cache) view = cache[name];
            if (!view) {
                var View = this.get('view');
                view = new View(name, {
                    defaultEngine: this.get('view engine'),
                    root: this.get('views'),
                    engines: engines
                });
                if (!view.path) {
                    var dirs = Array.isArray(view.root) && view.root.length > 1 ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"' : 'directory "' + view.root + '"';
                    var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
                    err.view = view;
                    return done(err);
                }
                if (renderOptions.cache) cache[name] = view;
            }
            tryRender(view, renderOptions, done);
        };
        app.listen = function() {
            var server = http.createServer(this);
            return server.listen.apply(server, arguments);
        };
        function logerror(err) {
            if ('test' !== this.get('env')) console.error(err.stack || err.toString());
        }
        function tryRender(view, options, callback) {
            try {
                view.render(options, callback);
            } catch (err) {
                callback(err);
            }
        }
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/express.js": function(module, exports1, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var bodyParser = __webpack_require__("../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/index.js");
        var EventEmitter = __webpack_require__("events").EventEmitter;
        var mixin = __webpack_require__("../node_modules/.pnpm/merge-descriptors@1.0.3/node_modules/merge-descriptors/index.js");
        var proto = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/application.js");
        var Route = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/route.js");
        var Router = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/index.js");
        var req = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/request.js");
        var res = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/response.js");
        exports1 = module.exports = createApplication;
        function createApplication() {
            var app = function(req, res, next) {
                app.handle(req, res, next);
            };
            mixin(app, EventEmitter.prototype, false);
            mixin(app, proto, false);
            app.request = Object.create(req, {
                app: {
                    configurable: true,
                    enumerable: true,
                    writable: true,
                    value: app
                }
            });
            app.response = Object.create(res, {
                app: {
                    configurable: true,
                    enumerable: true,
                    writable: true,
                    value: app
                }
            });
            app.init();
            return app;
        }
        exports1.application = proto;
        exports1.request = req;
        exports1.response = res;
        exports1.Route = Route;
        exports1.Router = Router;
        exports1.json = bodyParser.json;
        exports1.query = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/middleware/query.js");
        exports1.raw = bodyParser.raw;
        exports1["static"] = __webpack_require__("../node_modules/.pnpm/serve-static@1.16.2/node_modules/serve-static/index.js");
        exports1.text = bodyParser.text;
        exports1.urlencoded = bodyParser.urlencoded;
        var removedMiddlewares = [
            'bodyParser',
            'compress',
            'cookieSession',
            'session',
            'logger',
            'cookieParser',
            'favicon',
            'responseTime',
            'errorHandler',
            'timeout',
            'methodOverride',
            'vhost',
            'csrf',
            'directory',
            'limit',
            'multipart',
            'staticCache'
        ];
        removedMiddlewares.forEach(function(name) {
            Object.defineProperty(exports1, name, {
                get: function() {
                    throw new Error('Most middleware (like ' + name + ') is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.');
                },
                configurable: true
            });
        });
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/middleware/init.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var setPrototypeOf = __webpack_require__("../node_modules/.pnpm/setprototypeof@1.2.0/node_modules/setprototypeof/index.js");
        exports1.init = function(app) {
            return function(req, res, next) {
                if (app.enabled('x-powered-by')) res.setHeader('X-Powered-By', 'Express');
                req.res = res;
                res.req = req;
                req.next = next;
                setPrototypeOf(req, app.request);
                setPrototypeOf(res, app.response);
                res.locals = res.locals || Object.create(null);
                next();
            };
        };
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/middleware/query.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var merge = __webpack_require__("../node_modules/.pnpm/utils-merge@1.0.1/node_modules/utils-merge/index.js");
        var parseUrl = __webpack_require__("../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js");
        var qs = __webpack_require__("../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/index.js");
        module.exports = function(options) {
            var opts = merge({}, options);
            var queryparse = qs.parse;
            if ('function' == typeof options) {
                queryparse = options;
                opts = void 0;
            }
            if (void 0 !== opts && void 0 === opts.allowPrototypes) opts.allowPrototypes = true;
            return function(req, res, next) {
                if (!req.query) {
                    var val = parseUrl(req).query;
                    req.query = queryparse(val, opts);
                }
                next();
            };
        };
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/request.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var accepts = __webpack_require__("../node_modules/.pnpm/accepts@1.3.8/node_modules/accepts/index.js");
        var deprecate = __webpack_require__("../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('express');
        var isIP = __webpack_require__("net").isIP;
        var typeis = __webpack_require__("../node_modules/.pnpm/type-is@1.6.18/node_modules/type-is/index.js");
        var http = __webpack_require__("http");
        var fresh = __webpack_require__("../node_modules/.pnpm/fresh@0.5.2/node_modules/fresh/index.js");
        var parseRange = __webpack_require__("../node_modules/.pnpm/range-parser@1.2.1/node_modules/range-parser/index.js");
        var parse = __webpack_require__("../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js");
        var proxyaddr = __webpack_require__("../node_modules/.pnpm/proxy-addr@2.0.7/node_modules/proxy-addr/index.js");
        var req = Object.create(http.IncomingMessage.prototype);
        module.exports = req;
        req.get = req.header = function(name) {
            if (!name) throw new TypeError('name argument is required to req.get');
            if ('string' != typeof name) throw new TypeError('name must be a string to req.get');
            var lc = name.toLowerCase();
            switch(lc){
                case 'referer':
                case 'referrer':
                    return this.headers.referrer || this.headers.referer;
                default:
                    return this.headers[lc];
            }
        };
        req.accepts = function() {
            var accept = accepts(this);
            return accept.types.apply(accept, arguments);
        };
        req.acceptsEncodings = function() {
            var accept = accepts(this);
            return accept.encodings.apply(accept, arguments);
        };
        req.acceptsEncoding = deprecate.function(req.acceptsEncodings, 'req.acceptsEncoding: Use acceptsEncodings instead');
        req.acceptsCharsets = function() {
            var accept = accepts(this);
            return accept.charsets.apply(accept, arguments);
        };
        req.acceptsCharset = deprecate.function(req.acceptsCharsets, 'req.acceptsCharset: Use acceptsCharsets instead');
        req.acceptsLanguages = function() {
            var accept = accepts(this);
            return accept.languages.apply(accept, arguments);
        };
        req.acceptsLanguage = deprecate.function(req.acceptsLanguages, 'req.acceptsLanguage: Use acceptsLanguages instead');
        req.range = function(size, options) {
            var range = this.get('Range');
            if (!range) return;
            return parseRange(size, range, options);
        };
        req.param = function(name, defaultValue) {
            var params = this.params || {};
            var body = this.body || {};
            var query = this.query || {};
            var args = 1 === arguments.length ? 'name' : 'name, default';
            deprecate('req.param(' + args + '): Use req.params, req.body, or req.query instead');
            if (null != params[name] && params.hasOwnProperty(name)) return params[name];
            if (null != body[name]) return body[name];
            if (null != query[name]) return query[name];
            return defaultValue;
        };
        req.is = function(types) {
            var arr = types;
            if (!Array.isArray(types)) {
                arr = new Array(arguments.length);
                for(var i = 0; i < arr.length; i++)arr[i] = arguments[i];
            }
            return typeis(this, arr);
        };
        defineGetter(req, 'protocol', function() {
            var proto = this.connection.encrypted ? 'https' : 'http';
            var trust = this.app.get('trust proxy fn');
            if (!trust(this.connection.remoteAddress, 0)) return proto;
            var header = this.get('X-Forwarded-Proto') || proto;
            var index = header.indexOf(',');
            return -1 !== index ? header.substring(0, index).trim() : header.trim();
        });
        defineGetter(req, 'secure', function() {
            return 'https' === this.protocol;
        });
        defineGetter(req, 'ip', function() {
            var trust = this.app.get('trust proxy fn');
            return proxyaddr(this, trust);
        });
        defineGetter(req, 'ips', function() {
            var trust = this.app.get('trust proxy fn');
            var addrs = proxyaddr.all(this, trust);
            addrs.reverse().pop();
            return addrs;
        });
        defineGetter(req, 'subdomains', function() {
            var hostname = this.hostname;
            if (!hostname) return [];
            var offset = this.app.get('subdomain offset');
            var subdomains = isIP(hostname) ? [
                hostname
            ] : hostname.split('.').reverse();
            return subdomains.slice(offset);
        });
        defineGetter(req, 'path', function() {
            return parse(this).pathname;
        });
        defineGetter(req, 'hostname', function() {
            var trust = this.app.get('trust proxy fn');
            var host = this.get('X-Forwarded-Host');
            if (host && trust(this.connection.remoteAddress, 0)) {
                if (-1 !== host.indexOf(',')) host = host.substring(0, host.indexOf(',')).trimRight();
            } else host = this.get('Host');
            if (!host) return;
            var offset = '[' === host[0] ? host.indexOf(']') + 1 : 0;
            var index = host.indexOf(':', offset);
            return -1 !== index ? host.substring(0, index) : host;
        });
        defineGetter(req, 'host', deprecate.function(function() {
            return this.hostname;
        }, 'req.host: Use req.hostname instead'));
        defineGetter(req, 'fresh', function() {
            var method = this.method;
            var res = this.res;
            var status = res.statusCode;
            if ('GET' !== method && 'HEAD' !== method) return false;
            if (status >= 200 && status < 300 || 304 === status) return fresh(this.headers, {
                etag: res.get('ETag'),
                'last-modified': res.get('Last-Modified')
            });
            return false;
        });
        defineGetter(req, 'stale', function() {
            return !this.fresh;
        });
        defineGetter(req, 'xhr', function() {
            var val = this.get('X-Requested-With') || '';
            return 'xmlhttprequest' === val.toLowerCase();
        });
        function defineGetter(obj, name, getter) {
            Object.defineProperty(obj, name, {
                configurable: true,
                enumerable: true,
                get: getter
            });
        }
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/response.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Buffer1 = __webpack_require__("../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer;
        var contentDisposition = __webpack_require__("../node_modules/.pnpm/content-disposition@0.5.4/node_modules/content-disposition/index.js");
        var createError = __webpack_require__("../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js");
        var deprecate = __webpack_require__("../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('express');
        var encodeUrl = __webpack_require__("../node_modules/.pnpm/encodeurl@2.0.0/node_modules/encodeurl/index.js");
        var escapeHtml = __webpack_require__("../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js");
        var http = __webpack_require__("http");
        var isAbsolute = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/utils.js").isAbsolute;
        var onFinished = __webpack_require__("../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js");
        var path = __webpack_require__("path");
        var statuses = __webpack_require__("../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/index.js");
        var merge = __webpack_require__("../node_modules/.pnpm/utils-merge@1.0.1/node_modules/utils-merge/index.js");
        var sign = __webpack_require__("../node_modules/.pnpm/cookie-signature@1.0.6/node_modules/cookie-signature/index.js").sign;
        var normalizeType = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/utils.js").normalizeType;
        var normalizeTypes = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/utils.js").normalizeTypes;
        var setCharset = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/utils.js").setCharset;
        var cookie = __webpack_require__("../node_modules/.pnpm/cookie@0.7.1/node_modules/cookie/index.js");
        var send = __webpack_require__("../node_modules/.pnpm/send@0.19.0/node_modules/send/index.js");
        var extname = path.extname;
        var mime = send.mime;
        var resolve = path.resolve;
        var vary = __webpack_require__("../node_modules/.pnpm/vary@1.1.2/node_modules/vary/index.js");
        var res = Object.create(http.ServerResponse.prototype);
        module.exports = res;
        var charsetRegExp = /;\s*charset\s*=/;
        res.status = function(code) {
            if (('string' == typeof code || Math.floor(code) !== code) && code > 99 && code < 1000) deprecate('res.status(' + JSON.stringify(code) + '): use res.status(' + Math.floor(code) + ') instead');
            this.statusCode = code;
            return this;
        };
        res.links = function(links) {
            var link = this.get('Link') || '';
            if (link) link += ', ';
            return this.set('Link', link + Object.keys(links).map(function(rel) {
                return '<' + links[rel] + '>; rel="' + rel + '"';
            }).join(', '));
        };
        res.send = function(body) {
            var chunk = body;
            var encoding;
            var req = this.req;
            var type;
            var app = this.app;
            if (2 === arguments.length) if ('number' != typeof arguments[0] && 'number' == typeof arguments[1]) {
                deprecate('res.send(body, status): Use res.status(status).send(body) instead');
                this.statusCode = arguments[1];
            } else {
                deprecate('res.send(status, body): Use res.status(status).send(body) instead');
                this.statusCode = arguments[0];
                chunk = arguments[1];
            }
            if ('number' == typeof chunk && 1 === arguments.length) {
                if (!this.get('Content-Type')) this.type('txt');
                deprecate('res.send(status): Use res.sendStatus(status) instead');
                this.statusCode = chunk;
                chunk = statuses.message[chunk];
            }
            switch(typeof chunk){
                case 'string':
                    if (!this.get('Content-Type')) this.type('html');
                    break;
                case 'boolean':
                case 'number':
                case 'object':
                    if (null === chunk) chunk = '';
                    else if (!Buffer1.isBuffer(chunk)) return this.json(chunk);
                    else if (!this.get('Content-Type')) this.type('bin');
                    break;
            }
            if ('string' == typeof chunk) {
                encoding = 'utf8';
                type = this.get('Content-Type');
                if ('string' == typeof type) this.set('Content-Type', setCharset(type, 'utf-8'));
            }
            var etagFn = app.get('etag fn');
            var generateETag = !this.get('ETag') && 'function' == typeof etagFn;
            var len;
            if (void 0 !== chunk) {
                if (Buffer1.isBuffer(chunk)) len = chunk.length;
                else if (!generateETag && chunk.length < 1000) len = Buffer1.byteLength(chunk, encoding);
                else {
                    chunk = Buffer1.from(chunk, encoding);
                    encoding = void 0;
                    len = chunk.length;
                }
                this.set('Content-Length', len);
            }
            var etag;
            if (generateETag && void 0 !== len) {
                if (etag = etagFn(chunk, encoding)) this.set('ETag', etag);
            }
            if (req.fresh) this.statusCode = 304;
            if (204 === this.statusCode || 304 === this.statusCode) {
                this.removeHeader('Content-Type');
                this.removeHeader('Content-Length');
                this.removeHeader('Transfer-Encoding');
                chunk = '';
            }
            if (205 === this.statusCode) {
                this.set('Content-Length', '0');
                this.removeHeader('Transfer-Encoding');
                chunk = '';
            }
            if ('HEAD' === req.method) this.end();
            else this.end(chunk, encoding);
            return this;
        };
        res.json = function(obj) {
            var val = obj;
            if (2 === arguments.length) if ('number' == typeof arguments[1]) {
                deprecate('res.json(obj, status): Use res.status(status).json(obj) instead');
                this.statusCode = arguments[1];
            } else {
                deprecate('res.json(status, obj): Use res.status(status).json(obj) instead');
                this.statusCode = arguments[0];
                val = arguments[1];
            }
            var app = this.app;
            var escape1 = app.get('json escape');
            var replacer = app.get('json replacer');
            var spaces = app.get('json spaces');
            var body = stringify(val, replacer, spaces, escape1);
            if (!this.get('Content-Type')) this.set('Content-Type', 'application/json');
            return this.send(body);
        };
        res.jsonp = function(obj) {
            var val = obj;
            if (2 === arguments.length) if ('number' == typeof arguments[1]) {
                deprecate('res.jsonp(obj, status): Use res.status(status).jsonp(obj) instead');
                this.statusCode = arguments[1];
            } else {
                deprecate('res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead');
                this.statusCode = arguments[0];
                val = arguments[1];
            }
            var app = this.app;
            var escape1 = app.get('json escape');
            var replacer = app.get('json replacer');
            var spaces = app.get('json spaces');
            var body = stringify(val, replacer, spaces, escape1);
            var callback = this.req.query[app.get('jsonp callback name')];
            if (!this.get('Content-Type')) {
                this.set('X-Content-Type-Options', 'nosniff');
                this.set('Content-Type', 'application/json');
            }
            if (Array.isArray(callback)) callback = callback[0];
            if ('string' == typeof callback && 0 !== callback.length) {
                this.set('X-Content-Type-Options', 'nosniff');
                this.set('Content-Type', "text/javascript");
                callback = callback.replace(/[^\[\]\w$.]/g, '');
                if (void 0 === body) body = '';
                else if ('string' == typeof body) body = body.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
                body = '/**/ typeof ' + callback + ' === \'function\' && ' + callback + '(' + body + ');';
            }
            return this.send(body);
        };
        res.sendStatus = function(statusCode) {
            var body = statuses.message[statusCode] || String(statusCode);
            this.statusCode = statusCode;
            this.type('txt');
            return this.send(body);
        };
        res.sendFile = function(path, options, callback) {
            var done = callback;
            var req = this.req;
            var res = this;
            var next = req.next;
            var opts = options || {};
            if (!path) throw new TypeError('path argument is required to res.sendFile');
            if ('string' != typeof path) throw new TypeError('path must be a string to res.sendFile');
            if ('function' == typeof options) {
                done = options;
                opts = {};
            }
            if (!opts.root && !isAbsolute(path)) throw new TypeError('path must be absolute or specify root to res.sendFile');
            var pathname = encodeURI(path);
            var file = send(req, pathname, opts);
            sendfile(res, file, opts, function(err) {
                if (done) return done(err);
                if (err && 'EISDIR' === err.code) return next();
                if (err && 'ECONNABORTED' !== err.code && 'write' !== err.syscall) next(err);
            });
        };
        res.sendfile = function(path, options, callback) {
            var done = callback;
            var req = this.req;
            var res = this;
            var next = req.next;
            var opts = options || {};
            if ('function' == typeof options) {
                done = options;
                opts = {};
            }
            var file = send(req, path, opts);
            sendfile(res, file, opts, function(err) {
                if (done) return done(err);
                if (err && 'EISDIR' === err.code) return next();
                if (err && 'ECONNABORTED' !== err.code && 'write' !== err.syscall) next(err);
            });
        };
        res.sendfile = deprecate.function(res.sendfile, 'res.sendfile: Use res.sendFile instead');
        res.download = function(path, filename, options, callback) {
            var done = callback;
            var name = filename;
            var opts = options || null;
            if ('function' == typeof filename) {
                done = filename;
                name = null;
                opts = null;
            } else if ('function' == typeof options) {
                done = options;
                opts = null;
            }
            if ('object' == typeof filename && ('function' == typeof options || void 0 === options)) {
                name = null;
                opts = filename;
            }
            var headers = {
                'Content-Disposition': contentDisposition(name || path)
            };
            if (opts && opts.headers) {
                var keys = Object.keys(opts.headers);
                for(var i = 0; i < keys.length; i++){
                    var key = keys[i];
                    if ('content-disposition' !== key.toLowerCase()) headers[key] = opts.headers[key];
                }
            }
            opts = Object.create(opts);
            opts.headers = headers;
            var fullPath = opts.root ? path : resolve(path);
            return this.sendFile(fullPath, opts, done);
        };
        res.contentType = res.type = function(type) {
            var ct = -1 === type.indexOf('/') ? mime.lookup(type) : type;
            return this.set('Content-Type', ct);
        };
        res.format = function(obj) {
            var req = this.req;
            var next = req.next;
            var keys = Object.keys(obj).filter(function(v) {
                return 'default' !== v;
            });
            var key = keys.length > 0 ? req.accepts(keys) : false;
            this.vary("Accept");
            if (key) {
                this.set('Content-Type', normalizeType(key).value);
                obj[key](req, this, next);
            } else if (obj.default) obj.default(req, this, next);
            else next(createError(406, {
                types: normalizeTypes(keys).map(function(o) {
                    return o.value;
                })
            }));
            return this;
        };
        res.attachment = function(filename) {
            if (filename) this.type(extname(filename));
            this.set('Content-Disposition', contentDisposition(filename));
            return this;
        };
        res.append = function(field, val) {
            var prev = this.get(field);
            var value = val;
            if (prev) value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [
                prev
            ].concat(val) : [
                prev,
                val
            ];
            return this.set(field, value);
        };
        res.set = res.header = function(field, val) {
            if (2 === arguments.length) {
                var value = Array.isArray(val) ? val.map(String) : String(val);
                if ('content-type' === field.toLowerCase()) {
                    if (Array.isArray(value)) throw new TypeError('Content-Type cannot be set to an Array');
                    if (!charsetRegExp.test(value)) {
                        var charset = mime.charsets.lookup(value.split(';')[0]);
                        if (charset) value += '; charset=' + charset.toLowerCase();
                    }
                }
                this.setHeader(field, value);
            } else for(var key in field)this.set(key, field[key]);
            return this;
        };
        res.get = function(field) {
            return this.getHeader(field);
        };
        res.clearCookie = function(name, options) {
            if (options) {
                if (options.maxAge) deprecate('res.clearCookie: Passing "options.maxAge" is deprecated. In v5.0.0 of Express, this option will be ignored, as res.clearCookie will automatically set cookies to expire immediately. Please update your code to omit this option.');
                if (options.expires) deprecate('res.clearCookie: Passing "options.expires" is deprecated. In v5.0.0 of Express, this option will be ignored, as res.clearCookie will automatically set cookies to expire immediately. Please update your code to omit this option.');
            }
            var opts = merge({
                expires: new Date(1),
                path: '/'
            }, options);
            return this.cookie(name, '', opts);
        };
        res.cookie = function(name, value, options) {
            var opts = merge({}, options);
            var secret = this.req.secret;
            var signed = opts.signed;
            if (signed && !secret) throw new Error('cookieParser("secret") required for signed cookies');
            var val = 'object' == typeof value ? 'j:' + JSON.stringify(value) : String(value);
            if (signed) val = 's:' + sign(val, secret);
            if (null != opts.maxAge) {
                var maxAge = opts.maxAge - 0;
                if (!isNaN(maxAge)) {
                    opts.expires = new Date(Date.now() + maxAge);
                    opts.maxAge = Math.floor(maxAge / 1000);
                }
            }
            if (null == opts.path) opts.path = '/';
            this.append('Set-Cookie', cookie.serialize(name, String(val), opts));
            return this;
        };
        res.location = function(url) {
            var loc;
            if ('back' === url) {
                deprecate('res.location("back"): use res.location(req.get("Referrer") || "/") and refer to https://dub.sh/security-redirect for best practices');
                loc = this.req.get('Referrer') || '/';
            } else loc = String(url);
            return this.set('Location', encodeUrl(loc));
        };
        res.redirect = function(url) {
            var address = url;
            var body;
            var status = 302;
            if (2 === arguments.length) if ('number' == typeof arguments[0]) {
                status = arguments[0];
                address = arguments[1];
            } else {
                deprecate('res.redirect(url, status): Use res.redirect(status, url) instead');
                status = arguments[1];
            }
            address = this.location(address).get('Location');
            this.format({
                text: function() {
                    body = statuses.message[status] + '. Redirecting to ' + address;
                },
                html: function() {
                    var u = escapeHtml(address);
                    body = '<p>' + statuses.message[status] + '. Redirecting to ' + u + '</p>';
                },
                default: function() {
                    body = '';
                }
            });
            this.statusCode = status;
            this.set('Content-Length', Buffer1.byteLength(body));
            if ('HEAD' === this.req.method) this.end();
            else this.end(body);
        };
        res.vary = function(field) {
            if (!field || Array.isArray(field) && !field.length) {
                deprecate('res.vary(): Provide a field name');
                return this;
            }
            vary(this, field);
            return this;
        };
        res.render = function(view, options, callback) {
            var app = this.req.app;
            var done = callback;
            var opts = options || {};
            var req = this.req;
            var self = this;
            if ('function' == typeof options) {
                done = options;
                opts = {};
            }
            opts._locals = self.locals;
            done = done || function(err, str) {
                if (err) return req.next(err);
                self.send(str);
            };
            app.render(view, opts, done);
        };
        function sendfile(res, file, options, callback) {
            var done = false;
            var streaming;
            function onaborted() {
                if (done) return;
                done = true;
                var err = new Error('Request aborted');
                err.code = 'ECONNABORTED';
                callback(err);
            }
            function ondirectory() {
                if (done) return;
                done = true;
                var err = new Error('EISDIR, read');
                err.code = 'EISDIR';
                callback(err);
            }
            function onerror(err) {
                if (done) return;
                done = true;
                callback(err);
            }
            function onend() {
                if (done) return;
                done = true;
                callback();
            }
            function onfile() {
                streaming = false;
            }
            function onfinish(err) {
                if (err && 'ECONNRESET' === err.code) return onaborted();
                if (err) return onerror(err);
                if (done) return;
                setImmediate(function() {
                    if (false !== streaming && !done) return void onaborted();
                    if (done) return;
                    done = true;
                    callback();
                });
            }
            function onstream() {
                streaming = true;
            }
            file.on('directory', ondirectory);
            file.on('end', onend);
            file.on('error', onerror);
            file.on('file', onfile);
            file.on('stream', onstream);
            onFinished(res, onfinish);
            if (options.headers) file.on('headers', function(res) {
                var obj = options.headers;
                var keys = Object.keys(obj);
                for(var i = 0; i < keys.length; i++){
                    var k = keys[i];
                    res.setHeader(k, obj[k]);
                }
            });
            file.pipe(res);
        }
        function stringify(value, replacer, spaces, escape1) {
            var json = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
            if (escape1 && 'string' == typeof json) json = json.replace(/[<>&]/g, function(c) {
                switch(c.charCodeAt(0)){
                    case 0x3c:
                        return '\\u003c';
                    case 0x3e:
                        return '\\u003e';
                    case 0x26:
                        return '\\u0026';
                    default:
                        return c;
                }
            });
            return json;
        }
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Route = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/route.js");
        var Layer = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/layer.js");
        var methods = __webpack_require__("../node_modules/.pnpm/methods@1.1.2/node_modules/methods/index.js");
        var mixin = __webpack_require__("../node_modules/.pnpm/utils-merge@1.0.1/node_modules/utils-merge/index.js");
        var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('express:router');
        var deprecate = __webpack_require__("../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('express');
        var flatten = __webpack_require__("../node_modules/.pnpm/array-flatten@1.1.1/node_modules/array-flatten/array-flatten.js");
        var parseUrl = __webpack_require__("../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js");
        var setPrototypeOf = __webpack_require__("../node_modules/.pnpm/setprototypeof@1.2.0/node_modules/setprototypeof/index.js");
        var objectRegExp = /^\[object (\S+)\]$/;
        var slice = Array.prototype.slice;
        var toString = Object.prototype.toString;
        var proto = module.exports = function(options) {
            var opts = options || {};
            function router(req, res, next) {
                router.handle(req, res, next);
            }
            setPrototypeOf(router, proto);
            router.params = {};
            router._params = [];
            router.caseSensitive = opts.caseSensitive;
            router.mergeParams = opts.mergeParams;
            router.strict = opts.strict;
            router.stack = [];
            return router;
        };
        proto.param = function(name, fn) {
            if ('function' == typeof name) {
                deprecate('router.param(fn): Refactor to use path params');
                this._params.push(name);
                return;
            }
            var params = this._params;
            var len = params.length;
            var ret;
            if (':' === name[0]) {
                deprecate('router.param(' + JSON.stringify(name) + ', fn): Use router.param(' + JSON.stringify(name.slice(1)) + ', fn) instead');
                name = name.slice(1);
            }
            for(var i = 0; i < len; ++i)if (ret = params[i](name, fn)) fn = ret;
            if ('function' != typeof fn) throw new Error('invalid param() call for ' + name + ', got ' + fn);
            (this.params[name] = this.params[name] || []).push(fn);
            return this;
        };
        proto.handle = function(req, res, out) {
            var self = this;
            debug('dispatching %s %s', req.method, req.url);
            var idx = 0;
            var protohost = getProtohost(req.url) || '';
            var removed = '';
            var slashAdded = false;
            var sync = 0;
            var paramcalled = {};
            var options = [];
            var stack = self.stack;
            var parentParams = req.params;
            var parentUrl = req.baseUrl || '';
            var done = restore(out, req, 'baseUrl', 'next', 'params');
            req.next = next;
            if ('OPTIONS' === req.method) done = wrap(done, function(old, err) {
                if (err || 0 === options.length) return old(err);
                sendOptionsResponse(res, options, old);
            });
            req.baseUrl = parentUrl;
            req.originalUrl = req.originalUrl || req.url;
            next();
            function next(err) {
                var layerError = 'route' === err ? null : err;
                if (slashAdded) {
                    req.url = req.url.slice(1);
                    slashAdded = false;
                }
                if (0 !== removed.length) {
                    req.baseUrl = parentUrl;
                    req.url = protohost + removed + req.url.slice(protohost.length);
                    removed = '';
                }
                if ('router' === layerError) return void setImmediate(done, null);
                if (idx >= stack.length) return void setImmediate(done, layerError);
                if (++sync > 100) return setImmediate(next, err);
                var path = getPathname(req);
                if (null == path) return done(layerError);
                var layer;
                var match;
                var route;
                while(true !== match && idx < stack.length){
                    layer = stack[idx++];
                    match = matchLayer(layer, path);
                    route = layer.route;
                    if ('boolean' != typeof match) layerError = layerError || match;
                    if (true !== match) continue;
                    if (!route) continue;
                    if (layerError) {
                        match = false;
                        continue;
                    }
                    var method = req.method;
                    var has_method = route._handles_method(method);
                    if (!has_method && 'OPTIONS' === method) appendMethods(options, route._options());
                    if (!has_method && 'HEAD' !== method) match = false;
                }
                if (true !== match) return done(layerError);
                if (route) req.route = route;
                req.params = self.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;
                var layerPath = layer.path;
                self.process_params(layer, paramcalled, req, res, function(err) {
                    if (err) next(layerError || err);
                    else if (route) layer.handle_request(req, res, next);
                    else trim_prefix(layer, layerError, layerPath, path);
                    sync = 0;
                });
            }
            function trim_prefix(layer, layerError, layerPath, path) {
                if (0 !== layerPath.length) {
                    if (layerPath !== path.slice(0, layerPath.length)) return void next(layerError);
                    var c = path[layerPath.length];
                    if (c && '/' !== c && '.' !== c) return next(layerError);
                    debug('trim prefix (%s) from url %s', layerPath, req.url);
                    removed = layerPath;
                    req.url = protohost + req.url.slice(protohost.length + removed.length);
                    if (!protohost && '/' !== req.url[0]) {
                        req.url = '/' + req.url;
                        slashAdded = true;
                    }
                    req.baseUrl = parentUrl + ('/' === removed[removed.length - 1] ? removed.substring(0, removed.length - 1) : removed);
                }
                debug('%s %s : %s', layer.name, layerPath, req.originalUrl);
                if (layerError) layer.handle_error(layerError, req, res, next);
                else layer.handle_request(req, res, next);
            }
        };
        proto.process_params = function(layer, called, req, res, done) {
            var params = this.params;
            var keys = layer.keys;
            if (!keys || 0 === keys.length) return done();
            var i = 0;
            var name;
            var paramIndex = 0;
            var key;
            var paramVal;
            var paramCallbacks;
            var paramCalled;
            function param(err) {
                if (err) return done(err);
                if (i >= keys.length) return done();
                paramIndex = 0;
                key = keys[i++];
                name = key.name;
                paramVal = req.params[name];
                paramCallbacks = params[name];
                paramCalled = called[name];
                if (void 0 === paramVal || !paramCallbacks) return param();
                if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && 'route' !== paramCalled.error)) {
                    req.params[name] = paramCalled.value;
                    return param(paramCalled.error);
                }
                called[name] = paramCalled = {
                    error: null,
                    match: paramVal,
                    value: paramVal
                };
                paramCallback();
            }
            function paramCallback(err) {
                var fn = paramCallbacks[paramIndex++];
                paramCalled.value = req.params[key.name];
                if (err) {
                    paramCalled.error = err;
                    param(err);
                    return;
                }
                if (!fn) return param();
                try {
                    fn(req, res, paramCallback, paramVal, key.name);
                } catch (e) {
                    paramCallback(e);
                }
            }
            param();
        };
        proto.use = function(fn) {
            var offset = 0;
            var path = '/';
            if ('function' != typeof fn) {
                var arg = fn;
                while(Array.isArray(arg) && 0 !== arg.length)arg = arg[0];
                if ('function' != typeof arg) {
                    offset = 1;
                    path = fn;
                }
            }
            var callbacks = flatten(slice.call(arguments, offset));
            if (0 === callbacks.length) throw new TypeError('Router.use() requires a middleware function');
            for(var i = 0; i < callbacks.length; i++){
                var fn = callbacks[i];
                if ('function' != typeof fn) throw new TypeError('Router.use() requires a middleware function but got a ' + gettype(fn));
                debug('use %o %s', path, fn.name || '<anonymous>');
                var layer = new Layer(path, {
                    sensitive: this.caseSensitive,
                    strict: false,
                    end: false
                }, fn);
                layer.route = void 0;
                this.stack.push(layer);
            }
            return this;
        };
        proto.route = function(path) {
            var route = new Route(path);
            var layer = new Layer(path, {
                sensitive: this.caseSensitive,
                strict: this.strict,
                end: true
            }, route.dispatch.bind(route));
            layer.route = route;
            this.stack.push(layer);
            return route;
        };
        methods.concat('all').forEach(function(method) {
            proto[method] = function(path) {
                var route = this.route(path);
                route[method].apply(route, slice.call(arguments, 1));
                return this;
            };
        });
        function appendMethods(list, addition) {
            for(var i = 0; i < addition.length; i++){
                var method = addition[i];
                if (-1 === list.indexOf(method)) list.push(method);
            }
        }
        function getPathname(req) {
            try {
                return parseUrl(req).pathname;
            } catch (err) {
                return;
            }
        }
        function getProtohost(url) {
            if ('string' != typeof url || 0 === url.length || '/' === url[0]) return;
            var searchIndex = url.indexOf('?');
            var pathLength = -1 !== searchIndex ? searchIndex : url.length;
            var fqdnIndex = url.slice(0, pathLength).indexOf('://');
            return -1 !== fqdnIndex ? url.substring(0, url.indexOf('/', 3 + fqdnIndex)) : void 0;
        }
        function gettype(obj) {
            var type = typeof obj;
            if ('object' !== type) return type;
            return toString.call(obj).replace(objectRegExp, '$1');
        }
        function matchLayer(layer, path) {
            try {
                return layer.match(path);
            } catch (err) {
                return err;
            }
        }
        function mergeParams(params, parent) {
            if ('object' != typeof parent || !parent) return params;
            var obj = mixin({}, parent);
            if (!(0 in params) || !(0 in parent)) return mixin(obj, params);
            var i = 0;
            var o = 0;
            while(i in params)i++;
            while(o in parent)o++;
            for(i--; i >= 0; i--){
                params[i + o] = params[i];
                if (i < o) delete params[i];
            }
            return mixin(obj, params);
        }
        function restore(fn, obj) {
            var props = new Array(arguments.length - 2);
            var vals = new Array(arguments.length - 2);
            for(var i = 0; i < props.length; i++){
                props[i] = arguments[i + 2];
                vals[i] = obj[props[i]];
            }
            return function() {
                for(var i = 0; i < props.length; i++)obj[props[i]] = vals[i];
                return fn.apply(this, arguments);
            };
        }
        function sendOptionsResponse(res, options, next) {
            try {
                var body = options.join(',');
                res.set('Allow', body);
                res.send(body);
            } catch (err) {
                next(err);
            }
        }
        function wrap(old, fn) {
            return function() {
                var args = new Array(arguments.length + 1);
                args[0] = old;
                for(var i = 0, len = arguments.length; i < len; i++)args[i + 1] = arguments[i];
                fn.apply(this, args);
            };
        }
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/layer.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var pathRegexp = __webpack_require__("../node_modules/.pnpm/path-to-regexp@0.1.12/node_modules/path-to-regexp/index.js");
        var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('express:router:layer');
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        module.exports = Layer;
        function Layer(path, options, fn) {
            if (!(this instanceof Layer)) return new Layer(path, options, fn);
            debug('new %o', path);
            var opts = options || {};
            this.handle = fn;
            this.name = fn.name || '<anonymous>';
            this.params = void 0;
            this.path = void 0;
            this.regexp = pathRegexp(path, this.keys = [], opts);
            this.regexp.fast_star = '*' === path;
            this.regexp.fast_slash = '/' === path && false === opts.end;
        }
        Layer.prototype.handle_error = function(error, req, res, next) {
            var fn = this.handle;
            if (4 !== fn.length) return next(error);
            try {
                fn(error, req, res, next);
            } catch (err) {
                next(err);
            }
        };
        Layer.prototype.handle_request = function(req, res, next) {
            var fn = this.handle;
            if (fn.length > 3) return next();
            try {
                fn(req, res, next);
            } catch (err) {
                next(err);
            }
        };
        Layer.prototype.match = function(path) {
            var match;
            if (null != path) {
                if (this.regexp.fast_slash) {
                    this.params = {};
                    this.path = '';
                    return true;
                }
                if (this.regexp.fast_star) {
                    this.params = {
                        0: decode_param(path)
                    };
                    this.path = path;
                    return true;
                }
                match = this.regexp.exec(path);
            }
            if (!match) {
                this.params = void 0;
                this.path = void 0;
                return false;
            }
            this.params = {};
            this.path = match[0];
            var keys = this.keys;
            var params = this.params;
            for(var i = 1; i < match.length; i++){
                var key = keys[i - 1];
                var prop = key.name;
                var val = decode_param(match[i]);
                if (void 0 !== val || !hasOwnProperty.call(params, prop)) params[prop] = val;
            }
            return true;
        };
        function decode_param(val) {
            if ('string' != typeof val || 0 === val.length) return val;
            try {
                return decodeURIComponent(val);
            } catch (err) {
                if (err instanceof URIError) {
                    err.message = 'Failed to decode param \'' + val + '\'';
                    err.status = err.statusCode = 400;
                }
                throw err;
            }
        }
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/route.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('express:router:route');
        var flatten = __webpack_require__("../node_modules/.pnpm/array-flatten@1.1.1/node_modules/array-flatten/array-flatten.js");
        var Layer = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/layer.js");
        var methods = __webpack_require__("../node_modules/.pnpm/methods@1.1.2/node_modules/methods/index.js");
        var slice = Array.prototype.slice;
        var toString = Object.prototype.toString;
        module.exports = Route;
        function Route(path) {
            this.path = path;
            this.stack = [];
            debug('new %o', path);
            this.methods = {};
        }
        Route.prototype._handles_method = function(method) {
            if (this.methods._all) return true;
            var name = 'string' == typeof method ? method.toLowerCase() : method;
            if ('head' === name && !this.methods['head']) name = 'get';
            return Boolean(this.methods[name]);
        };
        Route.prototype._options = function() {
            var methods = Object.keys(this.methods);
            if (this.methods.get && !this.methods.head) methods.push('head');
            for(var i = 0; i < methods.length; i++)methods[i] = methods[i].toUpperCase();
            return methods;
        };
        Route.prototype.dispatch = function(req, res, done) {
            var idx = 0;
            var stack = this.stack;
            var sync = 0;
            if (0 === stack.length) return done();
            var method = 'string' == typeof req.method ? req.method.toLowerCase() : req.method;
            if ('head' === method && !this.methods['head']) method = 'get';
            req.route = this;
            next();
            function next(err) {
                if (err && 'route' === err) return done();
                if (err && 'router' === err) return done(err);
                if (++sync > 100) return setImmediate(next, err);
                var layer = stack[idx++];
                if (!layer) return done(err);
                if (layer.method && layer.method !== method) next(err);
                else if (err) layer.handle_error(err, req, res, next);
                else layer.handle_request(req, res, next);
                sync = 0;
            }
        };
        Route.prototype.all = function() {
            var handles = flatten(slice.call(arguments));
            for(var i = 0; i < handles.length; i++){
                var handle = handles[i];
                if ('function' != typeof handle) {
                    var type = toString.call(handle);
                    var msg = 'Route.all() requires a callback function but got a ' + type;
                    throw new TypeError(msg);
                }
                var layer = Layer('/', {}, handle);
                layer.method = void 0;
                this.methods._all = true;
                this.stack.push(layer);
            }
            return this;
        };
        methods.forEach(function(method) {
            Route.prototype[method] = function() {
                var handles = flatten(slice.call(arguments));
                for(var i = 0; i < handles.length; i++){
                    var handle = handles[i];
                    if ('function' != typeof handle) {
                        var type = toString.call(handle);
                        var msg = 'Route.' + method + '() requires a callback function but got a ' + type;
                        throw new Error(msg);
                    }
                    debug('%s %o', method, this.path);
                    var layer = Layer('/', {}, handle);
                    layer.method = method;
                    this.methods[method] = true;
                    this.stack.push(layer);
                }
                return this;
            };
        });
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/utils.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Buffer1 = __webpack_require__("../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer;
        var contentDisposition = __webpack_require__("../node_modules/.pnpm/content-disposition@0.5.4/node_modules/content-disposition/index.js");
        var contentType = __webpack_require__("../node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js");
        var deprecate = __webpack_require__("../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('express');
        var flatten = __webpack_require__("../node_modules/.pnpm/array-flatten@1.1.1/node_modules/array-flatten/array-flatten.js");
        var mime = __webpack_require__("../node_modules/.pnpm/send@0.19.0/node_modules/send/index.js").mime;
        var etag = __webpack_require__("../node_modules/.pnpm/etag@1.8.1/node_modules/etag/index.js");
        var proxyaddr = __webpack_require__("../node_modules/.pnpm/proxy-addr@2.0.7/node_modules/proxy-addr/index.js");
        var qs = __webpack_require__("../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/index.js");
        var querystring = __webpack_require__("querystring");
        exports1.etag = createETagGenerator({
            weak: false
        });
        exports1.wetag = createETagGenerator({
            weak: true
        });
        exports1.isAbsolute = function(path) {
            if ('/' === path[0]) return true;
            if (':' === path[1] && ('\\' === path[2] || '/' === path[2])) return true;
            if ('\\\\' === path.substring(0, 2)) return true;
        };
        exports1.flatten = deprecate.function(flatten, 'utils.flatten: use array-flatten npm module instead');
        exports1.normalizeType = function(type) {
            return ~type.indexOf('/') ? acceptParams(type) : {
                value: mime.lookup(type),
                params: {}
            };
        };
        exports1.normalizeTypes = function(types) {
            var ret = [];
            for(var i = 0; i < types.length; ++i)ret.push(exports1.normalizeType(types[i]));
            return ret;
        };
        exports1.contentDisposition = deprecate.function(contentDisposition, 'utils.contentDisposition: use content-disposition npm module instead');
        function acceptParams(str) {
            var parts = str.split(/ *; */);
            var ret = {
                value: parts[0],
                quality: 1,
                params: {}
            };
            for(var i = 1; i < parts.length; ++i){
                var pms = parts[i].split(/ *= */);
                if ('q' === pms[0]) ret.quality = parseFloat(pms[1]);
                else ret.params[pms[0]] = pms[1];
            }
            return ret;
        }
        exports1.compileETag = function(val) {
            var fn;
            if ('function' == typeof val) return val;
            switch(val){
                case true:
                case 'weak':
                    fn = exports1.wetag;
                    break;
                case false:
                    break;
                case 'strong':
                    fn = exports1.etag;
                    break;
                default:
                    throw new TypeError('unknown value for etag function: ' + val);
            }
            return fn;
        };
        exports1.compileQueryParser = function(val) {
            var fn;
            if ('function' == typeof val) return val;
            switch(val){
                case true:
                case 'simple':
                    fn = querystring.parse;
                    break;
                case false:
                    fn = newObject;
                    break;
                case 'extended':
                    fn = parseExtendedQueryString;
                    break;
                default:
                    throw new TypeError('unknown value for query parser function: ' + val);
            }
            return fn;
        };
        exports1.compileTrust = function(val) {
            if ('function' == typeof val) return val;
            if (true === val) return function() {
                return true;
            };
            if ('number' == typeof val) return function(a, i) {
                return i < val;
            };
            if ('string' == typeof val) val = val.split(',').map(function(v) {
                return v.trim();
            });
            return proxyaddr.compile(val || []);
        };
        exports1.setCharset = function(type, charset) {
            if (!type || !charset) return type;
            var parsed = contentType.parse(type);
            parsed.parameters.charset = charset;
            return contentType.format(parsed);
        };
        function createETagGenerator(options) {
            return function(body, encoding) {
                var buf = Buffer1.isBuffer(body) ? body : Buffer1.from(body, encoding);
                return etag(buf, options);
            };
        }
        function parseExtendedQueryString(str) {
            return qs.parse(str, {
                allowPrototypes: true
            });
        }
        function newObject() {
            return {};
        }
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/view.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('express:view');
        var path = __webpack_require__("path");
        var fs = __webpack_require__("fs");
        var dirname = path.dirname;
        var basename = path.basename;
        var extname = path.extname;
        var join = path.join;
        var resolve = path.resolve;
        module.exports = View;
        function View(name, options) {
            var opts = options || {};
            this.defaultEngine = opts.defaultEngine;
            this.ext = extname(name);
            this.name = name;
            this.root = opts.root;
            if (!this.ext && !this.defaultEngine) throw new Error('No default engine was specified and no extension was provided.');
            var fileName = name;
            if (!this.ext) {
                this.ext = '.' !== this.defaultEngine[0] ? '.' + this.defaultEngine : this.defaultEngine;
                fileName += this.ext;
            }
            if (!opts.engines[this.ext]) {
                var mod = this.ext.slice(1);
                debug('require "%s"', mod);
                var fn = require(mod).__express;
                if ('function' != typeof fn) throw new Error('Module "' + mod + '" does not provide a view engine.');
                opts.engines[this.ext] = fn;
            }
            this.engine = opts.engines[this.ext];
            this.path = this.lookup(fileName);
        }
        View.prototype.lookup = function(name) {
            var path;
            var roots = [].concat(this.root);
            debug('lookup "%s"', name);
            for(var i = 0; i < roots.length && !path; i++){
                var root = roots[i];
                var loc = resolve(root, name);
                var dir = dirname(loc);
                var file = basename(loc);
                path = this.resolve(dir, file);
            }
            return path;
        };
        View.prototype.render = function(options, callback) {
            debug('render "%s"', this.path);
            this.engine(this.path, options, callback);
        };
        View.prototype.resolve = function(dir, file) {
            var ext = this.ext;
            var path = join(dir, file);
            var stat = tryStat(path);
            if (stat && stat.isFile()) return path;
            path = join(dir, basename(file, ext), 'index' + ext);
            stat = tryStat(path);
            if (stat && stat.isFile()) return path;
        };
        function tryStat(path) {
            debug('stat "%s"', path);
            try {
                return fs.statSync(path);
            } catch (e) {
                return;
            }
        }
    },
    "../node_modules/.pnpm/fast-json-stable-stringify@2.1.0/node_modules/fast-json-stable-stringify/index.js": function(module) {
        "use strict";
        module.exports = function(data, opts) {
            if (!opts) opts = {};
            if ('function' == typeof opts) opts = {
                cmp: opts
            };
            var cycles = 'boolean' == typeof opts.cycles ? opts.cycles : false;
            var cmp = opts.cmp && function(f) {
                return function(node) {
                    return function(a, b) {
                        var aobj = {
                            key: a,
                            value: node[a]
                        };
                        var bobj = {
                            key: b,
                            value: node[b]
                        };
                        return f(aobj, bobj);
                    };
                };
            }(opts.cmp);
            var seen = [];
            return function stringify(node) {
                if (node && node.toJSON && 'function' == typeof node.toJSON) node = node.toJSON();
                if (void 0 === node) return;
                if ('number' == typeof node) return isFinite(node) ? '' + node : 'null';
                if ('object' != typeof node) return JSON.stringify(node);
                var i, out;
                if (Array.isArray(node)) {
                    out = '[';
                    for(i = 0; i < node.length; i++){
                        if (i) out += ',';
                        out += stringify(node[i]) || 'null';
                    }
                    return out + ']';
                }
                if (null === node) return 'null';
                if (-1 !== seen.indexOf(node)) {
                    if (cycles) return JSON.stringify('__cycle__');
                    throw new TypeError('Converting circular structure to JSON');
                }
                var seenIndex = seen.push(node) - 1;
                var keys = Object.keys(node).sort(cmp && cmp(node));
                out = '';
                for(i = 0; i < keys.length; i++){
                    var key = keys[i];
                    var value = stringify(node[key]);
                    if (value) {
                        if (out) out += ',';
                        out += JSON.stringify(key) + ':' + value;
                    }
                }
                seen.splice(seenIndex, 1);
                return '{' + out + '}';
            }(data);
        };
    },
    "../node_modules/.pnpm/finalhandler@1.3.1/node_modules/finalhandler/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * finalhandler
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('finalhandler');
        var encodeUrl = __webpack_require__("../node_modules/.pnpm/encodeurl@2.0.0/node_modules/encodeurl/index.js");
        var escapeHtml = __webpack_require__("../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js");
        var onFinished = __webpack_require__("../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js");
        var parseUrl = __webpack_require__("../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js");
        var statuses = __webpack_require__("../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/index.js");
        var unpipe = __webpack_require__("../node_modules/.pnpm/unpipe@1.0.0/node_modules/unpipe/index.js");
        var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
        var NEWLINE_REGEXP = /\n/g;
        var defer = 'function' == typeof setImmediate ? setImmediate : function(fn) {
            process.nextTick(fn.bind.apply(fn, arguments));
        };
        var isFinished = onFinished.isFinished;
        function createHtmlDocument(message) {
            var body = escapeHtml(message).replace(NEWLINE_REGEXP, '<br>').replace(DOUBLE_SPACE_REGEXP, ' &nbsp;');
            return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
        }
        module.exports = finalhandler;
        function finalhandler(req, res, options) {
            var opts = options || {};
            var env = opts.env || process.env.NODE_ENV || 'development';
            var onerror = opts.onerror;
            return function(err) {
                var headers;
                var msg;
                var status;
                if (!err && headersSent(res)) return void debug('cannot 404 after headers sent');
                if (err) {
                    status = getErrorStatusCode(err);
                    if (void 0 === status) status = getResponseStatusCode(res);
                    else headers = getErrorHeaders(err);
                    msg = getErrorMessage(err, status, env);
                } else {
                    status = 404;
                    msg = 'Cannot ' + req.method + ' ' + encodeUrl(getResourceName(req));
                }
                debug('default %s', status);
                if (err && onerror) defer(onerror, err, req, res);
                if (headersSent(res)) {
                    debug('cannot %d after headers sent', status);
                    if (req.socket) req.socket.destroy();
                    return;
                }
                send(req, res, status, headers, msg);
            };
        }
        function getErrorHeaders(err) {
            if (!err.headers || 'object' != typeof err.headers) return;
            var headers = Object.create(null);
            var keys = Object.keys(err.headers);
            for(var i = 0; i < keys.length; i++){
                var key = keys[i];
                headers[key] = err.headers[key];
            }
            return headers;
        }
        function getErrorMessage(err, status, env) {
            var msg;
            if ('production' !== env) {
                msg = err.stack;
                if (!msg && 'function' == typeof err.toString) msg = err.toString();
            }
            return msg || statuses.message[status];
        }
        function getErrorStatusCode(err) {
            if ('number' == typeof err.status && err.status >= 400 && err.status < 600) return err.status;
            if ('number' == typeof err.statusCode && err.statusCode >= 400 && err.statusCode < 600) return err.statusCode;
        }
        function getResourceName(req) {
            try {
                return parseUrl.original(req).pathname;
            } catch (e) {
                return 'resource';
            }
        }
        function getResponseStatusCode(res) {
            var status = res.statusCode;
            if ('number' != typeof status || status < 400 || status > 599) status = 500;
            return status;
        }
        function headersSent(res) {
            return 'boolean' != typeof res.headersSent ? Boolean(res._header) : res.headersSent;
        }
        function send(req, res, status, headers, message) {
            function write() {
                var body = createHtmlDocument(message);
                res.statusCode = status;
                if (req.httpVersionMajor < 2) res.statusMessage = statuses.message[status];
                res.removeHeader('Content-Encoding');
                res.removeHeader('Content-Language');
                res.removeHeader('Content-Range');
                setHeaders(res, headers);
                res.setHeader('Content-Security-Policy', "default-src 'none'");
                res.setHeader('X-Content-Type-Options', 'nosniff');
                res.setHeader('Content-Type', 'text/html; charset=utf-8');
                res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'));
                if ('HEAD' === req.method) return void res.end();
                res.end(body, 'utf8');
            }
            if (isFinished(req)) return void write();
            unpipe(req);
            onFinished(req, write);
            req.resume();
        }
        function setHeaders(res, headers) {
            if (!headers) return;
            var keys = Object.keys(headers);
            for(var i = 0; i < keys.length; i++){
                var key = keys[i];
                res.setHeader(key, headers[key]);
            }
        }
    },
    "../node_modules/.pnpm/forwarded@0.2.0/node_modules/forwarded/index.js": function(module) {
        "use strict";
        /*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = forwarded;
        function forwarded(req) {
            if (!req) throw new TypeError('argument req is required');
            var proxyAddrs = parse(req.headers['x-forwarded-for'] || '');
            var socketAddr = getSocketAddr(req);
            var addrs = [
                socketAddr
            ].concat(proxyAddrs);
            return addrs;
        }
        function getSocketAddr(req) {
            return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
        }
        function parse(header) {
            var end = header.length;
            var list = [];
            var start = header.length;
            for(var i = header.length - 1; i >= 0; i--)switch(header.charCodeAt(i)){
                case 0x20:
                    if (start === end) start = end = i;
                    break;
                case 0x2c:
                    if (start !== end) list.push(header.substring(start, end));
                    start = end = i;
                    break;
                default:
                    start = i;
                    break;
            }
            if (start !== end) list.push(header.substring(start, end));
            return list;
        }
    },
    "../node_modules/.pnpm/fresh@0.5.2/node_modules/fresh/index.js": function(module) {
        "use strict";
        /*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
        module.exports = fresh;
        function fresh(reqHeaders, resHeaders) {
            var modifiedSince = reqHeaders['if-modified-since'];
            var noneMatch = reqHeaders['if-none-match'];
            if (!modifiedSince && !noneMatch) return false;
            var cacheControl = reqHeaders['cache-control'];
            if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) return false;
            if (noneMatch && '*' !== noneMatch) {
                var etag = resHeaders['etag'];
                if (!etag) return false;
                var etagStale = true;
                var matches = parseTokenList(noneMatch);
                for(var i = 0; i < matches.length; i++){
                    var match = matches[i];
                    if (match === etag || match === 'W/' + etag || 'W/' + match === etag) {
                        etagStale = false;
                        break;
                    }
                }
                if (etagStale) return false;
            }
            if (modifiedSince) {
                var lastModified = resHeaders['last-modified'];
                var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));
                if (modifiedStale) return false;
            }
            return true;
        }
        function parseHttpDate(date) {
            var timestamp = date && Date.parse(date);
            return 'number' == typeof timestamp ? timestamp : NaN;
        }
        function parseTokenList(str) {
            var end = 0;
            var list = [];
            var start = 0;
            for(var i = 0, len = str.length; i < len; i++)switch(str.charCodeAt(i)){
                case 0x20:
                    if (start === end) start = end = i + 1;
                    break;
                case 0x2c:
                    list.push(str.substring(start, end));
                    start = end = i + 1;
                    break;
                default:
                    end = i + 1;
                    break;
            }
            list.push(str.substring(start, end));
            return list;
        }
    },
    "../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js": function(module) {
        "use strict";
        var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
        var toStr = Object.prototype.toString;
        var max = Math.max;
        var funcType = '[object Function]';
        var concatty = function(a, b) {
            var arr = [];
            for(var i = 0; i < a.length; i += 1)arr[i] = a[i];
            for(var j = 0; j < b.length; j += 1)arr[j + a.length] = b[j];
            return arr;
        };
        var slicy = function(arrLike, offset) {
            var arr = [];
            for(var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1)arr[j] = arrLike[i];
            return arr;
        };
        var joiny = function(arr, joiner) {
            var str = '';
            for(var i = 0; i < arr.length; i += 1){
                str += arr[i];
                if (i + 1 < arr.length) str += joiner;
            }
            return str;
        };
        module.exports = function(that) {
            var target = this;
            if ('function' != typeof target || toStr.apply(target) !== funcType) throw new TypeError(ERROR_MESSAGE + target);
            var args = slicy(arguments, 1);
            var bound;
            var binder = function() {
                if (this instanceof bound) {
                    var result = target.apply(this, concatty(args, arguments));
                    if (Object(result) === result) return result;
                    return this;
                }
                return target.apply(that, concatty(args, arguments));
            };
            var boundLength = max(0, target.length - args.length);
            var boundArgs = [];
            for(var i = 0; i < boundLength; i++)boundArgs[i] = '$' + i;
            bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
            if (target.prototype) {
                var Empty = function() {};
                Empty.prototype = target.prototype;
                bound.prototype = new Empty();
                Empty.prototype = null;
            }
            return bound;
        };
    },
    "../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var implementation = __webpack_require__("../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js");
        module.exports = Function.prototype.bind || implementation;
    },
    "../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var undefined;
        var $Object = __webpack_require__("../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js");
        var $Error = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js");
        var $EvalError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js");
        var $RangeError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js");
        var $ReferenceError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js");
        var $SyntaxError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js");
        var $TypeError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
        var $URIError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js");
        var abs = __webpack_require__("../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js");
        var floor = __webpack_require__("../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js");
        var max = __webpack_require__("../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js");
        var min = __webpack_require__("../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js");
        var pow = __webpack_require__("../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js");
        var round = __webpack_require__("../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js");
        var sign = __webpack_require__("../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js");
        var $Function = Function;
        var getEvalledConstructor = function(expressionSyntax) {
            try {
                return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
            } catch (e) {}
        };
        var $gOPD = __webpack_require__("../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");
        var $defineProperty = __webpack_require__("../node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js");
        var throwTypeError = function() {
            throw new $TypeError();
        };
        var ThrowTypeError = $gOPD ? function() {
            try {
                arguments.callee;
                return throwTypeError;
            } catch (calleeThrows) {
                try {
                    return $gOPD(arguments, 'callee').get;
                } catch (gOPDthrows) {
                    return throwTypeError;
                }
            }
        }() : throwTypeError;
        var hasSymbols = __webpack_require__("../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js")();
        var getProto = __webpack_require__("../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js");
        var $ObjectGPO = __webpack_require__("../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js");
        var $ReflectGPO = __webpack_require__("../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js");
        var $apply = __webpack_require__("../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js");
        var $call = __webpack_require__("../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js");
        var needsEval = {};
        var TypedArray = 'undefined' != typeof Uint8Array && getProto ? getProto(Uint8Array) : undefined;
        var INTRINSICS = {
            __proto__: null,
            '%AggregateError%': 'undefined' == typeof AggregateError ? undefined : AggregateError,
            '%Array%': Array,
            '%ArrayBuffer%': 'undefined' == typeof ArrayBuffer ? undefined : ArrayBuffer,
            '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
            '%AsyncFromSyncIteratorPrototype%': undefined,
            '%AsyncFunction%': needsEval,
            '%AsyncGenerator%': needsEval,
            '%AsyncGeneratorFunction%': needsEval,
            '%AsyncIteratorPrototype%': needsEval,
            '%Atomics%': 'undefined' == typeof Atomics ? undefined : Atomics,
            '%BigInt%': 'undefined' == typeof BigInt ? undefined : BigInt,
            '%BigInt64Array%': 'undefined' == typeof BigInt64Array ? undefined : BigInt64Array,
            '%BigUint64Array%': 'undefined' == typeof BigUint64Array ? undefined : BigUint64Array,
            '%Boolean%': Boolean,
            '%DataView%': 'undefined' == typeof DataView ? undefined : DataView,
            '%Date%': Date,
            '%decodeURI%': decodeURI,
            '%decodeURIComponent%': decodeURIComponent,
            '%encodeURI%': encodeURI,
            '%encodeURIComponent%': encodeURIComponent,
            '%Error%': $Error,
            '%eval%': eval,
            '%EvalError%': $EvalError,
            '%Float16Array%': 'undefined' == typeof Float16Array ? undefined : Float16Array,
            '%Float32Array%': 'undefined' == typeof Float32Array ? undefined : Float32Array,
            '%Float64Array%': 'undefined' == typeof Float64Array ? undefined : Float64Array,
            '%FinalizationRegistry%': 'undefined' == typeof FinalizationRegistry ? undefined : FinalizationRegistry,
            '%Function%': $Function,
            '%GeneratorFunction%': needsEval,
            '%Int8Array%': 'undefined' == typeof Int8Array ? undefined : Int8Array,
            '%Int16Array%': 'undefined' == typeof Int16Array ? undefined : Int16Array,
            '%Int32Array%': 'undefined' == typeof Int32Array ? undefined : Int32Array,
            '%isFinite%': isFinite,
            '%isNaN%': isNaN,
            '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
            '%JSON%': 'object' == typeof JSON ? JSON : undefined,
            '%Map%': 'undefined' == typeof Map ? undefined : Map,
            '%MapIteratorPrototype%': 'undefined' != typeof Map && hasSymbols && getProto ? getProto(new Map()[Symbol.iterator]()) : undefined,
            '%Math%': Math,
            '%Number%': Number,
            '%Object%': $Object,
            "%Object.getOwnPropertyDescriptor%": $gOPD,
            '%parseFloat%': parseFloat,
            '%parseInt%': parseInt,
            '%Promise%': 'undefined' == typeof Promise ? undefined : Promise,
            '%Proxy%': 'undefined' == typeof Proxy ? undefined : Proxy,
            '%RangeError%': $RangeError,
            '%ReferenceError%': $ReferenceError,
            '%Reflect%': 'undefined' == typeof Reflect ? undefined : Reflect,
            '%RegExp%': RegExp,
            '%Set%': 'undefined' == typeof Set ? undefined : Set,
            '%SetIteratorPrototype%': 'undefined' != typeof Set && hasSymbols && getProto ? getProto(new Set()[Symbol.iterator]()) : undefined,
            '%SharedArrayBuffer%': 'undefined' == typeof SharedArrayBuffer ? undefined : SharedArrayBuffer,
            '%String%': String,
            '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
            '%Symbol%': hasSymbols ? Symbol : undefined,
            '%SyntaxError%': $SyntaxError,
            '%ThrowTypeError%': ThrowTypeError,
            '%TypedArray%': TypedArray,
            '%TypeError%': $TypeError,
            '%Uint8Array%': 'undefined' == typeof Uint8Array ? undefined : Uint8Array,
            '%Uint8ClampedArray%': 'undefined' == typeof Uint8ClampedArray ? undefined : Uint8ClampedArray,
            '%Uint16Array%': 'undefined' == typeof Uint16Array ? undefined : Uint16Array,
            '%Uint32Array%': 'undefined' == typeof Uint32Array ? undefined : Uint32Array,
            '%URIError%': $URIError,
            '%WeakMap%': 'undefined' == typeof WeakMap ? undefined : WeakMap,
            '%WeakRef%': 'undefined' == typeof WeakRef ? undefined : WeakRef,
            '%WeakSet%': 'undefined' == typeof WeakSet ? undefined : WeakSet,
            '%Function.prototype.call%': $call,
            '%Function.prototype.apply%': $apply,
            '%Object.defineProperty%': $defineProperty,
            '%Object.getPrototypeOf%': $ObjectGPO,
            '%Math.abs%': abs,
            '%Math.floor%': floor,
            '%Math.max%': max,
            '%Math.min%': min,
            '%Math.pow%': pow,
            '%Math.round%': round,
            '%Math.sign%': sign,
            '%Reflect.getPrototypeOf%': $ReflectGPO
        };
        if (getProto) try {
            null.error;
        } catch (e) {
            var errorProto = getProto(getProto(e));
            INTRINSICS['%Error.prototype%'] = errorProto;
        }
        var doEval = function doEval(name) {
            var value;
            if ('%AsyncFunction%' === name) value = getEvalledConstructor('async function () {}');
            else if ('%GeneratorFunction%' === name) value = getEvalledConstructor('function* () {}');
            else if ('%AsyncGeneratorFunction%' === name) value = getEvalledConstructor('async function* () {}');
            else if ('%AsyncGenerator%' === name) {
                var fn = doEval('%AsyncGeneratorFunction%');
                if (fn) value = fn.prototype;
            } else if ('%AsyncIteratorPrototype%' === name) {
                var gen = doEval('%AsyncGenerator%');
                if (gen && getProto) value = getProto(gen.prototype);
            }
            INTRINSICS[name] = value;
            return value;
        };
        var LEGACY_ALIASES = {
            __proto__: null,
            '%ArrayBufferPrototype%': [
                'ArrayBuffer',
                'prototype'
            ],
            '%ArrayPrototype%': [
                'Array',
                'prototype'
            ],
            '%ArrayProto_entries%': [
                'Array',
                'prototype',
                'entries'
            ],
            '%ArrayProto_forEach%': [
                'Array',
                'prototype',
                'forEach'
            ],
            '%ArrayProto_keys%': [
                'Array',
                'prototype',
                'keys'
            ],
            '%ArrayProto_values%': [
                'Array',
                'prototype',
                'values'
            ],
            '%AsyncFunctionPrototype%': [
                'AsyncFunction',
                'prototype'
            ],
            '%AsyncGenerator%': [
                'AsyncGeneratorFunction',
                'prototype'
            ],
            '%AsyncGeneratorPrototype%': [
                'AsyncGeneratorFunction',
                'prototype',
                'prototype'
            ],
            '%BooleanPrototype%': [
                'Boolean',
                'prototype'
            ],
            '%DataViewPrototype%': [
                'DataView',
                'prototype'
            ],
            '%DatePrototype%': [
                'Date',
                'prototype'
            ],
            '%ErrorPrototype%': [
                'Error',
                'prototype'
            ],
            '%EvalErrorPrototype%': [
                'EvalError',
                'prototype'
            ],
            '%Float32ArrayPrototype%': [
                'Float32Array',
                'prototype'
            ],
            '%Float64ArrayPrototype%': [
                'Float64Array',
                'prototype'
            ],
            '%FunctionPrototype%': [
                'Function',
                'prototype'
            ],
            '%Generator%': [
                'GeneratorFunction',
                'prototype'
            ],
            '%GeneratorPrototype%': [
                'GeneratorFunction',
                'prototype',
                'prototype'
            ],
            '%Int8ArrayPrototype%': [
                'Int8Array',
                'prototype'
            ],
            '%Int16ArrayPrototype%': [
                'Int16Array',
                'prototype'
            ],
            '%Int32ArrayPrototype%': [
                'Int32Array',
                'prototype'
            ],
            '%JSONParse%': [
                'JSON',
                'parse'
            ],
            '%JSONStringify%': [
                'JSON',
                'stringify'
            ],
            '%MapPrototype%': [
                'Map',
                'prototype'
            ],
            '%NumberPrototype%': [
                'Number',
                'prototype'
            ],
            '%ObjectPrototype%': [
                'Object',
                'prototype'
            ],
            '%ObjProto_toString%': [
                'Object',
                'prototype',
                'toString'
            ],
            '%ObjProto_valueOf%': [
                'Object',
                'prototype',
                'valueOf'
            ],
            '%PromisePrototype%': [
                'Promise',
                'prototype'
            ],
            '%PromiseProto_then%': [
                'Promise',
                'prototype',
                'then'
            ],
            '%Promise_all%': [
                'Promise',
                'all'
            ],
            '%Promise_reject%': [
                'Promise',
                'reject'
            ],
            '%Promise_resolve%': [
                'Promise',
                'resolve'
            ],
            '%RangeErrorPrototype%': [
                'RangeError',
                'prototype'
            ],
            '%ReferenceErrorPrototype%': [
                'ReferenceError',
                'prototype'
            ],
            '%RegExpPrototype%': [
                'RegExp',
                'prototype'
            ],
            '%SetPrototype%': [
                'Set',
                'prototype'
            ],
            '%SharedArrayBufferPrototype%': [
                'SharedArrayBuffer',
                'prototype'
            ],
            '%StringPrototype%': [
                'String',
                'prototype'
            ],
            '%SymbolPrototype%': [
                'Symbol',
                'prototype'
            ],
            '%SyntaxErrorPrototype%': [
                'SyntaxError',
                'prototype'
            ],
            '%TypedArrayPrototype%': [
                'TypedArray',
                'prototype'
            ],
            '%TypeErrorPrototype%': [
                'TypeError',
                'prototype'
            ],
            '%Uint8ArrayPrototype%': [
                'Uint8Array',
                'prototype'
            ],
            '%Uint8ClampedArrayPrototype%': [
                'Uint8ClampedArray',
                'prototype'
            ],
            '%Uint16ArrayPrototype%': [
                'Uint16Array',
                'prototype'
            ],
            '%Uint32ArrayPrototype%': [
                'Uint32Array',
                'prototype'
            ],
            '%URIErrorPrototype%': [
                'URIError',
                'prototype'
            ],
            '%WeakMapPrototype%': [
                'WeakMap',
                'prototype'
            ],
            '%WeakSetPrototype%': [
                'WeakSet',
                'prototype'
            ]
        };
        var bind = __webpack_require__("../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
        var hasOwn = __webpack_require__("../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js");
        var $concat = bind.call($call, Array.prototype.concat);
        var $spliceApply = bind.call($apply, Array.prototype.splice);
        var $replace = bind.call($call, String.prototype.replace);
        var $strSlice = bind.call($call, String.prototype.slice);
        var $exec = bind.call($call, RegExp.prototype.exec);
        var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
        var reEscapeChar = /\\(\\)?/g;
        var stringToPath = function(string) {
            var first = $strSlice(string, 0, 1);
            var last = $strSlice(string, -1);
            if ('%' === first && '%' !== last) throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
            if ('%' === last && '%' !== first) throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
            var result = [];
            $replace(string, rePropName, function(match, number, quote, subString) {
                result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
            });
            return result;
        };
        var getBaseIntrinsic = function(name, allowMissing) {
            var intrinsicName = name;
            var alias;
            if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
                alias = LEGACY_ALIASES[intrinsicName];
                intrinsicName = '%' + alias[0] + '%';
            }
            if (hasOwn(INTRINSICS, intrinsicName)) {
                var value = INTRINSICS[intrinsicName];
                if (value === needsEval) value = doEval(intrinsicName);
                if (void 0 === value && !allowMissing) throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
                return {
                    alias: alias,
                    name: intrinsicName,
                    value: value
                };
            }
            throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
        };
        module.exports = function(name, allowMissing) {
            if ('string' != typeof name || 0 === name.length) throw new $TypeError('intrinsic name must be a non-empty string');
            if (arguments.length > 1 && 'boolean' != typeof allowMissing) throw new $TypeError('"allowMissing" argument must be a boolean');
            if (null === $exec(/^%?[^%]*%?$/, name)) throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
            var parts = stringToPath(name);
            var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
            var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
            var intrinsicRealName = intrinsic.name;
            var value = intrinsic.value;
            var skipFurtherCaching = false;
            var alias = intrinsic.alias;
            if (alias) {
                intrinsicBaseName = alias[0];
                $spliceApply(parts, $concat([
                    0,
                    1
                ], alias));
            }
            for(var i = 1, isOwn = true; i < parts.length; i += 1){
                var part = parts[i];
                var first = $strSlice(part, 0, 1);
                var last = $strSlice(part, -1);
                if (('"' === first || "'" === first || '`' === first || '"' === last || "'" === last || '`' === last) && first !== last) throw new $SyntaxError('property names with quotes must have matching quotes');
                if ('constructor' === part || !isOwn) skipFurtherCaching = true;
                intrinsicBaseName += '.' + part;
                intrinsicRealName = '%' + intrinsicBaseName + '%';
                if (hasOwn(INTRINSICS, intrinsicRealName)) value = INTRINSICS[intrinsicRealName];
                else if (null != value) {
                    if (!(part in value)) {
                        if (!allowMissing) throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                        return;
                    }
                    if ($gOPD && i + 1 >= parts.length) {
                        var desc = $gOPD(value, part);
                        isOwn = !!desc;
                        value = isOwn && 'get' in desc && !('originalValue' in desc.get) ? desc.get : value[part];
                    } else {
                        isOwn = hasOwn(value, part);
                        value = value[part];
                    }
                    if (isOwn && !skipFurtherCaching) INTRINSICS[intrinsicRealName] = value;
                }
            }
            return value;
        };
    },
    "../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var $Object = __webpack_require__("../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js");
        module.exports = $Object.getPrototypeOf || null;
    },
    "../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js": function(module) {
        "use strict";
        module.exports = 'undefined' != typeof Reflect && Reflect.getPrototypeOf || null;
    },
    "../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var reflectGetProto = __webpack_require__("../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js");
        var originalGetProto = __webpack_require__("../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js");
        var getDunderProto = __webpack_require__("../node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js");
        module.exports = reflectGetProto ? function(O) {
            return reflectGetProto(O);
        } : originalGetProto ? function(O) {
            if (!O || 'object' != typeof O && 'function' != typeof O) throw new TypeError('getProto: not an object');
            return originalGetProto(O);
        } : getDunderProto ? function(O) {
            return getDunderProto(O);
        } : null;
    },
    "../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js": function(module) {
        "use strict";
        module.exports = Object.getOwnPropertyDescriptor;
    },
    "../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var $gOPD = __webpack_require__("../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js");
        if ($gOPD) try {
            $gOPD([], 'length');
        } catch (e) {
            $gOPD = null;
        }
        module.exports = $gOPD;
    },
    "../node_modules/.pnpm/has-flag@3.0.0/node_modules/has-flag/index.js": function(module) {
        "use strict";
        module.exports = (flag, argv)=>{
            argv = argv || process.argv;
            const prefix = flag.startsWith('-') ? '' : 1 === flag.length ? '-' : '--';
            const pos = argv.indexOf(prefix + flag);
            const terminatorPos = argv.indexOf('--');
            return -1 !== pos && (-1 === terminatorPos ? true : pos < terminatorPos);
        };
    },
    "../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var origSymbol = 'undefined' != typeof Symbol && Symbol;
        var hasSymbolSham = __webpack_require__("../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js");
        module.exports = function() {
            if ('function' != typeof origSymbol) return false;
            if ('function' != typeof Symbol) return false;
            if ('symbol' != typeof origSymbol('foo')) return false;
            if ('symbol' != typeof Symbol('bar')) return false;
            return hasSymbolSham();
        };
    },
    "../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js": function(module) {
        "use strict";
        module.exports = function() {
            if ('function' != typeof Symbol || 'function' != typeof Object.getOwnPropertySymbols) return false;
            if ('symbol' == typeof Symbol.iterator) return true;
            var obj = {};
            var sym = Symbol('test');
            var symObj = Object(sym);
            if ('string' == typeof sym) return false;
            if ('[object Symbol]' !== Object.prototype.toString.call(sym)) return false;
            if ('[object Symbol]' !== Object.prototype.toString.call(symObj)) return false;
            var symVal = 42;
            obj[sym] = symVal;
            for(var _ in obj)return false;
            if ('function' == typeof Object.keys && 0 !== Object.keys(obj).length) return false;
            if ('function' == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(obj).length) return false;
            var syms = Object.getOwnPropertySymbols(obj);
            if (1 !== syms.length || syms[0] !== sym) return false;
            if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) return false;
            if ('function' == typeof Object.getOwnPropertyDescriptor) {
                var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
                if (descriptor.value !== symVal || true !== descriptor.enumerable) return false;
            }
            return true;
        };
    },
    "../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var call = Function.prototype.call;
        var $hasOwn = Object.prototype.hasOwnProperty;
        var bind = __webpack_require__("../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
        module.exports = bind.call(call, $hasOwn);
    },
    "../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var deprecate = __webpack_require__("../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('http-errors');
        var setPrototypeOf = __webpack_require__("../node_modules/.pnpm/setprototypeof@1.2.0/node_modules/setprototypeof/index.js");
        var statuses = __webpack_require__("../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/index.js");
        var inherits = __webpack_require__("../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js");
        var toIdentifier = __webpack_require__("../node_modules/.pnpm/toidentifier@1.0.1/node_modules/toidentifier/index.js");
        module.exports = createError;
        module.exports.HttpError = createHttpErrorConstructor();
        module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
        populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);
        function codeClass(status) {
            return Number(String(status).charAt(0) + '00');
        }
        function createError() {
            var err;
            var msg;
            var status = 500;
            var props = {};
            for(var i = 0; i < arguments.length; i++){
                var arg = arguments[i];
                var type = typeof arg;
                if ('object' === type && arg instanceof Error) {
                    err = arg;
                    status = err.status || err.statusCode || status;
                } else if ('number' === type && 0 === i) status = arg;
                else if ('string' === type) msg = arg;
                else if ('object' === type) props = arg;
                else throw new TypeError('argument #' + (i + 1) + ' unsupported type ' + type);
            }
            if ('number' == typeof status && (status < 400 || status >= 600)) deprecate('non-error status code; use only 4xx or 5xx status codes');
            if ('number' != typeof status || !statuses.message[status] && (status < 400 || status >= 600)) status = 500;
            var HttpError = createError[status] || createError[codeClass(status)];
            if (!err) {
                err = HttpError ? new HttpError(msg) : new Error(msg || statuses.message[status]);
                Error.captureStackTrace(err, createError);
            }
            if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
                err.expose = status < 500;
                err.status = err.statusCode = status;
            }
            for(var key in props)if ('status' !== key && 'statusCode' !== key) err[key] = props[key];
            return err;
        }
        function createHttpErrorConstructor() {
            function HttpError() {
                throw new TypeError('cannot construct abstract class');
            }
            inherits(HttpError, Error);
            return HttpError;
        }
        function createClientErrorConstructor(HttpError, name, code) {
            var className = toClassName(name);
            function ClientError(message) {
                var msg = null != message ? message : statuses.message[code];
                var err = new Error(msg);
                Error.captureStackTrace(err, ClientError);
                setPrototypeOf(err, ClientError.prototype);
                Object.defineProperty(err, 'message', {
                    enumerable: true,
                    configurable: true,
                    value: msg,
                    writable: true
                });
                Object.defineProperty(err, 'name', {
                    enumerable: false,
                    configurable: true,
                    value: className,
                    writable: true
                });
                return err;
            }
            inherits(ClientError, HttpError);
            nameFunc(ClientError, className);
            ClientError.prototype.status = code;
            ClientError.prototype.statusCode = code;
            ClientError.prototype.expose = true;
            return ClientError;
        }
        function createIsHttpErrorFunction(HttpError) {
            return function(val) {
                if (!val || 'object' != typeof val) return false;
                if (val instanceof HttpError) return true;
                return val instanceof Error && 'boolean' == typeof val.expose && 'number' == typeof val.statusCode && val.status === val.statusCode;
            };
        }
        function createServerErrorConstructor(HttpError, name, code) {
            var className = toClassName(name);
            function ServerError(message) {
                var msg = null != message ? message : statuses.message[code];
                var err = new Error(msg);
                Error.captureStackTrace(err, ServerError);
                setPrototypeOf(err, ServerError.prototype);
                Object.defineProperty(err, 'message', {
                    enumerable: true,
                    configurable: true,
                    value: msg,
                    writable: true
                });
                Object.defineProperty(err, 'name', {
                    enumerable: false,
                    configurable: true,
                    value: className,
                    writable: true
                });
                return err;
            }
            inherits(ServerError, HttpError);
            nameFunc(ServerError, className);
            ServerError.prototype.status = code;
            ServerError.prototype.statusCode = code;
            ServerError.prototype.expose = false;
            return ServerError;
        }
        function nameFunc(func, name) {
            var desc = Object.getOwnPropertyDescriptor(func, 'name');
            if (desc && desc.configurable) {
                desc.value = name;
                Object.defineProperty(func, 'name', desc);
            }
        }
        function populateConstructorExports(exports1, codes, HttpError) {
            codes.forEach(function(code) {
                var CodeError;
                var name = toIdentifier(statuses.message[code]);
                switch(codeClass(code)){
                    case 400:
                        CodeError = createClientErrorConstructor(HttpError, name, code);
                        break;
                    case 500:
                        CodeError = createServerErrorConstructor(HttpError, name, code);
                        break;
                }
                if (CodeError) {
                    exports1[code] = CodeError;
                    exports1[name] = CodeError;
                }
            });
        }
        function toClassName(name) {
            return 'Error' !== name.substr(-5) ? name + 'Error' : name;
        }
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/dbcs-codec.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js").Buffer;
        exports1._dbcs = DBCSCodec;
        var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1000, UNASSIGNED_NODE = new Array(0x100), DEF_CHAR = -1;
        for(var i = 0; i < 0x100; i++)UNASSIGNED_NODE[i] = UNASSIGNED;
        function DBCSCodec(codecOptions, iconv) {
            this.encodingName = codecOptions.encodingName;
            if (!codecOptions) throw new Error("DBCS codec is called without the data.");
            if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");
            var mappingTable = codecOptions.table();
            this.decodeTables = [];
            this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
            this.decodeTableSeq = [];
            for(var i = 0; i < mappingTable.length; i++)this._addDecodeChunk(mappingTable[i]);
            this.defaultCharUnicode = iconv.defaultCharUnicode;
            this.encodeTable = [];
            this.encodeTableSeq = [];
            var skipEncodeChars = {};
            if (codecOptions.encodeSkipVals) for(var i = 0; i < codecOptions.encodeSkipVals.length; i++){
                var val = codecOptions.encodeSkipVals[i];
                if ('number' == typeof val) skipEncodeChars[val] = true;
                else for(var j = val.from; j <= val.to; j++)skipEncodeChars[j] = true;
            }
            this._fillEncodeTable(0, 0, skipEncodeChars);
            if (codecOptions.encodeAdd) {
                for(var uChar in codecOptions.encodeAdd)if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
            }
            this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
            if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
            if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
            if ('function' == typeof codecOptions.gb18030) {
                this.gb18030 = codecOptions.gb18030();
                var thirdByteNodeIdx = this.decodeTables.length;
                var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
                var fourthByteNodeIdx = this.decodeTables.length;
                var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
                for(var i = 0x81; i <= 0xFE; i++){
                    var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
                    var secondByteNode = this.decodeTables[secondByteNodeIdx];
                    for(var j = 0x30; j <= 0x39; j++)secondByteNode[j] = NODE_START - thirdByteNodeIdx;
                }
                for(var i = 0x81; i <= 0xFE; i++)thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
                for(var i = 0x30; i <= 0x39; i++)fourthByteNode[i] = GB18030_CODE;
            }
        }
        DBCSCodec.prototype.encoder = DBCSEncoder;
        DBCSCodec.prototype.decoder = DBCSDecoder;
        DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
            var bytes = [];
            for(; addr > 0; addr >>= 8)bytes.push(0xFF & addr);
            if (0 == bytes.length) bytes.push(0);
            var node = this.decodeTables[0];
            for(var i = bytes.length - 1; i > 0; i--){
                var val = node[bytes[i]];
                if (val == UNASSIGNED) {
                    node[bytes[i]] = NODE_START - this.decodeTables.length;
                    this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
                } else if (val <= NODE_START) node = this.decodeTables[NODE_START - val];
                else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
            }
            return node;
        };
        DBCSCodec.prototype._addDecodeChunk = function(chunk) {
            var curAddr = parseInt(chunk[0], 16);
            var writeTable = this._getDecodeTrieNode(curAddr);
            curAddr &= 0xFF;
            for(var k = 1; k < chunk.length; k++){
                var part = chunk[k];
                if ("string" == typeof part) for(var l = 0; l < part.length;){
                    var code = part.charCodeAt(l++);
                    if (0xD800 <= code && code < 0xDC00) {
                        var codeTrail = part.charCodeAt(l++);
                        if (0xDC00 <= codeTrail && codeTrail < 0xE000) writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
                        else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
                    } else if (0x0FF0 < code && code <= 0x0FFF) {
                        var len = 0xFFF - code + 2;
                        var seq = [];
                        for(var m = 0; m < len; m++)seq.push(part.charCodeAt(l++));
                        writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                        this.decodeTableSeq.push(seq);
                    } else writeTable[curAddr++] = code;
                }
                else if ("number" == typeof part) {
                    var charCode = writeTable[curAddr - 1] + 1;
                    for(var l = 0; l < part; l++)writeTable[curAddr++] = charCode++;
                } else throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
            }
            if (curAddr > 0xFF) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
        };
        DBCSCodec.prototype._getEncodeBucket = function(uCode) {
            var high = uCode >> 8;
            if (void 0 === this.encodeTable[high]) this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
            return this.encodeTable[high];
        };
        DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
            var bucket = this._getEncodeBucket(uCode);
            var low = 0xFF & uCode;
            if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
            else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
        };
        DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
            var uCode = seq[0];
            var bucket = this._getEncodeBucket(uCode);
            var low = 0xFF & uCode;
            var node;
            if (bucket[low] <= SEQ_START) node = this.encodeTableSeq[SEQ_START - bucket[low]];
            else {
                node = {};
                if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
                bucket[low] = SEQ_START - this.encodeTableSeq.length;
                this.encodeTableSeq.push(node);
            }
            for(var j = 1; j < seq.length - 1; j++){
                var oldVal = node[uCode];
                if ('object' == typeof oldVal) node = oldVal;
                else {
                    node = node[uCode] = {};
                    if (void 0 !== oldVal) node[DEF_CHAR] = oldVal;
                }
            }
            uCode = seq[seq.length - 1];
            node[uCode] = dbcsCode;
        };
        DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
            var node = this.decodeTables[nodeIdx];
            for(var i = 0; i < 0x100; i++){
                var uCode = node[i];
                var mbCode = prefix + i;
                if (!skipEncodeChars[mbCode]) {
                    if (uCode >= 0) this._setEncodeChar(uCode, mbCode);
                    else if (uCode <= NODE_START) this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
                    else if (uCode <= SEQ_START) this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
                }
            }
        };
        function DBCSEncoder(options, codec) {
            this.leadSurrogate = -1;
            this.seqObj = void 0;
            this.encodeTable = codec.encodeTable;
            this.encodeTableSeq = codec.encodeTableSeq;
            this.defaultCharSingleByte = codec.defCharSB;
            this.gb18030 = codec.gb18030;
        }
        DBCSEncoder.prototype.write = function(str) {
            var newBuf = Buffer1.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i = 0, j = 0;
            while(true){
                if (-1 === nextChar) {
                    if (i == str.length) break;
                    var uCode = str.charCodeAt(i++);
                } else {
                    var uCode = nextChar;
                    nextChar = -1;
                }
                if (0xD800 <= uCode && uCode < 0xE000) if (uCode < 0xDC00) if (-1 === leadSurrogate) {
                    leadSurrogate = uCode;
                    continue;
                } else {
                    leadSurrogate = uCode;
                    uCode = UNASSIGNED;
                }
                else if (-1 !== leadSurrogate) {
                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
                    leadSurrogate = -1;
                } else uCode = UNASSIGNED;
                else if (-1 !== leadSurrogate) {
                    nextChar = uCode;
                    uCode = UNASSIGNED;
                    leadSurrogate = -1;
                }
                var dbcsCode = UNASSIGNED;
                if (void 0 !== seqObj && uCode != UNASSIGNED) {
                    var resCode = seqObj[uCode];
                    if ('object' == typeof resCode) {
                        seqObj = resCode;
                        continue;
                    }
                    if ('number' == typeof resCode) dbcsCode = resCode;
                    else if (void 0 == resCode) {
                        resCode = seqObj[DEF_CHAR];
                        if (void 0 !== resCode) {
                            dbcsCode = resCode;
                            nextChar = uCode;
                        }
                    }
                    seqObj = void 0;
                } else if (uCode >= 0) {
                    var subtable = this.encodeTable[uCode >> 8];
                    if (void 0 !== subtable) dbcsCode = subtable[0xFF & uCode];
                    if (dbcsCode <= SEQ_START) {
                        seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
                        continue;
                    }
                    if (dbcsCode == UNASSIGNED && this.gb18030) {
                        var idx = findIdx(this.gb18030.uChars, uCode);
                        if (-1 != idx) {
                            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                            newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);
                            dbcsCode %= 12600;
                            newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);
                            dbcsCode %= 1260;
                            newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);
                            dbcsCode %= 10;
                            newBuf[j++] = 0x30 + dbcsCode;
                            continue;
                        }
                    }
                }
                if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
                if (dbcsCode < 0x100) newBuf[j++] = dbcsCode;
                else if (dbcsCode < 0x10000) {
                    newBuf[j++] = dbcsCode >> 8;
                    newBuf[j++] = 0xFF & dbcsCode;
                } else {
                    newBuf[j++] = dbcsCode >> 16;
                    newBuf[j++] = dbcsCode >> 8 & 0xFF;
                    newBuf[j++] = 0xFF & dbcsCode;
                }
            }
            this.seqObj = seqObj;
            this.leadSurrogate = leadSurrogate;
            return newBuf.slice(0, j);
        };
        DBCSEncoder.prototype.end = function() {
            if (-1 === this.leadSurrogate && void 0 === this.seqObj) return;
            var newBuf = Buffer1.alloc(10), j = 0;
            if (this.seqObj) {
                var dbcsCode = this.seqObj[DEF_CHAR];
                if (void 0 !== dbcsCode) if (dbcsCode < 0x100) newBuf[j++] = dbcsCode;
                else {
                    newBuf[j++] = dbcsCode >> 8;
                    newBuf[j++] = 0xFF & dbcsCode;
                }
                this.seqObj = void 0;
            }
            if (-1 !== this.leadSurrogate) {
                newBuf[j++] = this.defaultCharSingleByte;
                this.leadSurrogate = -1;
            }
            return newBuf.slice(0, j);
        };
        DBCSEncoder.prototype.findIdx = findIdx;
        function DBCSDecoder(options, codec) {
            this.nodeIdx = 0;
            this.prevBuf = Buffer1.alloc(0);
            this.decodeTables = codec.decodeTables;
            this.decodeTableSeq = codec.decodeTableSeq;
            this.defaultCharUnicode = codec.defaultCharUnicode;
            this.gb18030 = codec.gb18030;
        }
        DBCSDecoder.prototype.write = function(buf) {
            var newBuf = Buffer1.alloc(2 * buf.length), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
            if (prevBufOffset > 0) prevBuf = Buffer1.concat([
                prevBuf,
                buf.slice(0, 10)
            ]);
            for(var i = 0, j = 0; i < buf.length; i++){
                var curByte = i >= 0 ? buf[i] : prevBuf[i + prevBufOffset];
                var uCode = this.decodeTables[nodeIdx][curByte];
                if (uCode >= 0) ;
                else if (uCode === UNASSIGNED) {
                    i = seqStart;
                    uCode = this.defaultCharUnicode.charCodeAt(0);
                } else if (uCode === GB18030_CODE) {
                    var curSeq = seqStart >= 0 ? buf.slice(seqStart, i + 1) : prevBuf.slice(seqStart + prevBufOffset, i + 1 + prevBufOffset);
                    var ptr = (curSeq[0] - 0x81) * 12600 + (curSeq[1] - 0x30) * 1260 + (curSeq[2] - 0x81) * 10 + (curSeq[3] - 0x30);
                    var idx = findIdx(this.gb18030.gbChars, ptr);
                    uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
                } else if (uCode <= NODE_START) {
                    nodeIdx = NODE_START - uCode;
                    continue;
                } else if (uCode <= SEQ_START) {
                    var seq = this.decodeTableSeq[SEQ_START - uCode];
                    for(var k = 0; k < seq.length - 1; k++){
                        uCode = seq[k];
                        newBuf[j++] = 0xFF & uCode;
                        newBuf[j++] = uCode >> 8;
                    }
                    uCode = seq[seq.length - 1];
                } else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
                if (uCode > 0xFFFF) {
                    uCode -= 0x10000;
                    var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
                    newBuf[j++] = 0xFF & uCodeLead;
                    newBuf[j++] = uCodeLead >> 8;
                    uCode = 0xDC00 + uCode % 0x400;
                }
                newBuf[j++] = 0xFF & uCode;
                newBuf[j++] = uCode >> 8;
                nodeIdx = 0;
                seqStart = i + 1;
            }
            this.nodeIdx = nodeIdx;
            this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
            return newBuf.slice(0, j).toString('ucs2');
        };
        DBCSDecoder.prototype.end = function() {
            var ret = '';
            while(this.prevBuf.length > 0){
                ret += this.defaultCharUnicode;
                var buf = this.prevBuf.slice(1);
                this.prevBuf = Buffer1.alloc(0);
                this.nodeIdx = 0;
                if (buf.length > 0) ret += this.write(buf);
            }
            this.nodeIdx = 0;
            return ret;
        };
        function findIdx(table, val) {
            if (table[0] > val) return -1;
            var l = 0, r = table.length;
            while(l < r - 1){
                var mid = l + Math.floor((r - l + 1) / 2);
                if (table[mid] <= val) l = mid;
                else r = mid;
            }
            return l;
        }
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/dbcs-data.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        module.exports = {
            shiftjis: {
                type: '_dbcs',
                table: function() {
                    return __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/shiftjis.json");
                },
                encodeAdd: {
                    '\u00a5': 0x5C,
                    '\u203E': 0x7E
                },
                encodeSkipVals: [
                    {
                        from: 0xED40,
                        to: 0xF940
                    }
                ]
            },
            csshiftjis: 'shiftjis',
            mskanji: 'shiftjis',
            sjis: 'shiftjis',
            windows31j: 'shiftjis',
            ms31j: 'shiftjis',
            xsjis: 'shiftjis',
            windows932: 'shiftjis',
            ms932: 'shiftjis',
            932: 'shiftjis',
            cp932: 'shiftjis',
            eucjp: {
                type: '_dbcs',
                table: function() {
                    return __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/eucjp.json");
                },
                encodeAdd: {
                    '\u00a5': 0x5C,
                    '\u203E': 0x7E
                }
            },
            gb2312: 'cp936',
            gb231280: 'cp936',
            gb23121980: 'cp936',
            csgb2312: 'cp936',
            csiso58gb231280: 'cp936',
            euccn: 'cp936',
            windows936: 'cp936',
            ms936: 'cp936',
            936: 'cp936',
            cp936: {
                type: '_dbcs',
                table: function() {
                    return __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp936.json");
                }
            },
            gbk: {
                type: '_dbcs',
                table: function() {
                    return __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp936.json").concat(__webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/gbk-added.json"));
                }
            },
            xgbk: 'gbk',
            isoir58: 'gbk',
            gb18030: {
                type: '_dbcs',
                table: function() {
                    return __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp936.json").concat(__webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/gbk-added.json"));
                },
                gb18030: function() {
                    return __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json");
                },
                encodeSkipVals: [
                    0x80
                ],
                encodeAdd: {
                    '€': 0xA2E3
                }
            },
            chinese: 'gb18030',
            windows949: 'cp949',
            ms949: 'cp949',
            949: 'cp949',
            cp949: {
                type: '_dbcs',
                table: function() {
                    return __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp949.json");
                }
            },
            cseuckr: 'cp949',
            csksc56011987: 'cp949',
            euckr: 'cp949',
            isoir149: 'cp949',
            korean: 'cp949',
            ksc56011987: 'cp949',
            ksc56011989: 'cp949',
            ksc5601: 'cp949',
            windows950: 'cp950',
            ms950: 'cp950',
            950: 'cp950',
            cp950: {
                type: '_dbcs',
                table: function() {
                    return __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp950.json");
                }
            },
            big5: 'big5hkscs',
            big5hkscs: {
                type: '_dbcs',
                table: function() {
                    return __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp950.json").concat(__webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/big5-added.json"));
                },
                encodeSkipVals: [
                    0xa2cc
                ]
            },
            cnbig5: 'big5hkscs',
            csbig5: 'big5hkscs',
            xxbig5: 'big5hkscs'
        };
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var modules = [
            __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/internal.js"),
            __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/utf16.js"),
            __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/utf7.js"),
            __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-codec.js"),
            __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-data.js"),
            __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-data-generated.js"),
            __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/dbcs-codec.js"),
            __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/dbcs-data.js")
        ];
        for(var i = 0; i < modules.length; i++){
            var module = modules[i];
            for(var enc in module)if (Object.prototype.hasOwnProperty.call(module, enc)) exports1[enc] = module[enc];
        }
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/internal.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js").Buffer;
        module.exports = {
            utf8: {
                type: "_internal",
                bomAware: true
            },
            cesu8: {
                type: "_internal",
                bomAware: true
            },
            unicode11utf8: "utf8",
            ucs2: {
                type: "_internal",
                bomAware: true
            },
            utf16le: "ucs2",
            binary: {
                type: "_internal"
            },
            base64: {
                type: "_internal"
            },
            hex: {
                type: "_internal"
            },
            _internal: InternalCodec
        };
        function InternalCodec(codecOptions, iconv) {
            this.enc = codecOptions.encodingName;
            this.bomAware = codecOptions.bomAware;
            if ("base64" === this.enc) this.encoder = InternalEncoderBase64;
            else if ("cesu8" === this.enc) {
                this.enc = "utf8";
                this.encoder = InternalEncoderCesu8;
                if ('💩' !== Buffer1.from('eda0bdedb2a9', 'hex').toString()) {
                    this.decoder = InternalDecoderCesu8;
                    this.defaultCharUnicode = iconv.defaultCharUnicode;
                }
            }
        }
        InternalCodec.prototype.encoder = InternalEncoder;
        InternalCodec.prototype.decoder = InternalDecoder;
        var StringDecoder = __webpack_require__("string_decoder").StringDecoder;
        if (!StringDecoder.prototype.end) StringDecoder.prototype.end = function() {};
        function InternalDecoder(options, codec) {
            StringDecoder.call(this, codec.enc);
        }
        InternalDecoder.prototype = StringDecoder.prototype;
        function InternalEncoder(options, codec) {
            this.enc = codec.enc;
        }
        InternalEncoder.prototype.write = function(str) {
            return Buffer1.from(str, this.enc);
        };
        InternalEncoder.prototype.end = function() {};
        function InternalEncoderBase64(options, codec) {
            this.prevStr = '';
        }
        InternalEncoderBase64.prototype.write = function(str) {
            str = this.prevStr + str;
            var completeQuads = str.length - str.length % 4;
            this.prevStr = str.slice(completeQuads);
            str = str.slice(0, completeQuads);
            return Buffer1.from(str, "base64");
        };
        InternalEncoderBase64.prototype.end = function() {
            return Buffer1.from(this.prevStr, "base64");
        };
        function InternalEncoderCesu8(options, codec) {}
        InternalEncoderCesu8.prototype.write = function(str) {
            var buf = Buffer1.alloc(3 * str.length), bufIdx = 0;
            for(var i = 0; i < str.length; i++){
                var charCode = str.charCodeAt(i);
                if (charCode < 0x80) buf[bufIdx++] = charCode;
                else if (charCode < 0x800) {
                    buf[bufIdx++] = 0xC0 + (charCode >>> 6);
                    buf[bufIdx++] = 0x80 + (0x3f & charCode);
                } else {
                    buf[bufIdx++] = 0xE0 + (charCode >>> 12);
                    buf[bufIdx++] = 0x80 + (charCode >>> 6 & 0x3f);
                    buf[bufIdx++] = 0x80 + (0x3f & charCode);
                }
            }
            return buf.slice(0, bufIdx);
        };
        InternalEncoderCesu8.prototype.end = function() {};
        function InternalDecoderCesu8(options, codec) {
            this.acc = 0;
            this.contBytes = 0;
            this.accBytes = 0;
            this.defaultCharUnicode = codec.defaultCharUnicode;
        }
        InternalDecoderCesu8.prototype.write = function(buf) {
            var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = '';
            for(var i = 0; i < buf.length; i++){
                var curByte = buf[i];
                if ((0xC0 & curByte) !== 0x80) {
                    if (contBytes > 0) {
                        res += this.defaultCharUnicode;
                        contBytes = 0;
                    }
                    if (curByte < 0x80) res += String.fromCharCode(curByte);
                    else if (curByte < 0xE0) {
                        acc = 0x1F & curByte;
                        contBytes = 1;
                        accBytes = 1;
                    } else if (curByte < 0xF0) {
                        acc = 0x0F & curByte;
                        contBytes = 2;
                        accBytes = 1;
                    } else res += this.defaultCharUnicode;
                } else if (contBytes > 0) {
                    acc = acc << 6 | 0x3f & curByte;
                    contBytes--;
                    accBytes++;
                    if (0 === contBytes) if (2 === accBytes && acc < 0x80 && acc > 0) res += this.defaultCharUnicode;
                    else if (3 === accBytes && acc < 0x800) res += this.defaultCharUnicode;
                    else res += String.fromCharCode(acc);
                } else res += this.defaultCharUnicode;
            }
            this.acc = acc;
            this.contBytes = contBytes;
            this.accBytes = accBytes;
            return res;
        };
        InternalDecoderCesu8.prototype.end = function() {
            var res = 0;
            if (this.contBytes > 0) res += this.defaultCharUnicode;
            return res;
        };
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-codec.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js").Buffer;
        exports1._sbcs = SBCSCodec;
        function SBCSCodec(codecOptions, iconv) {
            if (!codecOptions) throw new Error("SBCS codec is called without the data.");
            if (!codecOptions.chars || 128 !== codecOptions.chars.length && 256 !== codecOptions.chars.length) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
            if (128 === codecOptions.chars.length) {
                var asciiString = "";
                for(var i = 0; i < 128; i++)asciiString += String.fromCharCode(i);
                codecOptions.chars = asciiString + codecOptions.chars;
            }
            this.decodeBuf = Buffer1.from(codecOptions.chars, 'ucs2');
            var encodeBuf = Buffer1.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
            for(var i = 0; i < codecOptions.chars.length; i++)encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
            this.encodeBuf = encodeBuf;
        }
        SBCSCodec.prototype.encoder = SBCSEncoder;
        SBCSCodec.prototype.decoder = SBCSDecoder;
        function SBCSEncoder(options, codec) {
            this.encodeBuf = codec.encodeBuf;
        }
        SBCSEncoder.prototype.write = function(str) {
            var buf = Buffer1.alloc(str.length);
            for(var i = 0; i < str.length; i++)buf[i] = this.encodeBuf[str.charCodeAt(i)];
            return buf;
        };
        SBCSEncoder.prototype.end = function() {};
        function SBCSDecoder(options, codec) {
            this.decodeBuf = codec.decodeBuf;
        }
        SBCSDecoder.prototype.write = function(buf) {
            var decodeBuf = this.decodeBuf;
            var newBuf = Buffer1.alloc(2 * buf.length);
            var idx1 = 0, idx2 = 0;
            for(var i = 0; i < buf.length; i++){
                idx1 = 2 * buf[i];
                idx2 = 2 * i;
                newBuf[idx2] = decodeBuf[idx1];
                newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
            }
            return newBuf.toString('ucs2');
        };
        SBCSDecoder.prototype.end = function() {};
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-data-generated.js": function(module) {
        "use strict";
        module.exports = {
            437: "cp437",
            737: "cp737",
            775: "cp775",
            850: "cp850",
            852: "cp852",
            855: "cp855",
            856: "cp856",
            857: "cp857",
            858: "cp858",
            860: "cp860",
            861: "cp861",
            862: "cp862",
            863: "cp863",
            864: "cp864",
            865: "cp865",
            866: "cp866",
            869: "cp869",
            874: "windows874",
            922: "cp922",
            1046: "cp1046",
            1124: "cp1124",
            1125: "cp1125",
            1129: "cp1129",
            1133: "cp1133",
            1161: "cp1161",
            1162: "cp1162",
            1163: "cp1163",
            1250: "windows1250",
            1251: "windows1251",
            1252: "windows1252",
            1253: "windows1253",
            1254: "windows1254",
            1255: "windows1255",
            1256: "windows1256",
            1257: "windows1257",
            1258: "windows1258",
            28591: "iso88591",
            28592: "iso88592",
            28593: "iso88593",
            28594: "iso88594",
            28595: "iso88595",
            28596: "iso88596",
            28597: "iso88597",
            28598: "iso88598",
            28599: "iso88599",
            28600: "iso885910",
            28601: "iso885911",
            28603: "iso885913",
            28604: "iso885914",
            28605: "iso885915",
            28606: "iso885916",
            windows874: {
                type: "_sbcs",
                chars: "€����…�����������‘’“”•–—�������� กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
            },
            win874: "windows874",
            cp874: "windows874",
            windows1250: {
                type: "_sbcs",
                chars: "€�‚�„…†‡�‰Š‹ŚŤŽŹ�‘’“”•–—�™š›śťžź ˇ˘Ł¤Ą¦§¨©Ş«¬­®Ż°±˛ł´µ¶·¸ąş»Ľ˝ľżŔÁÂĂÄĹĆÇČÉĘËĚÍÎĎĐŃŇÓÔŐÖ×ŘŮÚŰÜÝŢßŕáâăäĺćçčéęëěíîďđńňóôőö÷řůúűüýţ˙"
            },
            win1250: "windows1250",
            cp1250: "windows1250",
            windows1251: {
                type: "_sbcs",
                chars: "ЂЃ‚ѓ„…†‡€‰Љ‹ЊЌЋЏђ‘’“”•–—�™љ›њќћџ ЎўЈ¤Ґ¦§Ё©Є«¬­®Ї°±Ііґµ¶·ё№є»јЅѕїАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
            },
            win1251: "windows1251",
            cp1251: "windows1251",
            windows1252: {
                type: "_sbcs",
                chars: "€�‚ƒ„…†‡ˆ‰Š‹Œ�Ž��‘’“”•–—˜™š›œ�žŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
            },
            win1252: "windows1252",
            cp1252: "windows1252",
            windows1253: {
                type: "_sbcs",
                chars: "€�‚ƒ„…†‡�‰�‹�����‘’“”•–—�™�›���� ΅Ά£¤¥¦§¨©�«¬­®―°±²³΄µ¶·ΈΉΊ»Ό½ΎΏΐΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ�ΣΤΥΦΧΨΩΪΫάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ�"
            },
            win1253: "windows1253",
            cp1253: "windows1253",
            windows1254: {
                type: "_sbcs",
                chars: "€�‚ƒ„…†‡ˆ‰Š‹Œ����‘’“”•–—˜™š›œ��Ÿ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ"
            },
            win1254: "windows1254",
            cp1254: "windows1254",
            windows1255: {
                type: "_sbcs",
                chars: "€�‚ƒ„…†‡ˆ‰�‹�����‘’“”•–—˜™�›���� ¡¢£₪¥¦§¨©×«¬­®¯°±²³´µ¶·¸¹÷»¼½¾¿ְֱֲֳִֵֶַָֹֺֻּֽ־ֿ׀ׁׂ׃װױײ׳״�������אבגדהוזחטיךכלםמןנסעףפץצקרשת��‎‏�"
            },
            win1255: "windows1255",
            cp1255: "windows1255",
            windows1256: {
                type: "_sbcs",
                chars: "€پ‚ƒ„…†‡ˆ‰ٹ‹Œچژڈگ‘’“”•–—ک™ڑ›œ‌‍ں ،¢£¤¥¦§¨©ھ«¬­®¯°±²³´µ¶·¸¹؛»¼½¾؟ہءآأؤإئابةتثجحخدذرزسشصض×طظعغـفقكàلâمنهوçèéêëىيîïًٌٍَôُِ÷ّùْûü‎‏ے"
            },
            win1256: "windows1256",
            cp1256: "windows1256",
            windows1257: {
                type: "_sbcs",
                chars: "€�‚�„…†‡�‰�‹�¨ˇ¸�‘’“”•–—�™�›�¯˛� �¢£¤�¦§Ø©Ŗ«¬­®Æ°±²³´µ¶·ø¹ŗ»¼½¾æĄĮĀĆÄÅĘĒČÉŹĖĢĶĪĻŠŃŅÓŌÕÖ×ŲŁŚŪÜŻŽßąįāćäåęēčéźėģķīļšńņóōõö÷ųłśūüżž˙"
            },
            win1257: "windows1257",
            cp1257: "windows1257",
            windows1258: {
                type: "_sbcs",
                chars: "€�‚ƒ„…†‡ˆ‰�‹Œ����‘’“”•–—˜™�›œ��Ÿ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ"
            },
            win1258: "windows1258",
            cp1258: "windows1258",
            iso88591: {
                type: "_sbcs",
                chars: " ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
            },
            cp28591: "iso88591",
            iso88592: {
                type: "_sbcs",
                chars: " Ą˘Ł¤ĽŚ§¨ŠŞŤŹ­ŽŻ°ą˛ł´ľśˇ¸šşťź˝žżŔÁÂĂÄĹĆÇČÉĘËĚÍÎĎĐŃŇÓÔŐÖ×ŘŮÚŰÜÝŢßŕáâăäĺćçčéęëěíîďđńňóôőö÷řůúűüýţ˙"
            },
            cp28592: "iso88592",
            iso88593: {
                type: "_sbcs",
                chars: " Ħ˘£¤�Ĥ§¨İŞĞĴ­�Ż°ħ²³´µĥ·¸ışğĵ½�żÀÁÂ�ÄĊĈÇÈÉÊËÌÍÎÏ�ÑÒÓÔĠÖ×ĜÙÚÛÜŬŜßàáâ�äċĉçèéêëìíîï�ñòóôġö÷ĝùúûüŭŝ˙"
            },
            cp28593: "iso88593",
            iso88594: {
                type: "_sbcs",
                chars: " ĄĸŖ¤ĨĻ§¨ŠĒĢŦ­Ž¯°ą˛ŗ´ĩļˇ¸šēģŧŊžŋĀÁÂÃÄÅÆĮČÉĘËĖÍÎĪĐŅŌĶÔÕÖ×ØŲÚÛÜŨŪßāáâãäåæįčéęëėíîīđņōķôõö÷øųúûüũū˙"
            },
            cp28594: "iso88594",
            iso88595: {
                type: "_sbcs",
                chars: " ЁЂЃЄЅІЇЈЉЊЋЌ­ЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя№ёђѓєѕіїјљњћќ§ўџ"
            },
            cp28595: "iso88595",
            iso88596: {
                type: "_sbcs",
                chars: " ���¤�������،­�������������؛���؟�ءآأؤإئابةتثجحخدذرزسشصضطظعغ�����ـفقكلمنهوىيًٌٍَُِّْ�������������"
            },
            cp28596: "iso88596",
            iso88597: {
                type: "_sbcs",
                chars: " ‘’£€₯¦§¨©ͺ«¬­�―°±²³΄΅Ά·ΈΉΊ»Ό½ΎΏΐΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ�ΣΤΥΦΧΨΩΪΫάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ�"
            },
            cp28597: "iso88597",
            iso88598: {
                type: "_sbcs",
                chars: " �¢£¤¥¦§¨©×«¬­®¯°±²³´µ¶·¸¹÷»¼½¾��������������������������������‗אבגדהוזחטיךכלםמןנסעףפץצקרשת��‎‏�"
            },
            cp28598: "iso88598",
            iso88599: {
                type: "_sbcs",
                chars: " ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ"
            },
            cp28599: "iso88599",
            iso885910: {
                type: "_sbcs",
                chars: " ĄĒĢĪĨĶ§ĻĐŠŦŽ­ŪŊ°ąēģīĩķ·ļđšŧž―ūŋĀÁÂÃÄÅÆĮČÉĘËĖÍÎÏÐŅŌÓÔÕÖŨØŲÚÛÜÝÞßāáâãäåæįčéęëėíîïðņōóôõöũøųúûüýþĸ"
            },
            cp28600: "iso885910",
            iso885911: {
                type: "_sbcs",
                chars: " กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
            },
            cp28601: "iso885911",
            iso885913: {
                type: "_sbcs",
                chars: " ”¢£¤„¦§Ø©Ŗ«¬­®Æ°±²³“µ¶·ø¹ŗ»¼½¾æĄĮĀĆÄÅĘĒČÉŹĖĢĶĪĻŠŃŅÓŌÕÖ×ŲŁŚŪÜŻŽßąįāćäåęēčéźėģķīļšńņóōõö÷ųłśūüżž’"
            },
            cp28603: "iso885913",
            iso885914: {
                type: "_sbcs",
                chars: " Ḃḃ£ĊċḊ§Ẁ©ẂḋỲ­®ŸḞḟĠġṀṁ¶ṖẁṗẃṠỳẄẅṡÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏŴÑÒÓÔÕÖṪØÙÚÛÜÝŶßàáâãäåæçèéêëìíîïŵñòóôõöṫøùúûüýŷÿ"
            },
            cp28604: "iso885914",
            iso885915: {
                type: "_sbcs",
                chars: " ¡¢£€¥Š§š©ª«¬­®¯°±²³Žµ¶·ž¹º»ŒœŸ¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
            },
            cp28605: "iso885915",
            iso885916: {
                type: "_sbcs",
                chars: " ĄąŁ€„Š§š©Ș«Ź­źŻ°±ČłŽ”¶·žčș»ŒœŸżÀÁÂĂÄĆÆÇÈÉÊËÌÍÎÏĐŃÒÓÔŐÖŚŰÙÚÛÜĘȚßàáâăäćæçèéêëìíîïđńòóôőöśűùúûüęțÿ"
            },
            cp28606: "iso885916",
            cp437: {
                type: "_sbcs",
                chars: "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
            },
            ibm437: "cp437",
            csibm437: "cp437",
            cp737: {
                type: "_sbcs",
                chars: "ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρσςτυφχψ░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀ωάέήϊίόύϋώΆΈΉΊΌΎΏ±≥≤ΪΫ÷≈°∙·√ⁿ²■ "
            },
            ibm737: "cp737",
            csibm737: "cp737",
            cp775: {
                type: "_sbcs",
                chars: "ĆüéāäģåćłēŖŗīŹÄÅÉæÆōöĢ¢ŚśÖÜø£Ø×¤ĀĪóŻżź”¦©®¬½¼Ł«»░▒▓│┤ĄČĘĖ╣║╗╝ĮŠ┐└┴┬├─┼ŲŪ╚╔╩╦╠═╬Žąčęėįšųūž┘┌█▄▌▐▀ÓßŌŃõÕµńĶķĻļņĒŅ’­±“¾¶§÷„°∙·¹³²■ "
            },
            ibm775: "cp775",
            csibm775: "cp775",
            cp850: {
                type: "_sbcs",
                chars: "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ðÐÊËÈıÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµþÞÚÛÙýÝ¯´­±‗¾¶§÷¸°¨·¹³²■ "
            },
            ibm850: "cp850",
            csibm850: "cp850",
            cp852: {
                type: "_sbcs",
                chars: "ÇüéâäůćçłëŐőîŹÄĆÉĹĺôöĽľŚśÖÜŤťŁ×čáíóúĄąŽžĘę¬źČş«»░▒▓│┤ÁÂĚŞ╣║╗╝Żż┐└┴┬├─┼Ăă╚╔╩╦╠═╬¤đĐĎËďŇÍÎě┘┌█▄ŢŮ▀ÓßÔŃńňŠšŔÚŕŰýÝţ´­˝˛ˇ˘§÷¸°¨˙űŘř■ "
            },
            ibm852: "cp852",
            csibm852: "cp852",
            cp855: {
                type: "_sbcs",
                chars: "ђЂѓЃёЁєЄѕЅіІїЇјЈљЉњЊћЋќЌўЎџЏюЮъЪаАбБцЦдДеЕфФгГ«»░▒▓│┤хХиИ╣║╗╝йЙ┐└┴┬├─┼кК╚╔╩╦╠═╬¤лЛмМнНоОп┘┌█▄Пя▀ЯрРсСтТуУжЖвВьЬ№­ыЫзЗшШэЭщЩчЧ§■ "
            },
            ibm855: "cp855",
            csibm855: "cp855",
            cp856: {
                type: "_sbcs",
                chars: "אבגדהוזחטיךכלםמןנסעףפץצקרשת�£�×����������®¬½¼�«»░▒▓│┤���©╣║╗╝¢¥┐└┴┬├─┼��╚╔╩╦╠═╬¤���������┘┌█▄¦�▀������µ�������¯´­±‗¾¶§÷¸°¨·¹³²■ "
            },
            ibm856: "cp856",
            csibm856: "cp856",
            cp857: {
                type: "_sbcs",
                chars: "ÇüéâäàåçêëèïîıÄÅÉæÆôöòûùİÖÜø£ØŞşáíóúñÑĞğ¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ºªÊËÈ�ÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµ�×ÚÛÙìÿ¯´­±�¾¶§÷¸°¨·¹³²■ "
            },
            ibm857: "cp857",
            csibm857: "cp857",
            cp858: {
                type: "_sbcs",
                chars: "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ðÐÊËÈ€ÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµþÞÚÛÙýÝ¯´­±‗¾¶§÷¸°¨·¹³²■ "
            },
            ibm858: "cp858",
            csibm858: "cp858",
            cp860: {
                type: "_sbcs",
                chars: "ÇüéâãàÁçêÊèÍÔìÃÂÉÀÈôõòÚùÌÕÜ¢£Ù₧ÓáíóúñÑªº¿Ò¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
            },
            ibm860: "cp860",
            csibm860: "cp860",
            cp861: {
                type: "_sbcs",
                chars: "ÇüéâäàåçêëèÐðÞÄÅÉæÆôöþûÝýÖÜø£Ø₧ƒáíóúÁÍÓÚ¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
            },
            ibm861: "cp861",
            csibm861: "cp861",
            cp862: {
                type: "_sbcs",
                chars: "אבגדהוזחטיךכלםמןנסעףפץצקרשת¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
            },
            ibm862: "cp862",
            csibm862: "cp862",
            cp863: {
                type: "_sbcs",
                chars: "ÇüéâÂà¶çêëèïî‗À§ÉÈÊôËÏûù¤ÔÜ¢£ÙÛƒ¦´óú¨¸³¯Î⌐¬½¼¾«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
            },
            ibm863: "cp863",
            csibm863: "cp863",
            cp864: {
                type: "_sbcs",
                chars: "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$٪&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~°·∙√▒─│┼┤┬├┴┐┌└┘β∞φ±½¼≈«»ﻷﻸ��ﻻﻼ� ­ﺂ£¤ﺄ��ﺎﺏﺕﺙ،ﺝﺡﺥ٠١٢٣٤٥٦٧٨٩ﻑ؛ﺱﺵﺹ؟¢ﺀﺁﺃﺅﻊﺋﺍﺑﺓﺗﺛﺟﺣﺧﺩﺫﺭﺯﺳﺷﺻﺿﻁﻅﻋﻏ¦¬÷×ﻉـﻓﻗﻛﻟﻣﻧﻫﻭﻯﻳﺽﻌﻎﻍﻡﹽّﻥﻩﻬﻰﻲﻐﻕﻵﻶﻝﻙﻱ■�"
            },
            ibm864: "cp864",
            csibm864: "cp864",
            cp865: {
                type: "_sbcs",
                chars: "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø₧ƒáíóúñÑªº¿⌐¬½¼¡«¤░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
            },
            ibm865: "cp865",
            csibm865: "cp865",
            cp866: {
                type: "_sbcs",
                chars: "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёЄєЇїЎў°∙·√№¤■ "
            },
            ibm866: "cp866",
            csibm866: "cp866",
            cp869: {
                type: "_sbcs",
                chars: "������Ά�·¬¦‘’Έ―ΉΊΪΌ��ΎΫ©Ώ²³ά£έήίϊΐόύΑΒΓΔΕΖΗ½ΘΙ«»░▒▓│┤ΚΛΜΝ╣║╗╝ΞΟ┐└┴┬├─┼ΠΡ╚╔╩╦╠═╬ΣΤΥΦΧΨΩαβγ┘┌█▄δε▀ζηθικλμνξοπρσςτ΄­±υφχ§ψ΅°¨ωϋΰώ■ "
            },
            ibm869: "cp869",
            csibm869: "cp869",
            cp922: {
                type: "_sbcs",
                chars: " ¡¢£¤¥¦§¨©ª«¬­®‾°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏŠÑÒÓÔÕÖ×ØÙÚÛÜÝŽßàáâãäåæçèéêëìíîïšñòóôõö÷øùúûüýžÿ"
            },
            ibm922: "cp922",
            csibm922: "cp922",
            cp1046: {
                type: "_sbcs",
                chars: "ﺈ×÷ﹱ■│─┐┌└┘ﹹﹻﹽﹿﹷﺊﻰﻳﻲﻎﻏﻐﻶﻸﻺﻼ ¤ﺋﺑﺗﺛﺟﺣ،­ﺧﺳ٠١٢٣٤٥٦٧٨٩ﺷ؛ﺻﺿﻊ؟ﻋءآأؤإئابةتثجحخدذرزسشصضطﻇعغﻌﺂﺄﺎﻓـفقكلمنهوىيًٌٍَُِّْﻗﻛﻟﻵﻷﻹﻻﻣﻧﻬﻩ�"
            },
            ibm1046: "cp1046",
            csibm1046: "cp1046",
            cp1124: {
                type: "_sbcs",
                chars: " ЁЂҐЄЅІЇЈЉЊЋЌ­ЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя№ёђґєѕіїјљњћќ§ўџ"
            },
            ibm1124: "cp1124",
            csibm1124: "cp1124",
            cp1125: {
                type: "_sbcs",
                chars: "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёҐґЄєІіЇї·√№¤■ "
            },
            ibm1125: "cp1125",
            csibm1125: "cp1125",
            cp1129: {
                type: "_sbcs",
                chars: " ¡¢£¤¥¦§œ©ª«¬­®¯°±²³Ÿµ¶·Œ¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ"
            },
            ibm1129: "cp1129",
            csibm1129: "cp1129",
            cp1133: {
                type: "_sbcs",
                chars: " ກຂຄງຈສຊຍດຕຖທນບປຜຝພຟມຢຣລວຫອຮ���ຯະາຳິີຶືຸູຼັົຽ���ເແໂໃໄ່້໊໋໌ໍໆ�ໜໝ₭����������������໐໑໒໓໔໕໖໗໘໙��¢¬¦�"
            },
            ibm1133: "cp1133",
            csibm1133: "cp1133",
            cp1161: {
                type: "_sbcs",
                chars: "��������������������������������่กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู้๊๋€฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛¢¬¦ "
            },
            ibm1161: "cp1161",
            csibm1161: "cp1161",
            cp1162: {
                type: "_sbcs",
                chars: "€…‘’“”•–— กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
            },
            ibm1162: "cp1162",
            csibm1162: "cp1162",
            cp1163: {
                type: "_sbcs",
                chars: " ¡¢£€¥¦§œ©ª«¬­®¯°±²³Ÿµ¶·Œ¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ"
            },
            ibm1163: "cp1163",
            csibm1163: "cp1163",
            maccroatian: {
                type: "_sbcs",
                chars: "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊�©⁄¤‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ"
            },
            maccyrillic: {
                type: "_sbcs",
                chars: "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°¢£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµ∂ЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю¤"
            },
            macgreek: {
                type: "_sbcs",
                chars: "Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦­ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ�"
            },
            maciceland: {
                type: "_sbcs",
                chars: "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
            },
            macroman: {
                type: "_sbcs",
                chars: "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
            },
            macromania: {
                type: "_sbcs",
                chars: "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂŞ∞±≤≥¥µ∂∑∏π∫ªºΩăş¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›Ţţ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
            },
            macthai: {
                type: "_sbcs",
                chars: "«»…“”�•‘’� กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู﻿​–—฿เแโใไๅๆ็่้๊๋์ํ™๏๐๑๒๓๔๕๖๗๘๙®©����"
            },
            macturkish: {
                type: "_sbcs",
                chars: "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙ�ˆ˜¯˘˙˚¸˝˛ˇ"
            },
            macukraine: {
                type: "_sbcs",
                chars: "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю¤"
            },
            koi8r: {
                type: "_sbcs",
                chars: "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ё╓╔╕╖╗╘╙╚╛╜╝╞╟╠╡Ё╢╣╤╥╦╧╨╩╪╫╬©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
            },
            koi8u: {
                type: "_sbcs",
                chars: "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ёє╔ії╗╘╙╚╛ґ╝╞╟╠╡ЁЄ╣ІЇ╦╧╨╩╪Ґ╬©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
            },
            koi8ru: {
                type: "_sbcs",
                chars: "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ёє╔ії╗╘╙╚╛ґў╞╟╠╡ЁЄ╣ІЇ╦╧╨╩╪ҐЎ©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
            },
            koi8t: {
                type: "_sbcs",
                chars: "қғ‚Ғ„…†‡�‰ҳ‹ҲҷҶ�Қ‘’“”•–—�™�›�����ӯӮё¤ӣ¦§���«¬­®�°±²Ё�Ӣ¶·�№�»���©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
            },
            armscii8: {
                type: "_sbcs",
                chars: " �և։)(»«—.՝,-֊…՜՛՞ԱաԲբԳգԴդԵեԶզԷէԸըԹթԺժԻիԼլԽխԾծԿկՀհՁձՂղՃճՄմՅյՆնՇշՈոՉչՊպՋջՌռՍսՎվՏտՐրՑցՒւՓփՔքՕօՖֆ՚�"
            },
            rk1048: {
                type: "_sbcs",
                chars: "ЂЃ‚ѓ„…†‡€‰Љ‹ЊҚҺЏђ‘’“”•–—�™љ›њқһџ ҰұӘ¤Ө¦§Ё©Ғ«¬­®Ү°±Ііөµ¶·ё№ғ»әҢңүАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
            },
            tcvn: {
                type: "_sbcs",
                chars: "\u0000ÚỤ\u0003ỪỬỮ\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010ỨỰỲỶỸÝỴ\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ÀẢÃÁẠẶẬÈẺẼÉẸỆÌỈĨÍỊÒỎÕÓỌỘỜỞỠỚỢÙỦŨ ĂÂÊÔƠƯĐăâêôơưđẶ̀̀̉̃́àảãáạẲằẳẵắẴẮẦẨẪẤỀặầẩẫấậèỂẻẽéẹềểễếệìỉỄẾỒĩíịòỔỏõóọồổỗốộờởỡớợùỖủũúụừửữứựỳỷỹýỵỐ"
            },
            georgianacademy: {
                type: "_sbcs",
                chars: "‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿აბგდევზთიკლმნოპჟრსტუფქღყშჩცძწჭხჯჰჱჲჳჴჵჶçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
            },
            georgianps: {
                type: "_sbcs",
                chars: "‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿აბგდევზჱთიკლმნჲოპჟრსტჳუფქღყშჩცძწჭხჴჯჰჵæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
            },
            pt154: {
                type: "_sbcs",
                chars: "ҖҒӮғ„…ҶҮҲүҠӢҢҚҺҸҗ‘’“”•–—ҳҷҡӣңқһҹ ЎўЈӨҘҰ§Ё©Ә«¬ӯ®Ҝ°ұІіҙө¶·ё№ә»јҪҫҝАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
            },
            viscii: {
                type: "_sbcs",
                chars: "\u0000\u0001Ẳ\u0003\u0004ẴẪ\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013Ỷ\u0015\u0016\u0017\u0018Ỹ\u001a\u001b\u001c\u001dỴ\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ẠẮẰẶẤẦẨẬẼẸẾỀỂỄỆỐỒỔỖỘỢỚỜỞỊỎỌỈỦŨỤỲÕắằặấầẩậẽẹếềểễệốồổỗỠƠộờởịỰỨỪỬơớƯÀÁÂÃẢĂẳẵÈÉÊẺÌÍĨỳĐứÒÓÔạỷừửÙÚỹỵÝỡưàáâãảăữẫèéêẻìíĩỉđựòóôõỏọụùúũủýợỮ"
            },
            iso646cn: {
                type: "_sbcs",
                chars: "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#¥%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}‾��������������������������������������������������������������������������������������������������������������������������������"
            },
            iso646jp: {
                type: "_sbcs",
                chars: "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[¥]^_`abcdefghijklmnopqrstuvwxyz{|}‾��������������������������������������������������������������������������������������������������������������������������������"
            },
            hproman8: {
                type: "_sbcs",
                chars: " ÀÂÈÊËÎÏ´ˋˆ¨˜ÙÛ₤¯Ýý°ÇçÑñ¡¿¤£¥§ƒ¢âêôûáéóúàèòùäëöüÅîØÆåíøæÄìÖÜÉïßÔÁÃãÐðÍÌÓÒÕõŠšÚŸÿÞþ·µ¶¾—¼½ªº«■»±�"
            },
            macintosh: {
                type: "_sbcs",
                chars: "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
            },
            ascii: {
                type: "_sbcs",
                chars: "��������������������������������������������������������������������������������������������������������������������������������"
            },
            tis620: {
                type: "_sbcs",
                chars: "���������������������������������กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
            }
        };
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-data.js": function(module) {
        "use strict";
        module.exports = {
            10029: "maccenteuro",
            maccenteuro: {
                type: "_sbcs",
                chars: "ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ"
            },
            808: "cp808",
            ibm808: "cp808",
            cp808: {
                type: "_sbcs",
                chars: "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёЄєЇїЎў°∙·√№€■ "
            },
            mik: {
                type: "_sbcs",
                chars: "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя└┴┬├─┼╣║╚╔╩╦╠═╬┐░▒▓│┤№§╗╝┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
            },
            ascii8bit: "ascii",
            usascii: "ascii",
            ansix34: "ascii",
            ansix341968: "ascii",
            ansix341986: "ascii",
            csascii: "ascii",
            cp367: "ascii",
            ibm367: "ascii",
            isoir6: "ascii",
            iso646us: "ascii",
            iso646irv: "ascii",
            us: "ascii",
            latin1: "iso88591",
            latin2: "iso88592",
            latin3: "iso88593",
            latin4: "iso88594",
            latin5: "iso88599",
            latin6: "iso885910",
            latin7: "iso885913",
            latin8: "iso885914",
            latin9: "iso885915",
            latin10: "iso885916",
            csisolatin1: "iso88591",
            csisolatin2: "iso88592",
            csisolatin3: "iso88593",
            csisolatin4: "iso88594",
            csisolatincyrillic: "iso88595",
            csisolatinarabic: "iso88596",
            csisolatingreek: "iso88597",
            csisolatinhebrew: "iso88598",
            csisolatin5: "iso88599",
            csisolatin6: "iso885910",
            l1: "iso88591",
            l2: "iso88592",
            l3: "iso88593",
            l4: "iso88594",
            l5: "iso88599",
            l6: "iso885910",
            l7: "iso885913",
            l8: "iso885914",
            l9: "iso885915",
            l10: "iso885916",
            isoir14: "iso646jp",
            isoir57: "iso646cn",
            isoir100: "iso88591",
            isoir101: "iso88592",
            isoir109: "iso88593",
            isoir110: "iso88594",
            isoir144: "iso88595",
            isoir127: "iso88596",
            isoir126: "iso88597",
            isoir138: "iso88598",
            isoir148: "iso88599",
            isoir157: "iso885910",
            isoir166: "tis620",
            isoir179: "iso885913",
            isoir199: "iso885914",
            isoir203: "iso885915",
            isoir226: "iso885916",
            cp819: "iso88591",
            ibm819: "iso88591",
            cyrillic: "iso88595",
            arabic: "iso88596",
            arabic8: "iso88596",
            ecma114: "iso88596",
            asmo708: "iso88596",
            greek: "iso88597",
            greek8: "iso88597",
            ecma118: "iso88597",
            elot928: "iso88597",
            hebrew: "iso88598",
            hebrew8: "iso88598",
            turkish: "iso88599",
            turkish8: "iso88599",
            thai: "iso885911",
            thai8: "iso885911",
            celtic: "iso885914",
            celtic8: "iso885914",
            isoceltic: "iso885914",
            tis6200: "tis620",
            tis62025291: "tis620",
            tis62025330: "tis620",
            10000: "macroman",
            10006: "macgreek",
            10007: "maccyrillic",
            10079: "maciceland",
            10081: "macturkish",
            cspc8codepage437: "cp437",
            cspc775baltic: "cp775",
            cspc850multilingual: "cp850",
            cspcp852: "cp852",
            cspc862latinhebrew: "cp862",
            cpgr: "cp869",
            msee: "cp1250",
            mscyrl: "cp1251",
            msansi: "cp1252",
            msgreek: "cp1253",
            msturk: "cp1254",
            mshebr: "cp1255",
            msarab: "cp1256",
            winbaltrim: "cp1257",
            cp20866: "koi8r",
            20866: "koi8r",
            ibm878: "koi8r",
            cskoi8r: "koi8r",
            cp21866: "koi8u",
            21866: "koi8u",
            ibm1168: "koi8u",
            strk10482002: "rk1048",
            tcvn5712: "tcvn",
            tcvn57121: "tcvn",
            gb198880: "iso646cn",
            cn: "iso646cn",
            csiso14jisc6220ro: "iso646jp",
            jisc62201969ro: "iso646jp",
            jp: "iso646jp",
            cshproman8: "hproman8",
            r8: "hproman8",
            roman8: "hproman8",
            xroman8: "hproman8",
            ibm1051: "hproman8",
            mac: "macintosh",
            csmacintosh: "macintosh"
        };
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/utf16.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js").Buffer;
        exports1.utf16be = Utf16BECodec;
        function Utf16BECodec() {}
        Utf16BECodec.prototype.encoder = Utf16BEEncoder;
        Utf16BECodec.prototype.decoder = Utf16BEDecoder;
        Utf16BECodec.prototype.bomAware = true;
        function Utf16BEEncoder() {}
        Utf16BEEncoder.prototype.write = function(str) {
            var buf = Buffer1.from(str, 'ucs2');
            for(var i = 0; i < buf.length; i += 2){
                var tmp = buf[i];
                buf[i] = buf[i + 1];
                buf[i + 1] = tmp;
            }
            return buf;
        };
        Utf16BEEncoder.prototype.end = function() {};
        function Utf16BEDecoder() {
            this.overflowByte = -1;
        }
        Utf16BEDecoder.prototype.write = function(buf) {
            if (0 == buf.length) return '';
            var buf2 = Buffer1.alloc(buf.length + 1), i = 0, j = 0;
            if (-1 !== this.overflowByte) {
                buf2[0] = buf[0];
                buf2[1] = this.overflowByte;
                i = 1;
                j = 2;
            }
            for(; i < buf.length - 1; i += 2, j += 2){
                buf2[j] = buf[i + 1];
                buf2[j + 1] = buf[i];
            }
            this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
            return buf2.slice(0, j).toString('ucs2');
        };
        Utf16BEDecoder.prototype.end = function() {};
        exports1.utf16 = Utf16Codec;
        function Utf16Codec(codecOptions, iconv) {
            this.iconv = iconv;
        }
        Utf16Codec.prototype.encoder = Utf16Encoder;
        Utf16Codec.prototype.decoder = Utf16Decoder;
        function Utf16Encoder(options, codec) {
            options = options || {};
            if (void 0 === options.addBOM) options.addBOM = true;
            this.encoder = codec.iconv.getEncoder('utf-16le', options);
        }
        Utf16Encoder.prototype.write = function(str) {
            return this.encoder.write(str);
        };
        Utf16Encoder.prototype.end = function() {
            return this.encoder.end();
        };
        function Utf16Decoder(options, codec) {
            this.decoder = null;
            this.initialBytes = [];
            this.initialBytesLen = 0;
            this.options = options || {};
            this.iconv = codec.iconv;
        }
        Utf16Decoder.prototype.write = function(buf) {
            if (!this.decoder) {
                this.initialBytes.push(buf);
                this.initialBytesLen += buf.length;
                if (this.initialBytesLen < 16) return '';
                var buf = Buffer1.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
                this.decoder = this.iconv.getDecoder(encoding, this.options);
                this.initialBytes.length = this.initialBytesLen = 0;
            }
            return this.decoder.write(buf);
        };
        Utf16Decoder.prototype.end = function() {
            if (!this.decoder) {
                var buf = Buffer1.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
                this.decoder = this.iconv.getDecoder(encoding, this.options);
                var res = this.decoder.write(buf), trail = this.decoder.end();
                return trail ? res + trail : res;
            }
            return this.decoder.end();
        };
        function detectEncoding(buf, defaultEncoding) {
            var enc = defaultEncoding || 'utf-16le';
            if (buf.length >= 2) if (0xFE == buf[0] && 0xFF == buf[1]) enc = 'utf-16be';
            else if (0xFF == buf[0] && 0xFE == buf[1]) enc = 'utf-16le';
            else {
                var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
                for(var i = 0; i < _len; i += 2){
                    if (0 === buf[i] && 0 !== buf[i + 1]) asciiCharsBE++;
                    if (0 !== buf[i] && 0 === buf[i + 1]) asciiCharsLE++;
                }
                if (asciiCharsBE > asciiCharsLE) enc = 'utf-16be';
                else if (asciiCharsBE < asciiCharsLE) enc = 'utf-16le';
            }
            return enc;
        }
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/utf7.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js").Buffer;
        exports1.utf7 = Utf7Codec;
        exports1.unicode11utf7 = 'utf7';
        function Utf7Codec(codecOptions, iconv) {
            this.iconv = iconv;
        }
        Utf7Codec.prototype.encoder = Utf7Encoder;
        Utf7Codec.prototype.decoder = Utf7Decoder;
        Utf7Codec.prototype.bomAware = true;
        var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
        function Utf7Encoder(options, codec) {
            this.iconv = codec.iconv;
        }
        Utf7Encoder.prototype.write = function(str) {
            return Buffer1.from(str.replace(nonDirectChars, (function(chunk) {
                return "+" + ('+' === chunk ? '' : this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) + "-";
            }).bind(this)));
        };
        Utf7Encoder.prototype.end = function() {};
        function Utf7Decoder(options, codec) {
            this.iconv = codec.iconv;
            this.inBase64 = false;
            this.base64Accum = '';
        }
        var base64Regex = /[A-Za-z0-9\/+]/;
        var base64Chars = [];
        for(var i = 0; i < 256; i++)base64Chars[i] = base64Regex.test(String.fromCharCode(i));
        var plusChar = '+'.charCodeAt(0), minusChar = '-'.charCodeAt(0), andChar = '&'.charCodeAt(0);
        Utf7Decoder.prototype.write = function(buf) {
            var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
            for(var i = 0; i < buf.length; i++)if (inBase64) {
                if (!base64Chars[buf[i]]) {
                    if (i == lastI && buf[i] == minusChar) res += "+";
                    else {
                        var b64str = base64Accum + buf.slice(lastI, i).toString();
                        res += this.iconv.decode(Buffer1.from(b64str, 'base64'), "utf16-be");
                    }
                    if (buf[i] != minusChar) i--;
                    lastI = i + 1;
                    inBase64 = false;
                    base64Accum = '';
                }
            } else if (buf[i] == plusChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii");
                lastI = i + 1;
                inBase64 = true;
            }
            if (inBase64) {
                var b64str = base64Accum + buf.slice(lastI).toString();
                var canBeDecoded = b64str.length - b64str.length % 8;
                base64Accum = b64str.slice(canBeDecoded);
                b64str = b64str.slice(0, canBeDecoded);
                res += this.iconv.decode(Buffer1.from(b64str, 'base64'), "utf16-be");
            } else res += this.iconv.decode(buf.slice(lastI), "ascii");
            this.inBase64 = inBase64;
            this.base64Accum = base64Accum;
            return res;
        };
        Utf7Decoder.prototype.end = function() {
            var res = "";
            if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer1.from(this.base64Accum, 'base64'), "utf16-be");
            this.inBase64 = false;
            this.base64Accum = '';
            return res;
        };
        exports1.utf7imap = Utf7IMAPCodec;
        function Utf7IMAPCodec(codecOptions, iconv) {
            this.iconv = iconv;
        }
        Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
        Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
        Utf7IMAPCodec.prototype.bomAware = true;
        function Utf7IMAPEncoder(options, codec) {
            this.iconv = codec.iconv;
            this.inBase64 = false;
            this.base64Accum = Buffer1.alloc(6);
            this.base64AccumIdx = 0;
        }
        Utf7IMAPEncoder.prototype.write = function(str) {
            var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer1.alloc(5 * str.length + 10), bufIdx = 0;
            for(var i = 0; i < str.length; i++){
                var uChar = str.charCodeAt(i);
                if (0x20 <= uChar && uChar <= 0x7E) {
                    if (inBase64) {
                        if (base64AccumIdx > 0) {
                            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                            base64AccumIdx = 0;
                        }
                        buf[bufIdx++] = minusChar;
                        inBase64 = false;
                    }
                    if (!inBase64) {
                        buf[bufIdx++] = uChar;
                        if (uChar === andChar) buf[bufIdx++] = minusChar;
                    }
                } else {
                    if (!inBase64) {
                        buf[bufIdx++] = andChar;
                        inBase64 = true;
                    }
                    if (inBase64) {
                        base64Accum[base64AccumIdx++] = uChar >> 8;
                        base64Accum[base64AccumIdx++] = 0xFF & uChar;
                        if (base64AccumIdx == base64Accum.length) {
                            bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
                            base64AccumIdx = 0;
                        }
                    }
                }
            }
            this.inBase64 = inBase64;
            this.base64AccumIdx = base64AccumIdx;
            return buf.slice(0, bufIdx);
        };
        Utf7IMAPEncoder.prototype.end = function() {
            var buf = Buffer1.alloc(10), bufIdx = 0;
            if (this.inBase64) {
                if (this.base64AccumIdx > 0) {
                    bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                    this.base64AccumIdx = 0;
                }
                buf[bufIdx++] = minusChar;
                this.inBase64 = false;
            }
            return buf.slice(0, bufIdx);
        };
        function Utf7IMAPDecoder(options, codec) {
            this.iconv = codec.iconv;
            this.inBase64 = false;
            this.base64Accum = '';
        }
        var base64IMAPChars = base64Chars.slice();
        base64IMAPChars[','.charCodeAt(0)] = true;
        Utf7IMAPDecoder.prototype.write = function(buf) {
            var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
            for(var i = 0; i < buf.length; i++)if (inBase64) {
                if (!base64IMAPChars[buf[i]]) {
                    if (i == lastI && buf[i] == minusChar) res += "&";
                    else {
                        var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
                        res += this.iconv.decode(Buffer1.from(b64str, 'base64'), "utf16-be");
                    }
                    if (buf[i] != minusChar) i--;
                    lastI = i + 1;
                    inBase64 = false;
                    base64Accum = '';
                }
            } else if (buf[i] == andChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii");
                lastI = i + 1;
                inBase64 = true;
            }
            if (inBase64) {
                var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');
                var canBeDecoded = b64str.length - b64str.length % 8;
                base64Accum = b64str.slice(canBeDecoded);
                b64str = b64str.slice(0, canBeDecoded);
                res += this.iconv.decode(Buffer1.from(b64str, 'base64'), "utf16-be");
            } else res += this.iconv.decode(buf.slice(lastI), "ascii");
            this.inBase64 = inBase64;
            this.base64Accum = base64Accum;
            return res;
        };
        Utf7IMAPDecoder.prototype.end = function() {
            var res = "";
            if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer1.from(this.base64Accum, 'base64'), "utf16-be");
            this.inBase64 = false;
            this.base64Accum = '';
            return res;
        };
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/bom-handling.js": function(__unused_webpack_module, exports1) {
        "use strict";
        var BOMChar = '\uFEFF';
        exports1.PrependBOM = PrependBOMWrapper;
        function PrependBOMWrapper(encoder, options) {
            this.encoder = encoder;
            this.addBOM = true;
        }
        PrependBOMWrapper.prototype.write = function(str) {
            if (this.addBOM) {
                str = BOMChar + str;
                this.addBOM = false;
            }
            return this.encoder.write(str);
        };
        PrependBOMWrapper.prototype.end = function() {
            return this.encoder.end();
        };
        exports1.StripBOM = StripBOMWrapper;
        function StripBOMWrapper(decoder, options) {
            this.decoder = decoder;
            this.pass = false;
            this.options = options || {};
        }
        StripBOMWrapper.prototype.write = function(buf) {
            var res = this.decoder.write(buf);
            if (this.pass || !res) return res;
            if (res[0] === BOMChar) {
                res = res.slice(1);
                if ('function' == typeof this.options.stripBOM) this.options.stripBOM();
            }
            this.pass = true;
            return res;
        };
        StripBOMWrapper.prototype.end = function() {
            return this.decoder.end();
        };
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/extend-node.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("buffer").Buffer;
        module.exports = function(iconv) {
            var original = void 0;
            iconv.supportsNodeEncodingsExtension = !(Buffer1.from || new Buffer1(0) instanceof Uint8Array);
            iconv.extendNodeEncodings = function() {
                if (original) return;
                original = {};
                if (!iconv.supportsNodeEncodingsExtension) {
                    console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
                    console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
                    return;
                }
                var nodeNativeEncodings = {
                    hex: true,
                    utf8: true,
                    'utf-8': true,
                    ascii: true,
                    binary: true,
                    base64: true,
                    ucs2: true,
                    'ucs-2': true,
                    utf16le: true,
                    'utf-16le': true
                };
                Buffer1.isNativeEncoding = function(enc) {
                    return enc && nodeNativeEncodings[enc.toLowerCase()];
                };
                var SlowBuffer = __webpack_require__("buffer").SlowBuffer;
                original.SlowBufferToString = SlowBuffer.prototype.toString;
                SlowBuffer.prototype.toString = function(encoding, start, end) {
                    encoding = String(encoding || 'utf8').toLowerCase();
                    if (Buffer1.isNativeEncoding(encoding)) return original.SlowBufferToString.call(this, encoding, start, end);
                    if (void 0 === start) start = 0;
                    if (void 0 === end) end = this.length;
                    return iconv.decode(this.slice(start, end), encoding);
                };
                original.SlowBufferWrite = SlowBuffer.prototype.write;
                SlowBuffer.prototype.write = function(string, offset, length, encoding) {
                    if (isFinite(offset)) {
                        if (!isFinite(length)) {
                            encoding = length;
                            length = void 0;
                        }
                    } else {
                        var swap = encoding;
                        encoding = offset;
                        offset = length;
                        length = swap;
                    }
                    offset = +offset || 0;
                    var remaining = this.length - offset;
                    if (length) {
                        length *= 1;
                        if (length > remaining) length = remaining;
                    } else length = remaining;
                    encoding = String(encoding || 'utf8').toLowerCase();
                    if (Buffer1.isNativeEncoding(encoding)) return original.SlowBufferWrite.call(this, string, offset, length, encoding);
                    if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError('attempt to write beyond buffer bounds');
                    var buf = iconv.encode(string, encoding);
                    if (buf.length < length) length = buf.length;
                    buf.copy(this, offset, 0, length);
                    return length;
                };
                original.BufferIsEncoding = Buffer1.isEncoding;
                Buffer1.isEncoding = function(encoding) {
                    return Buffer1.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
                };
                original.BufferByteLength = Buffer1.byteLength;
                Buffer1.byteLength = SlowBuffer.byteLength = function(str, encoding) {
                    encoding = String(encoding || 'utf8').toLowerCase();
                    if (Buffer1.isNativeEncoding(encoding)) return original.BufferByteLength.call(this, str, encoding);
                    return iconv.encode(str, encoding).length;
                };
                original.BufferToString = Buffer1.prototype.toString;
                Buffer1.prototype.toString = function(encoding, start, end) {
                    encoding = String(encoding || 'utf8').toLowerCase();
                    if (Buffer1.isNativeEncoding(encoding)) return original.BufferToString.call(this, encoding, start, end);
                    if (void 0 === start) start = 0;
                    if (void 0 === end) end = this.length;
                    return iconv.decode(this.slice(start, end), encoding);
                };
                original.BufferWrite = Buffer1.prototype.write;
                Buffer1.prototype.write = function(string, offset, length, encoding) {
                    var _offset = offset, _length = length, _encoding = encoding;
                    if (isFinite(offset)) {
                        if (!isFinite(length)) {
                            encoding = length;
                            length = void 0;
                        }
                    } else {
                        var swap = encoding;
                        encoding = offset;
                        offset = length;
                        length = swap;
                    }
                    encoding = String(encoding || 'utf8').toLowerCase();
                    if (Buffer1.isNativeEncoding(encoding)) return original.BufferWrite.call(this, string, _offset, _length, _encoding);
                    offset = +offset || 0;
                    var remaining = this.length - offset;
                    if (length) {
                        length *= 1;
                        if (length > remaining) length = remaining;
                    } else length = remaining;
                    if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError('attempt to write beyond buffer bounds');
                    var buf = iconv.encode(string, encoding);
                    if (buf.length < length) length = buf.length;
                    buf.copy(this, offset, 0, length);
                    return length;
                };
                if (iconv.supportsStreams) {
                    var Readable = __webpack_require__("stream").Readable;
                    original.ReadableSetEncoding = Readable.prototype.setEncoding;
                    Readable.prototype.setEncoding = function(enc, options) {
                        this._readableState.decoder = iconv.getDecoder(enc, options);
                        this._readableState.encoding = enc;
                    };
                    Readable.prototype.collect = iconv._collect;
                }
            };
            iconv.undoExtendNodeEncodings = function() {
                if (!iconv.supportsNodeEncodingsExtension) return;
                if (!original) throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
                delete Buffer1.isNativeEncoding;
                var SlowBuffer = __webpack_require__("buffer").SlowBuffer;
                SlowBuffer.prototype.toString = original.SlowBufferToString;
                SlowBuffer.prototype.write = original.SlowBufferWrite;
                Buffer1.isEncoding = original.BufferIsEncoding;
                Buffer1.byteLength = original.BufferByteLength;
                Buffer1.prototype.toString = original.BufferToString;
                Buffer1.prototype.write = original.BufferWrite;
                if (iconv.supportsStreams) {
                    var Readable = __webpack_require__("stream").Readable;
                    Readable.prototype.setEncoding = original.ReadableSetEncoding;
                    delete Readable.prototype.collect;
                }
                original = void 0;
            };
        };
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js").Buffer;
        var bomHandling = __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/bom-handling.js"), iconv = module.exports;
        iconv.encodings = null;
        iconv.defaultCharUnicode = '�';
        iconv.defaultCharSingleByte = '?';
        iconv.encode = function(str, encoding, options) {
            str = "" + (str || "");
            var encoder = iconv.getEncoder(encoding, options);
            var res = encoder.write(str);
            var trail = encoder.end();
            return trail && trail.length > 0 ? Buffer1.concat([
                res,
                trail
            ]) : res;
        };
        iconv.decode = function(buf, encoding, options) {
            if ('string' == typeof buf) {
                if (!iconv.skipDecodeWarning) {
                    console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
                    iconv.skipDecodeWarning = true;
                }
                buf = Buffer1.from("" + (buf || ""), "binary");
            }
            var decoder = iconv.getDecoder(encoding, options);
            var res = decoder.write(buf);
            var trail = decoder.end();
            return trail ? res + trail : res;
        };
        iconv.encodingExists = function(enc) {
            try {
                iconv.getCodec(enc);
                return true;
            } catch (e) {
                return false;
            }
        };
        iconv.toEncoding = iconv.encode;
        iconv.fromEncoding = iconv.decode;
        iconv._codecDataCache = {};
        iconv.getCodec = function(encoding) {
            if (!iconv.encodings) iconv.encodings = __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/index.js");
            var enc = iconv._canonicalizeEncoding(encoding);
            var codecOptions = {};
            while(true){
                var codec = iconv._codecDataCache[enc];
                if (codec) return codec;
                var codecDef = iconv.encodings[enc];
                switch(typeof codecDef){
                    case "string":
                        enc = codecDef;
                        break;
                    case "object":
                        for(var key in codecDef)codecOptions[key] = codecDef[key];
                        if (!codecOptions.encodingName) codecOptions.encodingName = enc;
                        enc = codecDef.type;
                        break;
                    case "function":
                        if (!codecOptions.encodingName) codecOptions.encodingName = enc;
                        codec = new codecDef(codecOptions, iconv);
                        iconv._codecDataCache[codecOptions.encodingName] = codec;
                        return codec;
                    default:
                        throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
                }
            }
        };
        iconv._canonicalizeEncoding = function(encoding) {
            return ('' + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
        };
        iconv.getEncoder = function(encoding, options) {
            var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
            if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);
            return encoder;
        };
        iconv.getDecoder = function(encoding, options) {
            var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
            if (codec.bomAware && !(options && false === options.stripBOM)) decoder = new bomHandling.StripBOM(decoder, options);
            return decoder;
        };
        var nodeVer = 'undefined' != typeof process && process.versions && process.versions.node;
        if (nodeVer) {
            var nodeVerArr = nodeVer.split(".").map(Number);
            if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/streams.js")(iconv);
            __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/extend-node.js")(iconv);
        }
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/streams.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("buffer").Buffer, Transform = __webpack_require__("stream").Transform;
        module.exports = function(iconv) {
            iconv.encodeStream = function(encoding, options) {
                return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
            };
            iconv.decodeStream = function(encoding, options) {
                return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
            };
            iconv.supportsStreams = true;
            iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
            iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
            iconv._collect = IconvLiteDecoderStream.prototype.collect;
        };
        function IconvLiteEncoderStream(conv, options) {
            this.conv = conv;
            options = options || {};
            options.decodeStrings = false;
            Transform.call(this, options);
        }
        IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
            constructor: {
                value: IconvLiteEncoderStream
            }
        });
        IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
            if ('string' != typeof chunk) return done(new Error("Iconv encoding stream needs strings as its input."));
            try {
                var res = this.conv.write(chunk);
                if (res && res.length) this.push(res);
                done();
            } catch (e) {
                done(e);
            }
        };
        IconvLiteEncoderStream.prototype._flush = function(done) {
            try {
                var res = this.conv.end();
                if (res && res.length) this.push(res);
                done();
            } catch (e) {
                done(e);
            }
        };
        IconvLiteEncoderStream.prototype.collect = function(cb) {
            var chunks = [];
            this.on('error', cb);
            this.on('data', function(chunk) {
                chunks.push(chunk);
            });
            this.on('end', function() {
                cb(null, Buffer1.concat(chunks));
            });
            return this;
        };
        function IconvLiteDecoderStream(conv, options) {
            this.conv = conv;
            options = options || {};
            options.encoding = this.encoding = 'utf8';
            Transform.call(this, options);
        }
        IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
            constructor: {
                value: IconvLiteDecoderStream
            }
        });
        IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
            if (!Buffer1.isBuffer(chunk)) return done(new Error("Iconv decoding stream needs buffers as its input."));
            try {
                var res = this.conv.write(chunk);
                if (res && res.length) this.push(res, this.encoding);
                done();
            } catch (e) {
                done(e);
            }
        };
        IconvLiteDecoderStream.prototype._flush = function(done) {
            try {
                var res = this.conv.end();
                if (res && res.length) this.push(res, this.encoding);
                done();
            } catch (e) {
                done(e);
            }
        };
        IconvLiteDecoderStream.prototype.collect = function(cb) {
            var res = '';
            this.on('error', cb);
            this.on('data', function(chunk) {
                res += chunk;
            });
            this.on('end', function() {
                cb(null, res);
            });
            return this;
        };
    },
    "../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js": function(module, __unused_webpack_exports, __webpack_require__) {
        try {
            var util = __webpack_require__("util");
            if ('function' != typeof util.inherits) throw '';
            module.exports = util.inherits;
        } catch (e) {
            module.exports = __webpack_require__("../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");
        }
    },
    "../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js": function(module) {
        if ('function' == typeof Object.create) module.exports = function(ctor, superCtor) {
            if (superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
            }
        };
        else module.exports = function(ctor, superCtor) {
            if (superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function() {};
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor();
                ctor.prototype.constructor = ctor;
            }
        };
    },
    "../node_modules/.pnpm/ipaddr.js@1.9.1/node_modules/ipaddr.js/lib/ipaddr.js": function(module, __unused_webpack_exports, __webpack_require__) {
        module = __webpack_require__.nmd(module);
        (function() {
            var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;
            ipaddr = {};
            root = this;
            if (null !== module && module.exports) module.exports = ipaddr;
            else root['ipaddr'] = ipaddr;
            matchCIDR = function(first, second, partSize, cidrBits) {
                var part, shift;
                if (first.length !== second.length) throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
                part = 0;
                while(cidrBits > 0){
                    shift = partSize - cidrBits;
                    if (shift < 0) shift = 0;
                    if (first[part] >> shift !== second[part] >> shift) return false;
                    cidrBits -= partSize;
                    part += 1;
                }
                return true;
            };
            ipaddr.subnetMatch = function(address, rangeList, defaultName) {
                var k, len, rangeName, rangeSubnets, subnet;
                if (null == defaultName) defaultName = 'unicast';
                for(rangeName in rangeList){
                    rangeSubnets = rangeList[rangeName];
                    if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) rangeSubnets = [
                        rangeSubnets
                    ];
                    for(k = 0, len = rangeSubnets.length; k < len; k++){
                        subnet = rangeSubnets[k];
                        if (address.kind() === subnet[0].kind()) {
                            if (address.match.apply(address, subnet)) return rangeName;
                        }
                    }
                }
                return defaultName;
            };
            ipaddr.IPv4 = function() {
                function IPv4(octets) {
                    var k, len, octet;
                    if (4 !== octets.length) throw new Error("ipaddr: ipv4 octet count should be 4");
                    for(k = 0, len = octets.length; k < len; k++){
                        octet = octets[k];
                        if (!(0 <= octet && octet <= 255)) throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
                    }
                    this.octets = octets;
                }
                IPv4.prototype.kind = function() {
                    return 'ipv4';
                };
                IPv4.prototype.toString = function() {
                    return this.octets.join(".");
                };
                IPv4.prototype.toNormalizedString = function() {
                    return this.toString();
                };
                IPv4.prototype.toByteArray = function() {
                    return this.octets.slice(0);
                };
                IPv4.prototype.match = function(other, cidrRange) {
                    var ref;
                    if (void 0 === cidrRange) ref = other, other = ref[0], cidrRange = ref[1];
                    if ('ipv4' !== other.kind()) throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
                    return matchCIDR(this.octets, other.octets, 8, cidrRange);
                };
                IPv4.prototype.SpecialRanges = {
                    unspecified: [
                        [
                            new IPv4([
                                0,
                                0,
                                0,
                                0
                            ]),
                            8
                        ]
                    ],
                    broadcast: [
                        [
                            new IPv4([
                                255,
                                255,
                                255,
                                255
                            ]),
                            32
                        ]
                    ],
                    multicast: [
                        [
                            new IPv4([
                                224,
                                0,
                                0,
                                0
                            ]),
                            4
                        ]
                    ],
                    linkLocal: [
                        [
                            new IPv4([
                                169,
                                254,
                                0,
                                0
                            ]),
                            16
                        ]
                    ],
                    loopback: [
                        [
                            new IPv4([
                                127,
                                0,
                                0,
                                0
                            ]),
                            8
                        ]
                    ],
                    carrierGradeNat: [
                        [
                            new IPv4([
                                100,
                                64,
                                0,
                                0
                            ]),
                            10
                        ]
                    ],
                    private: [
                        [
                            new IPv4([
                                10,
                                0,
                                0,
                                0
                            ]),
                            8
                        ],
                        [
                            new IPv4([
                                172,
                                16,
                                0,
                                0
                            ]),
                            12
                        ],
                        [
                            new IPv4([
                                192,
                                168,
                                0,
                                0
                            ]),
                            16
                        ]
                    ],
                    reserved: [
                        [
                            new IPv4([
                                192,
                                0,
                                0,
                                0
                            ]),
                            24
                        ],
                        [
                            new IPv4([
                                192,
                                0,
                                2,
                                0
                            ]),
                            24
                        ],
                        [
                            new IPv4([
                                192,
                                88,
                                99,
                                0
                            ]),
                            24
                        ],
                        [
                            new IPv4([
                                198,
                                51,
                                100,
                                0
                            ]),
                            24
                        ],
                        [
                            new IPv4([
                                203,
                                0,
                                113,
                                0
                            ]),
                            24
                        ],
                        [
                            new IPv4([
                                240,
                                0,
                                0,
                                0
                            ]),
                            4
                        ]
                    ]
                };
                IPv4.prototype.range = function() {
                    return ipaddr.subnetMatch(this, this.SpecialRanges);
                };
                IPv4.prototype.toIPv4MappedAddress = function() {
                    return ipaddr.IPv6.parse("::ffff:" + this.toString());
                };
                IPv4.prototype.prefixLengthFromSubnetMask = function() {
                    var cidr, i, k, octet, stop, zeros, zerotable;
                    zerotable = {
                        0: 8,
                        128: 7,
                        192: 6,
                        224: 5,
                        240: 4,
                        248: 3,
                        252: 2,
                        254: 1,
                        255: 0
                    };
                    cidr = 0;
                    stop = false;
                    for(i = k = 3; k >= 0; i = k += -1){
                        octet = this.octets[i];
                        if (!(octet in zerotable)) return null;
                        zeros = zerotable[octet];
                        if (stop && 0 !== zeros) return null;
                        if (8 !== zeros) stop = true;
                        cidr += zeros;
                    }
                    return 32 - cidr;
                };
                return IPv4;
            }();
            ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
            ipv4Regexes = {
                fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
                longValue: new RegExp("^" + ipv4Part + "$", 'i')
            };
            ipaddr.IPv4.parser = function(string) {
                var match, parseIntAuto, part, shift, value;
                parseIntAuto = function(string) {
                    if ("0" === string[0] && "x" !== string[1]) return parseInt(string, 8);
                    return parseInt(string);
                };
                if (match = string.match(ipv4Regexes.fourOctet)) return function() {
                    var k, len, ref, results;
                    ref = match.slice(1, 6);
                    results = [];
                    for(k = 0, len = ref.length; k < len; k++){
                        part = ref[k];
                        results.push(parseIntAuto(part));
                    }
                    return results;
                }();
                if (!(match = string.match(ipv4Regexes.longValue))) return null;
                value = parseIntAuto(match[1]);
                if (value > 0xffffffff || value < 0) throw new Error("ipaddr: address outside defined range");
                return (function() {
                    var k, results;
                    results = [];
                    for(shift = k = 0; k <= 24; shift = k += 8)results.push(value >> shift & 0xff);
                    return results;
                })().reverse();
            };
            ipaddr.IPv6 = function() {
                function IPv6(parts, zoneId) {
                    var i, k, l, len, part, ref;
                    if (16 === parts.length) {
                        this.parts = [];
                        for(i = k = 0; k <= 14; i = k += 2)this.parts.push(parts[i] << 8 | parts[i + 1]);
                    } else if (8 === parts.length) this.parts = parts;
                    else throw new Error("ipaddr: ipv6 part count should be 8 or 16");
                    ref = this.parts;
                    for(l = 0, len = ref.length; l < len; l++){
                        part = ref[l];
                        if (!(0 <= part && part <= 0xffff)) throw new Error("ipaddr: ipv6 part should fit in 16 bits");
                    }
                    if (zoneId) this.zoneId = zoneId;
                }
                IPv6.prototype.kind = function() {
                    return 'ipv6';
                };
                IPv6.prototype.toString = function() {
                    return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');
                };
                IPv6.prototype.toRFC5952String = function() {
                    var bestMatchIndex, bestMatchLength, match, regex, string;
                    regex = /((^|:)(0(:|$)){2,})/g;
                    string = this.toNormalizedString();
                    bestMatchIndex = 0;
                    bestMatchLength = -1;
                    while(match = regex.exec(string))if (match[0].length > bestMatchLength) {
                        bestMatchIndex = match.index;
                        bestMatchLength = match[0].length;
                    }
                    if (bestMatchLength < 0) return string;
                    return string.substring(0, bestMatchIndex) + '::' + string.substring(bestMatchIndex + bestMatchLength);
                };
                IPv6.prototype.toByteArray = function() {
                    var bytes, k, len, part, ref;
                    bytes = [];
                    ref = this.parts;
                    for(k = 0, len = ref.length; k < len; k++){
                        part = ref[k];
                        bytes.push(part >> 8);
                        bytes.push(0xff & part);
                    }
                    return bytes;
                };
                IPv6.prototype.toNormalizedString = function() {
                    var addr, part, suffix;
                    addr = (function() {
                        var k, len, ref, results;
                        ref = this.parts;
                        results = [];
                        for(k = 0, len = ref.length; k < len; k++){
                            part = ref[k];
                            results.push(part.toString(16));
                        }
                        return results;
                    }).call(this).join(":");
                    suffix = '';
                    if (this.zoneId) suffix = '%' + this.zoneId;
                    return addr + suffix;
                };
                IPv6.prototype.toFixedLengthString = function() {
                    var addr, part, suffix;
                    addr = (function() {
                        var k, len, ref, results;
                        ref = this.parts;
                        results = [];
                        for(k = 0, len = ref.length; k < len; k++){
                            part = ref[k];
                            results.push(part.toString(16).padStart(4, '0'));
                        }
                        return results;
                    }).call(this).join(":");
                    suffix = '';
                    if (this.zoneId) suffix = '%' + this.zoneId;
                    return addr + suffix;
                };
                IPv6.prototype.match = function(other, cidrRange) {
                    var ref;
                    if (void 0 === cidrRange) ref = other, other = ref[0], cidrRange = ref[1];
                    if ('ipv6' !== other.kind()) throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
                    return matchCIDR(this.parts, other.parts, 16, cidrRange);
                };
                IPv6.prototype.SpecialRanges = {
                    unspecified: [
                        new IPv6([
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        128
                    ],
                    linkLocal: [
                        new IPv6([
                            0xfe80,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        10
                    ],
                    multicast: [
                        new IPv6([
                            0xff00,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        8
                    ],
                    loopback: [
                        new IPv6([
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            1
                        ]),
                        128
                    ],
                    uniqueLocal: [
                        new IPv6([
                            0xfc00,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        7
                    ],
                    ipv4Mapped: [
                        new IPv6([
                            0,
                            0,
                            0,
                            0,
                            0,
                            0xffff,
                            0,
                            0
                        ]),
                        96
                    ],
                    rfc6145: [
                        new IPv6([
                            0,
                            0,
                            0,
                            0,
                            0xffff,
                            0,
                            0,
                            0
                        ]),
                        96
                    ],
                    rfc6052: [
                        new IPv6([
                            0x64,
                            0xff9b,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        96
                    ],
                    '6to4': [
                        new IPv6([
                            0x2002,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        16
                    ],
                    teredo: [
                        new IPv6([
                            0x2001,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        32
                    ],
                    reserved: [
                        [
                            new IPv6([
                                0x2001,
                                0xdb8,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0
                            ]),
                            32
                        ]
                    ]
                };
                IPv6.prototype.range = function() {
                    return ipaddr.subnetMatch(this, this.SpecialRanges);
                };
                IPv6.prototype.isIPv4MappedAddress = function() {
                    return 'ipv4Mapped' === this.range();
                };
                IPv6.prototype.toIPv4Address = function() {
                    var high, low, ref;
                    if (!this.isIPv4MappedAddress()) throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
                    ref = this.parts.slice(-2), high = ref[0], low = ref[1];
                    return new ipaddr.IPv4([
                        high >> 8,
                        0xff & high,
                        low >> 8,
                        0xff & low
                    ]);
                };
                IPv6.prototype.prefixLengthFromSubnetMask = function() {
                    var cidr, i, k, part, stop, zeros, zerotable;
                    zerotable = {
                        0: 16,
                        32768: 15,
                        49152: 14,
                        57344: 13,
                        61440: 12,
                        63488: 11,
                        64512: 10,
                        65024: 9,
                        65280: 8,
                        65408: 7,
                        65472: 6,
                        65504: 5,
                        65520: 4,
                        65528: 3,
                        65532: 2,
                        65534: 1,
                        65535: 0
                    };
                    cidr = 0;
                    stop = false;
                    for(i = k = 7; k >= 0; i = k += -1){
                        part = this.parts[i];
                        if (!(part in zerotable)) return null;
                        zeros = zerotable[part];
                        if (stop && 0 !== zeros) return null;
                        if (16 !== zeros) stop = true;
                        cidr += zeros;
                    }
                    return 128 - cidr;
                };
                return IPv6;
            }();
            ipv6Part = "(?:[0-9a-f]+::?)+";
            zoneIndex = "%[0-9a-z]{1,}";
            ipv6Regexes = {
                zoneIndex: new RegExp(zoneIndex, 'i'),
                native: new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", 'i'),
                transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + "\\." + ipv4Part + "(" + zoneIndex + ")?$", 'i')
            };
            expandIPv6 = function(string, parts) {
                var colonCount, lastColon, part, replacement, replacementCount, zoneId;
                if (string.indexOf('::') !== string.lastIndexOf('::')) return null;
                zoneId = (string.match(ipv6Regexes['zoneIndex']) || [])[0];
                if (zoneId) {
                    zoneId = zoneId.substring(1);
                    string = string.replace(/%.+$/, '');
                }
                colonCount = 0;
                lastColon = -1;
                while((lastColon = string.indexOf(':', lastColon + 1)) >= 0)colonCount++;
                if ('::' === string.substr(0, 2)) colonCount--;
                if ('::' === string.substr(-2, 2)) colonCount--;
                if (colonCount > parts) return null;
                replacementCount = parts - colonCount;
                replacement = ':';
                while(replacementCount--)replacement += '0:';
                string = string.replace('::', replacement);
                if (':' === string[0]) string = string.slice(1);
                if (':' === string[string.length - 1]) string = string.slice(0, -1);
                parts = function() {
                    var k, len, ref, results;
                    ref = string.split(":");
                    results = [];
                    for(k = 0, len = ref.length; k < len; k++){
                        part = ref[k];
                        results.push(parseInt(part, 16));
                    }
                    return results;
                }();
                return {
                    parts: parts,
                    zoneId: zoneId
                };
            };
            ipaddr.IPv6.parser = function(string) {
                var addr, k, len, match, octet, octets, zoneId;
                if (ipv6Regexes['native'].test(string)) return expandIPv6(string, 8);
                if (match = string.match(ipv6Regexes['transitional'])) {
                    zoneId = match[6] || '';
                    addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
                    if (addr.parts) {
                        octets = [
                            parseInt(match[2]),
                            parseInt(match[3]),
                            parseInt(match[4]),
                            parseInt(match[5])
                        ];
                        for(k = 0, len = octets.length; k < len; k++){
                            octet = octets[k];
                            if (!(0 <= octet && octet <= 255)) return null;
                        }
                        addr.parts.push(octets[0] << 8 | octets[1]);
                        addr.parts.push(octets[2] << 8 | octets[3]);
                        return {
                            parts: addr.parts,
                            zoneId: addr.zoneId
                        };
                    }
                }
                return null;
            };
            ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
                return null !== this.parser(string);
            };
            ipaddr.IPv4.isValid = function(string) {
                try {
                    new this(this.parser(string));
                    return true;
                } catch (error1) {
                    return false;
                }
            };
            ipaddr.IPv4.isValidFourPartDecimal = function(string) {
                if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) return true;
                return false;
            };
            ipaddr.IPv6.isValid = function(string) {
                var addr;
                if ("string" == typeof string && -1 === string.indexOf(":")) return false;
                try {
                    addr = this.parser(string);
                    new this(addr.parts, addr.zoneId);
                    return true;
                } catch (error1) {
                    return false;
                }
            };
            ipaddr.IPv4.parse = function(string) {
                var parts;
                parts = this.parser(string);
                if (null === parts) throw new Error("ipaddr: string is not formatted like ip address");
                return new this(parts);
            };
            ipaddr.IPv6.parse = function(string) {
                var addr;
                addr = this.parser(string);
                if (null === addr.parts) throw new Error("ipaddr: string is not formatted like ip address");
                return new this(addr.parts, addr.zoneId);
            };
            ipaddr.IPv4.parseCIDR = function(string) {
                var maskLength, match, parsed;
                if (match = string.match(/^(.+)\/(\d+)$/)) {
                    maskLength = parseInt(match[2]);
                    if (maskLength >= 0 && maskLength <= 32) {
                        parsed = [
                            this.parse(match[1]),
                            maskLength
                        ];
                        Object.defineProperty(parsed, 'toString', {
                            value: function() {
                                return this.join('/');
                            }
                        });
                        return parsed;
                    }
                }
                throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
            };
            ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
                var filledOctetCount, j, octets;
                prefix = parseInt(prefix);
                if (prefix < 0 || prefix > 32) throw new Error('ipaddr: invalid IPv4 prefix length');
                octets = [
                    0,
                    0,
                    0,
                    0
                ];
                j = 0;
                filledOctetCount = Math.floor(prefix / 8);
                while(j < filledOctetCount){
                    octets[j] = 255;
                    j++;
                }
                if (filledOctetCount < 4) octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
                return new this(octets);
            };
            ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
                var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
                try {
                    cidr = this.parseCIDR(string);
                    ipInterfaceOctets = cidr[0].toByteArray();
                    subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
                    octets = [];
                    i = 0;
                    while(i < 4){
                        octets.push(parseInt(ipInterfaceOctets[i], 10) | 255 ^ parseInt(subnetMaskOctets[i], 10));
                        i++;
                    }
                    return new this(octets);
                } catch (error1) {
                    throw new Error('ipaddr: the address does not have IPv4 CIDR format');
                }
            };
            ipaddr.IPv4.networkAddressFromCIDR = function(string) {
                var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
                try {
                    cidr = this.parseCIDR(string);
                    ipInterfaceOctets = cidr[0].toByteArray();
                    subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
                    octets = [];
                    i = 0;
                    while(i < 4){
                        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
                        i++;
                    }
                    return new this(octets);
                } catch (error1) {
                    throw new Error('ipaddr: the address does not have IPv4 CIDR format');
                }
            };
            ipaddr.IPv6.parseCIDR = function(string) {
                var maskLength, match, parsed;
                if (match = string.match(/^(.+)\/(\d+)$/)) {
                    maskLength = parseInt(match[2]);
                    if (maskLength >= 0 && maskLength <= 128) {
                        parsed = [
                            this.parse(match[1]),
                            maskLength
                        ];
                        Object.defineProperty(parsed, 'toString', {
                            value: function() {
                                return this.join('/');
                            }
                        });
                        return parsed;
                    }
                }
                throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
            };
            ipaddr.isValid = function(string) {
                return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
            };
            ipaddr.parse = function(string) {
                if (ipaddr.IPv6.isValid(string)) return ipaddr.IPv6.parse(string);
                if (ipaddr.IPv4.isValid(string)) return ipaddr.IPv4.parse(string);
                throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
            };
            ipaddr.parseCIDR = function(string) {
                try {
                    return ipaddr.IPv6.parseCIDR(string);
                } catch (error1) {
                    try {
                        return ipaddr.IPv4.parseCIDR(string);
                    } catch (error1) {
                        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
                    }
                }
            };
            ipaddr.fromByteArray = function(bytes) {
                var length;
                length = bytes.length;
                if (4 === length) return new ipaddr.IPv4(bytes);
                if (16 === length) return new ipaddr.IPv6(bytes);
                throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
            };
            ipaddr.process = function(string) {
                var addr;
                addr = this.parse(string);
                if ('ipv6' === addr.kind() && addr.isIPv4MappedAddress()) return addr.toIPv4Address();
                return addr;
            };
        }).call(this);
    },
    "../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js": function(module) {
        "use strict";
        module.exports = Math.abs;
    },
    "../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js": function(module) {
        "use strict";
        module.exports = Math.floor;
    },
    "../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js": function(module) {
        "use strict";
        module.exports = Number.isNaN || function(a) {
            return a !== a;
        };
    },
    "../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js": function(module) {
        "use strict";
        module.exports = Math.max;
    },
    "../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js": function(module) {
        "use strict";
        module.exports = Math.min;
    },
    "../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js": function(module) {
        "use strict";
        module.exports = Math.pow;
    },
    "../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js": function(module) {
        "use strict";
        module.exports = Math.round;
    },
    "../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var $isNaN = __webpack_require__("../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js");
        module.exports = function(number) {
            if ($isNaN(number) || 0 === number) return number;
            return number < 0 ? -1 : 1;
        };
    },
    "../node_modules/.pnpm/media-typer@0.3.0/node_modules/media-typer/index.js": function(__unused_webpack_module, exports1) {
        /*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */ var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
        var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
        var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
        var qescRegExp = /\\([\u0000-\u007f])/g;
        var quoteRegExp = /([\\"])/g;
        var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
        var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
        var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
        exports1.format = format;
        exports1.parse = parse;
        function format(obj) {
            if (!obj || 'object' != typeof obj) throw new TypeError('argument obj is required');
            var parameters = obj.parameters;
            var subtype = obj.subtype;
            var suffix = obj.suffix;
            var type = obj.type;
            if (!type || !typeNameRegExp.test(type)) throw new TypeError('invalid type');
            if (!subtype || !subtypeNameRegExp.test(subtype)) throw new TypeError('invalid subtype');
            var string = type + '/' + subtype;
            if (suffix) {
                if (!typeNameRegExp.test(suffix)) throw new TypeError('invalid suffix');
                string += '+' + suffix;
            }
            if (parameters && 'object' == typeof parameters) {
                var param;
                var params = Object.keys(parameters).sort();
                for(var i = 0; i < params.length; i++){
                    param = params[i];
                    if (!tokenRegExp.test(param)) throw new TypeError('invalid parameter name');
                    string += '; ' + param + '=' + qstring(parameters[param]);
                }
            }
            return string;
        }
        function parse(string) {
            if (!string) throw new TypeError('argument string is required');
            if ('object' == typeof string) string = getcontenttype(string);
            if ('string' != typeof string) throw new TypeError('argument string is required to be a string');
            var index = string.indexOf(';');
            var type = -1 !== index ? string.substr(0, index) : string;
            var key;
            var match;
            var obj = splitType(type);
            var params = {};
            var value;
            paramRegExp.lastIndex = index;
            while(match = paramRegExp.exec(string)){
                if (match.index !== index) throw new TypeError('invalid parameter format');
                index += match[0].length;
                key = match[1].toLowerCase();
                value = match[2];
                if ('"' === value[0]) value = value.substr(1, value.length - 2).replace(qescRegExp, '$1');
                params[key] = value;
            }
            if (-1 !== index && index !== string.length) throw new TypeError('invalid parameter format');
            obj.parameters = params;
            return obj;
        }
        function getcontenttype(obj) {
            if ('function' == typeof obj.getHeader) return obj.getHeader('content-type');
            if ('object' == typeof obj.headers) return obj.headers && obj.headers['content-type'];
        }
        function qstring(val) {
            var str = String(val);
            if (tokenRegExp.test(str)) return str;
            if (str.length > 0 && !textRegExp.test(str)) throw new TypeError('invalid parameter value');
            return '"' + str.replace(quoteRegExp, '\\$1') + '"';
        }
        function splitType(string) {
            var match = typeRegExp.exec(string.toLowerCase());
            if (!match) throw new TypeError('invalid media type');
            var type = match[1];
            var subtype = match[2];
            var suffix;
            var index = subtype.lastIndexOf('+');
            if (-1 !== index) {
                suffix = subtype.substr(index + 1);
                subtype = subtype.substr(0, index);
            }
            var obj = {
                type: type,
                subtype: subtype,
                suffix: suffix
            };
            return obj;
        }
    },
    "../node_modules/.pnpm/merge-descriptors@1.0.3/node_modules/merge-descriptors/index.js": function(module) {
        "use strict";
        /*!
 * merge-descriptors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = merge;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function merge(dest, src, redefine) {
            if (!dest) throw new TypeError('argument dest is required');
            if (!src) throw new TypeError('argument src is required');
            if (void 0 === redefine) redefine = true;
            Object.getOwnPropertyNames(src).forEach(function(name) {
                if (!redefine && hasOwnProperty.call(dest, name)) return;
                var descriptor = Object.getOwnPropertyDescriptor(src, name);
                Object.defineProperty(dest, name, descriptor);
            });
            return dest;
        }
    },
    "../node_modules/.pnpm/methods@1.1.2/node_modules/methods/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * methods
 * Copyright(c) 2013-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var http = __webpack_require__("http");
        module.exports = getCurrentNodeMethods() || getBasicNodeMethods();
        function getCurrentNodeMethods() {
            return http.METHODS && http.METHODS.map(function(method) {
                return method.toLowerCase();
            });
        }
        function getBasicNodeMethods() {
            return [
                'get',
                'post',
                'put',
                'head',
                'delete',
                'options',
                'trace',
                'copy',
                'lock',
                'mkcol',
                'move',
                'purge',
                'propfind',
                'proppatch',
                'unlock',
                'report',
                'mkactivity',
                'checkout',
                'merge',
                'm-search',
                'notify',
                'subscribe',
                'unsubscribe',
                'patch',
                'search',
                'connect'
            ];
        }
    },
    "../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        /*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = __webpack_require__("../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json");
    },
    "../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        /*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var db = __webpack_require__("../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js");
        var extname = __webpack_require__("path").extname;
        var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
        var TEXT_TYPE_REGEXP = /^text\//i;
        exports1.charset = charset;
        exports1.charsets = {
            lookup: charset
        };
        exports1.contentType = contentType;
        exports1.extension = extension;
        exports1.extensions = Object.create(null);
        exports1.lookup = lookup;
        exports1.types = Object.create(null);
        populateMaps(exports1.extensions, exports1.types);
        function charset(type) {
            if (!type || 'string' != typeof type) return false;
            var match = EXTRACT_TYPE_REGEXP.exec(type);
            var mime = match && db[match[1].toLowerCase()];
            if (mime && mime.charset) return mime.charset;
            if (match && TEXT_TYPE_REGEXP.test(match[1])) return 'UTF-8';
            return false;
        }
        function contentType(str) {
            if (!str || 'string' != typeof str) return false;
            var mime = -1 === str.indexOf('/') ? exports1.lookup(str) : str;
            if (!mime) return false;
            if (-1 === mime.indexOf('charset')) {
                var charset = exports1.charset(mime);
                if (charset) mime += '; charset=' + charset.toLowerCase();
            }
            return mime;
        }
        function extension(type) {
            if (!type || 'string' != typeof type) return false;
            var match = EXTRACT_TYPE_REGEXP.exec(type);
            var exts = match && exports1.extensions[match[1].toLowerCase()];
            if (!exts || !exts.length) return false;
            return exts[0];
        }
        function lookup(path) {
            if (!path || 'string' != typeof path) return false;
            var extension = extname('x.' + path).toLowerCase().substr(1);
            if (!extension) return false;
            return exports1.types[extension] || false;
        }
        function populateMaps(extensions, types) {
            var preference = [
                'nginx',
                'apache',
                void 0,
                'iana'
            ];
            Object.keys(db).forEach(function(type) {
                var mime = db[type];
                var exts = mime.extensions;
                if (!exts || !exts.length) return;
                extensions[type] = exts;
                for(var i = 0; i < exts.length; i++){
                    var extension = exts[i];
                    if (types[extension]) {
                        var from = preference.indexOf(db[types[extension]].source);
                        var to = preference.indexOf(mime.source);
                        if ('application/octet-stream' !== types[extension] && (from > to || from === to && 'application/' === types[extension].substr(0, 12))) continue;
                    }
                    types[extension] = type;
                }
            });
        }
    },
    "../node_modules/.pnpm/mime@1.6.0/node_modules/mime/mime.js": function(module, __unused_webpack_exports, __webpack_require__) {
        __webpack_require__("path");
        var fs = __webpack_require__("fs");
        function Mime() {
            this.types = Object.create(null);
            this.extensions = Object.create(null);
        }
        Mime.prototype.define = function(map) {
            for(var type in map){
                var exts = map[type];
                for(var i = 0; i < exts.length; i++){
                    if (process.env.DEBUG_MIME && this.types[exts[i]]) console.warn((this._loading || "define()").replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' + this.types[exts[i]] + ' to ' + type);
                    this.types[exts[i]] = type;
                }
                if (!this.extensions[type]) this.extensions[type] = exts[0];
            }
        };
        Mime.prototype.load = function(file) {
            this._loading = file;
            var map = {}, content = fs.readFileSync(file, 'ascii'), lines = content.split(/[\r\n]+/);
            lines.forEach(function(line) {
                var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
                map[fields.shift()] = fields;
            });
            this.define(map);
            this._loading = null;
        };
        Mime.prototype.lookup = function(path, fallback) {
            var ext = path.replace(/^.*[\.\/\\]/, '').toLowerCase();
            return this.types[ext] || fallback || this.default_type;
        };
        Mime.prototype.extension = function(mimeType) {
            var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
            return this.extensions[type];
        };
        var mime = new Mime();
        mime.define(__webpack_require__("../node_modules/.pnpm/mime@1.6.0/node_modules/mime/types.json"));
        mime.default_type = mime.lookup('bin');
        mime.Mime = Mime;
        mime.charsets = {
            lookup: function(mimeType, fallback) {
                return /^text\/|^application\/(javascript|json)/.test(mimeType) ? 'UTF-8' : fallback;
            }
        };
        module.exports = mime;
    },
    "../node_modules/.pnpm/ms@2.0.0/node_modules/ms/index.js": function(module) {
        var s = 1000;
        var m = 60 * s;
        var h = 60 * m;
        var d = 24 * h;
        var y = 365.25 * d;
        module.exports = function(val, options) {
            options = options || {};
            var type = typeof val;
            if ('string' === type && val.length > 0) return parse(val);
            if ('number' === type && false === isNaN(val)) return options.long ? fmtLong(val) : fmtShort(val);
            throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
        };
        function parse(str) {
            str = String(str);
            if (str.length > 100) return;
            var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
            if (!match) return;
            var n = parseFloat(match[1]);
            var type = (match[2] || 'ms').toLowerCase();
            switch(type){
                case 'years':
                case 'year':
                case 'yrs':
                case 'yr':
                case 'y':
                    return n * y;
                case 'days':
                case 'day':
                case 'd':
                    return n * d;
                case 'hours':
                case 'hour':
                case 'hrs':
                case 'hr':
                case 'h':
                    return n * h;
                case 'minutes':
                case 'minute':
                case 'mins':
                case 'min':
                case 'm':
                    return n * m;
                case 'seconds':
                case 'second':
                case 'secs':
                case 'sec':
                case 's':
                    return n * s;
                case 'milliseconds':
                case 'millisecond':
                case 'msecs':
                case 'msec':
                case 'ms':
                    return n;
                default:
                    return;
            }
        }
        function fmtShort(ms) {
            if (ms >= d) return Math.round(ms / d) + 'd';
            if (ms >= h) return Math.round(ms / h) + 'h';
            if (ms >= m) return Math.round(ms / m) + 'm';
            if (ms >= s) return Math.round(ms / s) + 's';
            return ms + 'ms';
        }
        function fmtLong(ms) {
            return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
        }
        function plural(ms, n, name) {
            if (ms < n) return;
            if (ms < 1.5 * n) return Math.floor(ms / n) + ' ' + name;
            return Math.ceil(ms / n) + ' ' + name + 's';
        }
    },
    "../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js": function(module) {
        var s = 1000;
        var m = 60 * s;
        var h = 60 * m;
        var d = 24 * h;
        var w = 7 * d;
        var y = 365.25 * d;
        module.exports = function(val, options) {
            options = options || {};
            var type = typeof val;
            if ('string' === type && val.length > 0) return parse(val);
            if ('number' === type && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
            throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
        };
        function parse(str) {
            str = String(str);
            if (str.length > 100) return;
            var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
            if (!match) return;
            var n = parseFloat(match[1]);
            var type = (match[2] || 'ms').toLowerCase();
            switch(type){
                case 'years':
                case 'year':
                case 'yrs':
                case 'yr':
                case 'y':
                    return n * y;
                case 'weeks':
                case 'week':
                case 'w':
                    return n * w;
                case 'days':
                case 'day':
                case 'd':
                    return n * d;
                case 'hours':
                case 'hour':
                case 'hrs':
                case 'hr':
                case 'h':
                    return n * h;
                case 'minutes':
                case 'minute':
                case 'mins':
                case 'min':
                case 'm':
                    return n * m;
                case 'seconds':
                case 'second':
                case 'secs':
                case 'sec':
                case 's':
                    return n * s;
                case 'milliseconds':
                case 'millisecond':
                case 'msecs':
                case 'msec':
                case 'ms':
                    return n;
                default:
                    return;
            }
        }
        function fmtShort(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) return Math.round(ms / d) + 'd';
            if (msAbs >= h) return Math.round(ms / h) + 'h';
            if (msAbs >= m) return Math.round(ms / m) + 'm';
            if (msAbs >= s) return Math.round(ms / s) + 's';
            return ms + 'ms';
        }
        function fmtLong(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) return plural(ms, msAbs, d, 'day');
            if (msAbs >= h) return plural(ms, msAbs, h, 'hour');
            if (msAbs >= m) return plural(ms, msAbs, m, 'minute');
            if (msAbs >= s) return plural(ms, msAbs, s, 'second');
            return ms + ' ms';
        }
        function plural(ms, msAbs, n, name) {
            var isPlural = msAbs >= 1.5 * n;
            return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
        }
    },
    "../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var preferredCharsets = __webpack_require__("../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/charset.js");
        var preferredEncodings = __webpack_require__("../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/encoding.js");
        var preferredLanguages = __webpack_require__("../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/language.js");
        var preferredMediaTypes = __webpack_require__("../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/mediaType.js");
        module.exports = Negotiator;
        module.exports.Negotiator = Negotiator;
        function Negotiator(request) {
            if (!(this instanceof Negotiator)) return new Negotiator(request);
            this.request = request;
        }
        Negotiator.prototype.charset = function(available) {
            var set = this.charsets(available);
            return set && set[0];
        };
        Negotiator.prototype.charsets = function(available) {
            return preferredCharsets(this.request.headers['accept-charset'], available);
        };
        Negotiator.prototype.encoding = function(available) {
            var set = this.encodings(available);
            return set && set[0];
        };
        Negotiator.prototype.encodings = function(available) {
            return preferredEncodings(this.request.headers['accept-encoding'], available);
        };
        Negotiator.prototype.language = function(available) {
            var set = this.languages(available);
            return set && set[0];
        };
        Negotiator.prototype.languages = function(available) {
            return preferredLanguages(this.request.headers['accept-language'], available);
        };
        Negotiator.prototype.mediaType = function(available) {
            var set = this.mediaTypes(available);
            return set && set[0];
        };
        Negotiator.prototype.mediaTypes = function(available) {
            return preferredMediaTypes(this.request.headers.accept, available);
        };
        Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
        Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
        Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
        Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
        Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
        Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
        Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
        Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
    },
    "../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/charset.js": function(module) {
        "use strict";
        module.exports = preferredCharsets;
        module.exports.preferredCharsets = preferredCharsets;
        var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
        function parseAcceptCharset(accept) {
            var accepts = accept.split(',');
            for(var i = 0, j = 0; i < accepts.length; i++){
                var charset = parseCharset(accepts[i].trim(), i);
                if (charset) accepts[j++] = charset;
            }
            accepts.length = j;
            return accepts;
        }
        function parseCharset(str, i) {
            var match = simpleCharsetRegExp.exec(str);
            if (!match) return null;
            var charset = match[1];
            var q = 1;
            if (match[2]) {
                var params = match[2].split(';');
                for(var j = 0; j < params.length; j++){
                    var p = params[j].trim().split('=');
                    if ('q' === p[0]) {
                        q = parseFloat(p[1]);
                        break;
                    }
                }
            }
            return {
                charset: charset,
                q: q,
                i: i
            };
        }
        function getCharsetPriority(charset, accepted, index) {
            var priority = {
                o: -1,
                q: 0,
                s: 0
            };
            for(var i = 0; i < accepted.length; i++){
                var spec = specify(charset, accepted[i], index);
                if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
            }
            return priority;
        }
        function specify(charset, spec, index) {
            var s = 0;
            if (spec.charset.toLowerCase() === charset.toLowerCase()) s |= 1;
            else if ('*' !== spec.charset) return null;
            return {
                i: index,
                o: spec.i,
                q: spec.q,
                s: s
            };
        }
        function preferredCharsets(accept, provided) {
            var accepts = parseAcceptCharset(void 0 === accept ? '*' : accept || '');
            if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
            var priorities = provided.map(function(type, index) {
                return getCharsetPriority(type, accepts, index);
            });
            return priorities.filter(isQuality).sort(compareSpecs).map(function(priority) {
                return provided[priorities.indexOf(priority)];
            });
        }
        function compareSpecs(a, b) {
            return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
        }
        function getFullCharset(spec) {
            return spec.charset;
        }
        function isQuality(spec) {
            return spec.q > 0;
        }
    },
    "../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/encoding.js": function(module) {
        "use strict";
        module.exports = preferredEncodings;
        module.exports.preferredEncodings = preferredEncodings;
        var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
        function parseAcceptEncoding(accept) {
            var accepts = accept.split(',');
            var hasIdentity = false;
            var minQuality = 1;
            for(var i = 0, j = 0; i < accepts.length; i++){
                var encoding = parseEncoding(accepts[i].trim(), i);
                if (encoding) {
                    accepts[j++] = encoding;
                    hasIdentity = hasIdentity || specify('identity', encoding);
                    minQuality = Math.min(minQuality, encoding.q || 1);
                }
            }
            if (!hasIdentity) accepts[j++] = {
                encoding: 'identity',
                q: minQuality,
                i: i
            };
            accepts.length = j;
            return accepts;
        }
        function parseEncoding(str, i) {
            var match = simpleEncodingRegExp.exec(str);
            if (!match) return null;
            var encoding = match[1];
            var q = 1;
            if (match[2]) {
                var params = match[2].split(';');
                for(var j = 0; j < params.length; j++){
                    var p = params[j].trim().split('=');
                    if ('q' === p[0]) {
                        q = parseFloat(p[1]);
                        break;
                    }
                }
            }
            return {
                encoding: encoding,
                q: q,
                i: i
            };
        }
        function getEncodingPriority(encoding, accepted, index) {
            var priority = {
                o: -1,
                q: 0,
                s: 0
            };
            for(var i = 0; i < accepted.length; i++){
                var spec = specify(encoding, accepted[i], index);
                if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
            }
            return priority;
        }
        function specify(encoding, spec, index) {
            var s = 0;
            if (spec.encoding.toLowerCase() === encoding.toLowerCase()) s |= 1;
            else if ('*' !== spec.encoding) return null;
            return {
                i: index,
                o: spec.i,
                q: spec.q,
                s: s
            };
        }
        function preferredEncodings(accept, provided) {
            var accepts = parseAcceptEncoding(accept || '');
            if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
            var priorities = provided.map(function(type, index) {
                return getEncodingPriority(type, accepts, index);
            });
            return priorities.filter(isQuality).sort(compareSpecs).map(function(priority) {
                return provided[priorities.indexOf(priority)];
            });
        }
        function compareSpecs(a, b) {
            return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
        }
        function getFullEncoding(spec) {
            return spec.encoding;
        }
        function isQuality(spec) {
            return spec.q > 0;
        }
    },
    "../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/language.js": function(module) {
        "use strict";
        module.exports = preferredLanguages;
        module.exports.preferredLanguages = preferredLanguages;
        var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
        function parseAcceptLanguage(accept) {
            var accepts = accept.split(',');
            for(var i = 0, j = 0; i < accepts.length; i++){
                var language = parseLanguage(accepts[i].trim(), i);
                if (language) accepts[j++] = language;
            }
            accepts.length = j;
            return accepts;
        }
        function parseLanguage(str, i) {
            var match = simpleLanguageRegExp.exec(str);
            if (!match) return null;
            var prefix = match[1];
            var suffix = match[2];
            var full = prefix;
            if (suffix) full += "-" + suffix;
            var q = 1;
            if (match[3]) {
                var params = match[3].split(';');
                for(var j = 0; j < params.length; j++){
                    var p = params[j].split('=');
                    if ('q' === p[0]) q = parseFloat(p[1]);
                }
            }
            return {
                prefix: prefix,
                suffix: suffix,
                q: q,
                i: i,
                full: full
            };
        }
        function getLanguagePriority(language, accepted, index) {
            var priority = {
                o: -1,
                q: 0,
                s: 0
            };
            for(var i = 0; i < accepted.length; i++){
                var spec = specify(language, accepted[i], index);
                if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
            }
            return priority;
        }
        function specify(language, spec, index) {
            var p = parseLanguage(language);
            if (!p) return null;
            var s = 0;
            if (spec.full.toLowerCase() === p.full.toLowerCase()) s |= 4;
            else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) s |= 2;
            else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) s |= 1;
            else if ('*' !== spec.full) return null;
            return {
                i: index,
                o: spec.i,
                q: spec.q,
                s: s
            };
        }
        function preferredLanguages(accept, provided) {
            var accepts = parseAcceptLanguage(void 0 === accept ? '*' : accept || '');
            if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
            var priorities = provided.map(function(type, index) {
                return getLanguagePriority(type, accepts, index);
            });
            return priorities.filter(isQuality).sort(compareSpecs).map(function(priority) {
                return provided[priorities.indexOf(priority)];
            });
        }
        function compareSpecs(a, b) {
            return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
        }
        function getFullLanguage(spec) {
            return spec.full;
        }
        function isQuality(spec) {
            return spec.q > 0;
        }
    },
    "../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/mediaType.js": function(module) {
        "use strict";
        module.exports = preferredMediaTypes;
        module.exports.preferredMediaTypes = preferredMediaTypes;
        var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
        function parseAccept(accept) {
            var accepts = splitMediaTypes(accept);
            for(var i = 0, j = 0; i < accepts.length; i++){
                var mediaType = parseMediaType(accepts[i].trim(), i);
                if (mediaType) accepts[j++] = mediaType;
            }
            accepts.length = j;
            return accepts;
        }
        function parseMediaType(str, i) {
            var match = simpleMediaTypeRegExp.exec(str);
            if (!match) return null;
            var params = Object.create(null);
            var q = 1;
            var subtype = match[2];
            var type = match[1];
            if (match[3]) {
                var kvps = splitParameters(match[3]).map(splitKeyValuePair);
                for(var j = 0; j < kvps.length; j++){
                    var pair = kvps[j];
                    var key = pair[0].toLowerCase();
                    var val = pair[1];
                    var value = val && '"' === val[0] && '"' === val[val.length - 1] ? val.substr(1, val.length - 2) : val;
                    if ('q' === key) {
                        q = parseFloat(value);
                        break;
                    }
                    params[key] = value;
                }
            }
            return {
                type: type,
                subtype: subtype,
                params: params,
                q: q,
                i: i
            };
        }
        function getMediaTypePriority(type, accepted, index) {
            var priority = {
                o: -1,
                q: 0,
                s: 0
            };
            for(var i = 0; i < accepted.length; i++){
                var spec = specify(type, accepted[i], index);
                if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
            }
            return priority;
        }
        function specify(type, spec, index) {
            var p = parseMediaType(type);
            var s = 0;
            if (!p) return null;
            if (spec.type.toLowerCase() == p.type.toLowerCase()) s |= 4;
            else if ('*' != spec.type) return null;
            if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) s |= 2;
            else if ('*' != spec.subtype) return null;
            var keys = Object.keys(spec.params);
            if (keys.length > 0) if (!keys.every(function(k) {
                return '*' == spec.params[k] || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
            })) return null;
            else s |= 1;
            return {
                i: index,
                o: spec.i,
                q: spec.q,
                s: s
            };
        }
        function preferredMediaTypes(accept, provided) {
            var accepts = parseAccept(void 0 === accept ? '*/*' : accept || '');
            if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
            var priorities = provided.map(function(type, index) {
                return getMediaTypePriority(type, accepts, index);
            });
            return priorities.filter(isQuality).sort(compareSpecs).map(function(priority) {
                return provided[priorities.indexOf(priority)];
            });
        }
        function compareSpecs(a, b) {
            return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
        }
        function getFullType(spec) {
            return spec.type + '/' + spec.subtype;
        }
        function isQuality(spec) {
            return spec.q > 0;
        }
        function quoteCount(string) {
            var count = 0;
            var index = 0;
            while(-1 !== (index = string.indexOf('"', index))){
                count++;
                index++;
            }
            return count;
        }
        function splitKeyValuePair(str) {
            var index = str.indexOf('=');
            var key;
            var val;
            if (-1 === index) key = str;
            else {
                key = str.substr(0, index);
                val = str.substr(index + 1);
            }
            return [
                key,
                val
            ];
        }
        function splitMediaTypes(accept) {
            var accepts = accept.split(',');
            for(var i = 1, j = 0; i < accepts.length; i++)if (quoteCount(accepts[j]) % 2 == 0) accepts[++j] = accepts[i];
            else accepts[j] += ',' + accepts[i];
            accepts.length = j + 1;
            return accepts;
        }
        function splitParameters(str) {
            var parameters = str.split(';');
            for(var i = 1, j = 0; i < parameters.length; i++)if (quoteCount(parameters[j]) % 2 == 0) parameters[++j] = parameters[i];
            else parameters[j] += ';' + parameters[i];
            parameters.length = j + 1;
            for(var i = 0; i < parameters.length; i++)parameters[i] = parameters[i].trim();
            return parameters;
        }
    },
    "../node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js": function(module) {
        "use strict";
        /*
object-assign
(c) Sindre Sorhus
@license MIT
*/ var getOwnPropertySymbols = Object.getOwnPropertySymbols;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var propIsEnumerable = Object.prototype.propertyIsEnumerable;
        function toObject(val) {
            if (null == val) throw new TypeError('Object.assign cannot be called with null or undefined');
            return Object(val);
        }
        function shouldUseNative() {
            try {
                if (!Object.assign) return false;
                var test1 = new String('abc');
                test1[5] = 'de';
                if ('5' === Object.getOwnPropertyNames(test1)[0]) return false;
                var test2 = {};
                for(var i = 0; i < 10; i++)test2['_' + String.fromCharCode(i)] = i;
                var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
                    return test2[n];
                });
                if ('0123456789' !== order2.join('')) return false;
                var test3 = {};
                'abcdefghijklmnopqrst'.split('').forEach(function(letter) {
                    test3[letter] = letter;
                });
                if ('abcdefghijklmnopqrst' !== Object.keys(Object.assign({}, test3)).join('')) return false;
                return true;
            } catch (err) {
                return false;
            }
        }
        module.exports = shouldUseNative() ? Object.assign : function(target, source) {
            var from;
            var to = toObject(target);
            var symbols;
            for(var s = 1; s < arguments.length; s++){
                from = Object(arguments[s]);
                for(var key in from)if (hasOwnProperty.call(from, key)) to[key] = from[key];
                if (getOwnPropertySymbols) {
                    symbols = getOwnPropertySymbols(from);
                    for(var i = 0; i < symbols.length; i++)if (propIsEnumerable.call(from, symbols[i])) to[symbols[i]] = from[symbols[i]];
                }
            }
            return to;
        };
    },
    "../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        var hasMap = 'function' == typeof Map && Map.prototype;
        var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
        var mapSize = hasMap && mapSizeDescriptor && 'function' == typeof mapSizeDescriptor.get ? mapSizeDescriptor.get : null;
        var mapForEach = hasMap && Map.prototype.forEach;
        var hasSet = 'function' == typeof Set && Set.prototype;
        var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
        var setSize = hasSet && setSizeDescriptor && 'function' == typeof setSizeDescriptor.get ? setSizeDescriptor.get : null;
        var setForEach = hasSet && Set.prototype.forEach;
        var hasWeakMap = 'function' == typeof WeakMap && WeakMap.prototype;
        var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
        var hasWeakSet = 'function' == typeof WeakSet && WeakSet.prototype;
        var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
        var hasWeakRef = 'function' == typeof WeakRef && WeakRef.prototype;
        var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
        var booleanValueOf = Boolean.prototype.valueOf;
        var objectToString = Object.prototype.toString;
        var functionToString = Function.prototype.toString;
        var $match = String.prototype.match;
        var $slice = String.prototype.slice;
        var $replace = String.prototype.replace;
        var $toUpperCase = String.prototype.toUpperCase;
        var $toLowerCase = String.prototype.toLowerCase;
        var $test = RegExp.prototype.test;
        var $concat = Array.prototype.concat;
        var $join = Array.prototype.join;
        var $arrSlice = Array.prototype.slice;
        var $floor = Math.floor;
        var bigIntValueOf = 'function' == typeof BigInt ? BigInt.prototype.valueOf : null;
        var gOPS = Object.getOwnPropertySymbols;
        var symToString = 'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator ? Symbol.prototype.toString : null;
        var hasShammedSymbols = 'function' == typeof Symbol && 'object' == typeof Symbol.iterator;
        var toStringTag = 'function' == typeof Symbol && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol') ? Symbol.toStringTag : null;
        var isEnumerable = Object.prototype.propertyIsEnumerable;
        var gPO = ('function' == typeof Reflect ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
            return O.__proto__;
        } : null);
        function addNumericSeparator(num, str) {
            if (num === 1 / 0 || num === -1 / 0 || num !== num || num && num > -1000 && num < 1000 || $test.call(/e/, str)) return str;
            var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
            if ('number' == typeof num) {
                var int = num < 0 ? -$floor(-num) : $floor(num);
                if (int !== num) {
                    var intStr = String(int);
                    var dec = $slice.call(str, intStr.length + 1);
                    return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
                }
            }
            return $replace.call(str, sepRegex, '$&_');
        }
        var utilInspect = __webpack_require__("../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/util.inspect.js");
        var inspectCustom = utilInspect.custom;
        var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
        var quotes = {
            __proto__: null,
            double: '"',
            single: "'"
        };
        var quoteREs = {
            __proto__: null,
            double: /(["\\])/g,
            single: /(['\\])/g
        };
        module.exports = function inspect_(obj, options, depth, seen) {
            var opts = options || {};
            if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) throw new TypeError('option "quoteStyle" must be "single" or "double"');
            if (has(opts, 'maxStringLength') && ('number' == typeof opts.maxStringLength ? opts.maxStringLength < 0 && opts.maxStringLength !== 1 / 0 : null !== opts.maxStringLength)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
            var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
            if ('boolean' != typeof customInspect && 'symbol' !== customInspect) throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
            if (has(opts, 'indent') && null !== opts.indent && '\t' !== opts.indent && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
            if (has(opts, 'numericSeparator') && 'boolean' != typeof opts.numericSeparator) throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
            var numericSeparator = opts.numericSeparator;
            if (void 0 === obj) return 'undefined';
            if (null === obj) return 'null';
            if ('boolean' == typeof obj) return obj ? 'true' : 'false';
            if ('string' == typeof obj) return inspectString(obj, opts);
            if ('number' == typeof obj) {
                if (0 === obj) return 1 / 0 / obj > 0 ? '0' : '-0';
                var str = String(obj);
                return numericSeparator ? addNumericSeparator(obj, str) : str;
            }
            if ('bigint' == typeof obj) {
                var bigIntStr = String(obj) + 'n';
                return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
            }
            var maxDepth = void 0 === opts.depth ? 5 : opts.depth;
            if (void 0 === depth) depth = 0;
            if (depth >= maxDepth && maxDepth > 0 && 'object' == typeof obj) return isArray(obj) ? '[Array]' : '[Object]';
            var indent = getIndent(opts, depth);
            if (void 0 === seen) seen = [];
            else if (indexOf(seen, obj) >= 0) return '[Circular]';
            function inspect(value, from, noIndent) {
                if (from) {
                    seen = $arrSlice.call(seen);
                    seen.push(from);
                }
                if (noIndent) {
                    var newOpts = {
                        depth: opts.depth
                    };
                    if (has(opts, 'quoteStyle')) newOpts.quoteStyle = opts.quoteStyle;
                    return inspect_(value, newOpts, depth + 1, seen);
                }
                return inspect_(value, opts, depth + 1, seen);
            }
            if ('function' == typeof obj && !isRegExp(obj)) {
                var name = nameOf(obj);
                var keys = arrObjKeys(obj, inspect);
                return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
            }
            if (isSymbol(obj)) {
                var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
                return 'object' != typeof obj || hasShammedSymbols ? symString : markBoxed(symString);
            }
            if (isElement(obj)) {
                var s = '<' + $toLowerCase.call(String(obj.nodeName));
                var attrs = obj.attributes || [];
                for(var i = 0; i < attrs.length; i++)s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
                s += '>';
                if (obj.childNodes && obj.childNodes.length) s += '...';
                s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
                return s;
            }
            if (isArray(obj)) {
                if (0 === obj.length) return '[]';
                var xs = arrObjKeys(obj, inspect);
                if (indent && !singleLineValues(xs)) return '[' + indentedJoin(xs, indent) + ']';
                return '[ ' + $join.call(xs, ', ') + ' ]';
            }
            if (isError(obj)) {
                var parts = arrObjKeys(obj, inspect);
                if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
                if (0 === parts.length) return '[' + String(obj) + ']';
                return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
            }
            if ('object' == typeof obj && customInspect) {
                if (inspectSymbol && 'function' == typeof obj[inspectSymbol] && utilInspect) return utilInspect(obj, {
                    depth: maxDepth - depth
                });
                else if ('symbol' !== customInspect && 'function' == typeof obj.inspect) return obj.inspect();
            }
            if (isMap(obj)) {
                var mapParts = [];
                if (mapForEach) mapForEach.call(obj, function(value, key) {
                    mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
                });
                return collectionOf('Map', mapSize.call(obj), mapParts, indent);
            }
            if (isSet(obj)) {
                var setParts = [];
                if (setForEach) setForEach.call(obj, function(value) {
                    setParts.push(inspect(value, obj));
                });
                return collectionOf('Set', setSize.call(obj), setParts, indent);
            }
            if (isWeakMap(obj)) return weakCollectionOf('WeakMap');
            if (isWeakSet(obj)) return weakCollectionOf('WeakSet');
            if (isWeakRef(obj)) return weakCollectionOf('WeakRef');
            if (isNumber(obj)) return markBoxed(inspect(Number(obj)));
            if (isBigInt(obj)) return markBoxed(inspect(bigIntValueOf.call(obj)));
            if (isBoolean(obj)) return markBoxed(booleanValueOf.call(obj));
            if (isString(obj)) return markBoxed(inspect(String(obj)));
            if ('undefined' != typeof window && obj === window) return '{ [object Window] }';
            if ('undefined' != typeof globalThis && obj === globalThis || 'undefined' != typeof global && obj === global) return '{ [object globalThis] }';
            if (!isDate(obj) && !isRegExp(obj)) {
                var ys = arrObjKeys(obj, inspect);
                var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
                var protoTag = obj instanceof Object ? '' : 'null prototype';
                var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
                var constructorTag = isPlainObject || 'function' != typeof obj.constructor ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
                var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
                if (0 === ys.length) return tag + '{}';
                if (indent) return tag + '{' + indentedJoin(ys, indent) + '}';
                return tag + '{ ' + $join.call(ys, ', ') + ' }';
            }
            return String(obj);
        };
        function wrapQuotes(s, defaultStyle, opts) {
            var style = opts.quoteStyle || defaultStyle;
            var quoteChar = quotes[style];
            return quoteChar + s + quoteChar;
        }
        function quote(s) {
            return $replace.call(String(s), /"/g, '&quot;');
        }
        function canTrustToString(obj) {
            return !toStringTag || !('object' == typeof obj && (toStringTag in obj || void 0 !== obj[toStringTag]));
        }
        function isArray(obj) {
            return '[object Array]' === toStr(obj) && canTrustToString(obj);
        }
        function isDate(obj) {
            return '[object Date]' === toStr(obj) && canTrustToString(obj);
        }
        function isRegExp(obj) {
            return '[object RegExp]' === toStr(obj) && canTrustToString(obj);
        }
        function isError(obj) {
            return '[object Error]' === toStr(obj) && canTrustToString(obj);
        }
        function isString(obj) {
            return '[object String]' === toStr(obj) && canTrustToString(obj);
        }
        function isNumber(obj) {
            return '[object Number]' === toStr(obj) && canTrustToString(obj);
        }
        function isBoolean(obj) {
            return '[object Boolean]' === toStr(obj) && canTrustToString(obj);
        }
        function isSymbol(obj) {
            if (hasShammedSymbols) return obj && 'object' == typeof obj && obj instanceof Symbol;
            if ('symbol' == typeof obj) return true;
            if (!obj || 'object' != typeof obj || !symToString) return false;
            try {
                symToString.call(obj);
                return true;
            } catch (e) {}
            return false;
        }
        function isBigInt(obj) {
            if (!obj || 'object' != typeof obj || !bigIntValueOf) return false;
            try {
                bigIntValueOf.call(obj);
                return true;
            } catch (e) {}
            return false;
        }
        var hasOwn = Object.prototype.hasOwnProperty || function(key) {
            return key in this;
        };
        function has(obj, key) {
            return hasOwn.call(obj, key);
        }
        function toStr(obj) {
            return objectToString.call(obj);
        }
        function nameOf(f) {
            if (f.name) return f.name;
            var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
            if (m) return m[1];
            return null;
        }
        function indexOf(xs, x) {
            if (xs.indexOf) return xs.indexOf(x);
            for(var i = 0, l = xs.length; i < l; i++)if (xs[i] === x) return i;
            return -1;
        }
        function isMap(x) {
            if (!mapSize || !x || 'object' != typeof x) return false;
            try {
                mapSize.call(x);
                try {
                    setSize.call(x);
                } catch (s) {
                    return true;
                }
                return x instanceof Map;
            } catch (e) {}
            return false;
        }
        function isWeakMap(x) {
            if (!weakMapHas || !x || 'object' != typeof x) return false;
            try {
                weakMapHas.call(x, weakMapHas);
                try {
                    weakSetHas.call(x, weakSetHas);
                } catch (s) {
                    return true;
                }
                return x instanceof WeakMap;
            } catch (e) {}
            return false;
        }
        function isWeakRef(x) {
            if (!weakRefDeref || !x || 'object' != typeof x) return false;
            try {
                weakRefDeref.call(x);
                return true;
            } catch (e) {}
            return false;
        }
        function isSet(x) {
            if (!setSize || !x || 'object' != typeof x) return false;
            try {
                setSize.call(x);
                try {
                    mapSize.call(x);
                } catch (m) {
                    return true;
                }
                return x instanceof Set;
            } catch (e) {}
            return false;
        }
        function isWeakSet(x) {
            if (!weakSetHas || !x || 'object' != typeof x) return false;
            try {
                weakSetHas.call(x, weakSetHas);
                try {
                    weakMapHas.call(x, weakMapHas);
                } catch (s) {
                    return true;
                }
                return x instanceof WeakSet;
            } catch (e) {}
            return false;
        }
        function isElement(x) {
            if (!x || 'object' != typeof x) return false;
            if ('undefined' != typeof HTMLElement && x instanceof HTMLElement) return true;
            return 'string' == typeof x.nodeName && 'function' == typeof x.getAttribute;
        }
        function inspectString(str, opts) {
            if (str.length > opts.maxStringLength) {
                var remaining = str.length - opts.maxStringLength;
                var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
                return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
            }
            var quoteRE = quoteREs[opts.quoteStyle || 'single'];
            quoteRE.lastIndex = 0;
            var s = $replace.call($replace.call(str, quoteRE, '\\$1'), /[\x00-\x1f]/g, lowbyte);
            return wrapQuotes(s, 'single', opts);
        }
        function lowbyte(c) {
            var n = c.charCodeAt(0);
            var x = {
                8: 'b',
                9: 't',
                10: 'n',
                12: 'f',
                13: 'r'
            }[n];
            if (x) return '\\' + x;
            return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
        }
        function markBoxed(str) {
            return 'Object(' + str + ')';
        }
        function weakCollectionOf(type) {
            return type + ' { ? }';
        }
        function collectionOf(type, size, entries, indent) {
            var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
            return type + ' (' + size + ') {' + joinedEntries + '}';
        }
        function singleLineValues(xs) {
            for(var i = 0; i < xs.length; i++)if (indexOf(xs[i], '\n') >= 0) return false;
            return true;
        }
        function getIndent(opts, depth) {
            var baseIndent;
            if ('\t' === opts.indent) baseIndent = '\t';
            else {
                if ('number' != typeof opts.indent || !(opts.indent > 0)) return null;
                baseIndent = $join.call(Array(opts.indent + 1), ' ');
            }
            return {
                base: baseIndent,
                prev: $join.call(Array(depth + 1), baseIndent)
            };
        }
        function indentedJoin(xs, indent) {
            if (0 === xs.length) return '';
            var lineJoiner = '\n' + indent.prev + indent.base;
            return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
        }
        function arrObjKeys(obj, inspect) {
            var isArr = isArray(obj);
            var xs = [];
            if (isArr) {
                xs.length = obj.length;
                for(var i = 0; i < obj.length; i++)xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
            }
            var syms = 'function' == typeof gOPS ? gOPS(obj) : [];
            var symMap;
            if (hasShammedSymbols) {
                symMap = {};
                for(var k = 0; k < syms.length; k++)symMap['$' + syms[k]] = syms[k];
            }
            for(var key in obj)if (has(obj, key)) {
                if (!isArr || String(Number(key)) !== key || !(key < obj.length)) if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) continue;
                else if ($test.call(/[^\w$]/, key)) xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
                else xs.push(key + ': ' + inspect(obj[key], obj));
            }
            if ('function' == typeof gOPS) {
                for(var j = 0; j < syms.length; j++)if (isEnumerable.call(obj, syms[j])) xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
            return xs;
        }
    },
    "../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/util.inspect.js": function(module, __unused_webpack_exports, __webpack_require__) {
        module.exports = __webpack_require__("util").inspect;
    },
    "../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = onFinished;
        module.exports.isFinished = isFinished;
        var asyncHooks = tryRequireAsyncHooks();
        var first = __webpack_require__("../node_modules/.pnpm/ee-first@1.1.1/node_modules/ee-first/index.js");
        var defer = 'function' == typeof setImmediate ? setImmediate : function(fn) {
            process.nextTick(fn.bind.apply(fn, arguments));
        };
        function onFinished(msg, listener) {
            if (false !== isFinished(msg)) {
                defer(listener, null, msg);
                return msg;
            }
            attachListener(msg, wrap(listener));
            return msg;
        }
        function isFinished(msg) {
            var socket = msg.socket;
            if ('boolean' == typeof msg.finished) return Boolean(msg.finished || socket && !socket.writable);
            if ('boolean' == typeof msg.complete) return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
        }
        function attachFinishedListener(msg, callback) {
            var eeMsg;
            var eeSocket;
            var finished = false;
            function onFinish(error) {
                eeMsg.cancel();
                eeSocket.cancel();
                finished = true;
                callback(error);
            }
            eeMsg = eeSocket = first([
                [
                    msg,
                    'end',
                    'finish'
                ]
            ], onFinish);
            function onSocket(socket) {
                msg.removeListener('socket', onSocket);
                if (finished) return;
                if (eeMsg !== eeSocket) return;
                eeSocket = first([
                    [
                        socket,
                        'error',
                        'close'
                    ]
                ], onFinish);
            }
            if (msg.socket) return void onSocket(msg.socket);
            msg.on('socket', onSocket);
            if (void 0 === msg.socket) patchAssignSocket(msg, onSocket);
        }
        function attachListener(msg, listener) {
            var attached = msg.__onFinished;
            if (!attached || !attached.queue) {
                attached = msg.__onFinished = createListener(msg);
                attachFinishedListener(msg, attached);
            }
            attached.queue.push(listener);
        }
        function createListener(msg) {
            function listener(err) {
                if (msg.__onFinished === listener) msg.__onFinished = null;
                if (!listener.queue) return;
                var queue = listener.queue;
                listener.queue = null;
                for(var i = 0; i < queue.length; i++)queue[i](err, msg);
            }
            listener.queue = [];
            return listener;
        }
        function patchAssignSocket(res, callback) {
            var assignSocket = res.assignSocket;
            if ('function' != typeof assignSocket) return;
            res.assignSocket = function(socket) {
                assignSocket.call(this, socket);
                callback(socket);
            };
        }
        function tryRequireAsyncHooks() {
            try {
                return __webpack_require__("async_hooks");
            } catch (e) {
                return {};
            }
        }
        function wrap(fn) {
            var res;
            if (asyncHooks.AsyncResource) res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');
            if (!res || !res.runInAsyncScope) return fn;
            return res.runInAsyncScope.bind(res, fn, null);
        }
    },
    "../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ var url = __webpack_require__("url");
        var parse = url.parse;
        var Url = url.Url;
        module.exports = parseurl;
        module.exports.original = originalurl;
        function parseurl(req) {
            var url = req.url;
            if (void 0 === url) return;
            var parsed = req._parsedUrl;
            if (fresh(url, parsed)) return parsed;
            parsed = fastparse(url);
            parsed._raw = url;
            return req._parsedUrl = parsed;
        }
        function originalurl(req) {
            var url = req.originalUrl;
            if ('string' != typeof url) return parseurl(req);
            var parsed = req._parsedOriginalUrl;
            if (fresh(url, parsed)) return parsed;
            parsed = fastparse(url);
            parsed._raw = url;
            return req._parsedOriginalUrl = parsed;
        }
        function fastparse(str) {
            if ('string' != typeof str || 0x2f !== str.charCodeAt(0)) return parse(str);
            var pathname = str;
            var query = null;
            var search = null;
            for(var i = 1; i < str.length; i++)switch(str.charCodeAt(i)){
                case 0x3f:
                    if (null === search) {
                        pathname = str.substring(0, i);
                        query = str.substring(i + 1);
                        search = str.substring(i);
                    }
                    break;
                case 0x09:
                case 0x0a:
                case 0x0c:
                case 0x0d:
                case 0x20:
                case 0x23:
                case 0xa0:
                case 0xfeff:
                    return parse(str);
            }
            var url = void 0 !== Url ? new Url() : {};
            url.path = str;
            url.href = str;
            url.pathname = pathname;
            if (null !== search) {
                url.query = query;
                url.search = search;
            }
            return url;
        }
        function fresh(url, parsedUrl) {
            return 'object' == typeof parsedUrl && null !== parsedUrl && (void 0 === Url || parsedUrl instanceof Url) && parsedUrl._raw === url;
        }
    },
    "../node_modules/.pnpm/path-to-regexp@0.1.12/node_modules/path-to-regexp/index.js": function(module) {
        module.exports = pathToRegexp;
        var MATCHING_GROUP_REGEXP = /\\.|\((?:\?<(.*?)>)?(?!\?)/g;
        function pathToRegexp(path, keys, options) {
            options = options || {};
            keys = keys || [];
            var strict = options.strict;
            var end = false !== options.end;
            var flags = options.sensitive ? '' : 'i';
            var lookahead = false !== options.lookahead;
            var extraOffset = 0;
            var keysOffset = keys.length;
            var i = 0;
            var name = 0;
            var pos = 0;
            var backtrack = '';
            var m;
            if (path instanceof RegExp) {
                while(m = MATCHING_GROUP_REGEXP.exec(path.source)){
                    if ('\\' === m[0][0]) continue;
                    keys.push({
                        name: m[1] || name++,
                        optional: false,
                        offset: m.index
                    });
                }
                return path;
            }
            if (Array.isArray(path)) {
                path = path.map(function(value) {
                    return pathToRegexp(value, keys, options).source;
                });
                return new RegExp(path.join('|'), flags);
            }
            if ('string' != typeof path) throw new TypeError('path must be a string, array of strings, or regular expression');
            path = path.replace(/\\.|(\/)?(\.)?:(\w+)(\(.*?\))?(\*)?(\?)?|[.*]|\/\(/g, function(match, slash, format, key, capture, star, optional, offset) {
                if ('\\' === match[0]) {
                    backtrack += match;
                    pos += 2;
                    return match;
                }
                if ('.' === match) {
                    backtrack += '\\.';
                    extraOffset += 1;
                    pos += 1;
                    return '\\.';
                }
                if (slash || format) backtrack = '';
                else backtrack += path.slice(pos, offset);
                pos = offset + match.length;
                if ('*' === match) {
                    extraOffset += 3;
                    return '(.*)';
                }
                if ('/(' === match) {
                    backtrack += '/';
                    extraOffset += 2;
                    return '/(?:';
                }
                slash = slash || '';
                format = format ? '\\.' : '';
                optional = optional || '';
                capture = capture ? capture.replace(/\\.|\*/, function(m) {
                    return '*' === m ? '(.*)' : m;
                }) : backtrack ? '((?:(?!/|' + backtrack + ').)+?)' : '([^/' + format + ']+?)';
                keys.push({
                    name: key,
                    optional: !!optional,
                    offset: offset + extraOffset
                });
                var result = '(?:' + format + slash + capture + (star ? '((?:[/' + format + '].+?)?)' : '') + ')' + optional;
                extraOffset += result.length - match.length;
                return result;
            });
            while(m = MATCHING_GROUP_REGEXP.exec(path)){
                if ('\\' === m[0][0]) continue;
                if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) keys.splice(keysOffset + i, 0, {
                    name: name++,
                    optional: false,
                    offset: m.index
                });
                i++;
            }
            path += strict ? '' : '/' === path[path.length - 1] ? '?' : '/?';
            if (end) path += '$';
            else if ('/' !== path[path.length - 1]) path += lookahead ? '(?=/|$)' : '(?:/|$)';
            return new RegExp('^' + path, flags);
        }
    },
    "../node_modules/.pnpm/proxy-addr@2.0.7/node_modules/proxy-addr/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = proxyaddr;
        module.exports.all = alladdrs;
        module.exports.compile = compile;
        var forwarded = __webpack_require__("../node_modules/.pnpm/forwarded@0.2.0/node_modules/forwarded/index.js");
        var ipaddr = __webpack_require__("../node_modules/.pnpm/ipaddr.js@1.9.1/node_modules/ipaddr.js/lib/ipaddr.js");
        var DIGIT_REGEXP = /^[0-9]+$/;
        var isip = ipaddr.isValid;
        var parseip = ipaddr.parse;
        var IP_RANGES = {
            linklocal: [
                '169.254.0.0/16',
                'fe80::/10'
            ],
            loopback: [
                '127.0.0.1/8',
                '::1/128'
            ],
            uniquelocal: [
                '10.0.0.0/8',
                '172.16.0.0/12',
                '192.168.0.0/16',
                'fc00::/7'
            ]
        };
        function alladdrs(req, trust) {
            var addrs = forwarded(req);
            if (!trust) return addrs;
            if ('function' != typeof trust) trust = compile(trust);
            for(var i = 0; i < addrs.length - 1; i++)if (!trust(addrs[i], i)) addrs.length = i + 1;
            return addrs;
        }
        function compile(val) {
            if (!val) throw new TypeError('argument is required');
            var trust;
            if ('string' == typeof val) trust = [
                val
            ];
            else if (Array.isArray(val)) trust = val.slice();
            else throw new TypeError('unsupported trust argument');
            for(var i = 0; i < trust.length; i++){
                val = trust[i];
                if (Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
                    val = IP_RANGES[val];
                    trust.splice.apply(trust, [
                        i,
                        1
                    ].concat(val));
                    i += val.length - 1;
                }
            }
            return compileTrust(compileRangeSubnets(trust));
        }
        function compileRangeSubnets(arr) {
            var rangeSubnets = new Array(arr.length);
            for(var i = 0; i < arr.length; i++)rangeSubnets[i] = parseipNotation(arr[i]);
            return rangeSubnets;
        }
        function compileTrust(rangeSubnets) {
            var len = rangeSubnets.length;
            return 0 === len ? trustNone : 1 === len ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
        }
        function parseipNotation(note) {
            var pos = note.lastIndexOf('/');
            var str = -1 !== pos ? note.substring(0, pos) : note;
            if (!isip(str)) throw new TypeError('invalid IP address: ' + str);
            var ip = parseip(str);
            if (-1 === pos && 'ipv6' === ip.kind() && ip.isIPv4MappedAddress()) ip = ip.toIPv4Address();
            var max = 'ipv6' === ip.kind() ? 128 : 32;
            var range = -1 !== pos ? note.substring(pos + 1, note.length) : null;
            range = null === range ? max : DIGIT_REGEXP.test(range) ? parseInt(range, 10) : 'ipv4' === ip.kind() && isip(range) ? parseNetmask(range) : null;
            if (range <= 0 || range > max) throw new TypeError('invalid range on address: ' + note);
            return [
                ip,
                range
            ];
        }
        function parseNetmask(netmask) {
            var ip = parseip(netmask);
            var kind = ip.kind();
            return 'ipv4' === kind ? ip.prefixLengthFromSubnetMask() : null;
        }
        function proxyaddr(req, trust) {
            if (!req) throw new TypeError('req argument is required');
            if (!trust) throw new TypeError('trust argument is required');
            var addrs = alladdrs(req, trust);
            var addr = addrs[addrs.length - 1];
            return addr;
        }
        function trustNone() {
            return false;
        }
        function trustMulti(subnets) {
            return function(addr) {
                if (!isip(addr)) return false;
                var ip = parseip(addr);
                var ipconv;
                var kind = ip.kind();
                for(var i = 0; i < subnets.length; i++){
                    var subnet = subnets[i];
                    var subnetip = subnet[0];
                    var subnetkind = subnetip.kind();
                    var subnetrange = subnet[1];
                    var trusted = ip;
                    if (kind !== subnetkind) {
                        if ('ipv4' === subnetkind && !ip.isIPv4MappedAddress()) continue;
                        if (!ipconv) ipconv = 'ipv4' === subnetkind ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
                        trusted = ipconv;
                    }
                    if (trusted.match(subnetip, subnetrange)) return true;
                }
                return false;
            };
        }
        function trustSingle(subnet) {
            var subnetip = subnet[0];
            var subnetkind = subnetip.kind();
            var subnetisipv4 = 'ipv4' === subnetkind;
            var subnetrange = subnet[1];
            return function(addr) {
                if (!isip(addr)) return false;
                var ip = parseip(addr);
                var kind = ip.kind();
                if (kind !== subnetkind) {
                    if (subnetisipv4 && !ip.isIPv4MappedAddress()) return false;
                    ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
                }
                return ip.match(subnetip, subnetrange);
            };
        }
    },
    "../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/formats.js": function(module) {
        "use strict";
        var replace = String.prototype.replace;
        var percentTwenties = /%20/g;
        var Format = {
            RFC1738: 'RFC1738',
            RFC3986: 'RFC3986'
        };
        module.exports = {
            default: Format.RFC3986,
            formatters: {
                RFC1738: function(value) {
                    return replace.call(value, percentTwenties, '+');
                },
                RFC3986: function(value) {
                    return String(value);
                }
            },
            RFC1738: Format.RFC1738,
            RFC3986: Format.RFC3986
        };
    },
    "../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var stringify = __webpack_require__("../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/stringify.js");
        var parse = __webpack_require__("../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/parse.js");
        var formats = __webpack_require__("../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/formats.js");
        module.exports = {
            formats: formats,
            parse: parse,
            stringify: stringify
        };
    },
    "../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/parse.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var utils = __webpack_require__("../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/utils.js");
        var has = Object.prototype.hasOwnProperty;
        var isArray = Array.isArray;
        var defaults = {
            allowDots: false,
            allowEmptyArrays: false,
            allowPrototypes: false,
            allowSparse: false,
            arrayLimit: 20,
            charset: 'utf-8',
            charsetSentinel: false,
            comma: false,
            decodeDotInKeys: false,
            decoder: utils.decode,
            delimiter: '&',
            depth: 5,
            duplicates: 'combine',
            ignoreQueryPrefix: false,
            interpretNumericEntities: false,
            parameterLimit: 1000,
            parseArrays: true,
            plainObjects: false,
            strictDepth: false,
            strictNullHandling: false
        };
        var interpretNumericEntities = function(str) {
            return str.replace(/&#(\d+);/g, function($0, numberStr) {
                return String.fromCharCode(parseInt(numberStr, 10));
            });
        };
        var parseArrayValue = function(val, options) {
            if (val && 'string' == typeof val && options.comma && val.indexOf(',') > -1) return val.split(',');
            return val;
        };
        var isoSentinel = 'utf8=%26%2310003%3B';
        var charsetSentinel = 'utf8=%E2%9C%93';
        var parseValues = function(str, options) {
            var obj = {
                __proto__: null
            };
            var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
            cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');
            var limit = options.parameterLimit === 1 / 0 ? void 0 : options.parameterLimit;
            var parts = cleanStr.split(options.delimiter, limit);
            var skipIndex = -1;
            var i;
            var charset = options.charset;
            if (options.charsetSentinel) {
                for(i = 0; i < parts.length; ++i)if (0 === parts[i].indexOf('utf8=')) {
                    if (parts[i] === charsetSentinel) charset = 'utf-8';
                    else if (parts[i] === isoSentinel) charset = 'iso-8859-1';
                    skipIndex = i;
                    i = parts.length;
                }
            }
            for(i = 0; i < parts.length; ++i)if (i !== skipIndex) {
                var part = parts[i];
                var bracketEqualsPos = part.indexOf(']=');
                var pos = -1 === bracketEqualsPos ? part.indexOf('=') : bracketEqualsPos + 1;
                var key, val;
                if (-1 === pos) {
                    key = options.decoder(part, defaults.decoder, charset, 'key');
                    val = options.strictNullHandling ? null : '';
                } else {
                    key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
                    val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
                        return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                    });
                }
                if (val && options.interpretNumericEntities && 'iso-8859-1' === charset) val = interpretNumericEntities(val);
                if (part.indexOf('[]=') > -1) val = isArray(val) ? [
                    val
                ] : val;
                var existing = has.call(obj, key);
                if (existing && 'combine' === options.duplicates) obj[key] = utils.combine(obj[key], val);
                else if (!existing || 'last' === options.duplicates) obj[key] = val;
            }
            return obj;
        };
        var parseObject = function(chain, val, options, valuesParsed) {
            var leaf = valuesParsed ? val : parseArrayValue(val, options);
            for(var i = chain.length - 1; i >= 0; --i){
                var obj;
                var root = chain[i];
                if ('[]' === root && options.parseArrays) obj = options.allowEmptyArrays && ('' === leaf || options.strictNullHandling && null === leaf) ? [] : [].concat(leaf);
                else {
                    obj = options.plainObjects ? Object.create(null) : {};
                    var cleanRoot = '[' === root.charAt(0) && ']' === root.charAt(root.length - 1) ? root.slice(1, -1) : root;
                    var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
                    var index = parseInt(decodedRoot, 10);
                    if (options.parseArrays || '' !== decodedRoot) {
                        if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
                            obj = [];
                            obj[index] = leaf;
                        } else if ('__proto__' !== decodedRoot) obj[decodedRoot] = leaf;
                    } else obj = {
                        0: leaf
                    };
                }
                leaf = obj;
            }
            return leaf;
        };
        var parseKeys = function(givenKey, val, options, valuesParsed) {
            if (!givenKey) return;
            var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;
            var brackets = /(\[[^[\]]*])/;
            var child = /(\[[^[\]]*])/g;
            var segment = options.depth > 0 && brackets.exec(key);
            var parent = segment ? key.slice(0, segment.index) : key;
            var keys = [];
            if (parent) {
                if (!options.plainObjects && has.call(Object.prototype, parent)) {
                    if (!options.allowPrototypes) return;
                }
                keys.push(parent);
            }
            var i = 0;
            while(options.depth > 0 && null !== (segment = child.exec(key)) && i < options.depth){
                i += 1;
                if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
                    if (!options.allowPrototypes) return;
                }
                keys.push(segment[1]);
            }
            if (segment) {
                if (true === options.strictDepth) throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
                keys.push('[' + key.slice(segment.index) + ']');
            }
            return parseObject(keys, val, options, valuesParsed);
        };
        var normalizeParseOptions = function(opts) {
            if (!opts) return defaults;
            if (void 0 !== opts.allowEmptyArrays && 'boolean' != typeof opts.allowEmptyArrays) throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
            if (void 0 !== opts.decodeDotInKeys && 'boolean' != typeof opts.decodeDotInKeys) throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
            if (null !== opts.decoder && void 0 !== opts.decoder && 'function' != typeof opts.decoder) throw new TypeError('Decoder has to be a function.');
            if (void 0 !== opts.charset && 'utf-8' !== opts.charset && 'iso-8859-1' !== opts.charset) throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
            var charset = void 0 === opts.charset ? defaults.charset : opts.charset;
            var duplicates = void 0 === opts.duplicates ? defaults.duplicates : opts.duplicates;
            if ('combine' !== duplicates && 'first' !== duplicates && 'last' !== duplicates) throw new TypeError('The duplicates option must be either combine, first, or last');
            var allowDots = void 0 === opts.allowDots ? true === opts.decodeDotInKeys ? true : defaults.allowDots : !!opts.allowDots;
            return {
                allowDots: allowDots,
                allowEmptyArrays: 'boolean' == typeof opts.allowEmptyArrays ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
                allowPrototypes: 'boolean' == typeof opts.allowPrototypes ? opts.allowPrototypes : defaults.allowPrototypes,
                allowSparse: 'boolean' == typeof opts.allowSparse ? opts.allowSparse : defaults.allowSparse,
                arrayLimit: 'number' == typeof opts.arrayLimit ? opts.arrayLimit : defaults.arrayLimit,
                charset: charset,
                charsetSentinel: 'boolean' == typeof opts.charsetSentinel ? opts.charsetSentinel : defaults.charsetSentinel,
                comma: 'boolean' == typeof opts.comma ? opts.comma : defaults.comma,
                decodeDotInKeys: 'boolean' == typeof opts.decodeDotInKeys ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
                decoder: 'function' == typeof opts.decoder ? opts.decoder : defaults.decoder,
                delimiter: 'string' == typeof opts.delimiter || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
                depth: 'number' == typeof opts.depth || false === opts.depth ? +opts.depth : defaults.depth,
                duplicates: duplicates,
                ignoreQueryPrefix: true === opts.ignoreQueryPrefix,
                interpretNumericEntities: 'boolean' == typeof opts.interpretNumericEntities ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
                parameterLimit: 'number' == typeof opts.parameterLimit ? opts.parameterLimit : defaults.parameterLimit,
                parseArrays: false !== opts.parseArrays,
                plainObjects: 'boolean' == typeof opts.plainObjects ? opts.plainObjects : defaults.plainObjects,
                strictDepth: 'boolean' == typeof opts.strictDepth ? !!opts.strictDepth : defaults.strictDepth,
                strictNullHandling: 'boolean' == typeof opts.strictNullHandling ? opts.strictNullHandling : defaults.strictNullHandling
            };
        };
        module.exports = function(str, opts) {
            var options = normalizeParseOptions(opts);
            if ('' === str || null == str) return options.plainObjects ? Object.create(null) : {};
            var tempObj = 'string' == typeof str ? parseValues(str, options) : str;
            var obj = options.plainObjects ? Object.create(null) : {};
            var keys = Object.keys(tempObj);
            for(var i = 0; i < keys.length; ++i){
                var key = keys[i];
                var newObj = parseKeys(key, tempObj[key], options, 'string' == typeof str);
                obj = utils.merge(obj, newObj, options);
            }
            if (true === options.allowSparse) return obj;
            return utils.compact(obj);
        };
    },
    "../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/stringify.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var getSideChannel = __webpack_require__("../node_modules/.pnpm/side-channel@1.1.0/node_modules/side-channel/index.js");
        var utils = __webpack_require__("../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/utils.js");
        var formats = __webpack_require__("../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/formats.js");
        var has = Object.prototype.hasOwnProperty;
        var arrayPrefixGenerators = {
            brackets: function(prefix) {
                return prefix + '[]';
            },
            comma: 'comma',
            indices: function(prefix, key) {
                return prefix + '[' + key + ']';
            },
            repeat: function(prefix) {
                return prefix;
            }
        };
        var isArray = Array.isArray;
        var push = Array.prototype.push;
        var pushToArray = function(arr, valueOrArray) {
            push.apply(arr, isArray(valueOrArray) ? valueOrArray : [
                valueOrArray
            ]);
        };
        var toISO = Date.prototype.toISOString;
        var defaultFormat = formats['default'];
        var defaults = {
            addQueryPrefix: false,
            allowDots: false,
            allowEmptyArrays: false,
            arrayFormat: 'indices',
            charset: 'utf-8',
            charsetSentinel: false,
            delimiter: '&',
            encode: true,
            encodeDotInKeys: false,
            encoder: utils.encode,
            encodeValuesOnly: false,
            format: defaultFormat,
            formatter: formats.formatters[defaultFormat],
            indices: false,
            serializeDate: function(date) {
                return toISO.call(date);
            },
            skipNulls: false,
            strictNullHandling: false
        };
        var isNonNullishPrimitive = function(v) {
            return 'string' == typeof v || 'number' == typeof v || 'boolean' == typeof v || 'symbol' == typeof v || 'bigint' == typeof v;
        };
        var sentinel = {};
        var stringify = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
            var obj = object;
            var tmpSc = sideChannel;
            var step = 0;
            var findFlag = false;
            while(void 0 !== (tmpSc = tmpSc.get(sentinel)) && !findFlag){
                var pos = tmpSc.get(object);
                step += 1;
                if (void 0 !== pos) if (pos === step) throw new RangeError('Cyclic object value');
                else findFlag = true;
                if (void 0 === tmpSc.get(sentinel)) step = 0;
            }
            if ('function' == typeof filter) obj = filter(prefix, obj);
            else if (obj instanceof Date) obj = serializeDate(obj);
            else if ('comma' === generateArrayPrefix && isArray(obj)) obj = utils.maybeMap(obj, function(value) {
                if (value instanceof Date) return serializeDate(value);
                return value;
            });
            if (null === obj) {
                if (strictNullHandling) return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
                obj = '';
            }
            if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
                if (encoder) {
                    var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
                    return [
                        formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))
                    ];
                }
                return [
                    formatter(prefix) + '=' + formatter(String(obj))
                ];
            }
            var values = [];
            if (void 0 === obj) return values;
            var objKeys;
            if ('comma' === generateArrayPrefix && isArray(obj)) {
                if (encodeValuesOnly && encoder) obj = utils.maybeMap(obj, encoder);
                objKeys = [
                    {
                        value: obj.length > 0 ? obj.join(',') || null : void 0
                    }
                ];
            } else if (isArray(filter)) objKeys = filter;
            else {
                var keys = Object.keys(obj);
                objKeys = sort ? keys.sort(sort) : keys;
            }
            var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, '%2E') : prefix;
            var adjustedPrefix = commaRoundTrip && isArray(obj) && 1 === obj.length ? encodedPrefix + '[]' : encodedPrefix;
            if (allowEmptyArrays && isArray(obj) && 0 === obj.length) return adjustedPrefix + '[]';
            for(var j = 0; j < objKeys.length; ++j){
                var key = objKeys[j];
                var value = 'object' == typeof key && void 0 !== key.value ? key.value : obj[key];
                if (!skipNulls || null !== value) {
                    var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, '%2E') : key;
                    var keyPrefix = isArray(obj) ? 'function' == typeof generateArrayPrefix ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');
                    sideChannel.set(object, step);
                    var valueSideChannel = getSideChannel();
                    valueSideChannel.set(sentinel, sideChannel);
                    pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, 'comma' === generateArrayPrefix && encodeValuesOnly && isArray(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
                }
            }
            return values;
        };
        var normalizeStringifyOptions = function(opts) {
            if (!opts) return defaults;
            if (void 0 !== opts.allowEmptyArrays && 'boolean' != typeof opts.allowEmptyArrays) throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
            if (void 0 !== opts.encodeDotInKeys && 'boolean' != typeof opts.encodeDotInKeys) throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
            if (null !== opts.encoder && void 0 !== opts.encoder && 'function' != typeof opts.encoder) throw new TypeError('Encoder has to be a function.');
            var charset = opts.charset || defaults.charset;
            if (void 0 !== opts.charset && 'utf-8' !== opts.charset && 'iso-8859-1' !== opts.charset) throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
            var format = formats['default'];
            if (void 0 !== opts.format) {
                if (!has.call(formats.formatters, opts.format)) throw new TypeError('Unknown format option provided.');
                format = opts.format;
            }
            var formatter = formats.formatters[format];
            var filter = defaults.filter;
            if ('function' == typeof opts.filter || isArray(opts.filter)) filter = opts.filter;
            var arrayFormat;
            arrayFormat = opts.arrayFormat in arrayPrefixGenerators ? opts.arrayFormat : 'indices' in opts ? opts.indices ? 'indices' : 'repeat' : defaults.arrayFormat;
            if ('commaRoundTrip' in opts && 'boolean' != typeof opts.commaRoundTrip) throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
            var allowDots = void 0 === opts.allowDots ? true === opts.encodeDotInKeys ? true : defaults.allowDots : !!opts.allowDots;
            return {
                addQueryPrefix: 'boolean' == typeof opts.addQueryPrefix ? opts.addQueryPrefix : defaults.addQueryPrefix,
                allowDots: allowDots,
                allowEmptyArrays: 'boolean' == typeof opts.allowEmptyArrays ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
                arrayFormat: arrayFormat,
                charset: charset,
                charsetSentinel: 'boolean' == typeof opts.charsetSentinel ? opts.charsetSentinel : defaults.charsetSentinel,
                commaRoundTrip: opts.commaRoundTrip,
                delimiter: void 0 === opts.delimiter ? defaults.delimiter : opts.delimiter,
                encode: 'boolean' == typeof opts.encode ? opts.encode : defaults.encode,
                encodeDotInKeys: 'boolean' == typeof opts.encodeDotInKeys ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
                encoder: 'function' == typeof opts.encoder ? opts.encoder : defaults.encoder,
                encodeValuesOnly: 'boolean' == typeof opts.encodeValuesOnly ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
                filter: filter,
                format: format,
                formatter: formatter,
                serializeDate: 'function' == typeof opts.serializeDate ? opts.serializeDate : defaults.serializeDate,
                skipNulls: 'boolean' == typeof opts.skipNulls ? opts.skipNulls : defaults.skipNulls,
                sort: 'function' == typeof opts.sort ? opts.sort : null,
                strictNullHandling: 'boolean' == typeof opts.strictNullHandling ? opts.strictNullHandling : defaults.strictNullHandling
            };
        };
        module.exports = function(object, opts) {
            var obj = object;
            var options = normalizeStringifyOptions(opts);
            var objKeys;
            var filter;
            if ('function' == typeof options.filter) {
                filter = options.filter;
                obj = filter('', obj);
            } else if (isArray(options.filter)) {
                filter = options.filter;
                objKeys = filter;
            }
            var keys = [];
            if ('object' != typeof obj || null === obj) return '';
            var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
            var commaRoundTrip = 'comma' === generateArrayPrefix && options.commaRoundTrip;
            if (!objKeys) objKeys = Object.keys(obj);
            if (options.sort) objKeys.sort(options.sort);
            var sideChannel = getSideChannel();
            for(var i = 0; i < objKeys.length; ++i){
                var key = objKeys[i];
                if (!options.skipNulls || null !== obj[key]) pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
            }
            var joined = keys.join(options.delimiter);
            var prefix = true === options.addQueryPrefix ? '?' : '';
            if (options.charsetSentinel) if ('iso-8859-1' === options.charset) prefix += 'utf8=%26%2310003%3B&';
            else prefix += 'utf8=%E2%9C%93&';
            return joined.length > 0 ? prefix + joined : '';
        };
    },
    "../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/utils.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var formats = __webpack_require__("../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/formats.js");
        var has = Object.prototype.hasOwnProperty;
        var isArray = Array.isArray;
        var hexTable = function() {
            var array = [];
            for(var i = 0; i < 256; ++i)array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
            return array;
        }();
        var compactQueue = function(queue) {
            while(queue.length > 1){
                var item = queue.pop();
                var obj = item.obj[item.prop];
                if (isArray(obj)) {
                    var compacted = [];
                    for(var j = 0; j < obj.length; ++j)if (void 0 !== obj[j]) compacted.push(obj[j]);
                    item.obj[item.prop] = compacted;
                }
            }
        };
        var arrayToObject = function(source, options) {
            var obj = options && options.plainObjects ? Object.create(null) : {};
            for(var i = 0; i < source.length; ++i)if (void 0 !== source[i]) obj[i] = source[i];
            return obj;
        };
        var merge = function merge(target, source, options) {
            if (!source) return target;
            if ('object' != typeof source) {
                if (isArray(target)) target.push(source);
                else if (!target || 'object' != typeof target) return [
                    target,
                    source
                ];
                else if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) target[source] = true;
                return target;
            }
            if (!target || 'object' != typeof target) return [
                target
            ].concat(source);
            var mergeTarget = target;
            if (isArray(target) && !isArray(source)) mergeTarget = arrayToObject(target, options);
            if (isArray(target) && isArray(source)) {
                source.forEach(function(item, i) {
                    if (has.call(target, i)) {
                        var targetItem = target[i];
                        if (targetItem && 'object' == typeof targetItem && item && 'object' == typeof item) target[i] = merge(targetItem, item, options);
                        else target.push(item);
                    } else target[i] = item;
                });
                return target;
            }
            return Object.keys(source).reduce(function(acc, key) {
                var value = source[key];
                if (has.call(acc, key)) acc[key] = merge(acc[key], value, options);
                else acc[key] = value;
                return acc;
            }, mergeTarget);
        };
        var assign = function(target, source) {
            return Object.keys(source).reduce(function(acc, key) {
                acc[key] = source[key];
                return acc;
            }, target);
        };
        var decode = function(str, decoder, charset) {
            var strWithoutPlus = str.replace(/\+/g, ' ');
            if ('iso-8859-1' === charset) return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
            try {
                return decodeURIComponent(strWithoutPlus);
            } catch (e) {
                return strWithoutPlus;
            }
        };
        var limit = 1024;
        var encode = function(str, defaultEncoder, charset, kind, format) {
            if (0 === str.length) return str;
            var string = str;
            if ('symbol' == typeof str) string = Symbol.prototype.toString.call(str);
            else if ('string' != typeof str) string = String(str);
            if ('iso-8859-1' === charset) return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
                return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
            });
            var out = '';
            for(var j = 0; j < string.length; j += limit){
                var segment = string.length >= limit ? string.slice(j, j + limit) : string;
                var arr = [];
                for(var i = 0; i < segment.length; ++i){
                    var c = segment.charCodeAt(i);
                    if (0x2D === c || 0x2E === c || 0x5F === c || 0x7E === c || c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A || format === formats.RFC1738 && (0x28 === c || 0x29 === c)) {
                        arr[arr.length] = segment.charAt(i);
                        continue;
                    }
                    if (c < 0x80) {
                        arr[arr.length] = hexTable[c];
                        continue;
                    }
                    if (c < 0x800) {
                        arr[arr.length] = hexTable[0xC0 | c >> 6] + hexTable[0x80 | 0x3F & c];
                        continue;
                    }
                    if (c < 0xD800 || c >= 0xE000) {
                        arr[arr.length] = hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | 0x3F & c];
                        continue;
                    }
                    i += 1;
                    c = 0x10000 + ((0x3FF & c) << 10 | 0x3FF & segment.charCodeAt(i));
                    arr[arr.length] = hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | 0x3F & c];
                }
                out += arr.join('');
            }
            return out;
        };
        var compact = function(value) {
            var queue = [
                {
                    obj: {
                        o: value
                    },
                    prop: 'o'
                }
            ];
            var refs = [];
            for(var i = 0; i < queue.length; ++i){
                var item = queue[i];
                var obj = item.obj[item.prop];
                var keys = Object.keys(obj);
                for(var j = 0; j < keys.length; ++j){
                    var key = keys[j];
                    var val = obj[key];
                    if ('object' == typeof val && null !== val && -1 === refs.indexOf(val)) {
                        queue.push({
                            obj: obj,
                            prop: key
                        });
                        refs.push(val);
                    }
                }
            }
            compactQueue(queue);
            return value;
        };
        var isRegExp = function(obj) {
            return '[object RegExp]' === Object.prototype.toString.call(obj);
        };
        var isBuffer = function(obj) {
            if (!obj || 'object' != typeof obj) return false;
            return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
        };
        var combine = function(a, b) {
            return [].concat(a, b);
        };
        var maybeMap = function(val, fn) {
            if (isArray(val)) {
                var mapped = [];
                for(var i = 0; i < val.length; i += 1)mapped.push(fn(val[i]));
                return mapped;
            }
            return fn(val);
        };
        module.exports = {
            arrayToObject: arrayToObject,
            assign: assign,
            combine: combine,
            compact: compact,
            decode: decode,
            encode: encode,
            isBuffer: isBuffer,
            isRegExp: isRegExp,
            maybeMap: maybeMap,
            merge: merge
        };
    },
    "../node_modules/.pnpm/range-parser@1.2.1/node_modules/range-parser/index.js": function(module) {
        "use strict";
        /*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = rangeParser;
        function rangeParser(size, str, options) {
            if ('string' != typeof str) throw new TypeError('argument str must be a string');
            var index = str.indexOf('=');
            if (-1 === index) return -2;
            var arr = str.slice(index + 1).split(',');
            var ranges = [];
            ranges.type = str.slice(0, index);
            for(var i = 0; i < arr.length; i++){
                var range = arr[i].split('-');
                var start = parseInt(range[0], 10);
                var end = parseInt(range[1], 10);
                if (isNaN(start)) {
                    start = size - end;
                    end = size - 1;
                } else if (isNaN(end)) end = size - 1;
                if (end > size - 1) end = size - 1;
                if (!(isNaN(start) || isNaN(end)) && !(start > end) && !(start < 0)) ranges.push({
                    start: start,
                    end: end
                });
            }
            if (ranges.length < 1) return -1;
            return options && options.combine ? combineRanges(ranges) : ranges;
        }
        function combineRanges(ranges) {
            var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
            for(var j = 0, i = 1; i < ordered.length; i++){
                var range = ordered[i];
                var current = ordered[j];
                if (range.start > current.end + 1) ordered[++j] = range;
                else if (range.end > current.end) {
                    current.end = range.end;
                    current.index = Math.min(current.index, range.index);
                }
            }
            ordered.length = j + 1;
            var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
            combined.type = ranges.type;
            return combined;
        }
        function mapWithIndex(range, index) {
            return {
                start: range.start,
                end: range.end,
                index: index
            };
        }
        function mapWithoutIndex(range) {
            return {
                start: range.start,
                end: range.end
            };
        }
        function sortByRangeIndex(a, b) {
            return a.index - b.index;
        }
        function sortByRangeStart(a, b) {
            return a.start - b.start;
        }
    },
    "../node_modules/.pnpm/raw-body@2.5.2/node_modules/raw-body/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var asyncHooks = tryRequireAsyncHooks();
        var bytes = __webpack_require__("../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js");
        var createError = __webpack_require__("../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js");
        var iconv = __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/index.js");
        var unpipe = __webpack_require__("../node_modules/.pnpm/unpipe@1.0.0/node_modules/unpipe/index.js");
        module.exports = getRawBody;
        var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
        function getDecoder(encoding) {
            if (!encoding) return null;
            try {
                return iconv.getDecoder(encoding);
            } catch (e) {
                if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;
                throw createError(415, 'specified encoding unsupported', {
                    encoding: encoding,
                    type: 'encoding.unsupported'
                });
            }
        }
        function getRawBody(stream, options, callback) {
            var done = callback;
            var opts = options || {};
            if (void 0 === stream) throw new TypeError('argument stream is required');
            if ('object' != typeof stream || null === stream || 'function' != typeof stream.on) throw new TypeError('argument stream must be a stream');
            if (true === options || 'string' == typeof options) opts = {
                encoding: options
            };
            if ('function' == typeof options) {
                done = options;
                opts = {};
            }
            if (void 0 !== done && 'function' != typeof done) throw new TypeError('argument callback must be a function');
            if (!done && !global.Promise) throw new TypeError('argument callback is required');
            var encoding = true !== opts.encoding ? opts.encoding : 'utf-8';
            var limit = bytes.parse(opts.limit);
            var length = null == opts.length || isNaN(opts.length) ? null : parseInt(opts.length, 10);
            if (done) return readStream(stream, encoding, length, limit, wrap(done));
            return new Promise(function(resolve, reject) {
                readStream(stream, encoding, length, limit, function(err, buf) {
                    if (err) return reject(err);
                    resolve(buf);
                });
            });
        }
        function halt(stream) {
            unpipe(stream);
            if ('function' == typeof stream.pause) stream.pause();
        }
        function readStream(stream, encoding, length, limit, callback) {
            var complete = false;
            var sync = true;
            if (null !== limit && null !== length && length > limit) return done(createError(413, 'request entity too large', {
                expected: length,
                length: length,
                limit: limit,
                type: 'entity.too.large'
            }));
            var state = stream._readableState;
            if (stream._decoder || state && (state.encoding || state.decoder)) return done(createError(500, 'stream encoding should not be set', {
                type: 'stream.encoding.set'
            }));
            if (void 0 !== stream.readable && !stream.readable) return done(createError(500, 'stream is not readable', {
                type: 'stream.not.readable'
            }));
            var received = 0;
            var decoder;
            try {
                decoder = getDecoder(encoding);
            } catch (err) {
                return done(err);
            }
            var buffer = decoder ? '' : [];
            stream.on('aborted', onAborted);
            stream.on('close', cleanup);
            stream.on('data', onData);
            stream.on('end', onEnd);
            stream.on('error', onEnd);
            sync = false;
            function done() {
                var args = new Array(arguments.length);
                for(var i = 0; i < args.length; i++)args[i] = arguments[i];
                complete = true;
                if (sync) process.nextTick(invokeCallback);
                else invokeCallback();
                function invokeCallback() {
                    cleanup();
                    if (args[0]) halt(stream);
                    callback.apply(null, args);
                }
            }
            function onAborted() {
                if (complete) return;
                done(createError(400, 'request aborted', {
                    code: 'ECONNABORTED',
                    expected: length,
                    length: length,
                    received: received,
                    type: 'request.aborted'
                }));
            }
            function onData(chunk) {
                if (complete) return;
                received += chunk.length;
                if (null !== limit && received > limit) done(createError(413, 'request entity too large', {
                    limit: limit,
                    received: received,
                    type: 'entity.too.large'
                }));
                else if (decoder) buffer += decoder.write(chunk);
                else buffer.push(chunk);
            }
            function onEnd(err) {
                if (complete) return;
                if (err) return done(err);
                if (null !== length && received !== length) done(createError(400, 'request size did not match content length', {
                    expected: length,
                    length: length,
                    received: received,
                    type: 'request.size.invalid'
                }));
                else {
                    var string = decoder ? buffer + (decoder.end() || '') : Buffer.concat(buffer);
                    done(null, string);
                }
            }
            function cleanup() {
                buffer = null;
                stream.removeListener('aborted', onAborted);
                stream.removeListener('data', onData);
                stream.removeListener('end', onEnd);
                stream.removeListener('error', onEnd);
                stream.removeListener('close', cleanup);
            }
        }
        function tryRequireAsyncHooks() {
            try {
                return __webpack_require__("async_hooks");
            } catch (e) {
                return {};
            }
        }
        function wrap(fn) {
            var res;
            if (asyncHooks.AsyncResource) res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');
            if (!res || !res.runInAsyncScope) return fn;
            return res.runInAsyncScope.bind(res, fn, null);
        }
    },
    "../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js": function(module, exports1, __webpack_require__) {
        /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ var buffer = __webpack_require__("buffer");
        var Buffer1 = buffer.Buffer;
        function copyProps(src, dst) {
            for(var key in src)dst[key] = src[key];
        }
        if (Buffer1.from && Buffer1.alloc && Buffer1.allocUnsafe && Buffer1.allocUnsafeSlow) module.exports = buffer;
        else {
            copyProps(buffer, exports1);
            exports1.Buffer = SafeBuffer;
        }
        function SafeBuffer(arg, encodingOrOffset, length) {
            return Buffer1(arg, encodingOrOffset, length);
        }
        SafeBuffer.prototype = Object.create(Buffer1.prototype);
        copyProps(Buffer1, SafeBuffer);
        SafeBuffer.from = function(arg, encodingOrOffset, length) {
            if ('number' == typeof arg) throw new TypeError('Argument must not be a number');
            return Buffer1(arg, encodingOrOffset, length);
        };
        SafeBuffer.alloc = function(size, fill, encoding) {
            if ('number' != typeof size) throw new TypeError('Argument must be a number');
            var buf = Buffer1(size);
            if (void 0 !== fill) if ('string' == typeof encoding) buf.fill(fill, encoding);
            else buf.fill(fill);
            else buf.fill(0);
            return buf;
        };
        SafeBuffer.allocUnsafe = function(size) {
            if ('number' != typeof size) throw new TypeError('Argument must be a number');
            return Buffer1(size);
        };
        SafeBuffer.allocUnsafeSlow = function(size) {
            if ('number' != typeof size) throw new TypeError('Argument must be a number');
            return buffer.SlowBuffer(size);
        };
    },
    "../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var buffer = __webpack_require__("buffer");
        var Buffer1 = buffer.Buffer;
        var safer = {};
        var key;
        for(key in buffer)if (buffer.hasOwnProperty(key)) {
            if ('SlowBuffer' !== key && 'Buffer' !== key) safer[key] = buffer[key];
        }
        var Safer = safer.Buffer = {};
        for(key in Buffer1)if (Buffer1.hasOwnProperty(key)) {
            if ('allocUnsafe' !== key && 'allocUnsafeSlow' !== key) Safer[key] = Buffer1[key];
        }
        safer.Buffer.prototype = Buffer1.prototype;
        if (!Safer.from || Safer.from === Uint8Array.from) Safer.from = function(value, encodingOrOffset, length) {
            if ('number' == typeof value) throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
            if (value && void 0 === value.length) throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value);
            return Buffer1(value, encodingOrOffset, length);
        };
        if (!Safer.alloc) Safer.alloc = function(size, fill, encoding) {
            if ('number' != typeof size) throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
            if (size < 0 || size >= 2 * 1073741824) throw new RangeError('The value "' + size + '" is invalid for option "size"');
            var buf = Buffer1(size);
            if (fill && 0 !== fill.length) if ('string' == typeof encoding) buf.fill(fill, encoding);
            else buf.fill(fill);
            else buf.fill(0);
            return buf;
        };
        if (!safer.kStringMaxLength) try {
            safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
        } catch (e) {}
        if (!safer.constants) {
            safer.constants = {
                MAX_LENGTH: safer.kMaxLength
            };
            if (safer.kStringMaxLength) safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
        }
        module.exports = safer;
    },
    "../node_modules/.pnpm/send@0.19.0/node_modules/send/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var createError = __webpack_require__("../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js");
        var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('send');
        var deprecate = __webpack_require__("../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('send');
        var destroy = __webpack_require__("../node_modules/.pnpm/destroy@1.2.0/node_modules/destroy/index.js");
        var encodeUrl = __webpack_require__("../node_modules/.pnpm/encodeurl@1.0.2/node_modules/encodeurl/index.js");
        var escapeHtml = __webpack_require__("../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js");
        var etag = __webpack_require__("../node_modules/.pnpm/etag@1.8.1/node_modules/etag/index.js");
        var fresh = __webpack_require__("../node_modules/.pnpm/fresh@0.5.2/node_modules/fresh/index.js");
        var fs = __webpack_require__("fs");
        var mime = __webpack_require__("../node_modules/.pnpm/mime@1.6.0/node_modules/mime/mime.js");
        var ms = __webpack_require__("../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js");
        var onFinished = __webpack_require__("../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js");
        var parseRange = __webpack_require__("../node_modules/.pnpm/range-parser@1.2.1/node_modules/range-parser/index.js");
        var path = __webpack_require__("path");
        var statuses = __webpack_require__("../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/index.js");
        var Stream = __webpack_require__("stream");
        var util = __webpack_require__("util");
        var extname = path.extname;
        var join = path.join;
        var normalize = path.normalize;
        var resolve = path.resolve;
        var sep = path.sep;
        var BYTES_RANGE_REGEXP = /^ *bytes=/;
        var MAX_MAXAGE = 31536000000;
        var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
        module.exports = send;
        module.exports.mime = mime;
        function send(req, path, options) {
            return new SendStream(req, path, options);
        }
        function SendStream(req, path, options) {
            Stream.call(this);
            var opts = options || {};
            this.options = opts;
            this.path = path;
            this.req = req;
            this._acceptRanges = void 0 !== opts.acceptRanges ? Boolean(opts.acceptRanges) : true;
            this._cacheControl = void 0 !== opts.cacheControl ? Boolean(opts.cacheControl) : true;
            this._etag = void 0 !== opts.etag ? Boolean(opts.etag) : true;
            this._dotfiles = void 0 !== opts.dotfiles ? opts.dotfiles : 'ignore';
            if ('ignore' !== this._dotfiles && 'allow' !== this._dotfiles && 'deny' !== this._dotfiles) throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
            this._hidden = Boolean(opts.hidden);
            if (void 0 !== opts.hidden) deprecate('hidden: use dotfiles: \'' + (this._hidden ? 'allow' : 'ignore') + '\' instead');
            if (void 0 === opts.dotfiles) this._dotfiles = void 0;
            this._extensions = void 0 !== opts.extensions ? normalizeList(opts.extensions, 'extensions option') : [];
            this._immutable = void 0 !== opts.immutable ? Boolean(opts.immutable) : false;
            this._index = void 0 !== opts.index ? normalizeList(opts.index, 'index option') : [
                'index.html'
            ];
            this._lastModified = void 0 !== opts.lastModified ? Boolean(opts.lastModified) : true;
            this._maxage = opts.maxAge || opts.maxage;
            this._maxage = 'string' == typeof this._maxage ? ms(this._maxage) : Number(this._maxage);
            this._maxage = isNaN(this._maxage) ? 0 : Math.min(Math.max(0, this._maxage), MAX_MAXAGE);
            this._root = opts.root ? resolve(opts.root) : null;
            if (!this._root && opts.from) this.from(opts.from);
        }
        util.inherits(SendStream, Stream);
        SendStream.prototype.etag = deprecate.function(function(val) {
            this._etag = Boolean(val);
            debug('etag %s', this._etag);
            return this;
        }, 'send.etag: pass etag as option');
        SendStream.prototype.hidden = deprecate.function(function(val) {
            this._hidden = Boolean(val);
            this._dotfiles = void 0;
            debug('hidden %s', this._hidden);
            return this;
        }, 'send.hidden: use dotfiles option');
        SendStream.prototype.index = deprecate.function(function(paths) {
            var index = paths ? normalizeList(paths, 'paths argument') : [];
            debug('index %o', paths);
            this._index = index;
            return this;
        }, 'send.index: pass index as option');
        SendStream.prototype.root = function(path) {
            this._root = resolve(String(path));
            debug('root %s', this._root);
            return this;
        };
        SendStream.prototype.from = deprecate.function(SendStream.prototype.root, 'send.from: pass root as option');
        SendStream.prototype.root = deprecate.function(SendStream.prototype.root, 'send.root: pass root as option');
        SendStream.prototype.maxage = deprecate.function(function(maxAge) {
            this._maxage = 'string' == typeof maxAge ? ms(maxAge) : Number(maxAge);
            this._maxage = isNaN(this._maxage) ? 0 : Math.min(Math.max(0, this._maxage), MAX_MAXAGE);
            debug('max-age %d', this._maxage);
            return this;
        }, 'send.maxage: pass maxAge as option');
        SendStream.prototype.error = function(status, err) {
            if (hasListeners(this, 'error')) return this.emit('error', createHttpError(status, err));
            var res = this.res;
            var msg = statuses.message[status] || String(status);
            var doc = createHtmlDocument('Error', escapeHtml(msg));
            clearHeaders(res);
            if (err && err.headers) setHeaders(res, err.headers);
            res.statusCode = status;
            res.setHeader('Content-Type', 'text/html; charset=UTF-8');
            res.setHeader('Content-Length', Buffer.byteLength(doc));
            res.setHeader('Content-Security-Policy', "default-src 'none'");
            res.setHeader('X-Content-Type-Options', 'nosniff');
            res.end(doc);
        };
        SendStream.prototype.hasTrailingSlash = function() {
            return '/' === this.path[this.path.length - 1];
        };
        SendStream.prototype.isConditionalGET = function() {
            return this.req.headers['if-match'] || this.req.headers['if-unmodified-since'] || this.req.headers['if-none-match'] || this.req.headers['if-modified-since'];
        };
        SendStream.prototype.isPreconditionFailure = function() {
            var req = this.req;
            var res = this.res;
            var match = req.headers['if-match'];
            if (match) {
                var etag = res.getHeader('ETag');
                return !etag || '*' !== match && parseTokenList(match).every(function(match) {
                    return match !== etag && match !== 'W/' + etag && 'W/' + match !== etag;
                });
            }
            var unmodifiedSince = parseHttpDate(req.headers['if-unmodified-since']);
            if (!isNaN(unmodifiedSince)) {
                var lastModified = parseHttpDate(res.getHeader('Last-Modified'));
                return isNaN(lastModified) || lastModified > unmodifiedSince;
            }
            return false;
        };
        SendStream.prototype.removeContentHeaderFields = function() {
            var res = this.res;
            res.removeHeader('Content-Encoding');
            res.removeHeader('Content-Language');
            res.removeHeader('Content-Length');
            res.removeHeader('Content-Range');
            res.removeHeader('Content-Type');
        };
        SendStream.prototype.notModified = function() {
            var res = this.res;
            debug('not modified');
            this.removeContentHeaderFields();
            res.statusCode = 304;
            res.end();
        };
        SendStream.prototype.headersAlreadySent = function() {
            var err = new Error('Can\'t set headers after they are sent.');
            debug('headers already sent');
            this.error(500, err);
        };
        SendStream.prototype.isCachable = function() {
            var statusCode = this.res.statusCode;
            return statusCode >= 200 && statusCode < 300 || 304 === statusCode;
        };
        SendStream.prototype.onStatError = function(error) {
            switch(error.code){
                case 'ENAMETOOLONG':
                case 'ENOENT':
                case 'ENOTDIR':
                    this.error(404, error);
                    break;
                default:
                    this.error(500, error);
                    break;
            }
        };
        SendStream.prototype.isFresh = function() {
            return fresh(this.req.headers, {
                etag: this.res.getHeader('ETag'),
                'last-modified': this.res.getHeader('Last-Modified')
            });
        };
        SendStream.prototype.isRangeFresh = function() {
            var ifRange = this.req.headers['if-range'];
            if (!ifRange) return true;
            if (-1 !== ifRange.indexOf('"')) {
                var etag = this.res.getHeader('ETag');
                return Boolean(etag && -1 !== ifRange.indexOf(etag));
            }
            var lastModified = this.res.getHeader('Last-Modified');
            return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
        };
        SendStream.prototype.redirect = function(path) {
            var res = this.res;
            if (hasListeners(this, 'directory')) return void this.emit('directory', res, path);
            if (this.hasTrailingSlash()) return void this.error(403);
            var loc = encodeUrl(collapseLeadingSlashes(this.path + '/'));
            var doc = createHtmlDocument('Redirecting', 'Redirecting to ' + escapeHtml(loc));
            res.statusCode = 301;
            res.setHeader('Content-Type', 'text/html; charset=UTF-8');
            res.setHeader('Content-Length', Buffer.byteLength(doc));
            res.setHeader('Content-Security-Policy', "default-src 'none'");
            res.setHeader('X-Content-Type-Options', 'nosniff');
            res.setHeader('Location', loc);
            res.end(doc);
        };
        SendStream.prototype.pipe = function(res) {
            var root = this._root;
            this.res = res;
            var path = decode(this.path);
            if (-1 === path) {
                this.error(400);
                return res;
            }
            if (~path.indexOf('\0')) {
                this.error(400);
                return res;
            }
            var parts;
            if (null !== root) {
                if (path) path = normalize('.' + sep + path);
                if (UP_PATH_REGEXP.test(path)) {
                    debug('malicious path "%s"', path);
                    this.error(403);
                    return res;
                }
                parts = path.split(sep);
                path = normalize(join(root, path));
            } else {
                if (UP_PATH_REGEXP.test(path)) {
                    debug('malicious path "%s"', path);
                    this.error(403);
                    return res;
                }
                parts = normalize(path).split(sep);
                path = resolve(path);
            }
            if (containsDotFile(parts)) {
                var access = this._dotfiles;
                if (void 0 === access) access = '.' === parts[parts.length - 1][0] ? this._hidden ? 'allow' : 'ignore' : 'allow';
                debug('%s dotfile "%s"', access, path);
                switch(access){
                    case 'allow':
                        break;
                    case 'deny':
                        this.error(403);
                        return res;
                    case 'ignore':
                    default:
                        this.error(404);
                        return res;
                }
            }
            if (this._index.length && this.hasTrailingSlash()) {
                this.sendIndex(path);
                return res;
            }
            this.sendFile(path);
            return res;
        };
        SendStream.prototype.send = function(path, stat) {
            var len = stat.size;
            var options = this.options;
            var opts = {};
            var res = this.res;
            var req = this.req;
            var ranges = req.headers.range;
            var offset = options.start || 0;
            if (headersSent(res)) return void this.headersAlreadySent();
            debug('pipe "%s"', path);
            this.setHeader(path, stat);
            this.type(path);
            if (this.isConditionalGET()) {
                if (this.isPreconditionFailure()) return void this.error(412);
                if (this.isCachable() && this.isFresh()) return void this.notModified();
            }
            len = Math.max(0, len - offset);
            if (void 0 !== options.end) {
                var bytes = options.end - offset + 1;
                if (len > bytes) len = bytes;
            }
            if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
                ranges = parseRange(len, ranges, {
                    combine: true
                });
                if (!this.isRangeFresh()) {
                    debug('range stale');
                    ranges = -2;
                }
                if (-1 === ranges) {
                    debug('range unsatisfiable');
                    res.setHeader('Content-Range', contentRange('bytes', len));
                    return this.error(416, {
                        headers: {
                            'Content-Range': res.getHeader('Content-Range')
                        }
                    });
                }
                if (-2 !== ranges && 1 === ranges.length) {
                    debug('range %j', ranges);
                    res.statusCode = 206;
                    res.setHeader('Content-Range', contentRange('bytes', len, ranges[0]));
                    offset += ranges[0].start;
                    len = ranges[0].end - ranges[0].start + 1;
                }
            }
            for(var prop in options)opts[prop] = options[prop];
            opts.start = offset;
            opts.end = Math.max(offset, offset + len - 1);
            res.setHeader('Content-Length', len);
            if ('HEAD' === req.method) return void res.end();
            this.stream(path, opts);
        };
        SendStream.prototype.sendFile = function(path) {
            var i = 0;
            var self = this;
            debug('stat "%s"', path);
            fs.stat(path, function(err, stat) {
                if (err && 'ENOENT' === err.code && !extname(path) && path[path.length - 1] !== sep) return next(err);
                if (err) return self.onStatError(err);
                if (stat.isDirectory()) return self.redirect(path);
                self.emit('file', path, stat);
                self.send(path, stat);
            });
            function next(err) {
                if (self._extensions.length <= i) return err ? self.onStatError(err) : self.error(404);
                var p = path + '.' + self._extensions[i++];
                debug('stat "%s"', p);
                fs.stat(p, function(err, stat) {
                    if (err) return next(err);
                    if (stat.isDirectory()) return next();
                    self.emit('file', p, stat);
                    self.send(p, stat);
                });
            }
        };
        SendStream.prototype.sendIndex = function(path) {
            var i = -1;
            var self = this;
            function next(err) {
                if (++i >= self._index.length) {
                    if (err) return self.onStatError(err);
                    return self.error(404);
                }
                var p = join(path, self._index[i]);
                debug('stat "%s"', p);
                fs.stat(p, function(err, stat) {
                    if (err) return next(err);
                    if (stat.isDirectory()) return next();
                    self.emit('file', p, stat);
                    self.send(p, stat);
                });
            }
            next();
        };
        SendStream.prototype.stream = function(path, options) {
            var self = this;
            var res = this.res;
            var stream = fs.createReadStream(path, options);
            this.emit('stream', stream);
            stream.pipe(res);
            function cleanup() {
                destroy(stream, true);
            }
            onFinished(res, cleanup);
            stream.on('error', function(err) {
                cleanup();
                self.onStatError(err);
            });
            stream.on('end', function() {
                self.emit('end');
            });
        };
        SendStream.prototype.type = function(path) {
            var res = this.res;
            if (res.getHeader('Content-Type')) return;
            var type = mime.lookup(path);
            if (!type) return void debug('no content-type');
            var charset = mime.charsets.lookup(type);
            debug('content-type %s', type);
            res.setHeader('Content-Type', type + (charset ? '; charset=' + charset : ''));
        };
        SendStream.prototype.setHeader = function(path, stat) {
            var res = this.res;
            this.emit('headers', res, path, stat);
            if (this._acceptRanges && !res.getHeader('Accept-Ranges')) {
                debug('accept ranges');
                res.setHeader('Accept-Ranges', 'bytes');
            }
            if (this._cacheControl && !res.getHeader('Cache-Control')) {
                var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000);
                if (this._immutable) cacheControl += ', immutable';
                debug('cache-control %s', cacheControl);
                res.setHeader('Cache-Control', cacheControl);
            }
            if (this._lastModified && !res.getHeader('Last-Modified')) {
                var modified = stat.mtime.toUTCString();
                debug('modified %s', modified);
                res.setHeader('Last-Modified', modified);
            }
            if (this._etag && !res.getHeader('ETag')) {
                var val = etag(stat);
                debug('etag %s', val);
                res.setHeader('ETag', val);
            }
        };
        function clearHeaders(res) {
            var headers = getHeaderNames(res);
            for(var i = 0; i < headers.length; i++)res.removeHeader(headers[i]);
        }
        function collapseLeadingSlashes(str) {
            for(var i = 0; i < str.length && '/' === str[i]; i++);
            return i > 1 ? '/' + str.substr(i) : str;
        }
        function containsDotFile(parts) {
            for(var i = 0; i < parts.length; i++){
                var part = parts[i];
                if (part.length > 1 && '.' === part[0]) return true;
            }
            return false;
        }
        function contentRange(type, size, range) {
            return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size;
        }
        function createHtmlDocument(title, body) {
            return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
        }
        function createHttpError(status, err) {
            if (!err) return createError(status);
            return err instanceof Error ? createError(status, err, {
                expose: false
            }) : createError(status, err);
        }
        function decode(path) {
            try {
                return decodeURIComponent(path);
            } catch (err) {
                return -1;
            }
        }
        function getHeaderNames(res) {
            return 'function' != typeof res.getHeaderNames ? Object.keys(res._headers || {}) : res.getHeaderNames();
        }
        function hasListeners(emitter, type) {
            var count = 'function' != typeof emitter.listenerCount ? emitter.listeners(type).length : emitter.listenerCount(type);
            return count > 0;
        }
        function headersSent(res) {
            return 'boolean' != typeof res.headersSent ? Boolean(res._header) : res.headersSent;
        }
        function normalizeList(val, name) {
            var list = [].concat(val || []);
            for(var i = 0; i < list.length; i++)if ('string' != typeof list[i]) throw new TypeError(name + ' must be array of strings or false');
            return list;
        }
        function parseHttpDate(date) {
            var timestamp = date && Date.parse(date);
            return 'number' == typeof timestamp ? timestamp : NaN;
        }
        function parseTokenList(str) {
            var end = 0;
            var list = [];
            var start = 0;
            for(var i = 0, len = str.length; i < len; i++)switch(str.charCodeAt(i)){
                case 0x20:
                    if (start === end) start = end = i + 1;
                    break;
                case 0x2c:
                    if (start !== end) list.push(str.substring(start, end));
                    start = end = i + 1;
                    break;
                default:
                    end = i + 1;
                    break;
            }
            if (start !== end) list.push(str.substring(start, end));
            return list;
        }
        function setHeaders(res, headers) {
            var keys = Object.keys(headers);
            for(var i = 0; i < keys.length; i++){
                var key = keys[i];
                res.setHeader(key, headers[key]);
            }
        }
    },
    "../node_modules/.pnpm/serve-static@1.16.2/node_modules/serve-static/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var encodeUrl = __webpack_require__("../node_modules/.pnpm/encodeurl@2.0.0/node_modules/encodeurl/index.js");
        var escapeHtml = __webpack_require__("../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js");
        var parseUrl = __webpack_require__("../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js");
        var resolve = __webpack_require__("path").resolve;
        var send = __webpack_require__("../node_modules/.pnpm/send@0.19.0/node_modules/send/index.js");
        var url = __webpack_require__("url");
        module.exports = serveStatic;
        module.exports.mime = send.mime;
        function serveStatic(root, options) {
            if (!root) throw new TypeError('root path required');
            if ('string' != typeof root) throw new TypeError('root path must be a string');
            var opts = Object.create(options || null);
            var fallthrough = false !== opts.fallthrough;
            var redirect = false !== opts.redirect;
            var setHeaders = opts.setHeaders;
            if (setHeaders && 'function' != typeof setHeaders) throw new TypeError('option setHeaders must be function');
            opts.maxage = opts.maxage || opts.maxAge || 0;
            opts.root = resolve(root);
            var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
            return function(req, res, next) {
                if ('GET' !== req.method && 'HEAD' !== req.method) {
                    if (fallthrough) return next();
                    res.statusCode = 405;
                    res.setHeader('Allow', 'GET, HEAD');
                    res.setHeader('Content-Length', '0');
                    res.end();
                    return;
                }
                var forwardError = !fallthrough;
                var originalUrl = parseUrl.original(req);
                var path = parseUrl(req).pathname;
                if ('/' === path && '/' !== originalUrl.pathname.substr(-1)) path = '';
                var stream = send(req, path, opts);
                stream.on('directory', onDirectory);
                if (setHeaders) stream.on('headers', setHeaders);
                if (fallthrough) stream.on('file', function() {
                    forwardError = true;
                });
                stream.on('error', function(err) {
                    if (forwardError || !(err.statusCode < 500)) return void next(err);
                    next();
                });
                stream.pipe(res);
            };
        }
        function collapseLeadingSlashes(str) {
            for(var i = 0; i < str.length && 0x2f === str.charCodeAt(i); i++);
            return i > 1 ? '/' + str.substr(i) : str;
        }
        function createHtmlDocument(title, body) {
            return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
        }
        function createNotFoundDirectoryListener() {
            return function() {
                this.error(404);
            };
        }
        function createRedirectDirectoryListener() {
            return function(res) {
                if (this.hasTrailingSlash()) return void this.error(404);
                var originalUrl = parseUrl.original(this.req);
                originalUrl.path = null;
                originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + '/');
                var loc = encodeUrl(url.format(originalUrl));
                var doc = createHtmlDocument('Redirecting', 'Redirecting to ' + escapeHtml(loc));
                res.statusCode = 301;
                res.setHeader('Content-Type', 'text/html; charset=UTF-8');
                res.setHeader('Content-Length', Buffer.byteLength(doc));
                res.setHeader('Content-Security-Policy', "default-src 'none'");
                res.setHeader('X-Content-Type-Options', 'nosniff');
                res.setHeader('Location', loc);
                res.end(doc);
            };
        }
    },
    "../node_modules/.pnpm/setprototypeof@1.2.0/node_modules/setprototypeof/index.js": function(module) {
        "use strict";
        module.exports = Object.setPrototypeOf || (({
            __proto__: []
        }) instanceof Array ? setProtoOf : mixinProperties);
        function setProtoOf(obj, proto) {
            obj.__proto__ = proto;
            return obj;
        }
        function mixinProperties(obj, proto) {
            for(var prop in proto)if (!Object.prototype.hasOwnProperty.call(obj, prop)) obj[prop] = proto[prop];
            return obj;
        }
    },
    "../node_modules/.pnpm/side-channel-list@1.0.0/node_modules/side-channel-list/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var inspect = __webpack_require__("../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js");
        var $TypeError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
        var listGetNode = function(list, key, isDelete) {
            var prev = list;
            var curr;
            for(; null != (curr = prev.next); prev = curr)if (curr.key === key) {
                prev.next = curr.next;
                if (!isDelete) {
                    curr.next = list.next;
                    list.next = curr;
                }
                return curr;
            }
        };
        var listGet = function(objects, key) {
            if (!objects) return;
            var node = listGetNode(objects, key);
            return node && node.value;
        };
        var listSet = function(objects, key, value) {
            var node = listGetNode(objects, key);
            if (node) node.value = value;
            else objects.next = {
                key: key,
                next: objects.next,
                value: value
            };
        };
        var listHas = function(objects, key) {
            if (!objects) return false;
            return !!listGetNode(objects, key);
        };
        var listDelete = function(objects, key) {
            if (objects) return listGetNode(objects, key, true);
        };
        module.exports = function() {
            var $o;
            var channel = {
                assert: function(key) {
                    if (!channel.has(key)) throw new $TypeError('Side channel does not contain ' + inspect(key));
                },
                delete: function(key) {
                    var root = $o && $o.next;
                    var deletedNode = listDelete($o, key);
                    if (deletedNode && root && root === deletedNode) $o = void 0;
                    return !!deletedNode;
                },
                get: function(key) {
                    return listGet($o, key);
                },
                has: function(key) {
                    return listHas($o, key);
                },
                set: function(key, value) {
                    if (!$o) $o = {
                        next: void 0
                    };
                    listSet($o, key, value);
                }
            };
            return channel;
        };
    },
    "../node_modules/.pnpm/side-channel-map@1.0.1/node_modules/side-channel-map/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var GetIntrinsic = __webpack_require__("../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js");
        var callBound = __webpack_require__("../node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
        var inspect = __webpack_require__("../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js");
        var $TypeError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
        var $Map = GetIntrinsic('%Map%', true);
        var $mapGet = callBound('Map.prototype.get', true);
        var $mapSet = callBound('Map.prototype.set', true);
        var $mapHas = callBound('Map.prototype.has', true);
        var $mapDelete = callBound('Map.prototype.delete', true);
        var $mapSize = callBound('Map.prototype.size', true);
        module.exports = !!$Map && function() {
            var $m;
            var channel = {
                assert: function(key) {
                    if (!channel.has(key)) throw new $TypeError('Side channel does not contain ' + inspect(key));
                },
                delete: function(key) {
                    if ($m) {
                        var result = $mapDelete($m, key);
                        if (0 === $mapSize($m)) $m = void 0;
                        return result;
                    }
                    return false;
                },
                get: function(key) {
                    if ($m) return $mapGet($m, key);
                },
                has: function(key) {
                    if ($m) return $mapHas($m, key);
                    return false;
                },
                set: function(key, value) {
                    if (!$m) $m = new $Map();
                    $mapSet($m, key, value);
                }
            };
            return channel;
        };
    },
    "../node_modules/.pnpm/side-channel-weakmap@1.0.2/node_modules/side-channel-weakmap/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var GetIntrinsic = __webpack_require__("../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js");
        var callBound = __webpack_require__("../node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
        var inspect = __webpack_require__("../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js");
        var getSideChannelMap = __webpack_require__("../node_modules/.pnpm/side-channel-map@1.0.1/node_modules/side-channel-map/index.js");
        var $TypeError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
        var $WeakMap = GetIntrinsic('%WeakMap%', true);
        var $weakMapGet = callBound('WeakMap.prototype.get', true);
        var $weakMapSet = callBound('WeakMap.prototype.set', true);
        var $weakMapHas = callBound('WeakMap.prototype.has', true);
        var $weakMapDelete = callBound('WeakMap.prototype.delete', true);
        module.exports = $WeakMap ? function() {
            var $wm;
            var $m;
            var channel = {
                assert: function(key) {
                    if (!channel.has(key)) throw new $TypeError('Side channel does not contain ' + inspect(key));
                },
                delete: function(key) {
                    if ($WeakMap && key && ('object' == typeof key || 'function' == typeof key)) {
                        if ($wm) return $weakMapDelete($wm, key);
                    } else if (getSideChannelMap) {
                        if ($m) return $m['delete'](key);
                    }
                    return false;
                },
                get: function(key) {
                    if ($WeakMap && key && ('object' == typeof key || 'function' == typeof key)) {
                        if ($wm) return $weakMapGet($wm, key);
                    }
                    return $m && $m.get(key);
                },
                has: function(key) {
                    if ($WeakMap && key && ('object' == typeof key || 'function' == typeof key)) {
                        if ($wm) return $weakMapHas($wm, key);
                    }
                    return !!$m && $m.has(key);
                },
                set: function(key, value) {
                    if ($WeakMap && key && ('object' == typeof key || 'function' == typeof key)) {
                        if (!$wm) $wm = new $WeakMap();
                        $weakMapSet($wm, key, value);
                    } else if (getSideChannelMap) {
                        if (!$m) $m = getSideChannelMap();
                        $m.set(key, value);
                    }
                }
            };
            return channel;
        } : getSideChannelMap;
    },
    "../node_modules/.pnpm/side-channel@1.1.0/node_modules/side-channel/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var $TypeError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
        var inspect = __webpack_require__("../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js");
        var getSideChannelList = __webpack_require__("../node_modules/.pnpm/side-channel-list@1.0.0/node_modules/side-channel-list/index.js");
        var getSideChannelMap = __webpack_require__("../node_modules/.pnpm/side-channel-map@1.0.1/node_modules/side-channel-map/index.js");
        var getSideChannelWeakMap = __webpack_require__("../node_modules/.pnpm/side-channel-weakmap@1.0.2/node_modules/side-channel-weakmap/index.js");
        var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
        module.exports = function() {
            var $channelData;
            var channel = {
                assert: function(key) {
                    if (!channel.has(key)) throw new $TypeError('Side channel does not contain ' + inspect(key));
                },
                delete: function(key) {
                    return !!$channelData && $channelData['delete'](key);
                },
                get: function(key) {
                    return $channelData && $channelData.get(key);
                },
                has: function(key) {
                    return !!$channelData && $channelData.has(key);
                },
                set: function(key, value) {
                    if (!$channelData) $channelData = makeChannel();
                    $channelData.set(key, value);
                }
            };
            return channel;
        };
    },
    "../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/cluster-adapter.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var __rest = this && this.__rest || function(s, e) {
            var t = {};
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
            if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
                for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
            }
            return t;
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.ClusterAdapterWithHeartbeat = exports1.ClusterAdapter = exports1.MessageType = void 0;
        const in_memory_adapter_1 = __webpack_require__("../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/in-memory-adapter.js");
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const crypto_1 = __webpack_require__("crypto");
        const debug = (0, debug_1.debug)("socket.io-adapter");
        const EMITTER_UID = "emitter";
        const DEFAULT_TIMEOUT = 5000;
        function randomId() {
            return (0, crypto_1.randomBytes)(8).toString("hex");
        }
        var MessageType;
        (function(MessageType) {
            MessageType[MessageType["INITIAL_HEARTBEAT"] = 1] = "INITIAL_HEARTBEAT";
            MessageType[MessageType["HEARTBEAT"] = 2] = "HEARTBEAT";
            MessageType[MessageType["BROADCAST"] = 3] = "BROADCAST";
            MessageType[MessageType["SOCKETS_JOIN"] = 4] = "SOCKETS_JOIN";
            MessageType[MessageType["SOCKETS_LEAVE"] = 5] = "SOCKETS_LEAVE";
            MessageType[MessageType["DISCONNECT_SOCKETS"] = 6] = "DISCONNECT_SOCKETS";
            MessageType[MessageType["FETCH_SOCKETS"] = 7] = "FETCH_SOCKETS";
            MessageType[MessageType["FETCH_SOCKETS_RESPONSE"] = 8] = "FETCH_SOCKETS_RESPONSE";
            MessageType[MessageType["SERVER_SIDE_EMIT"] = 9] = "SERVER_SIDE_EMIT";
            MessageType[MessageType["SERVER_SIDE_EMIT_RESPONSE"] = 10] = "SERVER_SIDE_EMIT_RESPONSE";
            MessageType[MessageType["BROADCAST_CLIENT_COUNT"] = 11] = "BROADCAST_CLIENT_COUNT";
            MessageType[MessageType["BROADCAST_ACK"] = 12] = "BROADCAST_ACK";
            MessageType[MessageType["ADAPTER_CLOSE"] = 13] = "ADAPTER_CLOSE";
        })(MessageType = exports1.MessageType || (exports1.MessageType = {}));
        function encodeOptions(opts) {
            return {
                rooms: [
                    ...opts.rooms
                ],
                except: [
                    ...opts.except
                ],
                flags: opts.flags
            };
        }
        function decodeOptions(opts) {
            return {
                rooms: new Set(opts.rooms),
                except: new Set(opts.except),
                flags: opts.flags
            };
        }
        class ClusterAdapter extends in_memory_adapter_1.Adapter {
            constructor(nsp){
                super(nsp);
                this.requests = new Map();
                this.ackRequests = new Map();
                this.uid = randomId();
            }
            onMessage(message, offset) {
                if (message.uid === this.uid) return debug("[%s] ignore message from self", this.uid);
                debug("[%s] new event of type %d from %s", this.uid, message.type, message.uid);
                switch(message.type){
                    case MessageType.BROADCAST:
                        {
                            const withAck = void 0 !== message.data.requestId;
                            if (withAck) super.broadcastWithAck(message.data.packet, decodeOptions(message.data.opts), (clientCount)=>{
                                debug("[%s] waiting for %d client acknowledgements", this.uid, clientCount);
                                this.publishResponse(message.uid, {
                                    type: MessageType.BROADCAST_CLIENT_COUNT,
                                    data: {
                                        requestId: message.data.requestId,
                                        clientCount
                                    }
                                });
                            }, (arg)=>{
                                debug("[%s] received acknowledgement with value %j", this.uid, arg);
                                this.publishResponse(message.uid, {
                                    type: MessageType.BROADCAST_ACK,
                                    data: {
                                        requestId: message.data.requestId,
                                        packet: arg
                                    }
                                });
                            });
                            else {
                                const packet = message.data.packet;
                                const opts = decodeOptions(message.data.opts);
                                this.addOffsetIfNecessary(packet, opts, offset);
                                super.broadcast(packet, opts);
                            }
                            break;
                        }
                    case MessageType.SOCKETS_JOIN:
                        super.addSockets(decodeOptions(message.data.opts), message.data.rooms);
                        break;
                    case MessageType.SOCKETS_LEAVE:
                        super.delSockets(decodeOptions(message.data.opts), message.data.rooms);
                        break;
                    case MessageType.DISCONNECT_SOCKETS:
                        super.disconnectSockets(decodeOptions(message.data.opts), message.data.close);
                        break;
                    case MessageType.FETCH_SOCKETS:
                        debug("[%s] calling fetchSockets with opts %j", this.uid, message.data.opts);
                        super.fetchSockets(decodeOptions(message.data.opts)).then((localSockets)=>{
                            this.publishResponse(message.uid, {
                                type: MessageType.FETCH_SOCKETS_RESPONSE,
                                data: {
                                    requestId: message.data.requestId,
                                    sockets: localSockets.map((socket)=>{
                                        const _a = socket.handshake, { sessionStore } = _a, handshake = __rest(_a, [
                                            "sessionStore"
                                        ]);
                                        return {
                                            id: socket.id,
                                            handshake,
                                            rooms: [
                                                ...socket.rooms
                                            ],
                                            data: socket.data
                                        };
                                    })
                                }
                            });
                        });
                        break;
                    case MessageType.SERVER_SIDE_EMIT:
                        {
                            const packet = message.data.packet;
                            const withAck = void 0 !== message.data.requestId;
                            if (!withAck) return void this.nsp._onServerSideEmit(packet);
                            let called = false;
                            const callback = (arg)=>{
                                if (called) return;
                                called = true;
                                debug("[%s] calling acknowledgement with %j", this.uid, arg);
                                this.publishResponse(message.uid, {
                                    type: MessageType.SERVER_SIDE_EMIT_RESPONSE,
                                    data: {
                                        requestId: message.data.requestId,
                                        packet: arg
                                    }
                                });
                            };
                            this.nsp._onServerSideEmit([
                                ...packet,
                                callback
                            ]);
                            break;
                        }
                    case MessageType.BROADCAST_CLIENT_COUNT:
                    case MessageType.BROADCAST_ACK:
                    case MessageType.FETCH_SOCKETS_RESPONSE:
                    case MessageType.SERVER_SIDE_EMIT_RESPONSE:
                        this.onResponse(message);
                        break;
                    default:
                        debug("[%s] unknown message type: %s", this.uid, message.type);
                }
            }
            onResponse(response) {
                var _a, _b;
                const requestId = response.data.requestId;
                debug("[%s] received response %s to request %s", this.uid, response.type, requestId);
                switch(response.type){
                    case MessageType.BROADCAST_CLIENT_COUNT:
                        null == (_a = this.ackRequests.get(requestId)) || _a.clientCountCallback(response.data.clientCount);
                        break;
                    case MessageType.BROADCAST_ACK:
                        null == (_b = this.ackRequests.get(requestId)) || _b.ack(response.data.packet);
                        break;
                    case MessageType.FETCH_SOCKETS_RESPONSE:
                        {
                            const request = this.requests.get(requestId);
                            if (!request) return;
                            request.current++;
                            response.data.sockets.forEach((socket)=>request.responses.push(socket));
                            if (request.current === request.expected) {
                                clearTimeout(request.timeout);
                                request.resolve(request.responses);
                                this.requests.delete(requestId);
                            }
                            break;
                        }
                    case MessageType.SERVER_SIDE_EMIT_RESPONSE:
                        {
                            const request = this.requests.get(requestId);
                            if (!request) return;
                            request.current++;
                            request.responses.push(response.data.packet);
                            if (request.current === request.expected) {
                                clearTimeout(request.timeout);
                                request.resolve(null, request.responses);
                                this.requests.delete(requestId);
                            }
                            break;
                        }
                    default:
                        debug("[%s] unknown response type: %s", this.uid, response.type);
                }
            }
            async broadcast(packet, opts) {
                var _a;
                const onlyLocal = null == (_a = opts.flags) ? void 0 : _a.local;
                if (!onlyLocal) try {
                    const offset = await this.publishAndReturnOffset({
                        type: MessageType.BROADCAST,
                        data: {
                            packet,
                            opts: encodeOptions(opts)
                        }
                    });
                    this.addOffsetIfNecessary(packet, opts, offset);
                } catch (e) {
                    return debug("[%s] error while broadcasting message: %s", this.uid, e.message);
                }
                super.broadcast(packet, opts);
            }
            addOffsetIfNecessary(packet, opts, offset) {
                var _a;
                if (!this.nsp.server.opts.connectionStateRecovery) return;
                const isEventPacket = 2 === packet.type;
                const withoutAcknowledgement = void 0 === packet.id;
                const notVolatile = (null == (_a = opts.flags) ? void 0 : _a.volatile) === void 0;
                if (isEventPacket && withoutAcknowledgement && notVolatile) packet.data.push(offset);
            }
            broadcastWithAck(packet, opts, clientCountCallback, ack) {
                var _a;
                const onlyLocal = null == (_a = null == opts ? void 0 : opts.flags) ? void 0 : _a.local;
                if (!onlyLocal) {
                    const requestId = randomId();
                    this.ackRequests.set(requestId, {
                        clientCountCallback,
                        ack
                    });
                    this.publish({
                        type: MessageType.BROADCAST,
                        data: {
                            packet,
                            requestId,
                            opts: encodeOptions(opts)
                        }
                    });
                    setTimeout(()=>{
                        this.ackRequests.delete(requestId);
                    }, opts.flags.timeout);
                }
                super.broadcastWithAck(packet, opts, clientCountCallback, ack);
            }
            async addSockets(opts, rooms) {
                var _a;
                const onlyLocal = null == (_a = opts.flags) ? void 0 : _a.local;
                if (!onlyLocal) try {
                    await this.publishAndReturnOffset({
                        type: MessageType.SOCKETS_JOIN,
                        data: {
                            opts: encodeOptions(opts),
                            rooms
                        }
                    });
                } catch (e) {
                    debug("[%s] error while publishing message: %s", this.uid, e.message);
                }
                super.addSockets(opts, rooms);
            }
            async delSockets(opts, rooms) {
                var _a;
                const onlyLocal = null == (_a = opts.flags) ? void 0 : _a.local;
                if (!onlyLocal) try {
                    await this.publishAndReturnOffset({
                        type: MessageType.SOCKETS_LEAVE,
                        data: {
                            opts: encodeOptions(opts),
                            rooms
                        }
                    });
                } catch (e) {
                    debug("[%s] error while publishing message: %s", this.uid, e.message);
                }
                super.delSockets(opts, rooms);
            }
            async disconnectSockets(opts, close) {
                var _a;
                const onlyLocal = null == (_a = opts.flags) ? void 0 : _a.local;
                if (!onlyLocal) try {
                    await this.publishAndReturnOffset({
                        type: MessageType.DISCONNECT_SOCKETS,
                        data: {
                            opts: encodeOptions(opts),
                            close
                        }
                    });
                } catch (e) {
                    debug("[%s] error while publishing message: %s", this.uid, e.message);
                }
                super.disconnectSockets(opts, close);
            }
            async fetchSockets(opts) {
                var _a;
                const [localSockets, serverCount] = await Promise.all([
                    super.fetchSockets(opts),
                    this.serverCount()
                ]);
                const expectedResponseCount = serverCount - 1;
                if ((null == (_a = opts.flags) ? void 0 : _a.local) || expectedResponseCount <= 0) return localSockets;
                const requestId = randomId();
                return new Promise((resolve, reject)=>{
                    const timeout = setTimeout(()=>{
                        const storedRequest = this.requests.get(requestId);
                        if (storedRequest) {
                            reject(new Error(`timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`));
                            this.requests.delete(requestId);
                        }
                    }, opts.flags.timeout || DEFAULT_TIMEOUT);
                    const storedRequest = {
                        type: MessageType.FETCH_SOCKETS,
                        resolve,
                        timeout,
                        current: 0,
                        expected: expectedResponseCount,
                        responses: localSockets
                    };
                    this.requests.set(requestId, storedRequest);
                    this.publish({
                        type: MessageType.FETCH_SOCKETS,
                        data: {
                            opts: encodeOptions(opts),
                            requestId
                        }
                    });
                });
            }
            async serverSideEmit(packet) {
                const withAck = "function" == typeof packet[packet.length - 1];
                if (!withAck) return this.publish({
                    type: MessageType.SERVER_SIDE_EMIT,
                    data: {
                        packet
                    }
                });
                const ack = packet.pop();
                const expectedResponseCount = await this.serverCount() - 1;
                debug('[%s] waiting for %d responses to "serverSideEmit" request', this.uid, expectedResponseCount);
                if (expectedResponseCount <= 0) return ack(null, []);
                const requestId = randomId();
                const timeout = setTimeout(()=>{
                    const storedRequest = this.requests.get(requestId);
                    if (storedRequest) {
                        ack(new Error(`timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`), storedRequest.responses);
                        this.requests.delete(requestId);
                    }
                }, DEFAULT_TIMEOUT);
                const storedRequest = {
                    type: MessageType.SERVER_SIDE_EMIT,
                    resolve: ack,
                    timeout,
                    current: 0,
                    expected: expectedResponseCount,
                    responses: []
                };
                this.requests.set(requestId, storedRequest);
                this.publish({
                    type: MessageType.SERVER_SIDE_EMIT,
                    data: {
                        requestId,
                        packet
                    }
                });
            }
            publish(message) {
                this.publishAndReturnOffset(message).catch((err)=>{
                    debug("[%s] error while publishing message: %s", this.uid, err);
                });
            }
            publishAndReturnOffset(message) {
                message.uid = this.uid;
                message.nsp = this.nsp.name;
                return this.doPublish(message);
            }
            publishResponse(requesterUid, response) {
                response.uid = this.uid;
                response.nsp = this.nsp.name;
                this.doPublishResponse(requesterUid, response).catch((err)=>{
                    debug("[%s] error while publishing response: %s", this.uid, err);
                });
            }
        }
        exports1.ClusterAdapter = ClusterAdapter;
        class ClusterAdapterWithHeartbeat extends ClusterAdapter {
            constructor(nsp, opts){
                super(nsp);
                this.nodesMap = new Map();
                this.customRequests = new Map();
                this._opts = Object.assign({
                    heartbeatInterval: 5000,
                    heartbeatTimeout: 10000
                }, opts);
                this.cleanupTimer = setInterval(()=>{
                    const now = Date.now();
                    this.nodesMap.forEach((lastSeen, uid)=>{
                        const nodeSeemsDown = now - lastSeen > this._opts.heartbeatTimeout;
                        if (nodeSeemsDown) {
                            debug("[%s] node %s seems down", this.uid, uid);
                            this.removeNode(uid);
                        }
                    });
                }, 1000);
            }
            init() {
                this.publish({
                    type: MessageType.INITIAL_HEARTBEAT
                });
            }
            scheduleHeartbeat() {
                if (this.heartbeatTimer) this.heartbeatTimer.refresh();
                else this.heartbeatTimer = setTimeout(()=>{
                    this.publish({
                        type: MessageType.HEARTBEAT
                    });
                }, this._opts.heartbeatInterval);
            }
            close() {
                this.publish({
                    type: MessageType.ADAPTER_CLOSE
                });
                clearTimeout(this.heartbeatTimer);
                if (this.cleanupTimer) clearInterval(this.cleanupTimer);
            }
            onMessage(message, offset) {
                if (message.uid === this.uid) return debug("[%s] ignore message from self", this.uid);
                if (message.uid && message.uid !== EMITTER_UID) this.nodesMap.set(message.uid, Date.now());
                debug("[%s] new event of type %d from %s", this.uid, message.type, message.uid);
                switch(message.type){
                    case MessageType.INITIAL_HEARTBEAT:
                        this.publish({
                            type: MessageType.HEARTBEAT
                        });
                        break;
                    case MessageType.HEARTBEAT:
                        break;
                    case MessageType.ADAPTER_CLOSE:
                        this.removeNode(message.uid);
                        break;
                    default:
                        super.onMessage(message, offset);
                }
            }
            serverCount() {
                return Promise.resolve(1 + this.nodesMap.size);
            }
            publish(message) {
                this.scheduleHeartbeat();
                return super.publish(message);
            }
            async serverSideEmit(packet) {
                const withAck = "function" == typeof packet[packet.length - 1];
                if (!withAck) return this.publish({
                    type: MessageType.SERVER_SIDE_EMIT,
                    data: {
                        packet
                    }
                });
                const ack = packet.pop();
                const expectedResponseCount = this.nodesMap.size;
                debug('[%s] waiting for %d responses to "serverSideEmit" request', this.uid, expectedResponseCount);
                if (expectedResponseCount <= 0) return ack(null, []);
                const requestId = randomId();
                const timeout = setTimeout(()=>{
                    const storedRequest = this.customRequests.get(requestId);
                    if (storedRequest) {
                        ack(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`), storedRequest.responses);
                        this.customRequests.delete(requestId);
                    }
                }, DEFAULT_TIMEOUT);
                const storedRequest = {
                    type: MessageType.SERVER_SIDE_EMIT,
                    resolve: ack,
                    timeout,
                    missingUids: new Set([
                        ...this.nodesMap.keys()
                    ]),
                    responses: []
                };
                this.customRequests.set(requestId, storedRequest);
                this.publish({
                    type: MessageType.SERVER_SIDE_EMIT,
                    data: {
                        requestId,
                        packet
                    }
                });
            }
            async fetchSockets(opts) {
                var _a;
                const [localSockets, serverCount] = await Promise.all([
                    super.fetchSockets({
                        rooms: opts.rooms,
                        except: opts.except,
                        flags: {
                            local: true
                        }
                    }),
                    this.serverCount()
                ]);
                const expectedResponseCount = serverCount - 1;
                if ((null == (_a = opts.flags) ? void 0 : _a.local) || expectedResponseCount <= 0) return localSockets;
                const requestId = randomId();
                return new Promise((resolve, reject)=>{
                    const timeout = setTimeout(()=>{
                        const storedRequest = this.customRequests.get(requestId);
                        if (storedRequest) {
                            reject(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`));
                            this.customRequests.delete(requestId);
                        }
                    }, opts.flags.timeout || DEFAULT_TIMEOUT);
                    const storedRequest = {
                        type: MessageType.FETCH_SOCKETS,
                        resolve,
                        timeout,
                        missingUids: new Set([
                            ...this.nodesMap.keys()
                        ]),
                        responses: localSockets
                    };
                    this.customRequests.set(requestId, storedRequest);
                    this.publish({
                        type: MessageType.FETCH_SOCKETS,
                        data: {
                            opts: encodeOptions(opts),
                            requestId
                        }
                    });
                });
            }
            onResponse(response) {
                const requestId = response.data.requestId;
                debug("[%s] received response %s to request %s", this.uid, response.type, requestId);
                switch(response.type){
                    case MessageType.FETCH_SOCKETS_RESPONSE:
                        {
                            const request = this.customRequests.get(requestId);
                            if (!request) return;
                            response.data.sockets.forEach((socket)=>request.responses.push(socket));
                            request.missingUids.delete(response.uid);
                            if (0 === request.missingUids.size) {
                                clearTimeout(request.timeout);
                                request.resolve(request.responses);
                                this.customRequests.delete(requestId);
                            }
                            break;
                        }
                    case MessageType.SERVER_SIDE_EMIT_RESPONSE:
                        {
                            const request = this.customRequests.get(requestId);
                            if (!request) return;
                            request.responses.push(response.data.packet);
                            request.missingUids.delete(response.uid);
                            if (0 === request.missingUids.size) {
                                clearTimeout(request.timeout);
                                request.resolve(null, request.responses);
                                this.customRequests.delete(requestId);
                            }
                            break;
                        }
                    default:
                        super.onResponse(response);
                }
            }
            removeNode(uid) {
                this.customRequests.forEach((request, requestId)=>{
                    request.missingUids.delete(uid);
                    if (0 === request.missingUids.size) {
                        clearTimeout(request.timeout);
                        if (request.type === MessageType.FETCH_SOCKETS) request.resolve(request.responses);
                        else if (request.type === MessageType.SERVER_SIDE_EMIT) request.resolve(null, request.responses);
                        this.customRequests.delete(requestId);
                    }
                });
                this.nodesMap.delete(uid);
            }
        }
        exports1.ClusterAdapterWithHeartbeat = ClusterAdapterWithHeartbeat;
    },
    "../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/contrib/yeast.js": function(__unused_webpack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.yeast = exports1.decode = exports1.encode = void 0;
        const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map = {};
        let seed = 0, i = 0, prev;
        function encode(num) {
            let encoded = "";
            do {
                encoded = alphabet[num % length] + encoded;
                num = Math.floor(num / length);
            }while (num > 0);
            return encoded;
        }
        exports1.encode = encode;
        function decode(str) {
            let decoded = 0;
            for(i = 0; i < str.length; i++)decoded = decoded * length + map[str.charAt(i)];
            return decoded;
        }
        exports1.decode = decode;
        function yeast() {
            const now = encode(+new Date());
            if (now !== prev) return seed = 0, prev = now;
            return now + "." + encode(seed++);
        }
        exports1.yeast = yeast;
        for(; i < length; i++)map[alphabet[i]] = i;
    },
    "../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/in-memory-adapter.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var _a;
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.SessionAwareAdapter = exports1.Adapter = void 0;
        const events_1 = __webpack_require__("events");
        const yeast_1 = __webpack_require__("../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/contrib/yeast.js");
        const WebSocket = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/index.js");
        const canPreComputeFrame = "function" == typeof (null == (_a = null == WebSocket ? void 0 : WebSocket.Sender) ? void 0 : _a.frame);
        class Adapter extends events_1.EventEmitter {
            constructor(nsp){
                super();
                this.nsp = nsp;
                this.rooms = new Map();
                this.sids = new Map();
                this.encoder = nsp.server.encoder;
            }
            init() {}
            close() {}
            serverCount() {
                return Promise.resolve(1);
            }
            addAll(id, rooms) {
                if (!this.sids.has(id)) this.sids.set(id, new Set());
                for (const room of rooms){
                    this.sids.get(id).add(room);
                    if (!this.rooms.has(room)) {
                        this.rooms.set(room, new Set());
                        this.emit("create-room", room);
                    }
                    if (!this.rooms.get(room).has(id)) {
                        this.rooms.get(room).add(id);
                        this.emit("join-room", room, id);
                    }
                }
            }
            del(id, room) {
                if (this.sids.has(id)) this.sids.get(id).delete(room);
                this._del(room, id);
            }
            _del(room, id) {
                const _room = this.rooms.get(room);
                if (null != _room) {
                    const deleted = _room.delete(id);
                    if (deleted) this.emit("leave-room", room, id);
                    if (0 === _room.size && this.rooms.delete(room)) this.emit("delete-room", room);
                }
            }
            delAll(id) {
                if (!this.sids.has(id)) return;
                for (const room of this.sids.get(id))this._del(room, id);
                this.sids.delete(id);
            }
            broadcast(packet, opts) {
                const flags = opts.flags || {};
                const packetOpts = {
                    preEncoded: true,
                    volatile: flags.volatile,
                    compress: flags.compress
                };
                packet.nsp = this.nsp.name;
                const encodedPackets = this._encode(packet, packetOpts);
                this.apply(opts, (socket)=>{
                    if ("function" == typeof socket.notifyOutgoingListeners) socket.notifyOutgoingListeners(packet);
                    socket.client.writeToEngine(encodedPackets, packetOpts);
                });
            }
            broadcastWithAck(packet, opts, clientCountCallback, ack) {
                const flags = opts.flags || {};
                const packetOpts = {
                    preEncoded: true,
                    volatile: flags.volatile,
                    compress: flags.compress
                };
                packet.nsp = this.nsp.name;
                packet.id = this.nsp._ids++;
                const encodedPackets = this._encode(packet, packetOpts);
                let clientCount = 0;
                this.apply(opts, (socket)=>{
                    clientCount++;
                    socket.acks.set(packet.id, ack);
                    if ("function" == typeof socket.notifyOutgoingListeners) socket.notifyOutgoingListeners(packet);
                    socket.client.writeToEngine(encodedPackets, packetOpts);
                });
                clientCountCallback(clientCount);
            }
            _encode(packet, packetOpts) {
                const encodedPackets = this.encoder.encode(packet);
                if (canPreComputeFrame && 1 === encodedPackets.length && "string" == typeof encodedPackets[0]) {
                    const data = Buffer.from("4" + encodedPackets[0]);
                    packetOpts.wsPreEncodedFrame = WebSocket.Sender.frame(data, {
                        readOnly: false,
                        mask: false,
                        rsv1: false,
                        opcode: 1,
                        fin: true
                    });
                }
                return encodedPackets;
            }
            sockets(rooms) {
                const sids = new Set();
                this.apply({
                    rooms
                }, (socket)=>{
                    sids.add(socket.id);
                });
                return Promise.resolve(sids);
            }
            socketRooms(id) {
                return this.sids.get(id);
            }
            fetchSockets(opts) {
                const sockets = [];
                this.apply(opts, (socket)=>{
                    sockets.push(socket);
                });
                return Promise.resolve(sockets);
            }
            addSockets(opts, rooms) {
                this.apply(opts, (socket)=>{
                    socket.join(rooms);
                });
            }
            delSockets(opts, rooms) {
                this.apply(opts, (socket)=>{
                    rooms.forEach((room)=>socket.leave(room));
                });
            }
            disconnectSockets(opts, close) {
                this.apply(opts, (socket)=>{
                    socket.disconnect(close);
                });
            }
            apply(opts, callback) {
                const rooms = opts.rooms;
                const except = this.computeExceptSids(opts.except);
                if (rooms.size) {
                    const ids = new Set();
                    for (const room of rooms)if (this.rooms.has(room)) for (const id of this.rooms.get(room)){
                        if (ids.has(id) || except.has(id)) continue;
                        const socket = this.nsp.sockets.get(id);
                        if (socket) {
                            callback(socket);
                            ids.add(id);
                        }
                    }
                } else for (const [id] of this.sids){
                    if (except.has(id)) continue;
                    const socket = this.nsp.sockets.get(id);
                    if (socket) callback(socket);
                }
            }
            computeExceptSids(exceptRooms) {
                const exceptSids = new Set();
                if (exceptRooms && exceptRooms.size > 0) {
                    for (const room of exceptRooms)if (this.rooms.has(room)) this.rooms.get(room).forEach((sid)=>exceptSids.add(sid));
                }
                return exceptSids;
            }
            serverSideEmit(packet) {
                console.warn("this adapter does not support the serverSideEmit() functionality");
            }
            persistSession(session) {}
            restoreSession(pid, offset) {
                return null;
            }
        }
        exports1.Adapter = Adapter;
        class SessionAwareAdapter extends Adapter {
            constructor(nsp){
                super(nsp);
                this.nsp = nsp;
                this.sessions = new Map();
                this.packets = [];
                this.maxDisconnectionDuration = nsp.server.opts.connectionStateRecovery.maxDisconnectionDuration;
                const timer = setInterval(()=>{
                    const threshold = Date.now() - this.maxDisconnectionDuration;
                    this.sessions.forEach((session, sessionId)=>{
                        const hasExpired = session.disconnectedAt < threshold;
                        if (hasExpired) this.sessions.delete(sessionId);
                    });
                    for(let i = this.packets.length - 1; i >= 0; i--){
                        const hasExpired = this.packets[i].emittedAt < threshold;
                        if (hasExpired) {
                            this.packets.splice(0, i + 1);
                            break;
                        }
                    }
                }, 60000);
                timer.unref();
            }
            persistSession(session) {
                session.disconnectedAt = Date.now();
                this.sessions.set(session.pid, session);
            }
            restoreSession(pid, offset) {
                const session = this.sessions.get(pid);
                if (!session) return null;
                const hasExpired = session.disconnectedAt + this.maxDisconnectionDuration < Date.now();
                if (hasExpired) {
                    this.sessions.delete(pid);
                    return null;
                }
                const index = this.packets.findIndex((packet)=>packet.id === offset);
                if (-1 === index) return null;
                const missedPackets = [];
                for(let i = index + 1; i < this.packets.length; i++){
                    const packet = this.packets[i];
                    if (shouldIncludePacket(session.rooms, packet.opts)) missedPackets.push(packet.data);
                }
                return Promise.resolve(Object.assign(Object.assign({}, session), {
                    missedPackets
                }));
            }
            broadcast(packet, opts) {
                var _a;
                const isEventPacket = 2 === packet.type;
                const withoutAcknowledgement = void 0 === packet.id;
                const notVolatile = (null == (_a = opts.flags) ? void 0 : _a.volatile) === void 0;
                if (isEventPacket && withoutAcknowledgement && notVolatile) {
                    const id = (0, yeast_1.yeast)();
                    packet.data.push(id);
                    this.packets.push({
                        id,
                        opts,
                        data: packet.data,
                        emittedAt: Date.now()
                    });
                }
                super.broadcast(packet, opts);
            }
        }
        exports1.SessionAwareAdapter = SessionAwareAdapter;
        function shouldIncludePacket(sessionRooms, opts) {
            const included = 0 === opts.rooms.size || sessionRooms.some((room)=>opts.rooms.has(room));
            const notExcluded = sessionRooms.every((room)=>!opts.except.has(room));
            return included && notExcluded;
        }
    },
    "../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.MessageType = exports1.ClusterAdapterWithHeartbeat = exports1.ClusterAdapter = exports1.SessionAwareAdapter = exports1.Adapter = void 0;
        var in_memory_adapter_1 = __webpack_require__("../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/in-memory-adapter.js");
        Object.defineProperty(exports1, "Adapter", {
            enumerable: true,
            get: function() {
                return in_memory_adapter_1.Adapter;
            }
        });
        Object.defineProperty(exports1, "SessionAwareAdapter", {
            enumerable: true,
            get: function() {
                return in_memory_adapter_1.SessionAwareAdapter;
            }
        });
        var cluster_adapter_1 = __webpack_require__("../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/cluster-adapter.js");
        Object.defineProperty(exports1, "ClusterAdapter", {
            enumerable: true,
            get: function() {
                return cluster_adapter_1.ClusterAdapter;
            }
        });
        Object.defineProperty(exports1, "ClusterAdapterWithHeartbeat", {
            enumerable: true,
            get: function() {
                return cluster_adapter_1.ClusterAdapterWithHeartbeat;
            }
        });
        Object.defineProperty(exports1, "MessageType", {
            enumerable: true,
            get: function() {
                return cluster_adapter_1.MessageType;
            }
        });
    },
    "../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var codes = __webpack_require__("../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/codes.json");
        module.exports = status;
        status.message = codes;
        status.code = createMessageToStatusCodeMap(codes);
        status.codes = createStatusCodeList(codes);
        status.redirect = {
            300: true,
            301: true,
            302: true,
            303: true,
            305: true,
            307: true,
            308: true
        };
        status.empty = {
            204: true,
            205: true,
            304: true
        };
        status.retry = {
            502: true,
            503: true,
            504: true
        };
        function createMessageToStatusCodeMap(codes) {
            var map = {};
            Object.keys(codes).forEach(function(code) {
                var message = codes[code];
                var status = Number(code);
                map[message.toLowerCase()] = status;
            });
            return map;
        }
        function createStatusCodeList(codes) {
            return Object.keys(codes).map(function(code) {
                return Number(code);
            });
        }
        function getStatusCode(message) {
            var msg = message.toLowerCase();
            if (!Object.prototype.hasOwnProperty.call(status.code, msg)) throw new Error('invalid status message: "' + message + '"');
            return status.code[msg];
        }
        function getStatusMessage(code) {
            if (!Object.prototype.hasOwnProperty.call(status.message, code)) throw new Error('invalid status code: ' + code);
            return status.message[code];
        }
        function status(code) {
            if ('number' == typeof code) return getStatusMessage(code);
            if ('string' != typeof code) throw new TypeError('code must be a number or string');
            var n = parseInt(code, 10);
            if (!isNaN(n)) return getStatusMessage(n);
            return getStatusCode(code);
        }
    },
    "../node_modules/.pnpm/supports-color@5.5.0/node_modules/supports-color/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const os = __webpack_require__("os");
        const hasFlag = __webpack_require__("../node_modules/.pnpm/has-flag@3.0.0/node_modules/has-flag/index.js");
        const env = process.env;
        let forceColor;
        if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) forceColor = false;
        else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) forceColor = true;
        if ('FORCE_COLOR' in env) forceColor = 0 === env.FORCE_COLOR.length || 0 !== parseInt(env.FORCE_COLOR, 10);
        function translateLevel(level) {
            if (0 === level) return false;
            return {
                level,
                hasBasic: true,
                has256: level >= 2,
                has16m: level >= 3
            };
        }
        function supportsColor(stream) {
            if (false === forceColor) return 0;
            if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) return 3;
            if (hasFlag('color=256')) return 2;
            if (stream && !stream.isTTY && true !== forceColor) return 0;
            const min = forceColor ? 1 : 0;
            if ('win32' === process.platform) {
                const osRelease = os.release().split('.');
                if (Number(process.versions.node.split('.')[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) return Number(osRelease[2]) >= 14931 ? 3 : 2;
                return 1;
            }
            if ('CI' in env) {
                if ([
                    'TRAVIS',
                    'CIRCLECI',
                    'APPVEYOR',
                    'GITLAB_CI'
                ].some((sign)=>sign in env) || 'codeship' === env.CI_NAME) return 1;
                return min;
            }
            if ('TEAMCITY_VERSION' in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
            if ('truecolor' === env.COLORTERM) return 3;
            if ('TERM_PROGRAM' in env) {
                const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
                switch(env.TERM_PROGRAM){
                    case 'iTerm.app':
                        return version >= 3 ? 3 : 2;
                    case 'Apple_Terminal':
                        return 2;
                }
            }
            if (/-256(color)?$/i.test(env.TERM)) return 2;
            if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) return 1;
            if ('COLORTERM' in env) return 1;
            env.TERM;
            return min;
        }
        function getSupportLevel(stream) {
            const level = supportsColor(stream);
            return translateLevel(level);
        }
        module.exports = {
            supportsColor: getSupportLevel,
            stdout: getSupportLevel(process.stdout),
            stderr: getSupportLevel(process.stderr)
        };
    },
    "../node_modules/.pnpm/toidentifier@1.0.1/node_modules/toidentifier/index.js": function(module) {
        "use strict";
        /*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = toIdentifier;
        function toIdentifier(str) {
            return str.split(' ').map(function(token) {
                return token.slice(0, 1).toUpperCase() + token.slice(1);
            }).join('').replace(/[^ _0-9a-z]/gi, '');
        }
    },
    "../node_modules/.pnpm/type-is@1.6.18/node_modules/type-is/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var typer = __webpack_require__("../node_modules/.pnpm/media-typer@0.3.0/node_modules/media-typer/index.js");
        var mime = __webpack_require__("../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js");
        module.exports = typeofrequest;
        module.exports.is = typeis;
        module.exports.hasBody = hasbody;
        module.exports.normalize = normalize;
        module.exports.match = mimeMatch;
        function typeis(value, types_) {
            var i;
            var types = types_;
            var val = tryNormalizeType(value);
            if (!val) return false;
            if (types && !Array.isArray(types)) {
                types = new Array(arguments.length - 1);
                for(i = 0; i < types.length; i++)types[i] = arguments[i + 1];
            }
            if (!types || !types.length) return val;
            var type;
            for(i = 0; i < types.length; i++)if (mimeMatch(normalize(type = types[i]), val)) return '+' === type[0] || -1 !== type.indexOf('*') ? val : type;
            return false;
        }
        function hasbody(req) {
            return void 0 !== req.headers['transfer-encoding'] || !isNaN(req.headers['content-length']);
        }
        function typeofrequest(req, types_) {
            var types = types_;
            if (!hasbody(req)) return null;
            if (arguments.length > 2) {
                types = new Array(arguments.length - 1);
                for(var i = 0; i < types.length; i++)types[i] = arguments[i + 1];
            }
            var value = req.headers['content-type'];
            return typeis(value, types);
        }
        function normalize(type) {
            if ('string' != typeof type) return false;
            switch(type){
                case 'urlencoded':
                    return 'application/x-www-form-urlencoded';
                case 'multipart':
                    return 'multipart/*';
            }
            if ('+' === type[0]) return '*/*' + type;
            return -1 === type.indexOf('/') ? mime.lookup(type) : type;
        }
        function mimeMatch(expected, actual) {
            if (false === expected) return false;
            var actualParts = actual.split('/');
            var expectedParts = expected.split('/');
            if (2 !== actualParts.length || 2 !== expectedParts.length) return false;
            if ('*' !== expectedParts[0] && expectedParts[0] !== actualParts[0]) return false;
            if ('*+' === expectedParts[1].substr(0, 2)) return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
            if ('*' !== expectedParts[1] && expectedParts[1] !== actualParts[1]) return false;
            return true;
        }
        function normalizeType(value) {
            var type = typer.parse(value);
            type.parameters = void 0;
            return typer.format(type);
        }
        function tryNormalizeType(value) {
            if (!value) return null;
            try {
                return normalizeType(value);
            } catch (err) {
                return null;
            }
        }
    },
    "../node_modules/.pnpm/unpipe@1.0.0/node_modules/unpipe/index.js": function(module) {
        "use strict";
        /*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = unpipe;
        function hasPipeDataListeners(stream) {
            var listeners = stream.listeners('data');
            for(var i = 0; i < listeners.length; i++)if ('ondata' === listeners[i].name) return true;
            return false;
        }
        function unpipe(stream) {
            if (!stream) throw new TypeError('argument stream is required');
            if ('function' == typeof stream.unpipe) return void stream.unpipe();
            if (!hasPipeDataListeners(stream)) return;
            var listener;
            var listeners = stream.listeners('close');
            for(var i = 0; i < listeners.length; i++){
                listener = listeners[i];
                if ('cleanup' === listener.name || 'onclose' === listener.name) listener.call(stream);
            }
        }
    },
    "../node_modules/.pnpm/utils-merge@1.0.1/node_modules/utils-merge/index.js": function(module, exports1) {
        module.exports = function(a, b) {
            if (a && b) for(var key in b)a[key] = b[key];
            return a;
        };
    },
    "../node_modules/.pnpm/vary@1.1.2/node_modules/vary/index.js": function(module) {
        "use strict";
        /*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = vary;
        module.exports.append = append;
        var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
        function append(header, field) {
            if ('string' != typeof header) throw new TypeError('header argument is required');
            if (!field) throw new TypeError('field argument is required');
            var fields = Array.isArray(field) ? field : parse(String(field));
            for(var j = 0; j < fields.length; j++)if (!FIELD_NAME_REGEXP.test(fields[j])) throw new TypeError('field argument contains an invalid header name');
            if ('*' === header) return header;
            var val = header;
            var vals = parse(header.toLowerCase());
            if (-1 !== fields.indexOf('*') || -1 !== vals.indexOf('*')) return '*';
            for(var i = 0; i < fields.length; i++){
                var fld = fields[i].toLowerCase();
                if (-1 === vals.indexOf(fld)) {
                    vals.push(fld);
                    val = val ? val + ', ' + fields[i] : fields[i];
                }
            }
            return val;
        }
        function parse(header) {
            var end = 0;
            var list = [];
            var start = 0;
            for(var i = 0, len = header.length; i < len; i++)switch(header.charCodeAt(i)){
                case 0x20:
                    if (start === end) start = end = i + 1;
                    break;
                case 0x2c:
                    list.push(header.substring(start, end));
                    start = end = i + 1;
                    break;
                default:
                    end = i + 1;
                    break;
            }
            list.push(header.substring(start, end));
            return list;
        }
        function vary(res, field) {
            if (!res || !res.getHeader || !res.setHeader) throw new TypeError('res argument is required');
            var val = res.getHeader('Vary') || '';
            var header = Array.isArray(val) ? val.join(', ') : String(val);
            if (val = append(header, field)) res.setHeader('Vary', val);
        }
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const WebSocket = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/websocket.js");
        WebSocket.createWebSocketStream = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/stream.js");
        WebSocket.Server = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/websocket-server.js");
        WebSocket.Receiver = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/receiver.js");
        WebSocket.Sender = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/sender.js");
        WebSocket.WebSocket = WebSocket;
        WebSocket.WebSocketServer = WebSocket.Server;
        module.exports = WebSocket;
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/buffer-util.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const { EMPTY_BUFFER } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/constants.js");
        const FastBuffer = Buffer[Symbol.species];
        function concat(list, totalLength) {
            if (0 === list.length) return EMPTY_BUFFER;
            if (1 === list.length) return list[0];
            const target = Buffer.allocUnsafe(totalLength);
            let offset = 0;
            for(let i = 0; i < list.length; i++){
                const buf = list[i];
                target.set(buf, offset);
                offset += buf.length;
            }
            if (offset < totalLength) return new FastBuffer(target.buffer, target.byteOffset, offset);
            return target;
        }
        function _mask(source, mask, output, offset, length) {
            for(let i = 0; i < length; i++)output[offset + i] = source[i] ^ mask[3 & i];
        }
        function _unmask(buffer, mask) {
            for(let i = 0; i < buffer.length; i++)buffer[i] ^= mask[3 & i];
        }
        function toArrayBuffer(buf) {
            if (buf.length === buf.buffer.byteLength) return buf.buffer;
            return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
        }
        function toBuffer(data) {
            toBuffer.readOnly = true;
            if (Buffer.isBuffer(data)) return data;
            let buf;
            if (data instanceof ArrayBuffer) buf = new FastBuffer(data);
            else if (ArrayBuffer.isView(data)) buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
            else {
                buf = Buffer.from(data);
                toBuffer.readOnly = false;
            }
            return buf;
        }
        module.exports = {
            concat,
            mask: _mask,
            toArrayBuffer,
            toBuffer,
            unmask: _unmask
        };
        if (!process.env.WS_NO_BUFFER_UTIL) try {
            const bufferUtil = __webpack_require__("../../node_modules/bufferutil/index.js");
            module.exports.mask = function(source, mask, output, offset, length) {
                if (length < 48) _mask(source, mask, output, offset, length);
                else bufferUtil.mask(source, mask, output, offset, length);
            };
            module.exports.unmask = function(buffer, mask) {
                if (buffer.length < 32) _unmask(buffer, mask);
                else bufferUtil.unmask(buffer, mask);
            };
        } catch (e) {}
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/constants.js": function(module) {
        "use strict";
        module.exports = {
            BINARY_TYPES: [
                'nodebuffer',
                'arraybuffer',
                'fragments'
            ],
            EMPTY_BUFFER: Buffer.alloc(0),
            GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
            kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
            kListener: Symbol('kListener'),
            kStatusCode: Symbol('status-code'),
            kWebSocket: Symbol('websocket'),
            NOOP: ()=>{}
        };
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/event-target.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const { kForOnEventAttribute, kListener } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/constants.js");
        const kCode = Symbol('kCode');
        const kData = Symbol('kData');
        const kError = Symbol('kError');
        const kMessage = Symbol('kMessage');
        const kReason = Symbol('kReason');
        const kTarget = Symbol('kTarget');
        const kType = Symbol('kType');
        const kWasClean = Symbol('kWasClean');
        class Event {
            constructor(type){
                this[kTarget] = null;
                this[kType] = type;
            }
            get target() {
                return this[kTarget];
            }
            get type() {
                return this[kType];
            }
        }
        Object.defineProperty(Event.prototype, 'target', {
            enumerable: true
        });
        Object.defineProperty(Event.prototype, 'type', {
            enumerable: true
        });
        class CloseEvent extends Event {
            constructor(type, options = {}){
                super(type);
                this[kCode] = void 0 === options.code ? 0 : options.code;
                this[kReason] = void 0 === options.reason ? '' : options.reason;
                this[kWasClean] = void 0 === options.wasClean ? false : options.wasClean;
            }
            get code() {
                return this[kCode];
            }
            get reason() {
                return this[kReason];
            }
            get wasClean() {
                return this[kWasClean];
            }
        }
        Object.defineProperty(CloseEvent.prototype, 'code', {
            enumerable: true
        });
        Object.defineProperty(CloseEvent.prototype, 'reason', {
            enumerable: true
        });
        Object.defineProperty(CloseEvent.prototype, 'wasClean', {
            enumerable: true
        });
        class ErrorEvent extends Event {
            constructor(type, options = {}){
                super(type);
                this[kError] = void 0 === options.error ? null : options.error;
                this[kMessage] = void 0 === options.message ? '' : options.message;
            }
            get error() {
                return this[kError];
            }
            get message() {
                return this[kMessage];
            }
        }
        Object.defineProperty(ErrorEvent.prototype, 'error', {
            enumerable: true
        });
        Object.defineProperty(ErrorEvent.prototype, 'message', {
            enumerable: true
        });
        class MessageEvent extends Event {
            constructor(type, options = {}){
                super(type);
                this[kData] = void 0 === options.data ? null : options.data;
            }
            get data() {
                return this[kData];
            }
        }
        Object.defineProperty(MessageEvent.prototype, 'data', {
            enumerable: true
        });
        const EventTarget = {
            addEventListener (type, handler, options = {}) {
                for (const listener of this.listeners(type))if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) return;
                let wrapper;
                if ('message' === type) wrapper = function(data, isBinary) {
                    const event = new MessageEvent('message', {
                        data: isBinary ? data : data.toString()
                    });
                    event[kTarget] = this;
                    callListener(handler, this, event);
                };
                else if ('close' === type) wrapper = function(code, message) {
                    const event = new CloseEvent('close', {
                        code,
                        reason: message.toString(),
                        wasClean: this._closeFrameReceived && this._closeFrameSent
                    });
                    event[kTarget] = this;
                    callListener(handler, this, event);
                };
                else if ('error' === type) wrapper = function(error) {
                    const event = new ErrorEvent('error', {
                        error,
                        message: error.message
                    });
                    event[kTarget] = this;
                    callListener(handler, this, event);
                };
                else {
                    if ('open' !== type) return;
                    wrapper = function() {
                        const event = new Event('open');
                        event[kTarget] = this;
                        callListener(handler, this, event);
                    };
                }
                wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
                wrapper[kListener] = handler;
                if (options.once) this.once(type, wrapper);
                else this.on(type, wrapper);
            },
            removeEventListener (type, handler) {
                for (const listener of this.listeners(type))if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
                    this.removeListener(type, listener);
                    break;
                }
            }
        };
        module.exports = {
            CloseEvent,
            ErrorEvent,
            Event,
            EventTarget,
            MessageEvent
        };
        function callListener(listener, thisArg, event) {
            if ('object' == typeof listener && listener.handleEvent) listener.handleEvent.call(listener, event);
            else listener.call(thisArg, event);
        }
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/extension.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const { tokenChars } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/validation.js");
        function push(dest, name, elem) {
            if (void 0 === dest[name]) dest[name] = [
                elem
            ];
            else dest[name].push(elem);
        }
        function parse(header) {
            const offers = Object.create(null);
            let params = Object.create(null);
            let mustUnescape = false;
            let isEscaping = false;
            let inQuotes = false;
            let extensionName;
            let paramName;
            let start = -1;
            let code = -1;
            let end = -1;
            let i = 0;
            for(; i < header.length; i++){
                code = header.charCodeAt(i);
                if (void 0 === extensionName) if (-1 === end && 1 === tokenChars[code]) {
                    if (-1 === start) start = i;
                } else if (0 !== i && (0x20 === code || 0x09 === code)) {
                    if (-1 === end && -1 !== start) end = i;
                } else if (0x3b === code || 0x2c === code) {
                    if (-1 === start) throw new SyntaxError(`Unexpected character at index ${i}`);
                    if (-1 === end) end = i;
                    const name = header.slice(start, end);
                    if (0x2c === code) {
                        push(offers, name, params);
                        params = Object.create(null);
                    } else extensionName = name;
                    start = end = -1;
                } else throw new SyntaxError(`Unexpected character at index ${i}`);
                else if (void 0 === paramName) if (-1 === end && 1 === tokenChars[code]) {
                    if (-1 === start) start = i;
                } else if (0x20 === code || 0x09 === code) {
                    if (-1 === end && -1 !== start) end = i;
                } else if (0x3b === code || 0x2c === code) {
                    if (-1 === start) throw new SyntaxError(`Unexpected character at index ${i}`);
                    if (-1 === end) end = i;
                    push(params, header.slice(start, end), true);
                    if (0x2c === code) {
                        push(offers, extensionName, params);
                        params = Object.create(null);
                        extensionName = void 0;
                    }
                    start = end = -1;
                } else if (0x3d === code && -1 !== start && -1 === end) {
                    paramName = header.slice(start, i);
                    start = end = -1;
                } else throw new SyntaxError(`Unexpected character at index ${i}`);
                else if (isEscaping) {
                    if (1 !== tokenChars[code]) throw new SyntaxError(`Unexpected character at index ${i}`);
                    if (-1 === start) start = i;
                    else if (!mustUnescape) mustUnescape = true;
                    isEscaping = false;
                } else if (inQuotes) if (1 === tokenChars[code]) {
                    if (-1 === start) start = i;
                } else if (0x22 === code && -1 !== start) {
                    inQuotes = false;
                    end = i;
                } else if (0x5c === code) isEscaping = true;
                else throw new SyntaxError(`Unexpected character at index ${i}`);
                else if (0x22 === code && 0x3d === header.charCodeAt(i - 1)) inQuotes = true;
                else if (-1 === end && 1 === tokenChars[code]) {
                    if (-1 === start) start = i;
                } else if (-1 !== start && (0x20 === code || 0x09 === code)) {
                    if (-1 === end) end = i;
                } else if (0x3b === code || 0x2c === code) {
                    if (-1 === start) throw new SyntaxError(`Unexpected character at index ${i}`);
                    if (-1 === end) end = i;
                    let value = header.slice(start, end);
                    if (mustUnescape) {
                        value = value.replace(/\\/g, '');
                        mustUnescape = false;
                    }
                    push(params, paramName, value);
                    if (0x2c === code) {
                        push(offers, extensionName, params);
                        params = Object.create(null);
                        extensionName = void 0;
                    }
                    paramName = void 0;
                    start = end = -1;
                } else throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (-1 === start || inQuotes || 0x20 === code || 0x09 === code) throw new SyntaxError('Unexpected end of input');
            if (-1 === end) end = i;
            const token = header.slice(start, end);
            if (void 0 === extensionName) push(offers, token, params);
            else {
                if (void 0 === paramName) push(params, token, true);
                else mustUnescape ? push(params, paramName, token.replace(/\\/g, '')) : push(params, paramName, token);
                push(offers, extensionName, params);
            }
            return offers;
        }
        function format(extensions) {
            return Object.keys(extensions).map((extension)=>{
                let configurations = extensions[extension];
                if (!Array.isArray(configurations)) configurations = [
                    configurations
                ];
                return configurations.map((params)=>[
                        extension
                    ].concat(Object.keys(params).map((k)=>{
                        let values = params[k];
                        if (!Array.isArray(values)) values = [
                            values
                        ];
                        return values.map((v)=>true === v ? k : `${k}=${v}`).join('; ');
                    })).join('; ')).join(', ');
            }).join(', ');
        }
        module.exports = {
            format,
            parse
        };
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/limiter.js": function(module) {
        "use strict";
        const kDone = Symbol('kDone');
        const kRun = Symbol('kRun');
        class Limiter {
            constructor(concurrency){
                this[kDone] = ()=>{
                    this.pending--;
                    this[kRun]();
                };
                this.concurrency = concurrency || 1 / 0;
                this.jobs = [];
                this.pending = 0;
            }
            add(job) {
                this.jobs.push(job);
                this[kRun]();
            }
            [kRun]() {
                if (this.pending === this.concurrency) return;
                if (this.jobs.length) {
                    const job = this.jobs.shift();
                    this.pending++;
                    job(this[kDone]);
                }
            }
        }
        module.exports = Limiter;
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/permessage-deflate.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const zlib = __webpack_require__("zlib");
        const bufferUtil = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/buffer-util.js");
        const Limiter = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/limiter.js");
        const { kStatusCode } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/constants.js");
        const FastBuffer = Buffer[Symbol.species];
        const TRAILER = Buffer.from([
            0x00,
            0x00,
            0xff,
            0xff
        ]);
        const kPerMessageDeflate = Symbol('permessage-deflate');
        const kTotalLength = Symbol('total-length');
        const kCallback = Symbol('callback');
        const kBuffers = Symbol('buffers');
        const kError = Symbol('error');
        let zlibLimiter;
        class PerMessageDeflate {
            constructor(options, isServer, maxPayload){
                this._maxPayload = 0 | maxPayload;
                this._options = options || {};
                this._threshold = void 0 !== this._options.threshold ? this._options.threshold : 1024;
                this._isServer = !!isServer;
                this._deflate = null;
                this._inflate = null;
                this.params = null;
                if (!zlibLimiter) {
                    const concurrency = void 0 !== this._options.concurrencyLimit ? this._options.concurrencyLimit : 10;
                    zlibLimiter = new Limiter(concurrency);
                }
            }
            static get extensionName() {
                return 'permessage-deflate';
            }
            offer() {
                const params = {};
                if (this._options.serverNoContextTakeover) params.server_no_context_takeover = true;
                if (this._options.clientNoContextTakeover) params.client_no_context_takeover = true;
                if (this._options.serverMaxWindowBits) params.server_max_window_bits = this._options.serverMaxWindowBits;
                if (this._options.clientMaxWindowBits) params.client_max_window_bits = this._options.clientMaxWindowBits;
                else if (null == this._options.clientMaxWindowBits) params.client_max_window_bits = true;
                return params;
            }
            accept(configurations) {
                configurations = this.normalizeParams(configurations);
                this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
                return this.params;
            }
            cleanup() {
                if (this._inflate) {
                    this._inflate.close();
                    this._inflate = null;
                }
                if (this._deflate) {
                    const callback = this._deflate[kCallback];
                    this._deflate.close();
                    this._deflate = null;
                    if (callback) callback(new Error('The deflate stream was closed while data was being processed'));
                }
            }
            acceptAsServer(offers) {
                const opts = this._options;
                const accepted = offers.find((params)=>{
                    if (false === opts.serverNoContextTakeover && params.server_no_context_takeover || params.server_max_window_bits && (false === opts.serverMaxWindowBits || 'number' == typeof opts.serverMaxWindowBits && opts.serverMaxWindowBits > params.server_max_window_bits) || 'number' == typeof opts.clientMaxWindowBits && !params.client_max_window_bits) return false;
                    return true;
                });
                if (!accepted) throw new Error('None of the extension offers can be accepted');
                if (opts.serverNoContextTakeover) accepted.server_no_context_takeover = true;
                if (opts.clientNoContextTakeover) accepted.client_no_context_takeover = true;
                if ('number' == typeof opts.serverMaxWindowBits) accepted.server_max_window_bits = opts.serverMaxWindowBits;
                if ('number' == typeof opts.clientMaxWindowBits) accepted.client_max_window_bits = opts.clientMaxWindowBits;
                else if (true === accepted.client_max_window_bits || false === opts.clientMaxWindowBits) delete accepted.client_max_window_bits;
                return accepted;
            }
            acceptAsClient(response) {
                const params = response[0];
                if (false === this._options.clientNoContextTakeover && params.client_no_context_takeover) throw new Error('Unexpected parameter "client_no_context_takeover"');
                if (params.client_max_window_bits) {
                    if (false === this._options.clientMaxWindowBits || 'number' == typeof this._options.clientMaxWindowBits && params.client_max_window_bits > this._options.clientMaxWindowBits) throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
                } else if ('number' == typeof this._options.clientMaxWindowBits) params.client_max_window_bits = this._options.clientMaxWindowBits;
                return params;
            }
            normalizeParams(configurations) {
                configurations.forEach((params)=>{
                    Object.keys(params).forEach((key)=>{
                        let value = params[key];
                        if (value.length > 1) throw new Error(`Parameter "${key}" must have only a single value`);
                        value = value[0];
                        if ('client_max_window_bits' === key) {
                            if (true !== value) {
                                const num = +value;
                                if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                                value = num;
                            } else if (!this._isServer) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                        } else if ('server_max_window_bits' === key) {
                            const num = +value;
                            if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                            value = num;
                        } else if ('client_no_context_takeover' === key || 'server_no_context_takeover' === key) {
                            if (true !== value) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                        } else throw new Error(`Unknown parameter "${key}"`);
                        params[key] = value;
                    });
                });
                return configurations;
            }
            decompress(data, fin, callback) {
                zlibLimiter.add((done)=>{
                    this._decompress(data, fin, (err, result)=>{
                        done();
                        callback(err, result);
                    });
                });
            }
            compress(data, fin, callback) {
                zlibLimiter.add((done)=>{
                    this._compress(data, fin, (err, result)=>{
                        done();
                        callback(err, result);
                    });
                });
            }
            _decompress(data, fin, callback) {
                const endpoint = this._isServer ? 'client' : 'server';
                if (!this._inflate) {
                    const key = `${endpoint}_max_window_bits`;
                    const windowBits = 'number' != typeof this.params[key] ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
                    this._inflate = zlib.createInflateRaw({
                        ...this._options.zlibInflateOptions,
                        windowBits
                    });
                    this._inflate[kPerMessageDeflate] = this;
                    this._inflate[kTotalLength] = 0;
                    this._inflate[kBuffers] = [];
                    this._inflate.on('error', inflateOnError);
                    this._inflate.on('data', inflateOnData);
                }
                this._inflate[kCallback] = callback;
                this._inflate.write(data);
                if (fin) this._inflate.write(TRAILER);
                this._inflate.flush(()=>{
                    const err = this._inflate[kError];
                    if (err) {
                        this._inflate.close();
                        this._inflate = null;
                        callback(err);
                        return;
                    }
                    const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
                    if (this._inflate._readableState.endEmitted) {
                        this._inflate.close();
                        this._inflate = null;
                    } else {
                        this._inflate[kTotalLength] = 0;
                        this._inflate[kBuffers] = [];
                        if (fin && this.params[`${endpoint}_no_context_takeover`]) this._inflate.reset();
                    }
                    callback(null, data);
                });
            }
            _compress(data, fin, callback) {
                const endpoint = this._isServer ? 'server' : 'client';
                if (!this._deflate) {
                    const key = `${endpoint}_max_window_bits`;
                    const windowBits = 'number' != typeof this.params[key] ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
                    this._deflate = zlib.createDeflateRaw({
                        ...this._options.zlibDeflateOptions,
                        windowBits
                    });
                    this._deflate[kTotalLength] = 0;
                    this._deflate[kBuffers] = [];
                    this._deflate.on('data', deflateOnData);
                }
                this._deflate[kCallback] = callback;
                this._deflate.write(data);
                this._deflate.flush(zlib.Z_SYNC_FLUSH, ()=>{
                    if (!this._deflate) return;
                    let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
                    if (fin) data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
                    this._deflate[kCallback] = null;
                    this._deflate[kTotalLength] = 0;
                    this._deflate[kBuffers] = [];
                    if (fin && this.params[`${endpoint}_no_context_takeover`]) this._deflate.reset();
                    callback(null, data);
                });
            }
        }
        module.exports = PerMessageDeflate;
        function deflateOnData(chunk) {
            this[kBuffers].push(chunk);
            this[kTotalLength] += chunk.length;
        }
        function inflateOnData(chunk) {
            this[kTotalLength] += chunk.length;
            if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) return void this[kBuffers].push(chunk);
            this[kError] = new RangeError('Max payload size exceeded');
            this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
            this[kError][kStatusCode] = 1009;
            this.removeListener('data', inflateOnData);
            this.reset();
        }
        function inflateOnError(err) {
            this[kPerMessageDeflate]._inflate = null;
            err[kStatusCode] = 1007;
            this[kCallback](err);
        }
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/receiver.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const { Writable } = __webpack_require__("stream");
        const PerMessageDeflate = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/permessage-deflate.js");
        const { BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/constants.js");
        const { concat, toArrayBuffer, unmask } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/buffer-util.js");
        const { isValidStatusCode, isValidUTF8 } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/validation.js");
        const FastBuffer = Buffer[Symbol.species];
        const GET_INFO = 0;
        const GET_PAYLOAD_LENGTH_16 = 1;
        const GET_PAYLOAD_LENGTH_64 = 2;
        const GET_MASK = 3;
        const GET_DATA = 4;
        const INFLATING = 5;
        const DEFER_EVENT = 6;
        class Receiver extends Writable {
            constructor(options = {}){
                super();
                this._allowSynchronousEvents = void 0 !== options.allowSynchronousEvents ? options.allowSynchronousEvents : true;
                this._binaryType = options.binaryType || BINARY_TYPES[0];
                this._extensions = options.extensions || {};
                this._isServer = !!options.isServer;
                this._maxPayload = 0 | options.maxPayload;
                this._skipUTF8Validation = !!options.skipUTF8Validation;
                this[kWebSocket] = void 0;
                this._bufferedBytes = 0;
                this._buffers = [];
                this._compressed = false;
                this._payloadLength = 0;
                this._mask = void 0;
                this._fragmented = 0;
                this._masked = false;
                this._fin = false;
                this._opcode = 0;
                this._totalPayloadLength = 0;
                this._messageLength = 0;
                this._fragments = [];
                this._errored = false;
                this._loop = false;
                this._state = GET_INFO;
            }
            _write(chunk, encoding, cb) {
                if (0x08 === this._opcode && this._state == GET_INFO) return cb();
                this._bufferedBytes += chunk.length;
                this._buffers.push(chunk);
                this.startLoop(cb);
            }
            consume(n) {
                this._bufferedBytes -= n;
                if (n === this._buffers[0].length) return this._buffers.shift();
                if (n < this._buffers[0].length) {
                    const buf = this._buffers[0];
                    this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
                    return new FastBuffer(buf.buffer, buf.byteOffset, n);
                }
                const dst = Buffer.allocUnsafe(n);
                do {
                    const buf = this._buffers[0];
                    const offset = dst.length - n;
                    if (n >= buf.length) dst.set(this._buffers.shift(), offset);
                    else {
                        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
                        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
                    }
                    n -= buf.length;
                }while (n > 0);
                return dst;
            }
            startLoop(cb) {
                this._loop = true;
                do switch(this._state){
                    case GET_INFO:
                        this.getInfo(cb);
                        break;
                    case GET_PAYLOAD_LENGTH_16:
                        this.getPayloadLength16(cb);
                        break;
                    case GET_PAYLOAD_LENGTH_64:
                        this.getPayloadLength64(cb);
                        break;
                    case GET_MASK:
                        this.getMask();
                        break;
                    case GET_DATA:
                        this.getData(cb);
                        break;
                    case INFLATING:
                    case DEFER_EVENT:
                        this._loop = false;
                        return;
                }
                while (this._loop);
                if (!this._errored) cb();
            }
            getInfo(cb) {
                if (this._bufferedBytes < 2) {
                    this._loop = false;
                    return;
                }
                const buf = this.consume(2);
                if ((0x30 & buf[0]) !== 0x00) {
                    const error = this.createError(RangeError, 'RSV2 and RSV3 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_2_3');
                    cb(error);
                    return;
                }
                const compressed = (0x40 & buf[0]) === 0x40;
                if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
                    const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
                    cb(error);
                    return;
                }
                this._fin = (0x80 & buf[0]) === 0x80;
                this._opcode = 0x0f & buf[0];
                this._payloadLength = 0x7f & buf[1];
                if (0x00 === this._opcode) {
                    if (compressed) {
                        const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
                        cb(error);
                        return;
                    }
                    if (!this._fragmented) {
                        const error = this.createError(RangeError, 'invalid opcode 0', true, 1002, 'WS_ERR_INVALID_OPCODE');
                        cb(error);
                        return;
                    }
                    this._opcode = this._fragmented;
                } else if (0x01 === this._opcode || 0x02 === this._opcode) {
                    if (this._fragmented) {
                        const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');
                        cb(error);
                        return;
                    }
                    this._compressed = compressed;
                } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
                    if (!this._fin) {
                        const error = this.createError(RangeError, 'FIN must be set', true, 1002, 'WS_ERR_EXPECTED_FIN');
                        cb(error);
                        return;
                    }
                    if (compressed) {
                        const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
                        cb(error);
                        return;
                    }
                    if (this._payloadLength > 0x7d || 0x08 === this._opcode && 1 === this._payloadLength) {
                        const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');
                        cb(error);
                        return;
                    }
                } else {
                    const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');
                    cb(error);
                    return;
                }
                if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
                this._masked = (0x80 & buf[1]) === 0x80;
                if (this._isServer) {
                    if (!this._masked) {
                        const error = this.createError(RangeError, 'MASK must be set', true, 1002, 'WS_ERR_EXPECTED_MASK');
                        cb(error);
                        return;
                    }
                } else if (this._masked) {
                    const error = this.createError(RangeError, 'MASK must be clear', true, 1002, 'WS_ERR_UNEXPECTED_MASK');
                    cb(error);
                    return;
                }
                if (126 === this._payloadLength) this._state = GET_PAYLOAD_LENGTH_16;
                else if (127 === this._payloadLength) this._state = GET_PAYLOAD_LENGTH_64;
                else this.haveLength(cb);
            }
            getPayloadLength16(cb) {
                if (this._bufferedBytes < 2) {
                    this._loop = false;
                    return;
                }
                this._payloadLength = this.consume(2).readUInt16BE(0);
                this.haveLength(cb);
            }
            getPayloadLength64(cb) {
                if (this._bufferedBytes < 8) {
                    this._loop = false;
                    return;
                }
                const buf = this.consume(8);
                const num = buf.readUInt32BE(0);
                if (num > Math.pow(2, 21) - 1) {
                    const error = this.createError(RangeError, 'Unsupported WebSocket frame: payload length > 2^53 - 1', false, 1009, 'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH');
                    cb(error);
                    return;
                }
                this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
                this.haveLength(cb);
            }
            haveLength(cb) {
                if (this._payloadLength && this._opcode < 0x08) {
                    this._totalPayloadLength += this._payloadLength;
                    if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
                        const error = this.createError(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');
                        cb(error);
                        return;
                    }
                }
                if (this._masked) this._state = GET_MASK;
                else this._state = GET_DATA;
            }
            getMask() {
                if (this._bufferedBytes < 4) {
                    this._loop = false;
                    return;
                }
                this._mask = this.consume(4);
                this._state = GET_DATA;
            }
            getData(cb) {
                let data = EMPTY_BUFFER;
                if (this._payloadLength) {
                    if (this._bufferedBytes < this._payloadLength) {
                        this._loop = false;
                        return;
                    }
                    data = this.consume(this._payloadLength);
                    if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) unmask(data, this._mask);
                }
                if (this._opcode > 0x07) return void this.controlMessage(data, cb);
                if (this._compressed) {
                    this._state = INFLATING;
                    this.decompress(data, cb);
                    return;
                }
                if (data.length) {
                    this._messageLength = this._totalPayloadLength;
                    this._fragments.push(data);
                }
                this.dataMessage(cb);
            }
            decompress(data, cb) {
                const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
                perMessageDeflate.decompress(data, this._fin, (err, buf)=>{
                    if (err) return cb(err);
                    if (buf.length) {
                        this._messageLength += buf.length;
                        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
                            const error = this.createError(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');
                            cb(error);
                            return;
                        }
                        this._fragments.push(buf);
                    }
                    this.dataMessage(cb);
                    if (this._state === GET_INFO) this.startLoop(cb);
                });
            }
            dataMessage(cb) {
                if (!this._fin) {
                    this._state = GET_INFO;
                    return;
                }
                const messageLength = this._messageLength;
                const fragments = this._fragments;
                this._totalPayloadLength = 0;
                this._messageLength = 0;
                this._fragmented = 0;
                this._fragments = [];
                if (2 === this._opcode) {
                    let data;
                    data = 'nodebuffer' === this._binaryType ? concat(fragments, messageLength) : 'arraybuffer' === this._binaryType ? toArrayBuffer(concat(fragments, messageLength)) : fragments;
                    if (this._allowSynchronousEvents) {
                        this.emit('message', data, true);
                        this._state = GET_INFO;
                    } else {
                        this._state = DEFER_EVENT;
                        setImmediate(()=>{
                            this.emit('message', data, true);
                            this._state = GET_INFO;
                            this.startLoop(cb);
                        });
                    }
                } else {
                    const buf = concat(fragments, messageLength);
                    if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
                        const error = this.createError(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');
                        cb(error);
                        return;
                    }
                    if (this._state === INFLATING || this._allowSynchronousEvents) {
                        this.emit('message', buf, false);
                        this._state = GET_INFO;
                    } else {
                        this._state = DEFER_EVENT;
                        setImmediate(()=>{
                            this.emit('message', buf, false);
                            this._state = GET_INFO;
                            this.startLoop(cb);
                        });
                    }
                }
            }
            controlMessage(data, cb) {
                if (0x08 === this._opcode) {
                    if (0 === data.length) {
                        this._loop = false;
                        this.emit('conclude', 1005, EMPTY_BUFFER);
                        this.end();
                    } else {
                        const code = data.readUInt16BE(0);
                        if (!isValidStatusCode(code)) {
                            const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, 'WS_ERR_INVALID_CLOSE_CODE');
                            cb(error);
                            return;
                        }
                        const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
                        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
                            const error = this.createError(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');
                            cb(error);
                            return;
                        }
                        this._loop = false;
                        this.emit('conclude', code, buf);
                        this.end();
                    }
                    this._state = GET_INFO;
                    return;
                }
                if (this._allowSynchronousEvents) {
                    this.emit(0x09 === this._opcode ? 'ping' : 'pong', data);
                    this._state = GET_INFO;
                } else {
                    this._state = DEFER_EVENT;
                    setImmediate(()=>{
                        this.emit(0x09 === this._opcode ? 'ping' : 'pong', data);
                        this._state = GET_INFO;
                        this.startLoop(cb);
                    });
                }
            }
            createError(ErrorCtor, message, prefix, statusCode, errorCode) {
                this._loop = false;
                this._errored = true;
                const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
                Error.captureStackTrace(err, this.createError);
                err.code = errorCode;
                err[kStatusCode] = statusCode;
                return err;
            }
        }
        module.exports = Receiver;
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/sender.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const { Duplex } = __webpack_require__("stream");
        const { randomFillSync } = __webpack_require__("crypto");
        const PerMessageDeflate = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/permessage-deflate.js");
        const { EMPTY_BUFFER } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/constants.js");
        const { isValidStatusCode } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/validation.js");
        const { mask: applyMask, toBuffer } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/buffer-util.js");
        const kByteLength = Symbol('kByteLength');
        const maskBuffer = Buffer.alloc(4);
        const RANDOM_POOL_SIZE = 8192;
        let randomPool;
        let randomPoolPointer = RANDOM_POOL_SIZE;
        class Sender {
            constructor(socket, extensions, generateMask){
                this._extensions = extensions || {};
                if (generateMask) {
                    this._generateMask = generateMask;
                    this._maskBuffer = Buffer.alloc(4);
                }
                this._socket = socket;
                this._firstFragment = true;
                this._compress = false;
                this._bufferedBytes = 0;
                this._deflating = false;
                this._queue = [];
            }
            static frame(data, options) {
                let mask;
                let merge = false;
                let offset = 2;
                let skipMasking = false;
                if (options.mask) {
                    mask = options.maskBuffer || maskBuffer;
                    if (options.generateMask) options.generateMask(mask);
                    else {
                        if (randomPoolPointer === RANDOM_POOL_SIZE) {
                            if (void 0 === randomPool) randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
                            randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
                            randomPoolPointer = 0;
                        }
                        mask[0] = randomPool[randomPoolPointer++];
                        mask[1] = randomPool[randomPoolPointer++];
                        mask[2] = randomPool[randomPoolPointer++];
                        mask[3] = randomPool[randomPoolPointer++];
                    }
                    skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
                    offset = 6;
                }
                let dataLength;
                if ('string' == typeof data) if ((!options.mask || skipMasking) && void 0 !== options[kByteLength]) dataLength = options[kByteLength];
                else {
                    data = Buffer.from(data);
                    dataLength = data.length;
                }
                else {
                    dataLength = data.length;
                    merge = options.mask && options.readOnly && !skipMasking;
                }
                let payloadLength = dataLength;
                if (dataLength >= 65536) {
                    offset += 8;
                    payloadLength = 127;
                } else if (dataLength > 125) {
                    offset += 2;
                    payloadLength = 126;
                }
                const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
                target[0] = options.fin ? 0x80 | options.opcode : options.opcode;
                if (options.rsv1) target[0] |= 0x40;
                target[1] = payloadLength;
                if (126 === payloadLength) target.writeUInt16BE(dataLength, 2);
                else if (127 === payloadLength) {
                    target[2] = target[3] = 0;
                    target.writeUIntBE(dataLength, 4, 6);
                }
                if (!options.mask) return [
                    target,
                    data
                ];
                target[1] |= 0x80;
                target[offset - 4] = mask[0];
                target[offset - 3] = mask[1];
                target[offset - 2] = mask[2];
                target[offset - 1] = mask[3];
                if (skipMasking) return [
                    target,
                    data
                ];
                if (merge) {
                    applyMask(data, mask, target, offset, dataLength);
                    return [
                        target
                    ];
                }
                applyMask(data, mask, data, 0, dataLength);
                return [
                    target,
                    data
                ];
            }
            close(code, data, mask, cb) {
                let buf;
                if (void 0 === code) buf = EMPTY_BUFFER;
                else if ('number' == typeof code && isValidStatusCode(code)) if (void 0 !== data && data.length) {
                    const length = Buffer.byteLength(data);
                    if (length > 123) throw new RangeError('The message must not be greater than 123 bytes');
                    buf = Buffer.allocUnsafe(2 + length);
                    buf.writeUInt16BE(code, 0);
                    if ('string' == typeof data) buf.write(data, 2);
                    else buf.set(data, 2);
                } else {
                    buf = Buffer.allocUnsafe(2);
                    buf.writeUInt16BE(code, 0);
                }
                else throw new TypeError('First argument must be a valid error code number');
                const options = {
                    [kByteLength]: buf.length,
                    fin: true,
                    generateMask: this._generateMask,
                    mask,
                    maskBuffer: this._maskBuffer,
                    opcode: 0x08,
                    readOnly: false,
                    rsv1: false
                };
                if (this._deflating) this.enqueue([
                    this.dispatch,
                    buf,
                    false,
                    options,
                    cb
                ]);
                else this.sendFrame(Sender.frame(buf, options), cb);
            }
            ping(data, mask, cb) {
                let byteLength;
                let readOnly;
                if ('string' == typeof data) {
                    byteLength = Buffer.byteLength(data);
                    readOnly = false;
                } else {
                    data = toBuffer(data);
                    byteLength = data.length;
                    readOnly = toBuffer.readOnly;
                }
                if (byteLength > 125) throw new RangeError('The data size must not be greater than 125 bytes');
                const options = {
                    [kByteLength]: byteLength,
                    fin: true,
                    generateMask: this._generateMask,
                    mask,
                    maskBuffer: this._maskBuffer,
                    opcode: 0x09,
                    readOnly,
                    rsv1: false
                };
                if (this._deflating) this.enqueue([
                    this.dispatch,
                    data,
                    false,
                    options,
                    cb
                ]);
                else this.sendFrame(Sender.frame(data, options), cb);
            }
            pong(data, mask, cb) {
                let byteLength;
                let readOnly;
                if ('string' == typeof data) {
                    byteLength = Buffer.byteLength(data);
                    readOnly = false;
                } else {
                    data = toBuffer(data);
                    byteLength = data.length;
                    readOnly = toBuffer.readOnly;
                }
                if (byteLength > 125) throw new RangeError('The data size must not be greater than 125 bytes');
                const options = {
                    [kByteLength]: byteLength,
                    fin: true,
                    generateMask: this._generateMask,
                    mask,
                    maskBuffer: this._maskBuffer,
                    opcode: 0x0a,
                    readOnly,
                    rsv1: false
                };
                if (this._deflating) this.enqueue([
                    this.dispatch,
                    data,
                    false,
                    options,
                    cb
                ]);
                else this.sendFrame(Sender.frame(data, options), cb);
            }
            send(data, options, cb) {
                const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
                let opcode = options.binary ? 2 : 1;
                let rsv1 = options.compress;
                let byteLength;
                let readOnly;
                if ('string' == typeof data) {
                    byteLength = Buffer.byteLength(data);
                    readOnly = false;
                } else {
                    data = toBuffer(data);
                    byteLength = data.length;
                    readOnly = toBuffer.readOnly;
                }
                if (this._firstFragment) {
                    this._firstFragment = false;
                    if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? 'server_no_context_takeover' : 'client_no_context_takeover']) rsv1 = byteLength >= perMessageDeflate._threshold;
                    this._compress = rsv1;
                } else {
                    rsv1 = false;
                    opcode = 0;
                }
                if (options.fin) this._firstFragment = true;
                if (perMessageDeflate) {
                    const opts = {
                        [kByteLength]: byteLength,
                        fin: options.fin,
                        generateMask: this._generateMask,
                        mask: options.mask,
                        maskBuffer: this._maskBuffer,
                        opcode,
                        readOnly,
                        rsv1
                    };
                    if (this._deflating) this.enqueue([
                        this.dispatch,
                        data,
                        this._compress,
                        opts,
                        cb
                    ]);
                    else this.dispatch(data, this._compress, opts, cb);
                } else this.sendFrame(Sender.frame(data, {
                    [kByteLength]: byteLength,
                    fin: options.fin,
                    generateMask: this._generateMask,
                    mask: options.mask,
                    maskBuffer: this._maskBuffer,
                    opcode,
                    readOnly,
                    rsv1: false
                }), cb);
            }
            dispatch(data, compress, options, cb) {
                if (!compress) return void this.sendFrame(Sender.frame(data, options), cb);
                const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
                this._bufferedBytes += options[kByteLength];
                this._deflating = true;
                perMessageDeflate.compress(data, options.fin, (_, buf)=>{
                    if (this._socket.destroyed) {
                        const err = new Error('The socket was closed while data was being compressed');
                        if ('function' == typeof cb) cb(err);
                        for(let i = 0; i < this._queue.length; i++){
                            const params = this._queue[i];
                            const callback = params[params.length - 1];
                            if ('function' == typeof callback) callback(err);
                        }
                        return;
                    }
                    this._bufferedBytes -= options[kByteLength];
                    this._deflating = false;
                    options.readOnly = false;
                    this.sendFrame(Sender.frame(buf, options), cb);
                    this.dequeue();
                });
            }
            dequeue() {
                while(!this._deflating && this._queue.length){
                    const params = this._queue.shift();
                    this._bufferedBytes -= params[3][kByteLength];
                    Reflect.apply(params[0], this, params.slice(1));
                }
            }
            enqueue(params) {
                this._bufferedBytes += params[3][kByteLength];
                this._queue.push(params);
            }
            sendFrame(list, cb) {
                if (2 === list.length) {
                    this._socket.cork();
                    this._socket.write(list[0]);
                    this._socket.write(list[1], cb);
                    this._socket.uncork();
                } else this._socket.write(list[0], cb);
            }
        }
        module.exports = Sender;
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/stream.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const { Duplex } = __webpack_require__("stream");
        function emitClose(stream) {
            stream.emit('close');
        }
        function duplexOnEnd() {
            if (!this.destroyed && this._writableState.finished) this.destroy();
        }
        function duplexOnError(err) {
            this.removeListener('error', duplexOnError);
            this.destroy();
            if (0 === this.listenerCount('error')) this.emit('error', err);
        }
        function createWebSocketStream(ws, options) {
            let terminateOnDestroy = true;
            const duplex = new Duplex({
                ...options,
                autoDestroy: false,
                emitClose: false,
                objectMode: false,
                writableObjectMode: false
            });
            ws.on('message', function(msg, isBinary) {
                const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
                if (!duplex.push(data)) ws.pause();
            });
            ws.once('error', function(err) {
                if (duplex.destroyed) return;
                terminateOnDestroy = false;
                duplex.destroy(err);
            });
            ws.once('close', function() {
                if (duplex.destroyed) return;
                duplex.push(null);
            });
            duplex._destroy = function(err, callback) {
                if (ws.readyState === ws.CLOSED) {
                    callback(err);
                    process.nextTick(emitClose, duplex);
                    return;
                }
                let called = false;
                ws.once('error', function(err) {
                    called = true;
                    callback(err);
                });
                ws.once('close', function() {
                    if (!called) callback(err);
                    process.nextTick(emitClose, duplex);
                });
                if (terminateOnDestroy) ws.terminate();
            };
            duplex._final = function(callback) {
                if (ws.readyState === ws.CONNECTING) return void ws.once('open', function() {
                    duplex._final(callback);
                });
                if (null === ws._socket) return;
                if (ws._socket._writableState.finished) {
                    callback();
                    if (duplex._readableState.endEmitted) duplex.destroy();
                } else {
                    ws._socket.once('finish', function() {
                        callback();
                    });
                    ws.close();
                }
            };
            duplex._read = function() {
                if (ws.isPaused) ws.resume();
            };
            duplex._write = function(chunk, encoding, callback) {
                if (ws.readyState === ws.CONNECTING) return void ws.once('open', function() {
                    duplex._write(chunk, encoding, callback);
                });
                ws.send(chunk, callback);
            };
            duplex.on('end', duplexOnEnd);
            duplex.on('error', duplexOnError);
            return duplex;
        }
        module.exports = createWebSocketStream;
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/subprotocol.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const { tokenChars } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/validation.js");
        function parse(header) {
            const protocols = new Set();
            let start = -1;
            let end = -1;
            let i = 0;
            for(i; i < header.length; i++){
                const code = header.charCodeAt(i);
                if (-1 === end && 1 === tokenChars[code]) {
                    if (-1 === start) start = i;
                } else if (0 !== i && (0x20 === code || 0x09 === code)) {
                    if (-1 === end && -1 !== start) end = i;
                } else if (0x2c === code) {
                    if (-1 === start) throw new SyntaxError(`Unexpected character at index ${i}`);
                    if (-1 === end) end = i;
                    const protocol = header.slice(start, end);
                    if (protocols.has(protocol)) throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
                    protocols.add(protocol);
                    start = end = -1;
                } else throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (-1 === start || -1 !== end) throw new SyntaxError('Unexpected end of input');
            const protocol = header.slice(start, i);
            if (protocols.has(protocol)) throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
            protocols.add(protocol);
            return protocols;
        }
        module.exports = {
            parse
        };
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/validation.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const { isUtf8 } = __webpack_require__("buffer");
        const tokenChars = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ];
        function isValidStatusCode(code) {
            return code >= 1000 && code <= 1014 && 1004 !== code && 1005 !== code && 1006 !== code || code >= 3000 && code <= 4999;
        }
        function _isValidUTF8(buf) {
            const len = buf.length;
            let i = 0;
            while(i < len)if ((0x80 & buf[i]) === 0) i++;
            else if ((0xe0 & buf[i]) === 0xc0) {
                if (i + 1 === len || (0xc0 & buf[i + 1]) !== 0x80 || (0xfe & buf[i]) === 0xc0) return false;
                i += 2;
            } else if ((0xf0 & buf[i]) === 0xe0) {
                if (i + 2 >= len || (0xc0 & buf[i + 1]) !== 0x80 || (0xc0 & buf[i + 2]) !== 0x80 || 0xe0 === buf[i] && (0xe0 & buf[i + 1]) === 0x80 || 0xed === buf[i] && (0xe0 & buf[i + 1]) === 0xa0) return false;
                i += 3;
            } else {
                if ((0xf8 & buf[i]) !== 0xf0) return false;
                if (i + 3 >= len || (0xc0 & buf[i + 1]) !== 0x80 || (0xc0 & buf[i + 2]) !== 0x80 || (0xc0 & buf[i + 3]) !== 0x80 || 0xf0 === buf[i] && (0xf0 & buf[i + 1]) === 0x80 || 0xf4 === buf[i] && buf[i + 1] > 0x8f || buf[i] > 0xf4) return false;
                i += 4;
            }
            return true;
        }
        module.exports = {
            isValidStatusCode,
            isValidUTF8: _isValidUTF8,
            tokenChars
        };
        if (isUtf8) module.exports.isValidUTF8 = function(buf) {
            return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
        };
        else if (!process.env.WS_NO_UTF_8_VALIDATE) try {
            const isValidUTF8 = __webpack_require__("../../node_modules/utf-8-validate/index.js");
            module.exports.isValidUTF8 = function(buf) {
                return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
            };
        } catch (e) {}
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/websocket-server.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const EventEmitter = __webpack_require__("events");
        const http = __webpack_require__("http");
        const { Duplex } = __webpack_require__("stream");
        const { createHash } = __webpack_require__("crypto");
        const extension = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/extension.js");
        const PerMessageDeflate = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/permessage-deflate.js");
        const subprotocol = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/subprotocol.js");
        const WebSocket = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/websocket.js");
        const { GUID, kWebSocket } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/constants.js");
        const keyRegex = /^[+/0-9A-Za-z]{22}==$/;
        const RUNNING = 0;
        const CLOSING = 1;
        const CLOSED = 2;
        class WebSocketServer extends EventEmitter {
            constructor(options, callback){
                super();
                options = {
                    allowSynchronousEvents: true,
                    autoPong: true,
                    maxPayload: 104857600,
                    skipUTF8Validation: false,
                    perMessageDeflate: false,
                    handleProtocols: null,
                    clientTracking: true,
                    verifyClient: null,
                    noServer: false,
                    backlog: null,
                    server: null,
                    host: null,
                    path: null,
                    port: null,
                    WebSocket,
                    ...options
                };
                if (null == options.port && !options.server && !options.noServer || null != options.port && (options.server || options.noServer) || options.server && options.noServer) throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
                if (null != options.port) {
                    this._server = http.createServer((req, res)=>{
                        const body = http.STATUS_CODES[426];
                        res.writeHead(426, {
                            'Content-Length': body.length,
                            'Content-Type': 'text/plain'
                        });
                        res.end(body);
                    });
                    this._server.listen(options.port, options.host, options.backlog, callback);
                } else if (options.server) this._server = options.server;
                if (this._server) {
                    const emitConnection = this.emit.bind(this, 'connection');
                    this._removeListeners = addListeners(this._server, {
                        listening: this.emit.bind(this, 'listening'),
                        error: this.emit.bind(this, 'error'),
                        upgrade: (req, socket, head)=>{
                            this.handleUpgrade(req, socket, head, emitConnection);
                        }
                    });
                }
                if (true === options.perMessageDeflate) options.perMessageDeflate = {};
                if (options.clientTracking) {
                    this.clients = new Set();
                    this._shouldEmitClose = false;
                }
                this.options = options;
                this._state = RUNNING;
            }
            address() {
                if (this.options.noServer) throw new Error('The server is operating in "noServer" mode');
                if (!this._server) return null;
                return this._server.address();
            }
            close(cb) {
                if (this._state === CLOSED) {
                    if (cb) this.once('close', ()=>{
                        cb(new Error('The server is not running'));
                    });
                    process.nextTick(emitClose, this);
                    return;
                }
                if (cb) this.once('close', cb);
                if (this._state === CLOSING) return;
                this._state = CLOSING;
                if (this.options.noServer || this.options.server) {
                    if (this._server) {
                        this._removeListeners();
                        this._removeListeners = this._server = null;
                    }
                    if (this.clients) if (this.clients.size) this._shouldEmitClose = true;
                    else process.nextTick(emitClose, this);
                    else process.nextTick(emitClose, this);
                } else {
                    const server = this._server;
                    this._removeListeners();
                    this._removeListeners = this._server = null;
                    server.close(()=>{
                        emitClose(this);
                    });
                }
            }
            shouldHandle(req) {
                if (this.options.path) {
                    const index = req.url.indexOf('?');
                    const pathname = -1 !== index ? req.url.slice(0, index) : req.url;
                    if (pathname !== this.options.path) return false;
                }
                return true;
            }
            handleUpgrade(req, socket, head, cb) {
                socket.on('error', socketOnError);
                const key = req.headers['sec-websocket-key'];
                const upgrade = req.headers.upgrade;
                const version = +req.headers['sec-websocket-version'];
                if ('GET' !== req.method) {
                    const message = 'Invalid HTTP method';
                    abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
                    return;
                }
                if (void 0 === upgrade || 'websocket' !== upgrade.toLowerCase()) {
                    const message = 'Invalid Upgrade header';
                    abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
                    return;
                }
                if (void 0 === key || !keyRegex.test(key)) {
                    const message = 'Missing or invalid Sec-WebSocket-Key header';
                    abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
                    return;
                }
                if (8 !== version && 13 !== version) {
                    const message = 'Missing or invalid Sec-WebSocket-Version header';
                    abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
                    return;
                }
                if (!this.shouldHandle(req)) return void abortHandshake(socket, 400);
                const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
                let protocols = new Set();
                if (void 0 !== secWebSocketProtocol) try {
                    protocols = subprotocol.parse(secWebSocketProtocol);
                } catch (err) {
                    const message = 'Invalid Sec-WebSocket-Protocol header';
                    abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
                    return;
                }
                const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
                const extensions = {};
                if (this.options.perMessageDeflate && void 0 !== secWebSocketExtensions) {
                    const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
                    try {
                        const offers = extension.parse(secWebSocketExtensions);
                        if (offers[PerMessageDeflate.extensionName]) {
                            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
                            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
                        }
                    } catch (err) {
                        const message = 'Invalid or unacceptable Sec-WebSocket-Extensions header';
                        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
                        return;
                    }
                }
                if (this.options.verifyClient) {
                    const info = {
                        origin: req.headers[`${8 === version ? 'sec-websocket-origin' : 'origin'}`],
                        secure: !!(req.socket.authorized || req.socket.encrypted),
                        req
                    };
                    if (2 === this.options.verifyClient.length) return void this.options.verifyClient(info, (verified, code, message, headers)=>{
                        if (!verified) return abortHandshake(socket, code || 401, message, headers);
                        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
                    });
                    if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
                }
                this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
            }
            completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
                if (!socket.readable || !socket.writable) return socket.destroy();
                if (socket[kWebSocket]) throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
                if (this._state > RUNNING) return abortHandshake(socket, 503);
                const digest = createHash('sha1').update(key + GUID).digest('base64');
                const headers = [
                    'HTTP/1.1 101 Switching Protocols',
                    'Upgrade: websocket',
                    'Connection: Upgrade',
                    `Sec-WebSocket-Accept: ${digest}`
                ];
                const ws = new this.options.WebSocket(null, void 0, this.options);
                if (protocols.size) {
                    const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
                    if (protocol) {
                        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
                        ws._protocol = protocol;
                    }
                }
                if (extensions[PerMessageDeflate.extensionName]) {
                    const params = extensions[PerMessageDeflate.extensionName].params;
                    const value = extension.format({
                        [PerMessageDeflate.extensionName]: [
                            params
                        ]
                    });
                    headers.push(`Sec-WebSocket-Extensions: ${value}`);
                    ws._extensions = extensions;
                }
                this.emit('headers', headers, req);
                socket.write(headers.concat('\r\n').join('\r\n'));
                socket.removeListener('error', socketOnError);
                ws.setSocket(socket, head, {
                    allowSynchronousEvents: this.options.allowSynchronousEvents,
                    maxPayload: this.options.maxPayload,
                    skipUTF8Validation: this.options.skipUTF8Validation
                });
                if (this.clients) {
                    this.clients.add(ws);
                    ws.on('close', ()=>{
                        this.clients.delete(ws);
                        if (this._shouldEmitClose && !this.clients.size) process.nextTick(emitClose, this);
                    });
                }
                cb(ws, req);
            }
        }
        module.exports = WebSocketServer;
        function addListeners(server, map) {
            for (const event of Object.keys(map))server.on(event, map[event]);
            return function() {
                for (const event of Object.keys(map))server.removeListener(event, map[event]);
            };
        }
        function emitClose(server) {
            server._state = CLOSED;
            server.emit('close');
        }
        function socketOnError() {
            this.destroy();
        }
        function abortHandshake(socket, code, message, headers) {
            message = message || http.STATUS_CODES[code];
            headers = {
                Connection: 'close',
                'Content-Type': 'text/html',
                'Content-Length': Buffer.byteLength(message),
                ...headers
            };
            socket.once('finish', socket.destroy);
            socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` + Object.keys(headers).map((h)=>`${h}: ${headers[h]}`).join('\r\n') + '\r\n\r\n' + message);
        }
        function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
            if (server.listenerCount('wsClientError')) {
                const err = new Error(message);
                Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
                server.emit('wsClientError', err, socket, req);
            } else abortHandshake(socket, code, message);
        }
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/websocket.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const EventEmitter = __webpack_require__("events");
        const https = __webpack_require__("https");
        const http = __webpack_require__("http");
        const net = __webpack_require__("net");
        const tls = __webpack_require__("tls");
        const { randomBytes, createHash } = __webpack_require__("crypto");
        const { Duplex, Readable } = __webpack_require__("stream");
        const { URL: URL1 } = __webpack_require__("url");
        const PerMessageDeflate = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/permessage-deflate.js");
        const Receiver = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/receiver.js");
        const Sender = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/sender.js");
        const { BINARY_TYPES, EMPTY_BUFFER, GUID, kForOnEventAttribute, kListener, kStatusCode, kWebSocket, NOOP } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/constants.js");
        const { EventTarget: { addEventListener, removeEventListener } } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/event-target.js");
        const { format, parse } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/extension.js");
        const { toBuffer } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/buffer-util.js");
        const closeTimeout = 30000;
        const kAborted = Symbol('kAborted');
        const protocolVersions = [
            8,
            13
        ];
        const readyStates = [
            'CONNECTING',
            'OPEN',
            'CLOSING',
            'CLOSED'
        ];
        const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
        class WebSocket extends EventEmitter {
            constructor(address, protocols, options){
                super();
                this._binaryType = BINARY_TYPES[0];
                this._closeCode = 1006;
                this._closeFrameReceived = false;
                this._closeFrameSent = false;
                this._closeMessage = EMPTY_BUFFER;
                this._closeTimer = null;
                this._extensions = {};
                this._paused = false;
                this._protocol = '';
                this._readyState = WebSocket.CONNECTING;
                this._receiver = null;
                this._sender = null;
                this._socket = null;
                if (null !== address) {
                    this._bufferedAmount = 0;
                    this._isServer = false;
                    this._redirects = 0;
                    if (void 0 === protocols) protocols = [];
                    else if (!Array.isArray(protocols)) if ('object' == typeof protocols && null !== protocols) {
                        options = protocols;
                        protocols = [];
                    } else protocols = [
                        protocols
                    ];
                    initAsClient(this, address, protocols, options);
                } else {
                    this._autoPong = options.autoPong;
                    this._isServer = true;
                }
            }
            get binaryType() {
                return this._binaryType;
            }
            set binaryType(type) {
                if (!BINARY_TYPES.includes(type)) return;
                this._binaryType = type;
                if (this._receiver) this._receiver._binaryType = type;
            }
            get bufferedAmount() {
                if (!this._socket) return this._bufferedAmount;
                return this._socket._writableState.length + this._sender._bufferedBytes;
            }
            get extensions() {
                return Object.keys(this._extensions).join();
            }
            get isPaused() {
                return this._paused;
            }
            get onclose() {
                return null;
            }
            get onerror() {
                return null;
            }
            get onopen() {
                return null;
            }
            get onmessage() {
                return null;
            }
            get protocol() {
                return this._protocol;
            }
            get readyState() {
                return this._readyState;
            }
            get url() {
                return this._url;
            }
            setSocket(socket, head, options) {
                const receiver = new Receiver({
                    allowSynchronousEvents: options.allowSynchronousEvents,
                    binaryType: this.binaryType,
                    extensions: this._extensions,
                    isServer: this._isServer,
                    maxPayload: options.maxPayload,
                    skipUTF8Validation: options.skipUTF8Validation
                });
                this._sender = new Sender(socket, this._extensions, options.generateMask);
                this._receiver = receiver;
                this._socket = socket;
                receiver[kWebSocket] = this;
                socket[kWebSocket] = this;
                receiver.on('conclude', receiverOnConclude);
                receiver.on('drain', receiverOnDrain);
                receiver.on('error', receiverOnError);
                receiver.on('message', receiverOnMessage);
                receiver.on('ping', receiverOnPing);
                receiver.on('pong', receiverOnPong);
                if (socket.setTimeout) socket.setTimeout(0);
                if (socket.setNoDelay) socket.setNoDelay();
                if (head.length > 0) socket.unshift(head);
                socket.on('close', socketOnClose);
                socket.on('data', socketOnData);
                socket.on('end', socketOnEnd);
                socket.on('error', socketOnError);
                this._readyState = WebSocket.OPEN;
                this.emit('open');
            }
            emitClose() {
                if (!this._socket) {
                    this._readyState = WebSocket.CLOSED;
                    this.emit('close', this._closeCode, this._closeMessage);
                    return;
                }
                if (this._extensions[PerMessageDeflate.extensionName]) this._extensions[PerMessageDeflate.extensionName].cleanup();
                this._receiver.removeAllListeners();
                this._readyState = WebSocket.CLOSED;
                this.emit('close', this._closeCode, this._closeMessage);
            }
            close(code, data) {
                if (this.readyState === WebSocket.CLOSED) return;
                if (this.readyState === WebSocket.CONNECTING) {
                    const msg = 'WebSocket was closed before the connection was established';
                    abortHandshake(this, this._req, msg);
                    return;
                }
                if (this.readyState === WebSocket.CLOSING) {
                    if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) this._socket.end();
                    return;
                }
                this._readyState = WebSocket.CLOSING;
                this._sender.close(code, data, !this._isServer, (err)=>{
                    if (err) return;
                    this._closeFrameSent = true;
                    if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) this._socket.end();
                });
                this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
            }
            pause() {
                if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) return;
                this._paused = true;
                this._socket.pause();
            }
            ping(data, mask, cb) {
                if (this.readyState === WebSocket.CONNECTING) throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
                if ('function' == typeof data) {
                    cb = data;
                    data = mask = void 0;
                } else if ('function' == typeof mask) {
                    cb = mask;
                    mask = void 0;
                }
                if ('number' == typeof data) data = data.toString();
                if (this.readyState !== WebSocket.OPEN) return void sendAfterClose(this, data, cb);
                if (void 0 === mask) mask = !this._isServer;
                this._sender.ping(data || EMPTY_BUFFER, mask, cb);
            }
            pong(data, mask, cb) {
                if (this.readyState === WebSocket.CONNECTING) throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
                if ('function' == typeof data) {
                    cb = data;
                    data = mask = void 0;
                } else if ('function' == typeof mask) {
                    cb = mask;
                    mask = void 0;
                }
                if ('number' == typeof data) data = data.toString();
                if (this.readyState !== WebSocket.OPEN) return void sendAfterClose(this, data, cb);
                if (void 0 === mask) mask = !this._isServer;
                this._sender.pong(data || EMPTY_BUFFER, mask, cb);
            }
            resume() {
                if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) return;
                this._paused = false;
                if (!this._receiver._writableState.needDrain) this._socket.resume();
            }
            send(data, options, cb) {
                if (this.readyState === WebSocket.CONNECTING) throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
                if ('function' == typeof options) {
                    cb = options;
                    options = {};
                }
                if ('number' == typeof data) data = data.toString();
                if (this.readyState !== WebSocket.OPEN) return void sendAfterClose(this, data, cb);
                const opts = {
                    binary: 'string' != typeof data,
                    mask: !this._isServer,
                    compress: true,
                    fin: true,
                    ...options
                };
                if (!this._extensions[PerMessageDeflate.extensionName]) opts.compress = false;
                this._sender.send(data || EMPTY_BUFFER, opts, cb);
            }
            terminate() {
                if (this.readyState === WebSocket.CLOSED) return;
                if (this.readyState === WebSocket.CONNECTING) {
                    const msg = 'WebSocket was closed before the connection was established';
                    abortHandshake(this, this._req, msg);
                    return;
                }
                if (this._socket) {
                    this._readyState = WebSocket.CLOSING;
                    this._socket.destroy();
                }
            }
        }
        Object.defineProperty(WebSocket, 'CONNECTING', {
            enumerable: true,
            value: readyStates.indexOf('CONNECTING')
        });
        Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
            enumerable: true,
            value: readyStates.indexOf('CONNECTING')
        });
        Object.defineProperty(WebSocket, 'OPEN', {
            enumerable: true,
            value: readyStates.indexOf('OPEN')
        });
        Object.defineProperty(WebSocket.prototype, 'OPEN', {
            enumerable: true,
            value: readyStates.indexOf('OPEN')
        });
        Object.defineProperty(WebSocket, 'CLOSING', {
            enumerable: true,
            value: readyStates.indexOf('CLOSING')
        });
        Object.defineProperty(WebSocket.prototype, 'CLOSING', {
            enumerable: true,
            value: readyStates.indexOf('CLOSING')
        });
        Object.defineProperty(WebSocket, 'CLOSED', {
            enumerable: true,
            value: readyStates.indexOf('CLOSED')
        });
        Object.defineProperty(WebSocket.prototype, 'CLOSED', {
            enumerable: true,
            value: readyStates.indexOf('CLOSED')
        });
        [
            'binaryType',
            'bufferedAmount',
            'extensions',
            'isPaused',
            'protocol',
            'readyState',
            'url'
        ].forEach((property)=>{
            Object.defineProperty(WebSocket.prototype, property, {
                enumerable: true
            });
        });
        [
            'open',
            'error',
            'close',
            'message'
        ].forEach((method)=>{
            Object.defineProperty(WebSocket.prototype, `on${method}`, {
                enumerable: true,
                get () {
                    for (const listener of this.listeners(method))if (listener[kForOnEventAttribute]) return listener[kListener];
                    return null;
                },
                set (handler) {
                    for (const listener of this.listeners(method))if (listener[kForOnEventAttribute]) {
                        this.removeListener(method, listener);
                        break;
                    }
                    if ('function' != typeof handler) return;
                    this.addEventListener(method, handler, {
                        [kForOnEventAttribute]: true
                    });
                }
            });
        });
        WebSocket.prototype.addEventListener = addEventListener;
        WebSocket.prototype.removeEventListener = removeEventListener;
        module.exports = WebSocket;
        function initAsClient(websocket, address, protocols, options) {
            const opts = {
                allowSynchronousEvents: true,
                autoPong: true,
                protocolVersion: protocolVersions[1],
                maxPayload: 104857600,
                skipUTF8Validation: false,
                perMessageDeflate: true,
                followRedirects: false,
                maxRedirects: 10,
                ...options,
                socketPath: void 0,
                hostname: void 0,
                protocol: void 0,
                timeout: void 0,
                method: 'GET',
                host: void 0,
                path: void 0,
                port: void 0
            };
            websocket._autoPong = opts.autoPong;
            if (!protocolVersions.includes(opts.protocolVersion)) throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(', ')})`);
            let parsedUrl;
            if (address instanceof URL1) parsedUrl = address;
            else try {
                parsedUrl = new URL1(address);
            } catch (e) {
                throw new SyntaxError(`Invalid URL: ${address}`);
            }
            if ('http:' === parsedUrl.protocol) parsedUrl.protocol = 'ws:';
            else if ('https:' === parsedUrl.protocol) parsedUrl.protocol = 'wss:';
            websocket._url = parsedUrl.href;
            const isSecure = 'wss:' === parsedUrl.protocol;
            const isIpcUrl = 'ws+unix:' === parsedUrl.protocol;
            let invalidUrlMessage;
            if ('ws:' === parsedUrl.protocol || isSecure || isIpcUrl) {
                if (isIpcUrl && !parsedUrl.pathname) invalidUrlMessage = "The URL's pathname is empty";
                else if (parsedUrl.hash) invalidUrlMessage = 'The URL contains a fragment identifier';
            } else invalidUrlMessage = 'The URL\'s protocol must be one of "ws:", "wss:", "http:", "https", or "ws+unix:"';
            if (invalidUrlMessage) {
                const err = new SyntaxError(invalidUrlMessage);
                if (0 !== websocket._redirects) return void emitErrorAndClose(websocket, err);
                throw err;
            }
            const defaultPort = isSecure ? 443 : 80;
            const key = randomBytes(16).toString('base64');
            const request = isSecure ? https.request : http.request;
            const protocolSet = new Set();
            let perMessageDeflate;
            opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
            opts.defaultPort = opts.defaultPort || defaultPort;
            opts.port = parsedUrl.port || defaultPort;
            opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
            opts.headers = {
                ...opts.headers,
                'Sec-WebSocket-Version': opts.protocolVersion,
                'Sec-WebSocket-Key': key,
                Connection: 'Upgrade',
                Upgrade: 'websocket'
            };
            opts.path = parsedUrl.pathname + parsedUrl.search;
            opts.timeout = opts.handshakeTimeout;
            if (opts.perMessageDeflate) {
                perMessageDeflate = new PerMessageDeflate(true !== opts.perMessageDeflate ? opts.perMessageDeflate : {}, false, opts.maxPayload);
                opts.headers['Sec-WebSocket-Extensions'] = format({
                    [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
                });
            }
            if (protocols.length) {
                for (const protocol of protocols){
                    if ('string' != typeof protocol || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) throw new SyntaxError('An invalid or duplicated subprotocol was specified');
                    protocolSet.add(protocol);
                }
                opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
            }
            if (opts.origin) if (opts.protocolVersion < 13) opts.headers['Sec-WebSocket-Origin'] = opts.origin;
            else opts.headers.Origin = opts.origin;
            if (parsedUrl.username || parsedUrl.password) opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
            if (isIpcUrl) {
                const parts = opts.path.split(':');
                opts.socketPath = parts[0];
                opts.path = parts[1];
            }
            let req;
            if (opts.followRedirects) {
                if (0 === websocket._redirects) {
                    websocket._originalIpc = isIpcUrl;
                    websocket._originalSecure = isSecure;
                    websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
                    const headers = options && options.headers;
                    options = {
                        ...options,
                        headers: {}
                    };
                    if (headers) for (const [key, value] of Object.entries(headers))options.headers[key.toLowerCase()] = value;
                } else if (0 === websocket.listenerCount('redirect')) {
                    const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
                    if (!isSameHost || websocket._originalSecure && !isSecure) {
                        delete opts.headers.authorization;
                        delete opts.headers.cookie;
                        if (!isSameHost) delete opts.headers.host;
                        opts.auth = void 0;
                    }
                }
                if (opts.auth && !options.headers.authorization) options.headers.authorization = 'Basic ' + Buffer.from(opts.auth).toString('base64');
                req = websocket._req = request(opts);
                if (websocket._redirects) websocket.emit('redirect', websocket.url, req);
            } else req = websocket._req = request(opts);
            if (opts.timeout) req.on('timeout', ()=>{
                abortHandshake(websocket, req, 'Opening handshake has timed out');
            });
            req.on('error', (err)=>{
                if (null === req || req[kAborted]) return;
                req = websocket._req = null;
                emitErrorAndClose(websocket, err);
            });
            req.on('response', (res)=>{
                const location = res.headers.location;
                const statusCode = res.statusCode;
                if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
                    if (++websocket._redirects > opts.maxRedirects) return void abortHandshake(websocket, req, 'Maximum redirects exceeded');
                    req.abort();
                    let addr;
                    try {
                        addr = new URL1(location, address);
                    } catch (e) {
                        const err = new SyntaxError(`Invalid URL: ${location}`);
                        emitErrorAndClose(websocket, err);
                        return;
                    }
                    initAsClient(websocket, addr, protocols, options);
                } else if (!websocket.emit('unexpected-response', req, res)) abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
            });
            req.on('upgrade', (res, socket, head)=>{
                websocket.emit('upgrade', res);
                if (websocket.readyState !== WebSocket.CONNECTING) return;
                req = websocket._req = null;
                const upgrade = res.headers.upgrade;
                if (void 0 === upgrade || 'websocket' !== upgrade.toLowerCase()) return void abortHandshake(websocket, socket, 'Invalid Upgrade header');
                const digest = createHash('sha1').update(key + GUID).digest('base64');
                if (res.headers['sec-websocket-accept'] !== digest) return void abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
                const serverProt = res.headers['sec-websocket-protocol'];
                let protError;
                if (void 0 !== serverProt) if (protocolSet.size) {
                    if (!protocolSet.has(serverProt)) protError = 'Server sent an invalid subprotocol';
                } else protError = 'Server sent a subprotocol but none was requested';
                else if (protocolSet.size) protError = 'Server sent no subprotocol';
                if (protError) return void abortHandshake(websocket, socket, protError);
                if (serverProt) websocket._protocol = serverProt;
                const secWebSocketExtensions = res.headers['sec-websocket-extensions'];
                if (void 0 !== secWebSocketExtensions) {
                    if (!perMessageDeflate) {
                        const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
                        abortHandshake(websocket, socket, message);
                        return;
                    }
                    let extensions;
                    try {
                        extensions = parse(secWebSocketExtensions);
                    } catch (err) {
                        const message = 'Invalid Sec-WebSocket-Extensions header';
                        abortHandshake(websocket, socket, message);
                        return;
                    }
                    const extensionNames = Object.keys(extensions);
                    if (1 !== extensionNames.length || extensionNames[0] !== PerMessageDeflate.extensionName) {
                        const message = 'Server indicated an extension that was not requested';
                        abortHandshake(websocket, socket, message);
                        return;
                    }
                    try {
                        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
                    } catch (err) {
                        const message = 'Invalid Sec-WebSocket-Extensions header';
                        abortHandshake(websocket, socket, message);
                        return;
                    }
                    websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
                }
                websocket.setSocket(socket, head, {
                    allowSynchronousEvents: opts.allowSynchronousEvents,
                    generateMask: opts.generateMask,
                    maxPayload: opts.maxPayload,
                    skipUTF8Validation: opts.skipUTF8Validation
                });
            });
            if (opts.finishRequest) opts.finishRequest(req, websocket);
            else req.end();
        }
        function emitErrorAndClose(websocket, err) {
            websocket._readyState = WebSocket.CLOSING;
            websocket.emit('error', err);
            websocket.emitClose();
        }
        function netConnect(options) {
            options.path = options.socketPath;
            return net.connect(options);
        }
        function tlsConnect(options) {
            options.path = void 0;
            if (!options.servername && '' !== options.servername) options.servername = net.isIP(options.host) ? '' : options.host;
            return tls.connect(options);
        }
        function abortHandshake(websocket, stream, message) {
            websocket._readyState = WebSocket.CLOSING;
            const err = new Error(message);
            Error.captureStackTrace(err, abortHandshake);
            if (stream.setHeader) {
                stream[kAborted] = true;
                stream.abort();
                if (stream.socket && !stream.socket.destroyed) stream.socket.destroy();
                process.nextTick(emitErrorAndClose, websocket, err);
            } else {
                stream.destroy(err);
                stream.once('error', websocket.emit.bind(websocket, 'error'));
                stream.once('close', websocket.emitClose.bind(websocket));
            }
        }
        function sendAfterClose(websocket, data, cb) {
            if (data) {
                const length = toBuffer(data).length;
                if (websocket._socket) websocket._sender._bufferedBytes += length;
                else websocket._bufferedAmount += length;
            }
            if (cb) {
                const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
                process.nextTick(cb, err);
            }
        }
        function receiverOnConclude(code, reason) {
            const websocket = this[kWebSocket];
            websocket._closeFrameReceived = true;
            websocket._closeMessage = reason;
            websocket._closeCode = code;
            if (void 0 === websocket._socket[kWebSocket]) return;
            websocket._socket.removeListener('data', socketOnData);
            process.nextTick(resume, websocket._socket);
            if (1005 === code) websocket.close();
            else websocket.close(code, reason);
        }
        function receiverOnDrain() {
            const websocket = this[kWebSocket];
            if (!websocket.isPaused) websocket._socket.resume();
        }
        function receiverOnError(err) {
            const websocket = this[kWebSocket];
            if (void 0 !== websocket._socket[kWebSocket]) {
                websocket._socket.removeListener('data', socketOnData);
                process.nextTick(resume, websocket._socket);
                websocket.close(err[kStatusCode]);
            }
            websocket.emit('error', err);
        }
        function receiverOnFinish() {
            this[kWebSocket].emitClose();
        }
        function receiverOnMessage(data, isBinary) {
            this[kWebSocket].emit('message', data, isBinary);
        }
        function receiverOnPing(data) {
            const websocket = this[kWebSocket];
            if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
            websocket.emit('ping', data);
        }
        function receiverOnPong(data) {
            this[kWebSocket].emit('pong', data);
        }
        function resume(stream) {
            stream.resume();
        }
        function socketOnClose() {
            const websocket = this[kWebSocket];
            this.removeListener('close', socketOnClose);
            this.removeListener('data', socketOnData);
            this.removeListener('end', socketOnEnd);
            websocket._readyState = WebSocket.CLOSING;
            let chunk;
            if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && null !== (chunk = websocket._socket.read())) websocket._receiver.write(chunk);
            websocket._receiver.end();
            this[kWebSocket] = void 0;
            clearTimeout(websocket._closeTimer);
            if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) websocket.emitClose();
            else {
                websocket._receiver.on('error', receiverOnFinish);
                websocket._receiver.on('finish', receiverOnFinish);
            }
        }
        function socketOnData(chunk) {
            if (!this[kWebSocket]._receiver.write(chunk)) this.pause();
        }
        function socketOnEnd() {
            const websocket = this[kWebSocket];
            websocket._readyState = WebSocket.CLOSING;
            websocket._receiver.end();
            this.end();
        }
        function socketOnError() {
            const websocket = this[kWebSocket];
            this.removeListener('error', socketOnError);
            this.on('error', NOOP);
            if (websocket) {
                websocket._readyState = WebSocket.CLOSING;
                this.destroy();
            }
        }
    },
    "../../node_modules/bufferutil/fallback.js": function(module) {
        "use strict";
        const mask = (source, mask, output, offset, length)=>{
            for(var i = 0; i < length; i++)output[offset + i] = source[i] ^ mask[3 & i];
        };
        const unmask = (buffer, mask)=>{
            const length = buffer.length;
            for(var i = 0; i < length; i++)buffer[i] ^= mask[3 & i];
        };
        module.exports = {
            mask,
            unmask
        };
    },
    "../../node_modules/bufferutil/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        try {
            module.exports = __webpack_require__("../../node_modules/node-gyp-build/index.js")(__dirname);
        } catch (e) {
            module.exports = __webpack_require__("../../node_modules/bufferutil/fallback.js");
        }
    },
    "../../node_modules/node-gyp-build/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const runtimeRequire = require;
        if ('function' == typeof runtimeRequire.addon) module.exports = runtimeRequire.addon.bind(runtimeRequire);
        else module.exports = __webpack_require__("../../node_modules/node-gyp-build/node-gyp-build.js");
    },
    "../../node_modules/node-gyp-build/node-gyp-build.js": function(module, __unused_webpack_exports, __webpack_require__) {
        var fs = __webpack_require__("fs");
        var path = __webpack_require__("path");
        var os = __webpack_require__("os");
        var runtimeRequire = require;
        var vars = process.config && process.config.variables || {};
        var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
        var abi = process.versions.modules;
        var runtime = isElectron() ? 'electron' : isNwjs() ? 'node-webkit' : 'node';
        var arch = process.env.npm_config_arch || os.arch();
        var platform = process.env.npm_config_platform || os.platform();
        var libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc');
        var armv = process.env.ARM_VERSION || ('arm64' === arch ? '8' : vars.arm_version) || '';
        var uv = (process.versions.uv || '').split('.')[0];
        module.exports = load;
        function load(dir) {
            return runtimeRequire(load.resolve(dir));
        }
        load.resolve = load.path = function(dir) {
            dir = path.resolve(dir || '.');
            try {
                var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_');
                if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD'];
            } catch (err) {}
            if (!prebuildsOnly) {
                var release = getFirst(path.join(dir, 'build/Release'), matchBuild);
                if (release) return release;
                var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild);
                if (debug) return debug;
            }
            var prebuild = resolve(dir);
            if (prebuild) return prebuild;
            var nearby = resolve(path.dirname(process.execPath));
            if (nearby) return nearby;
            var target = [
                'platform=' + platform,
                'arch=' + arch,
                'runtime=' + runtime,
                'abi=' + abi,
                'uv=' + uv,
                armv ? 'armv=' + armv : '',
                'libc=' + libc,
                'node=' + process.versions.node,
                process.versions.electron ? 'electron=' + process.versions.electron : '',
                'webpack=true'
            ].filter(Boolean).join(' ');
            throw new Error('No native build was found for ' + target + '\n    loaded from: ' + dir + '\n');
            function resolve(dir) {
                var tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple);
                var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
                if (!tuple) return;
                var prebuilds = path.join(dir, 'prebuilds', tuple.name);
                var parsed = readdirSync(prebuilds).map(parseTags);
                var candidates = parsed.filter(matchTags(runtime, abi));
                var winner = candidates.sort(compareTags(runtime))[0];
                if (winner) return path.join(prebuilds, winner.file);
            }
        };
        function readdirSync(dir) {
            try {
                return fs.readdirSync(dir);
            } catch (err) {
                return [];
            }
        }
        function getFirst(dir, filter) {
            var files = readdirSync(dir).filter(filter);
            return files[0] && path.join(dir, files[0]);
        }
        function matchBuild(name) {
            return /\.node$/.test(name);
        }
        function parseTuple(name) {
            var arr = name.split('-');
            if (2 !== arr.length) return;
            var platform = arr[0];
            var architectures = arr[1].split('+');
            if (!platform) return;
            if (!architectures.length) return;
            if (!architectures.every(Boolean)) return;
            return {
                name,
                platform,
                architectures
            };
        }
        function matchTuple(platform, arch) {
            return function(tuple) {
                if (null == tuple) return false;
                if (tuple.platform !== platform) return false;
                return tuple.architectures.includes(arch);
            };
        }
        function compareTuples(a, b) {
            return a.architectures.length - b.architectures.length;
        }
        function parseTags(file) {
            var arr = file.split('.');
            var extension = arr.pop();
            var tags = {
                file: file,
                specificity: 0
            };
            if ('node' !== extension) return;
            for(var i = 0; i < arr.length; i++){
                var tag = arr[i];
                if ('node' === tag || 'electron' === tag || 'node-webkit' === tag) tags.runtime = tag;
                else if ('napi' === tag) tags.napi = true;
                else if ('abi' === tag.slice(0, 3)) tags.abi = tag.slice(3);
                else if ('uv' === tag.slice(0, 2)) tags.uv = tag.slice(2);
                else if ('armv' === tag.slice(0, 4)) tags.armv = tag.slice(4);
                else {
                    if ('glibc' !== tag && 'musl' !== tag) continue;
                    tags.libc = tag;
                }
                tags.specificity++;
            }
            return tags;
        }
        function matchTags(runtime, abi) {
            return function(tags) {
                if (null == tags) return false;
                if (tags.runtime && tags.runtime !== runtime && !runtimeAgnostic(tags)) return false;
                if (tags.abi && tags.abi !== abi && !tags.napi) return false;
                if (tags.uv && tags.uv !== uv) return false;
                if (tags.armv && tags.armv !== armv) return false;
                if (tags.libc && tags.libc !== libc) return false;
                return true;
            };
        }
        function runtimeAgnostic(tags) {
            return 'node' === tags.runtime && tags.napi;
        }
        function compareTags(runtime) {
            return function(a, b) {
                if (a.runtime !== b.runtime) return a.runtime === runtime ? -1 : 1;
                if (a.abi !== b.abi) return a.abi ? -1 : 1;
                if (a.specificity !== b.specificity) return a.specificity > b.specificity ? -1 : 1;
                return 0;
            };
        }
        function isNwjs() {
            return !!(process.versions && process.versions.nw);
        }
        function isElectron() {
            if (process.versions && process.versions.electron) return true;
            if (process.env.ELECTRON_RUN_AS_NODE) return true;
            return 'undefined' != typeof window && window.process && 'renderer' === window.process.type;
        }
        function isAlpine(platform) {
            return 'linux' === platform && fs.existsSync('/etc/alpine-release');
        }
        load.parseTags = parseTags;
        load.matchTags = matchTags;
        load.compareTags = compareTags;
        load.parseTuple = parseTuple;
        load.matchTuple = matchTuple;
        load.compareTuples = compareTuples;
    },
    "../../node_modules/utf-8-validate/fallback.js": function(module) {
        "use strict";
        function isValidUTF8(buf) {
            const len = buf.length;
            let i = 0;
            while(i < len)if ((0x80 & buf[i]) === 0x00) i++;
            else if ((0xe0 & buf[i]) === 0xc0) {
                if (i + 1 === len || (0xc0 & buf[i + 1]) !== 0x80 || (0xfe & buf[i]) === 0xc0) return false;
                i += 2;
            } else if ((0xf0 & buf[i]) === 0xe0) {
                if (i + 2 >= len || (0xc0 & buf[i + 1]) !== 0x80 || (0xc0 & buf[i + 2]) !== 0x80 || 0xe0 === buf[i] && (0xe0 & buf[i + 1]) === 0x80 || 0xed === buf[i] && (0xe0 & buf[i + 1]) === 0xa0) return false;
                i += 3;
            } else {
                if ((0xf8 & buf[i]) !== 0xf0) return false;
                if (i + 3 >= len || (0xc0 & buf[i + 1]) !== 0x80 || (0xc0 & buf[i + 2]) !== 0x80 || (0xc0 & buf[i + 3]) !== 0x80 || 0xf0 === buf[i] && (0xf0 & buf[i + 1]) === 0x80 || 0xf4 === buf[i] && buf[i + 1] > 0x8f || buf[i] > 0xf4) return false;
                i += 4;
            }
            return true;
        }
        module.exports = isValidUTF8;
    },
    "../../node_modules/utf-8-validate/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        try {
            module.exports = __webpack_require__("../../node_modules/node-gyp-build/index.js")(__dirname);
        } catch (e) {
            module.exports = __webpack_require__("../../node_modules/utf-8-validate/fallback.js");
        }
    },
    "../agent-interface/dist/agent.mjs": function() {},
    "../agent-interface/dist/index.mjs": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            isStreamingOptions: ()=>isStreamingOptions,
            LogLevel: ()=>dist["in"],
            isAgentRunObjectOptions: ()=>isAgentRunObjectOptions
        });
        __webpack_require__("../agent-interface/dist/agent.mjs");
        var dist = __webpack_require__("../node_modules/.pnpm/@agent-infra+logger@0.0.2-beta.2/node_modules/@agent-infra/logger/dist/index.mjs");
        function isAgentRunObjectOptions(options) {
            return 'string' != typeof options && 'input' in options;
        }
        function isStreamingOptions(options) {
            return true === options.stream;
        }
        var util_util;
        (function(util) {
            util.assertEqual = (_)=>{};
            function assertIs(_arg) {}
            util.assertIs = assertIs;
            function assertNever(_x) {
                throw new Error();
            }
            util.assertNever = assertNever;
            util.arrayToEnum = (items)=>{
                const obj = {};
                for (const item of items)obj[item] = item;
                return obj;
            };
            util.getValidEnumValues = (obj)=>{
                const validKeys = util.objectKeys(obj).filter((k)=>"number" != typeof obj[obj[k]]);
                const filtered = {};
                for (const k of validKeys)filtered[k] = obj[k];
                return util.objectValues(filtered);
            };
            util.objectValues = (obj)=>util.objectKeys(obj).map(function(e) {
                    return obj[e];
                });
            util.objectKeys = "function" == typeof Object.keys ? (obj)=>Object.keys(obj) : (object)=>{
                const keys = [];
                for(const key in object)if (Object.prototype.hasOwnProperty.call(object, key)) keys.push(key);
                return keys;
            };
            util.find = (arr, checker)=>{
                for (const item of arr)if (checker(item)) return item;
            };
            util.isInteger = "function" == typeof Number.isInteger ? (val)=>Number.isInteger(val) : (val)=>"number" == typeof val && Number.isFinite(val) && Math.floor(val) === val;
            function joinValues(array, separator = " | ") {
                return array.map((val)=>"string" == typeof val ? `'${val}'` : val).join(separator);
            }
            util.joinValues = joinValues;
            util.jsonStringifyReplacer = (_, value)=>{
                if ("bigint" == typeof value) return value.toString();
                return value;
            };
        })(util_util || (util_util = {}));
        var util_objectUtil;
        (function(objectUtil) {
            objectUtil.mergeShapes = (first, second)=>({
                    ...first,
                    ...second
                });
        })(util_objectUtil || (util_objectUtil = {}));
        const ZodParsedType = util_util.arrayToEnum([
            "string",
            "nan",
            "number",
            "integer",
            "float",
            "boolean",
            "date",
            "bigint",
            "symbol",
            "function",
            "undefined",
            "null",
            "array",
            "object",
            "unknown",
            "promise",
            "void",
            "never",
            "map",
            "set"
        ]);
        const getParsedType = (data)=>{
            const t = typeof data;
            switch(t){
                case "undefined":
                    return ZodParsedType.undefined;
                case "string":
                    return ZodParsedType.string;
                case "number":
                    return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
                case "boolean":
                    return ZodParsedType.boolean;
                case "function":
                    return ZodParsedType.function;
                case "bigint":
                    return ZodParsedType.bigint;
                case "symbol":
                    return ZodParsedType.symbol;
                case "object":
                    if (Array.isArray(data)) return ZodParsedType.array;
                    if (null === data) return ZodParsedType.null;
                    if (data.then && "function" == typeof data.then && data.catch && "function" == typeof data.catch) return ZodParsedType.promise;
                    if ("undefined" != typeof Map && data instanceof Map) return ZodParsedType.map;
                    if ("undefined" != typeof Set && data instanceof Set) return ZodParsedType.set;
                    if ("undefined" != typeof Date && data instanceof Date) return ZodParsedType.date;
                    return ZodParsedType.object;
                default:
                    return ZodParsedType.unknown;
            }
        };
        const ZodIssueCode = util_util.arrayToEnum([
            "invalid_type",
            "invalid_literal",
            "custom",
            "invalid_union",
            "invalid_union_discriminator",
            "invalid_enum_value",
            "unrecognized_keys",
            "invalid_arguments",
            "invalid_return_type",
            "invalid_date",
            "invalid_string",
            "too_small",
            "too_big",
            "invalid_intersection_types",
            "not_multiple_of",
            "not_finite"
        ]);
        class ZodError extends Error {
            get errors() {
                return this.issues;
            }
            constructor(issues){
                super();
                this.issues = [];
                this.addIssue = (sub)=>{
                    this.issues = [
                        ...this.issues,
                        sub
                    ];
                };
                this.addIssues = (subs = [])=>{
                    this.issues = [
                        ...this.issues,
                        ...subs
                    ];
                };
                const actualProto = new.target.prototype;
                if (Object.setPrototypeOf) Object.setPrototypeOf(this, actualProto);
                else this.__proto__ = actualProto;
                this.name = "ZodError";
                this.issues = issues;
            }
            format(_mapper) {
                const mapper = _mapper || function(issue) {
                    return issue.message;
                };
                const fieldErrors = {
                    _errors: []
                };
                const processError = (error)=>{
                    for (const issue of error.issues)if ("invalid_union" === issue.code) issue.unionErrors.map(processError);
                    else if ("invalid_return_type" === issue.code) processError(issue.returnTypeError);
                    else if ("invalid_arguments" === issue.code) processError(issue.argumentsError);
                    else if (0 === issue.path.length) fieldErrors._errors.push(mapper(issue));
                    else {
                        let curr = fieldErrors;
                        let i = 0;
                        while(i < issue.path.length){
                            const el = issue.path[i];
                            const terminal = i === issue.path.length - 1;
                            if (terminal) {
                                curr[el] = curr[el] || {
                                    _errors: []
                                };
                                curr[el]._errors.push(mapper(issue));
                            } else curr[el] = curr[el] || {
                                _errors: []
                            };
                            curr = curr[el];
                            i++;
                        }
                    }
                };
                processError(this);
                return fieldErrors;
            }
            static assert(value) {
                if (!(value instanceof ZodError)) throw new Error(`Not a ZodError: ${value}`);
            }
            toString() {
                return this.message;
            }
            get message() {
                return JSON.stringify(this.issues, util_util.jsonStringifyReplacer, 2);
            }
            get isEmpty() {
                return 0 === this.issues.length;
            }
            flatten(mapper = (issue)=>issue.message) {
                const fieldErrors = {};
                const formErrors = [];
                for (const sub of this.issues)if (sub.path.length > 0) {
                    fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                    fieldErrors[sub.path[0]].push(mapper(sub));
                } else formErrors.push(mapper(sub));
                return {
                    formErrors,
                    fieldErrors
                };
            }
            get formErrors() {
                return this.flatten();
            }
        }
        ZodError.create = (issues)=>{
            const error = new ZodError(issues);
            return error;
        };
        const en_errorMap = (issue, _ctx)=>{
            let message;
            switch(issue.code){
                case ZodIssueCode.invalid_type:
                    message = issue.received === ZodParsedType.undefined ? "Required" : `Expected ${issue.expected}, received ${issue.received}`;
                    break;
                case ZodIssueCode.invalid_literal:
                    message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_util.jsonStringifyReplacer)}`;
                    break;
                case ZodIssueCode.unrecognized_keys:
                    message = `Unrecognized key(s) in object: ${util_util.joinValues(issue.keys, ", ")}`;
                    break;
                case ZodIssueCode.invalid_union:
                    message = "Invalid input";
                    break;
                case ZodIssueCode.invalid_union_discriminator:
                    message = `Invalid discriminator value. Expected ${util_util.joinValues(issue.options)}`;
                    break;
                case ZodIssueCode.invalid_enum_value:
                    message = `Invalid enum value. Expected ${util_util.joinValues(issue.options)}, received '${issue.received}'`;
                    break;
                case ZodIssueCode.invalid_arguments:
                    message = "Invalid function arguments";
                    break;
                case ZodIssueCode.invalid_return_type:
                    message = "Invalid function return type";
                    break;
                case ZodIssueCode.invalid_date:
                    message = "Invalid date";
                    break;
                case ZodIssueCode.invalid_string:
                    if ("object" == typeof issue.validation) if ("includes" in issue.validation) {
                        message = `Invalid input: must include "${issue.validation.includes}"`;
                        if ("number" == typeof issue.validation.position) message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    } else if ("startsWith" in issue.validation) message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                    else if ("endsWith" in issue.validation) message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                    else util_util.assertNever(issue.validation);
                    else message = "regex" !== issue.validation ? `Invalid ${issue.validation}` : "Invalid";
                    break;
                case ZodIssueCode.too_small:
                    message = "array" === issue.type ? `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? "at least" : "more than"} ${issue.minimum} element(s)` : "string" === issue.type ? `String must contain ${issue.exact ? "exactly" : issue.inclusive ? "at least" : "over"} ${issue.minimum} character(s)` : "number" === issue.type ? `Number must be ${issue.exact ? "exactly equal to " : issue.inclusive ? "greater than or equal to " : "greater than "}${issue.minimum}` : "date" === issue.type ? `Date must be ${issue.exact ? "exactly equal to " : issue.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(issue.minimum))}` : "Invalid input";
                    break;
                case ZodIssueCode.too_big:
                    message = "array" === issue.type ? `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? "at most" : "less than"} ${issue.maximum} element(s)` : "string" === issue.type ? `String must contain ${issue.exact ? "exactly" : issue.inclusive ? "at most" : "under"} ${issue.maximum} character(s)` : "number" === issue.type ? `Number must be ${issue.exact ? "exactly" : issue.inclusive ? "less than or equal to" : "less than"} ${issue.maximum}` : "bigint" === issue.type ? `BigInt must be ${issue.exact ? "exactly" : issue.inclusive ? "less than or equal to" : "less than"} ${issue.maximum}` : "date" === issue.type ? `Date must be ${issue.exact ? "exactly" : issue.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(issue.maximum))}` : "Invalid input";
                    break;
                case ZodIssueCode.custom:
                    message = "Invalid input";
                    break;
                case ZodIssueCode.invalid_intersection_types:
                    message = "Intersection results could not be merged";
                    break;
                case ZodIssueCode.not_multiple_of:
                    message = `Number must be a multiple of ${issue.multipleOf}`;
                    break;
                case ZodIssueCode.not_finite:
                    message = "Number must be finite";
                    break;
                default:
                    message = _ctx.defaultError;
                    util_util.assertNever(issue);
            }
            return {
                message
            };
        };
        const en = en_errorMap;
        let overrideErrorMap = en;
        function getErrorMap() {
            return overrideErrorMap;
        }
        const makeIssue = (params)=>{
            const { data, path, errorMaps, issueData } = params;
            const fullPath = [
                ...path,
                ...issueData.path || []
            ];
            const fullIssue = {
                ...issueData,
                path: fullPath
            };
            if (void 0 !== issueData.message) return {
                ...issueData,
                path: fullPath,
                message: issueData.message
            };
            let errorMessage = "";
            const maps = errorMaps.filter((m)=>!!m).slice().reverse();
            for (const map of maps)errorMessage = map(fullIssue, {
                data,
                defaultError: errorMessage
            }).message;
            return {
                ...issueData,
                path: fullPath,
                message: errorMessage
            };
        };
        function addIssueToContext(ctx, issueData) {
            const overrideMap = getErrorMap();
            const issue = makeIssue({
                issueData: issueData,
                data: ctx.data,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    overrideMap,
                    overrideMap === en ? void 0 : en
                ].filter((x)=>!!x)
            });
            ctx.common.issues.push(issue);
        }
        class ParseStatus {
            constructor(){
                this.value = "valid";
            }
            dirty() {
                if ("valid" === this.value) this.value = "dirty";
            }
            abort() {
                if ("aborted" !== this.value) this.value = "aborted";
            }
            static mergeArray(status, results) {
                const arrayValue = [];
                for (const s of results){
                    if ("aborted" === s.status) return parseUtil_INVALID;
                    if ("dirty" === s.status) status.dirty();
                    arrayValue.push(s.value);
                }
                return {
                    status: status.value,
                    value: arrayValue
                };
            }
            static async mergeObjectAsync(status, pairs) {
                const syncPairs = [];
                for (const pair of pairs){
                    const key = await pair.key;
                    const value = await pair.value;
                    syncPairs.push({
                        key,
                        value
                    });
                }
                return ParseStatus.mergeObjectSync(status, syncPairs);
            }
            static mergeObjectSync(status, pairs) {
                const finalObject = {};
                for (const pair of pairs){
                    const { key, value } = pair;
                    if ("aborted" === key.status) return parseUtil_INVALID;
                    if ("aborted" === value.status) return parseUtil_INVALID;
                    if ("dirty" === key.status) status.dirty();
                    if ("dirty" === value.status) status.dirty();
                    if ("__proto__" !== key.value && (void 0 !== value.value || pair.alwaysSet)) finalObject[key.value] = value.value;
                }
                return {
                    status: status.value,
                    value: finalObject
                };
            }
        }
        const parseUtil_INVALID = Object.freeze({
            status: "aborted"
        });
        const DIRTY = (value)=>({
                status: "dirty",
                value
            });
        const OK = (value)=>({
                status: "valid",
                value
            });
        const isAborted = (x)=>"aborted" === x.status;
        const isDirty = (x)=>"dirty" === x.status;
        const isValid = (x)=>"valid" === x.status;
        const isAsync = (x)=>"undefined" != typeof Promise && x instanceof Promise;
        var errorUtil_errorUtil;
        (function(errorUtil) {
            errorUtil.errToObj = (message)=>"string" == typeof message ? {
                    message
                } : message || {};
            errorUtil.toString = (message)=>"string" == typeof message ? message : message?.message;
        })(errorUtil_errorUtil || (errorUtil_errorUtil = {}));
        class ParseInputLazyPath {
            constructor(parent, value, path, key){
                this._cachedPath = [];
                this.parent = parent;
                this.data = value;
                this._path = path;
                this._key = key;
            }
            get path() {
                if (!this._cachedPath.length) if (Array.isArray(this._key)) this._cachedPath.push(...this._path, ...this._key);
                else this._cachedPath.push(...this._path, this._key);
                return this._cachedPath;
            }
        }
        const handleResult = (ctx, result)=>{
            if (isValid(result)) return {
                success: true,
                data: result.value
            };
            if (!ctx.common.issues.length) throw new Error("Validation failed but no issues detected.");
            return {
                success: false,
                get error () {
                    if (this._error) return this._error;
                    const error = new ZodError(ctx.common.issues);
                    this._error = error;
                    return this._error;
                }
            };
        };
        function processCreateParams(params) {
            if (!params) return {};
            const { errorMap, invalid_type_error, required_error, description } = params;
            if (errorMap && (invalid_type_error || required_error)) throw new Error('Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.');
            if (errorMap) return {
                errorMap: errorMap,
                description
            };
            const customMap = (iss, ctx)=>{
                const { message } = params;
                if ("invalid_enum_value" === iss.code) return {
                    message: message ?? ctx.defaultError
                };
                if (void 0 === ctx.data) return {
                    message: message ?? required_error ?? ctx.defaultError
                };
                if ("invalid_type" !== iss.code) return {
                    message: ctx.defaultError
                };
                return {
                    message: message ?? invalid_type_error ?? ctx.defaultError
                };
            };
            return {
                errorMap: customMap,
                description
            };
        }
        class ZodType {
            get description() {
                return this._def.description;
            }
            _getType(input) {
                return getParsedType(input.data);
            }
            _getOrReturnCtx(input, ctx) {
                return ctx || {
                    common: input.parent.common,
                    data: input.data,
                    parsedType: getParsedType(input.data),
                    schemaErrorMap: this._def.errorMap,
                    path: input.path,
                    parent: input.parent
                };
            }
            _processInputParams(input) {
                return {
                    status: new ParseStatus(),
                    ctx: {
                        common: input.parent.common,
                        data: input.data,
                        parsedType: getParsedType(input.data),
                        schemaErrorMap: this._def.errorMap,
                        path: input.path,
                        parent: input.parent
                    }
                };
            }
            _parseSync(input) {
                const result = this._parse(input);
                if (isAsync(result)) throw new Error("Synchronous parse encountered promise.");
                return result;
            }
            _parseAsync(input) {
                const result = this._parse(input);
                return Promise.resolve(result);
            }
            parse(data, params) {
                const result = this.safeParse(data, params);
                if (result.success) return result.data;
                throw result.error;
            }
            safeParse(data, params) {
                const ctx = {
                    common: {
                        issues: [],
                        async: params?.async ?? false,
                        contextualErrorMap: params?.errorMap
                    },
                    path: params?.path || [],
                    schemaErrorMap: this._def.errorMap,
                    parent: null,
                    data,
                    parsedType: getParsedType(data)
                };
                const result = this._parseSync({
                    data,
                    path: ctx.path,
                    parent: ctx
                });
                return handleResult(ctx, result);
            }
            "~validate"(data) {
                const ctx = {
                    common: {
                        issues: [],
                        async: !!this["~standard"].async
                    },
                    path: [],
                    schemaErrorMap: this._def.errorMap,
                    parent: null,
                    data,
                    parsedType: getParsedType(data)
                };
                if (!this["~standard"].async) try {
                    const result = this._parseSync({
                        data,
                        path: [],
                        parent: ctx
                    });
                    return isValid(result) ? {
                        value: result.value
                    } : {
                        issues: ctx.common.issues
                    };
                } catch (err) {
                    if (err?.message?.toLowerCase()?.includes("encountered")) this["~standard"].async = true;
                    ctx.common = {
                        issues: [],
                        async: true
                    };
                }
                return this._parseAsync({
                    data,
                    path: [],
                    parent: ctx
                }).then((result)=>isValid(result) ? {
                        value: result.value
                    } : {
                        issues: ctx.common.issues
                    });
            }
            async parseAsync(data, params) {
                const result = await this.safeParseAsync(data, params);
                if (result.success) return result.data;
                throw result.error;
            }
            async safeParseAsync(data, params) {
                const ctx = {
                    common: {
                        issues: [],
                        contextualErrorMap: params?.errorMap,
                        async: true
                    },
                    path: params?.path || [],
                    schemaErrorMap: this._def.errorMap,
                    parent: null,
                    data,
                    parsedType: getParsedType(data)
                };
                const maybeAsyncResult = this._parse({
                    data,
                    path: ctx.path,
                    parent: ctx
                });
                const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
                return handleResult(ctx, result);
            }
            refine(check, message) {
                const getIssueProperties = (val)=>{
                    if ("string" == typeof message || void 0 === message) return {
                        message
                    };
                    if ("function" == typeof message) return message(val);
                    return message;
                };
                return this._refinement((val, ctx)=>{
                    const result = check(val);
                    const setError = ()=>ctx.addIssue({
                            code: ZodIssueCode.custom,
                            ...getIssueProperties(val)
                        });
                    if ("undefined" != typeof Promise && result instanceof Promise) return result.then((data)=>{
                        if (data) return true;
                        setError();
                        return false;
                    });
                    if (result) return true;
                    setError();
                    return false;
                });
            }
            refinement(check, refinementData) {
                return this._refinement((val, ctx)=>{
                    if (check(val)) return true;
                    ctx.addIssue("function" == typeof refinementData ? refinementData(val, ctx) : refinementData);
                    return false;
                });
            }
            _refinement(refinement) {
                return new ZodEffects({
                    schema: this,
                    typeName: types_ZodFirstPartyTypeKind.ZodEffects,
                    effect: {
                        type: "refinement",
                        refinement
                    }
                });
            }
            superRefine(refinement) {
                return this._refinement(refinement);
            }
            constructor(def){
                this.spa = this.safeParseAsync;
                this._def = def;
                this.parse = this.parse.bind(this);
                this.safeParse = this.safeParse.bind(this);
                this.parseAsync = this.parseAsync.bind(this);
                this.safeParseAsync = this.safeParseAsync.bind(this);
                this.spa = this.spa.bind(this);
                this.refine = this.refine.bind(this);
                this.refinement = this.refinement.bind(this);
                this.superRefine = this.superRefine.bind(this);
                this.optional = this.optional.bind(this);
                this.nullable = this.nullable.bind(this);
                this.nullish = this.nullish.bind(this);
                this.array = this.array.bind(this);
                this.promise = this.promise.bind(this);
                this.or = this.or.bind(this);
                this.and = this.and.bind(this);
                this.transform = this.transform.bind(this);
                this.brand = this.brand.bind(this);
                this.default = this.default.bind(this);
                this.catch = this.catch.bind(this);
                this.describe = this.describe.bind(this);
                this.pipe = this.pipe.bind(this);
                this.readonly = this.readonly.bind(this);
                this.isNullable = this.isNullable.bind(this);
                this.isOptional = this.isOptional.bind(this);
                this["~standard"] = {
                    version: 1,
                    vendor: "zod",
                    validate: (data)=>this["~validate"](data)
                };
            }
            optional() {
                return ZodOptional.create(this, this._def);
            }
            nullable() {
                return ZodNullable.create(this, this._def);
            }
            nullish() {
                return this.nullable().optional();
            }
            array() {
                return ZodArray.create(this);
            }
            promise() {
                return ZodPromise.create(this, this._def);
            }
            or(option) {
                return ZodUnion.create([
                    this,
                    option
                ], this._def);
            }
            and(incoming) {
                return ZodIntersection.create(this, incoming, this._def);
            }
            transform(transform) {
                return new ZodEffects({
                    ...processCreateParams(this._def),
                    schema: this,
                    typeName: types_ZodFirstPartyTypeKind.ZodEffects,
                    effect: {
                        type: "transform",
                        transform
                    }
                });
            }
            default(def) {
                const defaultValueFunc = "function" == typeof def ? def : ()=>def;
                return new ZodDefault({
                    ...processCreateParams(this._def),
                    innerType: this,
                    defaultValue: defaultValueFunc,
                    typeName: types_ZodFirstPartyTypeKind.ZodDefault
                });
            }
            brand() {
                return new ZodBranded({
                    typeName: types_ZodFirstPartyTypeKind.ZodBranded,
                    type: this,
                    ...processCreateParams(this._def)
                });
            }
            catch(def) {
                const catchValueFunc = "function" == typeof def ? def : ()=>def;
                return new ZodCatch({
                    ...processCreateParams(this._def),
                    innerType: this,
                    catchValue: catchValueFunc,
                    typeName: types_ZodFirstPartyTypeKind.ZodCatch
                });
            }
            describe(description) {
                const This = this.constructor;
                return new This({
                    ...this._def,
                    description
                });
            }
            pipe(target) {
                return ZodPipeline.create(this, target);
            }
            readonly() {
                return ZodReadonly.create(this);
            }
            isOptional() {
                return this.safeParse(void 0).success;
            }
            isNullable() {
                return this.safeParse(null).success;
            }
        }
        const cuidRegex = /^c[^\s-]{8,}$/i;
        const cuid2Regex = /^[0-9a-z]+$/;
        const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
        const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
        const nanoidRegex = /^[a-z0-9_-]{21}$/i;
        const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
        const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
        const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
        const _emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
        let emojiRegex;
        const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
        const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
        const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
        const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
        const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
        const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
        const dateRegexSource = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))";
        const dateRegex = new RegExp(`^${dateRegexSource}$`);
        function timeRegexSource(args) {
            let secondsRegexSource = "[0-5]\\d";
            if (args.precision) secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
            else if (null == args.precision) secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
            const secondsQuantifier = args.precision ? "+" : "?";
            return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
        }
        function timeRegex(args) {
            return new RegExp(`^${timeRegexSource(args)}$`);
        }
        function datetimeRegex(args) {
            let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
            const opts = [];
            opts.push(args.local ? "Z?" : "Z");
            if (args.offset) opts.push("([+-]\\d{2}:?\\d{2})");
            regex = `${regex}(${opts.join("|")})`;
            return new RegExp(`^${regex}$`);
        }
        function isValidIP(ip, version) {
            if (("v4" === version || !version) && ipv4Regex.test(ip)) return true;
            if (("v6" === version || !version) && ipv6Regex.test(ip)) return true;
            return false;
        }
        function isValidJWT(jwt, alg) {
            if (!jwtRegex.test(jwt)) return false;
            try {
                const [header] = jwt.split(".");
                const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
                const decoded = JSON.parse(atob(base64));
                if ("object" != typeof decoded || null === decoded) return false;
                if ("typ" in decoded && decoded?.typ !== "JWT") return false;
                if (!decoded.alg) return false;
                if (alg && decoded.alg !== alg) return false;
                return true;
            } catch  {
                return false;
            }
        }
        function isValidCidr(ip, version) {
            if (("v4" === version || !version) && ipv4CidrRegex.test(ip)) return true;
            if (("v6" === version || !version) && ipv6CidrRegex.test(ip)) return true;
            return false;
        }
        class ZodString extends ZodType {
            _parse(input) {
                if (this._def.coerce) input.data = String(input.data);
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.string) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.string,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                const status = new ParseStatus();
                let ctx;
                for (const check of this._def.checks)if ("min" === check.kind) {
                    if (input.data.length < check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: false,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("max" === check.kind) {
                    if (input.data.length > check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: false,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("length" === check.kind) {
                    const tooBig = input.data.length > check.value;
                    const tooSmall = input.data.length < check.value;
                    if (tooBig || tooSmall) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        if (tooBig) addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message
                        });
                        else if (tooSmall) addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("email" === check.kind) {
                    if (!emailRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "email",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("emoji" === check.kind) {
                    if (!emojiRegex) emojiRegex = new RegExp(_emojiRegex, "u");
                    if (!emojiRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "emoji",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("uuid" === check.kind) {
                    if (!uuidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "uuid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("nanoid" === check.kind) {
                    if (!nanoidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "nanoid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("cuid" === check.kind) {
                    if (!cuidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "cuid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("cuid2" === check.kind) {
                    if (!cuid2Regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "cuid2",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("ulid" === check.kind) {
                    if (!ulidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "ulid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("url" === check.kind) try {
                    new URL(input.data);
                } catch  {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
                else if ("regex" === check.kind) {
                    check.regex.lastIndex = 0;
                    const testResult = check.regex.test(input.data);
                    if (!testResult) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "regex",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("trim" === check.kind) input.data = input.data.trim();
                else if ("includes" === check.kind) {
                    if (!input.data.includes(check.value, check.position)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: {
                                includes: check.value,
                                position: check.position
                            },
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("toLowerCase" === check.kind) input.data = input.data.toLowerCase();
                else if ("toUpperCase" === check.kind) input.data = input.data.toUpperCase();
                else if ("startsWith" === check.kind) {
                    if (!input.data.startsWith(check.value)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: {
                                startsWith: check.value
                            },
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("endsWith" === check.kind) {
                    if (!input.data.endsWith(check.value)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: {
                                endsWith: check.value
                            },
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("datetime" === check.kind) {
                    const regex = datetimeRegex(check);
                    if (!regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: "datetime",
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("date" === check.kind) {
                    const regex = dateRegex;
                    if (!regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: "date",
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("time" === check.kind) {
                    const regex = timeRegex(check);
                    if (!regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: "time",
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("duration" === check.kind) {
                    if (!durationRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "duration",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("ip" === check.kind) {
                    if (!isValidIP(input.data, check.version)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "ip",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("jwt" === check.kind) {
                    if (!isValidJWT(input.data, check.alg)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "jwt",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("cidr" === check.kind) {
                    if (!isValidCidr(input.data, check.version)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "cidr",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("base64" === check.kind) {
                    if (!base64Regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "base64",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("base64url" === check.kind) {
                    if (!base64urlRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "base64url",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else util_util.assertNever(check);
                return {
                    status: status.value,
                    value: input.data
                };
            }
            _regex(regex, validation, message) {
                return this.refinement((data)=>regex.test(data), {
                    validation,
                    code: ZodIssueCode.invalid_string,
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            _addCheck(check) {
                return new ZodString({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        check
                    ]
                });
            }
            email(message) {
                return this._addCheck({
                    kind: "email",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            url(message) {
                return this._addCheck({
                    kind: "url",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            emoji(message) {
                return this._addCheck({
                    kind: "emoji",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            uuid(message) {
                return this._addCheck({
                    kind: "uuid",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            nanoid(message) {
                return this._addCheck({
                    kind: "nanoid",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            cuid(message) {
                return this._addCheck({
                    kind: "cuid",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            cuid2(message) {
                return this._addCheck({
                    kind: "cuid2",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            ulid(message) {
                return this._addCheck({
                    kind: "ulid",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            base64(message) {
                return this._addCheck({
                    kind: "base64",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            base64url(message) {
                return this._addCheck({
                    kind: "base64url",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            jwt(options) {
                return this._addCheck({
                    kind: "jwt",
                    ...errorUtil_errorUtil.errToObj(options)
                });
            }
            ip(options) {
                return this._addCheck({
                    kind: "ip",
                    ...errorUtil_errorUtil.errToObj(options)
                });
            }
            cidr(options) {
                return this._addCheck({
                    kind: "cidr",
                    ...errorUtil_errorUtil.errToObj(options)
                });
            }
            datetime(options) {
                if ("string" == typeof options) return this._addCheck({
                    kind: "datetime",
                    precision: null,
                    offset: false,
                    local: false,
                    message: options
                });
                return this._addCheck({
                    kind: "datetime",
                    precision: void 0 === options?.precision ? null : options?.precision,
                    offset: options?.offset ?? false,
                    local: options?.local ?? false,
                    ...errorUtil_errorUtil.errToObj(options?.message)
                });
            }
            date(message) {
                return this._addCheck({
                    kind: "date",
                    message
                });
            }
            time(options) {
                if ("string" == typeof options) return this._addCheck({
                    kind: "time",
                    precision: null,
                    message: options
                });
                return this._addCheck({
                    kind: "time",
                    precision: void 0 === options?.precision ? null : options?.precision,
                    ...errorUtil_errorUtil.errToObj(options?.message)
                });
            }
            duration(message) {
                return this._addCheck({
                    kind: "duration",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            regex(regex, message) {
                return this._addCheck({
                    kind: "regex",
                    regex: regex,
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            includes(value, options) {
                return this._addCheck({
                    kind: "includes",
                    value: value,
                    position: options?.position,
                    ...errorUtil_errorUtil.errToObj(options?.message)
                });
            }
            startsWith(value, message) {
                return this._addCheck({
                    kind: "startsWith",
                    value: value,
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            endsWith(value, message) {
                return this._addCheck({
                    kind: "endsWith",
                    value: value,
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            min(minLength, message) {
                return this._addCheck({
                    kind: "min",
                    value: minLength,
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            max(maxLength, message) {
                return this._addCheck({
                    kind: "max",
                    value: maxLength,
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            length(len, message) {
                return this._addCheck({
                    kind: "length",
                    value: len,
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            nonempty(message) {
                return this.min(1, errorUtil_errorUtil.errToObj(message));
            }
            trim() {
                return new ZodString({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        {
                            kind: "trim"
                        }
                    ]
                });
            }
            toLowerCase() {
                return new ZodString({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        {
                            kind: "toLowerCase"
                        }
                    ]
                });
            }
            toUpperCase() {
                return new ZodString({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        {
                            kind: "toUpperCase"
                        }
                    ]
                });
            }
            get isDatetime() {
                return !!this._def.checks.find((ch)=>"datetime" === ch.kind);
            }
            get isDate() {
                return !!this._def.checks.find((ch)=>"date" === ch.kind);
            }
            get isTime() {
                return !!this._def.checks.find((ch)=>"time" === ch.kind);
            }
            get isDuration() {
                return !!this._def.checks.find((ch)=>"duration" === ch.kind);
            }
            get isEmail() {
                return !!this._def.checks.find((ch)=>"email" === ch.kind);
            }
            get isURL() {
                return !!this._def.checks.find((ch)=>"url" === ch.kind);
            }
            get isEmoji() {
                return !!this._def.checks.find((ch)=>"emoji" === ch.kind);
            }
            get isUUID() {
                return !!this._def.checks.find((ch)=>"uuid" === ch.kind);
            }
            get isNANOID() {
                return !!this._def.checks.find((ch)=>"nanoid" === ch.kind);
            }
            get isCUID() {
                return !!this._def.checks.find((ch)=>"cuid" === ch.kind);
            }
            get isCUID2() {
                return !!this._def.checks.find((ch)=>"cuid2" === ch.kind);
            }
            get isULID() {
                return !!this._def.checks.find((ch)=>"ulid" === ch.kind);
            }
            get isIP() {
                return !!this._def.checks.find((ch)=>"ip" === ch.kind);
            }
            get isCIDR() {
                return !!this._def.checks.find((ch)=>"cidr" === ch.kind);
            }
            get isBase64() {
                return !!this._def.checks.find((ch)=>"base64" === ch.kind);
            }
            get isBase64url() {
                return !!this._def.checks.find((ch)=>"base64url" === ch.kind);
            }
            get minLength() {
                let min = null;
                for (const ch of this._def.checks)if ("min" === ch.kind) {
                    if (null === min || ch.value > min) min = ch.value;
                }
                return min;
            }
            get maxLength() {
                let max = null;
                for (const ch of this._def.checks)if ("max" === ch.kind) {
                    if (null === max || ch.value < max) max = ch.value;
                }
                return max;
            }
        }
        ZodString.create = (params)=>new ZodString({
                checks: [],
                typeName: types_ZodFirstPartyTypeKind.ZodString,
                coerce: params?.coerce ?? false,
                ...processCreateParams(params)
            });
        function floatSafeRemainder(val, step) {
            const valDecCount = (val.toString().split(".")[1] || "").length;
            const stepDecCount = (step.toString().split(".")[1] || "").length;
            const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
            const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
            const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
            return valInt % stepInt / 10 ** decCount;
        }
        class ZodNumber extends ZodType {
            constructor(){
                super(...arguments);
                this.min = this.gte;
                this.max = this.lte;
                this.step = this.multipleOf;
            }
            _parse(input) {
                if (this._def.coerce) input.data = Number(input.data);
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.number) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.number,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                let ctx;
                const status = new ParseStatus();
                for (const check of this._def.checks)if ("int" === check.kind) {
                    if (!util_util.isInteger(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_type,
                            expected: "integer",
                            received: "float",
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("min" === check.kind) {
                    const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                    if (tooSmall) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "number",
                            inclusive: check.inclusive,
                            exact: false,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("max" === check.kind) {
                    const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                    if (tooBig) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "number",
                            inclusive: check.inclusive,
                            exact: false,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("multipleOf" === check.kind) {
                    if (0 !== floatSafeRemainder(input.data, check.value)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.not_multiple_of,
                            multipleOf: check.value,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("finite" === check.kind) {
                    if (!Number.isFinite(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.not_finite,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else util_util.assertNever(check);
                return {
                    status: status.value,
                    value: input.data
                };
            }
            gte(value, message) {
                return this.setLimit("min", value, true, errorUtil_errorUtil.toString(message));
            }
            gt(value, message) {
                return this.setLimit("min", value, false, errorUtil_errorUtil.toString(message));
            }
            lte(value, message) {
                return this.setLimit("max", value, true, errorUtil_errorUtil.toString(message));
            }
            lt(value, message) {
                return this.setLimit("max", value, false, errorUtil_errorUtil.toString(message));
            }
            setLimit(kind, value, inclusive, message) {
                return new ZodNumber({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        {
                            kind,
                            value,
                            inclusive,
                            message: errorUtil_errorUtil.toString(message)
                        }
                    ]
                });
            }
            _addCheck(check) {
                return new ZodNumber({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        check
                    ]
                });
            }
            int(message) {
                return this._addCheck({
                    kind: "int",
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            positive(message) {
                return this._addCheck({
                    kind: "min",
                    value: 0,
                    inclusive: false,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            negative(message) {
                return this._addCheck({
                    kind: "max",
                    value: 0,
                    inclusive: false,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            nonpositive(message) {
                return this._addCheck({
                    kind: "max",
                    value: 0,
                    inclusive: true,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            nonnegative(message) {
                return this._addCheck({
                    kind: "min",
                    value: 0,
                    inclusive: true,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            multipleOf(value, message) {
                return this._addCheck({
                    kind: "multipleOf",
                    value: value,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            finite(message) {
                return this._addCheck({
                    kind: "finite",
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            safe(message) {
                return this._addCheck({
                    kind: "min",
                    inclusive: true,
                    value: Number.MIN_SAFE_INTEGER,
                    message: errorUtil_errorUtil.toString(message)
                })._addCheck({
                    kind: "max",
                    inclusive: true,
                    value: Number.MAX_SAFE_INTEGER,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            get minValue() {
                let min = null;
                for (const ch of this._def.checks)if ("min" === ch.kind) {
                    if (null === min || ch.value > min) min = ch.value;
                }
                return min;
            }
            get maxValue() {
                let max = null;
                for (const ch of this._def.checks)if ("max" === ch.kind) {
                    if (null === max || ch.value < max) max = ch.value;
                }
                return max;
            }
            get isInt() {
                return !!this._def.checks.find((ch)=>"int" === ch.kind || "multipleOf" === ch.kind && util_util.isInteger(ch.value));
            }
            get isFinite() {
                let max = null;
                let min = null;
                for (const ch of this._def.checks)if ("finite" === ch.kind || "int" === ch.kind || "multipleOf" === ch.kind) return true;
                else if ("min" === ch.kind) {
                    if (null === min || ch.value > min) min = ch.value;
                } else if ("max" === ch.kind) {
                    if (null === max || ch.value < max) max = ch.value;
                }
                return Number.isFinite(min) && Number.isFinite(max);
            }
        }
        ZodNumber.create = (params)=>new ZodNumber({
                checks: [],
                typeName: types_ZodFirstPartyTypeKind.ZodNumber,
                coerce: params?.coerce || false,
                ...processCreateParams(params)
            });
        class ZodBigInt extends ZodType {
            constructor(){
                super(...arguments);
                this.min = this.gte;
                this.max = this.lte;
            }
            _parse(input) {
                if (this._def.coerce) try {
                    input.data = BigInt(input.data);
                } catch  {
                    return this._getInvalidInput(input);
                }
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.bigint) return this._getInvalidInput(input);
                let ctx;
                const status = new ParseStatus();
                for (const check of this._def.checks)if ("min" === check.kind) {
                    const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                    if (tooSmall) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            type: "bigint",
                            minimum: check.value,
                            inclusive: check.inclusive,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("max" === check.kind) {
                    const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                    if (tooBig) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            type: "bigint",
                            maximum: check.value,
                            inclusive: check.inclusive,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("multipleOf" === check.kind) {
                    if (input.data % check.value !== BigInt(0)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.not_multiple_of,
                            multipleOf: check.value,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else util_util.assertNever(check);
                return {
                    status: status.value,
                    value: input.data
                };
            }
            _getInvalidInput(input) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.bigint,
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
            gte(value, message) {
                return this.setLimit("min", value, true, errorUtil_errorUtil.toString(message));
            }
            gt(value, message) {
                return this.setLimit("min", value, false, errorUtil_errorUtil.toString(message));
            }
            lte(value, message) {
                return this.setLimit("max", value, true, errorUtil_errorUtil.toString(message));
            }
            lt(value, message) {
                return this.setLimit("max", value, false, errorUtil_errorUtil.toString(message));
            }
            setLimit(kind, value, inclusive, message) {
                return new ZodBigInt({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        {
                            kind,
                            value,
                            inclusive,
                            message: errorUtil_errorUtil.toString(message)
                        }
                    ]
                });
            }
            _addCheck(check) {
                return new ZodBigInt({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        check
                    ]
                });
            }
            positive(message) {
                return this._addCheck({
                    kind: "min",
                    value: BigInt(0),
                    inclusive: false,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            negative(message) {
                return this._addCheck({
                    kind: "max",
                    value: BigInt(0),
                    inclusive: false,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            nonpositive(message) {
                return this._addCheck({
                    kind: "max",
                    value: BigInt(0),
                    inclusive: true,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            nonnegative(message) {
                return this._addCheck({
                    kind: "min",
                    value: BigInt(0),
                    inclusive: true,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            multipleOf(value, message) {
                return this._addCheck({
                    kind: "multipleOf",
                    value,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            get minValue() {
                let min = null;
                for (const ch of this._def.checks)if ("min" === ch.kind) {
                    if (null === min || ch.value > min) min = ch.value;
                }
                return min;
            }
            get maxValue() {
                let max = null;
                for (const ch of this._def.checks)if ("max" === ch.kind) {
                    if (null === max || ch.value < max) max = ch.value;
                }
                return max;
            }
        }
        ZodBigInt.create = (params)=>new ZodBigInt({
                checks: [],
                typeName: types_ZodFirstPartyTypeKind.ZodBigInt,
                coerce: params?.coerce ?? false,
                ...processCreateParams(params)
            });
        class ZodBoolean extends ZodType {
            _parse(input) {
                if (this._def.coerce) input.data = Boolean(input.data);
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.boolean) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.boolean,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                return OK(input.data);
            }
        }
        ZodBoolean.create = (params)=>new ZodBoolean({
                typeName: types_ZodFirstPartyTypeKind.ZodBoolean,
                coerce: params?.coerce || false,
                ...processCreateParams(params)
            });
        class ZodDate extends ZodType {
            _parse(input) {
                if (this._def.coerce) input.data = new Date(input.data);
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.date) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.date,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                if (Number.isNaN(input.data.getTime())) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_date
                    });
                    return parseUtil_INVALID;
                }
                const status = new ParseStatus();
                let ctx;
                for (const check of this._def.checks)if ("min" === check.kind) {
                    if (input.data.getTime() < check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            message: check.message,
                            inclusive: true,
                            exact: false,
                            minimum: check.value,
                            type: "date"
                        });
                        status.dirty();
                    }
                } else if ("max" === check.kind) {
                    if (input.data.getTime() > check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            message: check.message,
                            inclusive: true,
                            exact: false,
                            maximum: check.value,
                            type: "date"
                        });
                        status.dirty();
                    }
                } else util_util.assertNever(check);
                return {
                    status: status.value,
                    value: new Date(input.data.getTime())
                };
            }
            _addCheck(check) {
                return new ZodDate({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        check
                    ]
                });
            }
            min(minDate, message) {
                return this._addCheck({
                    kind: "min",
                    value: minDate.getTime(),
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            max(maxDate, message) {
                return this._addCheck({
                    kind: "max",
                    value: maxDate.getTime(),
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            get minDate() {
                let min = null;
                for (const ch of this._def.checks)if ("min" === ch.kind) {
                    if (null === min || ch.value > min) min = ch.value;
                }
                return null != min ? new Date(min) : null;
            }
            get maxDate() {
                let max = null;
                for (const ch of this._def.checks)if ("max" === ch.kind) {
                    if (null === max || ch.value < max) max = ch.value;
                }
                return null != max ? new Date(max) : null;
            }
        }
        ZodDate.create = (params)=>new ZodDate({
                checks: [],
                coerce: params?.coerce || false,
                typeName: types_ZodFirstPartyTypeKind.ZodDate,
                ...processCreateParams(params)
            });
        class ZodSymbol extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.symbol) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.symbol,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                return OK(input.data);
            }
        }
        ZodSymbol.create = (params)=>new ZodSymbol({
                typeName: types_ZodFirstPartyTypeKind.ZodSymbol,
                ...processCreateParams(params)
            });
        class ZodUndefined extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.undefined) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.undefined,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                return OK(input.data);
            }
        }
        ZodUndefined.create = (params)=>new ZodUndefined({
                typeName: types_ZodFirstPartyTypeKind.ZodUndefined,
                ...processCreateParams(params)
            });
        class ZodNull extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType["null"]) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType["null"],
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                return OK(input.data);
            }
        }
        ZodNull.create = (params)=>new ZodNull({
                typeName: types_ZodFirstPartyTypeKind.ZodNull,
                ...processCreateParams(params)
            });
        class ZodAny extends ZodType {
            constructor(){
                super(...arguments);
                this._any = true;
            }
            _parse(input) {
                return OK(input.data);
            }
        }
        ZodAny.create = (params)=>new ZodAny({
                typeName: types_ZodFirstPartyTypeKind.ZodAny,
                ...processCreateParams(params)
            });
        class ZodUnknown extends ZodType {
            constructor(){
                super(...arguments);
                this._unknown = true;
            }
            _parse(input) {
                return OK(input.data);
            }
        }
        ZodUnknown.create = (params)=>new ZodUnknown({
                typeName: types_ZodFirstPartyTypeKind.ZodUnknown,
                ...processCreateParams(params)
            });
        class ZodNever extends ZodType {
            _parse(input) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.never,
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
        }
        ZodNever.create = (params)=>new ZodNever({
                typeName: types_ZodFirstPartyTypeKind.ZodNever,
                ...processCreateParams(params)
            });
        class ZodVoid extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.undefined) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType["void"],
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                return OK(input.data);
            }
        }
        ZodVoid.create = (params)=>new ZodVoid({
                typeName: types_ZodFirstPartyTypeKind.ZodVoid,
                ...processCreateParams(params)
            });
        class ZodArray extends ZodType {
            _parse(input) {
                const { ctx, status } = this._processInputParams(input);
                const def = this._def;
                if (ctx.parsedType !== ZodParsedType.array) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.array,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                if (null !== def.exactLength) {
                    const tooBig = ctx.data.length > def.exactLength.value;
                    const tooSmall = ctx.data.length < def.exactLength.value;
                    if (tooBig || tooSmall) {
                        addIssueToContext(ctx, {
                            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                            minimum: tooSmall ? def.exactLength.value : void 0,
                            maximum: tooBig ? def.exactLength.value : void 0,
                            type: "array",
                            inclusive: true,
                            exact: true,
                            message: def.exactLength.message
                        });
                        status.dirty();
                    }
                }
                if (null !== def.minLength) {
                    if (ctx.data.length < def.minLength.value) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: def.minLength.value,
                            type: "array",
                            inclusive: true,
                            exact: false,
                            message: def.minLength.message
                        });
                        status.dirty();
                    }
                }
                if (null !== def.maxLength) {
                    if (ctx.data.length > def.maxLength.value) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: def.maxLength.value,
                            type: "array",
                            inclusive: true,
                            exact: false,
                            message: def.maxLength.message
                        });
                        status.dirty();
                    }
                }
                if (ctx.common.async) return Promise.all([
                    ...ctx.data
                ].map((item, i)=>def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i)))).then((result)=>ParseStatus.mergeArray(status, result));
                const result = [
                    ...ctx.data
                ].map((item, i)=>def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i)));
                return ParseStatus.mergeArray(status, result);
            }
            get element() {
                return this._def.type;
            }
            min(minLength, message) {
                return new ZodArray({
                    ...this._def,
                    minLength: {
                        value: minLength,
                        message: errorUtil_errorUtil.toString(message)
                    }
                });
            }
            max(maxLength, message) {
                return new ZodArray({
                    ...this._def,
                    maxLength: {
                        value: maxLength,
                        message: errorUtil_errorUtil.toString(message)
                    }
                });
            }
            length(len, message) {
                return new ZodArray({
                    ...this._def,
                    exactLength: {
                        value: len,
                        message: errorUtil_errorUtil.toString(message)
                    }
                });
            }
            nonempty(message) {
                return this.min(1, message);
            }
        }
        ZodArray.create = (schema, params)=>new ZodArray({
                type: schema,
                minLength: null,
                maxLength: null,
                exactLength: null,
                typeName: types_ZodFirstPartyTypeKind.ZodArray,
                ...processCreateParams(params)
            });
        function deepPartialify(schema) {
            if (schema instanceof ZodObject) {
                const newShape = {};
                for(const key in schema.shape){
                    const fieldSchema = schema.shape[key];
                    newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
                }
                return new ZodObject({
                    ...schema._def,
                    shape: ()=>newShape
                });
            }
            if (schema instanceof ZodArray) return new ZodArray({
                ...schema._def,
                type: deepPartialify(schema.element)
            });
            if (schema instanceof ZodOptional) return ZodOptional.create(deepPartialify(schema.unwrap()));
            if (schema instanceof ZodNullable) return ZodNullable.create(deepPartialify(schema.unwrap()));
            if (schema instanceof ZodTuple) return ZodTuple.create(schema.items.map((item)=>deepPartialify(item)));
            else return schema;
        }
        class ZodObject extends ZodType {
            constructor(){
                super(...arguments);
                this._cached = null;
                this.nonstrict = this.passthrough;
                this.augment = this.extend;
            }
            _getCached() {
                if (null !== this._cached) return this._cached;
                const shape = this._def.shape();
                const keys = util_util.objectKeys(shape);
                this._cached = {
                    shape,
                    keys
                };
                return this._cached;
            }
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.object) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.object,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                const { status, ctx } = this._processInputParams(input);
                const { shape, keys: shapeKeys } = this._getCached();
                const extraKeys = [];
                if (!(this._def.catchall instanceof ZodNever && "strip" === this._def.unknownKeys)) {
                    for(const key in ctx.data)if (!shapeKeys.includes(key)) extraKeys.push(key);
                }
                const pairs = [];
                for (const key of shapeKeys){
                    const keyValidator = shape[key];
                    const value = ctx.data[key];
                    pairs.push({
                        key: {
                            status: "valid",
                            value: key
                        },
                        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                        alwaysSet: key in ctx.data
                    });
                }
                if (this._def.catchall instanceof ZodNever) {
                    const unknownKeys = this._def.unknownKeys;
                    if ("passthrough" === unknownKeys) for (const key of extraKeys)pairs.push({
                        key: {
                            status: "valid",
                            value: key
                        },
                        value: {
                            status: "valid",
                            value: ctx.data[key]
                        }
                    });
                    else if ("strict" === unknownKeys) {
                        if (extraKeys.length > 0) {
                            addIssueToContext(ctx, {
                                code: ZodIssueCode.unrecognized_keys,
                                keys: extraKeys
                            });
                            status.dirty();
                        }
                    } else if ("strip" === unknownKeys) ;
                    else throw new Error("Internal ZodObject error: invalid unknownKeys value.");
                } else {
                    const catchall = this._def.catchall;
                    for (const key of extraKeys){
                        const value = ctx.data[key];
                        pairs.push({
                            key: {
                                status: "valid",
                                value: key
                            },
                            value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                            alwaysSet: key in ctx.data
                        });
                    }
                }
                if (ctx.common.async) return Promise.resolve().then(async ()=>{
                    const syncPairs = [];
                    for (const pair of pairs){
                        const key = await pair.key;
                        const value = await pair.value;
                        syncPairs.push({
                            key,
                            value,
                            alwaysSet: pair.alwaysSet
                        });
                    }
                    return syncPairs;
                }).then((syncPairs)=>ParseStatus.mergeObjectSync(status, syncPairs));
                return ParseStatus.mergeObjectSync(status, pairs);
            }
            get shape() {
                return this._def.shape();
            }
            strict(message) {
                errorUtil_errorUtil.errToObj;
                return new ZodObject({
                    ...this._def,
                    unknownKeys: "strict",
                    ...void 0 !== message ? {
                        errorMap: (issue, ctx)=>{
                            const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
                            if ("unrecognized_keys" === issue.code) return {
                                message: errorUtil_errorUtil.errToObj(message).message ?? defaultError
                            };
                            return {
                                message: defaultError
                            };
                        }
                    } : {}
                });
            }
            strip() {
                return new ZodObject({
                    ...this._def,
                    unknownKeys: "strip"
                });
            }
            passthrough() {
                return new ZodObject({
                    ...this._def,
                    unknownKeys: "passthrough"
                });
            }
            extend(augmentation) {
                return new ZodObject({
                    ...this._def,
                    shape: ()=>({
                            ...this._def.shape(),
                            ...augmentation
                        })
                });
            }
            merge(merging) {
                const merged = new ZodObject({
                    unknownKeys: merging._def.unknownKeys,
                    catchall: merging._def.catchall,
                    shape: ()=>({
                            ...this._def.shape(),
                            ...merging._def.shape()
                        }),
                    typeName: types_ZodFirstPartyTypeKind.ZodObject
                });
                return merged;
            }
            setKey(key, schema) {
                return this.augment({
                    [key]: schema
                });
            }
            catchall(index) {
                return new ZodObject({
                    ...this._def,
                    catchall: index
                });
            }
            pick(mask) {
                const shape = {};
                for (const key of util_util.objectKeys(mask))if (mask[key] && this.shape[key]) shape[key] = this.shape[key];
                return new ZodObject({
                    ...this._def,
                    shape: ()=>shape
                });
            }
            omit(mask) {
                const shape = {};
                for (const key of util_util.objectKeys(this.shape))if (!mask[key]) shape[key] = this.shape[key];
                return new ZodObject({
                    ...this._def,
                    shape: ()=>shape
                });
            }
            deepPartial() {
                return deepPartialify(this);
            }
            partial(mask) {
                const newShape = {};
                for (const key of util_util.objectKeys(this.shape)){
                    const fieldSchema = this.shape[key];
                    if (mask && !mask[key]) newShape[key] = fieldSchema;
                    else newShape[key] = fieldSchema.optional();
                }
                return new ZodObject({
                    ...this._def,
                    shape: ()=>newShape
                });
            }
            required(mask) {
                const newShape = {};
                for (const key of util_util.objectKeys(this.shape))if (mask && !mask[key]) newShape[key] = this.shape[key];
                else {
                    const fieldSchema = this.shape[key];
                    let newField = fieldSchema;
                    while(newField instanceof ZodOptional)newField = newField._def.innerType;
                    newShape[key] = newField;
                }
                return new ZodObject({
                    ...this._def,
                    shape: ()=>newShape
                });
            }
            keyof() {
                return createZodEnum(util_util.objectKeys(this.shape));
            }
        }
        ZodObject.create = (shape, params)=>new ZodObject({
                shape: ()=>shape,
                unknownKeys: "strip",
                catchall: ZodNever.create(),
                typeName: types_ZodFirstPartyTypeKind.ZodObject,
                ...processCreateParams(params)
            });
        ZodObject.strictCreate = (shape, params)=>new ZodObject({
                shape: ()=>shape,
                unknownKeys: "strict",
                catchall: ZodNever.create(),
                typeName: types_ZodFirstPartyTypeKind.ZodObject,
                ...processCreateParams(params)
            });
        ZodObject.lazycreate = (shape, params)=>new ZodObject({
                shape,
                unknownKeys: "strip",
                catchall: ZodNever.create(),
                typeName: types_ZodFirstPartyTypeKind.ZodObject,
                ...processCreateParams(params)
            });
        class ZodUnion extends ZodType {
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                const options = this._def.options;
                function handleResults(results) {
                    for (const result of results)if ("valid" === result.result.status) return result.result;
                    for (const result of results)if ("dirty" === result.result.status) {
                        ctx.common.issues.push(...result.ctx.common.issues);
                        return result.result;
                    }
                    const unionErrors = results.map((result)=>new ZodError(result.ctx.common.issues));
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_union,
                        unionErrors
                    });
                    return parseUtil_INVALID;
                }
                if (ctx.common.async) return Promise.all(options.map(async (option)=>{
                    const childCtx = {
                        ...ctx,
                        common: {
                            ...ctx.common,
                            issues: []
                        },
                        parent: null
                    };
                    return {
                        result: await option._parseAsync({
                            data: ctx.data,
                            path: ctx.path,
                            parent: childCtx
                        }),
                        ctx: childCtx
                    };
                })).then(handleResults);
                {
                    let dirty;
                    const issues = [];
                    for (const option of options){
                        const childCtx = {
                            ...ctx,
                            common: {
                                ...ctx.common,
                                issues: []
                            },
                            parent: null
                        };
                        const result = option._parseSync({
                            data: ctx.data,
                            path: ctx.path,
                            parent: childCtx
                        });
                        if ("valid" === result.status) return result;
                        if ("dirty" === result.status && !dirty) dirty = {
                            result,
                            ctx: childCtx
                        };
                        if (childCtx.common.issues.length) issues.push(childCtx.common.issues);
                    }
                    if (dirty) {
                        ctx.common.issues.push(...dirty.ctx.common.issues);
                        return dirty.result;
                    }
                    const unionErrors = issues.map((issues)=>new ZodError(issues));
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_union,
                        unionErrors
                    });
                    return parseUtil_INVALID;
                }
            }
            get options() {
                return this._def.options;
            }
        }
        ZodUnion.create = (types, params)=>new ZodUnion({
                options: types,
                typeName: types_ZodFirstPartyTypeKind.ZodUnion,
                ...processCreateParams(params)
            });
        const getDiscriminator = (type)=>{
            if (type instanceof ZodLazy) return getDiscriminator(type.schema);
            if (type instanceof ZodEffects) return getDiscriminator(type.innerType());
            if (type instanceof ZodLiteral) return [
                type.value
            ];
            if (type instanceof ZodEnum) return type.options;
            if (type instanceof ZodNativeEnum) return util_util.objectValues(type.enum);
            else if (type instanceof ZodDefault) return getDiscriminator(type._def.innerType);
            else if (type instanceof ZodUndefined) return [
                void 0
            ];
            else if (type instanceof ZodNull) return [
                null
            ];
            else if (type instanceof ZodOptional) return [
                void 0,
                ...getDiscriminator(type.unwrap())
            ];
            else if (type instanceof ZodNullable) return [
                null,
                ...getDiscriminator(type.unwrap())
            ];
            else if (type instanceof ZodBranded) return getDiscriminator(type.unwrap());
            else if (type instanceof ZodReadonly) return getDiscriminator(type.unwrap());
            else if (type instanceof ZodCatch) return getDiscriminator(type._def.innerType);
            else return [];
        };
        class ZodDiscriminatedUnion extends ZodType {
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType.object) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.object,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                const discriminator = this.discriminator;
                const discriminatorValue = ctx.data[discriminator];
                const option = this.optionsMap.get(discriminatorValue);
                if (!option) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_union_discriminator,
                        options: Array.from(this.optionsMap.keys()),
                        path: [
                            discriminator
                        ]
                    });
                    return parseUtil_INVALID;
                }
                if (ctx.common.async) return option._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                return option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
            }
            get discriminator() {
                return this._def.discriminator;
            }
            get options() {
                return this._def.options;
            }
            get optionsMap() {
                return this._def.optionsMap;
            }
            static create(discriminator, options, params) {
                const optionsMap = new Map();
                for (const type of options){
                    const discriminatorValues = getDiscriminator(type.shape[discriminator]);
                    if (!discriminatorValues.length) throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
                    for (const value of discriminatorValues){
                        if (optionsMap.has(value)) throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                        optionsMap.set(value, type);
                    }
                }
                return new ZodDiscriminatedUnion({
                    typeName: types_ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
                    discriminator,
                    options,
                    optionsMap,
                    ...processCreateParams(params)
                });
            }
        }
        function mergeValues(a, b) {
            const aType = getParsedType(a);
            const bType = getParsedType(b);
            if (a === b) return {
                valid: true,
                data: a
            };
            if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
                const bKeys = util_util.objectKeys(b);
                const sharedKeys = util_util.objectKeys(a).filter((key)=>-1 !== bKeys.indexOf(key));
                const newObj = {
                    ...a,
                    ...b
                };
                for (const key of sharedKeys){
                    const sharedValue = mergeValues(a[key], b[key]);
                    if (!sharedValue.valid) return {
                        valid: false
                    };
                    newObj[key] = sharedValue.data;
                }
                return {
                    valid: true,
                    data: newObj
                };
            }
            if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
                if (a.length !== b.length) return {
                    valid: false
                };
                const newArray = [];
                for(let index = 0; index < a.length; index++){
                    const itemA = a[index];
                    const itemB = b[index];
                    const sharedValue = mergeValues(itemA, itemB);
                    if (!sharedValue.valid) return {
                        valid: false
                    };
                    newArray.push(sharedValue.data);
                }
                return {
                    valid: true,
                    data: newArray
                };
            }
            if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) return {
                valid: true,
                data: a
            };
            return {
                valid: false
            };
        }
        class ZodIntersection extends ZodType {
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                const handleParsed = (parsedLeft, parsedRight)=>{
                    if (isAborted(parsedLeft) || isAborted(parsedRight)) return parseUtil_INVALID;
                    const merged = mergeValues(parsedLeft.value, parsedRight.value);
                    if (!merged.valid) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_intersection_types
                        });
                        return parseUtil_INVALID;
                    }
                    if (isDirty(parsedLeft) || isDirty(parsedRight)) status.dirty();
                    return {
                        status: status.value,
                        value: merged.data
                    };
                };
                if (ctx.common.async) return Promise.all([
                    this._def.left._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    }),
                    this._def.right._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    })
                ]).then(([left, right])=>handleParsed(left, right));
                return handleParsed(this._def.left._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }), this._def.right._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }));
            }
        }
        ZodIntersection.create = (left, right, params)=>new ZodIntersection({
                left: left,
                right: right,
                typeName: types_ZodFirstPartyTypeKind.ZodIntersection,
                ...processCreateParams(params)
            });
        class ZodTuple extends ZodType {
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType.array) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.array,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                if (ctx.data.length < this._def.items.length) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: this._def.items.length,
                        inclusive: true,
                        exact: false,
                        type: "array"
                    });
                    return parseUtil_INVALID;
                }
                const rest = this._def.rest;
                if (!rest && ctx.data.length > this._def.items.length) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: this._def.items.length,
                        inclusive: true,
                        exact: false,
                        type: "array"
                    });
                    status.dirty();
                }
                const items = [
                    ...ctx.data
                ].map((item, itemIndex)=>{
                    const schema = this._def.items[itemIndex] || this._def.rest;
                    if (!schema) return null;
                    return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
                }).filter((x)=>!!x);
                if (ctx.common.async) return Promise.all(items).then((results)=>ParseStatus.mergeArray(status, results));
                return ParseStatus.mergeArray(status, items);
            }
            get items() {
                return this._def.items;
            }
            rest(rest) {
                return new ZodTuple({
                    ...this._def,
                    rest
                });
            }
        }
        ZodTuple.create = (schemas, params)=>{
            if (!Array.isArray(schemas)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
            return new ZodTuple({
                items: schemas,
                typeName: types_ZodFirstPartyTypeKind.ZodTuple,
                rest: null,
                ...processCreateParams(params)
            });
        };
        class ZodRecord extends ZodType {
            get keySchema() {
                return this._def.keyType;
            }
            get valueSchema() {
                return this._def.valueType;
            }
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType.object) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.object,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                const pairs = [];
                const keyType = this._def.keyType;
                const valueType = this._def.valueType;
                for(const key in ctx.data)pairs.push({
                    key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                    value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
                    alwaysSet: key in ctx.data
                });
                if (ctx.common.async) return ParseStatus.mergeObjectAsync(status, pairs);
                return ParseStatus.mergeObjectSync(status, pairs);
            }
            get element() {
                return this._def.valueType;
            }
            static create(first, second, third) {
                if (second instanceof ZodType) return new ZodRecord({
                    keyType: first,
                    valueType: second,
                    typeName: types_ZodFirstPartyTypeKind.ZodRecord,
                    ...processCreateParams(third)
                });
                return new ZodRecord({
                    keyType: ZodString.create(),
                    valueType: first,
                    typeName: types_ZodFirstPartyTypeKind.ZodRecord,
                    ...processCreateParams(second)
                });
            }
        }
        class ZodMap extends ZodType {
            get keySchema() {
                return this._def.keyType;
            }
            get valueSchema() {
                return this._def.valueType;
            }
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType.map) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.map,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                const keyType = this._def.keyType;
                const valueType = this._def.valueType;
                const pairs = [
                    ...ctx.data.entries()
                ].map(([key, value], index)=>({
                        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [
                            index,
                            "key"
                        ])),
                        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [
                            index,
                            "value"
                        ]))
                    }));
                if (ctx.common.async) {
                    const finalMap = new Map();
                    return Promise.resolve().then(async ()=>{
                        for (const pair of pairs){
                            const key = await pair.key;
                            const value = await pair.value;
                            if ("aborted" === key.status || "aborted" === value.status) return parseUtil_INVALID;
                            if ("dirty" === key.status || "dirty" === value.status) status.dirty();
                            finalMap.set(key.value, value.value);
                        }
                        return {
                            status: status.value,
                            value: finalMap
                        };
                    });
                }
                {
                    const finalMap = new Map();
                    for (const pair of pairs){
                        const key = pair.key;
                        const value = pair.value;
                        if ("aborted" === key.status || "aborted" === value.status) return parseUtil_INVALID;
                        if ("dirty" === key.status || "dirty" === value.status) status.dirty();
                        finalMap.set(key.value, value.value);
                    }
                    return {
                        status: status.value,
                        value: finalMap
                    };
                }
            }
        }
        ZodMap.create = (keyType, valueType, params)=>new ZodMap({
                valueType,
                keyType,
                typeName: types_ZodFirstPartyTypeKind.ZodMap,
                ...processCreateParams(params)
            });
        class ZodSet extends ZodType {
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType.set) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.set,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                const def = this._def;
                if (null !== def.minSize) {
                    if (ctx.data.size < def.minSize.value) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: def.minSize.value,
                            type: "set",
                            inclusive: true,
                            exact: false,
                            message: def.minSize.message
                        });
                        status.dirty();
                    }
                }
                if (null !== def.maxSize) {
                    if (ctx.data.size > def.maxSize.value) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: def.maxSize.value,
                            type: "set",
                            inclusive: true,
                            exact: false,
                            message: def.maxSize.message
                        });
                        status.dirty();
                    }
                }
                const valueType = this._def.valueType;
                function finalizeSet(elements) {
                    const parsedSet = new Set();
                    for (const element of elements){
                        if ("aborted" === element.status) return parseUtil_INVALID;
                        if ("dirty" === element.status) status.dirty();
                        parsedSet.add(element.value);
                    }
                    return {
                        status: status.value,
                        value: parsedSet
                    };
                }
                const elements = [
                    ...ctx.data.values()
                ].map((item, i)=>valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
                if (ctx.common.async) return Promise.all(elements).then((elements)=>finalizeSet(elements));
                return finalizeSet(elements);
            }
            min(minSize, message) {
                return new ZodSet({
                    ...this._def,
                    minSize: {
                        value: minSize,
                        message: errorUtil_errorUtil.toString(message)
                    }
                });
            }
            max(maxSize, message) {
                return new ZodSet({
                    ...this._def,
                    maxSize: {
                        value: maxSize,
                        message: errorUtil_errorUtil.toString(message)
                    }
                });
            }
            size(size, message) {
                return this.min(size, message).max(size, message);
            }
            nonempty(message) {
                return this.min(1, message);
            }
        }
        ZodSet.create = (valueType, params)=>new ZodSet({
                valueType,
                minSize: null,
                maxSize: null,
                typeName: types_ZodFirstPartyTypeKind.ZodSet,
                ...processCreateParams(params)
            });
        class ZodFunction extends ZodType {
            constructor(){
                super(...arguments);
                this.validate = this.implement;
            }
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType["function"]) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType["function"],
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                function makeArgsIssue(args, error) {
                    return makeIssue({
                        data: args,
                        path: ctx.path,
                        errorMaps: [
                            ctx.common.contextualErrorMap,
                            ctx.schemaErrorMap,
                            getErrorMap(),
                            en
                        ].filter((x)=>!!x),
                        issueData: {
                            code: ZodIssueCode.invalid_arguments,
                            argumentsError: error
                        }
                    });
                }
                function makeReturnsIssue(returns, error) {
                    return makeIssue({
                        data: returns,
                        path: ctx.path,
                        errorMaps: [
                            ctx.common.contextualErrorMap,
                            ctx.schemaErrorMap,
                            getErrorMap(),
                            en
                        ].filter((x)=>!!x),
                        issueData: {
                            code: ZodIssueCode.invalid_return_type,
                            returnTypeError: error
                        }
                    });
                }
                const params = {
                    errorMap: ctx.common.contextualErrorMap
                };
                const fn = ctx.data;
                if (this._def.returns instanceof ZodPromise) {
                    const me = this;
                    return OK(async function(...args) {
                        const error = new ZodError([]);
                        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e)=>{
                            error.addIssue(makeArgsIssue(args, e));
                            throw error;
                        });
                        const result = await Reflect.apply(fn, this, parsedArgs);
                        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e)=>{
                            error.addIssue(makeReturnsIssue(result, e));
                            throw error;
                        });
                        return parsedReturns;
                    });
                }
                {
                    const me = this;
                    return OK(function(...args) {
                        const parsedArgs = me._def.args.safeParse(args, params);
                        if (!parsedArgs.success) throw new ZodError([
                            makeArgsIssue(args, parsedArgs.error)
                        ]);
                        const result = Reflect.apply(fn, this, parsedArgs.data);
                        const parsedReturns = me._def.returns.safeParse(result, params);
                        if (!parsedReturns.success) throw new ZodError([
                            makeReturnsIssue(result, parsedReturns.error)
                        ]);
                        return parsedReturns.data;
                    });
                }
            }
            parameters() {
                return this._def.args;
            }
            returnType() {
                return this._def.returns;
            }
            args(...items) {
                return new ZodFunction({
                    ...this._def,
                    args: ZodTuple.create(items).rest(ZodUnknown.create())
                });
            }
            returns(returnType) {
                return new ZodFunction({
                    ...this._def,
                    returns: returnType
                });
            }
            implement(func) {
                const validatedFunc = this.parse(func);
                return validatedFunc;
            }
            strictImplement(func) {
                const validatedFunc = this.parse(func);
                return validatedFunc;
            }
            static create(args, returns, params) {
                return new ZodFunction({
                    args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
                    returns: returns || ZodUnknown.create(),
                    typeName: types_ZodFirstPartyTypeKind.ZodFunction,
                    ...processCreateParams(params)
                });
            }
        }
        class ZodLazy extends ZodType {
            get schema() {
                return this._def.getter();
            }
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                const lazySchema = this._def.getter();
                return lazySchema._parse({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
            }
        }
        ZodLazy.create = (getter, params)=>new ZodLazy({
                getter: getter,
                typeName: types_ZodFirstPartyTypeKind.ZodLazy,
                ...processCreateParams(params)
            });
        class ZodLiteral extends ZodType {
            _parse(input) {
                if (input.data !== this._def.value) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        received: ctx.data,
                        code: ZodIssueCode.invalid_literal,
                        expected: this._def.value
                    });
                    return parseUtil_INVALID;
                }
                return {
                    status: "valid",
                    value: input.data
                };
            }
            get value() {
                return this._def.value;
            }
        }
        ZodLiteral.create = (value, params)=>new ZodLiteral({
                value: value,
                typeName: types_ZodFirstPartyTypeKind.ZodLiteral,
                ...processCreateParams(params)
            });
        function createZodEnum(values, params) {
            return new ZodEnum({
                values,
                typeName: types_ZodFirstPartyTypeKind.ZodEnum,
                ...processCreateParams(params)
            });
        }
        class ZodEnum extends ZodType {
            _parse(input) {
                if ("string" != typeof input.data) {
                    const ctx = this._getOrReturnCtx(input);
                    const expectedValues = this._def.values;
                    addIssueToContext(ctx, {
                        expected: util_util.joinValues(expectedValues),
                        received: ctx.parsedType,
                        code: ZodIssueCode.invalid_type
                    });
                    return parseUtil_INVALID;
                }
                if (!this._cache) this._cache = new Set(this._def.values);
                if (!this._cache.has(input.data)) {
                    const ctx = this._getOrReturnCtx(input);
                    const expectedValues = this._def.values;
                    addIssueToContext(ctx, {
                        received: ctx.data,
                        code: ZodIssueCode.invalid_enum_value,
                        options: expectedValues
                    });
                    return parseUtil_INVALID;
                }
                return OK(input.data);
            }
            get options() {
                return this._def.values;
            }
            get enum() {
                const enumValues = {};
                for (const val of this._def.values)enumValues[val] = val;
                return enumValues;
            }
            get Values() {
                const enumValues = {};
                for (const val of this._def.values)enumValues[val] = val;
                return enumValues;
            }
            get Enum() {
                const enumValues = {};
                for (const val of this._def.values)enumValues[val] = val;
                return enumValues;
            }
            extract(values, newDef = this._def) {
                return ZodEnum.create(values, {
                    ...this._def,
                    ...newDef
                });
            }
            exclude(values, newDef = this._def) {
                return ZodEnum.create(this.options.filter((opt)=>!values.includes(opt)), {
                    ...this._def,
                    ...newDef
                });
            }
        }
        ZodEnum.create = createZodEnum;
        class ZodNativeEnum extends ZodType {
            _parse(input) {
                const nativeEnumValues = util_util.getValidEnumValues(this._def.values);
                const ctx = this._getOrReturnCtx(input);
                if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
                    const expectedValues = util_util.objectValues(nativeEnumValues);
                    addIssueToContext(ctx, {
                        expected: util_util.joinValues(expectedValues),
                        received: ctx.parsedType,
                        code: ZodIssueCode.invalid_type
                    });
                    return parseUtil_INVALID;
                }
                if (!this._cache) this._cache = new Set(util_util.getValidEnumValues(this._def.values));
                if (!this._cache.has(input.data)) {
                    const expectedValues = util_util.objectValues(nativeEnumValues);
                    addIssueToContext(ctx, {
                        received: ctx.data,
                        code: ZodIssueCode.invalid_enum_value,
                        options: expectedValues
                    });
                    return parseUtil_INVALID;
                }
                return OK(input.data);
            }
            get enum() {
                return this._def.values;
            }
        }
        ZodNativeEnum.create = (values, params)=>new ZodNativeEnum({
                values: values,
                typeName: types_ZodFirstPartyTypeKind.ZodNativeEnum,
                ...processCreateParams(params)
            });
        class ZodPromise extends ZodType {
            unwrap() {
                return this._def.type;
            }
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType.promise && false === ctx.common.async) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.promise,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
                return OK(promisified.then((data)=>this._def.type.parseAsync(data, {
                        path: ctx.path,
                        errorMap: ctx.common.contextualErrorMap
                    })));
            }
        }
        ZodPromise.create = (schema, params)=>new ZodPromise({
                type: schema,
                typeName: types_ZodFirstPartyTypeKind.ZodPromise,
                ...processCreateParams(params)
            });
        class ZodEffects extends ZodType {
            innerType() {
                return this._def.schema;
            }
            sourceType() {
                return this._def.schema._def.typeName === types_ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
            }
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                const effect = this._def.effect || null;
                const checkCtx = {
                    addIssue: (arg)=>{
                        addIssueToContext(ctx, arg);
                        if (arg.fatal) status.abort();
                        else status.dirty();
                    },
                    get path () {
                        return ctx.path;
                    }
                };
                checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
                if ("preprocess" === effect.type) {
                    const processed = effect.transform(ctx.data, checkCtx);
                    if (ctx.common.async) return Promise.resolve(processed).then(async (processed)=>{
                        if ("aborted" === status.value) return parseUtil_INVALID;
                        const result = await this._def.schema._parseAsync({
                            data: processed,
                            path: ctx.path,
                            parent: ctx
                        });
                        if ("aborted" === result.status) return parseUtil_INVALID;
                        if ("dirty" === result.status) return DIRTY(result.value);
                        if ("dirty" === status.value) return DIRTY(result.value);
                        return result;
                    });
                    {
                        if ("aborted" === status.value) return parseUtil_INVALID;
                        const result = this._def.schema._parseSync({
                            data: processed,
                            path: ctx.path,
                            parent: ctx
                        });
                        if ("aborted" === result.status) return parseUtil_INVALID;
                        if ("dirty" === result.status) return DIRTY(result.value);
                        if ("dirty" === status.value) return DIRTY(result.value);
                        return result;
                    }
                }
                if ("refinement" === effect.type) {
                    const executeRefinement = (acc)=>{
                        const result = effect.refinement(acc, checkCtx);
                        if (ctx.common.async) return Promise.resolve(result);
                        if (result instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                        return acc;
                    };
                    if (false !== ctx.common.async) return this._def.schema._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    }).then((inner)=>{
                        if ("aborted" === inner.status) return parseUtil_INVALID;
                        if ("dirty" === inner.status) status.dirty();
                        return executeRefinement(inner.value).then(()=>({
                                status: status.value,
                                value: inner.value
                            }));
                    });
                    {
                        const inner = this._def.schema._parseSync({
                            data: ctx.data,
                            path: ctx.path,
                            parent: ctx
                        });
                        if ("aborted" === inner.status) return parseUtil_INVALID;
                        if ("dirty" === inner.status) status.dirty();
                        executeRefinement(inner.value);
                        return {
                            status: status.value,
                            value: inner.value
                        };
                    }
                }
                if ("transform" === effect.type) if (false !== ctx.common.async) return this._def.schema._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }).then((base)=>{
                    if (!isValid(base)) return parseUtil_INVALID;
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result)=>({
                            status: status.value,
                            value: result
                        }));
                });
                else {
                    const base = this._def.schema._parseSync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    });
                    if (!isValid(base)) return parseUtil_INVALID;
                    const result = effect.transform(base.value, checkCtx);
                    if (result instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                    return {
                        status: status.value,
                        value: result
                    };
                }
                util_util.assertNever(effect);
            }
        }
        ZodEffects.create = (schema, effect, params)=>new ZodEffects({
                schema,
                typeName: types_ZodFirstPartyTypeKind.ZodEffects,
                effect,
                ...processCreateParams(params)
            });
        ZodEffects.createWithPreprocess = (preprocess, schema, params)=>new ZodEffects({
                schema,
                effect: {
                    type: "preprocess",
                    transform: preprocess
                },
                typeName: types_ZodFirstPartyTypeKind.ZodEffects,
                ...processCreateParams(params)
            });
        class ZodOptional extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType === ZodParsedType.undefined) return OK(void 0);
                return this._def.innerType._parse(input);
            }
            unwrap() {
                return this._def.innerType;
            }
        }
        ZodOptional.create = (type, params)=>new ZodOptional({
                innerType: type,
                typeName: types_ZodFirstPartyTypeKind.ZodOptional,
                ...processCreateParams(params)
            });
        class ZodNullable extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType === ZodParsedType["null"]) return OK(null);
                return this._def.innerType._parse(input);
            }
            unwrap() {
                return this._def.innerType;
            }
        }
        ZodNullable.create = (type, params)=>new ZodNullable({
                innerType: type,
                typeName: types_ZodFirstPartyTypeKind.ZodNullable,
                ...processCreateParams(params)
            });
        class ZodDefault extends ZodType {
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                let data = ctx.data;
                if (ctx.parsedType === ZodParsedType.undefined) data = this._def.defaultValue();
                return this._def.innerType._parse({
                    data,
                    path: ctx.path,
                    parent: ctx
                });
            }
            removeDefault() {
                return this._def.innerType;
            }
        }
        ZodDefault.create = (type, params)=>new ZodDefault({
                innerType: type,
                typeName: types_ZodFirstPartyTypeKind.ZodDefault,
                defaultValue: "function" == typeof params.default ? params.default : ()=>params.default,
                ...processCreateParams(params)
            });
        class ZodCatch extends ZodType {
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                const newCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: []
                    }
                };
                const result = this._def.innerType._parse({
                    data: newCtx.data,
                    path: newCtx.path,
                    parent: {
                        ...newCtx
                    }
                });
                if (isAsync(result)) return result.then((result)=>({
                        status: "valid",
                        value: "valid" === result.status ? result.value : this._def.catchValue({
                            get error () {
                                return new ZodError(newCtx.common.issues);
                            },
                            input: newCtx.data
                        })
                    }));
                return {
                    status: "valid",
                    value: "valid" === result.status ? result.value : this._def.catchValue({
                        get error () {
                            return new ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data
                    })
                };
            }
            removeCatch() {
                return this._def.innerType;
            }
        }
        ZodCatch.create = (type, params)=>new ZodCatch({
                innerType: type,
                typeName: types_ZodFirstPartyTypeKind.ZodCatch,
                catchValue: "function" == typeof params.catch ? params.catch : ()=>params.catch,
                ...processCreateParams(params)
            });
        class ZodNaN extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.nan) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.nan,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                return {
                    status: "valid",
                    value: input.data
                };
            }
        }
        ZodNaN.create = (params)=>new ZodNaN({
                typeName: types_ZodFirstPartyTypeKind.ZodNaN,
                ...processCreateParams(params)
            });
        Symbol("zod_brand");
        class ZodBranded extends ZodType {
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                const data = ctx.data;
                return this._def.type._parse({
                    data,
                    path: ctx.path,
                    parent: ctx
                });
            }
            unwrap() {
                return this._def.type;
            }
        }
        class ZodPipeline extends ZodType {
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                if (ctx.common.async) {
                    const handleAsync = async ()=>{
                        const inResult = await this._def.in._parseAsync({
                            data: ctx.data,
                            path: ctx.path,
                            parent: ctx
                        });
                        if ("aborted" === inResult.status) return parseUtil_INVALID;
                        if ("dirty" !== inResult.status) return this._def.out._parseAsync({
                            data: inResult.value,
                            path: ctx.path,
                            parent: ctx
                        });
                        status.dirty();
                        return DIRTY(inResult.value);
                    };
                    return handleAsync();
                }
                {
                    const inResult = this._def.in._parseSync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    });
                    if ("aborted" === inResult.status) return parseUtil_INVALID;
                    if ("dirty" !== inResult.status) return this._def.out._parseSync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx
                    });
                    status.dirty();
                    return {
                        status: "dirty",
                        value: inResult.value
                    };
                }
            }
            static create(a, b) {
                return new ZodPipeline({
                    in: a,
                    out: b,
                    typeName: types_ZodFirstPartyTypeKind.ZodPipeline
                });
            }
        }
        class ZodReadonly extends ZodType {
            _parse(input) {
                const result = this._def.innerType._parse(input);
                const freeze = (data)=>{
                    if (isValid(data)) data.value = Object.freeze(data.value);
                    return data;
                };
                return isAsync(result) ? result.then((data)=>freeze(data)) : freeze(result);
            }
            unwrap() {
                return this._def.innerType;
            }
        }
        ZodReadonly.create = (type, params)=>new ZodReadonly({
                innerType: type,
                typeName: types_ZodFirstPartyTypeKind.ZodReadonly,
                ...processCreateParams(params)
            });
        ZodObject.lazycreate;
        var types_ZodFirstPartyTypeKind;
        (function(ZodFirstPartyTypeKind) {
            ZodFirstPartyTypeKind["ZodString"] = "ZodString";
            ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
            ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
            ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
            ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
            ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
            ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
            ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
            ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
            ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
            ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
            ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
            ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
            ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
            ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
            ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
            ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
            ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
            ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
            ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
            ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
            ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
            ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
            ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
            ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
            ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
            ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
            ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
            ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
            ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
            ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
            ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
            ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
            ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
            ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
            ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
        })(types_ZodFirstPartyTypeKind || (types_ZodFirstPartyTypeKind = {}));
        ZodString.create;
        ZodNumber.create;
        ZodNaN.create;
        ZodBigInt.create;
        ZodBoolean.create;
        ZodDate.create;
        ZodSymbol.create;
        ZodUndefined.create;
        ZodNull.create;
        ZodAny.create;
        ZodUnknown.create;
        ZodNever.create;
        ZodVoid.create;
        ZodArray.create;
        ZodObject.create;
        ZodObject.strictCreate;
        ZodUnion.create;
        ZodDiscriminatedUnion.create;
        ZodIntersection.create;
        ZodTuple.create;
        ZodRecord.create;
        ZodMap.create;
        ZodSet.create;
        ZodFunction.create;
        ZodLazy.create;
        ZodLiteral.create;
        ZodEnum.create;
        ZodNativeEnum.create;
        ZodPromise.create;
        ZodEffects.create;
        ZodOptional.create;
        ZodNullable.create;
        ZodEffects.createWithPreprocess;
        ZodPipeline.create;
    },
    "../agent-tars-interface/dist/cli.mjs": function() {},
    "../agent-tars-interface/dist/config.mjs": function() {},
    "../agent-tars-interface/dist/core.mjs": function() {},
    "../agent-tars-interface/dist/define-config.mjs": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            Z: ()=>defineConfig
        });
        function defineConfig(config) {
            return config;
        }
    },
    "../agent-tars-interface/dist/index.mjs": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, {
            LogLevel: ()=>_mcp_agent_interface__WEBPACK_IMPORTED_MODULE_0__.i,
            defineConfig: ()=>_define_config_mjs__WEBPACK_IMPORTED_MODULE_5__.Z
        });
        var _mcp_agent_interface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../mcp-agent-interface/dist/index.mjs");
        var _config_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../agent-tars-interface/dist/config.mjs");
        var __WEBPACK_REEXPORT_OBJECT__ = {};
        for(var __WEBPACK_IMPORT_KEY__ in _config_mjs__WEBPACK_IMPORTED_MODULE_1__)if ([
            "default",
            "LogLevel"
        ].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = (function(key) {
            return _config_mjs__WEBPACK_IMPORTED_MODULE_1__[key];
        }).bind(0, __WEBPACK_IMPORT_KEY__);
        __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
        var _core_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../agent-tars-interface/dist/core.mjs");
        var __WEBPACK_REEXPORT_OBJECT__ = {};
        for(var __WEBPACK_IMPORT_KEY__ in _core_mjs__WEBPACK_IMPORTED_MODULE_2__)if ([
            "default",
            "LogLevel"
        ].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = (function(key) {
            return _core_mjs__WEBPACK_IMPORTED_MODULE_2__[key];
        }).bind(0, __WEBPACK_IMPORT_KEY__);
        __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
        var _server_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../agent-tars-interface/dist/server.mjs");
        var __WEBPACK_REEXPORT_OBJECT__ = {};
        for(var __WEBPACK_IMPORT_KEY__ in _server_mjs__WEBPACK_IMPORTED_MODULE_3__)if ([
            "default",
            "LogLevel"
        ].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = (function(key) {
            return _server_mjs__WEBPACK_IMPORTED_MODULE_3__[key];
        }).bind(0, __WEBPACK_IMPORT_KEY__);
        __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
        var _cli_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../agent-tars-interface/dist/cli.mjs");
        var __WEBPACK_REEXPORT_OBJECT__ = {};
        for(var __WEBPACK_IMPORT_KEY__ in _cli_mjs__WEBPACK_IMPORTED_MODULE_4__)if ([
            "default",
            "LogLevel"
        ].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = (function(key) {
            return _cli_mjs__WEBPACK_IMPORTED_MODULE_4__[key];
        }).bind(0, __WEBPACK_IMPORT_KEY__);
        __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
        var _define_config_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../agent-tars-interface/dist/define-config.mjs");
    },
    "../agent-tars-interface/dist/server.mjs": function() {},
    "./src/core/SocketHandlers.ts": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            L: ()=>SocketHandlers,
            s: ()=>setupSocketIO
        });
        var dist = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/index.js");
        const { Server, Namespace, Socket } = dist;
        var error_handler = __webpack_require__("./src/utils/error-handler.ts");
        function setupSocketIO(httpServer, server) {
            const io = new Server(httpServer, {
                cors: {
                    origin: '*',
                    methods: [
                        'GET',
                        'POST'
                    ]
                }
            });
            io.on('connection', (socket)=>{
                SocketHandlers.handleConnection(socket, server);
            });
            return io;
        }
        class SocketHandlers {
            static handleConnection(socket, server) {
                console.log('Client connected:', socket.id);
                socket.on('ping', (callback)=>{
                    if ('function' == typeof callback) callback();
                });
                socket.on('join-session', (sessionId)=>{
                    SocketHandlers.handleJoinSession(socket, server, sessionId);
                });
                socket.on('send-query', async ({ sessionId, query })=>{
                    await SocketHandlers.handleSendQuery(socket, server, sessionId, query);
                });
                socket.on('abort-query', async ({ sessionId })=>{
                    await SocketHandlers.handleAbortQuery(socket, server, sessionId);
                });
                socket.on('disconnect', ()=>{
                    console.log('Client disconnected:', socket.id);
                });
            }
            static handleJoinSession(socket, server, sessionId) {
                if (server.sessions[sessionId]) {
                    socket.join(sessionId);
                    console.log(`Client ${socket.id} joined session ${sessionId}`);
                    const eventHandler = (eventType, data)=>{
                        socket.emit('agent-event', {
                            type: eventType,
                            data
                        });
                    };
                    const initialStatus = {
                        isProcessing: server.sessions[sessionId].getProcessingStatus(),
                        state: server.sessions[sessionId].agent.status()
                    };
                    socket.emit('agent-status', initialStatus);
                    server.sessions[sessionId].eventBridge.subscribe(eventHandler);
                    socket.on('disconnect', ()=>{
                        if (server.sessions[sessionId]) server.sessions[sessionId].eventBridge.unsubscribe(eventHandler);
                    });
                } else socket.emit('error', 'Session not found');
            }
            static async handleSendQuery(socket, server, sessionId, query) {
                if (server.sessions[sessionId]) try {
                    const response = await server.sessions[sessionId].runQuery(query);
                    if (!response.success && response.error) socket.emit('error', response.error.message);
                } catch (error) {
                    const handledError = (0, error_handler.rB)(error);
                    console.error('Unexpected error in socket query:', handledError);
                    socket.emit('error', handledError.message);
                }
                else socket.emit('error', 'Session not found');
            }
            static async handleAbortQuery(socket, server, sessionId) {
                if (server.sessions[sessionId]) try {
                    const aborted = await server.sessions[sessionId].abortQuery();
                    socket.emit('abort-result', {
                        success: aborted
                    });
                } catch (error) {
                    console.error('Error aborting query:', error);
                    socket.emit('error', 'Failed to abort query');
                }
                else socket.emit('error', 'Session not found');
            }
        }
    },
    "./src/core/index.ts": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            iF: ()=>AgioProvider,
            ZT: ()=>AgentSession,
            sI: ()=>SocketHandlers.s,
            Lw: ()=>SocketHandlers.L
        });
        var external_path_ = __webpack_require__("path");
        var external_path_default = /*#__PURE__*/ __webpack_require__.n(external_path_);
        var core_ = __webpack_require__("@agent-tars/core");
        var external_fs_ = __webpack_require__("fs");
        var external_fs_default = /*#__PURE__*/ __webpack_require__.n(external_fs_);
        var dist = __webpack_require__("../agent-interface/dist/index.mjs");
        var logger_dist = __webpack_require__("../node_modules/.pnpm/@agent-infra+logger@0.0.2-beta.2/node_modules/@agent-infra/logger/dist/index.mjs");
        const logger = new logger_dist.kw('[AgentSnapshot]');
        var fast_json_stable_stringify = __webpack_require__("../node_modules/.pnpm/fast-json-stable-stringify@2.1.0/node_modules/fast-json-stable-stringify/index.js");
        var fast_json_stable_stringify_default = /*#__PURE__*/ __webpack_require__.n(fast_json_stable_stringify);
        function _define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        const DEFAULT_CONFIG = {
            fieldsToNormalize: [
                {
                    pattern: /id$/,
                    replacement: '<<ID>>'
                },
                {
                    pattern: 'timestamp',
                    replacement: '<<TIMESTAMP>>'
                },
                {
                    pattern: 'created',
                    replacement: '<<TIMESTAMP>>'
                },
                {
                    pattern: 'startTime',
                    replacement: '<<TIMESTAMP>>'
                },
                {
                    pattern: 'elapsedMs',
                    replacement: '<<elapsedMs>>'
                },
                {
                    pattern: 'image_url',
                    replacement: '<<image_url>>'
                },
                {
                    pattern: 'toolCallId',
                    replacement: '<<toolCallId>>'
                },
                {
                    pattern: 'sessionId',
                    replacement: '<<sessionId>>'
                },
                {
                    pattern: 'messageId',
                    replacement: '<<messageId>>'
                },
                {
                    pattern: /Time$/,
                    replacement: '<<TIMESTAMP>>'
                }
            ],
            fieldsToIgnore: []
        };
        class SimpleDiffer {
            diff(expected, actual, expectedLabel = 'Expected', actualLabel = 'Actual') {
                const expectedLines = expected.split('\n');
                const actualLines = actual.split('\n');
                const diffLines = [];
                diffLines.push(`--- ${expectedLabel}`);
                diffLines.push(`+++ ${actualLabel}`);
                const lcs = this.longestCommonSubsequence(expectedLines, actualLines);
                const changes = this.generateChanges(expectedLines, actualLines, lcs);
                const hunks = this.groupChangesIntoHunks(changes, expectedLines.length, actualLines.length);
                for (const hunk of hunks){
                    diffLines.push(`@@ -${hunk.oldStart},${hunk.oldCount} +${hunk.newStart},${hunk.newCount} @@`);
                    diffLines.push(...hunk.lines);
                }
                return diffLines.join('\n');
            }
            longestCommonSubsequence(a, b) {
                const m = a.length;
                const n = b.length;
                const dp = Array(m + 1).fill(null).map(()=>Array(n + 1).fill(0));
                for(let i = 1; i <= m; i++)for(let j = 1; j <= n; j++)if (a[i - 1] === b[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                return dp;
            }
            generateChanges(expected, actual, lcs) {
                const changes = [];
                let i = expected.length;
                let j = actual.length;
                while(i > 0 || j > 0)if (i > 0 && j > 0 && expected[i - 1] === actual[j - 1]) {
                    changes.unshift({
                        type: 'equal',
                        expectedIndex: i - 1,
                        actualIndex: j - 1,
                        line: expected[i - 1]
                    });
                    i--;
                    j--;
                } else if (j > 0 && (0 === i || lcs[i][j - 1] >= lcs[i - 1][j])) {
                    changes.unshift({
                        type: 'add',
                        expectedIndex: -1,
                        actualIndex: j - 1,
                        line: actual[j - 1]
                    });
                    j--;
                } else if (i > 0) {
                    changes.unshift({
                        type: 'remove',
                        expectedIndex: i - 1,
                        actualIndex: -1,
                        line: expected[i - 1]
                    });
                    i--;
                }
                return changes;
            }
            groupChangesIntoHunks(changes, expectedLength, actualLength) {
                const hunks = [];
                let currentHunk = null;
                for(let i = 0; i < changes.length; i++){
                    const change = changes[i];
                    if ('equal' !== change.type) {
                        if (!currentHunk) {
                            var _changes_contextStart, _changes_contextStart1;
                            const contextStart = Math.max(0, i - this.contextLines);
                            currentHunk = {
                                oldStart: (null == (_changes_contextStart = changes[contextStart]) ? void 0 : _changes_contextStart.expectedIndex) + 1 || 1,
                                oldCount: 0,
                                newStart: (null == (_changes_contextStart1 = changes[contextStart]) ? void 0 : _changes_contextStart1.actualIndex) + 1 || 1,
                                newCount: 0,
                                lines: []
                            };
                            for(let j = contextStart; j < i; j++)if ('equal' === changes[j].type) {
                                currentHunk.lines.push(` ${changes[j].line}`);
                                currentHunk.oldCount++;
                                currentHunk.newCount++;
                            }
                        }
                        if ('remove' === change.type) {
                            currentHunk.lines.push(`-${change.line}`);
                            currentHunk.oldCount++;
                        } else if ('add' === change.type) {
                            currentHunk.lines.push(`+${change.line}`);
                            currentHunk.newCount++;
                        }
                    } else if (currentHunk) {
                        currentHunk.lines.push(` ${change.line}`);
                        currentHunk.oldCount++;
                        currentHunk.newCount++;
                        const nextChanges = changes.slice(i + 1, i + 1 + 2 * this.contextLines);
                        const hasMoreChanges = nextChanges.some((c)=>'equal' !== c.type);
                        if (!hasMoreChanges || i === changes.length - 1) {
                            var _changes_j;
                            const contextEnd = Math.min(i + this.contextLines, changes.length - 1);
                            for(let j = i + 1; j <= contextEnd; j++)if ((null == (_changes_j = changes[j]) ? void 0 : _changes_j.type) === 'equal') {
                                currentHunk.lines.push(` ${changes[j].line}`);
                                currentHunk.oldCount++;
                                currentHunk.newCount++;
                            }
                            hunks.push(currentHunk);
                            currentHunk = null;
                        }
                    }
                }
                return hunks;
            }
            constructor(contextLines = 3){
                _define_property(this, "contextLines", void 0);
                this.contextLines = contextLines;
            }
        }
        class AgentSnapshotNormalizer {
            normalize(obj, path = '') {
                if ('' === path) this.seenObjects = new WeakMap();
                if (null == obj) return obj;
                if ('object' == typeof obj) {
                    if (this.seenObjects.has(obj)) return '[Circular Reference]';
                    this.seenObjects.set(obj, true);
                }
                if (Array.isArray(obj)) return obj.map((item, index)=>this.normalize(item, `${path}[${index}]`));
                if ('object' == typeof obj) {
                    const result = {};
                    for (const [key, value] of Object.entries(obj)){
                        const currentPath = path ? `${path}.${key}` : key;
                        if (this.shouldIgnoreField(key, currentPath)) continue;
                        const normalized = this.normalizeField(key, value, currentPath);
                        if (void 0 !== normalized) result[key] = normalized;
                        else if ('object' == typeof value && null !== value) result[key] = this.normalize(value, currentPath);
                        else result[key] = value;
                    }
                    return result;
                }
                return obj;
            }
            shouldIgnoreField(key, path) {
                var _this_config_fieldsToIgnore;
                return (null == (_this_config_fieldsToIgnore = this.config.fieldsToIgnore) ? void 0 : _this_config_fieldsToIgnore.some((pattern)=>{
                    if (pattern instanceof RegExp) return pattern.test(key) || pattern.test(path);
                    return key === pattern || path === pattern;
                })) || false;
            }
            normalizeField(key, value, path) {
                if (this.config.customNormalizers) {
                    for (const { pattern, normalizer } of this.config.customNormalizers)if (pattern instanceof RegExp && (pattern.test(key) || pattern.test(path)) || key === pattern || path === pattern) return normalizer(value, path);
                }
                if (this.config.fieldsToNormalize) {
                    for (const { pattern, replacement, deep = true } of this.config.fieldsToNormalize)if (pattern instanceof RegExp && (pattern.test(key) || pattern.test(path)) || key === pattern || path === pattern) return replacement;
                }
            }
            compare(expected, actual) {
                const normalizedExpected = this.normalize(expected);
                const normalizedActual = this.normalize(actual);
                const expectedString = fast_json_stable_stringify_default()(normalizedExpected);
                const actualString = fast_json_stable_stringify_default()(normalizedActual);
                if (expectedString === actualString) return {
                    equal: true,
                    diff: null
                };
                const diff = this.differ.diff(JSON.stringify(normalizedExpected, null, 2), JSON.stringify(normalizedActual, null, 2), 'Created Agent Snapshot', 'Runtime Agent State');
                return {
                    equal: false,
                    diff
                };
            }
            createSnapshotSerializer() {
                return {
                    test (val) {
                        return 'object' == typeof val && null !== val;
                    },
                    serialize: (val)=>JSON.stringify(this.normalize(val), null, 2)
                };
            }
            constructor(config){
                _define_property(this, "config", void 0);
                _define_property(this, "seenObjects", new WeakMap());
                _define_property(this, "differ", new SimpleDiffer(3));
                this.config = {
                    ...DEFAULT_CONFIG,
                    ...config,
                    fieldsToNormalize: [
                        ...DEFAULT_CONFIG.fieldsToNormalize || [],
                        ...(null == config ? void 0 : config.fieldsToNormalize) || []
                    ],
                    fieldsToIgnore: [
                        ...DEFAULT_CONFIG.fieldsToIgnore || [],
                        ...(null == config ? void 0 : config.fieldsToIgnore) || []
                    ],
                    customNormalizers: [
                        ...DEFAULT_CONFIG.customNormalizers || [],
                        ...(null == config ? void 0 : config.customNormalizers) || []
                    ]
                };
            }
        }
        function snapshot_manager_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class SnapshotManager {
            getSnapshotPath(caseName, loopDir, filename) {
                if ('' === loopDir) return external_path_default().join(this.fixturesRoot, caseName, filename);
                return external_path_default().join(this.fixturesRoot, caseName, loopDir, filename);
            }
            async readSnapshot(caseName, loopDir, filename) {
                const filePath = this.getSnapshotPath(caseName, loopDir, filename);
                if (!external_fs_default().existsSync(filePath)) return null;
                try {
                    const content = external_fs_default().readFileSync(filePath, 'utf-8');
                    if ('llm-response.jsonl' === filename) try {
                        return JSON.parse(content);
                    } catch (parseError) {
                        const lines = content.split('\n').filter((line)=>line.trim());
                        if (lines.length > 0) try {
                            const chunks = lines.map((line)=>JSON.parse(line));
                            return chunks;
                        } catch (lineParseError) {
                            logger.error(`Error parsing LLM response as streaming format: ${lineParseError}`);
                            throw lineParseError;
                        }
                        throw parseError;
                    }
                    return JSON.parse(content);
                } catch (error) {
                    logger.error(`Error reading snapshot from ${filePath}: ${error}`);
                    return null;
                }
            }
            async writeSnapshot(caseName, loopDir, filename, data) {
                const filePath = this.getSnapshotPath(caseName, loopDir, filename);
                const dirPath = external_path_default().dirname(filePath);
                if (!external_fs_default().existsSync(dirPath)) await external_fs_default().promises.mkdir(dirPath, {
                    recursive: true
                });
                try {
                    await external_fs_default().promises.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');
                    logger.info(`Snapshot written to ${filePath}`);
                } catch (error) {
                    logger.error(`Error writing snapshot to ${filePath}: ${error}`);
                    throw error;
                }
            }
            async writeActualData(caseName, loopDir, filename, data) {
                const actualFilename = filename.replace(/(\.[^.]+)$/, '.actual$1');
                const actualFilePath = this.getSnapshotPath(caseName, loopDir, actualFilename);
                await this.writeSnapshot(caseName, loopDir, actualFilename, data);
                logger.info(`Actual data written to ${actualFilePath}`);
                return actualFilePath;
            }
            async deleteActualDataIfExists(caseName, loopDir, filename) {
                const actualFilename = filename.replace(/(\.[^.]+)$/, '.actual$1');
                const actualFilePath = this.getSnapshotPath(caseName, loopDir, actualFilename);
                if (external_fs_default().existsSync(actualFilePath)) try {
                    await external_fs_default().promises.unlink(actualFilePath);
                    logger.info(`Deleted actual data file: ${actualFilePath}`);
                } catch (error) {
                    logger.warn(`Failed to delete actual data file ${actualFilePath}: ${error}`);
                }
            }
            async cleanupAllActualFiles(caseName) {
                const casePath = external_path_default().join(this.fixturesRoot, caseName);
                if (!external_fs_default().existsSync(casePath)) return 0;
                try {
                    const findActualFiles = (dir)=>{
                        const results = [];
                        const files = external_fs_default().readdirSync(dir);
                        for (const file of files){
                            const fullPath = external_path_default().join(dir, file);
                            if (external_fs_default().statSync(fullPath).isDirectory()) results.push(...findActualFiles(fullPath));
                            else if (file.includes('.actual.jsonl')) results.push(fullPath);
                        }
                        return results;
                    };
                    const actualFiles = findActualFiles(casePath);
                    for (const file of actualFiles)try {
                        await external_fs_default().promises.unlink(file);
                        logger.info(`Cleanup: Deleted leftover temporary file ${file}`);
                    } catch (err) {
                        logger.warn(`Failed to delete temporary file ${file}: ${err}`);
                    }
                    if (actualFiles.length > 0) logger.success(`\u{2705} Successfully cleaned up ${actualFiles.length} temporary .actual.jsonl files`);
                    return actualFiles.length;
                } catch (error) {
                    logger.warn(`Failed to perform cleanup of actual files: ${error}`);
                    return 0;
                }
            }
            async verifyEventStreamSnapshot(caseName, loopDir, actualEventStream, updateSnapshots = false) {
                const filename = 'event-stream.jsonl';
                const expectedEventStream = await this.readSnapshot(caseName, loopDir, filename);
                if (!expectedEventStream) {
                    if (updateSnapshots) {
                        await this.writeSnapshot(caseName, loopDir, filename, actualEventStream);
                        logger.success(`\u{2705} Created new event stream snapshot for ${caseName}/${loopDir}`);
                        return true;
                    }
                    throw new Error(`No event stream snapshot found for ${caseName}/${loopDir}`);
                }
                if (updateSnapshots) {
                    await this.writeSnapshot(caseName, loopDir, filename, actualEventStream);
                    logger.warn(`\u{26A0}\u{FE0F} Skipping event stream verification for ${caseName}/${loopDir}, updating snapshot directly`);
                    return true;
                }
                const result = this.normalizer.compare(expectedEventStream, actualEventStream);
                if (!result.equal) {
                    await this.writeActualData(caseName, loopDir, filename, actualEventStream);
                    logger.error(`\u{274C} Event stream comparison failed for ${caseName}/${loopDir}:\n${result.diff}`);
                    throw new Error(`Event stream doesn't match for ${caseName}/${loopDir}. Actual data saved to ${loopDir ? `${loopDir}/` : ''}event-stream.actual.jsonl`);
                }
                await this.deleteActualDataIfExists(caseName, loopDir, filename);
                logger.success(`\u{2705} Event stream comparison passed for ${caseName}/${loopDir}`);
                return true;
            }
            async verifyRequestSnapshot(caseName, loopDir, actualRequest, updateSnapshots = false) {
                actualRequest = JSON.parse(JSON.stringify(actualRequest));
                const filename = 'llm-request.jsonl';
                const expectedRequest = await this.readSnapshot(caseName, loopDir, filename);
                if (!expectedRequest) {
                    if (updateSnapshots) {
                        await this.writeSnapshot(caseName, loopDir, filename, actualRequest);
                        logger.success(`\u{2705} Created new request snapshot for ${caseName}/${loopDir}`);
                        return true;
                    }
                    throw new Error(`No request snapshot found for ${caseName}/${loopDir}`);
                }
                if (updateSnapshots) {
                    await this.writeSnapshot(caseName, loopDir, filename, actualRequest);
                    logger.warn(`\u{26A0}\u{FE0F} Skipping request verification for ${caseName}/${loopDir}, updating snapshot directly`);
                    return true;
                }
                const result = this.normalizer.compare(expectedRequest, actualRequest);
                if (!result.equal) {
                    await this.writeActualData(caseName, loopDir, filename, actualRequest);
                    logger.error(`\u{274C} Request comparison failed for ${caseName}/${loopDir}:\n${result.diff}`);
                    throw new Error(`Request doesn't match for ${caseName}/${loopDir}. Actual data saved to ${loopDir}/llm-request.actual.jsonl`);
                }
                await this.deleteActualDataIfExists(caseName, loopDir, filename);
                logger.success(`\u{2705} LLM request comparison passed for ${caseName}/${loopDir}`);
                return true;
            }
            async verifyToolCallsSnapshot(caseName, loopDir, actualToolCalls, updateSnapshots = false) {
                actualToolCalls = JSON.parse(JSON.stringify(actualToolCalls));
                const filename = 'tool-calls.jsonl';
                const expectedToolCalls = await this.readSnapshot(caseName, loopDir, filename);
                if (!expectedToolCalls) {
                    if (updateSnapshots) {
                        await this.writeSnapshot(caseName, loopDir, filename, actualToolCalls);
                        logger.success(`\u{2705} Created new tool calls snapshot for ${caseName}/${loopDir}`);
                        return true;
                    }
                    throw new Error(`No tool calls snapshot found for ${caseName}/${loopDir}`);
                }
                if (updateSnapshots) {
                    await this.writeSnapshot(caseName, loopDir, filename, actualToolCalls);
                    logger.warn(`\u{26A0}\u{FE0F} Skipping tool calls verification for ${caseName}/${loopDir}, updating snapshot directly`);
                    return true;
                }
                const result = this.normalizer.compare(expectedToolCalls, actualToolCalls);
                if (!result.equal) {
                    await this.writeActualData(caseName, loopDir, filename, actualToolCalls);
                    logger.error(`\u{274C} Tool calls comparison failed for ${caseName}/${loopDir}:\n${result.diff}`);
                    throw new Error(`Tool calls don't match for ${caseName}/${loopDir}. Actual data saved to ${loopDir}/tool-calls.actual.jsonl`);
                }
                await this.deleteActualDataIfExists(caseName, loopDir, filename);
                logger.success(`\u{2705} Tool calls comparison passed for ${caseName}/${loopDir}`);
                return true;
            }
            async createTestCaseStructure(caseName, numLoops) {
                const caseDir = external_path_default().join(this.fixturesRoot, caseName);
                if (!external_fs_default().existsSync(caseDir)) await external_fs_default().promises.mkdir(caseDir, {
                    recursive: true
                });
                for(let i = 1; i <= numLoops; i++){
                    const loopDir = external_path_default().join(caseDir, `loop-${i}`);
                    if (!external_fs_default().existsSync(loopDir)) await external_fs_default().promises.mkdir(loopDir, {
                        recursive: true
                    });
                }
                const initialDir = external_path_default().join(caseDir, 'initial');
                if (!external_fs_default().existsSync(initialDir)) await external_fs_default().promises.mkdir(initialDir, {
                    recursive: true
                });
                return caseDir;
            }
            async writeStreamingChunks(caseName, loopDir, filename, chunks, updateIfExists = false) {
                const filePath = this.getSnapshotPath(caseName, loopDir, filename);
                const dirPath = external_path_default().dirname(filePath);
                if (!external_fs_default().existsSync(dirPath)) await external_fs_default().promises.mkdir(dirPath, {
                    recursive: true
                });
                if (external_fs_default().existsSync(filePath) && !updateIfExists) return void logger.info(`Skipping write to existing file: ${filePath}`);
                try {
                    const chunksAsJsonLines = chunks.map((chunk)=>JSON.stringify(chunk)).join('\n');
                    await external_fs_default().promises.writeFile(filePath, chunksAsJsonLines, 'utf-8');
                    logger.info(`Stream chunks written to ${filePath} (${chunks.length} chunks)`);
                } catch (error) {
                    logger.error(`Error writing stream chunks to ${filePath}: ${error}`);
                    throw error;
                }
            }
            async readStreamingChunks(caseName, loopDir, filename) {
                const filePath = this.getSnapshotPath(caseName, loopDir, filename);
                if (!external_fs_default().existsSync(filePath)) return [];
                try {
                    const content = await external_fs_default().promises.readFile(filePath, 'utf-8');
                    const lines = content.split('\n').filter((line)=>line.trim());
                    if (0 === lines.length) return [];
                    try {
                        return lines.map((line)=>JSON.parse(line));
                    } catch (lineParseError) {
                        logger.error(`Error parsing streaming chunks: ${lineParseError}`);
                        throw lineParseError;
                    }
                } catch (error) {
                    logger.error(`Error reading streaming chunks from ${filePath}: ${error}`);
                    return [];
                }
            }
            updateAgentNormalizerConfig(config) {
                this.normalizer = new AgentSnapshotNormalizer(config);
            }
            constructor(fixturesRoot, normalizerConfig){
                snapshot_manager_define_property(this, "fixturesRoot", void 0);
                snapshot_manager_define_property(this, "normalizer", void 0);
                this.fixturesRoot = fixturesRoot;
                this.normalizer = new AgentSnapshotNormalizer(normalizerConfig);
            }
        }
        function agent_hook_base_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class AgentHookBase {
            setCurrentRunOptions(options) {
                this.currentRunOptions = options;
            }
            hookAgent() {
                if (this.isHooked) return false;
                this.originalRequestHook = this.agent.onLLMRequest;
                this.originalResponseHook = this.agent.onLLMResponse;
                this.originalStreamingResponseHook = this.agent.onLLMStreamingResponse;
                this.originalLoopEndHook = this.agent.onAgentLoopEnd;
                this.originalEachLoopStartHook = this.agent.onEachAgentLoopStart;
                this.originalBeforeToolCallHook = this.agent.onBeforeToolCall;
                this.originalAfterToolCallHook = this.agent.onAfterToolCall;
                this.originalToolCallErrorHook = this.agent.onToolCallError;
                this.originalProcessToolCallsHook = this.agent.onProcessToolCalls;
                this.agent.onLLMRequest = (id, payload)=>this.safeExecuteHook(()=>this.onLLMRequest(id, payload));
                this.agent.onLLMResponse = (id, payload)=>this.safeExecuteHook(()=>this.onLLMResponse(id, payload));
                this.agent.onLLMStreamingResponse = (id, payload)=>this.safeExecuteHook(()=>this.onLLMStreamingResponse(id, payload));
                this.agent.onAgentLoopEnd = (id)=>this.safeExecuteHook(()=>this.onAgentLoopEnd(id));
                this.agent.onEachAgentLoopStart = (id)=>this.safeExecuteHook(()=>this.onEachAgentLoopStart(id));
                this.agent.onBeforeToolCall = (id, toolCall, args)=>this.safeExecuteHook(()=>this.onBeforeToolCall(id, toolCall, args));
                this.agent.onAfterToolCall = (id, toolCall, result)=>this.safeExecuteHook(()=>this.onAfterToolCall(id, toolCall, result));
                this.agent.onToolCallError = (id, toolCall, error)=>this.safeExecuteHook(()=>this.onToolCallError(id, toolCall, error));
                this.agent.onProcessToolCalls = (id, toolCalls)=>this.safeExecuteHook(()=>this.onProcessToolCalls(id, toolCalls));
                this.isHooked = true;
                logger.info(`Hooked into agent: ${this.snapshotName}`);
                return true;
            }
            unhookAgent(force = false) {
                if (!this.isHooked && !force) return false;
                if (this.originalRequestHook) this.agent.onLLMRequest = this.originalRequestHook;
                if (this.originalResponseHook) this.agent.onLLMResponse = this.originalResponseHook;
                if (this.originalStreamingResponseHook) this.agent.onLLMStreamingResponse = this.originalStreamingResponseHook;
                if (this.originalLoopEndHook) this.agent.onAgentLoopEnd = this.originalLoopEndHook;
                if (this.originalEachLoopStartHook) this.agent.onEachAgentLoopStart = this.originalEachLoopStartHook;
                if (this.originalBeforeToolCallHook) this.agent.onBeforeToolCall = this.originalBeforeToolCallHook;
                if (this.originalAfterToolCallHook) this.agent.onAfterToolCall = this.originalAfterToolCallHook;
                if (this.originalToolCallErrorHook) this.agent.onToolCallError = this.originalToolCallErrorHook;
                if (this.originalProcessToolCallsHook) this.agent.onProcessToolCalls = this.originalProcessToolCallsHook;
                this.isHooked = false;
                logger.info(`Unhooked from agent: ${this.snapshotName}`);
                return true;
            }
            async safeExecuteHook(hookFn) {
                try {
                    const result = await hookFn();
                    if (result instanceof Promise) return result.catch((error)=>{
                        this.lastError = error;
                        logger.error(`Hook execution error: ${error.message}`);
                        throw error;
                    });
                    return result;
                } catch (error) {
                    this.lastError = error;
                    logger.error(`Hook execution error: ${error.message}`);
                }
            }
            hasError() {
                return null !== this.lastError;
            }
            getLastError() {
                return this.lastError;
            }
            clearError() {
                this.lastError = null;
            }
            writeStreamingChunks(filePath, chunks) {
                if (!chunks || 0 === chunks.length) return;
                try {
                    const chunksAsJsonLines = chunks.map((chunk)=>JSON.stringify(chunk)).join('\n');
                    external_fs_default().writeFileSync(filePath, chunksAsJsonLines, 'utf-8');
                    logger.debug(`${chunks.length} chunks written to ${filePath}`);
                } catch (error) {
                    logger.error(`Error writing streaming chunks: ${error}`);
                    this.lastError = error;
                    throw error;
                }
            }
            constructor(agent, options){
                agent_hook_base_define_property(this, "agent", void 0);
                agent_hook_base_define_property(this, "snapshotPath", void 0);
                agent_hook_base_define_property(this, "snapshotName", void 0);
                agent_hook_base_define_property(this, "originalRequestHook", null);
                agent_hook_base_define_property(this, "originalResponseHook", null);
                agent_hook_base_define_property(this, "originalLoopEndHook", null);
                agent_hook_base_define_property(this, "originalEachLoopStartHook", null);
                agent_hook_base_define_property(this, "originalStreamingResponseHook", null);
                agent_hook_base_define_property(this, "originalBeforeToolCallHook", null);
                agent_hook_base_define_property(this, "originalAfterToolCallHook", null);
                agent_hook_base_define_property(this, "originalToolCallErrorHook", null);
                agent_hook_base_define_property(this, "originalProcessToolCallsHook", null);
                agent_hook_base_define_property(this, "isHooked", false);
                agent_hook_base_define_property(this, "currentRunOptions", void 0);
                agent_hook_base_define_property(this, "snapshotManager", void 0);
                agent_hook_base_define_property(this, "lastError", null);
                this.agent = agent;
                this.snapshotPath = options.snapshotPath;
                this.snapshotName = options.snapshotName;
                if (!external_fs_default().existsSync(this.snapshotPath)) external_fs_default().mkdirSync(this.snapshotPath, {
                    recursive: true
                });
            }
        }
        function agent_generate_snapshot_hook_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class AgentGenerateSnapshotHook extends AgentHookBase {
            onEachAgentLoopStart(id) {
                logger.info(`Starting agent loop ${this.agent.getCurrentLoopIteration()}`);
                const currentLoop = this.agent.getCurrentLoopIteration();
                if (!this.toolCallsByLoop[currentLoop]) this.toolCallsByLoop[currentLoop] = [];
                if (this.originalEachLoopStartHook) return this.originalEachLoopStartHook.call(this.agent, id);
            }
            onLLMRequest(id, payload) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                this.llmRequests[currentLoop] = payload;
                const loopDir = external_path_default().join(this.snapshotPath, `loop-${currentLoop}`);
                if (!external_fs_default().existsSync(loopDir)) external_fs_default().mkdirSync(loopDir, {
                    recursive: true
                });
                external_fs_default().writeFileSync(external_path_default().join(loopDir, 'llm-request.jsonl'), JSON.stringify(payload, null, 2), 'utf-8');
                const events = this.agent.getEventStream().getEvents();
                external_fs_default().writeFileSync(external_path_default().join(loopDir, 'event-stream.jsonl'), JSON.stringify(events, null, 2), 'utf-8');
                if (this.originalRequestHook) return this.originalRequestHook.call(this.agent, id, payload);
            }
            onLLMResponse(id, payload) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                this.llmResponses[currentLoop] = payload;
                if (this.originalResponseHook) return this.originalResponseHook.call(this.agent, id, payload);
            }
            onLLMStreamingResponse(id, payload) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                const loopDir = `loop-${currentLoop}`;
                try {
                    const responsePath = external_path_default().join(this.snapshotPath, loopDir, 'llm-response.jsonl');
                    this.writeStreamingChunks(responsePath, payload.chunks);
                    logger.info(`Saved ${payload.chunks.length} streaming chunks for ${loopDir}`);
                } catch (error) {
                    logger.error(`Failed to save streaming chunks: ${error}`);
                }
                if (this.originalStreamingResponseHook) this.originalStreamingResponseHook.call(this.agent, id, payload);
            }
            onBeforeToolCall(id, toolCall, args) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                this.startTimeByToolCall[toolCall.toolCallId] = Date.now();
                if (!this.toolCallsByLoop[currentLoop]) this.toolCallsByLoop[currentLoop] = [];
                this.toolCallsByLoop[currentLoop].push({
                    toolCallId: toolCall.toolCallId,
                    name: toolCall.name,
                    args
                });
                logger.debug(`Tool call captured for ${toolCall.name} (${toolCall.toolCallId}) in loop ${currentLoop}`);
                if (this.originalBeforeToolCallHook) return this.originalBeforeToolCallHook.call(this.agent, id, toolCall, args);
                return args;
            }
            onAfterToolCall(id, toolCall, result) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                const executionTime = Date.now() - (this.startTimeByToolCall[toolCall.toolCallId] || Date.now());
                if (this.toolCallsByLoop[currentLoop]) {
                    const toolCallData = this.toolCallsByLoop[currentLoop].find((tc)=>tc.toolCallId === toolCall.toolCallId);
                    if (toolCallData) {
                        toolCallData.result = result;
                        toolCallData.executionTime = executionTime;
                    }
                }
                logger.debug(`Tool call result captured for ${toolCall.name} (${toolCall.toolCallId}) in loop ${currentLoop}`);
                this.saveToolCalls(currentLoop);
                if (this.originalAfterToolCallHook) return this.originalAfterToolCallHook.call(this.agent, id, toolCall, result);
                return result;
            }
            onToolCallError(id, toolCall, error) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                const executionTime = Date.now() - (this.startTimeByToolCall[toolCall.toolCallId] || Date.now());
                if (this.toolCallsByLoop[currentLoop]) {
                    const toolCallData = this.toolCallsByLoop[currentLoop].find((tc)=>tc.toolCallId === toolCall.toolCallId);
                    if (toolCallData) {
                        toolCallData.error = error;
                        toolCallData.executionTime = executionTime;
                    }
                }
                logger.debug(`Tool call error captured for ${toolCall.name} (${toolCall.toolCallId}) in loop ${currentLoop}`);
                this.saveToolCalls(currentLoop);
                if (this.originalToolCallErrorHook) return this.originalToolCallErrorHook.call(this.agent, id, toolCall, error);
                return `Error: ${error}`;
            }
            saveToolCalls(loopNumber) {
                if (!this.toolCallsByLoop[loopNumber] || 0 === this.toolCallsByLoop[loopNumber].length) return;
                try {
                    const loopDir = external_path_default().join(this.snapshotPath, `loop-${loopNumber}`);
                    if (!external_fs_default().existsSync(loopDir)) external_fs_default().mkdirSync(loopDir, {
                        recursive: true
                    });
                    external_fs_default().writeFileSync(external_path_default().join(loopDir, 'tool-calls.jsonl'), JSON.stringify(this.toolCallsByLoop[loopNumber], null, 2), 'utf-8');
                    logger.info(`Saved ${this.toolCallsByLoop[loopNumber].length} tool calls for loop ${loopNumber}`);
                } catch (error) {
                    logger.error(`Failed to save tool calls for loop ${loopNumber}: ${error}`);
                }
            }
            onAgentLoopEnd(id) {
                const finalEvents = this.agent.getEventStream().getEvents();
                external_fs_default().writeFileSync(external_path_default().join(this.snapshotPath, 'event-stream.jsonl'), JSON.stringify(finalEvents, null, 2), 'utf-8');
                logger.info(`Snapshot generation completed: ${this.snapshotPath}`);
                if (this.originalLoopEndHook) return this.originalLoopEndHook.call(this.agent, id);
            }
            onProcessToolCalls(id, toolCalls) {}
            constructor(agent, options){
                super(agent, options), agent_generate_snapshot_hook_define_property(this, "llmRequests", {}), agent_generate_snapshot_hook_define_property(this, "llmResponses", {}), agent_generate_snapshot_hook_define_property(this, "toolCallsByLoop", {}), agent_generate_snapshot_hook_define_property(this, "startTimeByToolCall", {});
            }
        }
        function agent_replay_snapshot_hook_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class AgentReplaySnapshotHook extends AgentHookBase {
            async setup(agent, casePath, totalLoops, options = {}) {
                var _options_verification, _options_verification1, _options_verification2;
                this.agent = agent;
                this.snapshotPath = casePath;
                this.snapshotName = external_path_default().basename(casePath);
                this.totalLoops = totalLoops;
                this.updateSnapshots = options.updateSnapshots || false;
                this.verifyLLMRequests = (null == (_options_verification = options.verification) ? void 0 : _options_verification.verifyLLMRequests) !== false;
                this.verifyEventStreams = (null == (_options_verification1 = options.verification) ? void 0 : _options_verification1.verifyEventStreams) !== false;
                this.verifyToolCalls = (null == (_options_verification2 = options.verification) ? void 0 : _options_verification2.verifyToolCalls) !== false;
                this.snapshotManager = new SnapshotManager(external_path_default().dirname(casePath), options.normalizerConfig);
                this.hookAgent();
                this.mockLLMClient = this.createMockLLMClient();
                logger.info(`LLM mocker set up for ${this.snapshotName} with ${totalLoops} loops`);
                logger.info(`Verification settings: LLM requests: ${this.verifyLLMRequests ? 'enabled' : 'disabled'}, Event streams: ${this.verifyEventStreams ? 'enabled' : 'disabled'}, Tool calls: ${this.verifyToolCalls ? 'enabled' : 'disabled'}`);
                if (this.verifyEventStreams) await this.verifyInitialEventStreamState();
            }
            storeFinalEventStreamState(events) {
                this.finalEventStreamState = [
                    ...events
                ];
            }
            getFinalEventStreamState() {
                return this.finalEventStreamState;
            }
            getMockLLMClient() {
                return this.mockLLMClient;
            }
            restore() {
                this.unhookAgent();
                this.mockLLMClient = void 0;
                logger.info('Restored original LLM hooks and client');
            }
            createMockLLMClient() {
                return {
                    chat: {
                        completions: {
                            create: async (request)=>{
                                var _this_agent, _this_snapshotManager;
                                const currentLoop = null == (_this_agent = this.agent) ? void 0 : _this_agent.getCurrentLoopIteration();
                                logger.info(`[Mock LLM Client] Creating chat completion for loop ${currentLoop} with args: ` + JSON.stringify(request, null, 2));
                                const loopDir = `loop-${currentLoop}`;
                                const mockResponse = await (null == (_this_snapshotManager = this.snapshotManager) ? void 0 : _this_snapshotManager.readSnapshot(external_path_default().basename(this.snapshotPath), loopDir, 'llm-response.jsonl'));
                                if (!mockResponse) {
                                    const error = new Error(`No mock response found for ${loopDir}`);
                                    this.lastError = error;
                                }
                                logger.info(`[Mock LLM Response] Loop ${currentLoop}: Type: ${Array.isArray(mockResponse) ? 'array' : 'object'}, Length: ${Array.isArray(mockResponse) ? mockResponse.length : 1}`);
                                logger.success(`\u{2705} Using mock LLM response from snapshot for ${loopDir}`);
                                if (!request.stream) return mockResponse;
                                {
                                    const streamResponse = Array.isArray(mockResponse) ? mockResponse : [
                                        mockResponse
                                    ];
                                    logger.info(`Creating streaming response with ${streamResponse.length} chunks for loop ${currentLoop}`);
                                    streamResponse.forEach((chunk, idx)=>{
                                        if (!chunk.id || !chunk.object || !chunk.choices) logger.warn(`Chunk ${idx} may have invalid structure: ${JSON.stringify(chunk)}`);
                                    });
                                    return this.createAsyncIterable(streamResponse);
                                }
                            }
                        }
                    }
                };
            }
            async verifyInitialEventStreamState() {
                if (!this.snapshotPath || !this.snapshotManager || !this.agent) throw new Error('LLMMocker not properly set up');
                logger.info(`\u{1F50D} Verifying initial event stream state before first loop`);
                const events = this.agent.getEventStream().getEvents();
                if (events.length > 0) try {
                    await this.snapshotManager.verifyEventStreamSnapshot(external_path_default().basename(this.snapshotPath), 'initial', events, this.updateSnapshots);
                    logger.success(`\u{2705} Initial event stream verification succeeded`);
                } catch (error) {
                    logger.error(`\u{274C} Initial event stream verification failed: ${error}`);
                    if (!this.updateSnapshots) throw error;
                }
            }
            createAsyncIterable(chunks) {
                logger.info(`Creating AsyncIterable with ${chunks.length} chunks`);
                return {
                    [Symbol.asyncIterator] () {
                        let index = 0;
                        let iteratorClosed = false;
                        logger.info(`AsyncIterator created for ${chunks.length} chunks`);
                        return {
                            async next () {
                                if (iteratorClosed) {
                                    logger.info("Iterator already closed, returning done");
                                    return {
                                        done: true,
                                        value: void 0
                                    };
                                }
                                if (index < chunks.length) {
                                    const chunk = chunks[index];
                                    logger.info(`Yielding chunk ${index + 1}/${chunks.length}`);
                                    index++;
                                    return {
                                        done: false,
                                        value: chunk
                                    };
                                }
                                logger.info(`Iterator completed after yielding ${index} chunks`);
                                iteratorClosed = true;
                                return {
                                    done: true,
                                    value: void 0
                                };
                            },
                            async return () {
                                logger.info(`Iterator return() called early at index ${index}/${chunks.length}`);
                                iteratorClosed = true;
                                return {
                                    done: true,
                                    value: void 0
                                };
                            },
                            async throw (error) {
                                logger.error(`Error in streaming response iterator: ${error}`);
                                iteratorClosed = true;
                                return {
                                    done: true,
                                    value: void 0
                                };
                            }
                        };
                    }
                };
            }
            onEachAgentLoopStart(id) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                if (!this.toolCallsByLoop[currentLoop]) this.toolCallsByLoop[currentLoop] = [];
                if (this.originalEachLoopStartHook) return this.originalEachLoopStartHook.call(this.agent, id);
            }
            async onLLMRequest(id, payload) {
                if (!this.snapshotPath || !this.snapshotManager) throw new Error('LLMMocker not properly set up');
                const currentLoop = this.agent.getCurrentLoopIteration();
                const loopDir = `loop-${currentLoop}`;
                logger.info(`\u{1F504} Intercepted LLM request for loop ${currentLoop}`);
                const events = this.agent.getEventStream().getEvents();
                this.eventStreamStatesByLoop.set(currentLoop, [
                    ...events
                ]);
                if (this.verifyEventStreams) try {
                    logger.info(`\u{1F50D} Verifying event stream state at the beginning of ${loopDir}`);
                    if (this.updateSnapshots) logger.warn(`\u{26A0}\u{FE0F} Update mode enabled: directly updating event stream snapshot for ${loopDir}`);
                    await this.snapshotManager.verifyEventStreamSnapshot(external_path_default().basename(this.snapshotPath), loopDir, events, this.updateSnapshots);
                } catch (error) {
                    logger.error(`\u{274C} Event stream verification failed for ${loopDir}: ${error}`);
                    if (!this.updateSnapshots) throw error;
                }
                else logger.info(`Event stream verification skipped for ${loopDir} (disabled in config)`);
                if (this.verifyLLMRequests) try {
                    if (this.updateSnapshots) logger.warn(`\u{26A0}\u{FE0F} Update mode enabled: directly updating LLM request snapshot for ${loopDir}`);
                    await this.snapshotManager.verifyRequestSnapshot(external_path_default().basename(this.snapshotPath), loopDir, payload, this.updateSnapshots);
                } catch (error) {
                    logger.error(`\u{274C} Request verification failed for ${loopDir}: ${error}`);
                    if (!this.updateSnapshots) throw error;
                }
                else logger.info(`LLM request verification skipped for ${loopDir} (disabled in config)`);
                if (this.originalRequestHook) await this.originalRequestHook.call(this.agent, id, payload);
            }
            async onLLMResponse(id, payload) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                logger.debug(`LLM response hook called for loop ${currentLoop}`);
                if (this.originalResponseHook) await this.originalResponseHook.call(this.agent, id, payload);
            }
            onLLMStreamingResponse(id, payload) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                logger.debug(`LLM onStreamingResponseHook called for loop ${currentLoop}`);
                if (this.originalStreamingResponseHook) this.originalStreamingResponseHook.call(this.agent, id, payload);
            }
            onBeforeToolCall(id, toolCall, args) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                this.startTimeByToolCall[toolCall.toolCallId] = Date.now();
                if (this.verifyToolCalls) this.loadToolCallsFromSnapshot(currentLoop).catch((error)=>{
                    logger.error(`Error loading tool calls from snapshot: ${error}`);
                    if (!this.updateSnapshots) this.lastError = error instanceof Error ? error : new Error(String(error));
                });
                if (!this.toolCallsByLoop[currentLoop]) this.toolCallsByLoop[currentLoop] = [];
                this.toolCallsByLoop[currentLoop].push({
                    toolCallId: toolCall.toolCallId,
                    name: toolCall.name,
                    args
                });
                logger.debug(`Tool call intercepted for ${toolCall.name} (${toolCall.toolCallId}) in loop ${currentLoop}`);
                if (this.originalBeforeToolCallHook) return this.originalBeforeToolCallHook.call(this.agent, id, toolCall, args);
                return args;
            }
            onAfterToolCall(id, toolCall, result) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                const executionTime = Date.now() - (this.startTimeByToolCall[toolCall.toolCallId] || Date.now());
                if (this.toolCallsByLoop[currentLoop]) {
                    const toolCallData = this.toolCallsByLoop[currentLoop].find((tc)=>tc.toolCallId === toolCall.toolCallId);
                    if (toolCallData) {
                        toolCallData.result = result;
                        toolCallData.executionTime = executionTime;
                    }
                }
                logger.debug(`Tool call result intercepted for ${toolCall.name} (${toolCall.toolCallId}) in loop ${currentLoop}`);
                if (this.verifyToolCalls) this.verifyToolCallsForLoop(currentLoop).catch((error)=>{
                    logger.error(`Error verifying tool calls: ${error}`);
                    if (!this.updateSnapshots) this.lastError = error instanceof Error ? error : new Error(String(error));
                });
                if (this.originalAfterToolCallHook) return this.originalAfterToolCallHook.call(this.agent, id, toolCall, result);
                return result;
            }
            onToolCallError(id, toolCall, error) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                const executionTime = Date.now() - (this.startTimeByToolCall[toolCall.toolCallId] || Date.now());
                if (this.toolCallsByLoop[currentLoop]) {
                    const toolCallData = this.toolCallsByLoop[currentLoop].find((tc)=>tc.toolCallId === toolCall.toolCallId);
                    if (toolCallData) {
                        toolCallData.error = error;
                        toolCallData.executionTime = executionTime;
                    }
                }
                logger.debug(`Tool call error intercepted for ${toolCall.name} (${toolCall.toolCallId}) in loop ${currentLoop}`);
                if (this.verifyToolCalls) this.verifyToolCallsForLoop(currentLoop).catch((error)=>{
                    logger.error(`Error verifying tool calls: ${error}`);
                    if (!this.updateSnapshots) this.lastError = error instanceof Error ? error : new Error(String(error));
                });
                if (this.originalToolCallErrorHook) return this.originalToolCallErrorHook.call(this.agent, id, toolCall, error);
                return `Error: ${error}`;
            }
            async onProcessToolCalls(id, toolCalls) {
                if (!this.verifyToolCalls) return;
                const currentLoop = this.agent.getCurrentLoopIteration();
                const loopDir = `loop-${currentLoop}`;
                try {
                    var _this_snapshotManager;
                    const savedToolCalls = await (null == (_this_snapshotManager = this.snapshotManager) ? void 0 : _this_snapshotManager.readSnapshot(external_path_default().basename(this.snapshotPath), loopDir, 'tool-calls.jsonl'));
                    if (!savedToolCalls || 0 === savedToolCalls.length) return void logger.warn(`No saved tool calls found for ${loopDir}, executing real tools`);
                    if (savedToolCalls.length !== toolCalls.length) logger.warn(`Tool call count mismatch in ${loopDir}: expected ${toolCalls.length} but found ${savedToolCalls.length} in snapshot`);
                    const results = [];
                    for(let i = 0; i < toolCalls.length; i++){
                        const toolCall = toolCalls[i];
                        const savedToolCall = savedToolCalls.find((stc)=>stc.name === toolCall.function.name);
                        if (savedToolCall) results.push({
                            toolCallId: toolCall.id,
                            toolName: toolCall.function.name,
                            content: savedToolCall.result || savedToolCall.error || 'No result in snapshot'
                        });
                        else {
                            logger.warn(`No matching saved tool call found for ${toolCall.function.name} in ${loopDir}`);
                            results.push({
                                toolCallId: toolCall.id,
                                toolName: toolCall.function.name,
                                content: "Mock result: No saved result found for this tool in snapshot"
                            });
                        }
                    }
                    logger.info(`Replaying ${results.length} tool call results from snapshot`);
                    return results;
                } catch (error) {
                    logger.error(`Error replaying tool calls: ${error}`);
                    return;
                }
            }
            async loadToolCallsFromSnapshot(loopNumber) {
                if (!this.snapshotManager) return;
                const loopDir = `loop-${loopNumber}`;
                const toolCalls = await this.snapshotManager.readSnapshot(external_path_default().basename(this.snapshotPath), loopDir, 'tool-calls.jsonl');
                if (!toolCalls || 0 === toolCalls.length) return void logger.debug(`No tool calls found in snapshot for ${loopDir}`);
                logger.debug(`Loaded ${toolCalls.length} tool calls from snapshot for ${loopDir}`);
            }
            async verifyToolCallsForLoop(loopNumber) {
                if (!this.snapshotManager || !this.toolCallsByLoop[loopNumber]) return;
                const loopDir = `loop-${loopNumber}`;
                try {
                    await this.snapshotManager.verifyToolCallsSnapshot(external_path_default().basename(this.snapshotPath), loopDir, this.toolCallsByLoop[loopNumber], this.updateSnapshots);
                    logger.success(`\u{2705} Tool calls verification succeeded for ${loopDir}`);
                } catch (error) {
                    logger.error(`\u{274C} Tool calls verification failed for ${loopDir}: ${error}`);
                    if (!this.updateSnapshots) throw error;
                }
            }
            async onAgentLoopEnd(id) {
                if (!this.snapshotPath || !this.snapshotManager || !this.agent) throw new Error('LLMMocker not properly set up');
                logger.info(`\u{1F504} Agent loop execution completed`);
                const finalEvents = this.agent.getEventStream().getEvents();
                this.finalEventStreamState = finalEvents;
                if (this.verifyEventStreams) try {
                    logger.info(`\u{1F50D} Verifying final event stream state after agent completion`);
                    await this.snapshotManager.verifyEventStreamSnapshot(external_path_default().basename(this.snapshotPath), '', JSON.parse(JSON.stringify(finalEvents)), this.updateSnapshots);
                    logger.success(`\u{2705} Final event stream verification succeeded`);
                } catch (error) {
                    logger.error(`\u{274C} Final event stream verification failed: ${error}`);
                    if (!this.updateSnapshots) throw error;
                }
                else logger.info("Final event stream verification skipped (disabled in config)");
                if (!this.hasError() && this.snapshotManager) await this.snapshotManager.cleanupAllActualFiles(external_path_default().basename(this.snapshotPath));
                if (this.originalLoopEndHook) await this.originalLoopEndHook.call(this.agent, id);
            }
            getEventStreamStateAfterLoop(loopNumber) {
                const events = this.eventStreamStatesByLoop.get(loopNumber);
                if (!events) throw new Error(`No event stream state found for loop ${loopNumber}`);
                return events;
            }
            constructor(...args){
                super(...args), agent_replay_snapshot_hook_define_property(this, "totalLoops", 0), agent_replay_snapshot_hook_define_property(this, "updateSnapshots", false), agent_replay_snapshot_hook_define_property(this, "eventStreamStatesByLoop", new Map()), agent_replay_snapshot_hook_define_property(this, "finalEventStreamState", []), agent_replay_snapshot_hook_define_property(this, "mockLLMClient", void 0), agent_replay_snapshot_hook_define_property(this, "verifyLLMRequests", true), agent_replay_snapshot_hook_define_property(this, "verifyEventStreams", true), agent_replay_snapshot_hook_define_property(this, "verifyToolCalls", true), agent_replay_snapshot_hook_define_property(this, "toolCallsByLoop", {}), agent_replay_snapshot_hook_define_property(this, "startTimeByToolCall", {});
            }
        }
        function agent_snapshot_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class agent_snapshot_AgentSnapshot {
            async run(runOptions) {
                logger.info(`AgentSnapshot.run called with ${'string' == typeof runOptions ? 'string' : 'options object'}`);
                if (!this.generateHook) this.generateHook = new AgentGenerateSnapshotHook(this.hostedAgent, {
                    snapshotPath: this.options.snapshotPath,
                    snapshotName: this.snapshotName
                });
                this.generateHook.setCurrentRunOptions(runOptions);
                this.generateHook.hookAgent();
                try {
                    const isStreaming = 'object' == typeof runOptions && (0, dist.isAgentRunObjectOptions)(runOptions) && (0, dist.isStreamingOptions)(runOptions);
                    logger.info(`Executing agent with ${isStreaming ? 'streaming' : 'non-streaming'} mode`);
                    const response = await this.hostedAgent.run(runOptions);
                    return response;
                } catch (error) {
                    logger.error(`Error during AgentSnapshot.run: ${error}`);
                    throw error;
                } finally{
                    if (this.generateHook) this.generateHook.clearError();
                }
            }
            async generate(runOptions) {
                const snapshotName = this.snapshotName || `agent-snapshot-${Date.now()}`;
                this.generateHook = new AgentGenerateSnapshotHook(this.hostedAgent, {
                    snapshotPath: this.options.snapshotPath || external_path_default().join(process.cwd(), 'fixtures'),
                    snapshotName: snapshotName
                });
                if (this.snapshotPath) {
                    if (!external_fs_default().existsSync(this.snapshotPath)) external_fs_default().mkdirSync(this.snapshotPath, {
                        recursive: true
                    });
                }
                logger.info(`Starting snapshot generation for '${snapshotName}'`);
                const startTime = Date.now();
                this.generateHook.setCurrentRunOptions(runOptions);
                this.generateHook.hookAgent();
                try {
                    const response = await this.hostedAgent.run(runOptions);
                    if (this.generateHook.hasError()) {
                        const error = this.generateHook.getLastError();
                        logger.error(`Error occurred during snapshot generation: ${null == error ? void 0 : error.message}`);
                        throw error;
                    }
                    const events = this.hostedAgent.getEventStream().getEvents();
                    const snapshotPath = external_path_default().join(this.options.snapshotPath);
                    const loopCount = this.countLoops(snapshotPath);
                    logger.success(`Successfully generated snapshot with ${loopCount} loops`);
                    return {
                        snapshotPath,
                        loopCount,
                        response,
                        events,
                        meta: {
                            snapshotName: this.snapshotName,
                            executionTime: Date.now() - startTime
                        }
                    };
                } catch (error) {
                    logger.error(`Snapshot generation failed: ${error}`);
                    throw error;
                } finally{
                    if (this.generateHook) this.generateHook.clearError();
                }
            }
            async replay(runOptions, config) {
                var _config_verification, _this_options_verification, _config_verification1, _this_options_verification1, _config_verification2, _this_options_verification2;
                const snapshotName = this.options.snapshotName || external_path_default().basename(this.options.snapshotPath);
                const updateSnapshots = (null == config ? void 0 : config.updateSnapshots) || this.options.updateSnapshots || false;
                if (null == config ? void 0 : config.normalizerConfig) this.snapshotManager.updateAgentNormalizerConfig(config.normalizerConfig);
                const verification = {
                    verifyLLMRequests: (null == config ? void 0 : null == (_config_verification = config.verification) ? void 0 : _config_verification.verifyLLMRequests) !== void 0 ? config.verification.verifyLLMRequests : (null == (_this_options_verification = this.options.verification) ? void 0 : _this_options_verification.verifyLLMRequests) !== false,
                    verifyEventStreams: (null == config ? void 0 : null == (_config_verification1 = config.verification) ? void 0 : _config_verification1.verifyEventStreams) !== void 0 ? config.verification.verifyEventStreams : (null == (_this_options_verification1 = this.options.verification) ? void 0 : _this_options_verification1.verifyEventStreams) !== false,
                    verifyToolCalls: (null == config ? void 0 : null == (_config_verification2 = config.verification) ? void 0 : _config_verification2.verifyToolCalls) !== void 0 ? config.verification.verifyToolCalls : (null == (_this_options_verification2 = this.options.verification) ? void 0 : _this_options_verification2.verifyToolCalls) !== false
                };
                if (!external_fs_default().existsSync(this.snapshotPath)) throw new Error(`Snapshot directory not found: ${this.snapshotPath}. Generate snapshots first using .generate()`);
                logger.info(`Running test against snapshot '${snapshotName}'${updateSnapshots ? ' (update mode)' : ''}`);
                logger.info(`Verification settings: 
      LLM requests: ${verification.verifyLLMRequests ? 'enabled' : 'disabled'}, 
      Event streams: ${verification.verifyEventStreams ? 'enabled' : 'disabled'},
      Tool calls: ${verification.verifyToolCalls ? 'enabled' : 'disabled'}`);
                const loopCount = this.countLoops(this.snapshotPath);
                logger.info(`Found ${loopCount} loops in test case`);
                const startTime = Date.now();
                try {
                    await this.replayHook.setup(this.hostedAgent, this.snapshotPath, loopCount, {
                        updateSnapshots,
                        normalizerConfig: (null == config ? void 0 : config.normalizerConfig) || this.options.normalizerConfig,
                        verification
                    });
                    if (this.replayHook.hasError()) {
                        const error = this.replayHook.getLastError();
                        logger.error(`Error occurred during test setup: ${null == error ? void 0 : error.message}`);
                        throw error;
                    }
                    const mockLLMClient = this.replayHook.getMockLLMClient();
                    this.hostedAgent.setCustomLLMClient(mockLLMClient);
                    const isStreaming = 'object' == typeof runOptions && (0, dist.isStreamingOptions)(runOptions);
                    let response;
                    let events = [];
                    this.hostedAgent._setIsReplay();
                    if (isStreaming) {
                        const asyncIterable = await this.hostedAgent.run(runOptions);
                        const streamEvents = [];
                        logger.info("Processing streaming response...");
                        for await (const event of asyncIterable){
                            if (this.replayHook.hasError()) {
                                const error = this.replayHook.getLastError();
                                logger.error(`Error occurred during streaming: ${null == error ? void 0 : error.message}`);
                                throw error;
                            }
                            streamEvents.push(event);
                        }
                        response = asyncIterable;
                        events = this.hostedAgent.getEventStream().getEvents();
                        logger.success(`Streaming execution completed with ${streamEvents.length} events`);
                    } else {
                        response = await this.hostedAgent.run(runOptions);
                        if (this.replayHook.hasError()) {
                            const error = this.replayHook.getLastError();
                            logger.error(`Error occurred during execution: ${null == error ? void 0 : error.message}`);
                            throw error;
                        }
                        events = this.hostedAgent.getEventStream().getEvents();
                        logger.success("Execution completed successfully");
                    }
                    const executedLoops = this.hostedAgent.getCurrentLoopIteration();
                    logger.info(`Executed ${executedLoops} agent loops out of ${loopCount} expected loops: ${JSON.stringify(this.options)}`);
                    if (executedLoops !== loopCount) throw new Error(`Loop count mismatch: Agent executed ${executedLoops} loops, but fixture has ${loopCount} loop directories`);
                    if (this.snapshotManager) await this.snapshotManager.cleanupAllActualFiles(this.snapshotName);
                    return {
                        response,
                        events,
                        meta: {
                            snapshotName,
                            executionTime: Date.now() - startTime,
                            loopCount: executedLoops
                        }
                    };
                } catch (error) {
                    logger.error(`Test execution failed: ${error}`);
                    throw error;
                } finally{
                    this.replayHook.clearError();
                }
            }
            countLoops(casePath) {
                if (!external_fs_default().existsSync(casePath)) return 0;
                const loopDirs = external_fs_default().readdirSync(casePath).filter((dir)=>dir.startsWith('loop-') && external_fs_default().statSync(external_path_default().join(casePath, dir)).isDirectory()).sort((a, b)=>{
                    const numA = parseInt(a.split('-')[1], 10);
                    const numB = parseInt(b.split('-')[1], 10);
                    return numA - numB;
                });
                return loopDirs.length;
            }
            getAgent() {
                return this.hostedAgent;
            }
            getCurrentLoop() {
                return this.hostedAgent.getCurrentLoopIteration();
            }
            updateAgentNormalizerConfig(config) {
                this.snapshotManager.updateAgentNormalizerConfig(config);
            }
            constructor(agent, options){
                agent_snapshot_define_property(this, "hostedAgent", void 0);
                agent_snapshot_define_property(this, "options", void 0);
                agent_snapshot_define_property(this, "snapshotPath", void 0);
                agent_snapshot_define_property(this, "snapshotName", void 0);
                agent_snapshot_define_property(this, "snapshotManager", void 0);
                agent_snapshot_define_property(this, "replayHook", void 0);
                agent_snapshot_define_property(this, "generateHook", null);
                this.hostedAgent = agent;
                this.options = options;
                this.snapshotPath = options.snapshotPath || external_path_default().join(process.cwd(), 'fixtures');
                this.snapshotName = options.snapshotName ?? external_path_default().basename(options.snapshotPath);
                this.snapshotManager = new SnapshotManager(this.snapshotPath, options.normalizerConfig);
                this.replayHook = new AgentReplaySnapshotHook(agent, {
                    snapshotPath: this.options.snapshotPath || external_path_default().join(process.cwd(), 'fixtures'),
                    snapshotName: this.snapshotName
                });
                if (!external_fs_default().existsSync(this.snapshotPath)) external_fs_default().mkdirSync(this.snapshotPath, {
                    recursive: true
                });
                process.env.TEST = 'true';
                const agentSnapshotProto = Object.getPrototypeOf(this);
                const methodsToPreserve = {};
                Object.getOwnPropertyNames(agentSnapshotProto).forEach((key)=>{
                    const descriptor = Object.getOwnPropertyDescriptor(agentSnapshotProto, key);
                    if ('function' == typeof (null == descriptor ? void 0 : descriptor.value) && 'constructor' !== key) methodsToPreserve[key] = this[key].bind(this);
                });
                Object.setPrototypeOf(this, Object.getPrototypeOf(agent));
                Object.getOwnPropertyNames(agent).forEach((prop)=>{
                    if (!(prop in this)) Object.defineProperty(this, prop, {
                        get: ()=>agent[prop],
                        set: (value)=>{
                            agent[prop] = value;
                        },
                        configurable: true
                    });
                });
                Object.entries(methodsToPreserve).forEach(([key, method])=>{
                    this[key] = method;
                });
            }
        }
        function event_stream_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class EventStreamBridge {
            subscribe(handler) {
                this.subscribers.add(handler);
            }
            unsubscribe(handler) {
                this.subscribers.delete(handler);
            }
            emit(type, data) {
                for (const handler of this.subscribers)handler(type, data);
            }
            connectToAgentEventStream(agentEventStream) {
                const handleEvent = (event)=>{
                    var _event_message, _event_message1;
                    switch(event.type){
                        case 'agent_run_start':
                            this.emit('agent-status', {
                                isProcessing: true,
                                state: 'executing'
                            });
                            break;
                        case 'agent_run_end':
                            this.emit('agent-status', {
                                isProcessing: false,
                                state: event.status || 'idle'
                            });
                            break;
                        case 'user_message':
                            this.emit('agent-status', {
                                isProcessing: true,
                                state: 'processing'
                            });
                            this.emit('query', {
                                text: event.content
                            });
                            break;
                        case 'assistant_message':
                            this.emit('answer', {
                                text: event.content
                            });
                            break;
                        case 'tool_call':
                            this.emit('event', {
                                type: 'tool_call',
                                name: event.name,
                                toolCallId: event.toolCallId,
                                arguments: event.arguments
                            });
                            break;
                        case 'tool_result':
                            this.emit('event', {
                                type: 'tool_result',
                                name: event.name,
                                toolCallId: event.toolCallId,
                                content: event.content,
                                error: event.error
                            });
                            break;
                        case 'system':
                            this.emit(event.level, {
                                message: event.message
                            });
                            break;
                        default:
                            this.emit('event', event);
                    }
                    if ('system' === event.type && (null == (_event_message = event.message) ? void 0 : _event_message.includes('aborted'))) {
                        this.emit('aborted', {
                            message: event.message
                        });
                        this.emit('agent-status', {
                            isProcessing: false,
                            state: 'idle'
                        });
                    }
                    if ('system' === event.type && (null == (_event_message1 = event.message) ? void 0 : _event_message1.includes('status'))) this.emit('status', {
                        message: event.message
                    });
                };
                return agentEventStream.subscribe(handleEvent);
            }
            constructor(){
                event_stream_define_property(this, "subscribers", new Set());
            }
        }
        (function(AgioEvent) {
            function createEvent(type, sessionId, payload) {
                return {
                    type,
                    timestamp: Date.now(),
                    sessionId,
                    ...payload
                };
            }
            AgioEvent.createEvent = createEvent;
            function createEvents(sessionId, events) {
                return events.map(({ type, payload })=>createEvent(type, sessionId, payload));
            }
            AgioEvent.createEvents = createEvents;
            function isEventType(event, type) {
                return event.type === type;
            }
            AgioEvent.isEventType = isEventType;
        })(src_AgioEvent || (src_AgioEvent = {}));
        var src_AgioEvent;
        function AgioBatchProcessor_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class AgioBatchProcessor {
            addEvent(event) {
                this.eventBuffer.push(event);
                if (this.eventBuffer.length >= this.maxBatchSize) this.flush();
                else this.scheduleFlush();
            }
            async flush() {
                this.clearScheduledFlush();
                if (0 === this.eventBuffer.length) return;
                const eventsToSend = [
                    ...this.eventBuffer
                ];
                this.eventBuffer = [];
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(()=>controller.abort(), this.requestTimeout);
                    const response = await fetch(this.providerUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            events: eventsToSend
                        }),
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                } catch (error) {}
            }
            scheduleFlush() {
                if (!this.timer) this.timer = setTimeout(()=>{
                    this.flush();
                }, this.flushInterval);
            }
            clearScheduledFlush() {
                if (this.timer) {
                    clearTimeout(this.timer);
                    this.timer = null;
                }
            }
            constructor(options){
                AgioBatchProcessor_define_property(this, "providerUrl", void 0);
                AgioBatchProcessor_define_property(this, "maxBatchSize", void 0);
                AgioBatchProcessor_define_property(this, "flushInterval", void 0);
                AgioBatchProcessor_define_property(this, "requestTimeout", void 0);
                AgioBatchProcessor_define_property(this, "eventBuffer", []);
                AgioBatchProcessor_define_property(this, "timer", null);
                this.providerUrl = options.providerUrl;
                this.maxBatchSize = options.maxBatchSize ?? 20;
                this.flushInterval = options.flushInterval ?? 5000;
                this.requestTimeout = options.requestTimeout ?? 5000;
            }
        }
        function AgioProvider_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class AgioProvider {
            calculateCounts() {
                var _this_appConfig_model;
                const toolsCount = this.agent.getTools().length;
                const modelProviders = null == (_this_appConfig_model = this.appConfig.model) ? void 0 : _this_appConfig_model.providers;
                const modelProvidersCount = Array.isArray(modelProviders) ? modelProviders.length : 1;
                const mcpServersConfig = this.appConfig.mcpServers || {};
                const mcpServersCount = Object.keys(mcpServersConfig).length;
                return {
                    mcpServersCount,
                    toolsCount,
                    modelProvidersCount
                };
            }
            async sendAgentInitialized() {
                var _this_appConfig_browser, _this_appConfig_thinking, _this_appConfig_snapshot;
                if (this.hasInitialized) return;
                this.hasInitialized = true;
                const resolvedModel = this.agent.getCurrentResolvedModel();
                const counts = this.calculateCounts();
                this.modelName = null == resolvedModel ? void 0 : resolvedModel.id;
                const event = src_AgioEvent.createEvent('agent_initialized', this.sessionId, {
                    config: {
                        modelProvider: null == resolvedModel ? void 0 : resolvedModel.provider,
                        modelName: null == resolvedModel ? void 0 : resolvedModel.id,
                        toolCallEngine: this.appConfig.toolCallEngine,
                        maxTokens: this.appConfig.maxTokens,
                        temperature: this.appConfig.temperature,
                        maxIterations: this.appConfig.maxIterations,
                        browserControl: null == (_this_appConfig_browser = this.appConfig.browser) ? void 0 : _this_appConfig_browser.control,
                        plannerEnabled: 'object' == typeof this.appConfig.planner ? this.appConfig.planner.enable : Boolean(this.appConfig.planner),
                        thinkingEnabled: (null == (_this_appConfig_thinking = this.appConfig.thinking) ? void 0 : _this_appConfig_thinking.type) === 'enabled',
                        snapshotEnabled: null == (_this_appConfig_snapshot = this.appConfig.snapshot) ? void 0 : _this_appConfig_snapshot.enable,
                        researchEnabled: 'object' == typeof this.appConfig.planner ? this.appConfig.planner.enable : Boolean(this.appConfig.planner),
                        customMcpServers: Boolean(this.appConfig.mcpServers && Object.keys(this.appConfig.mcpServers).length > 0)
                    },
                    count: counts
                });
                this.agentInitializedEvent = event;
            }
            async processAgentEvent(event) {
                try {
                    switch(event.type){
                        case 'agent_run_start':
                            await this.handleRunStart(event);
                            break;
                        case 'agent_run_end':
                            await this.handleRunEnd(event);
                            break;
                        case 'assistant_streaming_message':
                            await this.handleFirstToken(event);
                            break;
                        case 'tool_call':
                            await this.handleToolCall(event);
                            break;
                        case 'tool_result':
                            await this.handleToolResult(event);
                            break;
                        case 'user_message':
                            await this.handleLoopStart();
                            break;
                        case 'assistant_message':
                            await this.handleLoopEnd(event);
                            break;
                        default:
                            break;
                    }
                } catch (error) {
                    console.error('Failed to process AGIO event:', error);
                }
            }
            isInputMultimodal(input) {
                if (!Array.isArray(input)) return false;
                return input.some((part)=>{
                    if ('object' == typeof part && null !== part) {
                        if ('image_url' === part.type || 'image' === part.type) return true;
                        if (part.type && 'text' !== part.type) return true;
                    }
                    return false;
                });
            }
            async handleRunStart(event) {
                var _event_runOptions, _event_runOptions1, _event_runOptions2;
                if (this.agentInitializedEvent) {
                    await this.queueEvent(this.agentInitializedEvent);
                    this.agentInitializedEvent = null;
                }
                this.runId = event.sessionId;
                this.runStartTime = Date.now();
                this.firstTokenTime = void 0;
                this.currentIteration = 0;
                this.loopStartTimes.clear();
                const isMultimodalInput = this.isInputMultimodal((null == (_event_runOptions = event.runOptions) ? void 0 : _event_runOptions.input) || '');
                const agioEvent = src_AgioEvent.createEvent('agent_run_start', this.sessionId, {
                    runId: this.runId,
                    input: (null == (_event_runOptions1 = event.runOptions) ? void 0 : _event_runOptions1.input) || '',
                    isMultimodalInput,
                    streaming: Boolean(null == (_event_runOptions2 = event.runOptions) ? void 0 : _event_runOptions2.stream)
                });
                await this.queueEvent(agioEvent);
            }
            async handleRunEnd(event) {
                if (!this.runStartTime || !this.runId) return;
                const executionTimeMs = Date.now() - this.runStartTime;
                const successful = event.status !== core_.AgentStatus.ERROR;
                const isError = event.status === core_.AgentStatus.ERROR;
                const agioEvent = src_AgioEvent.createEvent('agent_run_end', this.sessionId, {
                    runId: this.runId,
                    executionTimeMs,
                    loopCount: event.iterations || this.currentIteration,
                    successful,
                    error: isError ? 'AgentRunError' : ''
                });
                await this.queueEvent(agioEvent);
                await this.batchProcessor.flush();
                this.runId = void 0;
                this.runStartTime = void 0;
            }
            async handleFirstToken(event) {
                if (!this.firstTokenTime && this.runStartTime && event.content) {
                    this.firstTokenTime = Date.now();
                    const ttftMs = this.firstTokenTime - this.runStartTime;
                    const agioEvent = src_AgioEvent.createEvent('agent_ttft', this.sessionId, {
                        runId: this.runId,
                        modelName: this.modelName,
                        ttftMs
                    });
                    await this.queueEvent(agioEvent);
                }
            }
            async handleToolCall(event) {
                const sanitizedArgs = this.sanitizeArguments(event.arguments);
                const agioEvent = src_AgioEvent.createEvent('tool_call', this.sessionId, {
                    runId: this.runId,
                    toolName: event.name,
                    toolCallId: event.toolCallId,
                    arguments: sanitizedArgs,
                    argumentsSize: JSON.stringify(event.arguments).length,
                    mcpServer: this.extractMCPServer(event.name)
                });
                await this.queueEvent(agioEvent);
            }
            async handleToolResult(event) {
                const agioEvent = src_AgioEvent.createEvent('tool_result', this.sessionId, {
                    runId: this.runId,
                    toolName: event.name,
                    toolCallId: event.toolCallId,
                    executionTimeMs: event.elapsedMs || 0,
                    successful: !event.error,
                    resultSize: this.calculateResultSize(event.content),
                    contentType: this.determineContentType(event.content)
                });
                await this.queueEvent(agioEvent);
            }
            async handleLoopStart() {
                this.currentIteration++;
                this.loopStartTimes.set(this.currentIteration, Date.now());
                const agioEvent = src_AgioEvent.createEvent('agent_loop_start', this.sessionId, {
                    runId: this.runId,
                    iteration: this.currentIteration
                });
                await this.queueEvent(agioEvent);
            }
            async handleLoopEnd(event) {
                const startTime = this.loopStartTimes.get(this.currentIteration);
                if (!startTime) return;
                const durationMs = Date.now() - startTime;
                const agioEvent = src_AgioEvent.createEvent('agent_loop_end', this.sessionId, {
                    runId: this.runId,
                    iteration: this.currentIteration,
                    durationMs
                });
                await this.queueEvent(agioEvent);
                this.loopStartTimes.delete(this.currentIteration);
            }
            queueEvent(event) {
                this.batchProcessor.addEvent(event);
            }
            sanitizeArguments(args) {
                if (!args || 'object' != typeof args) return {};
                const sanitized = {};
                const sensitiveKeys = [
                    'password',
                    'token',
                    'key',
                    'secret',
                    'apikey',
                    'auth'
                ];
                for (const [key, value] of Object.entries(args)){
                    const keyLower = key.toLowerCase();
                    if (sensitiveKeys.some((sensitive)=>keyLower.includes(sensitive))) sanitized[key] = '[REDACTED]';
                    else if ('string' == typeof value && value.length > 1000) sanitized[key] = value.substring(0, 100) + '...[TRUNCATED]';
                    else sanitized[key] = value;
                }
                return sanitized;
            }
            extractMCPServer(toolName) {
                if (toolName.startsWith('browser_')) return 'browser';
                if (toolName.startsWith('filesystem_')) return 'filesystem';
                if ('web_search' === toolName) return 'search';
                if (toolName.startsWith('commands_')) return 'commands';
            }
            calculateResultSize(content) {
                if (!content) return 0;
                try {
                    return JSON.stringify(content).length;
                } catch  {
                    return String(content).length;
                }
            }
            determineContentType(content) {
                if (!content) return 'empty';
                if ('string' == typeof content) return 'text';
                if (Array.isArray(content)) return 'array';
                if ('object' == typeof content) return 'object';
                return 'unknown';
            }
            async cleanup() {
                await this.batchProcessor.flush();
            }
            constructor(providerUrl, appConfig, sessionId, agent){
                AgioProvider_define_property(this, "providerUrl", void 0);
                AgioProvider_define_property(this, "appConfig", void 0);
                AgioProvider_define_property(this, "sessionId", void 0);
                AgioProvider_define_property(this, "agent", void 0);
                AgioProvider_define_property(this, "runId", void 0);
                AgioProvider_define_property(this, "runStartTime", void 0);
                AgioProvider_define_property(this, "firstTokenTime", void 0);
                AgioProvider_define_property(this, "loopStartTimes", void 0);
                AgioProvider_define_property(this, "currentIteration", void 0);
                AgioProvider_define_property(this, "hasInitialized", void 0);
                AgioProvider_define_property(this, "modelName", void 0);
                AgioProvider_define_property(this, "batchProcessor", void 0);
                AgioProvider_define_property(this, "agentInitializedEvent", void 0);
                this.providerUrl = providerUrl;
                this.appConfig = appConfig;
                this.sessionId = sessionId;
                this.agent = agent;
                this.loopStartTimes = new Map();
                this.currentIteration = 0;
                this.hasInitialized = false;
                this.agentInitializedEvent = null;
                this.sessionId = sessionId;
                this.agent = agent;
                this.appConfig = agent.getOptions();
                this.batchProcessor = new AgioBatchProcessor({
                    providerUrl: this.providerUrl,
                    maxBatchSize: 3
                });
            }
        }
        var error_handler = __webpack_require__("./src/utils/error-handler.ts");
        function AgentSession_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class AgentSession {
            getProcessingStatus() {
                return this.agent.status() === core_.AgentStatus.EXECUTING;
            }
            async initialize() {
                await this.agent.initialize();
                if (this.agioProvider) try {
                    await this.agioProvider.sendAgentInitialized();
                } catch (error) {
                    console.error('Failed to send AGIO initialization event:', error);
                }
                const agentEventStream = this.agent.getEventStream();
                const handleEvent = async (event)=>{
                    if (this.server.storageProvider) try {
                        await this.server.storageProvider.saveEvent(this.id, event);
                    } catch (error) {
                        console.error(`Failed to save event to storage: ${error}`);
                    }
                    if (this.agioProvider) try {
                        await this.agioProvider.processAgentEvent(event);
                    } catch (error) {
                        console.error('Failed to process AGIO event:', error);
                    }
                };
                const storageUnsubscribe = agentEventStream.subscribe(handleEvent);
                this.unsubscribe = this.eventBridge.connectToAgentEventStream(agentEventStream);
                this.eventBridge.emit('ready', {
                    sessionId: this.id
                });
                return {
                    storageUnsubscribe
                };
            }
            async runQuery(query) {
                try {
                    const result = await this.agent.run({
                        input: query
                    });
                    return {
                        success: true,
                        result
                    };
                } catch (error) {
                    this.eventBridge.emit('error', {
                        message: error instanceof Error ? error.message : String(error)
                    });
                    const handledError = (0, error_handler.rB)(error, `Session ${this.id}`);
                    return {
                        success: false,
                        error: {
                            code: handledError.code,
                            message: handledError.message,
                            details: handledError.details
                        }
                    };
                }
            }
            async runQueryStreaming(query) {
                try {
                    return await this.agent.run({
                        input: query,
                        stream: true
                    });
                } catch (error) {
                    this.eventBridge.emit('error', {
                        message: error instanceof Error ? error.message : String(error)
                    });
                    const handledError = (0, error_handler.rB)(error, `Session ${this.id} (streaming)`);
                    return this.createErrorEventStream(handledError);
                }
            }
            async *createErrorEventStream(error) {
                yield this.agent.getEventStream().createEvent('system', {
                    level: 'error',
                    message: error.message,
                    details: {
                        errorCode: error.code,
                        details: error.details
                    }
                });
            }
            async abortQuery() {
                try {
                    const aborted = this.agent.abort();
                    if (aborted) this.eventBridge.emit('aborted', {
                        sessionId: this.id
                    });
                    return aborted;
                } catch (error) {
                    this.eventBridge.emit('error', {
                        message: error instanceof Error ? error.message : String(error)
                    });
                    return false;
                }
            }
            async cleanup() {
                if (this.unsubscribe) {
                    this.unsubscribe();
                    this.unsubscribe = null;
                }
                await this.agent.cleanup();
                if (this.agioProvider) {
                    var _this_agioProvider_cleanup, _this_agioProvider;
                    await (null == (_this_agioProvider_cleanup = (_this_agioProvider = this.agioProvider).cleanup) ? void 0 : _this_agioProvider_cleanup.call(_this_agioProvider));
                }
                this.eventBridge.emit('closed', {
                    sessionId: this.id
                });
            }
            constructor(server, sessionId, agioProviderImpl, workingDirectory){
                var _appConfig_snapshot, _appConfig_agio;
                AgentSession_define_property(this, "server", void 0);
                AgentSession_define_property(this, "id", void 0);
                AgentSession_define_property(this, "agent", void 0);
                AgentSession_define_property(this, "eventBridge", void 0);
                AgentSession_define_property(this, "unsubscribe", void 0);
                AgentSession_define_property(this, "agioProvider", void 0);
                this.server = server;
                this.unsubscribe = null;
                this.id = sessionId;
                this.eventBridge = new EventStreamBridge();
                const { appConfig } = server;
                const { workspace, server: appServerConfig } = appConfig;
                workspace.workingDirectory = workingDirectory;
                const agent = new core_.AgentTARS(server.appConfig);
                if (null == (_appConfig_snapshot = appConfig.snapshot) ? void 0 : _appConfig_snapshot.enable) {
                    const snapshotStoragesDirectory = appConfig.snapshot.storageDirectory ?? workspace.workingDirectory;
                    const snapshotPath = external_path_default().join(snapshotStoragesDirectory, sessionId);
                    this.agent = new agent_snapshot_AgentSnapshot(agent, {
                        snapshotPath,
                        snapshotName: sessionId
                    });
                    agent.logger.debug(`AgentSnapshot initialized with path: ${snapshotPath}`);
                } else this.agent = agent;
                if (null == (_appConfig_agio = appConfig.agio) ? void 0 : _appConfig_agio.provider) {
                    var _appConfig_agio1;
                    const impl = agioProviderImpl ?? AgioProvider;
                    this.agioProvider = new impl(null == (_appConfig_agio1 = appConfig.agio) ? void 0 : _appConfig_agio1.provider, appConfig, sessionId, agent);
                    agent.logger.debug(`AGIO collector initialized with provider: ${appConfig.agio.provider}`);
                }
                agent.logger.info('Agent Config', JSON.stringify(agent.getOptions(), null, 2));
            }
        }
        var SocketHandlers = __webpack_require__("./src/core/SocketHandlers.ts");
    },
    "./src/server.ts": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            t: ()=>AgentTARSServer,
            z: ()=>express_default()
        });
        var express = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/index.js");
        var express_default = /*#__PURE__*/ __webpack_require__.n(express);
        var external_http_ = __webpack_require__("http");
        var external_http_default = /*#__PURE__*/ __webpack_require__.n(external_http_);
        var lib = __webpack_require__("../node_modules/.pnpm/cors@2.8.5/node_modules/cors/lib/index.js");
        var lib_default = /*#__PURE__*/ __webpack_require__.n(lib);
        const external_node_crypto_namespaceObject = require("node:crypto");
        const urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
        const POOL_SIZE_MULTIPLIER = 128;
        let pool, poolOffset;
        function fillPool(bytes) {
            if (!pool || pool.length < bytes) {
                pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
                external_node_crypto_namespaceObject.webcrypto.getRandomValues(pool);
                poolOffset = 0;
            } else if (poolOffset + bytes > pool.length) {
                external_node_crypto_namespaceObject.webcrypto.getRandomValues(pool);
                poolOffset = 0;
            }
            poolOffset += bytes;
        }
        function nanoid(size = 21) {
            fillPool(size |= 0);
            let id = '';
            for(let i = poolOffset - size; i < poolOffset; i++)id += urlAlphabet[63 & pool[i]];
            return id;
        }
        var workspace = __webpack_require__("./src/utils/workspace.ts");
        var core = __webpack_require__("./src/core/index.ts");
        var services = __webpack_require__("./src/services/index.ts");
        async function getAllSessions(req, res) {
            try {
                const server = req.app.locals.server;
                if (!server.storageProvider) {
                    const activeSessions = Object.keys(server.sessions).map((id)=>({
                            id,
                            createdAt: Date.now(),
                            updatedAt: Date.now()
                        }));
                    return res.status(200).json({
                        sessions: activeSessions
                    });
                }
                const sessions = await server.storageProvider.getAllSessions();
                res.status(200).json({
                    sessions
                });
            } catch (error) {
                console.error('Failed to get sessions:', error);
                res.status(500).json({
                    error: 'Failed to get sessions'
                });
            }
        }
        async function createSession(req, res) {
            try {
                var _server_appConfig_workspace;
                const server = req.app.locals.server;
                const sessionId = nanoid();
                await cleanupBrowserPagesForExistingSessions(server);
                const isolateSessions = (null == (_server_appConfig_workspace = server.appConfig.workspace) ? void 0 : _server_appConfig_workspace.isolateSessions) ?? false;
                const workingDirectory = (0, workspace.s)(sessionId, server.workspacePath, isolateSessions);
                const session = new core.ZT(server, sessionId, server.getCustomAgioProvider(), workingDirectory);
                server.sessions[sessionId] = session;
                const { storageUnsubscribe } = await session.initialize();
                if (storageUnsubscribe) server.storageUnsubscribes[sessionId] = storageUnsubscribe;
                if (server.storageProvider) {
                    const metadata = {
                        id: sessionId,
                        createdAt: Date.now(),
                        updatedAt: Date.now(),
                        workingDirectory
                    };
                    await server.storageProvider.createSession(metadata);
                }
                res.status(201).json({
                    sessionId
                });
            } catch (error) {
                console.error('Failed to create session:', error);
                res.status(500).json({
                    error: 'Failed to create session'
                });
            }
        }
        async function cleanupBrowserPagesForExistingSessions(server) {
            try {
                const activeSessions = Object.values(server.sessions);
                for (const session of activeSessions)if (session && session.agent) {
                    var _session_agent_getBrowserManager, _session_agent;
                    const browserManager = null == (_session_agent_getBrowserManager = (_session_agent = session.agent).getBrowserManager) ? void 0 : _session_agent_getBrowserManager.call(_session_agent);
                    if (browserManager && browserManager.isLaunchingComplete()) {
                        console.log("Closing browser pages for session before creating new session");
                        await browserManager.closeAllPages();
                    }
                }
            } catch (error) {
                console.warn(`Failed to cleanup browser pages for existing sessions: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
        async function getSessionDetails(req, res) {
            const sessionId = req.query.sessionId;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            try {
                const server = req.app.locals.server;
                if (server.storageProvider) {
                    const metadata = await server.storageProvider.getSessionMetadata(sessionId);
                    if (metadata) return res.status(200).json({
                        session: metadata
                    });
                }
                if (server.sessions[sessionId]) return res.status(200).json({
                    session: {
                        id: sessionId,
                        createdAt: Date.now(),
                        updatedAt: Date.now(),
                        workingDirectory: server.sessions[sessionId].agent.getWorkingDirectory()
                    }
                });
                return res.status(404).json({
                    error: 'Session not found'
                });
            } catch (error) {
                console.error(`Error getting session details for ${sessionId}:`, error);
                res.status(500).json({
                    error: 'Failed to get session details'
                });
            }
        }
        async function getSessionEvents(req, res) {
            const sessionId = req.query.sessionId;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            try {
                const server = req.app.locals.server;
                if (!server.storageProvider) return res.status(404).json({
                    error: 'Storage not configured, no events available'
                });
                const events = await server.storageProvider.getSessionEvents(sessionId);
                res.status(200).json({
                    events
                });
            } catch (error) {
                console.error(`Error getting events for session ${sessionId}:`, error);
                res.status(500).json({
                    error: 'Failed to get session events'
                });
            }
        }
        async function getSessionStatus(req, res) {
            var _server_appConfig_workspace;
            const sessionId = req.query.sessionId;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            const server = req.app.locals.server;
            const isolateSessions = (null == (_server_appConfig_workspace = server.appConfig.workspace) ? void 0 : _server_appConfig_workspace.isolateSessions) ?? false;
            const workingDirectory = (0, workspace.s)(sessionId, server.workspacePath, isolateSessions);
            try {
                const server = req.app.locals.server;
                let session = server.sessions[sessionId];
                if (!session && server.storageProvider) {
                    const metadata = await server.storageProvider.getSessionMetadata(sessionId);
                    if (metadata) try {
                        session = new core.ZT(server, sessionId, server.getCustomAgioProvider(), workingDirectory);
                        server.sessions[sessionId] = session;
                        const { storageUnsubscribe } = await session.initialize();
                        if (storageUnsubscribe) server.storageUnsubscribes[sessionId] = storageUnsubscribe;
                    } catch (error) {
                        console.error(`Failed to restore session ${sessionId}:`, error);
                        return res.status(200).json({
                            sessionId,
                            status: {
                                isProcessing: false,
                                state: 'stored'
                            }
                        });
                    }
                }
                if (!session) return res.status(404).json({
                    error: 'Session not found'
                });
                const isProcessing = session.getProcessingStatus();
                res.status(200).json({
                    sessionId,
                    status: {
                        isProcessing,
                        state: session.agent.status()
                    }
                });
            } catch (error) {
                console.error(`Error getting session status (${sessionId}):`, error);
                res.status(500).json({
                    error: 'Failed to get session status'
                });
            }
        }
        async function updateSession(req, res) {
            const { sessionId, name, tags } = req.body;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            try {
                const server = req.app.locals.server;
                if (!server.storageProvider) return res.status(404).json({
                    error: 'Storage not configured, cannot update session'
                });
                const metadata = await server.storageProvider.getSessionMetadata(sessionId);
                if (!metadata) return res.status(404).json({
                    error: 'Session not found'
                });
                const updatedMetadata = await server.storageProvider.updateSessionMetadata(sessionId, {
                    name,
                    tags,
                    updatedAt: Date.now()
                });
                res.status(200).json({
                    session: updatedMetadata
                });
            } catch (error) {
                console.error(`Error updating session ${sessionId}:`, error);
                res.status(500).json({
                    error: 'Failed to update session'
                });
            }
        }
        async function deleteSession(req, res) {
            const { sessionId } = req.body;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            try {
                const server = req.app.locals.server;
                if (server.sessions[sessionId]) {
                    try {
                        var _server_sessions_sessionId_agent_getBrowserManager, _server_sessions_sessionId_agent;
                        const browserManager = null == (_server_sessions_sessionId_agent_getBrowserManager = (_server_sessions_sessionId_agent = server.sessions[sessionId].agent).getBrowserManager) ? void 0 : _server_sessions_sessionId_agent_getBrowserManager.call(_server_sessions_sessionId_agent);
                        if (browserManager && browserManager.isLaunchingComplete()) {
                            console.log(`Closing browser pages for session ${sessionId} before deletion`);
                            await browserManager.closeAllPages();
                        }
                    } catch (error) {
                        console.warn(`Failed to cleanup browser pages for session ${sessionId}: ${error instanceof Error ? error.message : String(error)}`);
                    }
                    await server.sessions[sessionId].cleanup();
                    delete server.sessions[sessionId];
                    if (server.storageUnsubscribes[sessionId]) {
                        server.storageUnsubscribes[sessionId]();
                        delete server.storageUnsubscribes[sessionId];
                    }
                }
                if (server.storageProvider) {
                    const deleted = await server.storageProvider.deleteSession(sessionId);
                    if (!deleted) return res.status(404).json({
                        error: 'Session not found in storage'
                    });
                }
                res.status(200).json({
                    success: true
                });
            } catch (error) {
                console.error(`Error deleting session ${sessionId}:`, error);
                res.status(500).json({
                    error: 'Failed to delete session'
                });
            }
        }
        async function generateSummary(req, res) {
            const { sessionId, messages, model, provider } = req.body;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            if (!Array.isArray(messages) || 0 === messages.length) return res.status(400).json({
                error: 'Messages are required'
            });
            try {
                const server = req.app.locals.server;
                const session = server.sessions[sessionId];
                if (!session) return res.status(404).json({
                    error: 'Session not found'
                });
                const summaryResponse = await session.agent.generateSummary({
                    messages,
                    model,
                    provider
                });
                res.status(200).json(summaryResponse);
            } catch (error) {
                console.error(`Error generating summary for session ${sessionId}:`, error);
                res.status(500).json({
                    error: 'Failed to generate summary',
                    message: error instanceof Error ? error.message : String(error)
                });
            }
        }
        async function getBrowserControlInfo(req, res) {
            const sessionId = req.query.sessionId;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            try {
                const server = req.app.locals.server;
                const session = server.sessions[sessionId];
                if (!session) return res.status(404).json({
                    error: 'Session not found'
                });
                const browserControlInfo = await session.agent.getBrowserControlInfo();
                res.status(200).json(browserControlInfo);
            } catch (error) {
                console.error(`Error getting browser control info (${sessionId}):`, error);
                res.status(500).json({
                    error: 'Failed to get browser control info'
                });
            }
        }
        async function shareSession(req, res) {
            const { sessionId, upload } = req.body;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            try {
                var _server_sessions_sessionId;
                const server = req.app.locals.server;
                const shareService = new services.t(server.appConfig, server.storageProvider);
                const agent = null == (_server_sessions_sessionId = server.sessions[sessionId]) ? void 0 : _server_sessions_sessionId.agent;
                const result = await shareService.shareSession(sessionId, upload, agent);
                if (result.success) return res.status(200).json(result);
                return res.status(500).json({
                    error: result.error || 'Failed to share session'
                });
            } catch (error) {
                console.error(`Error sharing session ${sessionId}:`, error);
                return res.status(500).json({
                    error: 'Failed to share session'
                });
            }
        }
        async function getLatestSessionEvents(req, res) {
            try {
                const server = req.app.locals.server;
                if (!server.storageProvider) return res.status(404).json({
                    error: 'Storage not configured, cannot get latest session events'
                });
                const sessions = await server.storageProvider.getAllSessions();
                if (0 === sessions.length) return res.status(404).json({
                    error: 'No sessions found'
                });
                const latestSession = sessions.reduce((latest, current)=>current.updatedAt > latest.updatedAt ? current : latest);
                const events = await server.storageProvider.getSessionEvents(latestSession.id);
                res.status(200).json({
                    sessionId: latestSession.id,
                    sessionMetadata: latestSession,
                    events
                });
            } catch (error) {
                console.error('Error getting latest session events:', error);
                res.status(500).json({
                    error: 'Failed to get latest session events'
                });
            }
        }
        function registerSessionRoutes(app) {
            app.get('/api/v1/sessions', getAllSessions);
            app.post('/api/v1/sessions/create', createSession);
            app.get('/api/v1/sessions/details', getSessionDetails);
            app.get('/api/v1/sessions/events', getSessionEvents);
            app.get('/api/v1/sessions/events/latest', getLatestSessionEvents);
            app.get('/api/v1/sessions/status', getSessionStatus);
            app.post('/api/v1/sessions/update', updateSession);
            app.post('/api/v1/sessions/delete', deleteSession);
            app.post('/api/v1/sessions/generate-summary', generateSummary);
            app.get('/api/v1/sessions/browser-control', getBrowserControlInfo);
            app.post('/api/v1/sessions/share', shareSession);
        }
        var core_ = __webpack_require__("@agent-tars/core");
        var error_handler = __webpack_require__("./src/utils/error-handler.ts");
        const imageCompressor = new core_.ImageCompressor({
            quality: 5,
            format: 'webp'
        });
        async function compressImagesInQuery(query) {
            try {
                if ('string' == typeof query) return query;
                if (Array.isArray(query)) {
                    const compressedQuery = await Promise.all(query.map(async (part)=>{
                        var _part_image_url;
                        if ('image_url' === part.type && (null == (_part_image_url = part.image_url) ? void 0 : _part_image_url.url)) return await compressImageUrl(part);
                        return part;
                    }));
                    return compressedQuery;
                }
                return query;
            } catch (error) {
                console.error('Error compressing images in query:', error);
                return query;
            }
        }
        async function compressImageUrl(imagePart) {
            try {
                const imageUrl = imagePart.image_url.url;
                if (!imageUrl.startsWith('data:image/')) return imagePart;
                const base64Data = imageUrl.replace(/^data:image\/\w+;base64,/, '');
                const originalBuffer = Buffer.from(base64Data, 'base64');
                const originalSize = originalBuffer.length;
                const compressedBuffer = await imageCompressor.compressToBuffer(originalBuffer);
                const compressedSize = compressedBuffer.length;
                const compressedBase64 = `data:image/webp;base64,${compressedBuffer.toString('base64')}`;
                const compressionRatio = originalSize / compressedSize;
                const compressionPercentage = ((1 - compressedSize / originalSize) * 100).toFixed(2);
                console.log('Image compression stats:', {
                    original: (0, core_.formatBytes)(originalSize),
                    compressed: (0, core_.formatBytes)(compressedSize),
                    ratio: `${compressionRatio.toFixed(2)}x (${compressionPercentage}% smaller)`,
                    format: 'webp',
                    quality: 80
                });
                return {
                    ...imagePart,
                    image_url: {
                        url: compressedBase64
                    }
                };
            } catch (error) {
                console.error('Error compressing individual image:', error);
                return imagePart;
            }
        }
        async function executeQuery(req, res) {
            const { sessionId, query } = req.body;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            if (!query) return res.status(400).json({
                error: 'Query is required'
            });
            const server = req.app.locals.server;
            if (!server.sessions[sessionId]) return res.status(404).json({
                error: 'Session not found'
            });
            try {
                const compressedQuery = await compressImagesInQuery(query);
                const response = await server.sessions[sessionId].runQuery(compressedQuery);
                if (response.success) res.status(200).json({
                    result: response.result
                });
                else res.status(500).json(response);
            } catch (error) {
                console.error(`Unexpected error processing query in session ${sessionId}:`, error);
                res.status(500).json((0, error_handler.jl)(error));
            }
        }
        async function executeStreamingQuery(req, res) {
            const { sessionId, query } = req.body;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            if (!query) return res.status(400).json({
                error: 'Query is required'
            });
            const server = req.app.locals.server;
            if (!server.sessions[sessionId]) return res.status(404).json({
                error: 'Session not found'
            });
            try {
                res.setHeader('Content-Type', 'text/event-stream');
                res.setHeader('Cache-Control', 'no-cache');
                res.setHeader('Connection', 'keep-alive');
                const compressedQuery = await compressImagesInQuery(query);
                const eventStream = await server.sessions[sessionId].runQueryStreaming(compressedQuery);
                for await (const event of eventStream){
                    const isErrorEvent = 'system' === event.type && 'error' === event.level;
                    if (res.closed) break;
                    res.write(`data: ${JSON.stringify(event)}\n\n`);
                    if (isErrorEvent) break;
                }
                if (!res.closed) res.end();
            } catch (error) {
                console.error(`Critical error in streaming query for session ${sessionId}:`, error);
                if (res.headersSent) {
                    const errorObj = (0, error_handler.jl)(error);
                    res.write(`data: ${JSON.stringify({
                        type: 'system',
                        level: 'error',
                        message: errorObj.error.message,
                        timestamp: Date.now()
                    })}\n\n`);
                    res.end();
                } else res.status(500).json((0, error_handler.jl)(error));
            }
        }
        async function abortQuery(req, res) {
            const { sessionId } = req.body;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            const server = req.app.locals.server;
            if (!server.sessions[sessionId]) return res.status(404).json({
                error: 'Session not found'
            });
            try {
                const aborted = await server.sessions[sessionId].abortQuery();
                res.status(200).json({
                    success: aborted
                });
            } catch (error) {
                console.error(`Error aborting query in session ${sessionId}:`, error);
                res.status(500).json({
                    error: 'Failed to abort query'
                });
            }
        }
        function registerQueryRoutes(app) {
            app.post('/api/v1/sessions/query', executeQuery);
            app.post('/api/v1/sessions/query/stream', executeStreamingQuery);
            app.post('/api/v1/sessions/abort', abortQuery);
        }
        function healthCheck(req, res) {
            res.status(200).json({
                status: 'ok'
            });
        }
        function registerSystemRoutes(app) {
            app.get('/api/v1/health', healthCheck);
        }
        function getShareConfig(req, res) {
            const server = req.app.locals.server;
            const shareService = new services.t(server.appConfig, server.storageProvider);
            res.status(200).json(shareService.getShareConfig());
        }
        function registerShareRoutes(app) {
            app.get('/api/v1/share/config', getShareConfig);
        }
        async function createAndQuery(req, res) {
            try {
                var _server_appConfig_workspace;
                const { query, sessionName, sessionTags } = req.body;
                if (!query) return res.status(400).json({
                    error: 'Query is required'
                });
                const server = req.app.locals.server;
                const sessionId = nanoid();
                const isolateSessions = (null == (_server_appConfig_workspace = server.appConfig.workspace) ? void 0 : _server_appConfig_workspace.isolateSessions) ?? false;
                const workingDirectory = (0, workspace.s)(sessionId, server.workspacePath, isolateSessions);
                const session = new core.ZT(server, sessionId, server.getCustomAgioProvider(), workingDirectory);
                server.sessions[sessionId] = session;
                const { storageUnsubscribe } = await session.initialize();
                if (storageUnsubscribe) server.storageUnsubscribes[sessionId] = storageUnsubscribe;
                if (server.storageProvider) {
                    const metadata = {
                        id: sessionId,
                        createdAt: Date.now(),
                        updatedAt: Date.now(),
                        name: sessionName,
                        workingDirectory,
                        tags: sessionTags
                    };
                    await server.storageProvider.createSession(metadata);
                }
                const response = await session.runQuery(query);
                if (response.success) res.status(200).json({
                    sessionId,
                    result: response.result
                });
                else res.status(500).json({
                    sessionId,
                    ...response
                });
            } catch (error) {
                console.error("Unexpected error in createAndQuery:", error);
                res.status(500).json((0, error_handler.jl)(error));
            }
        }
        async function createAndStreamingQuery(req, res) {
            try {
                var _server_appConfig_workspace;
                const { query, sessionName, sessionTags } = req.body;
                if (!query) return res.status(400).json({
                    error: 'Query is required'
                });
                const server = req.app.locals.server;
                const sessionId = nanoid();
                const isolateSessions = (null == (_server_appConfig_workspace = server.appConfig.workspace) ? void 0 : _server_appConfig_workspace.isolateSessions) ?? false;
                const workingDirectory = (0, workspace.s)(sessionId, server.workspacePath, isolateSessions);
                const session = new core.ZT(server, sessionId, server.getCustomAgioProvider(), workingDirectory);
                server.sessions[sessionId] = session;
                const { storageUnsubscribe } = await session.initialize();
                if (storageUnsubscribe) server.storageUnsubscribes[sessionId] = storageUnsubscribe;
                if (server.storageProvider) {
                    const metadata = {
                        id: sessionId,
                        createdAt: Date.now(),
                        updatedAt: Date.now(),
                        name: sessionName,
                        workingDirectory,
                        tags: sessionTags
                    };
                    await server.storageProvider.createSession(metadata);
                }
                res.setHeader('Content-Type', 'text/event-stream');
                res.setHeader('Cache-Control', 'no-cache');
                res.setHeader('Connection', 'keep-alive');
                res.write(`data: ${JSON.stringify({
                    type: 'session_created',
                    sessionId,
                    timestamp: Date.now()
                })}\n\n`);
                const eventStream = await session.runQueryStreaming(query);
                for await (const event of eventStream){
                    const isErrorEvent = 'system' === event.type && 'error' === event.level;
                    if (res.closed) break;
                    res.write(`data: ${JSON.stringify(event)}\n\n`);
                    if (isErrorEvent) break;
                }
                if (!res.closed) res.end();
            } catch (error) {
                console.error("Critical error in streaming query creation:", error);
                if (res.headersSent) {
                    const errorObj = (0, error_handler.jl)(error);
                    res.write(`data: ${JSON.stringify({
                        type: 'system',
                        level: 'error',
                        message: errorObj.error.message,
                        timestamp: Date.now()
                    })}\n\n`);
                    res.end();
                } else res.status(500).json((0, error_handler.jl)(error));
            }
        }
        function registerOneshotRoutes(app) {
            app.post('/api/v1/oneshot/query', createAndQuery);
            app.post('/api/v1/oneshot/query/stream', createAndStreamingQuery);
        }
        function registerAllRoutes(app) {
            registerSessionRoutes(app);
            registerQueryRoutes(app);
            registerSystemRoutes(app);
            registerShareRoutes(app);
            registerOneshotRoutes(app);
        }
        function getDefaultCorsOptions() {
            return {
                origin: '*',
                methods: [
                    'GET',
                    'POST',
                    'PUT',
                    'DELETE',
                    'OPTIONS'
                ],
                allowedHeaders: [
                    'Content-Type',
                    'Authorization'
                ]
            };
        }
        function setupAPI(app) {
            app.use(lib_default()(getDefaultCorsOptions()));
            app.use(express_default().json({
                limit: '20mb'
            }));
            registerAllRoutes(app);
        }
        var SocketHandlers = __webpack_require__("./src/core/SocketHandlers.ts");
        var storage = __webpack_require__("./src/storage/index.ts");
        function _define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class AgentTARSServer {
            getCustomAgioProvider() {
                return this.customAgioProvider;
            }
            getApp() {
                return this.app;
            }
            getHttpServer() {
                return this.server;
            }
            getSocketIOServer() {
                return this.io;
            }
            isServerRunning() {
                return this.isRunning;
            }
            getStorageInfo() {
                if (!this.storageProvider) return {
                    type: 'none'
                };
                if ('FileStorageProvider' === this.storageProvider.constructor.name) return {
                    type: 'file',
                    path: this.storageProvider.dbPath
                };
                if ('SQLiteStorageProvider' === this.storageProvider.constructor.name) return {
                    type: 'sqlite',
                    path: this.storageProvider.dbPath
                };
                return {
                    type: this.storageProvider.constructor.name.replace('StorageProvider', '').toLowerCase()
                };
            }
            async start() {
                if (this.storageProvider) try {
                    await this.storageProvider.initialize();
                } catch (error) {
                    console.error('Failed to initialize storage provider:', error);
                }
                return new Promise((resolve)=>{
                    this.server.listen(this.port, ()=>{
                        this.isRunning = true;
                        resolve(this.server);
                    });
                });
            }
            async stop() {
                const sessionCleanup = Object.values(this.sessions).map((session)=>session.cleanup());
                await Promise.all(sessionCleanup);
                Object.values(this.storageUnsubscribes).forEach((unsubscribe)=>unsubscribe());
                this.storageUnsubscribes = {};
                this.sessions = {};
                if (this.storageProvider) await this.storageProvider.close();
                if (this.isRunning) return new Promise((resolve, reject)=>{
                    this.server.close((err)=>{
                        if (err) return void reject(err);
                        this.isRunning = false;
                        resolve();
                    });
                });
                return Promise.resolve();
            }
            constructor(appConfig, injectionOptions){
                var _appConfig_workspace;
                _define_property(this, "app", void 0);
                _define_property(this, "server", void 0);
                _define_property(this, "io", void 0);
                _define_property(this, "isRunning", false);
                _define_property(this, "sessions", {});
                _define_property(this, "storageUnsubscribes", {});
                _define_property(this, "customAgioProvider", void 0);
                _define_property(this, "port", void 0);
                _define_property(this, "workspacePath", void 0);
                _define_property(this, "isDebug", void 0);
                _define_property(this, "storageProvider", null);
                _define_property(this, "appConfig", void 0);
                this.appConfig = appConfig;
                this.port = appConfig.server.port ?? 3000;
                this.workspacePath = null == (_appConfig_workspace = appConfig.workspace) ? void 0 : _appConfig_workspace.workingDirectory;
                this.isDebug = appConfig.logLevel === core_.LogLevel.DEBUG;
                this.customAgioProvider = null == injectionOptions ? void 0 : injectionOptions.agioProvider;
                this.app = express_default()();
                this.server = external_http_default().createServer(this.app);
                if (appConfig.server.storage) this.storageProvider = (0, storage.E)(appConfig.server.storage);
                setupAPI(this.app);
                this.io = (0, SocketHandlers.s)(this.server, this);
                this.app.locals.server = this;
            }
        }
    },
    "./src/services/index.ts": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            t: ()=>ShareService
        });
        var external_fs_ = __webpack_require__("fs");
        var external_fs_default = /*#__PURE__*/ __webpack_require__.n(external_fs_);
        var external_path_ = __webpack_require__("path");
        var external_path_default = /*#__PURE__*/ __webpack_require__.n(external_path_);
        var external_os_ = __webpack_require__("os");
        var external_os_default = /*#__PURE__*/ __webpack_require__.n(external_os_);
        class ShareUtils {
            static generateShareHtml(events, metadata, staticPath) {
                if (!staticPath) throw new Error('Cannot found static path.');
                const indexPath = external_path_default().join(staticPath, 'index.html');
                if (!external_fs_default().existsSync(indexPath)) throw new Error('Static web ui not found.');
                try {
                    let htmlContent = external_fs_default().readFileSync(indexPath, 'utf8');
                    const safeEventJson = this.safeJsonStringify(events);
                    const safeMetadataJson = this.safeJsonStringify(metadata);
                    const scriptTag = `<script>
        window.AGENT_TARS_REPLAY_MODE = true;
        window.AGENT_TARS_SESSION_DATA = ${safeMetadataJson};
        window.AGENT_TARS_EVENT_STREAM = ${safeEventJson};
      </script>
      <script>
        // Add a fallback mechanism for when routes don't match in shared HTML files
        window.addEventListener('DOMContentLoaded', function() {
          // Give React time to attempt normal routing
          setTimeout(function() {
            const root = document.getElementById('root');
            if (root && (!root.children || root.children.length === 0)) {
              console.log('[ReplayMode] No content rendered, applying fallback');
              // Try to force the app to re-render if no content is displayed
              window.dispatchEvent(new Event('resize'));
            }
          }, 1000);
        });
      </script>`;
                    htmlContent = htmlContent.replace('</head>', `${scriptTag}\n</head>`);
                    return htmlContent;
                } catch (error) {
                    console.error('Failed to generate share HTML:', error);
                    throw new Error(`Failed to generate share HTML: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            static safeJsonStringify(data) {
                let jsonString = JSON.stringify(data);
                jsonString = jsonString.replace(/</g, '\\u003C');
                jsonString = jsonString.replace(/>/g, '\\u003E');
                jsonString = jsonString.replace(/\//g, '\\/');
                return jsonString;
            }
            static async uploadShareHtml(html, sessionId, shareProviderUrl, options) {
                if (!shareProviderUrl) throw new Error('Share provider not configured');
                try {
                    const tempDir = external_path_default().join(external_os_default().tmpdir(), 'agent-tars-share');
                    if (!external_fs_default().existsSync(tempDir)) external_fs_default().mkdirSync(tempDir, {
                        recursive: true
                    });
                    const fileName = `agent-tars-${sessionId}-${Date.now()}.html`;
                    const filePath = external_path_default().join(tempDir, fileName);
                    external_fs_default().writeFileSync(filePath, html);
                    const formData = new FormData();
                    const file = new File([
                        html
                    ], fileName, {
                        type: 'text/html'
                    });
                    formData.append('file', file);
                    formData.append('sessionId', sessionId);
                    if (options) {
                        if (options.slug) formData.append('slug', options.slug);
                        if (options.query) formData.append('query', options.query);
                        if (options.metadata) {
                            formData.append('name', options.metadata.name || '');
                            if (options.metadata.tags && options.metadata.tags.length > 0) formData.append('tags', JSON.stringify(options.metadata.tags));
                        }
                    }
                    const response = await fetch(shareProviderUrl, {
                        method: 'POST',
                        body: formData
                    });
                    external_fs_default().unlinkSync(filePath);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const responseData = await response.json();
                    if (responseData && responseData.url) return responseData.url;
                    throw new Error('Invalid response from share provider');
                } catch (error) {
                    console.error('Failed to upload share HTML:', error);
                    throw error;
                }
            }
        }
        function _define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class SlugGenerator {
            async generateSlug(userMessage) {
                if (!userMessage.trim()) return this.getDefaultSlug();
                try {
                    const llmSlug = await this.generateWithLLM(userMessage);
                    if (llmSlug) return llmSlug;
                } catch (error) {
                    console.warn('LLM slug generation failed, using manual normalization:', error);
                }
                return this.manualNormalization(userMessage);
            }
            async generateWithLLM(userMessage) {
                var _response_choices__message, _response_choices_;
                const response = await this.agent.callLLM({
                    messages: [
                        {
                            role: 'system',
                            content: `You are a URL slug generator. Generate a semantic, URL-friendly slug from the given text.

Requirements:
- Use 3-5 words separated by hyphens
- Use only lowercase English words
- No special characters except hyphens
- Capture the main topic/intent of the text
- Handle multilingual input (Chinese, English, etc.)
- NEVER include non-ASCII characters like Chinese in the output

Return only a JSON object with a "slug" field.`
                        },
                        {
                            role: 'user',
                            content: `Generate a slug for: "${userMessage}"`
                        }
                    ],
                    response_format: {
                        type: 'json_object'
                    },
                    temperature: 0.3,
                    max_tokens: 100
                });
                const content = null == (_response_choices_ = response.choices[0]) ? void 0 : null == (_response_choices__message = _response_choices_.message) ? void 0 : _response_choices__message.content;
                if (!content) return null;
                try {
                    const parsed = JSON.parse(content);
                    return this.manualNormalization(parsed.slug);
                } catch (error) {
                    console.error('Failed to parse LLM slug response:', error);
                    return null;
                }
            }
            manualNormalization(text) {
                const normalized = text.toLowerCase().replace(/[^\x00-\x7F]+/g, '-').replace(/[^\w\s-]/g, '').replace(/\s+/g, '-').replace(/-+/g, '-').substring(0, 60).replace(/^-+|-+$/g, '');
                if (!normalized || 0 === normalized.length) return this.getDefaultSlug();
                const words = normalized.split('-').filter((word)=>word.length > 0);
                return words.slice(0, 4).join('-') || this.getDefaultSlug();
            }
            getDefaultSlug() {
                return 'untitled-session';
            }
            constructor(agent){
                _define_property(this, "agent", void 0);
                this.agent = agent;
            }
        }
        function ShareService_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class ShareService {
            async shareSession(sessionId, upload = false, agent) {
                try {
                    if (!this.storageProvider) throw new Error('Storage not configured, cannot share session');
                    const metadata = await this.storageProvider.getSessionMetadata(sessionId);
                    if (!metadata) throw new Error('Session not found');
                    const events = await this.storageProvider.getSessionEvents(sessionId);
                    const keyFrameEvents = events.filter((event)=>'assistant_streaming_message' !== event.type && 'assistant_streaming_thinking_message' !== event.type && 'final_answer_streaming' !== event.type);
                    const shareHtml = this.generateShareHtml(keyFrameEvents, metadata);
                    if (upload && this.appConfig.share.provider) {
                        const shareUrl = await this.uploadShareHtml(shareHtml, sessionId, metadata, agent);
                        return {
                            success: true,
                            url: shareUrl,
                            sessionId
                        };
                    }
                    return {
                        success: true,
                        html: shareHtml,
                        sessionId
                    };
                } catch (error) {
                    return {
                        success: false,
                        sessionId,
                        error: error instanceof Error ? error.message : String(error)
                    };
                }
            }
            generateShareHtml(events, metadata) {
                if (!this.appConfig.ui.staticPath) throw new Error('Cannot found static path.');
                return ShareUtils.generateShareHtml(events, metadata, this.appConfig.ui.staticPath);
            }
            async uploadShareHtml(html, sessionId, metadata, agent) {
                if (!this.appConfig.share.provider) throw new Error('Share provider not configured');
                let normalizedSlug = '';
                let originalQuery = '';
                if (this.storageProvider && agent) try {
                    const events = await this.storageProvider.getSessionEvents(sessionId);
                    const firstUserMessage = events.find((e)=>'user_message' === e.type);
                    if (firstUserMessage && firstUserMessage.content) {
                        var _firstUserMessage_content_find;
                        originalQuery = 'string' == typeof firstUserMessage.content ? firstUserMessage.content : (null == (_firstUserMessage_content_find = firstUserMessage.content.find((c)=>'text' === c.type)) ? void 0 : _firstUserMessage_content_find.text) || '';
                        if (originalQuery) {
                            const slugGenerator = new SlugGenerator(agent);
                            normalizedSlug = await slugGenerator.generateSlug(originalQuery);
                            normalizedSlug = normalizedSlug.replace(/[^\x00-\x7F]+/g, '').replace(/[^\w-]/g, '');
                        }
                    }
                } catch (error) {
                    console.warn('Failed to extract query for normalized slug:', error);
                }
                normalizedSlug = normalizedSlug ? `${normalizedSlug}-${sessionId}` : sessionId;
                return ShareUtils.uploadShareHtml(html, sessionId, this.appConfig.share.provider, {
                    metadata,
                    slug: normalizedSlug,
                    query: originalQuery
                });
            }
            getShareConfig() {
                var _this_appConfig_share, _this_appConfig_share1;
                return {
                    hasShareProvider: !!(null == (_this_appConfig_share = this.appConfig.share) ? void 0 : _this_appConfig_share.provider),
                    shareProvider: (null == (_this_appConfig_share1 = this.appConfig.share) ? void 0 : _this_appConfig_share1.provider) || null
                };
            }
            constructor(appConfig, storageProvider){
                ShareService_define_property(this, "appConfig", void 0);
                ShareService_define_property(this, "storageProvider", void 0);
                this.appConfig = appConfig;
                this.storageProvider = storageProvider;
            }
        }
    },
    "./src/storage/index.ts": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            E: ()=>createStorageProvider
        });
        function _define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class MemoryStorageProvider {
            async initialize() {}
            async createSession(metadata) {
                this.sessions.set(metadata.id, {
                    ...metadata,
                    createdAt: metadata.createdAt || Date.now(),
                    updatedAt: metadata.updatedAt || Date.now()
                });
                this.events.set(metadata.id, []);
                return this.sessions.get(metadata.id);
            }
            async updateSessionMetadata(sessionId, metadata) {
                const session = this.sessions.get(sessionId);
                if (!session) throw new Error(`Session not found: ${sessionId}`);
                const updatedSession = {
                    ...session,
                    ...metadata,
                    updatedAt: Date.now()
                };
                this.sessions.set(sessionId, updatedSession);
                return updatedSession;
            }
            async getSessionMetadata(sessionId) {
                return this.sessions.get(sessionId) || null;
            }
            async getAllSessions() {
                return Array.from(this.sessions.values());
            }
            async deleteSession(sessionId) {
                const deleted = this.sessions.delete(sessionId);
                this.events.delete(sessionId);
                return deleted;
            }
            async saveEvent(sessionId, event) {
                if (!this.sessions.has(sessionId)) throw new Error(`Session not found: ${sessionId}`);
                const sessionEvents = this.events.get(sessionId) || [];
                sessionEvents.push(event);
                this.events.set(sessionId, sessionEvents);
                await this.updateSessionMetadata(sessionId, {
                    updatedAt: Date.now()
                });
            }
            async getSessionEvents(sessionId) {
                if (!this.sessions.has(sessionId)) throw new Error(`Session not found: ${sessionId}`);
                return this.events.get(sessionId) || [];
            }
            async close() {}
            constructor(){
                _define_property(this, "sessions", new Map());
                _define_property(this, "events", new Map());
            }
        }
        var external_path_ = __webpack_require__("path");
        var external_path_default = /*#__PURE__*/ __webpack_require__.n(external_path_);
        var external_fs_ = __webpack_require__("fs");
        var external_fs_default = /*#__PURE__*/ __webpack_require__.n(external_fs_);
        function checkArgs(adapter, defaultData) {
            if (void 0 === adapter) throw new Error('lowdb: missing adapter');
            if (void 0 === defaultData) throw new Error('lowdb: missing default data');
        }
        class Low_Low {
            adapter;
            data;
            constructor(adapter, defaultData){
                checkArgs(adapter, defaultData);
                this.adapter = adapter;
                this.data = defaultData;
            }
            async read() {
                const data = await this.adapter.read();
                if (data) this.data = data;
            }
            async write() {
                if (this.data) await this.adapter.write(this.data);
            }
        }
        require("node:fs");
        const promises_namespaceObject = require("node:fs/promises");
        const external_node_path_namespaceObject = require("node:path");
        const external_node_url_namespaceObject = require("node:url");
        function getTempFilename(file) {
            const f = file instanceof URL ? (0, external_node_url_namespaceObject.fileURLToPath)(file) : file.toString();
            return (0, external_node_path_namespaceObject.join)((0, external_node_path_namespaceObject.dirname)(f), `.${(0, external_node_path_namespaceObject.basename)(f)}.tmp`);
        }
        class Writer {
            #filename;
            #tempFilename;
            #locked = false;
            #prev = null;
            #next = null;
            #nextPromise = null;
            #nextData = null;
            #add(data) {
                this.#nextData = data;
                this.#nextPromise ||= new Promise((resolve, reject)=>{
                    this.#next = [
                        resolve,
                        reject
                    ];
                });
                return new Promise((resolve, reject)=>{
                    this.#nextPromise?.then(resolve).catch(reject);
                });
            }
            async #write(data) {
                this.#locked = true;
                try {
                    await (0, promises_namespaceObject.writeFile)(this.#tempFilename, data, 'utf-8');
                    await (0, promises_namespaceObject.rename)(this.#tempFilename, this.#filename);
                    this.#prev?.[0]();
                } catch (err) {
                    if (err instanceof Error) this.#prev?.[1](err);
                    throw err;
                } finally{
                    this.#locked = false;
                    this.#prev = this.#next;
                    this.#next = this.#nextPromise = null;
                    if (null !== this.#nextData) {
                        const nextData = this.#nextData;
                        this.#nextData = null;
                        await this.write(nextData);
                    }
                }
            }
            constructor(filename){
                this.#filename = filename;
                this.#tempFilename = getTempFilename(filename);
            }
            async write(data) {
                return this.#locked ? this.#add(data) : this.#write(data);
            }
        }
        class TextFile {
            #filename;
            #writer;
            constructor(filename){
                this.#filename = filename;
                this.#writer = new Writer(filename);
            }
            async read() {
                let data;
                try {
                    data = await promises_namespaceObject.readFile(this.#filename, 'utf-8');
                } catch (e) {
                    if ('ENOENT' === e.code) return null;
                    throw e;
                }
                return data;
            }
            write(str) {
                return this.#writer.write(str);
            }
        }
        class JSONFile_JSONFile {
            #adapter;
            constructor(filename){
                this.#adapter = new TextFile(filename);
            }
            async read() {
                const data = await this.#adapter.read();
                if (null === data) return null;
                return JSON.parse(data);
            }
            write(obj) {
                return this.#adapter.write(JSON.stringify(obj, null, 2));
            }
        }
        function FileStorageProvider_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class FileStorageProvider {
            async initialize() {
                if (!this.initialized) try {
                    await this.db.read();
                    this.db.data = this.db.data || {
                        sessions: {},
                        events: {}
                    };
                    this.initialized = true;
                } catch (error) {
                    this.db.data = {
                        sessions: {},
                        events: {}
                    };
                    await this.db.write();
                    this.initialized = true;
                }
            }
            async createSession(metadata) {
                await this.ensureInitialized();
                const sessionData = {
                    ...metadata,
                    createdAt: metadata.createdAt || Date.now(),
                    updatedAt: metadata.updatedAt || Date.now()
                };
                this.db.data.sessions[metadata.id] = sessionData;
                this.db.data.events[metadata.id] = [];
                await this.db.write();
                return sessionData;
            }
            async updateSessionMetadata(sessionId, metadata) {
                await this.ensureInitialized();
                const session = this.db.data.sessions[sessionId];
                if (!session) throw new Error(`Session not found: ${sessionId}`);
                const updatedSession = {
                    ...session,
                    ...metadata,
                    updatedAt: Date.now()
                };
                this.db.data.sessions[sessionId] = updatedSession;
                await this.db.write();
                return updatedSession;
            }
            async getSessionMetadata(sessionId) {
                await this.ensureInitialized();
                return this.db.data.sessions[sessionId] || null;
            }
            async getAllSessions() {
                await this.ensureInitialized();
                return Object.values(this.db.data.sessions);
            }
            async deleteSession(sessionId) {
                await this.ensureInitialized();
                if (!this.db.data.sessions[sessionId]) return false;
                delete this.db.data.sessions[sessionId];
                delete this.db.data.events[sessionId];
                await this.db.write();
                return true;
            }
            async saveEvent(sessionId, event) {
                await this.ensureInitialized();
                if (!this.db.data.sessions[sessionId]) throw new Error(`Session not found: ${sessionId}`);
                if (!this.db.data.events[sessionId]) this.db.data.events[sessionId] = [];
                this.db.data.events[sessionId].push(event);
                this.db.data.sessions[sessionId].updatedAt = Date.now();
                await this.db.write();
            }
            async getSessionEvents(sessionId) {
                await this.ensureInitialized();
                if (!this.db.data.sessions[sessionId]) throw new Error(`Session not found: ${sessionId}`);
                return this.db.data.events[sessionId] || [];
            }
            async close() {
                if (this.initialized) await this.db.write();
            }
            async ensureInitialized() {
                if (!this.initialized) await this.initialize();
            }
            constructor(storagePath){
                FileStorageProvider_define_property(this, "db", void 0);
                FileStorageProvider_define_property(this, "initialized", false);
                FileStorageProvider_define_property(this, "dbPath", void 0);
                const defaultPath = process.env.HOME || process.env.USERPROFILE || '.';
                const baseDir = storagePath || external_path_default().join(defaultPath, '.agent-tars');
                if (!external_fs_default().existsSync(baseDir)) external_fs_default().mkdirSync(baseDir, {
                    recursive: true
                });
                this.dbPath = external_path_default().join(baseDir, 'storage.json');
                const adapter = new JSONFile_JSONFile(this.dbPath);
                this.db = new Low_Low(adapter, {
                    sessions: {},
                    events: {}
                });
            }
        }
        const external_node_sqlite_namespaceObject = require("node:sqlite");
        function SQLiteStorageProvider_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class SQLiteStorageProvider {
            async initialize() {
                if (!this.initialized) try {
                    this.db.open();
                    this.db.exec('PRAGMA journal_mode = WAL');
                    this.db.exec(`
          CREATE TABLE IF NOT EXISTS sessions (
            id TEXT PRIMARY KEY,
            createdAt INTEGER NOT NULL,
            updatedAt INTEGER NOT NULL,
            name TEXT,
            workingDirectory TEXT NOT NULL,
            tags TEXT
          )
        `);
                    this.db.exec(`
          CREATE TABLE IF NOT EXISTS events (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            sessionId TEXT NOT NULL,
            timestamp INTEGER NOT NULL,
            eventData TEXT NOT NULL,
            FOREIGN KEY (sessionId) REFERENCES sessions (id) ON DELETE CASCADE
          )
        `);
                    this.db.exec(`
          CREATE INDEX IF NOT EXISTS idx_events_sessionId ON events (sessionId)
        `);
                    this.db.exec('PRAGMA foreign_keys = ON');
                    this.initialized = true;
                } catch (error) {
                    console.error('Failed to initialize SQLite database:', error);
                    throw error;
                }
            }
            async createSession(metadata) {
                await this.ensureInitialized();
                const sessionData = {
                    ...metadata,
                    createdAt: metadata.createdAt || Date.now(),
                    updatedAt: metadata.updatedAt || Date.now()
                };
                const tagsJson = sessionData.tags ? JSON.stringify(sessionData.tags) : null;
                try {
                    const stmt = this.db.prepare(`
        INSERT INTO sessions (id, createdAt, updatedAt, name, workingDirectory, tags)
        VALUES (?, ?, ?, ?, ?, ?)
      `);
                    stmt.run(sessionData.id, sessionData.createdAt, sessionData.updatedAt, sessionData.name || null, sessionData.workingDirectory, tagsJson);
                    return sessionData;
                } catch (error) {
                    console.error(`Failed to create session ${sessionData.id}:`, error);
                    throw new Error(`Failed to create session: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            async updateSessionMetadata(sessionId, metadata) {
                await this.ensureInitialized();
                const session = await this.getSessionMetadata(sessionId);
                if (!session) throw new Error(`Session not found: ${sessionId}`);
                const updatedSession = {
                    ...session,
                    ...metadata,
                    updatedAt: Date.now()
                };
                try {
                    const params = [];
                    const setClauses = [];
                    if (void 0 !== metadata.name) {
                        setClauses.push('name = ?');
                        params.push(metadata.name || null);
                    }
                    if (void 0 !== metadata.workingDirectory) {
                        setClauses.push('workingDirectory = ?');
                        params.push(metadata.workingDirectory);
                    }
                    if (void 0 !== metadata.tags) {
                        setClauses.push('tags = ?');
                        params.push(metadata.tags ? JSON.stringify(metadata.tags) : null);
                    }
                    setClauses.push('updatedAt = ?');
                    params.push(updatedSession.updatedAt);
                    params.push(sessionId);
                    if (0 === setClauses.length) return updatedSession;
                    const updateQuery = `
        UPDATE sessions
        SET ${setClauses.join(', ')}
        WHERE id = ?
      `;
                    const updateStmt = this.db.prepare(updateQuery);
                    updateStmt.run(...params);
                    return updatedSession;
                } catch (error) {
                    console.error(`Failed to update session ${sessionId}:`, error);
                    throw new Error(`Failed to update session: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            async getSessionMetadata(sessionId) {
                await this.ensureInitialized();
                try {
                    const stmt = this.db.prepare(`
        SELECT id, createdAt, updatedAt, name, workingDirectory, tags
        FROM sessions
        WHERE id = ?
      `);
                    const row = stmt.get(sessionId);
                    if (!row) return null;
                    return {
                        id: row.id,
                        createdAt: row.createdAt,
                        updatedAt: row.updatedAt,
                        name: row.name || void 0,
                        workingDirectory: row.workingDirectory,
                        tags: row.tags ? JSON.parse(row.tags) : void 0
                    };
                } catch (error) {
                    console.error(`Failed to get session ${sessionId}:`, error);
                    throw new Error(`Failed to get session: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            async getAllSessions() {
                await this.ensureInitialized();
                try {
                    const stmt = this.db.prepare(`
        SELECT id, createdAt, updatedAt, name, workingDirectory, tags
        FROM sessions
        ORDER BY updatedAt DESC
      `);
                    const rows = stmt.all();
                    return rows.map((row)=>({
                            id: row.id,
                            createdAt: row.createdAt,
                            updatedAt: row.updatedAt,
                            name: row.name || void 0,
                            workingDirectory: row.workingDirectory,
                            tags: row.tags ? JSON.parse(row.tags) : void 0
                        }));
                } catch (error) {
                    console.error('Failed to get all sessions:', error);
                    throw new Error(`Failed to get all sessions: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            async deleteSession(sessionId) {
                await this.ensureInitialized();
                try {
                    const deleteEventsStmt = this.db.prepare('DELETE FROM events WHERE sessionId = ?');
                    deleteEventsStmt.run(sessionId);
                    const deleteSessionStmt = this.db.prepare('DELETE FROM sessions WHERE id = ?');
                    const result = deleteSessionStmt.run(sessionId);
                    return result.changes > 0;
                } catch (error) {
                    console.error(`Failed to delete session ${sessionId}:`, error);
                    throw new Error(`Failed to delete session: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            async saveEvent(sessionId, event) {
                await this.ensureInitialized();
                try {
                    const sessionExistsStmt = this.db.prepare(`
        SELECT 1 as existsFlag FROM sessions WHERE id = ?
      `);
                    const sessionExists = sessionExistsStmt.get(sessionId);
                    if (!sessionExists || !sessionExists.existsFlag) throw new Error(`Session not found: ${sessionId}`);
                    const timestamp = Date.now();
                    const eventData = JSON.stringify(event);
                    const insertEventStmt = this.db.prepare(`
        INSERT INTO events (sessionId, timestamp, eventData)
        VALUES (?, ?, ?)
      `);
                    insertEventStmt.run(sessionId, timestamp, eventData);
                    const updateSessionStmt = this.db.prepare(`
        UPDATE sessions SET updatedAt = ? WHERE id = ?
      `);
                    updateSessionStmt.run(timestamp, sessionId);
                } catch (error) {
                    console.error(`Failed to save event for session ${sessionId}:`, error);
                    throw new Error(`Failed to save event: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            async getSessionEvents(sessionId) {
                await this.ensureInitialized();
                try {
                    const sessionExistsStmt = this.db.prepare(`
        SELECT 1 as existsFlag FROM sessions WHERE id = ?
      `);
                    const sessionExists = sessionExistsStmt.get(sessionId);
                    if (!sessionExists || !sessionExists.existsFlag) throw new Error(`Session not found: ${sessionId}`);
                    const stmt = this.db.prepare(`
        SELECT eventData
        FROM events
        WHERE sessionId = ?
        ORDER BY timestamp ASC, id ASC
      `);
                    const rows = stmt.all(sessionId);
                    return rows.map((row)=>{
                        try {
                            return JSON.parse(row.eventData);
                        } catch (error) {
                            console.error(`Failed to parse event data: ${row.eventData}`);
                            return {
                                type: 'system',
                                message: 'Failed to parse event data',
                                timestamp: Date.now()
                            };
                        }
                    });
                } catch (error) {
                    console.error(`Failed to get events for session ${sessionId}:`, error);
                    throw new Error(`Failed to get session events: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            async close() {
                if (this.db && this.db.isOpen) this.db.close();
            }
            async ensureInitialized() {
                if (!this.initialized) await this.initialize();
            }
            constructor(storagePath){
                SQLiteStorageProvider_define_property(this, "db", void 0);
                SQLiteStorageProvider_define_property(this, "initialized", false);
                SQLiteStorageProvider_define_property(this, "dbPath", void 0);
                const defaultPath = process.env.HOME || process.env.USERPROFILE || '.';
                const baseDir = storagePath || external_path_default().join(defaultPath, '.agent-tars');
                if (!external_fs_default().existsSync(baseDir)) external_fs_default().mkdirSync(baseDir, {
                    recursive: true
                });
                this.dbPath = external_path_default().join(baseDir, 'agent-tars.db');
                this.db = new external_node_sqlite_namespaceObject.DatabaseSync(this.dbPath, {
                    open: false
                });
            }
        }
        function createStorageProvider(options) {
            if (!options || 'memory' === options.type) return new MemoryStorageProvider();
            if ('file' === options.type) return new FileStorageProvider(options.path);
            if ('sqlite' === options.type) return new SQLiteStorageProvider(options.path);
            if ('database' === options.type) throw new Error('Database storage not implemented');
            throw new Error(`Unknown storage type: ${options.type}`);
        }
    },
    "./src/types.ts": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var _agent_tars_interface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../agent-tars-interface/dist/index.mjs");
        var __WEBPACK_REEXPORT_OBJECT__ = {};
        for(var __WEBPACK_IMPORT_KEY__ in _agent_tars_interface__WEBPACK_IMPORTED_MODULE_0__)if ("default" !== __WEBPACK_IMPORT_KEY__) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = (function(key) {
            return _agent_tars_interface__WEBPACK_IMPORTED_MODULE_0__[key];
        }).bind(0, __WEBPACK_IMPORT_KEY__);
        __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
    },
    "./src/utils/error-handler.ts": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            G8: ()=>ErrorWithCode,
            jl: ()=>createErrorResponse,
            rB: ()=>handleAgentError
        });
        function _define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class ErrorWithCode extends Error {
            constructor(message, code, details){
                super(message), _define_property(this, "code", void 0), _define_property(this, "details", void 0), this.code = code, this.details = details;
                this.name = 'AgentTARSError';
            }
        }
        function handleAgentError(error, context) {
            console.error(`Agent error${context ? ` [${context}]` : ''}:`, error);
            if (error instanceof ErrorWithCode) return error;
            if (error instanceof Error) return new ErrorWithCode(error.message, 'AGENT_EXECUTION_ERROR', {
                stack: error.stack
            });
            return new ErrorWithCode('string' == typeof error ? error : 'Unknown agent execution error', 'UNKNOWN_ERROR', {
                originalError: error
            });
        }
        function createErrorResponse(error) {
            const normalizedError = handleAgentError(error);
            return {
                success: false,
                error: {
                    code: normalizedError.code,
                    message: normalizedError.message,
                    details: normalizedError.details
                }
            };
        }
    },
    "./src/utils/index.ts": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            G8: ()=>_error_handler__WEBPACK_IMPORTED_MODULE_1__.G8,
            jl: ()=>_error_handler__WEBPACK_IMPORTED_MODULE_1__.jl,
            rB: ()=>_error_handler__WEBPACK_IMPORTED_MODULE_1__.rB,
            st: ()=>_workspace__WEBPACK_IMPORTED_MODULE_0__.s
        });
        var _workspace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/workspace.ts");
        var _error_handler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/error-handler.ts");
    },
    "./src/utils/workspace.ts": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            s: ()=>ensureWorkingDirectory
        });
        var external_fs_ = __webpack_require__("fs");
        var external_fs_default = /*#__PURE__*/ __webpack_require__.n(external_fs_);
        var external_path_ = __webpack_require__("path");
        var external_path_default = /*#__PURE__*/ __webpack_require__.n(external_path_);
        var external_os_ = __webpack_require__("os");
        var external_os_default = /*#__PURE__*/ __webpack_require__.n(external_os_);
        function _define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class WorkspacePathManager {
            static resolveWorkspacePath(baseDir, workspacePath, namespace, isolateSessions) {
                let resolvedPath;
                resolvedPath = workspacePath ? workspacePath.startsWith('~') ? workspacePath.replace(/^~/, external_os_default().homedir()) : external_path_default().isAbsolute(workspacePath) ? workspacePath : external_path_default().resolve(baseDir, workspacePath) : external_path_default().join(baseDir, this.DEFAULT_WORKSPACE_DIR);
                if (isolateSessions && namespace) resolvedPath = external_path_default().join(resolvedPath, namespace);
                return resolvedPath;
            }
            static ensureWorkspaceDirectory(workspacePath) {
                try {
                    external_fs_default().mkdirSync(workspacePath, {
                        recursive: true
                    });
                    return workspacePath;
                } catch (error) {
                    throw new Error(`Failed to create workspace directory ${workspacePath}: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
        }
        _define_property(WorkspacePathManager, "DEFAULT_WORKSPACE_DIR", 'agent-tars-workspace');
        function ensureWorkingDirectory(namespace, workspacePath, isolateSessions = false, isDebug = false) {
            try {
                const baseDir = process.cwd();
                const resolvedPath = WorkspacePathManager.resolveWorkspacePath(baseDir, workspacePath, namespace, isolateSessions);
                const workingDirectory = WorkspacePathManager.ensureWorkspaceDirectory(resolvedPath);
                if (isDebug) console.log(`Created or verified working directory: ${workingDirectory}`);
                return workingDirectory;
            } catch (error) {
                console.error("Failed to create working directory:", error);
                throw new Error(`Failed to initialize agent workspace: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    },
    "../mcp-agent-interface/dist/index.mjs": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            i: ()=>_multimodal_agent_interface__WEBPACK_IMPORTED_MODULE_0__.LogLevel
        });
        var _multimodal_agent_interface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../agent-interface/dist/index.mjs");
    },
    "@agent-tars/core": function(module) {
        "use strict";
        module.exports = require("@agent-tars/core");
    },
    async_hooks: function(module) {
        "use strict";
        module.exports = require("async_hooks");
    },
    buffer: function(module) {
        "use strict";
        module.exports = require("buffer");
    },
    crypto: function(module) {
        "use strict";
        module.exports = require("crypto");
    },
    events: function(module) {
        "use strict";
        module.exports = require("events");
    },
    fs: function(module) {
        "use strict";
        module.exports = require("fs");
    },
    http: function(module) {
        "use strict";
        module.exports = require("http");
    },
    https: function(module) {
        "use strict";
        module.exports = require("https");
    },
    net: function(module) {
        "use strict";
        module.exports = require("net");
    },
    os: function(module) {
        "use strict";
        module.exports = require("os");
    },
    path: function(module) {
        "use strict";
        module.exports = require("path");
    },
    querystring: function(module) {
        "use strict";
        module.exports = require("querystring");
    },
    stream: function(module) {
        "use strict";
        module.exports = require("stream");
    },
    string_decoder: function(module) {
        "use strict";
        module.exports = require("string_decoder");
    },
    timers: function(module) {
        "use strict";
        module.exports = require("timers");
    },
    tls: function(module) {
        "use strict";
        module.exports = require("tls");
    },
    tty: function(module) {
        "use strict";
        module.exports = require("tty");
    },
    url: function(module) {
        "use strict";
        module.exports = require("url");
    },
    util: function(module) {
        "use strict";
        module.exports = require("util");
    },
    zlib: function(module) {
        "use strict";
        module.exports = require("zlib");
    },
    "../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/commons.js": function(__unused_webpack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.ERROR_PACKET = exports1.PACKET_TYPES_REVERSE = exports1.PACKET_TYPES = void 0;
        const PACKET_TYPES = Object.create(null);
        exports1.PACKET_TYPES = PACKET_TYPES;
        PACKET_TYPES["open"] = "0";
        PACKET_TYPES["close"] = "1";
        PACKET_TYPES["ping"] = "2";
        PACKET_TYPES["pong"] = "3";
        PACKET_TYPES["message"] = "4";
        PACKET_TYPES["upgrade"] = "5";
        PACKET_TYPES["noop"] = "6";
        const PACKET_TYPES_REVERSE = Object.create(null);
        exports1.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
        Object.keys(PACKET_TYPES).forEach((key)=>{
            PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
        });
        const ERROR_PACKET = {
            type: "error",
            data: "parser error"
        };
        exports1.ERROR_PACKET = ERROR_PACKET;
    },
    "../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/decodePacket.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.decodePacket = void 0;
        const commons_js_1 = __webpack_require__("../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/commons.js");
        const decodePacket = (encodedPacket, binaryType)=>{
            if ("string" != typeof encodedPacket) return {
                type: "message",
                data: mapBinary(encodedPacket, binaryType)
            };
            const type = encodedPacket.charAt(0);
            if ("b" === type) {
                const buffer = Buffer.from(encodedPacket.substring(1), "base64");
                return {
                    type: "message",
                    data: mapBinary(buffer, binaryType)
                };
            }
            if (!commons_js_1.PACKET_TYPES_REVERSE[type]) return commons_js_1.ERROR_PACKET;
            return encodedPacket.length > 1 ? {
                type: commons_js_1.PACKET_TYPES_REVERSE[type],
                data: encodedPacket.substring(1)
            } : {
                type: commons_js_1.PACKET_TYPES_REVERSE[type]
            };
        };
        exports1.decodePacket = decodePacket;
        const mapBinary = (data, binaryType)=>{
            switch(binaryType){
                case "arraybuffer":
                    if (data instanceof ArrayBuffer) return data;
                    if (Buffer.isBuffer(data)) return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
                    return data.buffer;
                case "nodebuffer":
                default:
                    if (Buffer.isBuffer(data)) return data;
                    return Buffer.from(data);
            }
        };
    },
    "../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/encodePacket.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.encodePacket = void 0;
        exports1.encodePacketToBinary = encodePacketToBinary;
        const commons_js_1 = __webpack_require__("../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/commons.js");
        const encodePacket = ({ type, data }, supportsBinary, callback)=>{
            if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) return callback(supportsBinary ? data : "b" + toBuffer(data, true).toString("base64"));
            return callback(commons_js_1.PACKET_TYPES[type] + (data || ""));
        };
        exports1.encodePacket = encodePacket;
        const toBuffer = (data, forceBufferConversion)=>{
            if (Buffer.isBuffer(data) || data instanceof Uint8Array && !forceBufferConversion) return data;
            if (data instanceof ArrayBuffer) return Buffer.from(data);
            return Buffer.from(data.buffer, data.byteOffset, data.byteLength);
        };
        let TEXT_ENCODER;
        function encodePacketToBinary(packet, callback) {
            if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) return callback(toBuffer(packet.data, false));
            (0, exports1.encodePacket)(packet, true, (encoded)=>{
                if (!TEXT_ENCODER) TEXT_ENCODER = new TextEncoder();
                callback(TEXT_ENCODER.encode(encoded));
            });
        }
    },
    "../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.decodePayload = exports1.decodePacket = exports1.encodePayload = exports1.encodePacket = exports1.protocol = void 0;
        exports1.createPacketEncoderStream = createPacketEncoderStream;
        exports1.createPacketDecoderStream = createPacketDecoderStream;
        const encodePacket_js_1 = __webpack_require__("../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/encodePacket.js");
        Object.defineProperty(exports1, "encodePacket", {
            enumerable: true,
            get: function() {
                return encodePacket_js_1.encodePacket;
            }
        });
        const decodePacket_js_1 = __webpack_require__("../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/decodePacket.js");
        Object.defineProperty(exports1, "decodePacket", {
            enumerable: true,
            get: function() {
                return decodePacket_js_1.decodePacket;
            }
        });
        const commons_js_1 = __webpack_require__("../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/commons.js");
        const SEPARATOR = String.fromCharCode(30);
        const encodePayload = (packets, callback)=>{
            const length = packets.length;
            const encodedPackets = new Array(length);
            let count = 0;
            packets.forEach((packet, i)=>{
                (0, encodePacket_js_1.encodePacket)(packet, false, (encodedPacket)=>{
                    encodedPackets[i] = encodedPacket;
                    if (++count === length) callback(encodedPackets.join(SEPARATOR));
                });
            });
        };
        exports1.encodePayload = encodePayload;
        const decodePayload = (encodedPayload, binaryType)=>{
            const encodedPackets = encodedPayload.split(SEPARATOR);
            const packets = [];
            for(let i = 0; i < encodedPackets.length; i++){
                const decodedPacket = (0, decodePacket_js_1.decodePacket)(encodedPackets[i], binaryType);
                packets.push(decodedPacket);
                if ("error" === decodedPacket.type) break;
            }
            return packets;
        };
        exports1.decodePayload = decodePayload;
        function createPacketEncoderStream() {
            return new TransformStream({
                transform (packet, controller) {
                    (0, encodePacket_js_1.encodePacketToBinary)(packet, (encodedPacket)=>{
                        const payloadLength = encodedPacket.length;
                        let header;
                        if (payloadLength < 126) {
                            header = new Uint8Array(1);
                            new DataView(header.buffer).setUint8(0, payloadLength);
                        } else if (payloadLength < 65536) {
                            header = new Uint8Array(3);
                            const view = new DataView(header.buffer);
                            view.setUint8(0, 126);
                            view.setUint16(1, payloadLength);
                        } else {
                            header = new Uint8Array(9);
                            const view = new DataView(header.buffer);
                            view.setUint8(0, 127);
                            view.setBigUint64(1, BigInt(payloadLength));
                        }
                        if (packet.data && "string" != typeof packet.data) header[0] |= 0x80;
                        controller.enqueue(header);
                        controller.enqueue(encodedPacket);
                    });
                }
            });
        }
        let TEXT_DECODER;
        function totalLength(chunks) {
            return chunks.reduce((acc, chunk)=>acc + chunk.length, 0);
        }
        function concatChunks(chunks, size) {
            if (chunks[0].length === size) return chunks.shift();
            const buffer = new Uint8Array(size);
            let j = 0;
            for(let i = 0; i < size; i++){
                buffer[i] = chunks[0][j++];
                if (j === chunks[0].length) {
                    chunks.shift();
                    j = 0;
                }
            }
            if (chunks.length && j < chunks[0].length) chunks[0] = chunks[0].slice(j);
            return buffer;
        }
        function createPacketDecoderStream(maxPayload, binaryType) {
            if (!TEXT_DECODER) TEXT_DECODER = new TextDecoder();
            const chunks = [];
            let state = 0;
            let expectedLength = -1;
            let isBinary = false;
            return new TransformStream({
                transform (chunk, controller) {
                    chunks.push(chunk);
                    while(true){
                        if (0 === state) {
                            if (totalLength(chunks) < 1) break;
                            const header = concatChunks(chunks, 1);
                            isBinary = (0x80 & header[0]) === 0x80;
                            expectedLength = 0x7f & header[0];
                            state = expectedLength < 126 ? 3 : 126 === expectedLength ? 1 : 2;
                        } else if (1 === state) {
                            if (totalLength(chunks) < 2) break;
                            const headerArray = concatChunks(chunks, 2);
                            expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
                            state = 3;
                        } else if (2 === state) {
                            if (totalLength(chunks) < 8) break;
                            const headerArray = concatChunks(chunks, 8);
                            const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
                            const n = view.getUint32(0);
                            if (n > Math.pow(2, 21) - 1) {
                                controller.enqueue(commons_js_1.ERROR_PACKET);
                                break;
                            }
                            expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
                            state = 3;
                        } else {
                            if (totalLength(chunks) < expectedLength) break;
                            const data = concatChunks(chunks, expectedLength);
                            controller.enqueue((0, decodePacket_js_1.decodePacket)(isBinary ? data : TEXT_DECODER.decode(data), binaryType));
                            state = 0;
                        }
                        if (0 === expectedLength || expectedLength > maxPayload) {
                            controller.enqueue(commons_js_1.ERROR_PACKET);
                            break;
                        }
                    }
                }
            });
        }
        exports1.protocol = 4;
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/engine.io.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.protocol = exports1.Transport = exports1.Socket = exports1.uServer = exports1.parser = exports1.transports = exports1.Server = void 0;
        exports1.listen = listen;
        exports1.attach = attach;
        const http_1 = __webpack_require__("http");
        const server_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/server.js");
        Object.defineProperty(exports1, "Server", {
            enumerable: true,
            get: function() {
                return server_1.Server;
            }
        });
        const index_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/index.js");
        exports1.transports = index_1.default;
        const parser = __webpack_require__("../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/index.js");
        exports1.parser = parser;
        var userver_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/userver.js");
        Object.defineProperty(exports1, "uServer", {
            enumerable: true,
            get: function() {
                return userver_1.uServer;
            }
        });
        var socket_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/socket.js");
        Object.defineProperty(exports1, "Socket", {
            enumerable: true,
            get: function() {
                return socket_1.Socket;
            }
        });
        var transport_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transport.js");
        Object.defineProperty(exports1, "Transport", {
            enumerable: true,
            get: function() {
                return transport_1.Transport;
            }
        });
        exports1.protocol = parser.protocol;
        function listen(port, options, fn) {
            if ("function" == typeof options) {
                fn = options;
                options = {};
            }
            const server = (0, http_1.createServer)(function(req, res) {
                res.writeHead(501);
                res.end("Not Implemented");
            });
            const engine = attach(server, options);
            engine.httpServer = server;
            server.listen(port, fn);
            return engine;
        }
        function attach(server, options) {
            const engine = new server_1.Server(options);
            engine.attach(server, options);
            return engine;
        }
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/parser-v3/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.packets = exports1.protocol = void 0;
        exports1.encodePacket = encodePacket;
        exports1.encodeBase64Packet = encodeBase64Packet;
        exports1.decodePacket = decodePacket;
        exports1.decodeBase64Packet = decodeBase64Packet;
        exports1.encodePayload = encodePayload;
        exports1.decodePayload = decodePayload;
        exports1.encodePayloadAsBinary = encodePayloadAsBinary;
        exports1.decodePayloadAsBinary = decodePayloadAsBinary;
        var utf8 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/parser-v3/utf8.js");
        exports1.protocol = 3;
        const hasBinary = (packets)=>{
            for (const packet of packets)if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) return true;
            return false;
        };
        exports1.packets = {
            open: 0,
            close: 1,
            ping: 2,
            pong: 3,
            message: 4,
            upgrade: 5,
            noop: 6
        };
        var packetslist = Object.keys(exports1.packets);
        var err = {
            type: 'error',
            data: 'parser error'
        };
        const EMPTY_BUFFER = Buffer.concat([]);
        function encodePacket(packet, supportsBinary, utf8encode, callback) {
            if ('function' == typeof supportsBinary) {
                callback = supportsBinary;
                supportsBinary = null;
            }
            if ('function' == typeof utf8encode) {
                callback = utf8encode;
                utf8encode = null;
            }
            if (Buffer.isBuffer(packet.data)) return encodeBuffer(packet, supportsBinary, callback);
            if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) return encodeBuffer({
                type: packet.type,
                data: arrayBufferToBuffer(packet.data)
            }, supportsBinary, callback);
            var encoded = exports1.packets[packet.type];
            if (void 0 !== packet.data) encoded += utf8encode ? utf8.encode(String(packet.data), {
                strict: false
            }) : String(packet.data);
            return callback('' + encoded);
        }
        function encodeBuffer(packet, supportsBinary, callback) {
            if (!supportsBinary) return encodeBase64Packet(packet, callback);
            var data = packet.data;
            var typeBuffer = Buffer.allocUnsafe(1);
            typeBuffer[0] = exports1.packets[packet.type];
            return callback(Buffer.concat([
                typeBuffer,
                data
            ]));
        }
        function encodeBase64Packet(packet, callback) {
            var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);
            var message = 'b' + exports1.packets[packet.type];
            message += data.toString('base64');
            return callback(message);
        }
        function decodePacket(data, binaryType, utf8decode) {
            if (void 0 === data) return err;
            var type;
            if ('string' == typeof data) {
                type = data.charAt(0);
                if ('b' === type) return decodeBase64Packet(data.slice(1), binaryType);
                if (utf8decode) {
                    data = tryDecode(data);
                    if (false === data) return err;
                }
                if (Number(type) != type || !packetslist[type]) return err;
                if (data.length > 1) return {
                    type: packetslist[type],
                    data: data.slice(1)
                };
                return {
                    type: packetslist[type]
                };
            }
            if ('arraybuffer' === binaryType) {
                var intArray = new Uint8Array(data);
                type = intArray[0];
                return {
                    type: packetslist[type],
                    data: intArray.buffer.slice(1)
                };
            }
            if (data instanceof ArrayBuffer) data = arrayBufferToBuffer(data);
            type = data[0];
            return {
                type: packetslist[type],
                data: data.slice(1)
            };
        }
        function tryDecode(data) {
            try {
                data = utf8.decode(data, {
                    strict: false
                });
            } catch (e) {
                return false;
            }
            return data;
        }
        function decodeBase64Packet(msg, binaryType) {
            var type = packetslist[msg.charAt(0)];
            var data = Buffer.from(msg.slice(1), 'base64');
            if ('arraybuffer' === binaryType) {
                var abv = new Uint8Array(data.length);
                for(var i = 0; i < abv.length; i++)abv[i] = data[i];
                data = abv.buffer;
            }
            return {
                type: type,
                data: data
            };
        }
        function encodePayload(packets, supportsBinary, callback) {
            if ('function' == typeof supportsBinary) {
                callback = supportsBinary;
                supportsBinary = null;
            }
            if (supportsBinary && hasBinary(packets)) return encodePayloadAsBinary(packets, callback);
            if (!packets.length) return callback('0:');
            function encodeOne(packet, doneCallback) {
                encodePacket(packet, supportsBinary, false, function(message) {
                    doneCallback(null, setLengthHeader(message));
                });
            }
            map(packets, encodeOne, function(err, results) {
                return callback(results.join(''));
            });
        }
        function setLengthHeader(message) {
            return message.length + ':' + message;
        }
        function map(ary, each, done) {
            const results = new Array(ary.length);
            let count = 0;
            for(let i = 0; i < ary.length; i++)each(ary[i], (error, msg)=>{
                results[i] = msg;
                if (++count === ary.length) done(null, results);
            });
        }
        function decodePayload(data, binaryType, callback) {
            if ('string' != typeof data) return decodePayloadAsBinary(data, binaryType, callback);
            if ('function' == typeof binaryType) {
                callback = binaryType;
                binaryType = null;
            }
            if ('' === data) return callback(err, 0, 1);
            var length = '', n, msg, packet;
            for(var i = 0, l = data.length; i < l; i++){
                var chr = data.charAt(i);
                if (':' !== chr) {
                    length += chr;
                    continue;
                }
                if ('' === length || length != (n = Number(length))) return callback(err, 0, 1);
                msg = data.slice(i + 1, i + 1 + n);
                if (length != msg.length) return callback(err, 0, 1);
                if (msg.length) {
                    packet = decodePacket(msg, binaryType, false);
                    if (err.type === packet.type && err.data === packet.data) return callback(err, 0, 1);
                    var more = callback(packet, i + n, l);
                    if (false === more) return;
                }
                i += n;
                length = '';
            }
            if ('' !== length) return callback(err, 0, 1);
        }
        function bufferToString(buffer) {
            var str = '';
            for(var i = 0, l = buffer.length; i < l; i++)str += String.fromCharCode(buffer[i]);
            return str;
        }
        function stringToBuffer(string) {
            var buf = Buffer.allocUnsafe(string.length);
            for(var i = 0, l = string.length; i < l; i++)buf.writeUInt8(string.charCodeAt(i), i);
            return buf;
        }
        function arrayBufferToBuffer(data) {
            var length = data.byteLength || data.length;
            var offset = data.byteOffset || 0;
            return Buffer.from(data.buffer || data, offset, length);
        }
        function encodePayloadAsBinary(packets, callback) {
            if (!packets.length) return callback(EMPTY_BUFFER);
            map(packets, encodeOneBinaryPacket, function(err, results) {
                return callback(Buffer.concat(results));
            });
        }
        function encodeOneBinaryPacket(p, doneCallback) {
            function onBinaryPacketEncode(packet) {
                var encodingLength = '' + packet.length;
                var sizeBuffer;
                if ('string' == typeof packet) {
                    sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
                    sizeBuffer[0] = 0;
                    for(var i = 0; i < encodingLength.length; i++)sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
                    sizeBuffer[sizeBuffer.length - 1] = 255;
                    return doneCallback(null, Buffer.concat([
                        sizeBuffer,
                        stringToBuffer(packet)
                    ]));
                }
                sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
                sizeBuffer[0] = 1;
                for(var i = 0; i < encodingLength.length; i++)sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
                sizeBuffer[sizeBuffer.length - 1] = 255;
                doneCallback(null, Buffer.concat([
                    sizeBuffer,
                    packet
                ]));
            }
            encodePacket(p, true, true, onBinaryPacketEncode);
        }
        function decodePayloadAsBinary(data, binaryType, callback) {
            if ('function' == typeof binaryType) {
                callback = binaryType;
                binaryType = null;
            }
            var bufferTail = data;
            var buffers = [];
            var i;
            while(bufferTail.length > 0){
                var strLen = '';
                var isString = 0 === bufferTail[0];
                for(i = 1;; i++){
                    if (255 === bufferTail[i]) break;
                    if (strLen.length > 310) return callback(err, 0, 1);
                    strLen += '' + bufferTail[i];
                }
                bufferTail = bufferTail.slice(strLen.length + 1);
                var msgLength = parseInt(strLen, 10);
                var msg = bufferTail.slice(1, msgLength + 1);
                if (isString) msg = bufferToString(msg);
                buffers.push(msg);
                bufferTail = bufferTail.slice(msgLength + 1);
            }
            var total = buffers.length;
            for(i = 0; i < total; i++){
                var buffer = buffers[i];
                callback(decodePacket(buffer, binaryType, true), i, total);
            }
        }
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/parser-v3/utf8.js": function(module) {
        /*! https://mths.be/utf8js v2.1.2 by @mathias */ var stringFromCharCode = String.fromCharCode;
        function ucs2decode(string) {
            var output = [];
            var counter = 0;
            var length = string.length;
            var value;
            var extra;
            while(counter < length){
                value = string.charCodeAt(counter++);
                if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                    extra = string.charCodeAt(counter++);
                    if ((0xFC00 & extra) == 0xDC00) output.push(((0x3FF & value) << 10) + (0x3FF & extra) + 0x10000);
                    else {
                        output.push(value);
                        counter--;
                    }
                } else output.push(value);
            }
            return output;
        }
        function ucs2encode(array) {
            var length = array.length;
            var index = -1;
            var value;
            var output = '';
            while(++index < length){
                value = array[index];
                if (value > 0xFFFF) {
                    value -= 0x10000;
                    output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                    value = 0xDC00 | 0x3FF & value;
                }
                output += stringFromCharCode(value);
            }
            return output;
        }
        function checkScalarValue(codePoint, strict) {
            if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
                if (strict) throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
                return false;
            }
            return true;
        }
        function createByte(codePoint, shift) {
            return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);
        }
        function encodeCodePoint(codePoint, strict) {
            if ((0xFFFFFF80 & codePoint) == 0) return stringFromCharCode(codePoint);
            var symbol = '';
            if ((0xFFFFF800 & codePoint) == 0) symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);
            else if ((0xFFFF0000 & codePoint) == 0) {
                if (!checkScalarValue(codePoint, strict)) codePoint = 0xFFFD;
                symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);
                symbol += createByte(codePoint, 6);
            } else if ((0xFFE00000 & codePoint) == 0) {
                symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);
                symbol += createByte(codePoint, 12);
                symbol += createByte(codePoint, 6);
            }
            symbol += stringFromCharCode(0x3F & codePoint | 0x80);
            return symbol;
        }
        function utf8encode(string, opts) {
            opts = opts || {};
            var strict = false !== opts.strict;
            var codePoints = ucs2decode(string);
            var length = codePoints.length;
            var index = -1;
            var codePoint;
            var byteString = '';
            while(++index < length){
                codePoint = codePoints[index];
                byteString += encodeCodePoint(codePoint, strict);
            }
            return byteString;
        }
        function readContinuationByte() {
            if (byteIndex >= byteCount) throw Error('Invalid byte index');
            var continuationByte = 0xFF & byteArray[byteIndex];
            byteIndex++;
            if ((0xC0 & continuationByte) == 0x80) return 0x3F & continuationByte;
            throw Error('Invalid continuation byte');
        }
        function decodeSymbol(strict) {
            var byte1;
            var byte2;
            var byte3;
            var byte4;
            var codePoint;
            if (byteIndex > byteCount) throw Error('Invalid byte index');
            if (byteIndex == byteCount) return false;
            byte1 = 0xFF & byteArray[byteIndex];
            byteIndex++;
            if ((0x80 & byte1) == 0) return byte1;
            if ((0xE0 & byte1) == 0xC0) {
                byte2 = readContinuationByte();
                codePoint = (0x1F & byte1) << 6 | byte2;
                if (codePoint >= 0x80) return codePoint;
                throw Error('Invalid continuation byte');
            }
            if ((0xF0 & byte1) == 0xE0) {
                byte2 = readContinuationByte();
                byte3 = readContinuationByte();
                codePoint = (0x0F & byte1) << 12 | byte2 << 6 | byte3;
                if (codePoint >= 0x0800) return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
                throw Error('Invalid continuation byte');
            }
            if ((0xF8 & byte1) == 0xF0) {
                byte2 = readContinuationByte();
                byte3 = readContinuationByte();
                byte4 = readContinuationByte();
                codePoint = (0x07 & byte1) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;
                if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) return codePoint;
            }
            throw Error('Invalid UTF-8 detected');
        }
        var byteArray;
        var byteCount;
        var byteIndex;
        function utf8decode(byteString, opts) {
            opts = opts || {};
            var strict = false !== opts.strict;
            byteArray = ucs2decode(byteString);
            byteCount = byteArray.length;
            byteIndex = 0;
            var codePoints = [];
            var tmp;
            while(false !== (tmp = decodeSymbol(strict)))codePoints.push(tmp);
            return ucs2encode(codePoints);
        }
        module.exports = {
            version: '2.1.2',
            encode: utf8encode,
            decode: utf8decode
        };
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/server.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Server = exports1.BaseServer = void 0;
        const qs = __webpack_require__("querystring");
        const url_1 = __webpack_require__("url");
        const base64id = __webpack_require__("../node_modules/.pnpm/base64id@2.0.0/node_modules/base64id/lib/base64id.js");
        const transports_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/index.js");
        const events_1 = __webpack_require__("events");
        const socket_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/socket.js");
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const cookie_1 = __webpack_require__("../node_modules/.pnpm/cookie@0.7.2/node_modules/cookie/index.js");
        const ws_1 = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/index.js");
        const webtransport_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/webtransport.js");
        const engine_io_parser_1 = __webpack_require__("../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/index.js");
        const debug = (0, debug_1.default)("engine");
        const kResponseHeaders = Symbol("responseHeaders");
        function parseSessionId(data) {
            try {
                const parsed = JSON.parse(data);
                if ("string" == typeof parsed.sid) return parsed.sid;
            } catch (e) {}
        }
        class BaseServer extends events_1.EventEmitter {
            constructor(opts = {}){
                super();
                this.middlewares = [];
                this.clients = {};
                this.clientsCount = 0;
                this.opts = Object.assign({
                    wsEngine: ws_1.Server,
                    pingTimeout: 20000,
                    pingInterval: 25000,
                    upgradeTimeout: 10000,
                    maxHttpBufferSize: 1e6,
                    transports: [
                        "polling",
                        "websocket"
                    ],
                    allowUpgrades: true,
                    httpCompression: {
                        threshold: 1024
                    },
                    cors: false,
                    allowEIO3: false
                }, opts);
                if (opts.cookie) this.opts.cookie = Object.assign({
                    name: "io",
                    path: "/",
                    httpOnly: false !== opts.cookie.path,
                    sameSite: "lax"
                }, opts.cookie);
                if (this.opts.cors) this.use(__webpack_require__("../node_modules/.pnpm/cors@2.8.5/node_modules/cors/lib/index.js")(this.opts.cors));
                if (opts.perMessageDeflate) this.opts.perMessageDeflate = Object.assign({
                    threshold: 1024
                }, opts.perMessageDeflate);
                this.init();
            }
            _computePath(options) {
                let path = (options.path || "/engine.io").replace(/\/$/, "");
                if (false !== options.addTrailingSlash) path += "/";
                return path;
            }
            upgrades(transport) {
                if (!this.opts.allowUpgrades) return [];
                return transports_1.default[transport].upgradesTo || [];
            }
            verify(req, upgrade, fn) {
                const transport = req._query.transport;
                if (!~this.opts.transports.indexOf(transport) || "webtransport" === transport) {
                    debug('unknown transport "%s"', transport);
                    return fn(Server.errors.UNKNOWN_TRANSPORT, {
                        transport
                    });
                }
                const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);
                if (isOriginInvalid) {
                    const origin = req.headers.origin;
                    req.headers.origin = null;
                    debug("origin header invalid");
                    return fn(Server.errors.BAD_REQUEST, {
                        name: "INVALID_ORIGIN",
                        origin
                    });
                }
                const sid = req._query.sid;
                if (sid) {
                    if (!this.clients.hasOwnProperty(sid)) {
                        debug('unknown sid "%s"', sid);
                        return fn(Server.errors.UNKNOWN_SID, {
                            sid
                        });
                    }
                    const previousTransport = this.clients[sid].transport.name;
                    if (!upgrade && previousTransport !== transport) {
                        debug("bad request: unexpected transport without upgrade");
                        return fn(Server.errors.BAD_REQUEST, {
                            name: "TRANSPORT_MISMATCH",
                            transport,
                            previousTransport
                        });
                    }
                } else {
                    if ("GET" !== req.method) return fn(Server.errors.BAD_HANDSHAKE_METHOD, {
                        method: req.method
                    });
                    if ("websocket" === transport && !upgrade) {
                        debug("invalid transport upgrade");
                        return fn(Server.errors.BAD_REQUEST, {
                            name: "TRANSPORT_HANDSHAKE_ERROR"
                        });
                    }
                    if (!this.opts.allowRequest) return fn();
                    return this.opts.allowRequest(req, (message, success)=>{
                        if (!success) return fn(Server.errors.FORBIDDEN, {
                            message
                        });
                        fn();
                    });
                }
                fn();
            }
            use(fn) {
                this.middlewares.push(fn);
            }
            _applyMiddlewares(req, res, callback) {
                if (0 === this.middlewares.length) {
                    debug("no middleware to apply, skipping");
                    return callback();
                }
                const apply = (i)=>{
                    debug("applying middleware n°%d", i + 1);
                    this.middlewares[i](req, res, (err)=>{
                        if (err) return callback(err);
                        if (i + 1 < this.middlewares.length) apply(i + 1);
                        else callback();
                    });
                };
                apply(0);
            }
            close() {
                debug("closing all open clients");
                for(let i in this.clients)if (this.clients.hasOwnProperty(i)) this.clients[i].close(true);
                this.cleanup();
                return this;
            }
            generateId(req) {
                return base64id.generateId();
            }
            async handshake(transportName, req, closeConnection) {
                const protocol = "4" === req._query.EIO ? 4 : 3;
                if (3 === protocol && !this.opts.allowEIO3) {
                    debug("unsupported protocol version");
                    this.emit("connection_error", {
                        req,
                        code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,
                        message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],
                        context: {
                            protocol
                        }
                    });
                    closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);
                    return;
                }
                let id;
                try {
                    id = await this.generateId(req);
                } catch (e) {
                    debug("error while generating an id");
                    this.emit("connection_error", {
                        req,
                        code: Server.errors.BAD_REQUEST,
                        message: Server.errorMessages[Server.errors.BAD_REQUEST],
                        context: {
                            name: "ID_GENERATION_ERROR",
                            error: e
                        }
                    });
                    closeConnection(Server.errors.BAD_REQUEST);
                    return;
                }
                debug('handshaking client "%s"', id);
                try {
                    var transport = this.createTransport(transportName, req);
                    if ("polling" === transportName) {
                        transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;
                        transport.httpCompression = this.opts.httpCompression;
                    } else if ("websocket" === transportName) transport.perMessageDeflate = this.opts.perMessageDeflate;
                } catch (e) {
                    debug('error handshaking to transport "%s"', transportName);
                    this.emit("connection_error", {
                        req,
                        code: Server.errors.BAD_REQUEST,
                        message: Server.errorMessages[Server.errors.BAD_REQUEST],
                        context: {
                            name: "TRANSPORT_HANDSHAKE_ERROR",
                            error: e
                        }
                    });
                    closeConnection(Server.errors.BAD_REQUEST);
                    return;
                }
                const socket = new socket_1.Socket(id, this, transport, req, protocol);
                transport.on("headers", (headers, req)=>{
                    const isInitialRequest = !req._query.sid;
                    if (isInitialRequest) {
                        if (this.opts.cookie) headers["Set-Cookie"] = [
                            (0, cookie_1.serialize)(this.opts.cookie.name, id, this.opts.cookie)
                        ];
                        this.emit("initial_headers", headers, req);
                    }
                    this.emit("headers", headers, req);
                });
                transport.onRequest(req);
                this.clients[id] = socket;
                this.clientsCount++;
                socket.once("close", ()=>{
                    delete this.clients[id];
                    this.clientsCount--;
                });
                this.emit("connection", socket);
                return transport;
            }
            async onWebTransportSession(session) {
                const timeout = setTimeout(()=>{
                    debug("the client failed to establish a bidirectional stream in the given period");
                    session.close();
                }, this.opts.upgradeTimeout);
                const streamReader = session.incomingBidirectionalStreams.getReader();
                const result = await streamReader.read();
                if (result.done) return void debug("session is closed");
                const stream = result.value;
                const transformStream = (0, engine_io_parser_1.createPacketDecoderStream)(this.opts.maxHttpBufferSize, "nodebuffer");
                const reader = stream.readable.pipeThrough(transformStream).getReader();
                const { value, done } = await reader.read();
                if (done) return void debug("stream is closed");
                clearTimeout(timeout);
                if ("open" !== value.type) {
                    debug("invalid WebTransport handshake");
                    return session.close();
                }
                if (void 0 === value.data) {
                    const transport = new webtransport_1.WebTransport(session, stream, reader);
                    const id = base64id.generateId();
                    debug('handshaking client "%s" (WebTransport)', id);
                    const socket = new socket_1.Socket(id, this, transport, null, 4);
                    this.clients[id] = socket;
                    this.clientsCount++;
                    socket.once("close", ()=>{
                        delete this.clients[id];
                        this.clientsCount--;
                    });
                    this.emit("connection", socket);
                    return;
                }
                const sid = parseSessionId(value.data);
                if (!sid) {
                    debug("invalid WebTransport handshake");
                    return session.close();
                }
                const client = this.clients[sid];
                if (client) if (client.upgrading) {
                    debug("transport has already been trying to upgrade");
                    session.close();
                } else if (client.upgraded) {
                    debug("transport had already been upgraded");
                    session.close();
                } else {
                    debug("upgrading existing transport");
                    const transport = new webtransport_1.WebTransport(session, stream, reader);
                    client._maybeUpgrade(transport);
                }
                else {
                    debug("upgrade attempt for closed client");
                    session.close();
                }
            }
        }
        exports1.BaseServer = BaseServer;
        BaseServer.errors = {
            UNKNOWN_TRANSPORT: 0,
            UNKNOWN_SID: 1,
            BAD_HANDSHAKE_METHOD: 2,
            BAD_REQUEST: 3,
            FORBIDDEN: 4,
            UNSUPPORTED_PROTOCOL_VERSION: 5
        };
        BaseServer.errorMessages = {
            0: "Transport unknown",
            1: "Session ID unknown",
            2: "Bad handshake method",
            3: "Bad request",
            4: "Forbidden",
            5: "Unsupported protocol version"
        };
        class WebSocketResponse {
            constructor(req, socket){
                this.req = req;
                this.socket = socket;
                req[kResponseHeaders] = {};
            }
            setHeader(name, value) {
                this.req[kResponseHeaders][name] = value;
            }
            getHeader(name) {
                return this.req[kResponseHeaders][name];
            }
            removeHeader(name) {
                delete this.req[kResponseHeaders][name];
            }
            write() {}
            writeHead() {}
            end() {
                this.socket.destroy();
            }
        }
        class Server extends BaseServer {
            init() {
                if (!~this.opts.transports.indexOf("websocket")) return;
                if (this.ws) this.ws.close();
                this.ws = new this.opts.wsEngine({
                    noServer: true,
                    clientTracking: false,
                    perMessageDeflate: this.opts.perMessageDeflate,
                    maxPayload: this.opts.maxHttpBufferSize
                });
                if ("function" == typeof this.ws.on) this.ws.on("headers", (headersArray, req)=>{
                    const additionalHeaders = req[kResponseHeaders] || {};
                    delete req[kResponseHeaders];
                    const isInitialRequest = !req._query.sid;
                    if (isInitialRequest) this.emit("initial_headers", additionalHeaders, req);
                    this.emit("headers", additionalHeaders, req);
                    debug("writing headers: %j", additionalHeaders);
                    Object.keys(additionalHeaders).forEach((key)=>{
                        headersArray.push(`${key}: ${additionalHeaders[key]}`);
                    });
                });
            }
            cleanup() {
                if (this.ws) {
                    debug("closing webSocketServer");
                    this.ws.close();
                }
            }
            prepare(req) {
                if (!req._query) req._query = ~req.url.indexOf("?") ? qs.parse((0, url_1.parse)(req.url).query) : {};
            }
            createTransport(transportName, req) {
                return new transports_1.default[transportName](req);
            }
            handleRequest(req, res) {
                debug('handling "%s" http request "%s"', req.method, req.url);
                this.prepare(req);
                req.res = res;
                const callback = (errorCode, errorContext)=>{
                    if (void 0 !== errorCode) {
                        this.emit("connection_error", {
                            req,
                            code: errorCode,
                            message: Server.errorMessages[errorCode],
                            context: errorContext
                        });
                        abortRequest(res, errorCode, errorContext);
                        return;
                    }
                    if (req._query.sid) {
                        debug("setting new request for existing client");
                        this.clients[req._query.sid].transport.onRequest(req);
                    } else {
                        const closeConnection = (errorCode, errorContext)=>abortRequest(res, errorCode, errorContext);
                        this.handshake(req._query.transport, req, closeConnection);
                    }
                };
                this._applyMiddlewares(req, res, (err)=>{
                    if (err) callback(Server.errors.BAD_REQUEST, {
                        name: "MIDDLEWARE_FAILURE"
                    });
                    else this.verify(req, false, callback);
                });
            }
            handleUpgrade(req, socket, upgradeHead) {
                this.prepare(req);
                const res = new WebSocketResponse(req, socket);
                const callback = (errorCode, errorContext)=>{
                    if (void 0 !== errorCode) {
                        this.emit("connection_error", {
                            req,
                            code: errorCode,
                            message: Server.errorMessages[errorCode],
                            context: errorContext
                        });
                        abortUpgrade(socket, errorCode, errorContext);
                        return;
                    }
                    const head = Buffer.from(upgradeHead);
                    upgradeHead = null;
                    res.writeHead();
                    this.ws.handleUpgrade(req, socket, head, (websocket)=>{
                        this.onWebSocket(req, socket, websocket);
                    });
                };
                this._applyMiddlewares(req, res, (err)=>{
                    if (err) callback(Server.errors.BAD_REQUEST, {
                        name: "MIDDLEWARE_FAILURE"
                    });
                    else this.verify(req, true, callback);
                });
            }
            onWebSocket(req, socket, websocket) {
                websocket.on("error", onUpgradeError);
                if (void 0 !== transports_1.default[req._query.transport] && !transports_1.default[req._query.transport].prototype.handlesUpgrades) {
                    debug("transport doesnt handle upgraded requests");
                    websocket.close();
                    return;
                }
                const id = req._query.sid;
                req.websocket = websocket;
                if (id) {
                    const client = this.clients[id];
                    if (client) if (client.upgrading) {
                        debug("transport has already been trying to upgrade");
                        websocket.close();
                    } else if (client.upgraded) {
                        debug("transport had already been upgraded");
                        websocket.close();
                    } else {
                        debug("upgrading existing transport");
                        websocket.removeListener("error", onUpgradeError);
                        const transport = this.createTransport(req._query.transport, req);
                        transport.perMessageDeflate = this.opts.perMessageDeflate;
                        client._maybeUpgrade(transport);
                    }
                    else {
                        debug("upgrade attempt for closed client");
                        websocket.close();
                    }
                } else {
                    const closeConnection = (errorCode, errorContext)=>abortUpgrade(socket, errorCode, errorContext);
                    this.handshake(req._query.transport, req, closeConnection);
                }
                function onUpgradeError() {
                    debug("websocket error before upgrade");
                }
            }
            attach(server, options = {}) {
                const path = this._computePath(options);
                const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;
                function check(req) {
                    return path === req.url.slice(0, path.length);
                }
                const listeners = server.listeners("request").slice(0);
                server.removeAllListeners("request");
                server.on("close", this.close.bind(this));
                server.on("listening", this.init.bind(this));
                server.on("request", (req, res)=>{
                    if (check(req)) {
                        debug('intercepting request for path "%s"', path);
                        this.handleRequest(req, res);
                    } else {
                        let i = 0;
                        const l = listeners.length;
                        for(; i < l; i++)listeners[i].call(server, req, res);
                    }
                });
                if (~this.opts.transports.indexOf("websocket")) server.on("upgrade", (req, socket, head)=>{
                    if (check(req)) this.handleUpgrade(req, socket, head);
                    else if (false !== options.destroyUpgrade) setTimeout(function() {
                        if (socket.writable && socket.bytesWritten <= 0) {
                            socket.on("error", (e)=>{
                                debug("error while destroying upgrade: %s", e.message);
                            });
                            return socket.end();
                        }
                    }, destroyUpgradeTimeout);
                });
            }
        }
        exports1.Server = Server;
        function abortRequest(res, errorCode, errorContext) {
            const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;
            const message = errorContext && errorContext.message ? errorContext.message : Server.errorMessages[errorCode];
            res.writeHead(statusCode, {
                "Content-Type": "application/json"
            });
            res.end(JSON.stringify({
                code: errorCode,
                message
            }));
        }
        function abortUpgrade(socket, errorCode, errorContext = {}) {
            socket.on("error", ()=>{
                debug("ignoring error from closed connection");
            });
            if (socket.writable) {
                const message = errorContext.message || Server.errorMessages[errorCode];
                const length = Buffer.byteLength(message);
                socket.write("HTTP/1.1 400 Bad Request\r\nConnection: close\r\nContent-type: text/html\r\nContent-Length: " + length + "\r\n\r\n" + message);
            }
            socket.destroy();
        }
        const validHdrChars = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ];
        function checkInvalidHeaderChar(val) {
            val += "";
            if (val.length < 1) return false;
            if (!validHdrChars[val.charCodeAt(0)]) {
                debug('invalid header, index 0, char "%s"', val.charCodeAt(0));
                return true;
            }
            if (val.length < 2) return false;
            if (!validHdrChars[val.charCodeAt(1)]) {
                debug('invalid header, index 1, char "%s"', val.charCodeAt(1));
                return true;
            }
            if (val.length < 3) return false;
            if (!validHdrChars[val.charCodeAt(2)]) {
                debug('invalid header, index 2, char "%s"', val.charCodeAt(2));
                return true;
            }
            if (val.length < 4) return false;
            if (!validHdrChars[val.charCodeAt(3)]) {
                debug('invalid header, index 3, char "%s"', val.charCodeAt(3));
                return true;
            }
            for(let i = 4; i < val.length; ++i)if (!validHdrChars[val.charCodeAt(i)]) {
                debug('invalid header, index "%i", char "%s"', i, val.charCodeAt(i));
                return true;
            }
            return false;
        }
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/socket.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Socket = void 0;
        const events_1 = __webpack_require__("events");
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const timers_1 = __webpack_require__("timers");
        const debug = (0, debug_1.default)("engine:socket");
        class Socket extends events_1.EventEmitter {
            get readyState() {
                return this._readyState;
            }
            set readyState(state) {
                debug("readyState updated from %s to %s", this._readyState, state);
                this._readyState = state;
            }
            constructor(id, server, transport, req, protocol){
                super();
                this._readyState = "opening";
                this.upgrading = false;
                this.upgraded = false;
                this.writeBuffer = [];
                this.packetsFn = [];
                this.sentCallbackFn = [];
                this.cleanupFn = [];
                this.id = id;
                this.server = server;
                this.request = req;
                this.protocol = protocol;
                if (req) if (req.websocket && req.websocket._socket) this.remoteAddress = req.websocket._socket.remoteAddress;
                else this.remoteAddress = req.connection.remoteAddress;
                this.pingTimeoutTimer = null;
                this.pingIntervalTimer = null;
                this.setTransport(transport);
                this.onOpen();
            }
            onOpen() {
                this.readyState = "open";
                this.transport.sid = this.id;
                this.sendPacket("open", JSON.stringify({
                    sid: this.id,
                    upgrades: this.getAvailableUpgrades(),
                    pingInterval: this.server.opts.pingInterval,
                    pingTimeout: this.server.opts.pingTimeout,
                    maxPayload: this.server.opts.maxHttpBufferSize
                }));
                if (this.server.opts.initialPacket) this.sendPacket("message", this.server.opts.initialPacket);
                this.emit("open");
                if (3 === this.protocol) this.resetPingTimeout();
                else this.schedulePing();
            }
            onPacket(packet) {
                if ("open" !== this.readyState) return debug("packet received with closed socket");
                debug(`received packet ${packet.type}`);
                this.emit("packet", packet);
                switch(packet.type){
                    case "ping":
                        if (3 !== this.transport.protocol) return void this.onError(new Error("invalid heartbeat direction"));
                        debug("got ping");
                        this.pingTimeoutTimer.refresh();
                        this.sendPacket("pong");
                        this.emit("heartbeat");
                        break;
                    case "pong":
                        if (3 === this.transport.protocol) return void this.onError(new Error("invalid heartbeat direction"));
                        debug("got pong");
                        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
                        this.pingIntervalTimer.refresh();
                        this.emit("heartbeat");
                        break;
                    case "error":
                        this.onClose("parse error");
                        break;
                    case "message":
                        this.emit("data", packet.data);
                        this.emit("message", packet.data);
                        break;
                }
            }
            onError(err) {
                debug("transport error");
                this.onClose("transport error", err);
            }
            schedulePing() {
                this.pingIntervalTimer = (0, timers_1.setTimeout)(()=>{
                    debug("writing ping packet - expecting pong within %sms", this.server.opts.pingTimeout);
                    this.sendPacket("ping");
                    this.resetPingTimeout();
                }, this.server.opts.pingInterval);
            }
            resetPingTimeout() {
                (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
                this.pingTimeoutTimer = (0, timers_1.setTimeout)(()=>{
                    if ("closed" === this.readyState) return;
                    this.onClose("ping timeout");
                }, 3 === this.protocol ? this.server.opts.pingInterval + this.server.opts.pingTimeout : this.server.opts.pingTimeout);
            }
            setTransport(transport) {
                const onError = this.onError.bind(this);
                const onReady = ()=>this.flush();
                const onPacket = this.onPacket.bind(this);
                const onDrain = this.onDrain.bind(this);
                const onClose = this.onClose.bind(this, "transport close");
                this.transport = transport;
                this.transport.once("error", onError);
                this.transport.on("ready", onReady);
                this.transport.on("packet", onPacket);
                this.transport.on("drain", onDrain);
                this.transport.once("close", onClose);
                this.cleanupFn.push(function() {
                    transport.removeListener("error", onError);
                    transport.removeListener("ready", onReady);
                    transport.removeListener("packet", onPacket);
                    transport.removeListener("drain", onDrain);
                    transport.removeListener("close", onClose);
                });
            }
            onDrain() {
                if (this.sentCallbackFn.length > 0) {
                    debug("executing batch send callback");
                    const seqFn = this.sentCallbackFn.shift();
                    if (seqFn) for(let i = 0; i < seqFn.length; i++)seqFn[i](this.transport);
                }
            }
            _maybeUpgrade(transport) {
                debug('might upgrade socket transport from "%s" to "%s"', this.transport.name, transport.name);
                this.upgrading = true;
                const upgradeTimeoutTimer = (0, timers_1.setTimeout)(()=>{
                    debug("client did not complete upgrade - closing transport");
                    cleanup();
                    if ("open" === transport.readyState) transport.close();
                }, this.server.opts.upgradeTimeout);
                let checkIntervalTimer;
                const onPacket = (packet)=>{
                    if ("ping" === packet.type && "probe" === packet.data) {
                        debug("got probe ping packet, sending pong");
                        transport.send([
                            {
                                type: "pong",
                                data: "probe"
                            }
                        ]);
                        this.emit("upgrading", transport);
                        clearInterval(checkIntervalTimer);
                        checkIntervalTimer = setInterval(check, 100);
                    } else if ("upgrade" === packet.type && "closed" !== this.readyState) {
                        debug("got upgrade packet - upgrading");
                        cleanup();
                        this.transport.discard();
                        this.upgraded = true;
                        this.clearTransport();
                        this.setTransport(transport);
                        this.emit("upgrade", transport);
                        this.flush();
                        if ("closing" === this.readyState) transport.close(()=>{
                            this.onClose("forced close");
                        });
                    } else {
                        cleanup();
                        transport.close();
                    }
                };
                const check = ()=>{
                    if ("polling" === this.transport.name && this.transport.writable) {
                        debug("writing a noop packet to polling for fast upgrade");
                        this.transport.send([
                            {
                                type: "noop"
                            }
                        ]);
                    }
                };
                const cleanup = ()=>{
                    this.upgrading = false;
                    clearInterval(checkIntervalTimer);
                    (0, timers_1.clearTimeout)(upgradeTimeoutTimer);
                    transport.removeListener("packet", onPacket);
                    transport.removeListener("close", onTransportClose);
                    transport.removeListener("error", onError);
                    this.removeListener("close", onClose);
                };
                const onError = (err)=>{
                    debug("client did not complete upgrade - %s", err);
                    cleanup();
                    transport.close();
                    transport = null;
                };
                const onTransportClose = ()=>{
                    onError("transport closed");
                };
                const onClose = ()=>{
                    onError("socket closed");
                };
                transport.on("packet", onPacket);
                transport.once("close", onTransportClose);
                transport.once("error", onError);
                this.once("close", onClose);
            }
            clearTransport() {
                let cleanup;
                const toCleanUp = this.cleanupFn.length;
                for(let i = 0; i < toCleanUp; i++){
                    cleanup = this.cleanupFn.shift();
                    cleanup();
                }
                this.transport.on("error", function() {
                    debug("error triggered by discarded transport");
                });
                this.transport.close();
                (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
            }
            onClose(reason, description) {
                if ("closed" !== this.readyState) {
                    this.readyState = "closed";
                    (0, timers_1.clearTimeout)(this.pingIntervalTimer);
                    (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
                    process.nextTick(()=>{
                        this.writeBuffer = [];
                    });
                    this.packetsFn = [];
                    this.sentCallbackFn = [];
                    this.clearTransport();
                    this.emit("close", reason, description);
                }
            }
            send(data, options, callback) {
                this.sendPacket("message", data, options, callback);
                return this;
            }
            write(data, options, callback) {
                this.sendPacket("message", data, options, callback);
                return this;
            }
            sendPacket(type, data, options = {}, callback) {
                if ("function" == typeof options) {
                    callback = options;
                    options = {};
                }
                if ("closing" !== this.readyState && "closed" !== this.readyState) {
                    debug('sending packet "%s" (%s)', type, data);
                    options.compress = false !== options.compress;
                    const packet = {
                        type,
                        options: options
                    };
                    if (data) packet.data = data;
                    this.emit("packetCreate", packet);
                    this.writeBuffer.push(packet);
                    if ("function" == typeof callback) this.packetsFn.push(callback);
                    this.flush();
                }
            }
            flush() {
                if ("closed" !== this.readyState && this.transport.writable && this.writeBuffer.length) {
                    debug("flushing buffer to transport");
                    this.emit("flush", this.writeBuffer);
                    this.server.emit("flush", this, this.writeBuffer);
                    const wbuf = this.writeBuffer;
                    this.writeBuffer = [];
                    if (this.packetsFn.length) {
                        this.sentCallbackFn.push(this.packetsFn);
                        this.packetsFn = [];
                    } else this.sentCallbackFn.push(null);
                    this.transport.send(wbuf);
                    this.emit("drain");
                    this.server.emit("drain", this);
                }
            }
            getAvailableUpgrades() {
                const availableUpgrades = [];
                const allUpgrades = this.server.upgrades(this.transport.name);
                for(let i = 0; i < allUpgrades.length; ++i){
                    const upg = allUpgrades[i];
                    if (-1 !== this.server.opts.transports.indexOf(upg)) availableUpgrades.push(upg);
                }
                return availableUpgrades;
            }
            close(discard) {
                if (discard && ("open" === this.readyState || "closing" === this.readyState)) return this.closeTransport(discard);
                if ("open" !== this.readyState) return;
                this.readyState = "closing";
                if (this.writeBuffer.length) {
                    debug("there are %d remaining packets in the buffer, waiting for the 'drain' event", this.writeBuffer.length);
                    this.once("drain", ()=>{
                        debug("all packets have been sent, closing the transport");
                        this.closeTransport(discard);
                    });
                    return;
                }
                debug("the buffer is empty, closing the transport right away");
                this.closeTransport(discard);
            }
            closeTransport(discard) {
                debug("closing the transport (discard? %s)", !!discard);
                if (discard) this.transport.discard();
                this.transport.close(this.onClose.bind(this, "forced close"));
            }
        }
        exports1.Socket = Socket;
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transport.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Transport = void 0;
        const events_1 = __webpack_require__("events");
        const parser_v4 = __webpack_require__("../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/index.js");
        const parser_v3 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/parser-v3/index.js");
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const debug = (0, debug_1.default)("engine:transport");
        function noop() {}
        class Transport extends events_1.EventEmitter {
            get readyState() {
                return this._readyState;
            }
            set readyState(state) {
                debug("readyState updated from %s to %s (%s)", this._readyState, state, this.name);
                this._readyState = state;
            }
            constructor(req){
                super();
                this.writable = false;
                this._readyState = "open";
                this.discarded = false;
                this.protocol = "4" === req._query.EIO ? 4 : 3;
                this.parser = 4 === this.protocol ? parser_v4 : parser_v3;
                this.supportsBinary = !(req._query && req._query.b64);
            }
            discard() {
                this.discarded = true;
            }
            onRequest(req) {}
            close(fn) {
                if ("closed" === this.readyState || "closing" === this.readyState) return;
                this.readyState = "closing";
                this.doClose(fn || noop);
            }
            onError(msg, desc) {
                if (this.listeners("error").length) {
                    const err = new Error(msg);
                    err.type = "TransportError";
                    err.description = desc;
                    this.emit("error", err);
                } else debug("ignored transport error %s (%s)", msg, desc);
            }
            onPacket(packet) {
                this.emit("packet", packet);
            }
            onData(data) {
                this.onPacket(this.parser.decodePacket(data));
            }
            onClose() {
                this.readyState = "closed";
                this.emit("close");
            }
        }
        exports1.Transport = Transport;
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports-uws/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const polling_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports-uws/polling.js");
        const websocket_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports-uws/websocket.js");
        exports1["default"] = {
            polling: polling_1.Polling,
            websocket: websocket_1.WebSocket
        };
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports-uws/polling.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Polling = void 0;
        const transport_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transport.js");
        const zlib_1 = __webpack_require__("zlib");
        const accepts = __webpack_require__("../node_modules/.pnpm/accepts@1.3.8/node_modules/accepts/index.js");
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const debug = (0, debug_1.default)("engine:polling");
        const compressionMethods = {
            gzip: zlib_1.createGzip,
            deflate: zlib_1.createDeflate
        };
        class Polling extends transport_1.Transport {
            constructor(req){
                super(req);
                this.closeTimeout = 30000;
            }
            get name() {
                return "polling";
            }
            onRequest(req) {
                const res = req.res;
                req.res = null;
                if ("get" === req.getMethod()) this.onPollRequest(req, res);
                else if ("post" === req.getMethod()) this.onDataRequest(req, res);
                else {
                    res.writeStatus("500 Internal Server Error");
                    res.end();
                }
            }
            onPollRequest(req, res) {
                if (this.req) {
                    debug("request overlap");
                    this.onError("overlap from client");
                    res.writeStatus("500 Internal Server Error");
                    res.end();
                    return;
                }
                debug("setting request");
                this.req = req;
                this.res = res;
                const onClose = ()=>{
                    this.writable = false;
                    this.onError("poll connection closed prematurely");
                };
                const cleanup = ()=>{
                    this.req = this.res = null;
                };
                req.cleanup = cleanup;
                res.onAborted(onClose);
                this.writable = true;
                this.emit("ready");
                if (this.writable && this.shouldClose) {
                    debug("triggering empty send to append close packet");
                    this.send([
                        {
                            type: "noop"
                        }
                    ]);
                }
            }
            onDataRequest(req, res) {
                if (this.dataReq) {
                    this.onError("data request overlap from client");
                    res.writeStatus("500 Internal Server Error");
                    res.end();
                    return;
                }
                const expectedContentLength = Number(req.headers["content-length"]);
                if (!expectedContentLength) {
                    this.onError("content-length header required");
                    res.writeStatus("411 Length Required").end();
                    return;
                }
                if (expectedContentLength > this.maxHttpBufferSize) {
                    this.onError("payload too large");
                    res.writeStatus("413 Payload Too Large").end();
                    return;
                }
                const isBinary = "application/octet-stream" === req.headers["content-type"];
                if (isBinary && 4 === this.protocol) return this.onError("invalid content");
                this.dataReq = req;
                this.dataRes = res;
                let buffer;
                let offset = 0;
                const headers = {
                    "Content-Type": "text/html"
                };
                this.headers(req, headers);
                for(let key in headers)res.writeHeader(key, String(headers[key]));
                const onEnd = (buffer)=>{
                    this.onData(buffer.toString());
                    this.onDataRequestCleanup();
                    res.cork(()=>{
                        res.end("ok");
                    });
                };
                res.onAborted(()=>{
                    this.onDataRequestCleanup();
                    this.onError("data request connection closed prematurely");
                });
                res.onData((arrayBuffer, isLast)=>{
                    const totalLength = offset + arrayBuffer.byteLength;
                    if (totalLength > expectedContentLength) {
                        this.onError("content-length mismatch");
                        res.close();
                        return;
                    }
                    if (!buffer) {
                        if (isLast) return void onEnd(Buffer.from(arrayBuffer));
                        buffer = Buffer.allocUnsafe(expectedContentLength);
                    }
                    Buffer.from(arrayBuffer).copy(buffer, offset);
                    if (isLast) {
                        if (totalLength != expectedContentLength) {
                            this.onError("content-length mismatch");
                            res.writeStatus("400 Content-Length Mismatch").end();
                            this.onDataRequestCleanup();
                            return;
                        }
                        onEnd(buffer);
                        return;
                    }
                    offset = totalLength;
                });
            }
            onDataRequestCleanup() {
                this.dataReq = this.dataRes = null;
            }
            onData(data) {
                debug('received "%s"', data);
                const callback = (packet)=>{
                    if ("close" === packet.type) {
                        debug("got xhr close packet");
                        this.onClose();
                        return false;
                    }
                    this.onPacket(packet);
                };
                if (3 === this.protocol) this.parser.decodePayload(data, callback);
                else this.parser.decodePayload(data).forEach(callback);
            }
            onClose() {
                if (this.writable) this.send([
                    {
                        type: "noop"
                    }
                ]);
                super.onClose();
            }
            send(packets) {
                this.writable = false;
                if (this.shouldClose) {
                    debug("appending close packet to payload");
                    packets.push({
                        type: "close"
                    });
                    this.shouldClose();
                    this.shouldClose = null;
                }
                const doWrite = (data)=>{
                    const compress = packets.some((packet)=>packet.options && packet.options.compress);
                    this.write(data, {
                        compress
                    });
                };
                if (3 === this.protocol) this.parser.encodePayload(packets, this.supportsBinary, doWrite);
                else this.parser.encodePayload(packets, doWrite);
            }
            write(data, options) {
                debug('writing "%s"', data);
                this.doWrite(data, options, ()=>{
                    this.req.cleanup();
                    this.emit("drain");
                });
            }
            doWrite(data, options, callback) {
                const isString = "string" == typeof data;
                const contentType = isString ? "text/plain; charset=UTF-8" : "application/octet-stream";
                const headers = {
                    "Content-Type": contentType
                };
                const respond = (data)=>{
                    this.headers(this.req, headers);
                    this.res.cork(()=>{
                        Object.keys(headers).forEach((key)=>{
                            this.res.writeHeader(key, String(headers[key]));
                        });
                        this.res.end(data);
                    });
                    callback();
                };
                if (!this.httpCompression || !options.compress) return void respond(data);
                const len = isString ? Buffer.byteLength(data) : data.length;
                if (len < this.httpCompression.threshold) return void respond(data);
                const encoding = accepts(this.req).encodings([
                    "gzip",
                    "deflate"
                ]);
                if (!encoding) return void respond(data);
                this.compress(data, encoding, (err, data)=>{
                    if (err) {
                        this.res.writeStatus("500 Internal Server Error");
                        this.res.end();
                        callback(err);
                        return;
                    }
                    headers["Content-Encoding"] = encoding;
                    respond(data);
                });
            }
            compress(data, encoding, callback) {
                debug("compressing");
                const buffers = [];
                let nread = 0;
                compressionMethods[encoding](this.httpCompression).on("error", callback).on("data", function(chunk) {
                    buffers.push(chunk);
                    nread += chunk.length;
                }).on("end", function() {
                    callback(null, Buffer.concat(buffers, nread));
                }).end(data);
            }
            doClose(fn) {
                debug("closing");
                let closeTimeoutTimer;
                const onClose = ()=>{
                    clearTimeout(closeTimeoutTimer);
                    fn();
                    this.onClose();
                };
                if (this.writable) {
                    debug("transport writable - closing right away");
                    this.send([
                        {
                            type: "close"
                        }
                    ]);
                    onClose();
                } else if (this.discarded) {
                    debug("transport discarded - closing right away");
                    onClose();
                } else {
                    debug("transport not writable - buffering orderly close");
                    this.shouldClose = onClose;
                    closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
                }
            }
            headers(req, headers) {
                headers = headers || {};
                const ua = req.headers["user-agent"];
                if (ua && (~ua.indexOf(";MSIE") || ~ua.indexOf("Trident/"))) headers["X-XSS-Protection"] = "0";
                headers["cache-control"] = "no-store";
                this.emit("headers", headers, req);
                return headers;
            }
        }
        exports1.Polling = Polling;
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports-uws/websocket.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.WebSocket = void 0;
        const transport_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transport.js");
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const debug = (0, debug_1.default)("engine:ws");
        class WebSocket extends transport_1.Transport {
            constructor(req){
                super(req);
                this.writable = false;
                this.perMessageDeflate = null;
            }
            get name() {
                return "websocket";
            }
            get handlesUpgrades() {
                return true;
            }
            send(packets) {
                this.writable = false;
                for(let i = 0; i < packets.length; i++){
                    const packet = packets[i];
                    const isLast = i + 1 === packets.length;
                    const send = (data)=>{
                        const isBinary = "string" != typeof data;
                        const compress = this.perMessageDeflate && Buffer.byteLength(data) > this.perMessageDeflate.threshold;
                        debug('writing "%s"', data);
                        this.socket.send(data, isBinary, compress);
                        if (isLast) {
                            this.emit("drain");
                            this.writable = true;
                            this.emit("ready");
                        }
                    };
                    if (packet.options && "string" == typeof packet.options.wsPreEncoded) send(packet.options.wsPreEncoded);
                    else this.parser.encodePacket(packet, this.supportsBinary, send);
                }
            }
            doClose(fn) {
                debug("closing");
                fn && fn();
                this.socket.end();
            }
        }
        exports1.WebSocket = WebSocket;
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const polling_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/polling.js");
        const polling_jsonp_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/polling-jsonp.js");
        const websocket_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/websocket.js");
        const webtransport_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/webtransport.js");
        exports1["default"] = {
            polling: polling,
            websocket: websocket_1.WebSocket,
            webtransport: webtransport_1.WebTransport
        };
        function polling(req) {
            if ("string" == typeof req._query.j) return new polling_jsonp_1.JSONP(req);
            return new polling_1.Polling(req);
        }
        polling.upgradesTo = [
            "websocket",
            "webtransport"
        ];
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/polling-jsonp.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.JSONP = void 0;
        const polling_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/polling.js");
        const qs = __webpack_require__("querystring");
        const rDoubleSlashes = /\\\\n/g;
        const rSlashes = /(\\)?\\n/g;
        class JSONP extends polling_1.Polling {
            constructor(req){
                super(req);
                this.head = "___eio[" + (req._query.j || "").replace(/[^0-9]/g, "") + "](";
                this.foot = ");";
            }
            onData(data) {
                data = qs.parse(data).d;
                if ("string" == typeof data) {
                    data = data.replace(rSlashes, function(match, slashes) {
                        return slashes ? match : "\n";
                    });
                    super.onData(data.replace(rDoubleSlashes, "\\n"));
                }
            }
            doWrite(data, options, callback) {
                const js = JSON.stringify(data).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
                data = this.head + js + this.foot;
                super.doWrite(data, options, callback);
            }
        }
        exports1.JSONP = JSONP;
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/polling.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Polling = void 0;
        const transport_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transport.js");
        const zlib_1 = __webpack_require__("zlib");
        const accepts = __webpack_require__("../node_modules/.pnpm/accepts@1.3.8/node_modules/accepts/index.js");
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const debug = (0, debug_1.default)("engine:polling");
        const compressionMethods = {
            gzip: zlib_1.createGzip,
            deflate: zlib_1.createDeflate
        };
        class Polling extends transport_1.Transport {
            constructor(req){
                super(req);
                this.closeTimeout = 30000;
            }
            get name() {
                return "polling";
            }
            onRequest(req) {
                const res = req.res;
                req.res = null;
                if ("GET" === req.method) this.onPollRequest(req, res);
                else if ("POST" === req.method) this.onDataRequest(req, res);
                else {
                    res.writeHead(500);
                    res.end();
                }
            }
            onPollRequest(req, res) {
                if (this.req) {
                    debug("request overlap");
                    this.onError("overlap from client");
                    res.writeHead(400);
                    res.end();
                    return;
                }
                debug("setting request");
                this.req = req;
                this.res = res;
                const onClose = ()=>{
                    this.onError("poll connection closed prematurely");
                };
                const cleanup = ()=>{
                    req.removeListener("close", onClose);
                    this.req = this.res = null;
                };
                req.cleanup = cleanup;
                req.on("close", onClose);
                this.writable = true;
                this.emit("ready");
                if (this.writable && this.shouldClose) {
                    debug("triggering empty send to append close packet");
                    this.send([
                        {
                            type: "noop"
                        }
                    ]);
                }
            }
            onDataRequest(req, res) {
                if (this.dataReq) {
                    this.onError("data request overlap from client");
                    res.writeHead(400);
                    res.end();
                    return;
                }
                const isBinary = "application/octet-stream" === req.headers["content-type"];
                if (isBinary && 4 === this.protocol) return this.onError("invalid content");
                this.dataReq = req;
                this.dataRes = res;
                let chunks = isBinary ? Buffer.concat([]) : "";
                const cleanup = ()=>{
                    req.removeListener("data", onData);
                    req.removeListener("end", onEnd);
                    req.removeListener("close", onClose);
                    this.dataReq = this.dataRes = chunks = null;
                };
                const onClose = ()=>{
                    cleanup();
                    this.onError("data request connection closed prematurely");
                };
                const onData = (data)=>{
                    let contentLength;
                    if (isBinary) {
                        chunks = Buffer.concat([
                            chunks,
                            data
                        ]);
                        contentLength = chunks.length;
                    } else {
                        chunks += data;
                        contentLength = Buffer.byteLength(chunks);
                    }
                    if (contentLength > this.maxHttpBufferSize) {
                        res.writeHead(413).end();
                        cleanup();
                    }
                };
                const onEnd = ()=>{
                    this.onData(chunks);
                    const headers = {
                        "Content-Type": "text/html",
                        "Content-Length": "2"
                    };
                    res.writeHead(200, this.headers(req, headers));
                    res.end("ok");
                    cleanup();
                };
                req.on("close", onClose);
                if (!isBinary) req.setEncoding("utf8");
                req.on("data", onData);
                req.on("end", onEnd);
            }
            onData(data) {
                debug('received "%s"', data);
                const callback = (packet)=>{
                    if ("close" === packet.type) {
                        debug("got xhr close packet");
                        this.onClose();
                        return false;
                    }
                    this.onPacket(packet);
                };
                if (3 === this.protocol) this.parser.decodePayload(data, callback);
                else this.parser.decodePayload(data).forEach(callback);
            }
            onClose() {
                if (this.writable) this.send([
                    {
                        type: "noop"
                    }
                ]);
                super.onClose();
            }
            send(packets) {
                this.writable = false;
                if (this.shouldClose) {
                    debug("appending close packet to payload");
                    packets.push({
                        type: "close"
                    });
                    this.shouldClose();
                    this.shouldClose = null;
                }
                const doWrite = (data)=>{
                    const compress = packets.some((packet)=>packet.options && packet.options.compress);
                    this.write(data, {
                        compress
                    });
                };
                if (3 === this.protocol) this.parser.encodePayload(packets, this.supportsBinary, doWrite);
                else this.parser.encodePayload(packets, doWrite);
            }
            write(data, options) {
                debug('writing "%s"', data);
                this.doWrite(data, options, ()=>{
                    this.req.cleanup();
                    this.emit("drain");
                });
            }
            doWrite(data, options, callback) {
                const isString = "string" == typeof data;
                const contentType = isString ? "text/plain; charset=UTF-8" : "application/octet-stream";
                const headers = {
                    "Content-Type": contentType
                };
                const respond = (data)=>{
                    headers["Content-Length"] = "string" == typeof data ? Buffer.byteLength(data) : data.length;
                    this.res.writeHead(200, this.headers(this.req, headers));
                    this.res.end(data);
                    callback();
                };
                if (!this.httpCompression || !options.compress) return void respond(data);
                const len = isString ? Buffer.byteLength(data) : data.length;
                if (len < this.httpCompression.threshold) return void respond(data);
                const encoding = accepts(this.req).encodings([
                    "gzip",
                    "deflate"
                ]);
                if (!encoding) return void respond(data);
                this.compress(data, encoding, (err, data)=>{
                    if (err) {
                        this.res.writeHead(500);
                        this.res.end();
                        callback(err);
                        return;
                    }
                    headers["Content-Encoding"] = encoding;
                    respond(data);
                });
            }
            compress(data, encoding, callback) {
                debug("compressing");
                const buffers = [];
                let nread = 0;
                compressionMethods[encoding](this.httpCompression).on("error", callback).on("data", function(chunk) {
                    buffers.push(chunk);
                    nread += chunk.length;
                }).on("end", function() {
                    callback(null, Buffer.concat(buffers, nread));
                }).end(data);
            }
            doClose(fn) {
                debug("closing");
                let closeTimeoutTimer;
                if (this.dataReq) {
                    debug("aborting ongoing data request");
                    this.dataReq.destroy();
                }
                const onClose = ()=>{
                    clearTimeout(closeTimeoutTimer);
                    fn();
                    this.onClose();
                };
                if (this.writable) {
                    debug("transport writable - closing right away");
                    this.send([
                        {
                            type: "close"
                        }
                    ]);
                    onClose();
                } else if (this.discarded) {
                    debug("transport discarded - closing right away");
                    onClose();
                } else {
                    debug("transport not writable - buffering orderly close");
                    this.shouldClose = onClose;
                    closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
                }
            }
            headers(req, headers = {}) {
                const ua = req.headers["user-agent"];
                if (ua && (~ua.indexOf(";MSIE") || ~ua.indexOf("Trident/"))) headers["X-XSS-Protection"] = "0";
                headers["cache-control"] = "no-store";
                this.emit("headers", headers, req);
                return headers;
            }
        }
        exports1.Polling = Polling;
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/websocket.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.WebSocket = void 0;
        const transport_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transport.js");
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const debug = (0, debug_1.default)("engine:ws");
        class WebSocket extends transport_1.Transport {
            constructor(req){
                super(req);
                this._doSend = (data)=>{
                    this.socket.send(data, this._onSent);
                };
                this._doSendLast = (data)=>{
                    this.socket.send(data, this._onSentLast);
                };
                this._onSent = (err)=>{
                    if (err) this.onError("write error", err.stack);
                };
                this._onSentLast = (err)=>{
                    if (err) this.onError("write error", err.stack);
                    else {
                        this.emit("drain");
                        this.writable = true;
                        this.emit("ready");
                    }
                };
                this.socket = req.websocket;
                this.socket.on("message", (data, isBinary)=>{
                    const message = isBinary ? data : data.toString();
                    debug('received "%s"', message);
                    super.onData(message);
                });
                this.socket.once("close", this.onClose.bind(this));
                this.socket.on("error", this.onError.bind(this));
                this.writable = true;
                this.perMessageDeflate = null;
            }
            get name() {
                return "websocket";
            }
            get handlesUpgrades() {
                return true;
            }
            send(packets) {
                this.writable = false;
                for(let i = 0; i < packets.length; i++){
                    const packet = packets[i];
                    const isLast = i + 1 === packets.length;
                    if (this._canSendPreEncodedFrame(packet)) this.socket._sender.sendFrame(packet.options.wsPreEncodedFrame, isLast ? this._onSentLast : this._onSent);
                    else this.parser.encodePacket(packet, this.supportsBinary, isLast ? this._doSendLast : this._doSend);
                }
            }
            _canSendPreEncodedFrame(packet) {
                var _a, _b, _c;
                return !this.perMessageDeflate && "function" == typeof (null == (_b = null == (_a = this.socket) ? void 0 : _a._sender) ? void 0 : _b.sendFrame) && (null == (_c = packet.options) ? void 0 : _c.wsPreEncodedFrame) !== void 0;
            }
            doClose(fn) {
                debug("closing");
                this.socket.close();
                fn && fn();
            }
        }
        exports1.WebSocket = WebSocket;
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/webtransport.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.WebTransport = void 0;
        const transport_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transport.js");
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const engine_io_parser_1 = __webpack_require__("../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/index.js");
        const debug = (0, debug_1.default)("engine:webtransport");
        class WebTransport extends transport_1.Transport {
            constructor(session, stream, reader){
                super({
                    _query: {
                        EIO: "4"
                    }
                });
                this.session = session;
                const transformStream = (0, engine_io_parser_1.createPacketEncoderStream)();
                transformStream.readable.pipeTo(stream.writable).catch(()=>{
                    debug("the stream was closed");
                });
                this.writer = transformStream.writable.getWriter();
                (async ()=>{
                    try {
                        while(true){
                            const { value, done } = await reader.read();
                            if (done) {
                                debug("session is closed");
                                break;
                            }
                            debug("received chunk: %o", value);
                            this.onPacket(value);
                        }
                    } catch (e) {
                        debug("error while reading: %s", e.message);
                    }
                })();
                session.closed.then(()=>this.onClose());
                this.writable = true;
            }
            get name() {
                return "webtransport";
            }
            async send(packets) {
                this.writable = false;
                try {
                    for(let i = 0; i < packets.length; i++){
                        const packet = packets[i];
                        await this.writer.write(packet);
                    }
                } catch (e) {
                    debug("error while writing: %s", e.message);
                }
                this.emit("drain");
                this.writable = true;
                this.emit("ready");
            }
            doClose(fn) {
                debug("closing WebTransport session");
                this.session.close();
                fn && fn();
            }
        }
        exports1.WebTransport = WebTransport;
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/userver.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.uServer = void 0;
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const server_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/server.js");
        const transports_uws_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports-uws/index.js");
        const debug = (0, debug_1.default)("engine:uws");
        class uServer extends server_1.BaseServer {
            init() {}
            cleanup() {}
            prepare(req, res) {
                req.method = req.getMethod().toUpperCase();
                req.url = req.getUrl();
                const params = new URLSearchParams(req.getQuery());
                req._query = Object.fromEntries(params.entries());
                req.headers = {};
                req.forEach((key, value)=>{
                    req.headers[key] = value;
                });
                req.connection = {
                    remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString()
                };
                res.onAborted(()=>{
                    debug("response has been aborted");
                });
            }
            createTransport(transportName, req) {
                return new transports_uws_1.default[transportName](req);
            }
            attach(app, options = {}) {
                const path = this._computePath(options);
                app.any(path, this.handleRequest.bind(this)).ws(path, {
                    compression: options.compression,
                    idleTimeout: options.idleTimeout,
                    maxBackpressure: options.maxBackpressure,
                    maxPayloadLength: this.opts.maxHttpBufferSize,
                    upgrade: this.handleUpgrade.bind(this),
                    open: (ws)=>{
                        const transport = ws.getUserData().transport;
                        transport.socket = ws;
                        transport.writable = true;
                        transport.emit("ready");
                    },
                    message: (ws, message, isBinary)=>{
                        ws.getUserData().transport.onData(isBinary ? message : Buffer.from(message).toString());
                    },
                    close: (ws, code, message)=>{
                        ws.getUserData().transport.onClose(code, message);
                    }
                });
            }
            _applyMiddlewares(req, res, callback) {
                if (0 === this.middlewares.length) return callback();
                req.res = new ResponseWrapper(res);
                super._applyMiddlewares(req, req.res, (err)=>{
                    req.res.writeHead();
                    callback(err);
                });
            }
            handleRequest(res, req) {
                debug('handling "%s" http request "%s"', req.getMethod(), req.getUrl());
                this.prepare(req, res);
                req.res = res;
                const callback = (errorCode, errorContext)=>{
                    if (void 0 !== errorCode) {
                        this.emit("connection_error", {
                            req,
                            code: errorCode,
                            message: server_1.Server.errorMessages[errorCode],
                            context: errorContext
                        });
                        this.abortRequest(req.res, errorCode, errorContext);
                        return;
                    }
                    if (req._query.sid) {
                        debug("setting new request for existing client");
                        this.clients[req._query.sid].transport.onRequest(req);
                    } else {
                        const closeConnection = (errorCode, errorContext)=>this.abortRequest(res, errorCode, errorContext);
                        this.handshake(req._query.transport, req, closeConnection);
                    }
                };
                this._applyMiddlewares(req, res, (err)=>{
                    if (err) callback(server_1.Server.errors.BAD_REQUEST, {
                        name: "MIDDLEWARE_FAILURE"
                    });
                    else this.verify(req, false, callback);
                });
            }
            handleUpgrade(res, req, context) {
                debug("on upgrade");
                this.prepare(req, res);
                req.res = res;
                const callback = async (errorCode, errorContext)=>{
                    if (void 0 !== errorCode) {
                        this.emit("connection_error", {
                            req,
                            code: errorCode,
                            message: server_1.Server.errorMessages[errorCode],
                            context: errorContext
                        });
                        this.abortRequest(res, errorCode, errorContext);
                        return;
                    }
                    const id = req._query.sid;
                    let transport;
                    if (id) {
                        const client = this.clients[id];
                        if (client) if (client.upgrading) {
                            debug("transport has already been trying to upgrade");
                            return res.close();
                        } else if (client.upgraded) {
                            debug("transport had already been upgraded");
                            return res.close();
                        } else {
                            debug("upgrading existing transport");
                            transport = this.createTransport(req._query.transport, req);
                            client._maybeUpgrade(transport);
                        }
                        else {
                            debug("upgrade attempt for closed client");
                            return res.close();
                        }
                    } else {
                        transport = await this.handshake(req._query.transport, req, (errorCode, errorContext)=>this.abortRequest(res, errorCode, errorContext));
                        if (!transport) return;
                    }
                    req.res.writeStatus("101 Switching Protocols");
                    res.upgrade({
                        transport
                    }, req.getHeader("sec-websocket-key"), req.getHeader("sec-websocket-protocol"), req.getHeader("sec-websocket-extensions"), context);
                };
                this._applyMiddlewares(req, res, (err)=>{
                    if (err) callback(server_1.Server.errors.BAD_REQUEST, {
                        name: "MIDDLEWARE_FAILURE"
                    });
                    else this.verify(req, true, callback);
                });
            }
            abortRequest(res, errorCode, errorContext) {
                const statusCode = errorCode === server_1.Server.errors.FORBIDDEN ? "403 Forbidden" : "400 Bad Request";
                const message = errorContext && errorContext.message ? errorContext.message : server_1.Server.errorMessages[errorCode];
                res.writeStatus(statusCode);
                res.writeHeader("Content-Type", "application/json");
                res.end(JSON.stringify({
                    code: errorCode,
                    message
                }));
            }
        }
        exports1.uServer = uServer;
        class ResponseWrapper {
            constructor(res){
                this.res = res;
                this.statusWritten = false;
                this.headers = [];
                this.isAborted = false;
            }
            set statusCode(status) {
                if (!status) return;
                this.writeStatus(200 === status ? "200 OK" : "204 No Content");
            }
            writeHead(status) {
                this.statusCode = status;
            }
            setHeader(key, value) {
                if (Array.isArray(value)) value.forEach((val)=>{
                    this.writeHeader(key, val);
                });
                else this.writeHeader(key, value);
            }
            removeHeader() {}
            getHeader() {}
            writeStatus(status) {
                if (this.isAborted) return;
                this.res.writeStatus(status);
                this.statusWritten = true;
                this.writeBufferedHeaders();
                return this;
            }
            writeHeader(key, value) {
                if (this.isAborted) return;
                if ("Content-Length" === key) return;
                if (this.statusWritten) this.res.writeHeader(key, value);
                else this.headers.push([
                    key,
                    value
                ]);
            }
            writeBufferedHeaders() {
                this.headers.forEach(([key, value])=>{
                    this.res.writeHeader(key, value);
                });
            }
            end(data) {
                if (this.isAborted) return;
                this.res.cork(()=>{
                    if (!this.statusWritten) this.writeBufferedHeaders();
                    this.res.end(data);
                });
            }
            onData(fn) {
                if (this.isAborted) return;
                this.res.onData(fn);
            }
            onAborted(fn) {
                if (this.isAborted) return;
                this.res.onAborted(()=>{
                    this.isAborted = true;
                    fn();
                });
            }
            cork(fn) {
                if (this.isAborted) return;
                this.res.cork(fn);
            }
        }
    },
    "../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/cjs/binary.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.reconstructPacket = exports1.deconstructPacket = void 0;
        const is_binary_js_1 = __webpack_require__("../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/cjs/is-binary.js");
        function deconstructPacket(packet) {
            const buffers = [];
            const packetData = packet.data;
            const pack = packet;
            pack.data = _deconstructPacket(packetData, buffers);
            pack.attachments = buffers.length;
            return {
                packet: pack,
                buffers: buffers
            };
        }
        exports1.deconstructPacket = deconstructPacket;
        function _deconstructPacket(data, buffers) {
            if (!data) return data;
            if ((0, is_binary_js_1.isBinary)(data)) {
                const placeholder = {
                    _placeholder: true,
                    num: buffers.length
                };
                buffers.push(data);
                return placeholder;
            }
            if (Array.isArray(data)) {
                const newData = new Array(data.length);
                for(let i = 0; i < data.length; i++)newData[i] = _deconstructPacket(data[i], buffers);
                return newData;
            }
            if ("object" == typeof data && !(data instanceof Date)) {
                const newData = {};
                for(const key in data)if (Object.prototype.hasOwnProperty.call(data, key)) newData[key] = _deconstructPacket(data[key], buffers);
                return newData;
            }
            return data;
        }
        function reconstructPacket(packet, buffers) {
            packet.data = _reconstructPacket(packet.data, buffers);
            delete packet.attachments;
            return packet;
        }
        exports1.reconstructPacket = reconstructPacket;
        function _reconstructPacket(data, buffers) {
            if (!data) return data;
            if (data && true === data._placeholder) {
                const isIndexValid = "number" == typeof data.num && data.num >= 0 && data.num < buffers.length;
                if (isIndexValid) return buffers[data.num];
                throw new Error("illegal attachments");
            }
            if (Array.isArray(data)) for(let i = 0; i < data.length; i++)data[i] = _reconstructPacket(data[i], buffers);
            else if ("object" == typeof data) {
                for(const key in data)if (Object.prototype.hasOwnProperty.call(data, key)) data[key] = _reconstructPacket(data[key], buffers);
            }
            return data;
        }
    },
    "../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/cjs/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Decoder = exports1.Encoder = exports1.PacketType = exports1.protocol = void 0;
        const component_emitter_1 = __webpack_require__("../node_modules/.pnpm/@socket.io+component-emitter@3.1.2/node_modules/@socket.io/component-emitter/lib/esm/index.js");
        const binary_js_1 = __webpack_require__("../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/cjs/binary.js");
        const is_binary_js_1 = __webpack_require__("../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/cjs/is-binary.js");
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const debug = (0, debug_1.default)("socket.io-parser");
        const RESERVED_EVENTS = [
            "connect",
            "connect_error",
            "disconnect",
            "disconnecting",
            "newListener",
            "removeListener"
        ];
        exports1.protocol = 5;
        var PacketType;
        (function(PacketType) {
            PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
            PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
            PacketType[PacketType["EVENT"] = 2] = "EVENT";
            PacketType[PacketType["ACK"] = 3] = "ACK";
            PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
            PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
            PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
        })(PacketType = exports1.PacketType || (exports1.PacketType = {}));
        class Encoder {
            constructor(replacer){
                this.replacer = replacer;
            }
            encode(obj) {
                debug("encoding packet %j", obj);
                if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
                    if ((0, is_binary_js_1.hasBinary)(obj)) return this.encodeAsBinary({
                        type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
                        nsp: obj.nsp,
                        data: obj.data,
                        id: obj.id
                    });
                }
                return [
                    this.encodeAsString(obj)
                ];
            }
            encodeAsString(obj) {
                let str = "" + obj.type;
                if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) str += obj.attachments + "-";
                if (obj.nsp && "/" !== obj.nsp) str += obj.nsp + ",";
                if (null != obj.id) str += obj.id;
                if (null != obj.data) str += JSON.stringify(obj.data, this.replacer);
                debug("encoded %j as %s", obj, str);
                return str;
            }
            encodeAsBinary(obj) {
                const deconstruction = (0, binary_js_1.deconstructPacket)(obj);
                const pack = this.encodeAsString(deconstruction.packet);
                const buffers = deconstruction.buffers;
                buffers.unshift(pack);
                return buffers;
            }
        }
        exports1.Encoder = Encoder;
        function isObject(value) {
            return "[object Object]" === Object.prototype.toString.call(value);
        }
        class Decoder extends component_emitter_1.Emitter {
            constructor(reviver){
                super();
                this.reviver = reviver;
            }
            add(obj) {
                let packet;
                if ("string" == typeof obj) {
                    if (this.reconstructor) throw new Error("got plaintext data when reconstructing a packet");
                    packet = this.decodeString(obj);
                    const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
                    if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
                        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
                        this.reconstructor = new BinaryReconstructor(packet);
                        if (0 === packet.attachments) super.emitReserved("decoded", packet);
                    } else super.emitReserved("decoded", packet);
                } else if ((0, is_binary_js_1.isBinary)(obj) || obj.base64) if (this.reconstructor) {
                    packet = this.reconstructor.takeBinaryData(obj);
                    if (packet) {
                        this.reconstructor = null;
                        super.emitReserved("decoded", packet);
                    }
                } else throw new Error("got binary data when not reconstructing a packet");
                else throw new Error("Unknown type: " + obj);
            }
            decodeString(str) {
                let i = 0;
                const p = {
                    type: Number(str.charAt(0))
                };
                if (void 0 === PacketType[p.type]) throw new Error("unknown packet type " + p.type);
                if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
                    const start = i + 1;
                    while("-" !== str.charAt(++i) && i != str.length);
                    const buf = str.substring(start, i);
                    if (buf != Number(buf) || "-" !== str.charAt(i)) throw new Error("Illegal attachments");
                    p.attachments = Number(buf);
                }
                if ("/" === str.charAt(i + 1)) {
                    const start = i + 1;
                    while(++i){
                        const c = str.charAt(i);
                        if ("," === c) break;
                        if (i === str.length) break;
                    }
                    p.nsp = str.substring(start, i);
                } else p.nsp = "/";
                const next = str.charAt(i + 1);
                if ("" !== next && Number(next) == next) {
                    const start = i + 1;
                    while(++i){
                        const c = str.charAt(i);
                        if (null == c || Number(c) != c) {
                            --i;
                            break;
                        }
                        if (i === str.length) break;
                    }
                    p.id = Number(str.substring(start, i + 1));
                }
                if (str.charAt(++i)) {
                    const payload = this.tryParse(str.substr(i));
                    if (Decoder.isPayloadValid(p.type, payload)) p.data = payload;
                    else throw new Error("invalid payload");
                }
                debug("decoded %s as %j", str, p);
                return p;
            }
            tryParse(str) {
                try {
                    return JSON.parse(str, this.reviver);
                } catch (e) {
                    return false;
                }
            }
            static isPayloadValid(type, payload) {
                switch(type){
                    case PacketType.CONNECT:
                        return isObject(payload);
                    case PacketType.DISCONNECT:
                        return void 0 === payload;
                    case PacketType.CONNECT_ERROR:
                        return "string" == typeof payload || isObject(payload);
                    case PacketType.EVENT:
                    case PacketType.BINARY_EVENT:
                        return Array.isArray(payload) && ("number" == typeof payload[0] || "string" == typeof payload[0] && -1 === RESERVED_EVENTS.indexOf(payload[0]));
                    case PacketType.ACK:
                    case PacketType.BINARY_ACK:
                        return Array.isArray(payload);
                }
            }
            destroy() {
                if (this.reconstructor) {
                    this.reconstructor.finishedReconstruction();
                    this.reconstructor = null;
                }
            }
        }
        exports1.Decoder = Decoder;
        class BinaryReconstructor {
            constructor(packet){
                this.packet = packet;
                this.buffers = [];
                this.reconPack = packet;
            }
            takeBinaryData(binData) {
                this.buffers.push(binData);
                if (this.buffers.length === this.reconPack.attachments) {
                    const packet = (0, binary_js_1.reconstructPacket)(this.reconPack, this.buffers);
                    this.finishedReconstruction();
                    return packet;
                }
                return null;
            }
            finishedReconstruction() {
                this.reconPack = null;
                this.buffers = [];
            }
        }
    },
    "../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/cjs/is-binary.js": function(__unused_webpack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.hasBinary = exports1.isBinary = void 0;
        const withNativeArrayBuffer = "function" == typeof ArrayBuffer;
        const isView = (obj)=>"function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
        const toString = Object.prototype.toString;
        const withNativeBlob = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === toString.call(Blob);
        const withNativeFile = "function" == typeof File || "undefined" != typeof File && "[object FileConstructor]" === toString.call(File);
        function isBinary(obj) {
            return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
        }
        exports1.isBinary = isBinary;
        function hasBinary(obj, toJSON) {
            if (!obj || "object" != typeof obj) return false;
            if (Array.isArray(obj)) {
                for(let i = 0, l = obj.length; i < l; i++)if (hasBinary(obj[i])) return true;
                return false;
            }
            if (isBinary(obj)) return true;
            if (obj.toJSON && "function" == typeof obj.toJSON && 1 === arguments.length) return hasBinary(obj.toJSON(), true);
            for(const key in obj)if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) return true;
            return false;
        }
        exports1.hasBinary = hasBinary;
    },
    "../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/broadcast-operator.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.RemoteSocket = exports1.BroadcastOperator = void 0;
        const socket_types_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/socket-types.js");
        const socket_io_parser_1 = __webpack_require__("../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/cjs/index.js");
        class BroadcastOperator {
            constructor(adapter, rooms = new Set(), exceptRooms = new Set(), flags = {}){
                this.adapter = adapter;
                this.rooms = rooms;
                this.exceptRooms = exceptRooms;
                this.flags = flags;
            }
            to(room) {
                const rooms = new Set(this.rooms);
                if (Array.isArray(room)) room.forEach((r)=>rooms.add(r));
                else rooms.add(room);
                return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);
            }
            in(room) {
                return this.to(room);
            }
            except(room) {
                const exceptRooms = new Set(this.exceptRooms);
                if (Array.isArray(room)) room.forEach((r)=>exceptRooms.add(r));
                else exceptRooms.add(room);
                return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);
            }
            compress(compress) {
                const flags = Object.assign({}, this.flags, {
                    compress
                });
                return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
            }
            get volatile() {
                const flags = Object.assign({}, this.flags, {
                    volatile: true
                });
                return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
            }
            get local() {
                const flags = Object.assign({}, this.flags, {
                    local: true
                });
                return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
            }
            timeout(timeout) {
                const flags = Object.assign({}, this.flags, {
                    timeout
                });
                return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
            }
            emit(ev, ...args) {
                if (socket_types_1.RESERVED_EVENTS.has(ev)) throw new Error(`"${String(ev)}" is a reserved event name`);
                const data = [
                    ev,
                    ...args
                ];
                const packet = {
                    type: socket_io_parser_1.PacketType.EVENT,
                    data: data
                };
                const withAck = "function" == typeof data[data.length - 1];
                if (!withAck) {
                    this.adapter.broadcast(packet, {
                        rooms: this.rooms,
                        except: this.exceptRooms,
                        flags: this.flags
                    });
                    return true;
                }
                const ack = data.pop();
                let timedOut = false;
                let responses = [];
                const timer = setTimeout(()=>{
                    timedOut = true;
                    ack.apply(this, [
                        new Error("operation has timed out"),
                        this.flags.expectSingleResponse ? null : responses
                    ]);
                }, this.flags.timeout);
                let expectedServerCount = -1;
                let actualServerCount = 0;
                let expectedClientCount = 0;
                const checkCompleteness = ()=>{
                    if (!timedOut && expectedServerCount === actualServerCount && responses.length === expectedClientCount) {
                        clearTimeout(timer);
                        ack.apply(this, [
                            null,
                            this.flags.expectSingleResponse ? responses[0] : responses
                        ]);
                    }
                };
                this.adapter.broadcastWithAck(packet, {
                    rooms: this.rooms,
                    except: this.exceptRooms,
                    flags: this.flags
                }, (clientCount)=>{
                    expectedClientCount += clientCount;
                    actualServerCount++;
                    checkCompleteness();
                }, (clientResponse)=>{
                    responses.push(clientResponse);
                    checkCompleteness();
                });
                this.adapter.serverCount().then((serverCount)=>{
                    expectedServerCount = serverCount;
                    checkCompleteness();
                });
                return true;
            }
            emitWithAck(ev, ...args) {
                return new Promise((resolve, reject)=>{
                    args.push((err, responses)=>{
                        if (!err) return resolve(responses);
                        err.responses = responses;
                        return reject(err);
                    });
                    this.emit(ev, ...args);
                });
            }
            allSockets() {
                if (!this.adapter) throw new Error("No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?");
                return this.adapter.sockets(this.rooms);
            }
            fetchSockets() {
                return this.adapter.fetchSockets({
                    rooms: this.rooms,
                    except: this.exceptRooms,
                    flags: this.flags
                }).then((sockets)=>sockets.map((socket)=>{
                        if (socket.server) return socket;
                        return new RemoteSocket(this.adapter, socket);
                    }));
            }
            socketsJoin(room) {
                this.adapter.addSockets({
                    rooms: this.rooms,
                    except: this.exceptRooms,
                    flags: this.flags
                }, Array.isArray(room) ? room : [
                    room
                ]);
            }
            socketsLeave(room) {
                this.adapter.delSockets({
                    rooms: this.rooms,
                    except: this.exceptRooms,
                    flags: this.flags
                }, Array.isArray(room) ? room : [
                    room
                ]);
            }
            disconnectSockets(close = false) {
                this.adapter.disconnectSockets({
                    rooms: this.rooms,
                    except: this.exceptRooms,
                    flags: this.flags
                }, close);
            }
        }
        exports1.BroadcastOperator = BroadcastOperator;
        class RemoteSocket {
            constructor(adapter, details){
                this.id = details.id;
                this.handshake = details.handshake;
                this.rooms = new Set(details.rooms);
                this.data = details.data;
                this.operator = new BroadcastOperator(adapter, new Set([
                    this.id
                ]), new Set(), {
                    expectSingleResponse: true
                });
            }
            timeout(timeout) {
                return this.operator.timeout(timeout);
            }
            emit(ev, ...args) {
                return this.operator.emit(ev, ...args);
            }
            join(room) {
                return this.operator.socketsJoin(room);
            }
            leave(room) {
                return this.operator.socketsLeave(room);
            }
            disconnect(close = false) {
                this.operator.disconnectSockets(close);
                return this;
            }
        }
        exports1.RemoteSocket = RemoteSocket;
    },
    "../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/client.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Client = void 0;
        const socket_io_parser_1 = __webpack_require__("../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/cjs/index.js");
        const debugModule = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const url = __webpack_require__("url");
        const debug = debugModule("socket.io:client");
        class Client {
            constructor(server, conn){
                this.sockets = new Map();
                this.nsps = new Map();
                this.server = server;
                this.conn = conn;
                this.encoder = server.encoder;
                this.decoder = new server._parser.Decoder();
                this.id = conn.id;
                this.setup();
            }
            get request() {
                return this.conn.request;
            }
            setup() {
                this.onclose = this.onclose.bind(this);
                this.ondata = this.ondata.bind(this);
                this.onerror = this.onerror.bind(this);
                this.ondecoded = this.ondecoded.bind(this);
                this.decoder.on("decoded", this.ondecoded);
                this.conn.on("data", this.ondata);
                this.conn.on("error", this.onerror);
                this.conn.on("close", this.onclose);
                this.connectTimeout = setTimeout(()=>{
                    if (0 === this.nsps.size) {
                        debug("no namespace joined yet, close the client");
                        this.close();
                    } else debug("the client has already joined a namespace, nothing to do");
                }, this.server._connectTimeout);
            }
            connect(name, auth = {}) {
                if (this.server._nsps.has(name)) {
                    debug("connecting to namespace %s", name);
                    return this.doConnect(name, auth);
                }
                this.server._checkNamespace(name, auth, (dynamicNspName)=>{
                    if (dynamicNspName) this.doConnect(name, auth);
                    else {
                        debug("creation of namespace %s was denied", name);
                        this._packet({
                            type: socket_io_parser_1.PacketType.CONNECT_ERROR,
                            nsp: name,
                            data: {
                                message: "Invalid namespace"
                            }
                        });
                    }
                });
            }
            doConnect(name, auth) {
                const nsp = this.server.of(name);
                nsp._add(this, auth, (socket)=>{
                    this.sockets.set(socket.id, socket);
                    this.nsps.set(nsp.name, socket);
                    if (this.connectTimeout) {
                        clearTimeout(this.connectTimeout);
                        this.connectTimeout = void 0;
                    }
                });
            }
            _disconnect() {
                for (const socket of this.sockets.values())socket.disconnect();
                this.sockets.clear();
                this.close();
            }
            _remove(socket) {
                if (this.sockets.has(socket.id)) {
                    const nsp = this.sockets.get(socket.id).nsp.name;
                    this.sockets.delete(socket.id);
                    this.nsps.delete(nsp);
                } else debug("ignoring remove for %s", socket.id);
            }
            close() {
                if ("open" === this.conn.readyState) {
                    debug("forcing transport close");
                    this.conn.close();
                    this.onclose("forced server close");
                }
            }
            _packet(packet, opts = {}) {
                if ("open" !== this.conn.readyState) return void debug("ignoring packet write %j", packet);
                const encodedPackets = opts.preEncoded ? packet : this.encoder.encode(packet);
                this.writeToEngine(encodedPackets, opts);
            }
            writeToEngine(encodedPackets, opts) {
                if (opts.volatile && !this.conn.transport.writable) return void debug("volatile packet is discarded since the transport is not currently writable");
                const packets = Array.isArray(encodedPackets) ? encodedPackets : [
                    encodedPackets
                ];
                for (const encodedPacket of packets)this.conn.write(encodedPacket, opts);
            }
            ondata(data) {
                try {
                    this.decoder.add(data);
                } catch (e) {
                    debug("invalid packet format");
                    this.onerror(e);
                }
            }
            ondecoded(packet) {
                let namespace;
                let authPayload;
                if (3 === this.conn.protocol) {
                    const parsed = url.parse(packet.nsp, true);
                    namespace = parsed.pathname;
                    authPayload = parsed.query;
                } else {
                    namespace = packet.nsp;
                    authPayload = packet.data;
                }
                const socket = this.nsps.get(namespace);
                if (socket || packet.type !== socket_io_parser_1.PacketType.CONNECT) if (socket && packet.type !== socket_io_parser_1.PacketType.CONNECT && packet.type !== socket_io_parser_1.PacketType.CONNECT_ERROR) process.nextTick(function() {
                    socket._onpacket(packet);
                });
                else {
                    debug("invalid state (packet type: %s)", packet.type);
                    this.close();
                }
                else this.connect(namespace, authPayload);
            }
            onerror(err) {
                for (const socket of this.sockets.values())socket._onerror(err);
                this.conn.close();
            }
            onclose(reason, description) {
                debug("client close with reason %s", reason);
                this.destroy();
                for (const socket of this.sockets.values())socket._onclose(reason, description);
                this.sockets.clear();
                this.decoder.destroy();
            }
            destroy() {
                this.conn.removeListener("data", this.ondata);
                this.conn.removeListener("error", this.onerror);
                this.conn.removeListener("close", this.onclose);
                this.decoder.removeListener("decoded", this.ondecoded);
                if (this.connectTimeout) {
                    clearTimeout(this.connectTimeout);
                    this.connectTimeout = void 0;
                }
            }
        }
        exports1.Client = Client;
    },
    "../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/index.js": function(module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
            Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
                default: mod
            };
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Namespace = exports1.Socket = exports1.Server = void 0;
        const http = __webpack_require__("http");
        const fs_1 = __webpack_require__("fs");
        const zlib_1 = __webpack_require__("zlib");
        const accepts = __webpack_require__("../node_modules/.pnpm/accepts@1.3.8/node_modules/accepts/index.js");
        const stream_1 = __webpack_require__("stream");
        const path = __webpack_require__("path");
        const engine_io_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/engine.io.js");
        const client_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/client.js");
        const events_1 = __webpack_require__("events");
        const namespace_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/namespace.js");
        Object.defineProperty(exports1, "Namespace", {
            enumerable: true,
            get: function() {
                return namespace_1.Namespace;
            }
        });
        const parent_namespace_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/parent-namespace.js");
        const socket_io_adapter_1 = __webpack_require__("../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/index.js");
        const parser = __importStar(__webpack_require__("../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/cjs/index.js"));
        const debug_1 = __importDefault(__webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js"));
        const socket_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/socket.js");
        Object.defineProperty(exports1, "Socket", {
            enumerable: true,
            get: function() {
                return socket_1.Socket;
            }
        });
        const typed_events_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/typed-events.js");
        const uws_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/uws.js");
        const cors_1 = __importDefault(__webpack_require__("../node_modules/.pnpm/cors@2.8.5/node_modules/cors/lib/index.js"));
        const debug = (0, debug_1.default)("socket.io:server");
        const clientVersion = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/package.json").i8;
        const dotMapRegex = /\.map/;
        class Server extends typed_events_1.StrictEventEmitter {
            constructor(srv, opts = {}){
                super();
                this._nsps = new Map();
                this.parentNsps = new Map();
                this.parentNamespacesFromRegExp = new Map();
                if ("object" == typeof srv && srv instanceof Object && !srv.listen) {
                    opts = srv;
                    srv = void 0;
                }
                this.path(opts.path || "/socket.io");
                this.connectTimeout(opts.connectTimeout || 45000);
                this.serveClient(false !== opts.serveClient);
                this._parser = opts.parser || parser;
                this.encoder = new this._parser.Encoder();
                this.opts = opts;
                if (opts.connectionStateRecovery) {
                    opts.connectionStateRecovery = Object.assign({
                        maxDisconnectionDuration: 120000,
                        skipMiddlewares: true
                    }, opts.connectionStateRecovery);
                    this.adapter(opts.adapter || socket_io_adapter_1.SessionAwareAdapter);
                } else this.adapter(opts.adapter || socket_io_adapter_1.Adapter);
                opts.cleanupEmptyChildNamespaces = !!opts.cleanupEmptyChildNamespaces;
                this.sockets = this.of("/");
                if (srv || "number" == typeof srv) this.attach(srv);
                if (this.opts.cors) this._corsMiddleware = (0, cors_1.default)(this.opts.cors);
            }
            get _opts() {
                return this.opts;
            }
            serveClient(v) {
                if (!arguments.length) return this._serveClient;
                this._serveClient = v;
                return this;
            }
            _checkNamespace(name, auth, fn) {
                if (0 === this.parentNsps.size) return fn(false);
                const keysIterator = this.parentNsps.keys();
                const run = ()=>{
                    const nextFn = keysIterator.next();
                    if (nextFn.done) return fn(false);
                    nextFn.value(name, auth, (err, allow)=>{
                        if (err || !allow) return run();
                        if (this._nsps.has(name)) {
                            debug("dynamic namespace %s already exists", name);
                            return fn(this._nsps.get(name));
                        }
                        const namespace = this.parentNsps.get(nextFn.value).createChild(name);
                        debug("dynamic namespace %s was created", name);
                        fn(namespace);
                    });
                };
                run();
            }
            path(v) {
                if (!arguments.length) return this._path;
                this._path = v.replace(/\/$/, "");
                const escapedPath = this._path.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
                this.clientPathRegex = new RegExp("^" + escapedPath + "/socket\\.io(\\.msgpack|\\.esm)?(\\.min)?\\.js(\\.map)?(?:\\?|$)");
                return this;
            }
            connectTimeout(v) {
                if (void 0 === v) return this._connectTimeout;
                this._connectTimeout = v;
                return this;
            }
            adapter(v) {
                if (!arguments.length) return this._adapter;
                this._adapter = v;
                for (const nsp of this._nsps.values())nsp._initAdapter();
                return this;
            }
            listen(srv, opts = {}) {
                return this.attach(srv, opts);
            }
            attach(srv, opts = {}) {
                if ("function" == typeof srv) {
                    const msg = "You are trying to attach socket.io to an express request handler function. Please pass a http.Server instance.";
                    throw new Error(msg);
                }
                if (Number(srv) == srv) srv = Number(srv);
                if ("number" == typeof srv) {
                    debug("creating http server and binding to %d", srv);
                    const port = srv;
                    srv = http.createServer((req, res)=>{
                        res.writeHead(404);
                        res.end();
                    });
                    srv.listen(port);
                }
                Object.assign(opts, this.opts);
                opts.path = opts.path || this._path;
                this.initEngine(srv, opts);
                return this;
            }
            attachApp(app, opts = {}) {
                Object.assign(opts, this.opts);
                opts.path = opts.path || this._path;
                debug("creating uWebSockets.js-based engine with opts %j", opts);
                const engine = new engine_io_1.uServer(opts);
                engine.attach(app, opts);
                this.bind(engine);
                if (this._serveClient) app.get(`${this._path}/*`, (res, req)=>{
                    if (!this.clientPathRegex.test(req.getUrl())) return void req.setYield(true);
                    const filename = req.getUrl().replace(this._path, "").replace(/\?.*$/, "").replace(/^\//, "");
                    const isMap = dotMapRegex.test(filename);
                    const type = isMap ? "map" : "source";
                    const expectedEtag = '"' + clientVersion + '"';
                    const weakEtag = "W/" + expectedEtag;
                    const etag = req.getHeader("if-none-match");
                    if (etag) {
                        if (expectedEtag === etag || weakEtag === etag) {
                            debug("serve client %s 304", type);
                            res.writeStatus("304 Not Modified");
                            res.end();
                            return;
                        }
                    }
                    debug("serve client %s", type);
                    res.writeHeader("cache-control", "public, max-age=0");
                    res.writeHeader("content-type", "application/" + (isMap ? "json" : "javascript") + "; charset=utf-8");
                    res.writeHeader("etag", expectedEtag);
                    const filepath = path.join(__dirname, "../client-dist/", filename);
                    (0, uws_1.serveFile)(res, filepath);
                });
                (0, uws_1.patchAdapter)(app);
            }
            initEngine(srv, opts) {
                debug("creating engine.io instance with opts %j", opts);
                this.eio = (0, engine_io_1.attach)(srv, opts);
                if (this._serveClient) this.attachServe(srv);
                this.httpServer = srv;
                this.bind(this.eio);
            }
            attachServe(srv) {
                debug("attaching client serving req handler");
                const evs = srv.listeners("request").slice(0);
                srv.removeAllListeners("request");
                srv.on("request", (req, res)=>{
                    if (this.clientPathRegex.test(req.url)) if (this._corsMiddleware) this._corsMiddleware(req, res, ()=>{
                        this.serve(req, res);
                    });
                    else this.serve(req, res);
                    else for(let i = 0; i < evs.length; i++)evs[i].call(srv, req, res);
                });
            }
            serve(req, res) {
                const filename = req.url.replace(this._path, "").replace(/\?.*$/, "");
                const isMap = dotMapRegex.test(filename);
                const type = isMap ? "map" : "source";
                const expectedEtag = '"' + clientVersion + '"';
                const weakEtag = "W/" + expectedEtag;
                const etag = req.headers["if-none-match"];
                if (etag) {
                    if (expectedEtag === etag || weakEtag === etag) {
                        debug("serve client %s 304", type);
                        res.writeHead(304);
                        res.end();
                        return;
                    }
                }
                debug("serve client %s", type);
                res.setHeader("Cache-Control", "public, max-age=0");
                res.setHeader("Content-Type", "application/" + (isMap ? "json" : "javascript") + "; charset=utf-8");
                res.setHeader("ETag", expectedEtag);
                Server.sendFile(filename, req, res);
            }
            static sendFile(filename, req, res) {
                const readStream = (0, fs_1.createReadStream)(path.join(__dirname, "../client-dist/", filename));
                const encoding = accepts(req).encodings([
                    "br",
                    "gzip",
                    "deflate"
                ]);
                const onError = (err)=>{
                    if (err) res.end();
                };
                switch(encoding){
                    case "br":
                        res.writeHead(200, {
                            "content-encoding": "br"
                        });
                        (0, stream_1.pipeline)(readStream, (0, zlib_1.createBrotliCompress)(), res, onError);
                        break;
                    case "gzip":
                        res.writeHead(200, {
                            "content-encoding": "gzip"
                        });
                        (0, stream_1.pipeline)(readStream, (0, zlib_1.createGzip)(), res, onError);
                        break;
                    case "deflate":
                        res.writeHead(200, {
                            "content-encoding": "deflate"
                        });
                        (0, stream_1.pipeline)(readStream, (0, zlib_1.createDeflate)(), res, onError);
                        break;
                    default:
                        res.writeHead(200);
                        (0, stream_1.pipeline)(readStream, res, onError);
                }
            }
            bind(engine) {
                this.engine = engine;
                this.engine.on("connection", this.onconnection.bind(this));
                return this;
            }
            onconnection(conn) {
                debug("incoming connection with id %s", conn.id);
                const client = new client_1.Client(this, conn);
                if (3 === conn.protocol) client.connect("/");
                return this;
            }
            of(name, fn) {
                if ("function" == typeof name || name instanceof RegExp) {
                    const parentNsp = new parent_namespace_1.ParentNamespace(this);
                    debug("initializing parent namespace %s", parentNsp.name);
                    if ("function" == typeof name) this.parentNsps.set(name, parentNsp);
                    else {
                        this.parentNsps.set((nsp, conn, next)=>next(null, name.test(nsp)), parentNsp);
                        this.parentNamespacesFromRegExp.set(name, parentNsp);
                    }
                    if (fn) parentNsp.on("connect", fn);
                    return parentNsp;
                }
                if ("/" !== String(name)[0]) name = "/" + name;
                let nsp = this._nsps.get(name);
                if (!nsp) {
                    for (const [regex, parentNamespace] of this.parentNamespacesFromRegExp)if (regex.test(name)) {
                        debug("attaching namespace %s to parent namespace %s", name, regex);
                        return parentNamespace.createChild(name);
                    }
                    debug("initializing namespace %s", name);
                    nsp = new namespace_1.Namespace(this, name);
                    this._nsps.set(name, nsp);
                    if ("/" !== name) this.sockets.emitReserved("new_namespace", nsp);
                }
                if (fn) nsp.on("connect", fn);
                return nsp;
            }
            async close(fn) {
                await Promise.allSettled([
                    ...this._nsps.values()
                ].map(async (nsp)=>{
                    nsp.sockets.forEach((socket)=>{
                        socket._onclose("server shutting down");
                    });
                    await nsp.adapter.close();
                }));
                this.engine.close();
                (0, uws_1.restoreAdapter)();
                if (this.httpServer) this.httpServer.close(fn);
                else fn && fn();
            }
            use(fn) {
                this.sockets.use(fn);
                return this;
            }
            to(room) {
                return this.sockets.to(room);
            }
            in(room) {
                return this.sockets.in(room);
            }
            except(room) {
                return this.sockets.except(room);
            }
            send(...args) {
                this.sockets.emit("message", ...args);
                return this;
            }
            write(...args) {
                this.sockets.emit("message", ...args);
                return this;
            }
            serverSideEmit(ev, ...args) {
                return this.sockets.serverSideEmit(ev, ...args);
            }
            serverSideEmitWithAck(ev, ...args) {
                return this.sockets.serverSideEmitWithAck(ev, ...args);
            }
            allSockets() {
                return this.sockets.allSockets();
            }
            compress(compress) {
                return this.sockets.compress(compress);
            }
            get volatile() {
                return this.sockets.volatile;
            }
            get local() {
                return this.sockets.local;
            }
            timeout(timeout) {
                return this.sockets.timeout(timeout);
            }
            fetchSockets() {
                return this.sockets.fetchSockets();
            }
            socketsJoin(room) {
                return this.sockets.socketsJoin(room);
            }
            socketsLeave(room) {
                return this.sockets.socketsLeave(room);
            }
            disconnectSockets(close = false) {
                return this.sockets.disconnectSockets(close);
            }
        }
        exports1.Server = Server;
        const emitterMethods = Object.keys(events_1.EventEmitter.prototype).filter(function(key) {
            return "function" == typeof events_1.EventEmitter.prototype[key];
        });
        emitterMethods.forEach(function(fn) {
            Server.prototype[fn] = function() {
                return this.sockets[fn].apply(this.sockets, arguments);
            };
        });
        module.exports = (srv, opts)=>new Server(srv, opts);
        module.exports.Server = Server;
        module.exports.Namespace = namespace_1.Namespace;
        module.exports.Socket = socket_1.Socket;
    },
    "../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/namespace.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
                default: mod
            };
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Namespace = exports1.RESERVED_EVENTS = void 0;
        const socket_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/socket.js");
        const typed_events_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/typed-events.js");
        const debug_1 = __importDefault(__webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js"));
        const broadcast_operator_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/broadcast-operator.js");
        const debug = (0, debug_1.default)("socket.io:namespace");
        exports1.RESERVED_EVENTS = new Set([
            "connect",
            "connection",
            "new_namespace"
        ]);
        class Namespace extends typed_events_1.StrictEventEmitter {
            constructor(server, name){
                super();
                this.sockets = new Map();
                this._preConnectSockets = new Map();
                this._fns = [];
                this._ids = 0;
                this.server = server;
                this.name = name;
                this._initAdapter();
            }
            _initAdapter() {
                this.adapter = new (this.server.adapter())(this);
            }
            use(fn) {
                this._fns.push(fn);
                return this;
            }
            run(socket, fn) {
                if (!this._fns.length) return fn();
                const fns = this._fns.slice(0);
                function run(i) {
                    fns[i](socket, (err)=>{
                        if (err) return fn(err);
                        if (!fns[i + 1]) return fn();
                        run(i + 1);
                    });
                }
                run(0);
            }
            to(room) {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).to(room);
            }
            in(room) {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).in(room);
            }
            except(room) {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).except(room);
            }
            async _add(client, auth, fn) {
                var _a;
                debug("adding socket to nsp %s", this.name);
                const socket = await this._createSocket(client, auth);
                this._preConnectSockets.set(socket.id, socket);
                if ((null == (_a = this.server.opts.connectionStateRecovery) ? void 0 : _a.skipMiddlewares) && socket.recovered && "open" === client.conn.readyState) return this._doConnect(socket, fn);
                this.run(socket, (err)=>{
                    process.nextTick(()=>{
                        if ("open" !== client.conn.readyState) {
                            debug("next called after client was closed - ignoring socket");
                            socket._cleanup();
                            return;
                        }
                        if (err) {
                            debug("middleware error, sending CONNECT_ERROR packet to the client");
                            socket._cleanup();
                            if (3 === client.conn.protocol) return socket._error(err.data || err.message);
                            return socket._error({
                                message: err.message,
                                data: err.data
                            });
                        }
                        this._doConnect(socket, fn);
                    });
                });
            }
            async _createSocket(client, auth) {
                const sessionId = auth.pid;
                const offset = auth.offset;
                if (this.server.opts.connectionStateRecovery && "string" == typeof sessionId && "string" == typeof offset) {
                    let session;
                    try {
                        session = await this.adapter.restoreSession(sessionId, offset);
                    } catch (e) {
                        debug("error while restoring session: %s", e);
                    }
                    if (session) {
                        debug("connection state recovered for sid %s", session.sid);
                        return new socket_1.Socket(this, client, auth, session);
                    }
                }
                return new socket_1.Socket(this, client, auth);
            }
            _doConnect(socket, fn) {
                this._preConnectSockets.delete(socket.id);
                this.sockets.set(socket.id, socket);
                socket._onconnect();
                if (fn) fn(socket);
                this.emitReserved("connect", socket);
                this.emitReserved("connection", socket);
            }
            _remove(socket) {
                this.sockets.delete(socket.id) || this._preConnectSockets.delete(socket.id);
            }
            emit(ev, ...args) {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).emit(ev, ...args);
            }
            send(...args) {
                this.emit("message", ...args);
                return this;
            }
            write(...args) {
                this.emit("message", ...args);
                return this;
            }
            serverSideEmit(ev, ...args) {
                if (exports1.RESERVED_EVENTS.has(ev)) throw new Error(`"${String(ev)}" is a reserved event name`);
                args.unshift(ev);
                this.adapter.serverSideEmit(args);
                return true;
            }
            serverSideEmitWithAck(ev, ...args) {
                return new Promise((resolve, reject)=>{
                    args.push((err, responses)=>{
                        if (!err) return resolve(responses);
                        err.responses = responses;
                        return reject(err);
                    });
                    this.serverSideEmit(ev, ...args);
                });
            }
            _onServerSideEmit(args) {
                super.emitUntyped.apply(this, args);
            }
            allSockets() {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).allSockets();
            }
            compress(compress) {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).compress(compress);
            }
            get volatile() {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).volatile;
            }
            get local() {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).local;
            }
            timeout(timeout) {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).timeout(timeout);
            }
            fetchSockets() {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).fetchSockets();
            }
            socketsJoin(room) {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsJoin(room);
            }
            socketsLeave(room) {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsLeave(room);
            }
            disconnectSockets(close = false) {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).disconnectSockets(close);
            }
        }
        exports1.Namespace = Namespace;
    },
    "../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/parent-namespace.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
                default: mod
            };
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.ParentNamespace = void 0;
        const namespace_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/namespace.js");
        const socket_io_adapter_1 = __webpack_require__("../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/index.js");
        const debug_1 = __importDefault(__webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js"));
        const debug = (0, debug_1.default)("socket.io:parent-namespace");
        class ParentNamespace extends namespace_1.Namespace {
            constructor(server){
                super(server, "/_" + ParentNamespace.count++);
                this.children = new Set();
            }
            _initAdapter() {
                this.adapter = new ParentBroadcastAdapter(this);
            }
            emit(ev, ...args) {
                this.children.forEach((nsp)=>{
                    nsp.emit(ev, ...args);
                });
                return true;
            }
            createChild(name) {
                debug("creating child namespace %s", name);
                const namespace = new namespace_1.Namespace(this.server, name);
                this["_fns"].forEach((fn)=>namespace.use(fn));
                this.listeners("connect").forEach((listener)=>namespace.on("connect", listener));
                this.listeners("connection").forEach((listener)=>namespace.on("connection", listener));
                this.children.add(namespace);
                if (this.server._opts.cleanupEmptyChildNamespaces) {
                    const remove = namespace._remove;
                    namespace._remove = (socket)=>{
                        remove.call(namespace, socket);
                        if (0 === namespace.sockets.size) {
                            debug("closing child namespace %s", name);
                            namespace.adapter.close();
                            this.server._nsps.delete(namespace.name);
                            this.children.delete(namespace);
                        }
                    };
                }
                this.server._nsps.set(name, namespace);
                this.server.sockets.emitReserved("new_namespace", namespace);
                return namespace;
            }
            fetchSockets() {
                throw new Error("fetchSockets() is not supported on parent namespaces");
            }
        }
        exports1.ParentNamespace = ParentNamespace;
        ParentNamespace.count = 0;
        class ParentBroadcastAdapter extends socket_io_adapter_1.Adapter {
            broadcast(packet, opts) {
                this.nsp.children.forEach((nsp)=>{
                    nsp.adapter.broadcast(packet, opts);
                });
            }
        }
    },
    "../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/socket-types.js": function(__unused_webpack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.RESERVED_EVENTS = void 0;
        exports1.RESERVED_EVENTS = new Set([
            "connect",
            "connect_error",
            "disconnect",
            "disconnecting",
            "newListener",
            "removeListener"
        ]);
    },
    "../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/socket.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
                default: mod
            };
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Socket = void 0;
        const socket_io_parser_1 = __webpack_require__("../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/cjs/index.js");
        const debug_1 = __importDefault(__webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js"));
        const typed_events_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/typed-events.js");
        const base64id_1 = __importDefault(__webpack_require__("../node_modules/.pnpm/base64id@2.0.0/node_modules/base64id/lib/base64id.js"));
        const broadcast_operator_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/broadcast-operator.js");
        const socket_types_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/socket-types.js");
        const debug = (0, debug_1.default)("socket.io:socket");
        const RECOVERABLE_DISCONNECT_REASONS = new Set([
            "transport error",
            "transport close",
            "forced close",
            "ping timeout",
            "server shutting down",
            "forced server close"
        ]);
        function noop() {}
        class Socket extends typed_events_1.StrictEventEmitter {
            constructor(nsp, client, auth, previousSession){
                super();
                this.nsp = nsp;
                this.client = client;
                this.recovered = false;
                this.data = {};
                this.connected = false;
                this.acks = new Map();
                this.fns = [];
                this.flags = {};
                this.server = nsp.server;
                this.adapter = this.nsp.adapter;
                if (previousSession) {
                    this.id = previousSession.sid;
                    this.pid = previousSession.pid;
                    previousSession.rooms.forEach((room)=>this.join(room));
                    this.data = previousSession.data;
                    previousSession.missedPackets.forEach((packet)=>{
                        this.packet({
                            type: socket_io_parser_1.PacketType.EVENT,
                            data: packet
                        });
                    });
                    this.recovered = true;
                } else {
                    if (3 === client.conn.protocol) this.id = "/" !== nsp.name ? nsp.name + "#" + client.id : client.id;
                    else this.id = base64id_1.default.generateId();
                    if (this.server._opts.connectionStateRecovery) this.pid = base64id_1.default.generateId();
                }
                this.handshake = this.buildHandshake(auth);
                this.on("error", noop);
            }
            buildHandshake(auth) {
                var _a, _b, _c, _d;
                return {
                    headers: (null == (_a = this.request) ? void 0 : _a.headers) || {},
                    time: new Date() + "",
                    address: this.conn.remoteAddress,
                    xdomain: !!(null == (_b = this.request) ? void 0 : _b.headers.origin),
                    secure: !this.request || !!this.request.connection.encrypted,
                    issued: +new Date(),
                    url: null == (_c = this.request) ? void 0 : _c.url,
                    query: (null == (_d = this.request) ? void 0 : _d._query) || {},
                    auth
                };
            }
            emit(ev, ...args) {
                if (socket_types_1.RESERVED_EVENTS.has(ev)) throw new Error(`"${String(ev)}" is a reserved event name`);
                const data = [
                    ev,
                    ...args
                ];
                const packet = {
                    type: socket_io_parser_1.PacketType.EVENT,
                    data: data
                };
                if ("function" == typeof data[data.length - 1]) {
                    const id = this.nsp._ids++;
                    debug("emitting packet with ack id %d", id);
                    this.registerAckCallback(id, data.pop());
                    packet.id = id;
                }
                const flags = Object.assign({}, this.flags);
                this.flags = {};
                if (this.nsp.server.opts.connectionStateRecovery) this.adapter.broadcast(packet, {
                    rooms: new Set([
                        this.id
                    ]),
                    except: new Set(),
                    flags
                });
                else {
                    this.notifyOutgoingListeners(packet);
                    this.packet(packet, flags);
                }
                return true;
            }
            emitWithAck(ev, ...args) {
                const withErr = void 0 !== this.flags.timeout;
                return new Promise((resolve, reject)=>{
                    args.push((arg1, arg2)=>{
                        if (withErr) return arg1 ? reject(arg1) : resolve(arg2);
                        return resolve(arg1);
                    });
                    this.emit(ev, ...args);
                });
            }
            registerAckCallback(id, ack) {
                const timeout = this.flags.timeout;
                if (void 0 === timeout) return void this.acks.set(id, ack);
                const timer = setTimeout(()=>{
                    debug("event with ack id %d has timed out after %d ms", id, timeout);
                    this.acks.delete(id);
                    ack.call(this, new Error("operation has timed out"));
                }, timeout);
                this.acks.set(id, (...args)=>{
                    clearTimeout(timer);
                    ack.apply(this, [
                        null,
                        ...args
                    ]);
                });
            }
            to(room) {
                return this.newBroadcastOperator().to(room);
            }
            in(room) {
                return this.newBroadcastOperator().in(room);
            }
            except(room) {
                return this.newBroadcastOperator().except(room);
            }
            send(...args) {
                this.emit("message", ...args);
                return this;
            }
            write(...args) {
                this.emit("message", ...args);
                return this;
            }
            packet(packet, opts = {}) {
                packet.nsp = this.nsp.name;
                opts.compress = false !== opts.compress;
                this.client._packet(packet, opts);
            }
            join(rooms) {
                debug("join room %s", rooms);
                return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [
                    rooms
                ]));
            }
            leave(room) {
                debug("leave room %s", room);
                return this.adapter.del(this.id, room);
            }
            leaveAll() {
                this.adapter.delAll(this.id);
            }
            _onconnect() {
                debug("socket connected - writing packet");
                this.connected = true;
                this.join(this.id);
                if (3 === this.conn.protocol) this.packet({
                    type: socket_io_parser_1.PacketType.CONNECT
                });
                else this.packet({
                    type: socket_io_parser_1.PacketType.CONNECT,
                    data: {
                        sid: this.id,
                        pid: this.pid
                    }
                });
            }
            _onpacket(packet) {
                debug("got packet %j", packet);
                switch(packet.type){
                    case socket_io_parser_1.PacketType.EVENT:
                        this.onevent(packet);
                        break;
                    case socket_io_parser_1.PacketType.BINARY_EVENT:
                        this.onevent(packet);
                        break;
                    case socket_io_parser_1.PacketType.ACK:
                        this.onack(packet);
                        break;
                    case socket_io_parser_1.PacketType.BINARY_ACK:
                        this.onack(packet);
                        break;
                    case socket_io_parser_1.PacketType.DISCONNECT:
                        this.ondisconnect();
                        break;
                }
            }
            onevent(packet) {
                const args = packet.data || [];
                debug("emitting event %j", args);
                if (null != packet.id) {
                    debug("attaching ack callback to event");
                    args.push(this.ack(packet.id));
                }
                if (this._anyListeners && this._anyListeners.length) {
                    const listeners = this._anyListeners.slice();
                    for (const listener of listeners)listener.apply(this, args);
                }
                this.dispatch(args);
            }
            ack(id) {
                const self = this;
                let sent = false;
                return function() {
                    if (sent) return;
                    const args = Array.prototype.slice.call(arguments);
                    debug("sending ack %j", args);
                    self.packet({
                        id: id,
                        type: socket_io_parser_1.PacketType.ACK,
                        data: args
                    });
                    sent = true;
                };
            }
            onack(packet) {
                const ack = this.acks.get(packet.id);
                if ("function" == typeof ack) {
                    debug("calling ack %s with %j", packet.id, packet.data);
                    ack.apply(this, packet.data);
                    this.acks.delete(packet.id);
                } else debug("bad ack %s", packet.id);
            }
            ondisconnect() {
                debug("got disconnect packet");
                this._onclose("client namespace disconnect");
            }
            _onerror(err) {
                this.emitReserved("error", err);
            }
            _onclose(reason, description) {
                if (!this.connected) return this;
                debug("closing socket - reason %s", reason);
                this.emitReserved("disconnecting", reason, description);
                if (this.server._opts.connectionStateRecovery && RECOVERABLE_DISCONNECT_REASONS.has(reason)) {
                    debug("connection state recovery is enabled for sid %s", this.id);
                    this.adapter.persistSession({
                        sid: this.id,
                        pid: this.pid,
                        rooms: [
                            ...this.rooms
                        ],
                        data: this.data
                    });
                }
                this._cleanup();
                this.client._remove(this);
                this.connected = false;
                this.emitReserved("disconnect", reason, description);
            }
            _cleanup() {
                this.leaveAll();
                this.nsp._remove(this);
                this.join = noop;
            }
            _error(err) {
                this.packet({
                    type: socket_io_parser_1.PacketType.CONNECT_ERROR,
                    data: err
                });
            }
            disconnect(close = false) {
                if (!this.connected) return this;
                if (close) this.client._disconnect();
                else {
                    this.packet({
                        type: socket_io_parser_1.PacketType.DISCONNECT
                    });
                    this._onclose("server namespace disconnect");
                }
                return this;
            }
            compress(compress) {
                this.flags.compress = compress;
                return this;
            }
            get volatile() {
                this.flags.volatile = true;
                return this;
            }
            get broadcast() {
                return this.newBroadcastOperator();
            }
            get local() {
                return this.newBroadcastOperator().local;
            }
            timeout(timeout) {
                this.flags.timeout = timeout;
                return this;
            }
            dispatch(event) {
                debug("dispatching an event %j", event);
                this.run(event, (err)=>{
                    process.nextTick(()=>{
                        if (err) return this._onerror(err);
                        if (this.connected) super.emitUntyped.apply(this, event);
                        else debug("ignore packet received after disconnection");
                    });
                });
            }
            use(fn) {
                this.fns.push(fn);
                return this;
            }
            run(event, fn) {
                if (!this.fns.length) return fn();
                const fns = this.fns.slice(0);
                function run(i) {
                    fns[i](event, (err)=>{
                        if (err) return fn(err);
                        if (!fns[i + 1]) return fn();
                        run(i + 1);
                    });
                }
                run(0);
            }
            get disconnected() {
                return !this.connected;
            }
            get request() {
                return this.client.request;
            }
            get conn() {
                return this.client.conn;
            }
            get rooms() {
                return this.adapter.socketRooms(this.id) || new Set();
            }
            onAny(listener) {
                this._anyListeners = this._anyListeners || [];
                this._anyListeners.push(listener);
                return this;
            }
            prependAny(listener) {
                this._anyListeners = this._anyListeners || [];
                this._anyListeners.unshift(listener);
                return this;
            }
            offAny(listener) {
                if (!this._anyListeners) return this;
                if (listener) {
                    const listeners = this._anyListeners;
                    for(let i = 0; i < listeners.length; i++)if (listener === listeners[i]) {
                        listeners.splice(i, 1);
                        break;
                    }
                } else this._anyListeners = [];
                return this;
            }
            listenersAny() {
                return this._anyListeners || [];
            }
            onAnyOutgoing(listener) {
                this._anyOutgoingListeners = this._anyOutgoingListeners || [];
                this._anyOutgoingListeners.push(listener);
                return this;
            }
            prependAnyOutgoing(listener) {
                this._anyOutgoingListeners = this._anyOutgoingListeners || [];
                this._anyOutgoingListeners.unshift(listener);
                return this;
            }
            offAnyOutgoing(listener) {
                if (!this._anyOutgoingListeners) return this;
                if (listener) {
                    const listeners = this._anyOutgoingListeners;
                    for(let i = 0; i < listeners.length; i++)if (listener === listeners[i]) {
                        listeners.splice(i, 1);
                        break;
                    }
                } else this._anyOutgoingListeners = [];
                return this;
            }
            listenersAnyOutgoing() {
                return this._anyOutgoingListeners || [];
            }
            notifyOutgoingListeners(packet) {
                if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
                    const listeners = this._anyOutgoingListeners.slice();
                    for (const listener of listeners)listener.apply(this, packet.data);
                }
            }
            newBroadcastOperator() {
                const flags = Object.assign({}, this.flags);
                this.flags = {};
                return new broadcast_operator_1.BroadcastOperator(this.adapter, new Set(), new Set([
                    this.id
                ]), flags);
            }
        }
        exports1.Socket = Socket;
    },
    "../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/typed-events.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.StrictEventEmitter = void 0;
        const events_1 = __webpack_require__("events");
        class StrictEventEmitter extends events_1.EventEmitter {
            on(ev, listener) {
                return super.on(ev, listener);
            }
            once(ev, listener) {
                return super.once(ev, listener);
            }
            emit(ev, ...args) {
                return super.emit(ev, ...args);
            }
            emitReserved(ev, ...args) {
                return super.emit(ev, ...args);
            }
            emitUntyped(ev, ...args) {
                return super.emit(ev, ...args);
            }
            listeners(event) {
                return super.listeners(event);
            }
        }
        exports1.StrictEventEmitter = StrictEventEmitter;
    },
    "../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/uws.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
                default: mod
            };
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.patchAdapter = patchAdapter;
        exports1.restoreAdapter = restoreAdapter;
        exports1.serveFile = serveFile;
        const socket_io_adapter_1 = __webpack_require__("../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/index.js");
        const fs_1 = __webpack_require__("fs");
        const debug_1 = __importDefault(__webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js"));
        const debug = (0, debug_1.default)("socket.io:adapter-uws");
        const SEPARATOR = "\x1f";
        const { addAll, del, broadcast } = socket_io_adapter_1.Adapter.prototype;
        function patchAdapter(app) {
            socket_io_adapter_1.Adapter.prototype.addAll = function(id, rooms) {
                const isNew = !this.sids.has(id);
                addAll.call(this, id, rooms);
                const socket = this.nsp.sockets.get(id) || this.nsp._preConnectSockets.get(id);
                if (!socket) return;
                if ("websocket" === socket.conn.transport.name) return void subscribe(this.nsp.name, socket, isNew, rooms);
                if (isNew) socket.conn.on("upgrade", ()=>{
                    const rooms = this.sids.get(id);
                    if (rooms) subscribe(this.nsp.name, socket, isNew, rooms);
                });
            };
            socket_io_adapter_1.Adapter.prototype.del = function(id, room) {
                del.call(this, id, room);
                const socket = this.nsp.sockets.get(id) || this.nsp._preConnectSockets.get(id);
                if (socket && "websocket" === socket.conn.transport.name) {
                    const sessionId = socket.conn.id;
                    const websocket = socket.conn.transport.socket;
                    const topic = `${this.nsp.name}${SEPARATOR}${room}`;
                    debug("unsubscribe connection %s from topic %s", sessionId, topic);
                    websocket.unsubscribe(topic);
                }
            };
            socket_io_adapter_1.Adapter.prototype.broadcast = function(packet, opts) {
                const useFastPublish = opts.rooms.size <= 1 && 0 === opts.except.size;
                if (!useFastPublish) return void broadcast.call(this, packet, opts);
                const flags = opts.flags || {};
                const basePacketOpts = {
                    preEncoded: true,
                    volatile: flags.volatile,
                    compress: flags.compress
                };
                packet.nsp = this.nsp.name;
                const encodedPackets = this.encoder.encode(packet);
                const topic = 0 === opts.rooms.size ? this.nsp.name : `${this.nsp.name}${SEPARATOR}${opts.rooms.keys().next().value}`;
                debug("fast publish to %s", topic);
                encodedPackets.forEach((encodedPacket)=>{
                    const isBinary = "string" != typeof encodedPacket;
                    app.publish(topic, isBinary ? encodedPacket : "4" + encodedPacket, isBinary);
                });
                this.apply(opts, (socket)=>{
                    if ("websocket" !== socket.conn.transport.name) socket.client.writeToEngine(encodedPackets, basePacketOpts);
                });
            };
        }
        function subscribe(namespaceName, socket, isNew, rooms) {
            const sessionId = socket.conn.id;
            const websocket = socket.conn.transport.socket;
            if (isNew) {
                debug("subscribe connection %s to topic %s", sessionId, namespaceName);
                websocket.subscribe(namespaceName);
            }
            rooms.forEach((room)=>{
                const topic = `${namespaceName}${SEPARATOR}${room}`;
                debug("subscribe connection %s to topic %s", sessionId, topic);
                websocket.subscribe(topic);
            });
        }
        function restoreAdapter() {
            socket_io_adapter_1.Adapter.prototype.addAll = addAll;
            socket_io_adapter_1.Adapter.prototype.del = del;
            socket_io_adapter_1.Adapter.prototype.broadcast = broadcast;
        }
        const toArrayBuffer = (buffer)=>{
            const { buffer: arrayBuffer, byteOffset, byteLength } = buffer;
            return arrayBuffer.slice(byteOffset, byteOffset + byteLength);
        };
        function serveFile(res, filepath) {
            const { size } = (0, fs_1.statSync)(filepath);
            const readStream = (0, fs_1.createReadStream)(filepath);
            const destroyReadStream = ()=>!readStream.destroyed && readStream.destroy();
            const onError = (error)=>{
                destroyReadStream();
                throw error;
            };
            const onDataChunk = (chunk)=>{
                const arrayBufferChunk = toArrayBuffer(chunk);
                res.cork(()=>{
                    const lastOffset = res.getWriteOffset();
                    const [ok, done] = res.tryEnd(arrayBufferChunk, size);
                    if (!done && !ok) {
                        readStream.pause();
                        res.onWritable((offset)=>{
                            const [ok, done] = res.tryEnd(arrayBufferChunk.slice(offset - lastOffset), size);
                            if (!done && ok) readStream.resume();
                            return ok;
                        });
                    }
                });
            };
            res.onAborted(destroyReadStream);
            readStream.on("data", onDataChunk).on("error", onError).on("end", destroyReadStream);
        }
    },
    "../node_modules/.pnpm/@agent-infra+logger@0.0.2-beta.2/node_modules/@agent-infra/logger/dist/index.mjs": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            in: ()=>types_LogLevel,
            kw: ()=>ConsoleLogger
        });
        var types_LogLevel = /*#__PURE__*/ function(LogLevel) {
            LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
            LogLevel[LogLevel["INFO"] = 1] = "INFO";
            LogLevel[LogLevel["SUCCESS"] = 2] = "SUCCESS";
            LogLevel[LogLevel["WARN"] = 3] = "WARN";
            LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
            LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
            return LogLevel;
        }({});
        class BaseLogger {
            log(...args) {}
            info(...args) {}
            warn(...args) {}
            error(...args) {}
            debug(...args) {}
            success(message) {}
            infoWithData(message, data, transformer) {}
            spawn(subPrefix) {
                return new BaseLogger();
            }
            setLevel(level) {}
            getLevel() {
                return 1;
            }
        }
        new BaseLogger();
        var _process_stdout;
        const colorize_isBrowser = 'undefined' != typeof window && void 0 !== window.document;
        const supportsColor = !colorize_isBrowser && !('NO_COLOR' in process.env || '0' === process.env.FORCE_COLOR) && (void 0 !== process.env.FORCE_COLOR || (null == (_process_stdout = process.stdout) ? void 0 : _process_stdout.isTTY));
        const ANSI_COLORS = {
            black: '\x1b[30m',
            red: '\x1b[31m',
            green: '\x1b[32m',
            yellow: '\x1b[33m',
            blue: '\x1b[34m',
            magenta: '\x1b[35m',
            cyan: '\x1b[36m',
            white: '\x1b[37m',
            gray: '\x1b[90m',
            reset: '\x1b[0m'
        };
        const ANSI_STYLES = {
            bold: '\x1b[1m',
            normal: ''
        };
        const CSS_COLOR_VALUES = {
            black: '#1E1E2E',
            red: '#F87171',
            green: '#10B981',
            yellow: '#FBBF24',
            blue: '#3B82F6',
            magenta: '#A78BFA',
            cyan: '#06B6D4',
            white: '#F3F4F6',
            gray: '#9CA3AF',
            reset: 'inherit'
        };
        const CSS_COLORS = {};
        Object.entries(CSS_COLOR_VALUES).forEach(([key, value])=>{
            CSS_COLORS[key] = `color: ${value}`;
        });
        function colorize(text, color, style = 'normal') {
            if (!text) return text;
            if (colorize_isBrowser) return text;
            if (supportsColor) {
                let result = text;
                if ('normal' !== style) result = `${ANSI_STYLES[style]}${result}`;
                result = `${ANSI_COLORS[color]}${result}`;
                return `${result}${ANSI_COLORS.reset}`;
            }
            return text;
        }
        function _define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class ConsoleLogger extends BaseLogger {
            colorPrefix(prefix, type) {
                if (!prefix) return '';
                let color = 'gray';
                switch(type){
                    case 'info':
                        color = 'blue';
                        break;
                    case 'warn':
                        color = 'yellow';
                        break;
                    case 'error':
                        color = 'red';
                        break;
                    case 'debug':
                        color = 'gray';
                        break;
                    case 'success':
                        color = 'green';
                        break;
                }
                const isBrowser = 'undefined' != typeof window && void 0 !== window.document;
                if (isBrowser) {
                    this.lastPrefixColor = color;
                    return prefix;
                }
                return colorize(prefix, color, 'bold');
            }
            log(...args) {
                if (this.level <= types_LogLevel.DEBUG) console.log(this.colorPrefix(this.prefix), ...args);
            }
            info(...args) {
                if (this.level <= types_LogLevel.INFO) {
                    const prefix = this.colorPrefix(this.prefix, 'info');
                    if ('undefined' != typeof window && this.lastPrefixColor) {
                        console.log(`%c${prefix}%c`, `color: ${CSS_COLOR_VALUES[this.lastPrefixColor]}; font-weight: bold`, 'color: inherit', ...args);
                        this.lastPrefixColor = null;
                    } else console.log(`${prefix}`, ...args);
                }
            }
            warn(...args) {
                if (this.level <= types_LogLevel.WARN) {
                    const prefix = this.colorPrefix(this.prefix, 'warn');
                    if ('undefined' != typeof window && this.lastPrefixColor) {
                        console.warn(`%c${prefix}%c`, `color: ${CSS_COLOR_VALUES[this.lastPrefixColor]}; font-weight: bold`, 'color: inherit', ...args);
                        this.lastPrefixColor = null;
                    } else console.warn(`${prefix}`, ...args);
                }
            }
            error(...args) {
                if (this.level <= types_LogLevel.ERROR) {
                    const prefix = this.colorPrefix(this.prefix, 'error');
                    if ('undefined' != typeof window && this.lastPrefixColor) {
                        console.error(`%c${prefix}%c`, `color: ${CSS_COLOR_VALUES[this.lastPrefixColor]}; font-weight: bold`, 'color: inherit', ...args);
                        this.lastPrefixColor = null;
                    } else console.error(`${prefix}`, ...args);
                }
            }
            success(message) {
                if (this.level <= types_LogLevel.SUCCESS) {
                    const prefix = this.colorPrefix(this.prefix, 'success');
                    if ('undefined' != typeof window && this.lastPrefixColor) {
                        console.log(`%c${prefix}%c ${message}`, `color: ${CSS_COLOR_VALUES[this.lastPrefixColor]}; font-weight: bold`, 'color: inherit');
                        this.lastPrefixColor = null;
                    } else console.log(`${prefix} ${message}`);
                }
            }
            debug(...args) {
                if (this.level <= types_LogLevel.DEBUG) {
                    const prefix = this.colorPrefix(this.prefix, 'debug');
                    if ('undefined' != typeof window && this.lastPrefixColor) {
                        console.debug(`%c${prefix}%c`, `color: ${CSS_COLOR_VALUES[this.lastPrefixColor]}; font-weight: bold`, 'color: inherit', ...args);
                        this.lastPrefixColor = null;
                    } else console.debug(`${prefix}`, ...args);
                }
            }
            infoWithData(message, data, transformer) {
                if (this.level <= types_LogLevel.INFO) {
                    this.info(message);
                    if (data) console.log(transformer ? transformer(data) : data);
                }
            }
            spawn(prefix) {
                const newPrefix = this.prefix ? `${this.prefix}:${prefix}` : prefix;
                return new ConsoleLogger(newPrefix, this.level);
            }
            setLevel(level) {
                this.level = level;
            }
            getLevel() {
                return this.level;
            }
            constructor(prefix = '', level = types_LogLevel.INFO){
                super(), _define_property(this, "prefix", void 0), _define_property(this, "lastPrefixColor", null), _define_property(this, "level", types_LogLevel.INFO);
                this.prefix = prefix;
                this.level = level;
            }
        }
    },
    "../node_modules/.pnpm/@socket.io+component-emitter@3.1.2/node_modules/@socket.io/component-emitter/lib/esm/index.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, {
            Emitter: ()=>Emitter
        });
        function Emitter(obj) {
            if (obj) return mixin(obj);
        }
        function mixin(obj) {
            for(var key in Emitter.prototype)obj[key] = Emitter.prototype[key];
            return obj;
        }
        Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
            this._callbacks = this._callbacks || {};
            (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
            return this;
        };
        Emitter.prototype.once = function(event, fn) {
            function on() {
                this.off(event, on);
                fn.apply(this, arguments);
            }
            on.fn = fn;
            this.on(event, on);
            return this;
        };
        Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
            this._callbacks = this._callbacks || {};
            if (0 == arguments.length) {
                this._callbacks = {};
                return this;
            }
            var callbacks = this._callbacks['$' + event];
            if (!callbacks) return this;
            if (1 == arguments.length) {
                delete this._callbacks['$' + event];
                return this;
            }
            var cb;
            for(var i = 0; i < callbacks.length; i++){
                cb = callbacks[i];
                if (cb === fn || cb.fn === fn) {
                    callbacks.splice(i, 1);
                    break;
                }
            }
            if (0 === callbacks.length) delete this._callbacks['$' + event];
            return this;
        };
        Emitter.prototype.emit = function(event) {
            this._callbacks = this._callbacks || {};
            var args = new Array(arguments.length - 1), callbacks = this._callbacks['$' + event];
            for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
            if (callbacks) {
                callbacks = callbacks.slice(0);
                for(var i = 0, len = callbacks.length; i < len; ++i)callbacks[i].apply(this, args);
            }
            return this;
        };
        Emitter.prototype.emitReserved = Emitter.prototype.emit;
        Emitter.prototype.listeners = function(event) {
            this._callbacks = this._callbacks || {};
            return this._callbacks['$' + event] || [];
        };
        Emitter.prototype.hasListeners = function(event) {
            return !!this.listeners(event).length;
        };
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/big5-added.json": function(module) {
        "use strict";
        module.exports = JSON.parse('[["8740","䏰䰲䘃䖦䕸𧉧䵷䖳𧲱䳢𧳅㮕䜶䝄䱇䱀𤊿𣘗𧍒𦺋𧃒䱗𪍑䝏䗚䲅𧱬䴇䪤䚡𦬣爥𥩔𡩣𣸆𣽡晍囻"],["8767","綕夝𨮹㷴霴𧯯寛𡵞媤㘥𩺰嫑宷峼杮薓𩥅瑡璝㡵𡵓𣚞𦀡㻬"],["87a1","𥣞㫵竼龗𤅡𨤍𣇪𠪊𣉞䌊蒄龖鐯䤰蘓墖靊鈘秐稲晠権袝瑌篅枂稬剏遆㓦珄𥶹瓆鿇垳䤯呌䄱𣚎堘穲𧭥讏䚮𦺈䆁𥶙箮𢒼鿈𢓁𢓉𢓌鿉蔄𣖻䂴鿊䓡𪷿拁灮鿋"],["8840","㇀",4,"𠄌㇅𠃑𠃍㇆㇇𠃋𡿨㇈𠃊㇉㇊㇋㇌𠄎㇍㇎ĀÁǍÀĒÉĚÈŌÓǑÒ࿿Ê̄Ế࿿Ê̌ỀÊāáǎàɑēéěèīíǐìōóǒòūúǔùǖǘǚ"],["88a1","ǜü࿿ê̄ế࿿ê̌ềêɡ⏚⏛"],["8940","𪎩𡅅"],["8943","攊"],["8946","丽滝鵎釟"],["894c","𧜵撑会伨侨兖兴农凤务动医华发变团声处备夲头学实実岚庆总斉柾栄桥济炼电纤纬纺织经统缆缷艺苏药视设询车轧轮"],["89a1","琑糼緍楆竉刧"],["89ab","醌碸酞肼"],["89b0","贋胶𠧧"],["89b5","肟黇䳍鷉鸌䰾𩷶𧀎鸊𪄳㗁"],["89c1","溚舾甙"],["89c5","䤑马骏龙禇𨑬𡷊𠗐𢫦两亁亀亇亿仫伷㑌侽㹈倃傈㑽㒓㒥円夅凛凼刅争剹劐匧㗇厩㕑厰㕓参吣㕭㕲㚁咓咣咴咹哐哯唘唣唨㖘唿㖥㖿嗗㗅"],["8a40","𧶄唥"],["8a43","𠱂𠴕𥄫喐𢳆㧬𠍁蹆𤶸𩓥䁓𨂾睺𢰸㨴䟕𨅝𦧲𤷪擝𠵼𠾴𠳕𡃴撍蹾𠺖𠰋𠽤𢲩𨉖𤓓"],["8a64","𠵆𩩍𨃩䟴𤺧𢳂骲㩧𩗴㿭㔆𥋇𩟔𧣈𢵄鵮頕"],["8a76","䏙𦂥撴哣𢵌𢯊𡁷㧻𡁯"],["8aa1","𦛚𦜖𧦠擪𥁒𠱃蹨𢆡𨭌𠜱"],["8aac","䠋𠆩㿺塳𢶍"],["8ab2","𤗈𠓼𦂗𠽌𠶖啹䂻䎺"],["8abb","䪴𢩦𡂝膪飵𠶜捹㧾𢝵跀嚡摼㹃"],["8ac9","𪘁𠸉𢫏𢳉"],["8ace","𡃈𣧂㦒㨆𨊛㕸𥹉𢃇噒𠼱𢲲𩜠㒼氽𤸻"],["8adf","𧕴𢺋𢈈𪙛𨳍𠹺𠰴𦠜羓𡃏𢠃𢤹㗻𥇣𠺌𠾍𠺪㾓𠼰𠵇𡅏𠹌"],["8af6","𠺫𠮩𠵈𡃀𡄽㿹𢚖搲𠾭"],["8b40","𣏴𧘹𢯎𠵾𠵿𢱑𢱕㨘𠺘𡃇𠼮𪘲𦭐𨳒𨶙𨳊閪哌苄喹"],["8b55","𩻃鰦骶𧝞𢷮煀腭胬尜𦕲脴㞗卟𨂽醶𠻺𠸏𠹷𠻻㗝𤷫㘉𠳖嚯𢞵𡃉𠸐𠹸𡁸𡅈𨈇𡑕𠹹𤹐𢶤婔𡀝𡀞𡃵𡃶垜𠸑"],["8ba1","𧚔𨋍𠾵𠹻𥅾㜃𠾶𡆀𥋘𪊽𤧚𡠺𤅷𨉼墙剨㘚𥜽箲孨䠀䬬鼧䧧鰟鮍𥭴𣄽嗻㗲嚉丨夂𡯁屮靑𠂆乛亻㔾尣彑忄㣺扌攵歺氵氺灬爫丬犭𤣩罒礻糹罓𦉪㓁"],["8bde","𦍋耂肀𦘒𦥑卝衤见𧢲讠贝钅镸长门𨸏韦页风飞饣𩠐鱼鸟黄歯龜丷𠂇阝户钢"],["8c40","倻淾𩱳龦㷉袏𤅎灷峵䬠𥇍㕙𥴰愢𨨲辧釶熑朙玺𣊁𪄇㲋𡦀䬐磤琂冮𨜏䀉橣𪊺䈣蘏𠩯稪𩥇𨫪靕灍匤𢁾鏴盙𨧣龧矝亣俰傼丯众龨吴綋墒壐𡶶庒庙忂𢜒斋"],["8ca1","𣏹椙橃𣱣泿"],["8ca7","爀𤔅玌㻛𤨓嬕璹讃𥲤𥚕窓篬糃繬苸薗龩袐龪躹龫迏蕟駠鈡龬𨶹𡐿䁱䊢娚"],["8cc9","顨杫䉶圽"],["8cce","藖𤥻芿𧄍䲁𦵴嵻𦬕𦾾龭龮宖龯曧繛湗秊㶈䓃𣉖𢞖䎚䔶"],["8ce6","峕𣬚諹屸㴒𣕑嵸龲煗䕘𤃬𡸣䱷㥸㑊𠆤𦱁諌侴𠈹妿腬顖𩣺弻"],["8d40","𠮟"],["8d42","𢇁𨥭䄂䚻𩁹㼇龳𪆵䃸㟖䛷𦱆䅼𨚲𧏿䕭㣔𥒚䕡䔛䶉䱻䵶䗪㿈𤬏㙡䓞䒽䇭崾嵈嵖㷼㠏嶤嶹㠠㠸幂庽弥徃㤈㤔㤿㥍惗愽峥㦉憷憹懏㦸戬抐拥挘㧸嚱"],["8da1","㨃揢揻搇摚㩋擀崕嘡龟㪗斆㪽旿晓㫲暒㬢朖㭂枤栀㭘桊梄㭲㭱㭻椉楃牜楤榟榅㮼槖㯝橥橴橱檂㯬檙㯲檫檵櫔櫶殁毁毪汵沪㳋洂洆洦涁㳯涤涱渕渘温溆𨧀溻滢滚齿滨滩漤漴㵆𣽁澁澾㵪㵵熷岙㶊瀬㶑灐灔灯灿炉𠌥䏁㗱𠻘"],["8e40","𣻗垾𦻓焾𥟠㙎榢𨯩孴穉𥣡𩓙穥穽𥦬窻窰竂竃燑𦒍䇊竚竝竪䇯咲𥰁笋筕笩𥌎𥳾箢筯莜𥮴𦱿篐萡箒箸𥴠㶭𥱥蒒篺簆簵𥳁籄粃𤢂粦晽𤕸糉糇糦籴糳糵糎"],["8ea1","繧䔝𦹄絝𦻖璍綉綫焵綳緒𤁗𦀩緤㴓緵𡟹緥𨍭縝𦄡𦅚繮纒䌫鑬縧罀罁罇礶𦋐駡羗𦍑羣𡙡𠁨䕜𣝦䔃𨌺翺𦒉者耈耝耨耯𪂇𦳃耻耼聡𢜔䦉𦘦𣷣𦛨朥肧𨩈脇脚墰𢛶汿𦒘𤾸擧𡒊舘𡡞橓𤩥𤪕䑺舩𠬍𦩒𣵾俹𡓽蓢荢𦬊𤦧𣔰𡝳𣷸芪椛芳䇛"],["8f40","蕋苐茚𠸖𡞴㛁𣅽𣕚艻苢茘𣺋𦶣𦬅𦮗𣗎㶿茝嗬莅䔋𦶥莬菁菓㑾𦻔橗蕚㒖𦹂𢻯葘𥯤葱㷓䓤檧葊𣲵祘蒨𦮖𦹷𦹃蓞萏莑䒠蒓蓤𥲑䉀𥳀䕃蔴嫲𦺙䔧蕳䔖枿蘖"],["8fa1","𨘥𨘻藁𧂈蘂𡖂𧃍䕫䕪蘨㙈𡢢号𧎚虾蝱𪃸蟮𢰧螱蟚蠏噡虬桖䘏衅衆𧗠𣶹𧗤衞袜䙛袴袵揁装睷𧜏覇覊覦覩覧覼𨨥觧𧤤𧪽誜瞓釾誐𧩙竩𧬺𣾏䜓𧬸煼謌謟𥐰𥕥謿譌譍誩𤩺讐讛誯𡛟䘕衏貛𧵔𧶏貫㜥𧵓賖𧶘𧶽贒贃𡤐賛灜贑𤳉㻐起"],["9040","趩𨀂𡀔𤦊㭼𨆼𧄌竧躭躶軃鋔輙輭𨍥𨐒辥錃𪊟𠩐辳䤪𨧞𨔽𣶻廸𣉢迹𪀔𨚼𨔁𢌥㦀𦻗逷𨔼𧪾遡𨕬𨘋邨𨜓郄𨛦邮都酧㫰醩釄粬𨤳𡺉鈎沟鉁鉢𥖹銹𨫆𣲛𨬌𥗛"],["90a1","𠴱錬鍫𨫡𨯫炏嫃𨫢𨫥䥥鉄𨯬𨰹𨯿鍳鑛躼閅閦鐦閠濶䊹𢙺𨛘𡉼𣸮䧟氜陻隖䅬隣𦻕懚隶磵𨫠隽双䦡𦲸𠉴𦐐𩂯𩃥𤫑𡤕𣌊霱虂霶䨏䔽䖅𤫩灵孁霛靜𩇕靗孊𩇫靟鐥僐𣂷𣂼鞉鞟鞱鞾韀韒韠𥑬韮琜𩐳響韵𩐝𧥺䫑頴頳顋顦㬎𧅵㵑𠘰𤅜"],["9140","𥜆飊颷飈飇䫿𦴧𡛓喰飡飦飬鍸餹𤨩䭲𩡗𩤅駵騌騻騐驘𥜥㛄𩂱𩯕髠髢𩬅髴䰎鬔鬭𨘀倴鬴𦦨㣃𣁽魐魀𩴾婅𡡣鮎𤉋鰂鯿鰌𩹨鷔𩾷𪆒𪆫𪃡𪄣𪇟鵾鶃𪄴鸎梈"],["91a1","鷄𢅛𪆓𪈠𡤻𪈳鴹𪂹𪊴麐麕麞麢䴴麪麯𤍤黁㭠㧥㴝伲㞾𨰫鼂鼈䮖鐤𦶢鼗鼖鼹嚟嚊齅馸𩂋韲葿齢齩竜龎爖䮾𤥵𤦻煷𤧸𤍈𤩑玞𨯚𡣺禟𨥾𨸶鍩鏳𨩄鋬鎁鏋𨥬𤒹爗㻫睲穃烐𤑳𤏸煾𡟯炣𡢾𣖙㻇𡢅𥐯𡟸㜢𡛻𡠹㛡𡝴𡣑𥽋㜣𡛀坛𤨥𡏾𡊨"],["9240","𡏆𡒶蔃𣚦蔃葕𤦔𧅥𣸱𥕜𣻻𧁒䓴𣛮𩦝𦼦柹㜳㰕㷧塬𡤢栐䁗𣜿𤃡𤂋𤄏𦰡哋嚞𦚱嚒𠿟𠮨𠸍鏆𨬓鎜仸儫㠙𤐶亼𠑥𠍿佋侊𥙑婨𠆫𠏋㦙𠌊𠐔㐵伩𠋀𨺳𠉵諚𠈌亘"],["92a1","働儍侢伃𤨎𣺊佂倮偬傁俌俥偘僼兙兛兝兞湶𣖕𣸹𣺿浲𡢄𣺉冨凃𠗠䓝𠒣𠒒𠒑赺𨪜𠜎剙劤𠡳勡鍮䙺熌𤎌𠰠𤦬𡃤槑𠸝瑹㻞璙琔瑖玘䮎𤪼𤂍叐㖄爏𤃉喴𠍅响𠯆圝鉝雴鍦埝垍坿㘾壋媙𨩆𡛺𡝯𡜐娬妸銏婾嫏娒𥥆𡧳𡡡𤊕㛵洅瑃娡𥺃"],["9340","媁𨯗𠐓鏠璌𡌃焅䥲鐈𨧻鎽㞠尞岞幞幈𡦖𡥼𣫮廍孏𡤃𡤄㜁𡢠㛝𡛾㛓脪𨩇𡶺𣑲𨦨弌弎𡤧𡞫婫𡜻孄蘔𧗽衠恾𢡠𢘫忛㺸𢖯𢖾𩂈𦽳懀𠀾𠁆𢘛憙憘恵𢲛𢴇𤛔𩅍"],["93a1","摱𤙥𢭪㨩𢬢𣑐𩣪𢹸挷𪑛撶挱揑𤧣𢵧护𢲡搻敫楲㯴𣂎𣊭𤦉𣊫唍𣋠𡣙𩐿曎𣊉𣆳㫠䆐𥖄𨬢𥖏𡛼𥕛𥐥磮𣄃𡠪𣈴㑤𣈏𣆂𤋉暎𦴤晫䮓昰𧡰𡷫晣𣋒𣋡昞𥡲㣑𣠺𣞼㮙𣞢𣏾瓐㮖枏𤘪梶栞㯄檾㡣𣟕𤒇樳橒櫉欅𡤒攑梘橌㯗橺歗𣿀𣲚鎠鋲𨯪𨫋"],["9440","銉𨀞𨧜鑧涥漋𤧬浧𣽿㶏渄𤀼娽渊塇洤硂焻𤌚𤉶烱牐犇犔𤞏𤜥兹𤪤𠗫瑺𣻸𣙟𤩊𤤗𥿡㼆㺱𤫟𨰣𣼵悧㻳瓌琼鎇琷䒟𦷪䕑疃㽣𤳙𤴆㽘畕癳𪗆㬙瑨𨫌𤦫𤦎㫻"],["94a1","㷍𤩎㻿𤧅𤣳釺圲鍂𨫣𡡤僟𥈡𥇧睸𣈲眎眏睻𤚗𣞁㩞𤣰琸璛㺿𤪺𤫇䃈𤪖𦆮錇𥖁砞碍碈磒珐祙𧝁𥛣䄎禛蒖禥樭𣻺稺秴䅮𡛦䄲鈵秱𠵌𤦌𠊙𣶺𡝮㖗啫㕰㚪𠇔𠰍竢婙𢛵𥪯𥪜娍𠉛磰娪𥯆竾䇹籝籭䈑𥮳𥺼𥺦糍𤧹𡞰粎籼粮檲緜縇緓罎𦉡"],["9540","𦅜𧭈綗𥺂䉪𦭵𠤖柖𠁎𣗏埄𦐒𦏸𤥢翝笧𠠬𥫩𥵃笌𥸎駦虅驣樜𣐿㧢𤧷𦖭騟𦖠蒀𧄧𦳑䓪脷䐂胆脉腂𦞴飃𦩂艢艥𦩑葓𦶧蘐𧈛媆䅿𡡀嬫𡢡嫤𡣘蚠蜨𣶏蠭𧐢娂"],["95a1","衮佅袇袿裦襥襍𥚃襔𧞅𧞄𨯵𨯙𨮜𨧹㺭蒣䛵䛏㟲訽訜𩑈彍鈫𤊄旔焩烄𡡅鵭貟賩𧷜妚矃姰䍮㛔踪躧𤰉輰轊䋴汘澻𢌡䢛潹溋𡟚鯩㚵𤤯邻邗啱䤆醻鐄𨩋䁢𨫼鐧𨰝𨰻蓥訫閙閧閗閖𨴴瑅㻂𤣿𤩂𤏪㻧𣈥随𨻧𨹦𨹥㻌𤧭𤩸𣿮琒瑫㻼靁𩂰"],["9640","桇䨝𩂓𥟟靝鍨𨦉𨰦𨬯𦎾銺嬑譩䤼珹𤈛鞛靱餸𠼦巁𨯅𤪲頟𩓚鋶𩗗釥䓀𨭐𤩧𨭤飜𨩅㼀鈪䤥萔餻饍𧬆㷽馛䭯馪驜𨭥𥣈檏騡嫾騯𩣱䮐𩥈馼䮽䮗鍽塲𡌂堢𤦸"],["96a1","𡓨硄𢜟𣶸棅㵽鑘㤧慐𢞁𢥫愇鱏鱓鱻鰵鰐魿鯏𩸭鮟𪇵𪃾鴡䲮𤄄鸘䲰鴌𪆴𪃭𪃳𩤯鶥蒽𦸒𦿟𦮂藼䔳𦶤𦺄𦷰萠藮𦸀𣟗𦁤秢𣖜𣙀䤭𤧞㵢鏛銾鍈𠊿碹鉷鑍俤㑀遤𥕝砽硔碶硋𡝗𣇉𤥁㚚佲濚濙瀞瀞吔𤆵垻壳垊鴖埗焴㒯𤆬燫𦱀𤾗嬨𡞵𨩉"],["9740","愌嫎娋䊼𤒈㜬䭻𨧼鎻鎸𡣖𠼝葲𦳀𡐓𤋺𢰦𤏁妔𣶷𦝁綨𦅛𦂤𤦹𤦋𨧺鋥珢㻩璴𨭣𡢟㻡𤪳櫘珳珻㻖𤨾𤪔𡟙𤩦𠎧𡐤𤧥瑈𤤖炥𤥶銄珦鍟𠓾錱𨫎𨨖鎆𨯧𥗕䤵𨪂煫"],["97a1","𤥃𠳿嚤𠘚𠯫𠲸唂秄𡟺緾𡛂𤩐𡡒䔮鐁㜊𨫀𤦭妰𡢿𡢃𧒄媡㛢𣵛㚰鉟婹𨪁𡡢鍴㳍𠪴䪖㦊僴㵩㵌𡎜煵䋻𨈘渏𩃤䓫浗𧹏灧沯㳖𣿭𣸭渂漌㵯𠏵畑㚼㓈䚀㻚䡱姄鉮䤾轁𨰜𦯀堒埈㛖𡑒烾𤍢𤩱𢿣𡊰𢎽梹楧𡎘𣓥𧯴𣛟𨪃𣟖𣏺𤲟樚𣚭𦲷萾䓟䓎"],["9840","𦴦𦵑𦲂𦿞漗𧄉茽𡜺菭𦲀𧁓𡟛妉媂𡞳婡婱𡤅𤇼㜭姯𡜼㛇熎鎐暚𤊥婮娫𤊓樫𣻹𧜶𤑛𤋊焝𤉙𨧡侰𦴨峂𤓎𧹍𤎽樌𤉖𡌄炦焳𤏩㶥泟勇𤩏繥姫崯㷳彜𤩝𡟟綤萦"],["98a1","咅𣫺𣌀𠈔坾𠣕𠘙㿥𡾞𪊶瀃𩅛嵰玏糓𨩙𩐠俈翧狍猐𧫴猸猹𥛶獁獈㺩𧬘遬燵𤣲珡臶㻊県㻑沢国琙琞琟㻢㻰㻴㻺瓓㼎㽓畂畭畲疍㽼痈痜㿀癍㿗癴㿜発𤽜熈嘣覀塩䀝睃䀹条䁅㗛瞘䁪䁯属瞾矋売砘点砜䂨砹硇硑硦葈𥔵礳栃礲䄃"],["9940","䄉禑禙辻稆込䅧窑䆲窼艹䇄竏竛䇏両筢筬筻簒簛䉠䉺类粜䊌粸䊔糭输烀𠳏総緔緐緽羮羴犟䎗耠耥笹耮耱联㷌垴炠肷胩䏭脌猪脎脒畠脔䐁㬹腖腙腚"],["99a1","䐓堺腼膄䐥膓䐭膥埯臁臤艔䒏芦艶苊苘苿䒰荗险榊萅烵葤惣蒈䔄蒾蓡蓸蔐蔸蕒䔻蕯蕰藠䕷虲蚒蚲蛯际螋䘆䘗袮裿褤襇覑𧥧訩訸誔誴豑賔賲贜䞘塟跃䟭仮踺嗘坔蹱嗵躰䠷軎転軤軭軲辷迁迊迌逳駄䢭飠鈓䤞鈨鉘鉫銱銮銿"],["9a40","鋣鋫鋳鋴鋽鍃鎄鎭䥅䥑麿鐗匁鐝鐭鐾䥪鑔鑹锭関䦧间阳䧥枠䨤靀䨵鞲韂噔䫤惨颹䬙飱塄餎餙冴餜餷饂饝饢䭰駅䮝騼鬏窃魩鮁鯝鯱鯴䱭鰠㝯𡯂鵉鰺"],["9aa1","黾噐鶓鶽鷀鷼银辶鹻麬麱麽黆铜黢黱黸竈齄𠂔𠊷𠎠椚铃妬𠓗塀铁㞹𠗕𠘕𠙶𡚺块煳𠫂𠫍𠮿呪吆𠯋咞𠯻𠰻𠱓𠱥𠱼惧𠲍噺𠲵𠳝𠳭𠵯𠶲𠷈楕鰯螥𠸄𠸎𠻗𠾐𠼭𠹳尠𠾼帋𡁜𡁏𡁶朞𡁻𡂈𡂖㙇𡂿𡃓𡄯𡄻卤蒭𡋣𡍵𡌶讁𡕷𡘙𡟃𡟇乸炻𡠭𡥪"],["9b40","𡨭𡩅𡰪𡱰𡲬𡻈拃𡻕𡼕熘桕𢁅槩㛈𢉼𢏗𢏺𢜪𢡱𢥏苽𢥧𢦓𢫕覥𢫨辠𢬎鞸𢬿顇骽𢱌"],["9b62","𢲈𢲷𥯨𢴈𢴒𢶷𢶕𢹂𢽴𢿌𣀳𣁦𣌟𣏞徱晈暿𧩹𣕧𣗳爁𤦺矗𣘚𣜖纇𠍆墵朎"],["9ba1","椘𣪧𧙗𥿢𣸑𣺹𧗾𢂚䣐䪸𤄙𨪚𤋮𤌍𤀻𤌴𤎖𤩅𠗊凒𠘑妟𡺨㮾𣳿𤐄𤓖垈𤙴㦛𤜯𨗨𩧉㝢𢇃譞𨭎駖𤠒𤣻𤨕爉𤫀𠱸奥𤺥𤾆𠝹軚𥀬劏圿煱𥊙𥐙𣽊𤪧喼𥑆𥑮𦭒釔㑳𥔿𧘲𥕞䜘𥕢𥕦𥟇𤤿𥡝偦㓻𣏌惞𥤃䝼𨥈𥪮𥮉𥰆𡶐垡煑澶𦄂𧰒遖𦆲𤾚譢𦐂𦑊"],["9c40","嵛𦯷輶𦒄𡤜諪𤧶𦒈𣿯𦔒䯀𦖿𦚵𢜛鑥𥟡憕娧晉侻嚹𤔡𦛼乪𤤴陖涏𦲽㘘襷𦞙𦡮𦐑𦡞營𦣇筂𩃀𠨑𦤦鄄𦤹穅鷰𦧺騦𦨭㙟𦑩𠀡禃𦨴𦭛崬𣔙菏𦮝䛐𦲤画补𦶮墶"],["9ca1","㜜𢖍𧁋𧇍㱔𧊀𧊅銁𢅺𧊋錰𧋦𤧐氹钟𧑐𠻸蠧裵𢤦𨑳𡞱溸𤨪𡠠㦤㚹尐秣䔿暶𩲭𩢤襃𧟌𧡘囖䃟𡘊㦡𣜯𨃨𡏅熭荦𧧝𩆨婧䲷𧂯𨦫𧧽𧨊𧬋𧵦𤅺筃祾𨀉澵𪋟樃𨌘厢𦸇鎿栶靝𨅯𨀣𦦵𡏭𣈯𨁈嶅𨰰𨂃圕頣𨥉嶫𤦈斾槕叒𤪥𣾁㰑朶𨂐𨃴𨄮𡾡𨅏"],["9d40","𨆉𨆯𨈚𨌆𨌯𨎊㗊𨑨𨚪䣺揦𨥖砈鉕𨦸䏲𨧧䏟𨧨𨭆𨯔姸𨰉輋𨿅𩃬筑𩄐𩄼㷷𩅞𤫊运犏嚋𩓧𩗩𩖰𩖸𩜲𩣑𩥉𩥪𩧃𩨨𩬎𩵚𩶛纟𩻸𩼣䲤镇𪊓熢𪋿䶑递𪗋䶜𠲜达嗁"],["9da1","辺𢒰边𤪓䔉繿潖檱仪㓤𨬬𧢝㜺躀𡟵𨀤𨭬𨮙𧨾𦚯㷫𧙕𣲷𥘵𥥖亚𥺁𦉘嚿𠹭踎孭𣺈𤲞揞拐𡟶𡡻攰嘭𥱊吚𥌑㷆𩶘䱽嘢嘞罉𥻘奵𣵀蝰东𠿪𠵉𣚺脗鵞贘瘻鱅癎瞹鍅吲腈苷嘥脲萘肽嗪祢噃吖𠺝㗎嘅嗱曱𨋢㘭甴嗰喺咗啲𠱁𠲖廐𥅈𠹶𢱢"],["9e40","𠺢麫絚嗞𡁵抝靭咔賍燶酶揼掹揾啩𢭃鱲𢺳冚㓟𠶧冧呍唞唓癦踭𦢊疱肶蠄螆裇膶萜𡃁䓬猄𤜆宐茋𦢓噻𢛴𧴯𤆣𧵳𦻐𧊶酰𡇙鈈𣳼𪚩𠺬𠻹牦𡲢䝎𤿂𧿹𠿫䃺"],["9ea1","鱝攟𢶠䣳𤟠𩵼𠿬𠸊恢𧖣𠿭"],["9ead","𦁈𡆇熣纎鵐业丄㕷嬍沲卧㚬㧜卽㚥𤘘墚𤭮舭呋垪𥪕𠥹"],["9ec5","㩒𢑥獴𩺬䴉鯭𣳾𩼰䱛𤾩𩖞𩿞葜𣶶𧊲𦞳𣜠挮紥𣻷𣸬㨪逈勌㹴㙺䗩𠒎癀嫰𠺶硺𧼮墧䂿噼鮋嵴癔𪐴麅䳡痹㟻愙𣃚𤏲"],["9ef5","噝𡊩垧𤥣𩸆刴𧂮㖭汊鵼"],["9f40","籖鬹埞𡝬屓擓𩓐𦌵𧅤蚭𠴨𦴢𤫢𠵱"],["9f4f","凾𡼏嶎霃𡷑麁遌笟鬂峑箣扨挵髿篏鬪籾鬮籂粆鰕篼鬉鼗鰛𤤾齚啳寃俽麘俲剠㸆勑坧偖妷帒韈鶫轜呩鞴饀鞺匬愰"],["9fa1","椬叚鰊鴂䰻陁榀傦畆𡝭駚剳"],["9fae","酙隁酜"],["9fb2","酑𨺗捿𦴣櫊嘑醎畺抅𠏼獏籰𥰡𣳽"],["9fc1","𤤙盖鮝个𠳔莾衂"],["9fc9","届槀僭坺刟巵从氱𠇲伹咜哚劚趂㗾弌㗳"],["9fdb","歒酼龥鮗頮颴骺麨麄煺笔"],["9fe7","毺蠘罸"],["9feb","嘠𪙊蹷齓"],["9ff0","跔蹏鸜踁抂𨍽踨蹵竓𤩷稾磘泪詧瘇"],["a040","𨩚鼦泎蟖痃𪊲硓咢贌狢獱謭猂瓱賫𤪻蘯徺袠䒷"],["a055","𡠻𦸅"],["a058","詾𢔛"],["a05b","惽癧髗鵄鍮鮏蟵"],["a063","蠏賷猬霡鮰㗖犲䰇籑饊𦅙慙䰄麖慽"],["a073","坟慯抦戹拎㩜懢厪𣏵捤栂㗒"],["a0a1","嵗𨯂迚𨸹"],["a0a6","僙𡵆礆匲阸𠼻䁥"],["a0ae","矾"],["a0b0","糂𥼚糚稭聦聣絍甅瓲覔舚朌聢𧒆聛瓰脃眤覉𦟌畓𦻑螩蟎臈螌詉貭譃眫瓸蓚㘵榲趦"],["a0d4","覩瑨涹蟁𤀑瓧㷛煶悤憜㳑煢恷"],["a0e2","罱𨬭牐惩䭾删㰘𣳇𥻗𧙖𥔱𡥄𡋾𩤃𦷜𧂭峁𦆭𨨏𣙷𠃮𦡆𤼎䕢嬟𦍌齐麦𦉫"],["a3c0","␀",31,"␡"],["c6a1","①",9,"⑴",9,"ⅰ",9,"丶丿亅亠冂冖冫勹匸卩厶夊宀巛⼳广廴彐彡攴无疒癶辵隶¨ˆヽヾゝゞ〃仝々〆〇ー［］✽ぁ",23],["c740","す",58,"ァアィイ"],["c7a1","ゥ",81,"А",5,"ЁЖ",4],["c840","Л",26,"ёж",25,"⇧↸↹㇏𠃌乚𠂊刂䒑"],["c8a1","龰冈龱𧘇"],["c8cd","￢￤＇＂㈱№℡゛゜⺀⺄⺆⺇⺈⺊⺌⺍⺕⺜⺝⺥⺧⺪⺬⺮⺶⺼⺾⻆⻊⻌⻍⻏⻖⻗⻞⻣"],["c8f5","ʃɐɛɔɵœøŋʊɪ"],["f9fe","￭"],["fa40","𠕇鋛𠗟𣿅蕌䊵珯况㙉𤥂𨧤鍄𡧛苮𣳈砼杄拟𤤳𨦪𠊠𦮳𡌅侫𢓭倈𦴩𧪄𣘀𤪱𢔓倩𠍾徤𠎀𠍇滛𠐟偽儁㑺儎顬㝃萖𤦤𠒇兠𣎴兪𠯿𢃼𠋥𢔰𠖎𣈳𡦃宂蝽𠖳𣲙冲冸"],["faa1","鴴凉减凑㳜凓𤪦决凢卂凭菍椾𣜭彻刋刦刼劵剗劔効勅簕蕂勠蘍𦬓包𨫞啉滙𣾀𠥔𣿬匳卄𠯢泋𡜦栛珕恊㺪㣌𡛨燝䒢卭却𨚫卾卿𡖖𡘓矦厓𨪛厠厫厮玧𥝲㽙玜叁叅汉义埾叙㪫𠮏叠𣿫𢶣叶𠱷吓灹唫晗浛呭𦭓𠵴啝咏咤䞦𡜍𠻝㶴𠵍"],["fb40","𨦼𢚘啇䳭启琗喆喩嘅𡣗𤀺䕒𤐵暳𡂴嘷曍𣊊暤暭噍噏磱囱鞇叾圀囯园𨭦㘣𡉏坆𤆥汮炋坂㚱𦱾埦𡐖堃𡑔𤍣堦𤯵塜墪㕡壠壜𡈼壻寿坃𪅐𤉸鏓㖡够梦㛃湙"],["fba1","𡘾娤啓𡚒蔅姉𠵎𦲁𦴪𡟜姙𡟻𡞲𦶦浱𡠨𡛕姹𦹅媫婣㛦𤦩婷㜈媖瑥嫓𦾡𢕔㶅𡤑㜲𡚸広勐孶斈孼𧨎䀄䡝𠈄寕慠𡨴𥧌𠖥寳宝䴐尅𡭄尓珎尔𡲥𦬨屉䣝岅峩峯嶋𡷹𡸷崐崘嵆𡺤岺巗苼㠭𤤁𢁉𢅳芇㠶㯂帮檊幵幺𤒼𠳓厦亷廐厨𡝱帉廴𨒂"],["fc40","廹廻㢠廼栾鐛弍𠇁弢㫞䢮𡌺强𦢈𢏐彘𢑱彣鞽𦹮彲鍀𨨶徧嶶㵟𥉐𡽪𧃸𢙨釖𠊞𨨩怱暅𡡷㥣㷇㘹垐𢞴祱㹀悞悤悳𤦂𤦏𧩓璤僡媠慤萤慂慈𦻒憁凴𠙖憇宪𣾷"],["fca1","𢡟懓𨮝𩥝懐㤲𢦀𢣁怣慜攞掋𠄘担𡝰拕𢸍捬𤧟㨗搸揸𡎎𡟼撐澊𢸶頔𤂌𥜝擡擥鑻㩦携㩗敍漖𤨨𤨣斅敭敟𣁾斵𤥀䬷旑䃘𡠩无旣忟𣐀昘𣇷𣇸晄𣆤𣆥晋𠹵晧𥇦晳晴𡸽𣈱𨗴𣇈𥌓矅𢣷馤朂𤎜𤨡㬫槺𣟂杞杧杢𤇍𩃭柗䓩栢湐鈼栁𣏦𦶠桝"],["fd40","𣑯槡樋𨫟楳棃𣗍椁椀㴲㨁𣘼㮀枬楡𨩊䋼椶榘㮡𠏉荣傐槹𣙙𢄪橅𣜃檝㯳枱櫈𩆜㰍欝𠤣惞欵歴𢟍溵𣫛𠎵𡥘㝀吡𣭚毡𣻼毜氷𢒋𤣱𦭑汚舦汹𣶼䓅𣶽𤆤𤤌𤤀"],["fda1","𣳉㛥㳫𠴲鮃𣇹𢒑羏样𦴥𦶡𦷫涖浜湼漄𤥿𤂅𦹲蔳𦽴凇沜渝萮𨬡港𣸯瑓𣾂秌湏媑𣁋濸㜍澝𣸰滺𡒗𤀽䕕鏰潄潜㵎潴𩅰㴻澟𤅄濓𤂑𤅕𤀹𣿰𣾴𤄿凟𤅖𤅗𤅀𦇝灋灾炧炁烌烕烖烟䄄㷨熴熖𤉷焫煅媈煊煮岜𤍥煏鍢𤋁焬𤑚𤨧𤨢熺𨯨炽爎"],["fe40","鑂爕夑鑃爤鍁𥘅爮牀𤥴梽牕牗㹕𣁄栍漽犂猪猫𤠣𨠫䣭𨠄猨献珏玪𠰺𦨮珉瑉𤇢𡛧𤨤昣㛅𤦷𤦍𤧻珷琕椃𤨦琹𠗃㻗瑜𢢭瑠𨺲瑇珤瑶莹瑬㜰瑴鏱樬璂䥓𤪌"],["fea1","𤅟𤩹𨮏孆𨰃𡢞瓈𡦈甎瓩甞𨻙𡩋寗𨺬鎅畍畊畧畮𤾂㼄𤴓疎瑝疞疴瘂瘬癑癏癯癶𦏵皐臯㟸𦤑𦤎皡皥皷盌𦾟葢𥂝𥅽𡸜眞眦着撯𥈠睘𣊬瞯𨥤𨥨𡛁矴砉𡍶𤨒棊碯磇磓隥礮𥗠磗礴碱𧘌辸袄𨬫𦂃𢘜禆褀椂禀𥡗禝𧬹礼禩渪𧄦㺨秆𩄍秔"]]');
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp936.json": function(module) {
        "use strict";
        module.exports = JSON.parse('[["0","\\u0000",127,"€"],["8140","丂丄丅丆丏丒丗丟丠両丣並丩丮丯丱丳丵丷丼乀乁乂乄乆乊乑乕乗乚乛乢乣乤乥乧乨乪",5,"乲乴",9,"乿",6,"亇亊"],["8180","亐亖亗亙亜亝亞亣亪亯亰亱亴亶亷亸亹亼亽亾仈仌仏仐仒仚仛仜仠仢仦仧仩仭仮仯仱仴仸仹仺仼仾伀伂",6,"伋伌伒",4,"伜伝伡伣伨伩伬伭伮伱伳伵伷伹伻伾",4,"佄佅佇",5,"佒佔佖佡佢佦佨佪佫佭佮佱佲併佷佸佹佺佽侀侁侂侅來侇侊侌侎侐侒侓侕侖侘侙侚侜侞侟価侢"],["8240","侤侫侭侰",4,"侶",8,"俀俁係俆俇俈俉俋俌俍俒",4,"俙俛俠俢俤俥俧俫俬俰俲俴俵俶俷俹俻俼俽俿",11],["8280","個倎倐們倓倕倖倗倛倝倞倠倢倣値倧倫倯",10,"倻倽倿偀偁偂偄偅偆偉偊偋偍偐",4,"偖偗偘偙偛偝",7,"偦",5,"偭",8,"偸偹偺偼偽傁傂傃傄傆傇傉傊傋傌傎",20,"傤傦傪傫傭",4,"傳",6,"傼"],["8340","傽",17,"僐",5,"僗僘僙僛",10,"僨僩僪僫僯僰僱僲僴僶",4,"僼",9,"儈"],["8380","儉儊儌",5,"儓",13,"儢",28,"兂兇兊兌兎兏児兒兓兗兘兙兛兝",4,"兣兤兦內兩兪兯兲兺兾兿冃冄円冇冊冋冎冏冐冑冓冔冘冚冝冞冟冡冣冦",4,"冭冮冴冸冹冺冾冿凁凂凃凅凈凊凍凎凐凒",5],["8440","凘凙凚凜凞凟凢凣凥",5,"凬凮凱凲凴凷凾刄刅刉刋刌刏刐刓刔刕刜刞刟刡刢刣別刦刧刪刬刯刱刲刴刵刼刾剄",5,"剋剎剏剒剓剕剗剘"],["8480","剙剚剛剝剟剠剢剣剤剦剨剫剬剭剮剰剱剳",9,"剾劀劃",4,"劉",6,"劑劒劔",6,"劜劤劥劦劧劮劯劰労",9,"勀勁勂勄勅勆勈勊勌勍勎勏勑勓勔動勗務",5,"勠勡勢勣勥",10,"勱",7,"勻勼勽匁匂匃匄匇匉匊匋匌匎"],["8540","匑匒匓匔匘匛匜匞匟匢匤匥匧匨匩匫匬匭匯",9,"匼匽區卂卄卆卋卌卍卐協単卙卛卝卥卨卪卬卭卲卶卹卻卼卽卾厀厁厃厇厈厊厎厏"],["8580","厐",4,"厖厗厙厛厜厞厠厡厤厧厪厫厬厭厯",6,"厷厸厹厺厼厽厾叀參",4,"収叏叐叒叓叕叚叜叝叞叡叢叧叴叺叾叿吀吂吅吇吋吔吘吙吚吜吢吤吥吪吰吳吶吷吺吽吿呁呂呄呅呇呉呌呍呎呏呑呚呝",4,"呣呥呧呩",7,"呴呹呺呾呿咁咃咅咇咈咉咊咍咑咓咗咘咜咞咟咠咡"],["8640","咢咥咮咰咲咵咶咷咹咺咼咾哃哅哊哋哖哘哛哠",4,"哫哬哯哰哱哴",5,"哻哾唀唂唃唄唅唈唊",4,"唒唓唕",5,"唜唝唞唟唡唥唦"],["8680","唨唩唫唭唲唴唵唶唸唹唺唻唽啀啂啅啇啈啋",4,"啑啒啓啔啗",4,"啝啞啟啠啢啣啨啩啫啯",5,"啹啺啽啿喅喆喌喍喎喐喒喓喕喖喗喚喛喞喠",6,"喨",8,"喲喴営喸喺喼喿",4,"嗆嗇嗈嗊嗋嗎嗏嗐嗕嗗",4,"嗞嗠嗢嗧嗩嗭嗮嗰嗱嗴嗶嗸",4,"嗿嘂嘃嘄嘅"],["8740","嘆嘇嘊嘋嘍嘐",7,"嘙嘚嘜嘝嘠嘡嘢嘥嘦嘨嘩嘪嘫嘮嘯嘰嘳嘵嘷嘸嘺嘼嘽嘾噀",11,"噏",4,"噕噖噚噛噝",4],["8780","噣噥噦噧噭噮噯噰噲噳噴噵噷噸噹噺噽",7,"嚇",6,"嚐嚑嚒嚔",14,"嚤",10,"嚰",6,"嚸嚹嚺嚻嚽",12,"囋",8,"囕囖囘囙囜団囥",5,"囬囮囯囲図囶囷囸囻囼圀圁圂圅圇國",6],["8840","園",9,"圝圞圠圡圢圤圥圦圧圫圱圲圴",4,"圼圽圿坁坃坄坅坆坈坉坋坒",4,"坘坙坢坣坥坧坬坮坰坱坲坴坵坸坹坺坽坾坿垀"],["8880","垁垇垈垉垊垍",4,"垔",6,"垜垝垞垟垥垨垪垬垯垰垱垳垵垶垷垹",8,"埄",6,"埌埍埐埑埓埖埗埛埜埞埡埢埣埥",7,"埮埰埱埲埳埵埶執埻埼埾埿堁堃堄堅堈堉堊堌堎堏堐堒堓堔堖堗堘堚堛堜堝堟堢堣堥",4,"堫",4,"報堲堳場堶",7],["8940","堾",5,"塅",6,"塎塏塐塒塓塕塖塗塙",4,"塟",5,"塦",4,"塭",16,"塿墂墄墆墇墈墊墋墌"],["8980","墍",4,"墔",4,"墛墜墝墠",7,"墪",17,"墽墾墿壀壂壃壄壆",10,"壒壓壔壖",13,"壥",5,"壭壯壱売壴壵壷壸壺",7,"夃夅夆夈",4,"夎夐夑夒夓夗夘夛夝夞夠夡夢夣夦夨夬夰夲夳夵夶夻"],["8a40","夽夾夿奀奃奅奆奊奌奍奐奒奓奙奛",4,"奡奣奤奦",12,"奵奷奺奻奼奾奿妀妅妉妋妌妎妏妐妑妔妕妘妚妛妜妝妟妠妡妢妦"],["8a80","妧妬妭妰妱妳",5,"妺妼妽妿",6,"姇姈姉姌姍姎姏姕姖姙姛姞",4,"姤姦姧姩姪姫姭",11,"姺姼姽姾娀娂娊娋娍娎娏娐娒娔娕娖娗娙娚娛娝娞娡娢娤娦娧娨娪",6,"娳娵娷",4,"娽娾娿婁",4,"婇婈婋",9,"婖婗婘婙婛",5],["8b40","婡婣婤婥婦婨婩婫",8,"婸婹婻婼婽婾媀",17,"媓",6,"媜",13,"媫媬"],["8b80","媭",4,"媴媶媷媹",4,"媿嫀嫃",5,"嫊嫋嫍",4,"嫓嫕嫗嫙嫚嫛嫝嫞嫟嫢嫤嫥嫧嫨嫪嫬",4,"嫲",22,"嬊",11,"嬘",25,"嬳嬵嬶嬸",7,"孁",6],["8c40","孈",7,"孒孖孞孠孡孧孨孫孭孮孯孲孴孶孷學孹孻孼孾孿宂宆宊宍宎宐宑宒宔宖実宧宨宩宬宭宮宯宱宲宷宺宻宼寀寁寃寈寉寊寋寍寎寏"],["8c80","寑寔",8,"寠寢寣實寧審",4,"寯寱",6,"寽対尀専尃尅將專尋尌對導尐尒尓尗尙尛尞尟尠尡尣尦尨尩尪尫尭尮尯尰尲尳尵尶尷屃屄屆屇屌屍屒屓屔屖屗屘屚屛屜屝屟屢層屧",6,"屰屲",6,"屻屼屽屾岀岃",4,"岉岊岋岎岏岒岓岕岝",4,"岤",4],["8d40","岪岮岯岰岲岴岶岹岺岻岼岾峀峂峃峅",5,"峌",5,"峓",5,"峚",6,"峢峣峧峩峫峬峮峯峱",9,"峼",4],["8d80","崁崄崅崈",5,"崏",4,"崕崗崘崙崚崜崝崟",4,"崥崨崪崫崬崯",4,"崵",7,"崿",7,"嵈嵉嵍",10,"嵙嵚嵜嵞",10,"嵪嵭嵮嵰嵱嵲嵳嵵",12,"嶃",21,"嶚嶛嶜嶞嶟嶠"],["8e40","嶡",21,"嶸",12,"巆",6,"巎",12,"巜巟巠巣巤巪巬巭"],["8e80","巰巵巶巸",4,"巿帀帄帇帉帊帋帍帎帒帓帗帞",7,"帨",4,"帯帰帲",4,"帹帺帾帿幀幁幃幆",5,"幍",6,"幖",4,"幜幝幟幠幣",14,"幵幷幹幾庁庂広庅庈庉庌庍庎庒庘庛庝庡庢庣庤庨",4,"庮",4,"庴庺庻庼庽庿",6],["8f40","廆廇廈廋",5,"廔廕廗廘廙廚廜",11,"廩廫",8,"廵廸廹廻廼廽弅弆弇弉弌弍弎弐弒弔弖弙弚弜弝弞弡弢弣弤"],["8f80","弨弫弬弮弰弲",6,"弻弽弾弿彁",14,"彑彔彙彚彛彜彞彟彠彣彥彧彨彫彮彯彲彴彵彶彸彺彽彾彿徃徆徍徎徏徑従徔徖徚徛徝從徟徠徢",5,"復徫徬徯",5,"徶徸徹徺徻徾",4,"忇忈忊忋忎忓忔忕忚忛応忞忟忢忣忥忦忨忩忬忯忰忲忳忴忶忷忹忺忼怇"],["9040","怈怉怋怌怐怑怓怗怘怚怞怟怢怣怤怬怭怮怰",4,"怶",4,"怽怾恀恄",6,"恌恎恏恑恓恔恖恗恘恛恜恞恟恠恡恥恦恮恱恲恴恵恷恾悀"],["9080","悁悂悅悆悇悈悊悋悎悏悐悑悓悕悗悘悙悜悞悡悢悤悥悧悩悪悮悰悳悵悶悷悹悺悽",7,"惇惈惉惌",4,"惒惓惔惖惗惙惛惞惡",4,"惪惱惲惵惷惸惻",4,"愂愃愄愅愇愊愋愌愐",4,"愖愗愘愙愛愜愝愞愡愢愥愨愩愪愬",18,"慀",6],["9140","慇慉態慍慏慐慒慓慔慖",6,"慞慟慠慡慣慤慥慦慩",6,"慱慲慳慴慶慸",18,"憌憍憏",4,"憕"],["9180","憖",6,"憞",8,"憪憫憭",9,"憸",5,"憿懀懁懃",4,"應懌",4,"懓懕",16,"懧",13,"懶",8,"戀",5,"戇戉戓戔戙戜戝戞戠戣戦戧戨戩戫戭戯戰戱戲戵戶戸",4,"扂扄扅扆扊"],["9240","扏扐払扖扗扙扚扜",6,"扤扥扨扱扲扴扵扷扸扺扻扽抁抂抃抅抆抇抈抋",5,"抔抙抜抝択抣抦抧抩抪抭抮抯抰抲抳抴抶抷抸抺抾拀拁"],["9280","拃拋拏拑拕拝拞拠拡拤拪拫拰拲拵拸拹拺拻挀挃挄挅挆挊挋挌挍挏挐挒挓挔挕挗挘挙挜挦挧挩挬挭挮挰挱挳",5,"挻挼挾挿捀捁捄捇捈捊捑捒捓捔捖",7,"捠捤捥捦捨捪捫捬捯捰捲捳捴捵捸捹捼捽捾捿掁掃掄掅掆掋掍掑掓掔掕掗掙",6,"採掤掦掫掯掱掲掵掶掹掻掽掿揀"],["9340","揁揂揃揅揇揈揊揋揌揑揓揔揕揗",6,"揟揢揤",4,"揫揬揮揯揰揱揳揵揷揹揺揻揼揾搃搄搆",4,"損搎搑搒搕",5,"搝搟搢搣搤"],["9380","搥搧搨搩搫搮",5,"搵",4,"搻搼搾摀摂摃摉摋",6,"摓摕摖摗摙",4,"摟",7,"摨摪摫摬摮",9,"摻",6,"撃撆撈",8,"撓撔撗撘撚撛撜撝撟",4,"撥撦撧撨撪撫撯撱撲撳撴撶撹撻撽撾撿擁擃擄擆",6,"擏擑擓擔擕擖擙據"],["9440","擛擜擝擟擠擡擣擥擧",24,"攁",7,"攊",7,"攓",4,"攙",8],["9480","攢攣攤攦",4,"攬攭攰攱攲攳攷攺攼攽敀",4,"敆敇敊敋敍敎敐敒敓敔敗敘敚敜敟敠敡敤敥敧敨敩敪敭敮敯敱敳敵敶數",14,"斈斉斊斍斎斏斒斔斕斖斘斚斝斞斠斢斣斦斨斪斬斮斱",7,"斺斻斾斿旀旂旇旈旉旊旍旐旑旓旔旕旘",7,"旡旣旤旪旫"],["9540","旲旳旴旵旸旹旻",4,"昁昄昅昇昈昉昋昍昐昑昒昖昗昘昚昛昜昞昡昢昣昤昦昩昪昫昬昮昰昲昳昷",4,"昽昿晀時晄",6,"晍晎晐晑晘"],["9580","晙晛晜晝晞晠晢晣晥晧晩",4,"晱晲晳晵晸晹晻晼晽晿暀暁暃暅暆暈暉暊暋暍暎暏暐暒暓暔暕暘",4,"暞",8,"暩",4,"暯",4,"暵暶暷暸暺暻暼暽暿",25,"曚曞",7,"曧曨曪",5,"曱曵曶書曺曻曽朁朂會"],["9640","朄朅朆朇朌朎朏朑朒朓朖朘朙朚朜朞朠",5,"朧朩朮朰朲朳朶朷朸朹朻朼朾朿杁杄杅杇杊杋杍杒杔杕杗",4,"杝杢杣杤杦杧杫杬杮東杴杶"],["9680","杸杹杺杻杽枀枂枃枅枆枈枊枌枍枎枏枑枒枓枔枖枙枛枟枠枡枤枦枩枬枮枱枲枴枹",7,"柂柅",9,"柕柖柗柛柟柡柣柤柦柧柨柪柫柭柮柲柵",7,"柾栁栂栃栄栆栍栐栒栔栕栘",4,"栞栟栠栢",6,"栫",6,"栴栵栶栺栻栿桇桋桍桏桒桖",5],["9740","桜桝桞桟桪桬",7,"桵桸",8,"梂梄梇",7,"梐梑梒梔梕梖梘",9,"梣梤梥梩梪梫梬梮梱梲梴梶梷梸"],["9780","梹",6,"棁棃",5,"棊棌棎棏棐棑棓棔棖棗棙棛",4,"棡棢棤",9,"棯棲棳棴棶棷棸棻棽棾棿椀椂椃椄椆",4,"椌椏椑椓",11,"椡椢椣椥",7,"椮椯椱椲椳椵椶椷椸椺椻椼椾楀楁楃",16,"楕楖楘楙楛楜楟"],["9840","楡楢楤楥楧楨楩楪楬業楯楰楲",4,"楺楻楽楾楿榁榃榅榊榋榌榎",5,"榖榗榙榚榝",9,"榩榪榬榮榯榰榲榳榵榶榸榹榺榼榽"],["9880","榾榿槀槂",7,"構槍槏槑槒槓槕",5,"槜槝槞槡",11,"槮槯槰槱槳",9,"槾樀",9,"樋",11,"標",5,"樠樢",5,"権樫樬樭樮樰樲樳樴樶",6,"樿",4,"橅橆橈",7,"橑",6,"橚"],["9940","橜",4,"橢橣橤橦",10,"橲",6,"橺橻橽橾橿檁檂檃檅",8,"檏檒",4,"檘",7,"檡",5],["9980","檧檨檪檭",114,"欥欦欨",6],["9a40","欯欰欱欳欴欵欶欸欻欼欽欿歀歁歂歄歅歈歊歋歍",11,"歚",7,"歨歩歫",13,"歺歽歾歿殀殅殈"],["9a80","殌殎殏殐殑殔殕殗殘殙殜",4,"殢",7,"殫",7,"殶殸",6,"毀毃毄毆",4,"毌毎毐毑毘毚毜",4,"毢",7,"毬毭毮毰毱毲毴毶毷毸毺毻毼毾",6,"氈",4,"氎氒気氜氝氞氠氣氥氫氬氭氱氳氶氷氹氺氻氼氾氿汃汄汅汈汋",4,"汑汒汓汖汘"],["9b40","汙汚汢汣汥汦汧汫",4,"汱汳汵汷汸決汻汼汿沀沄沇沊沋沍沎沑沒沕沖沗沘沚沜沝沞沠沢沨沬沯沰沴沵沶沷沺泀況泂泃泆泇泈泋泍泎泏泑泒泘"],["9b80","泙泚泜泝泟泤泦泧泩泬泭泲泴泹泿洀洂洃洅洆洈洉洊洍洏洐洑洓洔洕洖洘洜洝洟",5,"洦洨洩洬洭洯洰洴洶洷洸洺洿浀浂浄浉浌浐浕浖浗浘浛浝浟浡浢浤浥浧浨浫浬浭浰浱浲浳浵浶浹浺浻浽",4,"涃涄涆涇涊涋涍涏涐涒涖",4,"涜涢涥涬涭涰涱涳涴涶涷涹",5,"淁淂淃淈淉淊"],["9c40","淍淎淏淐淒淓淔淕淗淚淛淜淟淢淣淥淧淨淩淪淭淯淰淲淴淵淶淸淺淽",7,"渆渇済渉渋渏渒渓渕渘渙減渜渞渟渢渦渧渨渪測渮渰渱渳渵"],["9c80","渶渷渹渻",7,"湅",7,"湏湐湑湒湕湗湙湚湜湝湞湠",10,"湬湭湯",14,"満溁溂溄溇溈溊",4,"溑",6,"溙溚溛溝溞溠溡溣溤溦溨溩溫溬溭溮溰溳溵溸溹溼溾溿滀滃滄滅滆滈滉滊滌滍滎滐滒滖滘滙滛滜滝滣滧滪",5],["9d40","滰滱滲滳滵滶滷滸滺",7,"漃漄漅漇漈漊",4,"漐漑漒漖",9,"漡漢漣漥漦漧漨漬漮漰漲漴漵漷",6,"漿潀潁潂"],["9d80","潃潄潅潈潉潊潌潎",9,"潙潚潛潝潟潠潡潣潤潥潧",5,"潯潰潱潳潵潶潷潹潻潽",6,"澅澆澇澊澋澏",12,"澝澞澟澠澢",4,"澨",10,"澴澵澷澸澺",5,"濁濃",5,"濊",6,"濓",10,"濟濢濣濤濥"],["9e40","濦",7,"濰",32,"瀒",7,"瀜",6,"瀤",6],["9e80","瀫",9,"瀶瀷瀸瀺",17,"灍灎灐",13,"灟",11,"灮灱灲灳灴灷灹灺灻災炁炂炃炄炆炇炈炋炌炍炏炐炑炓炗炘炚炛炞",12,"炰炲炴炵炶為炾炿烄烅烆烇烉烋",12,"烚"],["9f40","烜烝烞烠烡烢烣烥烪烮烰",6,"烸烺烻烼烾",10,"焋",4,"焑焒焔焗焛",10,"焧",7,"焲焳焴"],["9f80","焵焷",13,"煆煇煈煉煋煍煏",12,"煝煟",4,"煥煩",4,"煯煰煱煴煵煶煷煹煻煼煾",5,"熅",4,"熋熌熍熎熐熑熒熓熕熖熗熚",4,"熡",6,"熩熪熫熭",5,"熴熶熷熸熺",8,"燄",9,"燏",4],["a040","燖",9,"燡燢燣燤燦燨",5,"燯",9,"燺",11,"爇",19],["a080","爛爜爞",9,"爩爫爭爮爯爲爳爴爺爼爾牀",6,"牉牊牋牎牏牐牑牓牔牕牗牘牚牜牞牠牣牤牥牨牪牫牬牭牰牱牳牴牶牷牸牻牼牽犂犃犅",4,"犌犎犐犑犓",11,"犠",11,"犮犱犲犳犵犺",6,"狅狆狇狉狊狋狌狏狑狓狔狕狖狘狚狛"],["a1a1","　、。·ˉˇ¨〃々—～‖…‘’“”〔〕〈",7,"〖〗【】±×÷∶∧∨∑∏∪∩∈∷√⊥∥∠⌒⊙∫∮≡≌≈∽∝≠≮≯≤≥∞∵∴♂♀°′″℃＄¤￠￡‰§№☆★○●◎◇◆□■△▲※→←↑↓〓"],["a2a1","ⅰ",9],["a2b1","⒈",19,"⑴",19,"①",9],["a2e5","㈠",9],["a2f1","Ⅰ",11],["a3a1","！＂＃￥％",88,"￣"],["a4a1","ぁ",82],["a5a1","ァ",85],["a6a1","Α",16,"Σ",6],["a6c1","α",16,"σ",6],["a6e0","︵︶︹︺︿﹀︽︾﹁﹂﹃﹄"],["a6ee","︻︼︷︸︱"],["a6f4","︳︴"],["a7a1","А",5,"ЁЖ",25],["a7d1","а",5,"ёж",25],["a840","ˊˋ˙–―‥‵℅℉↖↗↘↙∕∟∣≒≦≧⊿═",35,"▁",6],["a880","█",7,"▓▔▕▼▽◢◣◤◥☉⊕〒〝〞"],["a8a1","āáǎàēéěèīíǐìōóǒòūúǔùǖǘǚǜüêɑ"],["a8bd","ńň"],["a8c0","ɡ"],["a8c5","ㄅ",36],["a940","〡",8,"㊣㎎㎏㎜㎝㎞㎡㏄㏎㏑㏒㏕︰￢￤"],["a959","℡㈱"],["a95c","‐"],["a960","ー゛゜ヽヾ〆ゝゞ﹉",9,"﹔﹕﹖﹗﹙",8],["a980","﹢",4,"﹨﹩﹪﹫"],["a996","〇"],["a9a4","─",75],["aa40","狜狝狟狢",5,"狪狫狵狶狹狽狾狿猀猂猄",5,"猋猌猍猏猐猑猒猔猘猙猚猟猠猣猤猦猧猨猭猯猰猲猳猵猶猺猻猼猽獀",8],["aa80","獉獊獋獌獎獏獑獓獔獕獖獘",7,"獡",10,"獮獰獱"],["ab40","獲",11,"獿",4,"玅玆玈玊玌玍玏玐玒玓玔玕玗玘玙玚玜玝玞玠玡玣",5,"玪玬玭玱玴玵玶玸玹玼玽玾玿珁珃",4],["ab80","珋珌珎珒",6,"珚珛珜珝珟珡珢珣珤珦珨珪珫珬珮珯珰珱珳",4],["ac40","珸",10,"琄琇琈琋琌琍琎琑",8,"琜",5,"琣琤琧琩琫琭琯琱琲琷",4,"琽琾琿瑀瑂",11],["ac80","瑎",6,"瑖瑘瑝瑠",12,"瑮瑯瑱",4,"瑸瑹瑺"],["ad40","瑻瑼瑽瑿璂璄璅璆璈璉璊璌璍璏璑",10,"璝璟",7,"璪",15,"璻",12],["ad80","瓈",9,"瓓",8,"瓝瓟瓡瓥瓧",6,"瓰瓱瓲"],["ae40","瓳瓵瓸",6,"甀甁甂甃甅",7,"甎甐甒甔甕甖甗甛甝甞甠",4,"甦甧甪甮甴甶甹甼甽甿畁畂畃畄畆畇畉畊畍畐畑畒畓畕畖畗畘"],["ae80","畝",7,"畧畨畩畫",6,"畳畵當畷畺",4,"疀疁疂疄疅疇"],["af40","疈疉疊疌疍疎疐疓疕疘疛疜疞疢疦",4,"疭疶疷疺疻疿痀痁痆痋痌痎痏痐痑痓痗痙痚痜痝痟痠痡痥痩痬痭痮痯痲痳痵痶痷痸痺痻痽痾瘂瘄瘆瘇"],["af80","瘈瘉瘋瘍瘎瘏瘑瘒瘓瘔瘖瘚瘜瘝瘞瘡瘣瘧瘨瘬瘮瘯瘱瘲瘶瘷瘹瘺瘻瘽癁療癄"],["b040","癅",6,"癎",5,"癕癗",4,"癝癟癠癡癢癤",6,"癬癭癮癰",7,"癹発發癿皀皁皃皅皉皊皌皍皏皐皒皔皕皗皘皚皛"],["b080","皜",7,"皥",8,"皯皰皳皵",9,"盀盁盃啊阿埃挨哎唉哀皑癌蔼矮艾碍爱隘鞍氨安俺按暗岸胺案肮昂盎凹敖熬翱袄傲奥懊澳芭捌扒叭吧笆八疤巴拔跋靶把耙坝霸罢爸白柏百摆佰败拜稗斑班搬扳般颁板版扮拌伴瓣半办绊邦帮梆榜膀绑棒磅蚌镑傍谤苞胞包褒剥"],["b140","盄盇盉盋盌盓盕盙盚盜盝盞盠",4,"盦",7,"盰盳盵盶盷盺盻盽盿眀眂眃眅眆眊県眎",10,"眛眜眝眞眡眣眤眥眧眪眫"],["b180","眬眮眰",4,"眹眻眽眾眿睂睄睅睆睈",7,"睒",7,"睜薄雹保堡饱宝抱报暴豹鲍爆杯碑悲卑北辈背贝钡倍狈备惫焙被奔苯本笨崩绷甭泵蹦迸逼鼻比鄙笔彼碧蓖蔽毕毙毖币庇痹闭敝弊必辟壁臂避陛鞭边编贬扁便变卞辨辩辫遍标彪膘表鳖憋别瘪彬斌濒滨宾摈兵冰柄丙秉饼炳"],["b240","睝睞睟睠睤睧睩睪睭",11,"睺睻睼瞁瞂瞃瞆",5,"瞏瞐瞓",11,"瞡瞣瞤瞦瞨瞫瞭瞮瞯瞱瞲瞴瞶",4],["b280","瞼瞾矀",12,"矎",8,"矘矙矚矝",4,"矤病并玻菠播拨钵波博勃搏铂箔伯帛舶脖膊渤泊驳捕卜哺补埠不布步簿部怖擦猜裁材才财睬踩采彩菜蔡餐参蚕残惭惨灿苍舱仓沧藏操糙槽曹草厕策侧册测层蹭插叉茬茶查碴搽察岔差诧拆柴豺搀掺蝉馋谗缠铲产阐颤昌猖"],["b340","矦矨矪矯矰矱矲矴矵矷矹矺矻矼砃",5,"砊砋砎砏砐砓砕砙砛砞砠砡砢砤砨砪砫砮砯砱砲砳砵砶砽砿硁硂硃硄硆硈硉硊硋硍硏硑硓硔硘硙硚"],["b380","硛硜硞",11,"硯",7,"硸硹硺硻硽",6,"场尝常长偿肠厂敞畅唱倡超抄钞朝嘲潮巢吵炒车扯撤掣彻澈郴臣辰尘晨忱沉陈趁衬撑称城橙成呈乘程惩澄诚承逞骋秤吃痴持匙池迟弛驰耻齿侈尺赤翅斥炽充冲虫崇宠抽酬畴踌稠愁筹仇绸瞅丑臭初出橱厨躇锄雏滁除楚"],["b440","碄碅碆碈碊碋碏碐碒碔碕碖碙碝碞碠碢碤碦碨",7,"碵碶碷碸確碻碼碽碿磀磂磃磄磆磇磈磌磍磎磏磑磒磓磖磗磘磚",9],["b480","磤磥磦磧磩磪磫磭",4,"磳磵磶磸磹磻",5,"礂礃礄礆",6,"础储矗搐触处揣川穿椽传船喘串疮窗幢床闯创吹炊捶锤垂春椿醇唇淳纯蠢戳绰疵茨磁雌辞慈瓷词此刺赐次聪葱囱匆从丛凑粗醋簇促蹿篡窜摧崔催脆瘁粹淬翠村存寸磋撮搓措挫错搭达答瘩打大呆歹傣戴带殆代贷袋待逮"],["b540","礍",5,"礔",9,"礟",4,"礥",14,"礵",4,"礽礿祂祃祄祅祇祊",8,"祔祕祘祙祡祣"],["b580","祤祦祩祪祫祬祮祰",6,"祹祻",4,"禂禃禆禇禈禉禋禌禍禎禐禑禒怠耽担丹单郸掸胆旦氮但惮淡诞弹蛋当挡党荡档刀捣蹈倒岛祷导到稻悼道盗德得的蹬灯登等瞪凳邓堤低滴迪敌笛狄涤翟嫡抵底地蒂第帝弟递缔颠掂滇碘点典靛垫电佃甸店惦奠淀殿碉叼雕凋刁掉吊钓调跌爹碟蝶迭谍叠"],["b640","禓",6,"禛",11,"禨",10,"禴",4,"禼禿秂秄秅秇秈秊秌秎秏秐秓秔秖秗秙",5,"秠秡秢秥秨秪"],["b680","秬秮秱",6,"秹秺秼秾秿稁稄稅稇稈稉稊稌稏",4,"稕稖稘稙稛稜丁盯叮钉顶鼎锭定订丢东冬董懂动栋侗恫冻洞兜抖斗陡豆逗痘都督毒犊独读堵睹赌杜镀肚度渡妒端短锻段断缎堆兑队对墩吨蹲敦顿囤钝盾遁掇哆多夺垛躲朵跺舵剁惰堕蛾峨鹅俄额讹娥恶厄扼遏鄂饿恩而儿耳尔饵洱二"],["b740","稝稟稡稢稤",14,"稴稵稶稸稺稾穀",5,"穇",9,"穒",4,"穘",16],["b780","穩",6,"穱穲穳穵穻穼穽穾窂窅窇窉窊窋窌窎窏窐窓窔窙窚窛窞窡窢贰发罚筏伐乏阀法珐藩帆番翻樊矾钒繁凡烦反返范贩犯饭泛坊芳方肪房防妨仿访纺放菲非啡飞肥匪诽吠肺废沸费芬酚吩氛分纷坟焚汾粉奋份忿愤粪丰封枫蜂峰锋风疯烽逢冯缝讽奉凤佛否夫敷肤孵扶拂辐幅氟符伏俘服"],["b840","窣窤窧窩窪窫窮",4,"窴",10,"竀",10,"竌",9,"竗竘竚竛竜竝竡竢竤竧",5,"竮竰竱竲竳"],["b880","竴",4,"竻竼竾笀笁笂笅笇笉笌笍笎笐笒笓笖笗笘笚笜笝笟笡笢笣笧笩笭浮涪福袱弗甫抚辅俯釜斧脯腑府腐赴副覆赋复傅付阜父腹负富讣附妇缚咐噶嘎该改概钙盖溉干甘杆柑竿肝赶感秆敢赣冈刚钢缸肛纲岗港杠篙皋高膏羔糕搞镐稿告哥歌搁戈鸽胳疙割革葛格蛤阁隔铬个各给根跟耕更庚羹"],["b940","笯笰笲笴笵笶笷笹笻笽笿",5,"筆筈筊筍筎筓筕筗筙筜筞筟筡筣",10,"筯筰筳筴筶筸筺筼筽筿箁箂箃箄箆",6,"箎箏"],["b980","箑箒箓箖箘箙箚箛箞箟箠箣箤箥箮箯箰箲箳箵箶箷箹",7,"篂篃範埂耿梗工攻功恭龚供躬公宫弓巩汞拱贡共钩勾沟苟狗垢构购够辜菇咕箍估沽孤姑鼓古蛊骨谷股故顾固雇刮瓜剐寡挂褂乖拐怪棺关官冠观管馆罐惯灌贯光广逛瑰规圭硅归龟闺轨鬼诡癸桂柜跪贵刽辊滚棍锅郭国果裹过哈"],["ba40","篅篈築篊篋篍篎篏篐篒篔",4,"篛篜篞篟篠篢篣篤篧篨篩篫篬篭篯篰篲",4,"篸篹篺篻篽篿",7,"簈簉簊簍簎簐",5,"簗簘簙"],["ba80","簚",4,"簠",5,"簨簩簫",12,"簹",5,"籂骸孩海氦亥害骇酣憨邯韩含涵寒函喊罕翰撼捍旱憾悍焊汗汉夯杭航壕嚎豪毫郝好耗号浩呵喝荷菏核禾和何合盒貉阂河涸赫褐鹤贺嘿黑痕很狠恨哼亨横衡恒轰哄烘虹鸿洪宏弘红喉侯猴吼厚候后呼乎忽瑚壶葫胡蝴狐糊湖"],["bb40","籃",9,"籎",36,"籵",5,"籾",9],["bb80","粈粊",6,"粓粔粖粙粚粛粠粡粣粦粧粨粩粫粬粭粯粰粴",4,"粺粻弧虎唬护互沪户花哗华猾滑画划化话槐徊怀淮坏欢环桓还缓换患唤痪豢焕涣宦幻荒慌黄磺蝗簧皇凰惶煌晃幌恍谎灰挥辉徽恢蛔回毁悔慧卉惠晦贿秽会烩汇讳诲绘荤昏婚魂浑混豁活伙火获或惑霍货祸击圾基机畸稽积箕"],["bc40","粿糀糂糃糄糆糉糋糎",6,"糘糚糛糝糞糡",6,"糩",5,"糰",7,"糹糺糼",13,"紋",5],["bc80","紑",14,"紡紣紤紥紦紨紩紪紬紭紮細",6,"肌饥迹激讥鸡姬绩缉吉极棘辑籍集及急疾汲即嫉级挤几脊己蓟技冀季伎祭剂悸济寄寂计记既忌际妓继纪嘉枷夹佳家加荚颊贾甲钾假稼价架驾嫁歼监坚尖笺间煎兼肩艰奸缄茧检柬碱硷拣捡简俭剪减荐槛鉴践贱见键箭件"],["bd40","紷",54,"絯",7],["bd80","絸",32,"健舰剑饯渐溅涧建僵姜将浆江疆蒋桨奖讲匠酱降蕉椒礁焦胶交郊浇骄娇嚼搅铰矫侥脚狡角饺缴绞剿教酵轿较叫窖揭接皆秸街阶截劫节桔杰捷睫竭洁结解姐戒藉芥界借介疥诫届巾筋斤金今津襟紧锦仅谨进靳晋禁近烬浸"],["be40","継",12,"綧",6,"綯",42],["be80","線",32,"尽劲荆兢茎睛晶鲸京惊精粳经井警景颈静境敬镜径痉靖竟竞净炯窘揪究纠玖韭久灸九酒厩救旧臼舅咎就疚鞠拘狙疽居驹菊局咀矩举沮聚拒据巨具距踞锯俱句惧炬剧捐鹃娟倦眷卷绢撅攫抉掘倔爵觉决诀绝均菌钧军君峻"],["bf40","緻",62],["bf80","縺縼",4,"繂",4,"繈",21,"俊竣浚郡骏喀咖卡咯开揩楷凯慨刊堪勘坎砍看康慷糠扛抗亢炕考拷烤靠坷苛柯棵磕颗科壳咳可渴克刻客课肯啃垦恳坑吭空恐孔控抠口扣寇枯哭窟苦酷库裤夸垮挎跨胯块筷侩快宽款匡筐狂框矿眶旷况亏盔岿窥葵奎魁傀"],["c040","繞",35,"纃",23,"纜纝纞"],["c080","纮纴纻纼绖绤绬绹缊缐缞缷缹缻",6,"罃罆",9,"罒罓馈愧溃坤昆捆困括扩廓阔垃拉喇蜡腊辣啦莱来赖蓝婪栏拦篮阑兰澜谰揽览懒缆烂滥琅榔狼廊郎朗浪捞劳牢老佬姥酪烙涝勒乐雷镭蕾磊累儡垒擂肋类泪棱楞冷厘梨犁黎篱狸离漓理李里鲤礼莉荔吏栗丽厉励砾历利傈例俐"],["c140","罖罙罛罜罝罞罠罣",4,"罫罬罭罯罰罳罵罶罷罸罺罻罼罽罿羀羂",7,"羋羍羏",4,"羕",4,"羛羜羠羢羣羥羦羨",6,"羱"],["c180","羳",4,"羺羻羾翀翂翃翄翆翇翈翉翋翍翏",4,"翖翗翙",5,"翢翣痢立粒沥隶力璃哩俩联莲连镰廉怜涟帘敛脸链恋炼练粮凉梁粱良两辆量晾亮谅撩聊僚疗燎寥辽潦了撂镣廖料列裂烈劣猎琳林磷霖临邻鳞淋凛赁吝拎玲菱零龄铃伶羚凌灵陵岭领另令溜琉榴硫馏留刘瘤流柳六龙聋咙笼窿"],["c240","翤翧翨翪翫翬翭翯翲翴",6,"翽翾翿耂耇耈耉耊耎耏耑耓耚耛耝耞耟耡耣耤耫",5,"耲耴耹耺耼耾聀聁聄聅聇聈聉聎聏聐聑聓聕聖聗"],["c280","聙聛",13,"聫",5,"聲",11,"隆垄拢陇楼娄搂篓漏陋芦卢颅庐炉掳卤虏鲁麓碌露路赂鹿潞禄录陆戮驴吕铝侣旅履屡缕虑氯律率滤绿峦挛孪滦卵乱掠略抡轮伦仑沦纶论萝螺罗逻锣箩骡裸落洛骆络妈麻玛码蚂马骂嘛吗埋买麦卖迈脉瞒馒蛮满蔓曼慢漫"],["c340","聾肁肂肅肈肊肍",5,"肔肕肗肙肞肣肦肧肨肬肰肳肵肶肸肹肻胅胇",4,"胏",6,"胘胟胠胢胣胦胮胵胷胹胻胾胿脀脁脃脄脅脇脈脋"],["c380","脌脕脗脙脛脜脝脟",12,"脭脮脰脳脴脵脷脹",4,"脿谩芒茫盲氓忙莽猫茅锚毛矛铆卯茂冒帽貌贸么玫枚梅酶霉煤没眉媒镁每美昧寐妹媚门闷们萌蒙檬盟锰猛梦孟眯醚靡糜迷谜弥米秘觅泌蜜密幂棉眠绵冕免勉娩缅面苗描瞄藐秒渺庙妙蔑灭民抿皿敏悯闽明螟鸣铭名命谬摸"],["c440","腀",5,"腇腉腍腎腏腒腖腗腘腛",4,"腡腢腣腤腦腨腪腫腬腯腲腳腵腶腷腸膁膃",4,"膉膋膌膍膎膐膒",5,"膙膚膞",4,"膤膥"],["c480","膧膩膫",7,"膴",5,"膼膽膾膿臄臅臇臈臉臋臍",6,"摹蘑模膜磨摩魔抹末莫墨默沫漠寞陌谋牟某拇牡亩姆母墓暮幕募慕木目睦牧穆拿哪呐钠那娜纳氖乃奶耐奈南男难囊挠脑恼闹淖呢馁内嫩能妮霓倪泥尼拟你匿腻逆溺蔫拈年碾撵捻念娘酿鸟尿捏聂孽啮镊镍涅您柠狞凝宁"],["c540","臔",14,"臤臥臦臨臩臫臮",4,"臵",5,"臽臿舃與",4,"舎舏舑舓舕",5,"舝舠舤舥舦舧舩舮舲舺舼舽舿"],["c580","艀艁艂艃艅艆艈艊艌艍艎艐",7,"艙艛艜艝艞艠",7,"艩拧泞牛扭钮纽脓浓农弄奴努怒女暖虐疟挪懦糯诺哦欧鸥殴藕呕偶沤啪趴爬帕怕琶拍排牌徘湃派攀潘盘磐盼畔判叛乓庞旁耪胖抛咆刨炮袍跑泡呸胚培裴赔陪配佩沛喷盆砰抨烹澎彭蓬棚硼篷膨朋鹏捧碰坯砒霹批披劈琵毗"],["c640","艪艫艬艭艱艵艶艷艸艻艼芀芁芃芅芆芇芉芌芐芓芔芕芖芚芛芞芠芢芣芧芲芵芶芺芻芼芿苀苂苃苅苆苉苐苖苙苚苝苢苧苨苩苪苬苭苮苰苲苳苵苶苸"],["c680","苺苼",4,"茊茋茍茐茒茓茖茘茙茝",9,"茩茪茮茰茲茷茻茽啤脾疲皮匹痞僻屁譬篇偏片骗飘漂瓢票撇瞥拼频贫品聘乒坪苹萍平凭瓶评屏坡泼颇婆破魄迫粕剖扑铺仆莆葡菩蒲埔朴圃普浦谱曝瀑期欺栖戚妻七凄漆柒沏其棋奇歧畦崎脐齐旗祈祁骑起岂乞企启契砌器气迄弃汽泣讫掐"],["c740","茾茿荁荂荄荅荈荊",4,"荓荕",4,"荝荢荰",6,"荹荺荾",6,"莇莈莊莋莌莍莏莐莑莔莕莖莗莙莚莝莟莡",6,"莬莭莮"],["c780","莯莵莻莾莿菂菃菄菆菈菉菋菍菎菐菑菒菓菕菗菙菚菛菞菢菣菤菦菧菨菫菬菭恰洽牵扦钎铅千迁签仟谦乾黔钱钳前潜遣浅谴堑嵌欠歉枪呛腔羌墙蔷强抢橇锹敲悄桥瞧乔侨巧鞘撬翘峭俏窍切茄且怯窃钦侵亲秦琴勤芹擒禽寝沁青轻氢倾卿清擎晴氰情顷请庆琼穷秋丘邱球求囚酋泅趋区蛆曲躯屈驱渠"],["c840","菮華菳",4,"菺菻菼菾菿萀萂萅萇萈萉萊萐萒",5,"萙萚萛萞",5,"萩",7,"萲",5,"萹萺萻萾",7,"葇葈葉"],["c880","葊",6,"葒",4,"葘葝葞葟葠葢葤",4,"葪葮葯葰葲葴葷葹葻葼取娶龋趣去圈颧权醛泉全痊拳犬券劝缺炔瘸却鹊榷确雀裙群然燃冉染瓤壤攘嚷让饶扰绕惹热壬仁人忍韧任认刃妊纫扔仍日戎茸蓉荣融熔溶容绒冗揉柔肉茹蠕儒孺如辱乳汝入褥软阮蕊瑞锐闰润若弱撒洒萨腮鳃塞赛三叁"],["c940","葽",4,"蒃蒄蒅蒆蒊蒍蒏",7,"蒘蒚蒛蒝蒞蒟蒠蒢",12,"蒰蒱蒳蒵蒶蒷蒻蒼蒾蓀蓂蓃蓅蓆蓇蓈蓋蓌蓎蓏蓒蓔蓕蓗"],["c980","蓘",4,"蓞蓡蓢蓤蓧",4,"蓭蓮蓯蓱",10,"蓽蓾蔀蔁蔂伞散桑嗓丧搔骚扫嫂瑟色涩森僧莎砂杀刹沙纱傻啥煞筛晒珊苫杉山删煽衫闪陕擅赡膳善汕扇缮墒伤商赏晌上尚裳梢捎稍烧芍勺韶少哨邵绍奢赊蛇舌舍赦摄射慑涉社设砷申呻伸身深娠绅神沈审婶甚肾慎渗声生甥牲升绳"],["ca40","蔃",8,"蔍蔎蔏蔐蔒蔔蔕蔖蔘蔙蔛蔜蔝蔞蔠蔢",8,"蔭",9,"蔾",4,"蕄蕅蕆蕇蕋",10],["ca80","蕗蕘蕚蕛蕜蕝蕟",4,"蕥蕦蕧蕩",8,"蕳蕵蕶蕷蕸蕼蕽蕿薀薁省盛剩胜圣师失狮施湿诗尸虱十石拾时什食蚀实识史矢使屎驶始式示士世柿事拭誓逝势是嗜噬适仕侍释饰氏市恃室视试收手首守寿授售受瘦兽蔬枢梳殊抒输叔舒淑疏书赎孰熟薯暑曙署蜀黍鼠属术述树束戍竖墅庶数漱"],["cb40","薂薃薆薈",6,"薐",10,"薝",6,"薥薦薧薩薫薬薭薱",5,"薸薺",6,"藂",6,"藊",4,"藑藒"],["cb80","藔藖",5,"藝",6,"藥藦藧藨藪",14,"恕刷耍摔衰甩帅栓拴霜双爽谁水睡税吮瞬顺舜说硕朔烁斯撕嘶思私司丝死肆寺嗣四伺似饲巳松耸怂颂送宋讼诵搜艘擞嗽苏酥俗素速粟僳塑溯宿诉肃酸蒜算虽隋随绥髓碎岁穗遂隧祟孙损笋蓑梭唆缩琐索锁所塌他它她塔"],["cc40","藹藺藼藽藾蘀",4,"蘆",10,"蘒蘓蘔蘕蘗",15,"蘨蘪",13,"蘹蘺蘻蘽蘾蘿虀"],["cc80","虁",11,"虒虓處",4,"虛虜虝號虠虡虣",7,"獭挞蹋踏胎苔抬台泰酞太态汰坍摊贪瘫滩坛檀痰潭谭谈坦毯袒碳探叹炭汤塘搪堂棠膛唐糖倘躺淌趟烫掏涛滔绦萄桃逃淘陶讨套特藤腾疼誊梯剔踢锑提题蹄啼体替嚏惕涕剃屉天添填田甜恬舔腆挑条迢眺跳贴铁帖厅听烃"],["cd40","虭虯虰虲",6,"蚃",6,"蚎",4,"蚔蚖",5,"蚞",4,"蚥蚦蚫蚭蚮蚲蚳蚷蚸蚹蚻",4,"蛁蛂蛃蛅蛈蛌蛍蛒蛓蛕蛖蛗蛚蛜"],["cd80","蛝蛠蛡蛢蛣蛥蛦蛧蛨蛪蛫蛬蛯蛵蛶蛷蛺蛻蛼蛽蛿蜁蜄蜅蜆蜋蜌蜎蜏蜐蜑蜔蜖汀廷停亭庭挺艇通桐酮瞳同铜彤童桶捅筒统痛偷投头透凸秃突图徒途涂屠土吐兔湍团推颓腿蜕褪退吞屯臀拖托脱鸵陀驮驼椭妥拓唾挖哇蛙洼娃瓦袜歪外豌弯湾玩顽丸烷完碗挽晚皖惋宛婉万腕汪王亡枉网往旺望忘妄威"],["ce40","蜙蜛蜝蜟蜠蜤蜦蜧蜨蜪蜫蜬蜭蜯蜰蜲蜳蜵蜶蜸蜹蜺蜼蜽蝀",6,"蝊蝋蝍蝏蝐蝑蝒蝔蝕蝖蝘蝚",5,"蝡蝢蝦",7,"蝯蝱蝲蝳蝵"],["ce80","蝷蝸蝹蝺蝿螀螁螄螆螇螉螊螌螎",4,"螔螕螖螘",6,"螠",4,"巍微危韦违桅围唯惟为潍维苇萎委伟伪尾纬未蔚味畏胃喂魏位渭谓尉慰卫瘟温蚊文闻纹吻稳紊问嗡翁瓮挝蜗涡窝我斡卧握沃巫呜钨乌污诬屋无芜梧吾吴毋武五捂午舞伍侮坞戊雾晤物勿务悟误昔熙析西硒矽晰嘻吸锡牺"],["cf40","螥螦螧螩螪螮螰螱螲螴螶螷螸螹螻螼螾螿蟁",4,"蟇蟈蟉蟌",4,"蟔",6,"蟜蟝蟞蟟蟡蟢蟣蟤蟦蟧蟨蟩蟫蟬蟭蟯",9],["cf80","蟺蟻蟼蟽蟿蠀蠁蠂蠄",5,"蠋",7,"蠔蠗蠘蠙蠚蠜",4,"蠣稀息希悉膝夕惜熄烯溪汐犀檄袭席习媳喜铣洗系隙戏细瞎虾匣霞辖暇峡侠狭下厦夏吓掀锨先仙鲜纤咸贤衔舷闲涎弦嫌显险现献县腺馅羡宪陷限线相厢镶香箱襄湘乡翔祥详想响享项巷橡像向象萧硝霄削哮嚣销消宵淆晓"],["d040","蠤",13,"蠳",5,"蠺蠻蠽蠾蠿衁衂衃衆",5,"衎",5,"衕衖衘衚",6,"衦衧衪衭衯衱衳衴衵衶衸衹衺"],["d080","衻衼袀袃袆袇袉袊袌袎袏袐袑袓袔袕袗",4,"袝",4,"袣袥",5,"小孝校肖啸笑效楔些歇蝎鞋协挟携邪斜胁谐写械卸蟹懈泄泻谢屑薪芯锌欣辛新忻心信衅星腥猩惺兴刑型形邢行醒幸杏性姓兄凶胸匈汹雄熊休修羞朽嗅锈秀袖绣墟戌需虚嘘须徐许蓄酗叙旭序畜恤絮婿绪续轩喧宣悬旋玄"],["d140","袬袮袯袰袲",4,"袸袹袺袻袽袾袿裀裃裄裇裈裊裋裌裍裏裐裑裓裖裗裚",4,"裠裡裦裧裩",6,"裲裵裶裷裺裻製裿褀褁褃",5],["d180","褉褋",4,"褑褔",4,"褜",4,"褢褣褤褦褧褨褩褬褭褮褯褱褲褳褵褷选癣眩绚靴薛学穴雪血勋熏循旬询寻驯巡殉汛训讯逊迅压押鸦鸭呀丫芽牙蚜崖衙涯雅哑亚讶焉咽阉烟淹盐严研蜒岩延言颜阎炎沿奄掩眼衍演艳堰燕厌砚雁唁彦焰宴谚验殃央鸯秧杨扬佯疡羊洋阳氧仰痒养样漾邀腰妖瑶"],["d240","褸",8,"襂襃襅",24,"襠",5,"襧",19,"襼"],["d280","襽襾覀覂覄覅覇",26,"摇尧遥窑谣姚咬舀药要耀椰噎耶爷野冶也页掖业叶曳腋夜液一壹医揖铱依伊衣颐夷遗移仪胰疑沂宜姨彝椅蚁倚已乙矣以艺抑易邑屹亿役臆逸肄疫亦裔意毅忆义益溢诣议谊译异翼翌绎茵荫因殷音阴姻吟银淫寅饮尹引隐"],["d340","覢",30,"觃觍觓觔觕觗觘觙觛觝觟觠觡觢觤觧觨觩觪觬觭觮觰觱觲觴",6],["d380","觻",4,"訁",5,"計",21,"印英樱婴鹰应缨莹萤营荧蝇迎赢盈影颖硬映哟拥佣臃痈庸雍踊蛹咏泳涌永恿勇用幽优悠忧尤由邮铀犹油游酉有友右佑釉诱又幼迂淤于盂榆虞愚舆余俞逾鱼愉渝渔隅予娱雨与屿禹宇语羽玉域芋郁吁遇喻峪御愈欲狱育誉"],["d440","訞",31,"訿",8,"詉",21],["d480","詟",25,"詺",6,"浴寓裕预豫驭鸳渊冤元垣袁原援辕园员圆猿源缘远苑愿怨院曰约越跃钥岳粤月悦阅耘云郧匀陨允运蕴酝晕韵孕匝砸杂栽哉灾宰载再在咱攒暂赞赃脏葬遭糟凿藻枣早澡蚤躁噪造皂灶燥责择则泽贼怎增憎曾赠扎喳渣札轧"],["d540","誁",7,"誋",7,"誔",46],["d580","諃",32,"铡闸眨栅榨咋乍炸诈摘斋宅窄债寨瞻毡詹粘沾盏斩辗崭展蘸栈占战站湛绽樟章彰漳张掌涨杖丈帐账仗胀瘴障招昭找沼赵照罩兆肇召遮折哲蛰辙者锗蔗这浙珍斟真甄砧臻贞针侦枕疹诊震振镇阵蒸挣睁征狰争怔整拯正政"],["d640","諤",34,"謈",27],["d680","謤謥謧",30,"帧症郑证芝枝支吱蜘知肢脂汁之织职直植殖执值侄址指止趾只旨纸志挚掷至致置帜峙制智秩稚质炙痔滞治窒中盅忠钟衷终种肿重仲众舟周州洲诌粥轴肘帚咒皱宙昼骤珠株蛛朱猪诸诛逐竹烛煮拄瞩嘱主著柱助蛀贮铸筑"],["d740","譆",31,"譧",4,"譭",25],["d780","讇",24,"讬讱讻诇诐诪谉谞住注祝驻抓爪拽专砖转撰赚篆桩庄装妆撞壮状椎锥追赘坠缀谆准捉拙卓桌琢茁酌啄着灼浊兹咨资姿滋淄孜紫仔籽滓子自渍字鬃棕踪宗综总纵邹走奏揍租足卒族祖诅阻组钻纂嘴醉最罪尊遵昨左佐柞做作坐座"],["d840","谸",8,"豂豃豄豅豈豊豋豍",7,"豖豗豘豙豛",5,"豣",6,"豬",6,"豴豵豶豷豻",6,"貃貄貆貇"],["d880","貈貋貍",6,"貕貖貗貙",20,"亍丌兀丐廿卅丕亘丞鬲孬噩丨禺丿匕乇夭爻卮氐囟胤馗毓睾鼗丶亟鼐乜乩亓芈孛啬嘏仄厍厝厣厥厮靥赝匚叵匦匮匾赜卦卣刂刈刎刭刳刿剀剌剞剡剜蒯剽劂劁劐劓冂罔亻仃仉仂仨仡仫仞伛仳伢佤仵伥伧伉伫佞佧攸佚佝"],["d940","貮",62],["d980","賭",32,"佟佗伲伽佶佴侑侉侃侏佾佻侪佼侬侔俦俨俪俅俚俣俜俑俟俸倩偌俳倬倏倮倭俾倜倌倥倨偾偃偕偈偎偬偻傥傧傩傺僖儆僭僬僦僮儇儋仝氽佘佥俎龠汆籴兮巽黉馘冁夔勹匍訇匐凫夙兕亠兖亳衮袤亵脔裒禀嬴蠃羸冫冱冽冼"],["da40","贎",14,"贠赑赒赗赟赥赨赩赪赬赮赯赱赲赸",8,"趂趃趆趇趈趉趌",4,"趒趓趕",9,"趠趡"],["da80","趢趤",12,"趲趶趷趹趻趽跀跁跂跅跇跈跉跊跍跐跒跓跔凇冖冢冥讠讦讧讪讴讵讷诂诃诋诏诎诒诓诔诖诘诙诜诟诠诤诨诩诮诰诳诶诹诼诿谀谂谄谇谌谏谑谒谔谕谖谙谛谘谝谟谠谡谥谧谪谫谮谯谲谳谵谶卩卺阝阢阡阱阪阽阼陂陉陔陟陧陬陲陴隈隍隗隰邗邛邝邙邬邡邴邳邶邺"],["db40","跕跘跙跜跠跡跢跥跦跧跩跭跮跰跱跲跴跶跼跾",6,"踆踇踈踋踍踎踐踑踒踓踕",7,"踠踡踤",4,"踫踭踰踲踳踴踶踷踸踻踼踾"],["db80","踿蹃蹅蹆蹌",4,"蹓",5,"蹚",11,"蹧蹨蹪蹫蹮蹱邸邰郏郅邾郐郄郇郓郦郢郜郗郛郫郯郾鄄鄢鄞鄣鄱鄯鄹酃酆刍奂劢劬劭劾哿勐勖勰叟燮矍廴凵凼鬯厶弁畚巯坌垩垡塾墼壅壑圩圬圪圳圹圮圯坜圻坂坩垅坫垆坼坻坨坭坶坳垭垤垌垲埏垧垴垓垠埕埘埚埙埒垸埴埯埸埤埝"],["dc40","蹳蹵蹷",4,"蹽蹾躀躂躃躄躆躈",6,"躑躒躓躕",6,"躝躟",11,"躭躮躰躱躳",6,"躻",7],["dc80","軃",10,"軏",21,"堋堍埽埭堀堞堙塄堠塥塬墁墉墚墀馨鼙懿艹艽艿芏芊芨芄芎芑芗芙芫芸芾芰苈苊苣芘芷芮苋苌苁芩芴芡芪芟苄苎芤苡茉苷苤茏茇苜苴苒苘茌苻苓茑茚茆茔茕苠苕茜荑荛荜茈莒茼茴茱莛荞茯荏荇荃荟荀茗荠茭茺茳荦荥"],["dd40","軥",62],["dd80","輤",32,"荨茛荩荬荪荭荮莰荸莳莴莠莪莓莜莅荼莶莩荽莸荻莘莞莨莺莼菁萁菥菘堇萘萋菝菽菖萜萸萑萆菔菟萏萃菸菹菪菅菀萦菰菡葜葑葚葙葳蒇蒈葺蒉葸萼葆葩葶蒌蒎萱葭蓁蓍蓐蓦蒽蓓蓊蒿蒺蓠蒡蒹蒴蒗蓥蓣蔌甍蔸蓰蔹蔟蔺"],["de40","轅",32,"轪辀辌辒辝辠辡辢辤辥辦辧辪辬辭辮辯農辳辴辵辷辸辺辻込辿迀迃迆"],["de80","迉",4,"迏迒迖迗迚迠迡迣迧迬迯迱迲迴迵迶迺迻迼迾迿逇逈逌逎逓逕逘蕖蔻蓿蓼蕙蕈蕨蕤蕞蕺瞢蕃蕲蕻薤薨薇薏蕹薮薜薅薹薷薰藓藁藜藿蘧蘅蘩蘖蘼廾弈夼奁耷奕奚奘匏尢尥尬尴扌扪抟抻拊拚拗拮挢拶挹捋捃掭揶捱捺掎掴捭掬掊捩掮掼揲揸揠揿揄揞揎摒揆掾摅摁搋搛搠搌搦搡摞撄摭撖"],["df40","這逜連逤逥逧",5,"逰",4,"逷逹逺逽逿遀遃遅遆遈",4,"過達違遖遙遚遜",5,"遤遦遧適遪遫遬遯",4,"遶",6,"遾邁"],["df80","還邅邆邇邉邊邌",4,"邒邔邖邘邚邜邞邟邠邤邥邧邨邩邫邭邲邷邼邽邿郀摺撷撸撙撺擀擐擗擤擢攉攥攮弋忒甙弑卟叱叽叩叨叻吒吖吆呋呒呓呔呖呃吡呗呙吣吲咂咔呷呱呤咚咛咄呶呦咝哐咭哂咴哒咧咦哓哔呲咣哕咻咿哌哙哚哜咩咪咤哝哏哞唛哧唠哽唔哳唢唣唏唑唧唪啧喏喵啉啭啁啕唿啐唼"],["e040","郂郃郆郈郉郋郌郍郒郔郕郖郘郙郚郞郟郠郣郤郥郩郪郬郮郰郱郲郳郵郶郷郹郺郻郼郿鄀鄁鄃鄅",19,"鄚鄛鄜"],["e080","鄝鄟鄠鄡鄤",10,"鄰鄲",6,"鄺",8,"酄唷啖啵啶啷唳唰啜喋嗒喃喱喹喈喁喟啾嗖喑啻嗟喽喾喔喙嗪嗷嗉嘟嗑嗫嗬嗔嗦嗝嗄嗯嗥嗲嗳嗌嗍嗨嗵嗤辔嘞嘈嘌嘁嘤嘣嗾嘀嘧嘭噘嘹噗嘬噍噢噙噜噌噔嚆噤噱噫噻噼嚅嚓嚯囔囗囝囡囵囫囹囿圄圊圉圜帏帙帔帑帱帻帼"],["e140","酅酇酈酑酓酔酕酖酘酙酛酜酟酠酦酧酨酫酭酳酺酻酼醀",4,"醆醈醊醎醏醓",6,"醜",5,"醤",5,"醫醬醰醱醲醳醶醷醸醹醻"],["e180","醼",10,"釈釋釐釒",9,"針",8,"帷幄幔幛幞幡岌屺岍岐岖岈岘岙岑岚岜岵岢岽岬岫岱岣峁岷峄峒峤峋峥崂崃崧崦崮崤崞崆崛嵘崾崴崽嵬嵛嵯嵝嵫嵋嵊嵩嵴嶂嶙嶝豳嶷巅彳彷徂徇徉後徕徙徜徨徭徵徼衢彡犭犰犴犷犸狃狁狎狍狒狨狯狩狲狴狷猁狳猃狺"],["e240","釦",62],["e280","鈥",32,"狻猗猓猡猊猞猝猕猢猹猥猬猸猱獐獍獗獠獬獯獾舛夥飧夤夂饣饧",5,"饴饷饽馀馄馇馊馍馐馑馓馔馕庀庑庋庖庥庠庹庵庾庳赓廒廑廛廨廪膺忄忉忖忏怃忮怄忡忤忾怅怆忪忭忸怙怵怦怛怏怍怩怫怊怿怡恸恹恻恺恂"],["e340","鉆",45,"鉵",16],["e380","銆",7,"銏",24,"恪恽悖悚悭悝悃悒悌悛惬悻悱惝惘惆惚悴愠愦愕愣惴愀愎愫慊慵憬憔憧憷懔懵忝隳闩闫闱闳闵闶闼闾阃阄阆阈阊阋阌阍阏阒阕阖阗阙阚丬爿戕氵汔汜汊沣沅沐沔沌汨汩汴汶沆沩泐泔沭泷泸泱泗沲泠泖泺泫泮沱泓泯泾"],["e440","銨",5,"銯",24,"鋉",31],["e480","鋩",32,"洹洧洌浃浈洇洄洙洎洫浍洮洵洚浏浒浔洳涑浯涞涠浞涓涔浜浠浼浣渚淇淅淞渎涿淠渑淦淝淙渖涫渌涮渫湮湎湫溲湟溆湓湔渲渥湄滟溱溘滠漭滢溥溧溽溻溷滗溴滏溏滂溟潢潆潇漤漕滹漯漶潋潴漪漉漩澉澍澌潸潲潼潺濑"],["e540","錊",51,"錿",10],["e580","鍊",31,"鍫濉澧澹澶濂濡濮濞濠濯瀚瀣瀛瀹瀵灏灞宀宄宕宓宥宸甯骞搴寤寮褰寰蹇謇辶迓迕迥迮迤迩迦迳迨逅逄逋逦逑逍逖逡逵逶逭逯遄遑遒遐遨遘遢遛暹遴遽邂邈邃邋彐彗彖彘尻咫屐屙孱屣屦羼弪弩弭艴弼鬻屮妁妃妍妩妪妣"],["e640","鍬",34,"鎐",27],["e680","鎬",29,"鏋鏌鏍妗姊妫妞妤姒妲妯姗妾娅娆姝娈姣姘姹娌娉娲娴娑娣娓婀婧婊婕娼婢婵胬媪媛婷婺媾嫫媲嫒嫔媸嫠嫣嫱嫖嫦嫘嫜嬉嬗嬖嬲嬷孀尕尜孚孥孳孑孓孢驵驷驸驺驿驽骀骁骅骈骊骐骒骓骖骘骛骜骝骟骠骢骣骥骧纟纡纣纥纨纩"],["e740","鏎",7,"鏗",54],["e780","鐎",32,"纭纰纾绀绁绂绉绋绌绐绔绗绛绠绡绨绫绮绯绱绲缍绶绺绻绾缁缂缃缇缈缋缌缏缑缒缗缙缜缛缟缡",6,"缪缫缬缭缯",4,"缵幺畿巛甾邕玎玑玮玢玟珏珂珑玷玳珀珉珈珥珙顼琊珩珧珞玺珲琏琪瑛琦琥琨琰琮琬"],["e840","鐯",14,"鐿",43,"鑬鑭鑮鑯"],["e880","鑰",20,"钑钖钘铇铏铓铔铚铦铻锜锠琛琚瑁瑜瑗瑕瑙瑷瑭瑾璜璎璀璁璇璋璞璨璩璐璧瓒璺韪韫韬杌杓杞杈杩枥枇杪杳枘枧杵枨枞枭枋杷杼柰栉柘栊柩枰栌柙枵柚枳柝栀柃枸柢栎柁柽栲栳桠桡桎桢桄桤梃栝桕桦桁桧桀栾桊桉栩梵梏桴桷梓桫棂楮棼椟椠棹"],["e940","锧锳锽镃镈镋镕镚镠镮镴镵長",7,"門",42],["e980","閫",32,"椤棰椋椁楗棣椐楱椹楠楂楝榄楫榀榘楸椴槌榇榈槎榉楦楣楹榛榧榻榫榭槔榱槁槊槟榕槠榍槿樯槭樗樘橥槲橄樾檠橐橛樵檎橹樽樨橘橼檑檐檩檗檫猷獒殁殂殇殄殒殓殍殚殛殡殪轫轭轱轲轳轵轶轸轷轹轺轼轾辁辂辄辇辋"],["ea40","闌",27,"闬闿阇阓阘阛阞阠阣",6,"阫阬阭阯阰阷阸阹阺阾陁陃陊陎陏陑陒陓陖陗"],["ea80","陘陙陚陜陝陞陠陣陥陦陫陭",4,"陳陸",12,"隇隉隊辍辎辏辘辚軎戋戗戛戟戢戡戥戤戬臧瓯瓴瓿甏甑甓攴旮旯旰昊昙杲昃昕昀炅曷昝昴昱昶昵耆晟晔晁晏晖晡晗晷暄暌暧暝暾曛曜曦曩贲贳贶贻贽赀赅赆赈赉赇赍赕赙觇觊觋觌觎觏觐觑牮犟牝牦牯牾牿犄犋犍犏犒挈挲掰"],["eb40","隌階隑隒隓隕隖隚際隝",9,"隨",7,"隱隲隴隵隷隸隺隻隿雂雃雈雊雋雐雑雓雔雖",9,"雡",6,"雫"],["eb80","雬雭雮雰雱雲雴雵雸雺電雼雽雿霂霃霅霊霋霌霐霑霒霔霕霗",4,"霝霟霠搿擘耄毪毳毽毵毹氅氇氆氍氕氘氙氚氡氩氤氪氲攵敕敫牍牒牖爰虢刖肟肜肓肼朊肽肱肫肭肴肷胧胨胩胪胛胂胄胙胍胗朐胝胫胱胴胭脍脎胲胼朕脒豚脶脞脬脘脲腈腌腓腴腙腚腱腠腩腼腽腭腧塍媵膈膂膑滕膣膪臌朦臊膻"],["ec40","霡",8,"霫霬霮霯霱霳",4,"霺霻霼霽霿",18,"靔靕靗靘靚靜靝靟靣靤靦靧靨靪",7],["ec80","靲靵靷",4,"靽",7,"鞆",4,"鞌鞎鞏鞐鞓鞕鞖鞗鞙",4,"臁膦欤欷欹歃歆歙飑飒飓飕飙飚殳彀毂觳斐齑斓於旆旄旃旌旎旒旖炀炜炖炝炻烀炷炫炱烨烊焐焓焖焯焱煳煜煨煅煲煊煸煺熘熳熵熨熠燠燔燧燹爝爨灬焘煦熹戾戽扃扈扉礻祀祆祉祛祜祓祚祢祗祠祯祧祺禅禊禚禧禳忑忐"],["ed40","鞞鞟鞡鞢鞤",6,"鞬鞮鞰鞱鞳鞵",46],["ed80","韤韥韨韮",4,"韴韷",23,"怼恝恚恧恁恙恣悫愆愍慝憩憝懋懑戆肀聿沓泶淼矶矸砀砉砗砘砑斫砭砜砝砹砺砻砟砼砥砬砣砩硎硭硖硗砦硐硇硌硪碛碓碚碇碜碡碣碲碹碥磔磙磉磬磲礅磴礓礤礞礴龛黹黻黼盱眄眍盹眇眈眚眢眙眭眦眵眸睐睑睇睃睚睨"],["ee40","頏",62],["ee80","顎",32,"睢睥睿瞍睽瞀瞌瞑瞟瞠瞰瞵瞽町畀畎畋畈畛畲畹疃罘罡罟詈罨罴罱罹羁罾盍盥蠲钅钆钇钋钊钌钍钏钐钔钗钕钚钛钜钣钤钫钪钭钬钯钰钲钴钶",4,"钼钽钿铄铈",6,"铐铑铒铕铖铗铙铘铛铞铟铠铢铤铥铧铨铪"],["ef40","顯",5,"颋颎颒颕颙颣風",37,"飏飐飔飖飗飛飜飝飠",4],["ef80","飥飦飩",30,"铩铫铮铯铳铴铵铷铹铼铽铿锃锂锆锇锉锊锍锎锏锒",4,"锘锛锝锞锟锢锪锫锩锬锱锲锴锶锷锸锼锾锿镂锵镄镅镆镉镌镎镏镒镓镔镖镗镘镙镛镞镟镝镡镢镤",8,"镯镱镲镳锺矧矬雉秕秭秣秫稆嵇稃稂稞稔"],["f040","餈",4,"餎餏餑",28,"餯",26],["f080","饊",9,"饖",12,"饤饦饳饸饹饻饾馂馃馉稹稷穑黏馥穰皈皎皓皙皤瓞瓠甬鸠鸢鸨",4,"鸲鸱鸶鸸鸷鸹鸺鸾鹁鹂鹄鹆鹇鹈鹉鹋鹌鹎鹑鹕鹗鹚鹛鹜鹞鹣鹦",6,"鹱鹭鹳疒疔疖疠疝疬疣疳疴疸痄疱疰痃痂痖痍痣痨痦痤痫痧瘃痱痼痿瘐瘀瘅瘌瘗瘊瘥瘘瘕瘙"],["f140","馌馎馚",10,"馦馧馩",47],["f180","駙",32,"瘛瘼瘢瘠癀瘭瘰瘿瘵癃瘾瘳癍癞癔癜癖癫癯翊竦穸穹窀窆窈窕窦窠窬窨窭窳衤衩衲衽衿袂袢裆袷袼裉裢裎裣裥裱褚裼裨裾裰褡褙褓褛褊褴褫褶襁襦襻疋胥皲皴矜耒耔耖耜耠耢耥耦耧耩耨耱耋耵聃聆聍聒聩聱覃顸颀颃"],["f240","駺",62],["f280","騹",32,"颉颌颍颏颔颚颛颞颟颡颢颥颦虍虔虬虮虿虺虼虻蚨蚍蚋蚬蚝蚧蚣蚪蚓蚩蚶蛄蚵蛎蚰蚺蚱蚯蛉蛏蚴蛩蛱蛲蛭蛳蛐蜓蛞蛴蛟蛘蛑蜃蜇蛸蜈蜊蜍蜉蜣蜻蜞蜥蜮蜚蜾蝈蜴蜱蜩蜷蜿螂蜢蝽蝾蝻蝠蝰蝌蝮螋蝓蝣蝼蝤蝙蝥螓螯螨蟒"],["f340","驚",17,"驲骃骉骍骎骔骕骙骦骩",6,"骲骳骴骵骹骻骽骾骿髃髄髆",4,"髍髎髏髐髒體髕髖髗髙髚髛髜"],["f380","髝髞髠髢髣髤髥髧髨髩髪髬髮髰",8,"髺髼",6,"鬄鬅鬆蟆螈螅螭螗螃螫蟥螬螵螳蟋蟓螽蟑蟀蟊蟛蟪蟠蟮蠖蠓蟾蠊蠛蠡蠹蠼缶罂罄罅舐竺竽笈笃笄笕笊笫笏筇笸笪笙笮笱笠笥笤笳笾笞筘筚筅筵筌筝筠筮筻筢筲筱箐箦箧箸箬箝箨箅箪箜箢箫箴篑篁篌篝篚篥篦篪簌篾篼簏簖簋"],["f440","鬇鬉",5,"鬐鬑鬒鬔",10,"鬠鬡鬢鬤",10,"鬰鬱鬳",7,"鬽鬾鬿魀魆魊魋魌魎魐魒魓魕",5],["f480","魛",32,"簟簪簦簸籁籀臾舁舂舄臬衄舡舢舣舭舯舨舫舸舻舳舴舾艄艉艋艏艚艟艨衾袅袈裘裟襞羝羟羧羯羰羲籼敉粑粝粜粞粢粲粼粽糁糇糌糍糈糅糗糨艮暨羿翎翕翥翡翦翩翮翳糸絷綦綮繇纛麸麴赳趄趔趑趱赧赭豇豉酊酐酎酏酤"],["f540","魼",62],["f580","鮻",32,"酢酡酰酩酯酽酾酲酴酹醌醅醐醍醑醢醣醪醭醮醯醵醴醺豕鹾趸跫踅蹙蹩趵趿趼趺跄跖跗跚跞跎跏跛跆跬跷跸跣跹跻跤踉跽踔踝踟踬踮踣踯踺蹀踹踵踽踱蹉蹁蹂蹑蹒蹊蹰蹶蹼蹯蹴躅躏躔躐躜躞豸貂貊貅貘貔斛觖觞觚觜"],["f640","鯜",62],["f680","鰛",32,"觥觫觯訾謦靓雩雳雯霆霁霈霏霎霪霭霰霾龀龃龅",5,"龌黾鼋鼍隹隼隽雎雒瞿雠銎銮鋈錾鍪鏊鎏鐾鑫鱿鲂鲅鲆鲇鲈稣鲋鲎鲐鲑鲒鲔鲕鲚鲛鲞",5,"鲥",4,"鲫鲭鲮鲰",7,"鲺鲻鲼鲽鳄鳅鳆鳇鳊鳋"],["f740","鰼",62],["f780","鱻鱽鱾鲀鲃鲄鲉鲊鲌鲏鲓鲖鲗鲘鲙鲝鲪鲬鲯鲹鲾",4,"鳈鳉鳑鳒鳚鳛鳠鳡鳌",4,"鳓鳔鳕鳗鳘鳙鳜鳝鳟鳢靼鞅鞑鞒鞔鞯鞫鞣鞲鞴骱骰骷鹘骶骺骼髁髀髅髂髋髌髑魅魃魇魉魈魍魑飨餍餮饕饔髟髡髦髯髫髻髭髹鬈鬏鬓鬟鬣麽麾縻麂麇麈麋麒鏖麝麟黛黜黝黠黟黢黩黧黥黪黯鼢鼬鼯鼹鼷鼽鼾齄"],["f840","鳣",62],["f880","鴢",32],["f940","鵃",62],["f980","鶂",32],["fa40","鶣",62],["fa80","鷢",32],["fb40","鸃",27,"鸤鸧鸮鸰鸴鸻鸼鹀鹍鹐鹒鹓鹔鹖鹙鹝鹟鹠鹡鹢鹥鹮鹯鹲鹴",9,"麀"],["fb80","麁麃麄麅麆麉麊麌",5,"麔",8,"麞麠",5,"麧麨麩麪"],["fc40","麫",8,"麵麶麷麹麺麼麿",4,"黅黆黇黈黊黋黌黐黒黓黕黖黗黙黚點黡黣黤黦黨黫黬黭黮黰",8,"黺黽黿",6],["fc80","鼆",4,"鼌鼏鼑鼒鼔鼕鼖鼘鼚",5,"鼡鼣",8,"鼭鼮鼰鼱"],["fd40","鼲",4,"鼸鼺鼼鼿",4,"齅",10,"齒",38],["fd80","齹",5,"龁龂龍",11,"龜龝龞龡",4,"郎凉秊裏隣"],["fe40","兀嗀﨎﨏﨑﨓﨔礼﨟蘒﨡﨣﨤﨧﨨﨩"]]');
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp949.json": function(module) {
        "use strict";
        module.exports = JSON.parse('[["0","\\u0000",127],["8141","갂갃갅갆갋",4,"갘갞갟갡갢갣갥",6,"갮갲갳갴"],["8161","갵갶갷갺갻갽갾갿걁",9,"걌걎",5,"걕"],["8181","걖걗걙걚걛걝",18,"걲걳걵걶걹걻",4,"겂겇겈겍겎겏겑겒겓겕",6,"겞겢",5,"겫겭겮겱",6,"겺겾겿곀곂곃곅곆곇곉곊곋곍",7,"곖곘",7,"곢곣곥곦곩곫곭곮곲곴곷",4,"곾곿괁괂괃괅괇",4,"괎괐괒괓"],["8241","괔괕괖괗괙괚괛괝괞괟괡",7,"괪괫괮",5],["8261","괶괷괹괺괻괽",6,"굆굈굊",5,"굑굒굓굕굖굗"],["8281","굙",7,"굢굤",7,"굮굯굱굲굷굸굹굺굾궀궃",4,"궊궋궍궎궏궑",10,"궞",5,"궥",17,"궸",7,"귂귃귅귆귇귉",6,"귒귔",7,"귝귞귟귡귢귣귥",18],["8341","귺귻귽귾긂",5,"긊긌긎",5,"긕",7],["8361","긝",18,"긲긳긵긶긹긻긼"],["8381","긽긾긿깂깄깇깈깉깋깏깑깒깓깕깗",4,"깞깢깣깤깦깧깪깫깭깮깯깱",6,"깺깾",5,"꺆",5,"꺍",46,"꺿껁껂껃껅",6,"껎껒",5,"껚껛껝",8],["8441","껦껧껩껪껬껮",5,"껵껶껷껹껺껻껽",8],["8461","꼆꼉꼊꼋꼌꼎꼏꼑",18],["8481","꼤",7,"꼮꼯꼱꼳꼵",6,"꼾꽀꽄꽅꽆꽇꽊",5,"꽑",10,"꽞",5,"꽦",18,"꽺",5,"꾁꾂꾃꾅꾆꾇꾉",6,"꾒꾓꾔꾖",5,"꾝",26,"꾺꾻꾽꾾"],["8541","꾿꿁",5,"꿊꿌꿏",4,"꿕",6,"꿝",4],["8561","꿢",5,"꿪",5,"꿲꿳꿵꿶꿷꿹",6,"뀂뀃"],["8581","뀅",6,"뀍뀎뀏뀑뀒뀓뀕",6,"뀞",9,"뀩",26,"끆끇끉끋끍끏끐끑끒끖끘끚끛끜끞",29,"끾끿낁낂낃낅",6,"낎낐낒",5,"낛낝낞낣낤"],["8641","낥낦낧낪낰낲낶낷낹낺낻낽",6,"냆냊",5,"냒"],["8661","냓냕냖냗냙",6,"냡냢냣냤냦",10],["8681","냱",22,"넊넍넎넏넑넔넕넖넗넚넞",4,"넦넧넩넪넫넭",6,"넶넺",5,"녂녃녅녆녇녉",6,"녒녓녖녗녙녚녛녝녞녟녡",22,"녺녻녽녾녿놁놃",4,"놊놌놎놏놐놑놕놖놗놙놚놛놝"],["8741","놞",9,"놩",15],["8761","놹",18,"뇍뇎뇏뇑뇒뇓뇕"],["8781","뇖",5,"뇞뇠",7,"뇪뇫뇭뇮뇯뇱",7,"뇺뇼뇾",5,"눆눇눉눊눍",6,"눖눘눚",5,"눡",18,"눵",6,"눽",26,"뉙뉚뉛뉝뉞뉟뉡",6,"뉪",4],["8841","뉯",4,"뉶",5,"뉽",6,"늆늇늈늊",4],["8861","늏늒늓늕늖늗늛",4,"늢늤늧늨늩늫늭늮늯늱늲늳늵늶늷"],["8881","늸",15,"닊닋닍닎닏닑닓",4,"닚닜닞닟닠닡닣닧닩닪닰닱닲닶닼닽닾댂댃댅댆댇댉",6,"댒댖",5,"댝",54,"덗덙덚덝덠덡덢덣"],["8941","덦덨덪덬덭덯덲덳덵덶덷덹",6,"뎂뎆",5,"뎍"],["8961","뎎뎏뎑뎒뎓뎕",10,"뎢",5,"뎩뎪뎫뎭"],["8981","뎮",21,"돆돇돉돊돍돏돑돒돓돖돘돚돜돞돟돡돢돣돥돦돧돩",18,"돽",18,"됑",6,"됙됚됛됝됞됟됡",6,"됪됬",7,"됵",15],["8a41","둅",10,"둒둓둕둖둗둙",6,"둢둤둦"],["8a61","둧",4,"둭",18,"뒁뒂"],["8a81","뒃",4,"뒉",19,"뒞",5,"뒥뒦뒧뒩뒪뒫뒭",7,"뒶뒸뒺",5,"듁듂듃듅듆듇듉",6,"듑듒듓듔듖",5,"듞듟듡듢듥듧",4,"듮듰듲",5,"듹",26,"딖딗딙딚딝"],["8b41","딞",5,"딦딫",4,"딲딳딵딶딷딹",6,"땂땆"],["8b61","땇땈땉땊땎땏땑땒땓땕",6,"땞땢",8],["8b81","땫",52,"떢떣떥떦떧떩떬떭떮떯떲떶",4,"떾떿뗁뗂뗃뗅",6,"뗎뗒",5,"뗙",18,"뗭",18],["8c41","똀",15,"똒똓똕똖똗똙",4],["8c61","똞",6,"똦",5,"똭",6,"똵",5],["8c81","똻",12,"뙉",26,"뙥뙦뙧뙩",50,"뚞뚟뚡뚢뚣뚥",5,"뚭뚮뚯뚰뚲",16],["8d41","뛃",16,"뛕",8],["8d61","뛞",17,"뛱뛲뛳뛵뛶뛷뛹뛺"],["8d81","뛻",4,"뜂뜃뜄뜆",33,"뜪뜫뜭뜮뜱",6,"뜺뜼",7,"띅띆띇띉띊띋띍",6,"띖",9,"띡띢띣띥띦띧띩",6,"띲띴띶",5,"띾띿랁랂랃랅",6,"랎랓랔랕랚랛랝랞"],["8e41","랟랡",6,"랪랮",5,"랶랷랹",8],["8e61","럂",4,"럈럊",19],["8e81","럞",13,"럮럯럱럲럳럵",6,"럾렂",4,"렊렋렍렎렏렑",6,"렚렜렞",5,"렦렧렩렪렫렭",6,"렶렺",5,"롁롂롃롅",11,"롒롔",7,"롞롟롡롢롣롥",6,"롮롰롲",5,"롹롺롻롽",7],["8f41","뢅",7,"뢎",17],["8f61","뢠",7,"뢩",6,"뢱뢲뢳뢵뢶뢷뢹",4],["8f81","뢾뢿룂룄룆",5,"룍룎룏룑룒룓룕",7,"룞룠룢",5,"룪룫룭룮룯룱",6,"룺룼룾",5,"뤅",18,"뤙",6,"뤡",26,"뤾뤿륁륂륃륅",6,"륍륎륐륒",5],["9041","륚륛륝륞륟륡",6,"륪륬륮",5,"륶륷륹륺륻륽"],["9061","륾",5,"릆릈릋릌릏",15],["9081","릟",12,"릮릯릱릲릳릵",6,"릾맀맂",5,"맊맋맍맓",4,"맚맜맟맠맢맦맧맩맪맫맭",6,"맶맻",4,"먂",5,"먉",11,"먖",33,"먺먻먽먾먿멁멃멄멅멆"],["9141","멇멊멌멏멐멑멒멖멗멙멚멛멝",6,"멦멪",5],["9161","멲멳멵멶멷멹",9,"몆몈몉몊몋몍",5],["9181","몓",20,"몪몭몮몯몱몳",4,"몺몼몾",5,"뫅뫆뫇뫉",14,"뫚",33,"뫽뫾뫿묁묂묃묅",7,"묎묐묒",5,"묙묚묛묝묞묟묡",6],["9241","묨묪묬",7,"묷묹묺묿",4,"뭆뭈뭊뭋뭌뭎뭑뭒"],["9261","뭓뭕뭖뭗뭙",7,"뭢뭤",7,"뭭",4],["9281","뭲",21,"뮉뮊뮋뮍뮎뮏뮑",18,"뮥뮦뮧뮩뮪뮫뮭",6,"뮵뮶뮸",7,"믁믂믃믅믆믇믉",6,"믑믒믔",35,"믺믻믽믾밁"],["9341","밃",4,"밊밎밐밒밓밙밚밠밡밢밣밦밨밪밫밬밮밯밲밳밵"],["9361","밶밷밹",6,"뱂뱆뱇뱈뱊뱋뱎뱏뱑",8],["9381","뱚뱛뱜뱞",37,"벆벇벉벊벍벏",4,"벖벘벛",4,"벢벣벥벦벩",6,"벲벶",5,"벾벿볁볂볃볅",7,"볎볒볓볔볖볗볙볚볛볝",22,"볷볹볺볻볽"],["9441","볾",5,"봆봈봊",5,"봑봒봓봕",8],["9461","봞",5,"봥",6,"봭",12],["9481","봺",5,"뵁",6,"뵊뵋뵍뵎뵏뵑",6,"뵚",9,"뵥뵦뵧뵩",22,"붂붃붅붆붋",4,"붒붔붖붗붘붛붝",6,"붥",10,"붱",6,"붹",24],["9541","뷒뷓뷖뷗뷙뷚뷛뷝",11,"뷪",5,"뷱"],["9561","뷲뷳뷵뷶뷷뷹",6,"븁븂븄븆",5,"븎븏븑븒븓"],["9581","븕",6,"븞븠",35,"빆빇빉빊빋빍빏",4,"빖빘빜빝빞빟빢빣빥빦빧빩빫",4,"빲빶",4,"빾빿뺁뺂뺃뺅",6,"뺎뺒",5,"뺚",13,"뺩",14],["9641","뺸",23,"뻒뻓"],["9661","뻕뻖뻙",6,"뻡뻢뻦",5,"뻭",8],["9681","뻶",10,"뼂",5,"뼊",13,"뼚뼞",33,"뽂뽃뽅뽆뽇뽉",6,"뽒뽓뽔뽖",44],["9741","뾃",16,"뾕",8],["9761","뾞",17,"뾱",7],["9781","뾹",11,"뿆",5,"뿎뿏뿑뿒뿓뿕",6,"뿝뿞뿠뿢",89,"쀽쀾쀿"],["9841","쁀",16,"쁒",5,"쁙쁚쁛"],["9861","쁝쁞쁟쁡",6,"쁪",15],["9881","쁺",21,"삒삓삕삖삗삙",6,"삢삤삦",5,"삮삱삲삷",4,"삾샂샃샄샆샇샊샋샍샎샏샑",6,"샚샞",5,"샦샧샩샪샫샭",6,"샶샸샺",5,"섁섂섃섅섆섇섉",6,"섑섒섓섔섖",5,"섡섢섥섨섩섪섫섮"],["9941","섲섳섴섵섷섺섻섽섾섿셁",6,"셊셎",5,"셖셗"],["9961","셙셚셛셝",6,"셦셪",5,"셱셲셳셵셶셷셹셺셻"],["9981","셼",8,"솆",5,"솏솑솒솓솕솗",4,"솞솠솢솣솤솦솧솪솫솭솮솯솱",11,"솾",5,"쇅쇆쇇쇉쇊쇋쇍",6,"쇕쇖쇙",6,"쇡쇢쇣쇥쇦쇧쇩",6,"쇲쇴",7,"쇾쇿숁숂숃숅",6,"숎숐숒",5,"숚숛숝숞숡숢숣"],["9a41","숤숥숦숧숪숬숮숰숳숵",16],["9a61","쉆쉇쉉",6,"쉒쉓쉕쉖쉗쉙",6,"쉡쉢쉣쉤쉦"],["9a81","쉧",4,"쉮쉯쉱쉲쉳쉵",6,"쉾슀슂",5,"슊",5,"슑",6,"슙슚슜슞",5,"슦슧슩슪슫슮",5,"슶슸슺",33,"싞싟싡싢싥",5,"싮싰싲싳싴싵싷싺싽싾싿쌁",6,"쌊쌋쌎쌏"],["9b41","쌐쌑쌒쌖쌗쌙쌚쌛쌝",6,"쌦쌧쌪",8],["9b61","쌳",17,"썆",7],["9b81","썎",25,"썪썫썭썮썯썱썳",4,"썺썻썾",5,"쎅쎆쎇쎉쎊쎋쎍",50,"쏁",22,"쏚"],["9c41","쏛쏝쏞쏡쏣",4,"쏪쏫쏬쏮",5,"쏶쏷쏹",5],["9c61","쏿",8,"쐉",6,"쐑",9],["9c81","쐛",8,"쐥",6,"쐭쐮쐯쐱쐲쐳쐵",6,"쐾",9,"쑉",26,"쑦쑧쑩쑪쑫쑭",6,"쑶쑷쑸쑺",5,"쒁",18,"쒕",6,"쒝",12],["9d41","쒪",13,"쒹쒺쒻쒽",8],["9d61","쓆",25],["9d81","쓠",8,"쓪",5,"쓲쓳쓵쓶쓷쓹쓻쓼쓽쓾씂",9,"씍씎씏씑씒씓씕",6,"씝",10,"씪씫씭씮씯씱",6,"씺씼씾",5,"앆앇앋앏앐앑앒앖앚앛앜앟앢앣앥앦앧앩",6,"앲앶",5,"앾앿얁얂얃얅얆얈얉얊얋얎얐얒얓얔"],["9e41","얖얙얚얛얝얞얟얡",7,"얪",9,"얶"],["9e61","얷얺얿",4,"엋엍엏엒엓엕엖엗엙",6,"엢엤엦엧"],["9e81","엨엩엪엫엯엱엲엳엵엸엹엺엻옂옃옄옉옊옋옍옎옏옑",6,"옚옝",6,"옦옧옩옪옫옯옱옲옶옸옺옼옽옾옿왂왃왅왆왇왉",6,"왒왖",5,"왞왟왡",10,"왭왮왰왲",5,"왺왻왽왾왿욁",6,"욊욌욎",5,"욖욗욙욚욛욝",6,"욦"],["9f41","욨욪",5,"욲욳욵욶욷욻",4,"웂웄웆",5,"웎"],["9f61","웏웑웒웓웕",6,"웞웟웢",5,"웪웫웭웮웯웱웲"],["9f81","웳",4,"웺웻웼웾",5,"윆윇윉윊윋윍",6,"윖윘윚",5,"윢윣윥윦윧윩",6,"윲윴윶윸윹윺윻윾윿읁읂읃읅",4,"읋읎읐읙읚읛읝읞읟읡",6,"읩읪읬",7,"읶읷읹읺읻읿잀잁잂잆잋잌잍잏잒잓잕잙잛",4,"잢잧",4,"잮잯잱잲잳잵잶잷"],["a041","잸잹잺잻잾쟂",5,"쟊쟋쟍쟏쟑",6,"쟙쟚쟛쟜"],["a061","쟞",5,"쟥쟦쟧쟩쟪쟫쟭",13],["a081","쟻",4,"젂젃젅젆젇젉젋",4,"젒젔젗",4,"젞젟젡젢젣젥",6,"젮젰젲",5,"젹젺젻젽젾젿졁",6,"졊졋졎",5,"졕",26,"졲졳졵졶졷졹졻",4,"좂좄좈좉좊좎",5,"좕",7,"좞좠좢좣좤"],["a141","좥좦좧좩",18,"좾좿죀죁"],["a161","죂죃죅죆죇죉죊죋죍",6,"죖죘죚",5,"죢죣죥"],["a181","죦",14,"죶",5,"죾죿줁줂줃줇",4,"줎　、。·‥…¨〃­―∥＼∼‘’“”〔〕〈",9,"±×÷≠≤≥∞∴°′″℃Å￠￡￥♂♀∠⊥⌒∂∇≡≒§※☆★○●◎◇◆□■△▲▽▼→←↑↓↔〓≪≫√∽∝∵∫∬∈∋⊆⊇⊂⊃∪∩∧∨￢"],["a241","줐줒",5,"줙",18],["a261","줭",6,"줵",18],["a281","쥈",7,"쥒쥓쥕쥖쥗쥙",6,"쥢쥤",7,"쥭쥮쥯⇒⇔∀∃´～ˇ˘˝˚˙¸˛¡¿ː∮∑∏¤℉‰◁◀▷▶♤♠♡♥♧♣⊙◈▣◐◑▒▤▥▨▧▦▩♨☏☎☜☞¶†‡↕↗↙↖↘♭♩♪♬㉿㈜№㏇™㏂㏘℡€®"],["a341","쥱쥲쥳쥵",6,"쥽",10,"즊즋즍즎즏"],["a361","즑",6,"즚즜즞",16],["a381","즯",16,"짂짃짅짆짉짋",4,"짒짔짗짘짛！",58,"￦］",32,"￣"],["a441","짞짟짡짣짥짦짨짩짪짫짮짲",5,"짺짻짽짾짿쨁쨂쨃쨄"],["a461","쨅쨆쨇쨊쨎",5,"쨕쨖쨗쨙",12],["a481","쨦쨧쨨쨪",28,"ㄱ",93],["a541","쩇",4,"쩎쩏쩑쩒쩓쩕",6,"쩞쩢",5,"쩩쩪"],["a561","쩫",17,"쩾",5,"쪅쪆"],["a581","쪇",16,"쪙",14,"ⅰ",9],["a5b0","Ⅰ",9],["a5c1","Α",16,"Σ",6],["a5e1","α",16,"σ",6],["a641","쪨",19,"쪾쪿쫁쫂쫃쫅"],["a661","쫆",5,"쫎쫐쫒쫔쫕쫖쫗쫚",5,"쫡",6],["a681","쫨쫩쫪쫫쫭",6,"쫵",18,"쬉쬊─│┌┐┘└├┬┤┴┼━┃┏┓┛┗┣┳┫┻╋┠┯┨┷┿┝┰┥┸╂┒┑┚┙┖┕┎┍┞┟┡┢┦┧┩┪┭┮┱┲┵┶┹┺┽┾╀╁╃",7],["a741","쬋",4,"쬑쬒쬓쬕쬖쬗쬙",6,"쬢",7],["a761","쬪",22,"쭂쭃쭄"],["a781","쭅쭆쭇쭊쭋쭍쭎쭏쭑",6,"쭚쭛쭜쭞",5,"쭥",7,"㎕㎖㎗ℓ㎘㏄㎣㎤㎥㎦㎙",9,"㏊㎍㎎㎏㏏㎈㎉㏈㎧㎨㎰",9,"㎀",4,"㎺",5,"㎐",4,"Ω㏀㏁㎊㎋㎌㏖㏅㎭㎮㎯㏛㎩㎪㎫㎬㏝㏐㏓㏃㏉㏜㏆"],["a841","쭭",10,"쭺",14],["a861","쮉",18,"쮝",6],["a881","쮤",19,"쮹",11,"ÆÐªĦ"],["a8a6","Ĳ"],["a8a8","ĿŁØŒºÞŦŊ"],["a8b1","㉠",27,"ⓐ",25,"①",14,"½⅓⅔¼¾⅛⅜⅝⅞"],["a941","쯅",14,"쯕",10],["a961","쯠쯡쯢쯣쯥쯦쯨쯪",18],["a981","쯽",14,"찎찏찑찒찓찕",6,"찞찟찠찣찤æđðħıĳĸŀłøœßþŧŋŉ㈀",27,"⒜",25,"⑴",14,"¹²³⁴ⁿ₁₂₃₄"],["aa41","찥찦찪찫찭찯찱",6,"찺찿",4,"챆챇챉챊챋챍챎"],["aa61","챏",4,"챖챚",5,"챡챢챣챥챧챩",6,"챱챲"],["aa81","챳챴챶",29,"ぁ",82],["ab41","첔첕첖첗첚첛첝첞첟첡",6,"첪첮",5,"첶첷첹"],["ab61","첺첻첽",6,"쳆쳈쳊",5,"쳑쳒쳓쳕",5],["ab81","쳛",8,"쳥",6,"쳭쳮쳯쳱",12,"ァ",85],["ac41","쳾쳿촀촂",5,"촊촋촍촎촏촑",6,"촚촜촞촟촠"],["ac61","촡촢촣촥촦촧촩촪촫촭",11,"촺",4],["ac81","촿",28,"쵝쵞쵟А",5,"ЁЖ",25],["acd1","а",5,"ёж",25],["ad41","쵡쵢쵣쵥",6,"쵮쵰쵲",5,"쵹",7],["ad61","춁",6,"춉",10,"춖춗춙춚춛춝춞춟"],["ad81","춠춡춢춣춦춨춪",5,"춱",18,"췅"],["ae41","췆",5,"췍췎췏췑",16],["ae61","췢",5,"췩췪췫췭췮췯췱",6,"췺췼췾",4],["ae81","츃츅츆츇츉츊츋츍",6,"츕츖츗츘츚",5,"츢츣츥츦츧츩츪츫"],["af41","츬츭츮츯츲츴츶",19],["af61","칊",13,"칚칛칝칞칢",5,"칪칬"],["af81","칮",5,"칶칷칹칺칻칽",6,"캆캈캊",5,"캒캓캕캖캗캙"],["b041","캚",5,"캢캦",5,"캮",12],["b061","캻",5,"컂",19],["b081","컖",13,"컦컧컩컪컭",6,"컶컺",5,"가각간갇갈갉갊감",7,"같",4,"갠갤갬갭갯갰갱갸갹갼걀걋걍걔걘걜거걱건걷걸걺검겁것겄겅겆겉겊겋게겐겔겜겝겟겠겡겨격겪견겯결겸겹겻겼경곁계곈곌곕곗고곡곤곧골곪곬곯곰곱곳공곶과곽관괄괆"],["b141","켂켃켅켆켇켉",6,"켒켔켖",5,"켝켞켟켡켢켣"],["b161","켥",6,"켮켲",5,"켹",11],["b181","콅",14,"콖콗콙콚콛콝",6,"콦콨콪콫콬괌괍괏광괘괜괠괩괬괭괴괵괸괼굄굅굇굉교굔굘굡굣구국군굳굴굵굶굻굼굽굿궁궂궈궉권궐궜궝궤궷귀귁귄귈귐귑귓규균귤그극근귿글긁금급긋긍긔기긱긴긷길긺김깁깃깅깆깊까깍깎깐깔깖깜깝깟깠깡깥깨깩깬깰깸"],["b241","콭콮콯콲콳콵콶콷콹",6,"쾁쾂쾃쾄쾆",5,"쾍"],["b261","쾎",18,"쾢",5,"쾩"],["b281","쾪",5,"쾱",18,"쿅",6,"깹깻깼깽꺄꺅꺌꺼꺽꺾껀껄껌껍껏껐껑께껙껜껨껫껭껴껸껼꼇꼈꼍꼐꼬꼭꼰꼲꼴꼼꼽꼿꽁꽂꽃꽈꽉꽐꽜꽝꽤꽥꽹꾀꾄꾈꾐꾑꾕꾜꾸꾹꾼꿀꿇꿈꿉꿋꿍꿎꿔꿜꿨꿩꿰꿱꿴꿸뀀뀁뀄뀌뀐뀔뀜뀝뀨끄끅끈끊끌끎끓끔끕끗끙"],["b341","쿌",19,"쿢쿣쿥쿦쿧쿩"],["b361","쿪",5,"쿲쿴쿶",5,"쿽쿾쿿퀁퀂퀃퀅",5],["b381","퀋",5,"퀒",5,"퀙",19,"끝끼끽낀낄낌낍낏낑나낙낚난낟날낡낢남납낫",4,"낱낳내낵낸낼냄냅냇냈냉냐냑냔냘냠냥너넉넋넌널넒넓넘넙넛넜넝넣네넥넨넬넴넵넷넸넹녀녁년녈념녑녔녕녘녜녠노녹논놀놂놈놉놋농높놓놔놘놜놨뇌뇐뇔뇜뇝"],["b441","퀮",5,"퀶퀷퀹퀺퀻퀽",6,"큆큈큊",5],["b461","큑큒큓큕큖큗큙",6,"큡",10,"큮큯"],["b481","큱큲큳큵",6,"큾큿킀킂",18,"뇟뇨뇩뇬뇰뇹뇻뇽누눅눈눋눌눔눕눗눙눠눴눼뉘뉜뉠뉨뉩뉴뉵뉼늄늅늉느늑는늘늙늚늠늡늣능늦늪늬늰늴니닉닌닐닒님닙닛닝닢다닥닦단닫",4,"닳담답닷",4,"닿대댁댄댈댐댑댓댔댕댜더덕덖던덛덜덞덟덤덥"],["b541","킕",14,"킦킧킩킪킫킭",5],["b561","킳킶킸킺",5,"탂탃탅탆탇탊",5,"탒탖",4],["b581","탛탞탟탡탢탣탥",6,"탮탲",5,"탹",11,"덧덩덫덮데덱덴델뎀뎁뎃뎄뎅뎌뎐뎔뎠뎡뎨뎬도독돈돋돌돎돐돔돕돗동돛돝돠돤돨돼됐되된될됨됩됫됴두둑둔둘둠둡둣둥둬뒀뒈뒝뒤뒨뒬뒵뒷뒹듀듄듈듐듕드득든듣들듦듬듭듯등듸디딕딘딛딜딤딥딧딨딩딪따딱딴딸"],["b641","턅",7,"턎",17],["b661","턠",15,"턲턳턵턶턷턹턻턼턽턾"],["b681","턿텂텆",5,"텎텏텑텒텓텕",6,"텞텠텢",5,"텩텪텫텭땀땁땃땄땅땋때땍땐땔땜땝땟땠땡떠떡떤떨떪떫떰떱떳떴떵떻떼떽뗀뗄뗌뗍뗏뗐뗑뗘뗬또똑똔똘똥똬똴뙈뙤뙨뚜뚝뚠뚤뚫뚬뚱뛔뛰뛴뛸뜀뜁뜅뜨뜩뜬뜯뜰뜸뜹뜻띄띈띌띔띕띠띤띨띰띱띳띵라락란랄람랍랏랐랑랒랖랗"],["b741","텮",13,"텽",6,"톅톆톇톉톊"],["b761","톋",20,"톢톣톥톦톧"],["b781","톩",6,"톲톴톶톷톸톹톻톽톾톿퇁",14,"래랙랜랠램랩랫랬랭랴략랸럇량러럭런럴럼럽럿렀렁렇레렉렌렐렘렙렛렝려력련렬렴렵렷렸령례롄롑롓로록론롤롬롭롯롱롸롼뢍뢨뢰뢴뢸룀룁룃룅료룐룔룝룟룡루룩룬룰룸룹룻룽뤄뤘뤠뤼뤽륀륄륌륏륑류륙륜률륨륩"],["b841","퇐",7,"퇙",17],["b861","퇫",8,"퇵퇶퇷퇹",13],["b881","툈툊",5,"툑",24,"륫륭르륵른를름릅릇릉릊릍릎리릭린릴림립릿링마막만많",4,"맘맙맛망맞맡맣매맥맨맬맴맵맷맸맹맺먀먁먈먕머먹먼멀멂멈멉멋멍멎멓메멕멘멜멤멥멧멨멩며멱면멸몃몄명몇몌모목몫몬몰몲몸몹못몽뫄뫈뫘뫙뫼"],["b941","툪툫툮툯툱툲툳툵",6,"툾퉀퉂",5,"퉉퉊퉋퉌"],["b961","퉍",14,"퉝",6,"퉥퉦퉧퉨"],["b981","퉩",22,"튂튃튅튆튇튉튊튋튌묀묄묍묏묑묘묜묠묩묫무묵묶문묻물묽묾뭄뭅뭇뭉뭍뭏뭐뭔뭘뭡뭣뭬뮈뮌뮐뮤뮨뮬뮴뮷므믄믈믐믓미믹민믿밀밂밈밉밋밌밍및밑바",4,"받",4,"밤밥밧방밭배백밴밸뱀뱁뱃뱄뱅뱉뱌뱍뱐뱝버벅번벋벌벎범법벗"],["ba41","튍튎튏튒튓튔튖",5,"튝튞튟튡튢튣튥",6,"튭"],["ba61","튮튯튰튲",5,"튺튻튽튾틁틃",4,"틊틌",5],["ba81","틒틓틕틖틗틙틚틛틝",6,"틦",9,"틲틳틵틶틷틹틺벙벚베벡벤벧벨벰벱벳벴벵벼벽변별볍볏볐병볕볘볜보복볶본볼봄봅봇봉봐봔봤봬뵀뵈뵉뵌뵐뵘뵙뵤뵨부북분붇불붉붊붐붑붓붕붙붚붜붤붰붸뷔뷕뷘뷜뷩뷰뷴뷸븀븃븅브븍븐블븜븝븟비빅빈빌빎빔빕빗빙빚빛빠빡빤"],["bb41","틻",4,"팂팄팆",5,"팏팑팒팓팕팗",4,"팞팢팣"],["bb61","팤팦팧팪팫팭팮팯팱",6,"팺팾",5,"퍆퍇퍈퍉"],["bb81","퍊",31,"빨빪빰빱빳빴빵빻빼빽뺀뺄뺌뺍뺏뺐뺑뺘뺙뺨뻐뻑뻔뻗뻘뻠뻣뻤뻥뻬뼁뼈뼉뼘뼙뼛뼜뼝뽀뽁뽄뽈뽐뽑뽕뾔뾰뿅뿌뿍뿐뿔뿜뿟뿡쀼쁑쁘쁜쁠쁨쁩삐삑삔삘삠삡삣삥사삭삯산삳살삵삶삼삽삿샀상샅새색샌샐샘샙샛샜생샤"],["bc41","퍪",17,"퍾퍿펁펂펃펅펆펇"],["bc61","펈펉펊펋펎펒",5,"펚펛펝펞펟펡",6,"펪펬펮"],["bc81","펯",4,"펵펶펷펹펺펻펽",6,"폆폇폊",5,"폑",5,"샥샨샬샴샵샷샹섀섄섈섐섕서",4,"섣설섦섧섬섭섯섰성섶세섹센셀셈셉셋셌셍셔셕션셜셤셥셧셨셩셰셴셸솅소속솎손솔솖솜솝솟송솥솨솩솬솰솽쇄쇈쇌쇔쇗쇘쇠쇤쇨쇰쇱쇳쇼쇽숀숄숌숍숏숑수숙순숟술숨숩숫숭"],["bd41","폗폙",7,"폢폤",7,"폮폯폱폲폳폵폶폷"],["bd61","폸폹폺폻폾퐀퐂",5,"퐉",13],["bd81","퐗",5,"퐞",25,"숯숱숲숴쉈쉐쉑쉔쉘쉠쉥쉬쉭쉰쉴쉼쉽쉿슁슈슉슐슘슛슝스슥슨슬슭슴습슷승시식신싣실싫심십싯싱싶싸싹싻싼쌀쌈쌉쌌쌍쌓쌔쌕쌘쌜쌤쌥쌨쌩썅써썩썬썰썲썸썹썼썽쎄쎈쎌쏀쏘쏙쏜쏟쏠쏢쏨쏩쏭쏴쏵쏸쐈쐐쐤쐬쐰"],["be41","퐸",7,"푁푂푃푅",14],["be61","푔",7,"푝푞푟푡푢푣푥",7,"푮푰푱푲"],["be81","푳",4,"푺푻푽푾풁풃",4,"풊풌풎",5,"풕",8,"쐴쐼쐽쑈쑤쑥쑨쑬쑴쑵쑹쒀쒔쒜쒸쒼쓩쓰쓱쓴쓸쓺쓿씀씁씌씐씔씜씨씩씬씰씸씹씻씽아악안앉않알앍앎앓암압앗았앙앝앞애액앤앨앰앱앳앴앵야약얀얄얇얌얍얏양얕얗얘얜얠얩어억언얹얻얼얽얾엄",6,"엌엎"],["bf41","풞",10,"풪",14],["bf61","풹",18,"퓍퓎퓏퓑퓒퓓퓕"],["bf81","퓖",5,"퓝퓞퓠",7,"퓩퓪퓫퓭퓮퓯퓱",6,"퓹퓺퓼에엑엔엘엠엡엣엥여역엮연열엶엷염",5,"옅옆옇예옌옐옘옙옛옜오옥온올옭옮옰옳옴옵옷옹옻와왁완왈왐왑왓왔왕왜왝왠왬왯왱외왹왼욀욈욉욋욍요욕욘욜욤욥욧용우욱운울욹욺움웁웃웅워웍원월웜웝웠웡웨"],["c041","퓾",5,"픅픆픇픉픊픋픍",6,"픖픘",5],["c061","픞",25],["c081","픸픹픺픻픾픿핁핂핃핅",6,"핎핐핒",5,"핚핛핝핞핟핡핢핣웩웬웰웸웹웽위윅윈윌윔윕윗윙유육윤율윰윱윳융윷으윽은을읊음읍읏응",7,"읜읠읨읫이익인일읽읾잃임입잇있잉잊잎자작잔잖잗잘잚잠잡잣잤장잦재잭잰잴잼잽잿쟀쟁쟈쟉쟌쟎쟐쟘쟝쟤쟨쟬저적전절젊"],["c141","핤핦핧핪핬핮",5,"핶핷핹핺핻핽",6,"햆햊햋"],["c161","햌햍햎햏햑",19,"햦햧"],["c181","햨",31,"점접젓정젖제젝젠젤젬젭젯젱져젼졀졈졉졌졍졔조족존졸졺좀좁좃종좆좇좋좌좍좔좝좟좡좨좼좽죄죈죌죔죕죗죙죠죡죤죵주죽준줄줅줆줌줍줏중줘줬줴쥐쥑쥔쥘쥠쥡쥣쥬쥰쥴쥼즈즉즌즐즘즙즛증지직진짇질짊짐집짓"],["c241","헊헋헍헎헏헑헓",4,"헚헜헞",5,"헦헧헩헪헫헭헮"],["c261","헯",4,"헶헸헺",5,"혂혃혅혆혇혉",6,"혒"],["c281","혖",5,"혝혞혟혡혢혣혥",7,"혮",9,"혺혻징짖짙짚짜짝짠짢짤짧짬짭짯짰짱째짹짼쨀쨈쨉쨋쨌쨍쨔쨘쨩쩌쩍쩐쩔쩜쩝쩟쩠쩡쩨쩽쪄쪘쪼쪽쫀쫄쫌쫍쫏쫑쫓쫘쫙쫠쫬쫴쬈쬐쬔쬘쬠쬡쭁쭈쭉쭌쭐쭘쭙쭝쭤쭸쭹쮜쮸쯔쯤쯧쯩찌찍찐찔찜찝찡찢찧차착찬찮찰참찹찻"],["c341","혽혾혿홁홂홃홄홆홇홊홌홎홏홐홒홓홖홗홙홚홛홝",4],["c361","홢",4,"홨홪",5,"홲홳홵",11],["c381","횁횂횄횆",5,"횎횏횑횒횓횕",7,"횞횠횢",5,"횩횪찼창찾채책챈챌챔챕챗챘챙챠챤챦챨챰챵처척천철첨첩첫첬청체첵첸첼쳄쳅쳇쳉쳐쳔쳤쳬쳰촁초촉촌촐촘촙촛총촤촨촬촹최쵠쵤쵬쵭쵯쵱쵸춈추축춘출춤춥춧충춰췄췌췐취췬췰췸췹췻췽츄츈츌츔츙츠측츤츨츰츱츳층"],["c441","횫횭횮횯횱",7,"횺횼",7,"훆훇훉훊훋"],["c461","훍훎훏훐훒훓훕훖훘훚",5,"훡훢훣훥훦훧훩",4],["c481","훮훯훱훲훳훴훶",5,"훾훿휁휂휃휅",11,"휒휓휔치칙친칟칠칡침칩칫칭카칵칸칼캄캅캇캉캐캑캔캘캠캡캣캤캥캬캭컁커컥컨컫컬컴컵컷컸컹케켁켄켈켐켑켓켕켜켠켤켬켭켯켰켱켸코콕콘콜콤콥콧콩콰콱콴콸쾀쾅쾌쾡쾨쾰쿄쿠쿡쿤쿨쿰쿱쿳쿵쿼퀀퀄퀑퀘퀭퀴퀵퀸퀼"],["c541","휕휖휗휚휛휝휞휟휡",6,"휪휬휮",5,"휶휷휹"],["c561","휺휻휽",6,"흅흆흈흊",5,"흒흓흕흚",4],["c581","흟흢흤흦흧흨흪흫흭흮흯흱흲흳흵",6,"흾흿힀힂",5,"힊힋큄큅큇큉큐큔큘큠크큭큰클큼큽킁키킥킨킬킴킵킷킹타탁탄탈탉탐탑탓탔탕태택탠탤탬탭탯탰탱탸턍터턱턴털턺텀텁텃텄텅테텍텐텔템텝텟텡텨텬텼톄톈토톡톤톨톰톱톳통톺톼퇀퇘퇴퇸툇툉툐투툭툰툴툼툽툿퉁퉈퉜"],["c641","힍힎힏힑",6,"힚힜힞",5],["c6a1","퉤튀튁튄튈튐튑튕튜튠튤튬튱트특튼튿틀틂틈틉틋틔틘틜틤틥티틱틴틸팀팁팃팅파팍팎판팔팖팜팝팟팠팡팥패팩팬팰팸팹팻팼팽퍄퍅퍼퍽펀펄펌펍펏펐펑페펙펜펠펨펩펫펭펴편펼폄폅폈평폐폘폡폣포폭폰폴폼폽폿퐁"],["c7a1","퐈퐝푀푄표푠푤푭푯푸푹푼푿풀풂품풉풋풍풔풩퓌퓐퓔퓜퓟퓨퓬퓰퓸퓻퓽프픈플픔픕픗피픽핀필핌핍핏핑하학한할핥함합핫항해핵핸핼햄햅햇했행햐향허헉헌헐헒험헙헛헝헤헥헨헬헴헵헷헹혀혁현혈혐협혓혔형혜혠"],["c8a1","혤혭호혹혼홀홅홈홉홋홍홑화확환활홧황홰홱홴횃횅회획횐횔횝횟횡효횬횰횹횻후훅훈훌훑훔훗훙훠훤훨훰훵훼훽휀휄휑휘휙휜휠휨휩휫휭휴휵휸휼흄흇흉흐흑흔흖흗흘흙흠흡흣흥흩희흰흴흼흽힁히힉힌힐힘힙힛힝"],["caa1","伽佳假價加可呵哥嘉嫁家暇架枷柯歌珂痂稼苛茄街袈訶賈跏軻迦駕刻却各恪慤殼珏脚覺角閣侃刊墾奸姦干幹懇揀杆柬桿澗癎看磵稈竿簡肝艮艱諫間乫喝曷渴碣竭葛褐蝎鞨勘坎堪嵌感憾戡敢柑橄減甘疳監瞰紺邯鑑鑒龕"],["cba1","匣岬甲胛鉀閘剛堈姜岡崗康强彊慷江畺疆糠絳綱羌腔舡薑襁講鋼降鱇介价個凱塏愷愾慨改槪漑疥皆盖箇芥蓋豈鎧開喀客坑更粳羹醵倨去居巨拒据據擧渠炬祛距踞車遽鉅鋸乾件健巾建愆楗腱虔蹇鍵騫乞傑杰桀儉劍劒檢"],["cca1","瞼鈐黔劫怯迲偈憩揭擊格檄激膈覡隔堅牽犬甄絹繭肩見譴遣鵑抉決潔結缺訣兼慊箝謙鉗鎌京俓倞傾儆勁勍卿坰境庚徑慶憬擎敬景暻更梗涇炅烱璟璥瓊痙硬磬竟競絅經耕耿脛莖警輕逕鏡頃頸驚鯨係啓堺契季屆悸戒桂械"],["cda1","棨溪界癸磎稽系繫繼計誡谿階鷄古叩告呱固姑孤尻庫拷攷故敲暠枯槁沽痼皐睾稿羔考股膏苦苽菰藁蠱袴誥賈辜錮雇顧高鼓哭斛曲梏穀谷鵠困坤崑昆梱棍滾琨袞鯤汨滑骨供公共功孔工恐恭拱控攻珙空蚣貢鞏串寡戈果瓜"],["cea1","科菓誇課跨過鍋顆廓槨藿郭串冠官寬慣棺款灌琯瓘管罐菅觀貫關館刮恝括适侊光匡壙廣曠洸炚狂珖筐胱鑛卦掛罫乖傀塊壞怪愧拐槐魁宏紘肱轟交僑咬喬嬌嶠巧攪敎校橋狡皎矯絞翹膠蕎蛟較轎郊餃驕鮫丘久九仇俱具勾"],["cfa1","區口句咎嘔坵垢寇嶇廐懼拘救枸柩構歐毆毬求溝灸狗玖球瞿矩究絿耉臼舅舊苟衢謳購軀逑邱鉤銶駒驅鳩鷗龜國局菊鞠鞫麴君窘群裙軍郡堀屈掘窟宮弓穹窮芎躬倦券勸卷圈拳捲權淃眷厥獗蕨蹶闕机櫃潰詭軌饋句晷歸貴"],["d0a1","鬼龜叫圭奎揆槻珪硅窺竅糾葵規赳逵閨勻均畇筠菌鈞龜橘克剋劇戟棘極隙僅劤勤懃斤根槿瑾筋芹菫覲謹近饉契今妗擒昑檎琴禁禽芩衾衿襟金錦伋及急扱汲級給亘兢矜肯企伎其冀嗜器圻基埼夔奇妓寄岐崎己幾忌技旗旣"],["d1a1","朞期杞棋棄機欺氣汽沂淇玘琦琪璂璣畸畿碁磯祁祇祈祺箕紀綺羈耆耭肌記譏豈起錡錤飢饑騎騏驥麒緊佶吉拮桔金喫儺喇奈娜懦懶拏拿癩",5,"那樂",4,"諾酪駱亂卵暖欄煖爛蘭難鸞捏捺南嵐枏楠湳濫男藍襤拉"],["d2a1","納臘蠟衲囊娘廊",4,"乃來內奈柰耐冷女年撚秊念恬拈捻寧寗努勞奴弩怒擄櫓爐瑙盧",5,"駑魯",10,"濃籠聾膿農惱牢磊腦賂雷尿壘",7,"嫩訥杻紐勒",5,"能菱陵尼泥匿溺多茶"],["d3a1","丹亶但單團壇彖斷旦檀段湍短端簞緞蛋袒鄲鍛撻澾獺疸達啖坍憺擔曇淡湛潭澹痰聃膽蕁覃談譚錟沓畓答踏遝唐堂塘幢戇撞棠當糖螳黨代垈坮大對岱帶待戴擡玳臺袋貸隊黛宅德悳倒刀到圖堵塗導屠島嶋度徒悼挑掉搗桃"],["d4a1","棹櫂淘渡滔濤燾盜睹禱稻萄覩賭跳蹈逃途道都鍍陶韜毒瀆牘犢獨督禿篤纛讀墩惇敦旽暾沌焞燉豚頓乭突仝冬凍動同憧東桐棟洞潼疼瞳童胴董銅兜斗杜枓痘竇荳讀豆逗頭屯臀芚遁遯鈍得嶝橙燈登等藤謄鄧騰喇懶拏癩羅"],["d5a1","蘿螺裸邏樂洛烙珞絡落諾酪駱丹亂卵欄欒瀾爛蘭鸞剌辣嵐擥攬欖濫籃纜藍襤覽拉臘蠟廊朗浪狼琅瑯螂郞來崍徠萊冷掠略亮倆兩凉梁樑粮粱糧良諒輛量侶儷勵呂廬慮戾旅櫚濾礪藜蠣閭驢驪麗黎力曆歷瀝礫轢靂憐戀攣漣"],["d6a1","煉璉練聯蓮輦連鍊冽列劣洌烈裂廉斂殮濂簾獵令伶囹寧岺嶺怜玲笭羚翎聆逞鈴零靈領齡例澧禮醴隷勞怒撈擄櫓潞瀘爐盧老蘆虜路輅露魯鷺鹵碌祿綠菉錄鹿麓論壟弄朧瀧瓏籠聾儡瀨牢磊賂賚賴雷了僚寮廖料燎療瞭聊蓼"],["d7a1","遼鬧龍壘婁屢樓淚漏瘻累縷蔞褸鏤陋劉旒柳榴流溜瀏琉瑠留瘤硫謬類六戮陸侖倫崙淪綸輪律慄栗率隆勒肋凜凌楞稜綾菱陵俚利厘吏唎履悧李梨浬犁狸理璃異痢籬罹羸莉裏裡里釐離鯉吝潾燐璘藺躪隣鱗麟林淋琳臨霖砬"],["d8a1","立笠粒摩瑪痲碼磨馬魔麻寞幕漠膜莫邈万卍娩巒彎慢挽晩曼滿漫灣瞞萬蔓蠻輓饅鰻唜抹末沫茉襪靺亡妄忘忙望網罔芒茫莽輞邙埋妹媒寐昧枚梅每煤罵買賣邁魅脈貊陌驀麥孟氓猛盲盟萌冪覓免冕勉棉沔眄眠綿緬面麵滅"],["d9a1","蔑冥名命明暝椧溟皿瞑茗蓂螟酩銘鳴袂侮冒募姆帽慕摸摹暮某模母毛牟牡瑁眸矛耗芼茅謀謨貌木沐牧目睦穆鶩歿沒夢朦蒙卯墓妙廟描昴杳渺猫竗苗錨務巫憮懋戊拇撫无楙武毋無珷畝繆舞茂蕪誣貿霧鵡墨默們刎吻問文"],["daa1","汶紊紋聞蚊門雯勿沕物味媚尾嵋彌微未梶楣渼湄眉米美薇謎迷靡黴岷悶愍憫敏旻旼民泯玟珉緡閔密蜜謐剝博拍搏撲朴樸泊珀璞箔粕縛膊舶薄迫雹駁伴半反叛拌搬攀斑槃泮潘班畔瘢盤盼磐磻礬絆般蟠返頒飯勃拔撥渤潑"],["dba1","發跋醱鉢髮魃倣傍坊妨尨幇彷房放方旁昉枋榜滂磅紡肪膀舫芳蒡蚌訪謗邦防龐倍俳北培徘拜排杯湃焙盃背胚裴裵褙賠輩配陪伯佰帛柏栢白百魄幡樊煩燔番磻繁蕃藩飜伐筏罰閥凡帆梵氾汎泛犯範范法琺僻劈壁擘檗璧癖"],["dca1","碧蘗闢霹便卞弁變辨辯邊別瞥鱉鼈丙倂兵屛幷昞昺柄棅炳甁病秉竝輧餠騈保堡報寶普步洑湺潽珤甫菩補褓譜輔伏僕匐卜宓復服福腹茯蔔複覆輹輻馥鰒本乶俸奉封峯峰捧棒烽熢琫縫蓬蜂逢鋒鳳不付俯傅剖副否咐埠夫婦"],["dda1","孚孵富府復扶敷斧浮溥父符簿缶腐腑膚艀芙莩訃負賦賻赴趺部釜阜附駙鳧北分吩噴墳奔奮忿憤扮昐汾焚盆粉糞紛芬賁雰不佛弗彿拂崩朋棚硼繃鵬丕備匕匪卑妃婢庇悲憊扉批斐枇榧比毖毗毘沸泌琵痺砒碑秕秘粃緋翡肥"],["dea1","脾臂菲蜚裨誹譬費鄙非飛鼻嚬嬪彬斌檳殯浜濱瀕牝玭貧賓頻憑氷聘騁乍事些仕伺似使俟僿史司唆嗣四士奢娑寫寺射巳師徙思捨斜斯柶査梭死沙泗渣瀉獅砂社祀祠私篩紗絲肆舍莎蓑蛇裟詐詞謝賜赦辭邪飼駟麝削數朔索"],["dfa1","傘刪山散汕珊産疝算蒜酸霰乷撒殺煞薩三參杉森渗芟蔘衫揷澁鈒颯上傷像償商喪嘗孀尙峠常床庠廂想桑橡湘爽牀狀相祥箱翔裳觴詳象賞霜塞璽賽嗇塞穡索色牲生甥省笙墅壻嶼序庶徐恕抒捿敍暑曙書栖棲犀瑞筮絮緖署"],["e0a1","胥舒薯西誓逝鋤黍鼠夕奭席惜昔晳析汐淅潟石碩蓆釋錫仙僊先善嬋宣扇敾旋渲煽琁瑄璇璿癬禪線繕羨腺膳船蘚蟬詵跣選銑鐥饍鮮卨屑楔泄洩渫舌薛褻設說雪齧剡暹殲纖蟾贍閃陝攝涉燮葉城姓宬性惺成星晟猩珹盛省筬"],["e1a1","聖聲腥誠醒世勢歲洗稅笹細說貰召嘯塑宵小少巢所掃搔昭梳沼消溯瀟炤燒甦疏疎瘙笑篠簫素紹蔬蕭蘇訴逍遡邵銷韶騷俗屬束涑粟續謖贖速孫巽損蓀遜飡率宋悚松淞訟誦送頌刷殺灑碎鎖衰釗修受嗽囚垂壽嫂守岫峀帥愁"],["e2a1","戍手授搜收數樹殊水洙漱燧狩獸琇璲瘦睡秀穗竪粹綏綬繡羞脩茱蒐蓚藪袖誰讐輸遂邃酬銖銹隋隧隨雖需須首髓鬚叔塾夙孰宿淑潚熟琡璹肅菽巡徇循恂旬栒楯橓殉洵淳珣盾瞬筍純脣舜荀蓴蕣詢諄醇錞順馴戌術述鉥崇崧"],["e3a1","嵩瑟膝蝨濕拾習褶襲丞乘僧勝升承昇繩蠅陞侍匙嘶始媤尸屎屍市弑恃施是時枾柴猜矢示翅蒔蓍視試詩諡豕豺埴寔式息拭植殖湜熄篒蝕識軾食飾伸侁信呻娠宸愼新晨燼申神紳腎臣莘薪藎蜃訊身辛辰迅失室實悉審尋心沁"],["e4a1","沈深瀋甚芯諶什十拾雙氏亞俄兒啞娥峨我牙芽莪蛾衙訝阿雅餓鴉鵝堊岳嶽幄惡愕握樂渥鄂鍔顎鰐齷安岸按晏案眼雁鞍顔鮟斡謁軋閼唵岩巖庵暗癌菴闇壓押狎鴨仰央怏昻殃秧鴦厓哀埃崖愛曖涯碍艾隘靄厄扼掖液縊腋額"],["e5a1","櫻罌鶯鸚也倻冶夜惹揶椰爺耶若野弱掠略約若葯蒻藥躍亮佯兩凉壤孃恙揚攘敭暘梁楊樣洋瀁煬痒瘍禳穰糧羊良襄諒讓釀陽量養圄御於漁瘀禦語馭魚齬億憶抑檍臆偃堰彦焉言諺孼蘖俺儼嚴奄掩淹嶪業円予余勵呂女如廬"],["e6a1","旅歟汝濾璵礖礪與艅茹輿轝閭餘驪麗黎亦力域役易曆歷疫繹譯轢逆驛嚥堧姸娟宴年延憐戀捐挻撚椽沇沿涎涓淵演漣烟然煙煉燃燕璉硏硯秊筵緣練縯聯衍軟輦蓮連鉛鍊鳶列劣咽悅涅烈熱裂說閱厭廉念捻染殮炎焰琰艶苒"],["e7a1","簾閻髥鹽曄獵燁葉令囹塋寧嶺嶸影怜映暎楹榮永泳渶潁濚瀛瀯煐營獰玲瑛瑩瓔盈穎纓羚聆英詠迎鈴鍈零霙靈領乂倪例刈叡曳汭濊猊睿穢芮藝蘂禮裔詣譽豫醴銳隸霓預五伍俉傲午吾吳嗚塢墺奧娛寤悟惡懊敖旿晤梧汚澳"],["e8a1","烏熬獒筽蜈誤鰲鼇屋沃獄玉鈺溫瑥瘟穩縕蘊兀壅擁瓮甕癰翁邕雍饔渦瓦窩窪臥蛙蝸訛婉完宛梡椀浣玩琓琬碗緩翫脘腕莞豌阮頑曰往旺枉汪王倭娃歪矮外嵬巍猥畏了僚僥凹堯夭妖姚寥寮尿嶢拗搖撓擾料曜樂橈燎燿瑤療"],["e9a1","窈窯繇繞耀腰蓼蟯要謠遙遼邀饒慾欲浴縟褥辱俑傭冗勇埇墉容庸慂榕涌湧溶熔瑢用甬聳茸蓉踊鎔鏞龍于佑偶優又友右宇寓尤愚憂旴牛玗瑀盂祐禑禹紆羽芋藕虞迂遇郵釪隅雨雩勖彧旭昱栯煜稶郁頊云暈橒殞澐熉耘芸蕓"],["eaa1","運隕雲韻蔚鬱亐熊雄元原員圓園垣媛嫄寃怨愿援沅洹湲源爰猿瑗苑袁轅遠阮院願鴛月越鉞位偉僞危圍委威尉慰暐渭爲瑋緯胃萎葦蔿蝟衛褘謂違韋魏乳侑儒兪劉唯喩孺宥幼幽庾悠惟愈愉揄攸有杻柔柚柳楡楢油洧流游溜"],["eba1","濡猶猷琉瑜由留癒硫紐維臾萸裕誘諛諭踰蹂遊逾遺酉釉鍮類六堉戮毓肉育陸倫允奫尹崙淪潤玧胤贇輪鈗閏律慄栗率聿戎瀜絨融隆垠恩慇殷誾銀隱乙吟淫蔭陰音飮揖泣邑凝應膺鷹依倚儀宜意懿擬椅毅疑矣義艤薏蟻衣誼"],["eca1","議醫二以伊利吏夷姨履已弛彛怡易李梨泥爾珥理異痍痢移罹而耳肄苡荑裏裡貽貳邇里離飴餌匿溺瀷益翊翌翼謚人仁刃印吝咽因姻寅引忍湮燐璘絪茵藺蚓認隣靭靷鱗麟一佚佾壹日溢逸鎰馹任壬妊姙恁林淋稔臨荏賃入卄"],["eda1","立笠粒仍剩孕芿仔刺咨姉姿子字孜恣慈滋炙煮玆瓷疵磁紫者自茨蔗藉諮資雌作勺嚼斫昨灼炸爵綽芍酌雀鵲孱棧殘潺盞岑暫潛箴簪蠶雜丈仗匠場墻壯奬將帳庄張掌暲杖樟檣欌漿牆狀獐璋章粧腸臟臧莊葬蔣薔藏裝贓醬長"],["eea1","障再哉在宰才材栽梓渽滓災縡裁財載齋齎爭箏諍錚佇低儲咀姐底抵杵楮樗沮渚狙猪疽箸紵苧菹著藷詛貯躇這邸雎齟勣吊嫡寂摘敵滴狄炙的積笛籍績翟荻謫賊赤跡蹟迪迹適鏑佃佺傳全典前剪塡塼奠專展廛悛戰栓殿氈澱"],["efa1","煎琠田甸畑癲筌箋箭篆纏詮輾轉鈿銓錢鐫電顚顫餞切截折浙癤竊節絶占岾店漸点粘霑鮎點接摺蝶丁井亭停偵呈姃定幀庭廷征情挺政整旌晶晸柾楨檉正汀淀淨渟湞瀞炡玎珽町睛碇禎程穽精綎艇訂諪貞鄭酊釘鉦鋌錠霆靖"],["f0a1","靜頂鼎制劑啼堤帝弟悌提梯濟祭第臍薺製諸蹄醍除際霽題齊俎兆凋助嘲弔彫措操早晁曺曹朝條棗槽漕潮照燥爪璪眺祖祚租稠窕粗糟組繰肇藻蚤詔調趙躁造遭釣阻雕鳥族簇足鏃存尊卒拙猝倧宗從悰慫棕淙琮種終綜縱腫"],["f1a1","踪踵鍾鐘佐坐左座挫罪主住侏做姝胄呪周嗾奏宙州廚晝朱柱株注洲湊澍炷珠疇籌紂紬綢舟蛛註誅走躊輳週酎酒鑄駐竹粥俊儁准埈寯峻晙樽浚準濬焌畯竣蠢逡遵雋駿茁中仲衆重卽櫛楫汁葺增憎曾拯烝甑症繒蒸證贈之只"],["f2a1","咫地址志持指摯支旨智枝枳止池沚漬知砥祉祗紙肢脂至芝芷蜘誌識贄趾遲直稙稷織職唇嗔塵振搢晉晋桭榛殄津溱珍瑨璡畛疹盡眞瞋秦縉縝臻蔯袗診賑軫辰進鎭陣陳震侄叱姪嫉帙桎瓆疾秩窒膣蛭質跌迭斟朕什執潗緝輯"],["f3a1","鏶集徵懲澄且侘借叉嗟嵯差次此磋箚茶蹉車遮捉搾着窄錯鑿齪撰澯燦璨瓚竄簒纂粲纘讚贊鑽餐饌刹察擦札紮僭參塹慘慙懺斬站讒讖倉倡創唱娼廠彰愴敞昌昶暢槍滄漲猖瘡窓脹艙菖蒼債埰寀寨彩採砦綵菜蔡采釵冊柵策"],["f4a1","責凄妻悽處倜刺剔尺慽戚拓擲斥滌瘠脊蹠陟隻仟千喘天川擅泉淺玔穿舛薦賤踐遷釧闡阡韆凸哲喆徹撤澈綴輟轍鐵僉尖沾添甛瞻簽籤詹諂堞妾帖捷牒疊睫諜貼輒廳晴淸聽菁請靑鯖切剃替涕滯締諦逮遞體初剿哨憔抄招梢"],["f5a1","椒楚樵炒焦硝礁礎秒稍肖艸苕草蕉貂超酢醋醮促囑燭矗蜀觸寸忖村邨叢塚寵悤憁摠總聰蔥銃撮催崔最墜抽推椎楸樞湫皺秋芻萩諏趨追鄒酋醜錐錘鎚雛騶鰍丑畜祝竺筑築縮蓄蹙蹴軸逐春椿瑃出朮黜充忠沖蟲衝衷悴膵萃"],["f6a1","贅取吹嘴娶就炊翠聚脆臭趣醉驟鷲側仄厠惻測層侈値嗤峙幟恥梔治淄熾痔痴癡稚穉緇緻置致蚩輜雉馳齒則勅飭親七柒漆侵寢枕沈浸琛砧針鍼蟄秤稱快他咤唾墮妥惰打拖朶楕舵陀馱駝倬卓啄坼度托拓擢晫柝濁濯琢琸託"],["f7a1","鐸呑嘆坦彈憚歎灘炭綻誕奪脫探眈耽貪塔搭榻宕帑湯糖蕩兌台太怠態殆汰泰笞胎苔跆邰颱宅擇澤撑攄兎吐土討慟桶洞痛筒統通堆槌腿褪退頹偸套妬投透鬪慝特闖坡婆巴把播擺杷波派爬琶破罷芭跛頗判坂板版瓣販辦鈑"],["f8a1","阪八叭捌佩唄悖敗沛浿牌狽稗覇貝彭澎烹膨愎便偏扁片篇編翩遍鞭騙貶坪平枰萍評吠嬖幣廢弊斃肺蔽閉陛佈包匍匏咆哺圃布怖抛抱捕暴泡浦疱砲胞脯苞葡蒲袍褒逋鋪飽鮑幅暴曝瀑爆輻俵剽彪慓杓標漂瓢票表豹飇飄驃"],["f9a1","品稟楓諷豊風馮彼披疲皮被避陂匹弼必泌珌畢疋筆苾馝乏逼下何厦夏廈昰河瑕荷蝦賀遐霞鰕壑學虐謔鶴寒恨悍旱汗漢澣瀚罕翰閑閒限韓割轄函含咸啣喊檻涵緘艦銜陷鹹合哈盒蛤閤闔陜亢伉姮嫦巷恒抗杭桁沆港缸肛航"],["faa1","行降項亥偕咳垓奚孩害懈楷海瀣蟹解該諧邂駭骸劾核倖幸杏荇行享向嚮珦鄕響餉饗香噓墟虛許憲櫶獻軒歇險驗奕爀赫革俔峴弦懸晛泫炫玄玹現眩睍絃絢縣舷衒見賢鉉顯孑穴血頁嫌俠協夾峽挾浹狹脅脇莢鋏頰亨兄刑型"],["fba1","形泂滎瀅灐炯熒珩瑩荊螢衡逈邢鎣馨兮彗惠慧暳蕙蹊醯鞋乎互呼壕壺好岵弧戶扈昊晧毫浩淏湖滸澔濠濩灝狐琥瑚瓠皓祜糊縞胡芦葫蒿虎號蝴護豪鎬頀顥惑或酷婚昏混渾琿魂忽惚笏哄弘汞泓洪烘紅虹訌鴻化和嬅樺火畵"],["fca1","禍禾花華話譁貨靴廓擴攫確碻穫丸喚奐宦幻患換歡晥桓渙煥環紈還驩鰥活滑猾豁闊凰幌徨恍惶愰慌晃晄榥況湟滉潢煌璜皇篁簧荒蝗遑隍黃匯回廻徊恢悔懷晦會檜淮澮灰獪繪膾茴蛔誨賄劃獲宖橫鐄哮嚆孝效斅曉梟涍淆"],["fda1","爻肴酵驍侯候厚后吼喉嗅帿後朽煦珝逅勛勳塤壎焄熏燻薰訓暈薨喧暄煊萱卉喙毁彙徽揮暉煇諱輝麾休携烋畦虧恤譎鷸兇凶匈洶胸黑昕欣炘痕吃屹紇訖欠欽歆吸恰洽翕興僖凞喜噫囍姬嬉希憙憘戱晞曦熙熹熺犧禧稀羲詰"]]');
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp950.json": function(module) {
        "use strict";
        module.exports = JSON.parse('[["0","\\u0000",127],["a140","　，、。．‧；：？！︰…‥﹐﹑﹒·﹔﹕﹖﹗｜–︱—︳╴︴﹏（）︵︶｛｝︷︸〔〕︹︺【】︻︼《》︽︾〈〉︿﹀「」﹁﹂『』﹃﹄﹙﹚"],["a1a1","﹛﹜﹝﹞‘’“”〝〞‵′＃＆＊※§〃○●△▲◎☆★◇◆□■▽▼㊣℅¯￣＿ˍ﹉﹊﹍﹎﹋﹌﹟﹠﹡＋－×÷±√＜＞＝≦≧≠∞≒≡﹢",4,"～∩∪⊥∠∟⊿㏒㏑∫∮∵∴♀♂⊕⊙↑↓←→↖↗↙↘∥∣／"],["a240","＼∕﹨＄￥〒￠￡％＠℃℉﹩﹪﹫㏕㎜㎝㎞㏎㎡㎎㎏㏄°兙兛兞兝兡兣嗧瓩糎▁",7,"▏▎▍▌▋▊▉┼┴┬┤├▔─│▕┌┐└┘╭"],["a2a1","╮╰╯═╞╪╡◢◣◥◤╱╲╳０",9,"Ⅰ",9,"〡",8,"十卄卅Ａ",25,"ａ",21],["a340","ｗｘｙｚΑ",16,"Σ",6,"α",16,"σ",6,"ㄅ",10],["a3a1","ㄐ",25,"˙ˉˊˇˋ"],["a3e1","€"],["a440","一乙丁七乃九了二人儿入八几刀刁力匕十卜又三下丈上丫丸凡久么也乞于亡兀刃勺千叉口土士夕大女子孑孓寸小尢尸山川工己已巳巾干廾弋弓才"],["a4a1","丑丐不中丰丹之尹予云井互五亢仁什仃仆仇仍今介仄元允內六兮公冗凶分切刈勻勾勿化匹午升卅卞厄友及反壬天夫太夭孔少尤尺屯巴幻廿弔引心戈戶手扎支文斗斤方日曰月木欠止歹毋比毛氏水火爪父爻片牙牛犬王丙"],["a540","世丕且丘主乍乏乎以付仔仕他仗代令仙仞充兄冉冊冬凹出凸刊加功包匆北匝仟半卉卡占卯卮去可古右召叮叩叨叼司叵叫另只史叱台句叭叻四囚外"],["a5a1","央失奴奶孕它尼巨巧左市布平幼弁弘弗必戊打扔扒扑斥旦朮本未末札正母民氐永汁汀氾犯玄玉瓜瓦甘生用甩田由甲申疋白皮皿目矛矢石示禾穴立丞丟乒乓乩亙交亦亥仿伉伙伊伕伍伐休伏仲件任仰仳份企伋光兇兆先全"],["a640","共再冰列刑划刎刖劣匈匡匠印危吉吏同吊吐吁吋各向名合吃后吆吒因回囝圳地在圭圬圯圩夙多夷夸妄奸妃好她如妁字存宇守宅安寺尖屹州帆并年"],["a6a1","式弛忙忖戎戌戍成扣扛托收早旨旬旭曲曳有朽朴朱朵次此死氖汝汗汙江池汐汕污汛汍汎灰牟牝百竹米糸缶羊羽老考而耒耳聿肉肋肌臣自至臼舌舛舟艮色艾虫血行衣西阡串亨位住佇佗佞伴佛何估佐佑伽伺伸佃佔似但佣"],["a740","作你伯低伶余佝佈佚兌克免兵冶冷別判利刪刨劫助努劬匣即卵吝吭吞吾否呎吧呆呃吳呈呂君吩告吹吻吸吮吵吶吠吼呀吱含吟听囪困囤囫坊坑址坍"],["a7a1","均坎圾坐坏圻壯夾妝妒妨妞妣妙妖妍妤妓妊妥孝孜孚孛完宋宏尬局屁尿尾岐岑岔岌巫希序庇床廷弄弟彤形彷役忘忌志忍忱快忸忪戒我抄抗抖技扶抉扭把扼找批扳抒扯折扮投抓抑抆改攻攸旱更束李杏材村杜杖杞杉杆杠"],["a840","杓杗步每求汞沙沁沈沉沅沛汪決沐汰沌汨沖沒汽沃汲汾汴沆汶沍沔沘沂灶灼災灸牢牡牠狄狂玖甬甫男甸皂盯矣私秀禿究系罕肖肓肝肘肛肚育良芒"],["a8a1","芋芍見角言谷豆豕貝赤走足身車辛辰迂迆迅迄巡邑邢邪邦那酉釆里防阮阱阪阬並乖乳事些亞享京佯依侍佳使佬供例來侃佰併侈佩佻侖佾侏侑佺兔兒兕兩具其典冽函刻券刷刺到刮制剁劾劻卒協卓卑卦卷卸卹取叔受味呵"],["a940","咖呸咕咀呻呷咄咒咆呼咐呱呶和咚呢周咋命咎固垃坷坪坩坡坦坤坼夜奉奇奈奄奔妾妻委妹妮姑姆姐姍始姓姊妯妳姒姅孟孤季宗定官宜宙宛尚屈居"],["a9a1","屆岷岡岸岩岫岱岳帘帚帖帕帛帑幸庚店府底庖延弦弧弩往征彿彼忝忠忽念忿怏怔怯怵怖怪怕怡性怩怫怛或戕房戾所承拉拌拄抿拂抹拒招披拓拔拋拈抨抽押拐拙拇拍抵拚抱拘拖拗拆抬拎放斧於旺昔易昌昆昂明昀昏昕昊"],["aa40","昇服朋杭枋枕東果杳杷枇枝林杯杰板枉松析杵枚枓杼杪杲欣武歧歿氓氛泣注泳沱泌泥河沽沾沼波沫法泓沸泄油況沮泗泅泱沿治泡泛泊沬泯泜泖泠"],["aaa1","炕炎炒炊炙爬爭爸版牧物狀狎狙狗狐玩玨玟玫玥甽疝疙疚的盂盲直知矽社祀祁秉秈空穹竺糾罔羌羋者肺肥肢肱股肫肩肴肪肯臥臾舍芳芝芙芭芽芟芹花芬芥芯芸芣芰芾芷虎虱初表軋迎返近邵邸邱邶采金長門阜陀阿阻附"],["ab40","陂隹雨青非亟亭亮信侵侯便俠俑俏保促侶俘俟俊俗侮俐俄係俚俎俞侷兗冒冑冠剎剃削前剌剋則勇勉勃勁匍南卻厚叛咬哀咨哎哉咸咦咳哇哂咽咪品"],["aba1","哄哈咯咫咱咻咩咧咿囿垂型垠垣垢城垮垓奕契奏奎奐姜姘姿姣姨娃姥姪姚姦威姻孩宣宦室客宥封屎屏屍屋峙峒巷帝帥帟幽庠度建弈弭彥很待徊律徇後徉怒思怠急怎怨恍恰恨恢恆恃恬恫恪恤扁拜挖按拼拭持拮拽指拱拷"],["ac40","拯括拾拴挑挂政故斫施既春昭映昧是星昨昱昤曷柿染柱柔某柬架枯柵柩柯柄柑枴柚查枸柏柞柳枰柙柢柝柒歪殃殆段毒毗氟泉洋洲洪流津洌洱洞洗"],["aca1","活洽派洶洛泵洹洧洸洩洮洵洎洫炫為炳炬炯炭炸炮炤爰牲牯牴狩狠狡玷珊玻玲珍珀玳甚甭畏界畎畋疫疤疥疢疣癸皆皇皈盈盆盃盅省盹相眉看盾盼眇矜砂研砌砍祆祉祈祇禹禺科秒秋穿突竿竽籽紂紅紀紉紇約紆缸美羿耄"],["ad40","耐耍耑耶胖胥胚胃胄背胡胛胎胞胤胝致舢苧范茅苣苛苦茄若茂茉苒苗英茁苜苔苑苞苓苟苯茆虐虹虻虺衍衫要觔計訂訃貞負赴赳趴軍軌述迦迢迪迥"],["ada1","迭迫迤迨郊郎郁郃酋酊重閂限陋陌降面革韋韭音頁風飛食首香乘亳倌倍倣俯倦倥俸倩倖倆值借倚倒們俺倀倔倨俱倡個候倘俳修倭倪俾倫倉兼冤冥冢凍凌准凋剖剜剔剛剝匪卿原厝叟哨唐唁唷哼哥哲唆哺唔哩哭員唉哮哪"],["ae40","哦唧唇哽唏圃圄埂埔埋埃堉夏套奘奚娑娘娜娟娛娓姬娠娣娩娥娌娉孫屘宰害家宴宮宵容宸射屑展屐峭峽峻峪峨峰島崁峴差席師庫庭座弱徒徑徐恙"],["aea1","恣恥恐恕恭恩息悄悟悚悍悔悌悅悖扇拳挈拿捎挾振捕捂捆捏捉挺捐挽挪挫挨捍捌效敉料旁旅時晉晏晃晒晌晅晁書朔朕朗校核案框桓根桂桔栩梳栗桌桑栽柴桐桀格桃株桅栓栘桁殊殉殷氣氧氨氦氤泰浪涕消涇浦浸海浙涓"],["af40","浬涉浮浚浴浩涌涊浹涅浥涔烊烘烤烙烈烏爹特狼狹狽狸狷玆班琉珮珠珪珞畔畝畜畚留疾病症疲疳疽疼疹痂疸皋皰益盍盎眩真眠眨矩砰砧砸砝破砷"],["afa1","砥砭砠砟砲祕祐祠祟祖神祝祗祚秤秣秧租秦秩秘窄窈站笆笑粉紡紗紋紊素索純紐紕級紜納紙紛缺罟羔翅翁耆耘耕耙耗耽耿胱脂胰脅胭胴脆胸胳脈能脊胼胯臭臬舀舐航舫舨般芻茫荒荔荊茸荐草茵茴荏茲茹茶茗荀茱茨荃"],["b040","虔蚊蚪蚓蚤蚩蚌蚣蚜衰衷袁袂衽衹記訐討訌訕訊託訓訖訏訑豈豺豹財貢起躬軒軔軏辱送逆迷退迺迴逃追逅迸邕郡郝郢酒配酌釘針釗釜釙閃院陣陡"],["b0a1","陛陝除陘陞隻飢馬骨高鬥鬲鬼乾偺偽停假偃偌做偉健偶偎偕偵側偷偏倏偯偭兜冕凰剪副勒務勘動匐匏匙匿區匾參曼商啪啦啄啞啡啃啊唱啖問啕唯啤唸售啜唬啣唳啁啗圈國圉域堅堊堆埠埤基堂堵執培夠奢娶婁婉婦婪婀"],["b140","娼婢婚婆婊孰寇寅寄寂宿密尉專將屠屜屝崇崆崎崛崖崢崑崩崔崙崤崧崗巢常帶帳帷康庸庶庵庾張強彗彬彩彫得徙從徘御徠徜恿患悉悠您惋悴惦悽"],["b1a1","情悻悵惜悼惘惕惆惟悸惚惇戚戛扈掠控捲掖探接捷捧掘措捱掩掉掃掛捫推掄授掙採掬排掏掀捻捩捨捺敝敖救教敗啟敏敘敕敔斜斛斬族旋旌旎晝晚晤晨晦晞曹勗望梁梯梢梓梵桿桶梱梧梗械梃棄梭梆梅梔條梨梟梡梂欲殺"],["b240","毫毬氫涎涼淳淙液淡淌淤添淺清淇淋涯淑涮淞淹涸混淵淅淒渚涵淚淫淘淪深淮淨淆淄涪淬涿淦烹焉焊烽烯爽牽犁猜猛猖猓猙率琅琊球理現琍瓠瓶"],["b2a1","瓷甜產略畦畢異疏痔痕疵痊痍皎盔盒盛眷眾眼眶眸眺硫硃硎祥票祭移窒窕笠笨笛第符笙笞笮粒粗粕絆絃統紮紹紼絀細紳組累終紲紱缽羞羚翌翎習耜聊聆脯脖脣脫脩脰脤舂舵舷舶船莎莞莘荸莢莖莽莫莒莊莓莉莠荷荻荼"],["b340","莆莧處彪蛇蛀蚶蛄蚵蛆蛋蚱蚯蛉術袞袈被袒袖袍袋覓規訪訝訣訥許設訟訛訢豉豚販責貫貨貪貧赧赦趾趺軛軟這逍通逗連速逝逐逕逞造透逢逖逛途"],["b3a1","部郭都酗野釵釦釣釧釭釩閉陪陵陳陸陰陴陶陷陬雀雪雩章竟頂頃魚鳥鹵鹿麥麻傢傍傅備傑傀傖傘傚最凱割剴創剩勞勝勛博厥啻喀喧啼喊喝喘喂喜喪喔喇喋喃喳單喟唾喲喚喻喬喱啾喉喫喙圍堯堪場堤堰報堡堝堠壹壺奠"],["b440","婷媚婿媒媛媧孳孱寒富寓寐尊尋就嵌嵐崴嵇巽幅帽幀幃幾廊廁廂廄弼彭復循徨惑惡悲悶惠愜愣惺愕惰惻惴慨惱愎惶愉愀愒戟扉掣掌描揀揩揉揆揍"],["b4a1","插揣提握揖揭揮捶援揪換摒揚揹敞敦敢散斑斐斯普晰晴晶景暑智晾晷曾替期朝棺棕棠棘棗椅棟棵森棧棹棒棲棣棋棍植椒椎棉棚楮棻款欺欽殘殖殼毯氮氯氬港游湔渡渲湧湊渠渥渣減湛湘渤湖湮渭渦湯渴湍渺測湃渝渾滋"],["b540","溉渙湎湣湄湲湩湟焙焚焦焰無然煮焜牌犄犀猶猥猴猩琺琪琳琢琥琵琶琴琯琛琦琨甥甦畫番痢痛痣痙痘痞痠登發皖皓皴盜睏短硝硬硯稍稈程稅稀窘"],["b5a1","窗窖童竣等策筆筐筒答筍筋筏筑粟粥絞結絨絕紫絮絲絡給絢絰絳善翔翕耋聒肅腕腔腋腑腎脹腆脾腌腓腴舒舜菩萃菸萍菠菅萋菁華菱菴著萊菰萌菌菽菲菊萸萎萄菜萇菔菟虛蛟蛙蛭蛔蛛蛤蛐蛞街裁裂袱覃視註詠評詞証詁"],["b640","詔詛詐詆訴診訶詖象貂貯貼貳貽賁費賀貴買貶貿貸越超趁跎距跋跚跑跌跛跆軻軸軼辜逮逵週逸進逶鄂郵鄉郾酣酥量鈔鈕鈣鈉鈞鈍鈐鈇鈑閔閏開閑"],["b6a1","間閒閎隊階隋陽隅隆隍陲隄雁雅雄集雇雯雲韌項順須飧飪飯飩飲飭馮馭黃黍黑亂傭債傲傳僅傾催傷傻傯僇剿剷剽募勦勤勢勣匯嗟嗨嗓嗦嗎嗜嗇嗑嗣嗤嗯嗚嗡嗅嗆嗥嗉園圓塞塑塘塗塚塔填塌塭塊塢塒塋奧嫁嫉嫌媾媽媼"],["b740","媳嫂媲嵩嵯幌幹廉廈弒彙徬微愚意慈感想愛惹愁愈慎慌慄慍愾愴愧愍愆愷戡戢搓搾搞搪搭搽搬搏搜搔損搶搖搗搆敬斟新暗暉暇暈暖暄暘暍會榔業"],["b7a1","楚楷楠楔極椰概楊楨楫楞楓楹榆楝楣楛歇歲毀殿毓毽溢溯滓溶滂源溝滇滅溥溘溼溺溫滑準溜滄滔溪溧溴煎煙煩煤煉照煜煬煦煌煥煞煆煨煖爺牒猷獅猿猾瑯瑚瑕瑟瑞瑁琿瑙瑛瑜當畸瘀痰瘁痲痱痺痿痴痳盞盟睛睫睦睞督"],["b840","睹睪睬睜睥睨睢矮碎碰碗碘碌碉硼碑碓硿祺祿禁萬禽稜稚稠稔稟稞窟窠筷節筠筮筧粱粳粵經絹綑綁綏絛置罩罪署義羨群聖聘肆肄腱腰腸腥腮腳腫"],["b8a1","腹腺腦舅艇蒂葷落萱葵葦葫葉葬葛萼萵葡董葩葭葆虞虜號蛹蜓蜈蜇蜀蛾蛻蜂蜃蜆蜊衙裟裔裙補裘裝裡裊裕裒覜解詫該詳試詩詰誇詼詣誠話誅詭詢詮詬詹詻訾詨豢貊貉賊資賈賄貲賃賂賅跡跟跨路跳跺跪跤跦躲較載軾輊"],["b940","辟農運遊道遂達逼違遐遇遏過遍遑逾遁鄒鄗酬酪酩釉鈷鉗鈸鈽鉀鈾鉛鉋鉤鉑鈴鉉鉍鉅鈹鈿鉚閘隘隔隕雍雋雉雊雷電雹零靖靴靶預頑頓頊頒頌飼飴"],["b9a1","飽飾馳馱馴髡鳩麂鼎鼓鼠僧僮僥僖僭僚僕像僑僱僎僩兢凳劃劂匱厭嗾嘀嘛嘗嗽嘔嘆嘉嘍嘎嗷嘖嘟嘈嘐嗶團圖塵塾境墓墊塹墅塽壽夥夢夤奪奩嫡嫦嫩嫗嫖嫘嫣孵寞寧寡寥實寨寢寤察對屢嶄嶇幛幣幕幗幔廓廖弊彆彰徹慇"],["ba40","愿態慷慢慣慟慚慘慵截撇摘摔撤摸摟摺摑摧搴摭摻敲斡旗旖暢暨暝榜榨榕槁榮槓構榛榷榻榫榴槐槍榭槌榦槃榣歉歌氳漳演滾漓滴漩漾漠漬漏漂漢"],["baa1","滿滯漆漱漸漲漣漕漫漯澈漪滬漁滲滌滷熔熙煽熊熄熒爾犒犖獄獐瑤瑣瑪瑰瑭甄疑瘧瘍瘋瘉瘓盡監瞄睽睿睡磁碟碧碳碩碣禎福禍種稱窪窩竭端管箕箋筵算箝箔箏箸箇箄粹粽精綻綰綜綽綾綠緊綴網綱綺綢綿綵綸維緒緇綬"],["bb40","罰翠翡翟聞聚肇腐膀膏膈膊腿膂臧臺與舔舞艋蓉蒿蓆蓄蒙蒞蒲蒜蓋蒸蓀蓓蒐蒼蓑蓊蜿蜜蜻蜢蜥蜴蜘蝕蜷蜩裳褂裴裹裸製裨褚裯誦誌語誣認誡誓誤"],["bba1","說誥誨誘誑誚誧豪貍貌賓賑賒赫趙趕跼輔輒輕輓辣遠遘遜遣遙遞遢遝遛鄙鄘鄞酵酸酷酴鉸銀銅銘銖鉻銓銜銨鉼銑閡閨閩閣閥閤隙障際雌雒需靼鞅韶頗領颯颱餃餅餌餉駁骯骰髦魁魂鳴鳶鳳麼鼻齊億儀僻僵價儂儈儉儅凜"],["bc40","劇劈劉劍劊勰厲嘮嘻嘹嘲嘿嘴嘩噓噎噗噴嘶嘯嘰墀墟增墳墜墮墩墦奭嬉嫻嬋嫵嬌嬈寮寬審寫層履嶝嶔幢幟幡廢廚廟廝廣廠彈影德徵慶慧慮慝慕憂"],["bca1","慼慰慫慾憧憐憫憎憬憚憤憔憮戮摩摯摹撞撲撈撐撰撥撓撕撩撒撮播撫撚撬撙撢撳敵敷數暮暫暴暱樣樟槨樁樞標槽模樓樊槳樂樅槭樑歐歎殤毅毆漿潼澄潑潦潔澆潭潛潸潮澎潺潰潤澗潘滕潯潠潟熟熬熱熨牖犛獎獗瑩璋璃"],["bd40","瑾璀畿瘠瘩瘟瘤瘦瘡瘢皚皺盤瞎瞇瞌瞑瞋磋磅確磊碾磕碼磐稿稼穀稽稷稻窯窮箭箱範箴篆篇篁箠篌糊締練緯緻緘緬緝編緣線緞緩綞緙緲緹罵罷羯"],["bda1","翩耦膛膜膝膠膚膘蔗蔽蔚蓮蔬蔭蔓蔑蔣蔡蔔蓬蔥蓿蔆螂蝴蝶蝠蝦蝸蝨蝙蝗蝌蝓衛衝褐複褒褓褕褊誼諒談諄誕請諸課諉諂調誰論諍誶誹諛豌豎豬賠賞賦賤賬賭賢賣賜質賡赭趟趣踫踐踝踢踏踩踟踡踞躺輝輛輟輩輦輪輜輞"],["be40","輥適遮遨遭遷鄰鄭鄧鄱醇醉醋醃鋅銻銷鋪銬鋤鋁銳銼鋒鋇鋰銲閭閱霄霆震霉靠鞍鞋鞏頡頫頜颳養餓餒餘駝駐駟駛駑駕駒駙骷髮髯鬧魅魄魷魯鴆鴉"],["bea1","鴃麩麾黎墨齒儒儘儔儐儕冀冪凝劑劓勳噙噫噹噩噤噸噪器噥噱噯噬噢噶壁墾壇壅奮嬝嬴學寰導彊憲憑憩憊懍憶憾懊懈戰擅擁擋撻撼據擄擇擂操撿擒擔撾整曆曉暹曄曇暸樽樸樺橙橫橘樹橄橢橡橋橇樵機橈歙歷氅濂澱澡"],["bf40","濃澤濁澧澳激澹澶澦澠澴熾燉燐燒燈燕熹燎燙燜燃燄獨璜璣璘璟璞瓢甌甍瘴瘸瘺盧盥瞠瞞瞟瞥磨磚磬磧禦積穎穆穌穋窺篙簑築篤篛篡篩篦糕糖縊"],["bfa1","縑縈縛縣縞縝縉縐罹羲翰翱翮耨膳膩膨臻興艘艙蕊蕙蕈蕨蕩蕃蕉蕭蕪蕞螃螟螞螢融衡褪褲褥褫褡親覦諦諺諫諱謀諜諧諮諾謁謂諷諭諳諶諼豫豭貓賴蹄踱踴蹂踹踵輻輯輸輳辨辦遵遴選遲遼遺鄴醒錠錶鋸錳錯錢鋼錫錄錚"],["c040","錐錦錡錕錮錙閻隧隨險雕霎霑霖霍霓霏靛靜靦鞘頰頸頻頷頭頹頤餐館餞餛餡餚駭駢駱骸骼髻髭鬨鮑鴕鴣鴦鴨鴒鴛默黔龍龜優償儡儲勵嚎嚀嚐嚅嚇"],["c0a1","嚏壕壓壑壎嬰嬪嬤孺尷屨嶼嶺嶽嶸幫彌徽應懂懇懦懋戲戴擎擊擘擠擰擦擬擱擢擭斂斃曙曖檀檔檄檢檜櫛檣橾檗檐檠歜殮毚氈濘濱濟濠濛濤濫濯澀濬濡濩濕濮濰燧營燮燦燥燭燬燴燠爵牆獰獲璩環璦璨癆療癌盪瞳瞪瞰瞬"],["c140","瞧瞭矯磷磺磴磯礁禧禪穗窿簇簍篾篷簌篠糠糜糞糢糟糙糝縮績繆縷縲繃縫總縱繅繁縴縹繈縵縿縯罄翳翼聱聲聰聯聳臆臃膺臂臀膿膽臉膾臨舉艱薪"],["c1a1","薄蕾薜薑薔薯薛薇薨薊虧蟀蟑螳蟒蟆螫螻螺蟈蟋褻褶襄褸褽覬謎謗謙講謊謠謝謄謐豁谿豳賺賽購賸賻趨蹉蹋蹈蹊轄輾轂轅輿避遽還邁邂邀鄹醣醞醜鍍鎂錨鍵鍊鍥鍋錘鍾鍬鍛鍰鍚鍔闊闋闌闈闆隱隸雖霜霞鞠韓顆颶餵騁"],["c240","駿鮮鮫鮪鮭鴻鴿麋黏點黜黝黛鼾齋叢嚕嚮壙壘嬸彝懣戳擴擲擾攆擺擻擷斷曜朦檳檬櫃檻檸櫂檮檯歟歸殯瀉瀋濾瀆濺瀑瀏燻燼燾燸獷獵璧璿甕癖癘"],["c2a1","癒瞽瞿瞻瞼礎禮穡穢穠竄竅簫簧簪簞簣簡糧織繕繞繚繡繒繙罈翹翻職聶臍臏舊藏薩藍藐藉薰薺薹薦蟯蟬蟲蟠覆覲觴謨謹謬謫豐贅蹙蹣蹦蹤蹟蹕軀轉轍邇邃邈醫醬釐鎔鎊鎖鎢鎳鎮鎬鎰鎘鎚鎗闔闖闐闕離雜雙雛雞霤鞣鞦"],["c340","鞭韹額顏題顎顓颺餾餿餽餮馥騎髁鬃鬆魏魎魍鯊鯉鯽鯈鯀鵑鵝鵠黠鼕鼬儳嚥壞壟壢寵龐廬懲懷懶懵攀攏曠曝櫥櫝櫚櫓瀛瀟瀨瀚瀝瀕瀘爆爍牘犢獸"],["c3a1","獺璽瓊瓣疇疆癟癡矇礙禱穫穩簾簿簸簽簷籀繫繭繹繩繪羅繳羶羹羸臘藩藝藪藕藤藥藷蟻蠅蠍蟹蟾襠襟襖襞譁譜識證譚譎譏譆譙贈贊蹼蹲躇蹶蹬蹺蹴轔轎辭邊邋醱醮鏡鏑鏟鏃鏈鏜鏝鏖鏢鏍鏘鏤鏗鏨關隴難霪霧靡韜韻類"],["c440","願顛颼饅饉騖騙鬍鯨鯧鯖鯛鶉鵡鵲鵪鵬麒麗麓麴勸嚨嚷嚶嚴嚼壤孀孃孽寶巉懸懺攘攔攙曦朧櫬瀾瀰瀲爐獻瓏癢癥礦礪礬礫竇競籌籃籍糯糰辮繽繼"],["c4a1","纂罌耀臚艦藻藹蘑藺蘆蘋蘇蘊蠔蠕襤覺觸議譬警譯譟譫贏贍躉躁躅躂醴釋鐘鐃鏽闡霰飄饒饑馨騫騰騷騵鰓鰍鹹麵黨鼯齟齣齡儷儸囁囀囂夔屬巍懼懾攝攜斕曩櫻欄櫺殲灌爛犧瓖瓔癩矓籐纏續羼蘗蘭蘚蠣蠢蠡蠟襪襬覽譴"],["c540","護譽贓躊躍躋轟辯醺鐮鐳鐵鐺鐸鐲鐫闢霸霹露響顧顥饗驅驃驀騾髏魔魑鰭鰥鶯鶴鷂鶸麝黯鼙齜齦齧儼儻囈囊囉孿巔巒彎懿攤權歡灑灘玀瓤疊癮癬"],["c5a1","禳籠籟聾聽臟襲襯觼讀贖贗躑躓轡酈鑄鑑鑒霽霾韃韁顫饕驕驍髒鬚鱉鰱鰾鰻鷓鷗鼴齬齪龔囌巖戀攣攫攪曬欐瓚竊籤籣籥纓纖纔臢蘸蘿蠱變邐邏鑣鑠鑤靨顯饜驚驛驗髓體髑鱔鱗鱖鷥麟黴囑壩攬灞癱癲矗罐羈蠶蠹衢讓讒"],["c640","讖艷贛釀鑪靂靈靄韆顰驟鬢魘鱟鷹鷺鹼鹽鼇齷齲廳欖灣籬籮蠻觀躡釁鑲鑰顱饞髖鬣黌灤矚讚鑷韉驢驥纜讜躪釅鑽鑾鑼鱷鱸黷豔鑿鸚爨驪鬱鸛鸞籲"],["c940","乂乜凵匚厂万丌乇亍囗兀屮彳丏冇与丮亓仂仉仈冘勼卬厹圠夃夬尐巿旡殳毌气爿丱丼仨仜仩仡仝仚刌匜卌圢圣夗夯宁宄尒尻屴屳帄庀庂忉戉扐氕"],["c9a1","氶汃氿氻犮犰玊禸肊阞伎优伬仵伔仱伀价伈伝伂伅伢伓伄仴伒冱刓刉刐劦匢匟卍厊吇囡囟圮圪圴夼妀奼妅奻奾奷奿孖尕尥屼屺屻屾巟幵庄异弚彴忕忔忏扜扞扤扡扦扢扙扠扚扥旯旮朾朹朸朻机朿朼朳氘汆汒汜汏汊汔汋"],["ca40","汌灱牞犴犵玎甪癿穵网艸艼芀艽艿虍襾邙邗邘邛邔阢阤阠阣佖伻佢佉体佤伾佧佒佟佁佘伭伳伿佡冏冹刜刞刡劭劮匉卣卲厎厏吰吷吪呔呅吙吜吥吘"],["caa1","吽呏呁吨吤呇囮囧囥坁坅坌坉坋坒夆奀妦妘妠妗妎妢妐妏妧妡宎宒尨尪岍岏岈岋岉岒岊岆岓岕巠帊帎庋庉庌庈庍弅弝彸彶忒忑忐忭忨忮忳忡忤忣忺忯忷忻怀忴戺抃抌抎抏抔抇扱扻扺扰抁抈扷扽扲扴攷旰旴旳旲旵杅杇"],["cb40","杙杕杌杈杝杍杚杋毐氙氚汸汧汫沄沋沏汱汯汩沚汭沇沕沜汦汳汥汻沎灴灺牣犿犽狃狆狁犺狅玕玗玓玔玒町甹疔疕皁礽耴肕肙肐肒肜芐芏芅芎芑芓"],["cba1","芊芃芄豸迉辿邟邡邥邞邧邠阰阨阯阭丳侘佼侅佽侀侇佶佴侉侄佷佌侗佪侚佹侁佸侐侜侔侞侒侂侕佫佮冞冼冾刵刲刳剆刱劼匊匋匼厒厔咇呿咁咑咂咈呫呺呾呥呬呴呦咍呯呡呠咘呣呧呤囷囹坯坲坭坫坱坰坶垀坵坻坳坴坢"],["cc40","坨坽夌奅妵妺姏姎妲姌姁妶妼姃姖妱妽姀姈妴姇孢孥宓宕屄屇岮岤岠岵岯岨岬岟岣岭岢岪岧岝岥岶岰岦帗帔帙弨弢弣弤彔徂彾彽忞忥怭怦怙怲怋"],["cca1","怴怊怗怳怚怞怬怢怍怐怮怓怑怌怉怜戔戽抭抴拑抾抪抶拊抮抳抯抻抩抰抸攽斨斻昉旼昄昒昈旻昃昋昍昅旽昑昐曶朊枅杬枎枒杶杻枘枆构杴枍枌杺枟枑枙枃杽极杸杹枔欥殀歾毞氝沓泬泫泮泙沶泔沭泧沷泐泂沺泃泆泭泲"],["cd40","泒泝沴沊沝沀泞泀洰泍泇沰泹泏泩泑炔炘炅炓炆炄炑炖炂炚炃牪狖狋狘狉狜狒狔狚狌狑玤玡玭玦玢玠玬玝瓝瓨甿畀甾疌疘皯盳盱盰盵矸矼矹矻矺"],["cda1","矷祂礿秅穸穻竻籵糽耵肏肮肣肸肵肭舠芠苀芫芚芘芛芵芧芮芼芞芺芴芨芡芩苂芤苃芶芢虰虯虭虮豖迒迋迓迍迖迕迗邲邴邯邳邰阹阽阼阺陃俍俅俓侲俉俋俁俔俜俙侻侳俛俇俖侺俀侹俬剄剉勀勂匽卼厗厖厙厘咺咡咭咥哏"],["ce40","哃茍咷咮哖咶哅哆咠呰咼咢咾呲哞咰垵垞垟垤垌垗垝垛垔垘垏垙垥垚垕壴复奓姡姞姮娀姱姝姺姽姼姶姤姲姷姛姩姳姵姠姾姴姭宨屌峐峘峌峗峋峛"],["cea1","峞峚峉峇峊峖峓峔峏峈峆峎峟峸巹帡帢帣帠帤庰庤庢庛庣庥弇弮彖徆怷怹恔恲恞恅恓恇恉恛恌恀恂恟怤恄恘恦恮扂扃拏挍挋拵挎挃拫拹挏挌拸拶挀挓挔拺挕拻拰敁敃斪斿昶昡昲昵昜昦昢昳昫昺昝昴昹昮朏朐柁柲柈枺"],["cf40","柜枻柸柘柀枷柅柫柤柟枵柍枳柷柶柮柣柂枹柎柧柰枲柼柆柭柌枮柦柛柺柉柊柃柪柋欨殂殄殶毖毘毠氠氡洨洴洭洟洼洿洒洊泚洳洄洙洺洚洑洀洝浂"],["cfa1","洁洘洷洃洏浀洇洠洬洈洢洉洐炷炟炾炱炰炡炴炵炩牁牉牊牬牰牳牮狊狤狨狫狟狪狦狣玅珌珂珈珅玹玶玵玴珫玿珇玾珃珆玸珋瓬瓮甮畇畈疧疪癹盄眈眃眄眅眊盷盻盺矧矨砆砑砒砅砐砏砎砉砃砓祊祌祋祅祄秕种秏秖秎窀"],["d040","穾竑笀笁籺籸籹籿粀粁紃紈紁罘羑羍羾耇耎耏耔耷胘胇胠胑胈胂胐胅胣胙胜胊胕胉胏胗胦胍臿舡芔苙苾苹茇苨茀苕茺苫苖苴苬苡苲苵茌苻苶苰苪"],["d0a1","苤苠苺苳苭虷虴虼虳衁衎衧衪衩觓訄訇赲迣迡迮迠郱邽邿郕郅邾郇郋郈釔釓陔陏陑陓陊陎倞倅倇倓倢倰倛俵俴倳倷倬俶俷倗倜倠倧倵倯倱倎党冔冓凊凄凅凈凎剡剚剒剞剟剕剢勍匎厞唦哢唗唒哧哳哤唚哿唄唈哫唑唅哱"],["d140","唊哻哷哸哠唎唃唋圁圂埌堲埕埒垺埆垽垼垸垶垿埇埐垹埁夎奊娙娖娭娮娕娏娗娊娞娳孬宧宭宬尃屖屔峬峿峮峱峷崀峹帩帨庨庮庪庬弳弰彧恝恚恧"],["d1a1","恁悢悈悀悒悁悝悃悕悛悗悇悜悎戙扆拲挐捖挬捄捅挶捃揤挹捋捊挼挩捁挴捘捔捙挭捇挳捚捑挸捗捀捈敊敆旆旃旄旂晊晟晇晑朒朓栟栚桉栲栳栻桋桏栖栱栜栵栫栭栯桎桄栴栝栒栔栦栨栮桍栺栥栠欬欯欭欱欴歭肂殈毦毤"],["d240","毨毣毢毧氥浺浣浤浶洍浡涒浘浢浭浯涑涍淯浿涆浞浧浠涗浰浼浟涂涘洯浨涋浾涀涄洖涃浻浽浵涐烜烓烑烝烋缹烢烗烒烞烠烔烍烅烆烇烚烎烡牂牸"],["d2a1","牷牶猀狺狴狾狶狳狻猁珓珙珥珖玼珧珣珩珜珒珛珔珝珚珗珘珨瓞瓟瓴瓵甡畛畟疰痁疻痄痀疿疶疺皊盉眝眛眐眓眒眣眑眕眙眚眢眧砣砬砢砵砯砨砮砫砡砩砳砪砱祔祛祏祜祓祒祑秫秬秠秮秭秪秜秞秝窆窉窅窋窌窊窇竘笐"],["d340","笄笓笅笏笈笊笎笉笒粄粑粊粌粈粍粅紞紝紑紎紘紖紓紟紒紏紌罜罡罞罠罝罛羖羒翃翂翀耖耾耹胺胲胹胵脁胻脀舁舯舥茳茭荄茙荑茥荖茿荁茦茜茢"],["d3a1","荂荎茛茪茈茼荍茖茤茠茷茯茩荇荅荌荓茞茬荋茧荈虓虒蚢蚨蚖蚍蚑蚞蚇蚗蚆蚋蚚蚅蚥蚙蚡蚧蚕蚘蚎蚝蚐蚔衃衄衭衵衶衲袀衱衿衯袃衾衴衼訒豇豗豻貤貣赶赸趵趷趶軑軓迾迵适迿迻逄迼迶郖郠郙郚郣郟郥郘郛郗郜郤酐"],["d440","酎酏釕釢釚陜陟隼飣髟鬯乿偰偪偡偞偠偓偋偝偲偈偍偁偛偊偢倕偅偟偩偫偣偤偆偀偮偳偗偑凐剫剭剬剮勖勓匭厜啵啶唼啍啐唴唪啑啢唶唵唰啒啅"],["d4a1","唌唲啥啎唹啈唭唻啀啋圊圇埻堔埢埶埜埴堀埭埽堈埸堋埳埏堇埮埣埲埥埬埡堎埼堐埧堁堌埱埩埰堍堄奜婠婘婕婧婞娸娵婭婐婟婥婬婓婤婗婃婝婒婄婛婈媎娾婍娹婌婰婩婇婑婖婂婜孲孮寁寀屙崞崋崝崚崠崌崨崍崦崥崏"],["d540","崰崒崣崟崮帾帴庱庴庹庲庳弶弸徛徖徟悊悐悆悾悰悺惓惔惏惤惙惝惈悱惛悷惊悿惃惍惀挲捥掊掂捽掽掞掭掝掗掫掎捯掇掐据掯捵掜捭掮捼掤挻掟"],["d5a1","捸掅掁掑掍捰敓旍晥晡晛晙晜晢朘桹梇梐梜桭桮梮梫楖桯梣梬梩桵桴梲梏桷梒桼桫桲梪梀桱桾梛梖梋梠梉梤桸桻梑梌梊桽欶欳欷欸殑殏殍殎殌氪淀涫涴涳湴涬淩淢涷淶淔渀淈淠淟淖涾淥淜淝淛淴淊涽淭淰涺淕淂淏淉"],["d640","淐淲淓淽淗淍淣涻烺焍烷焗烴焌烰焄烳焐烼烿焆焓焀烸烶焋焂焎牾牻牼牿猝猗猇猑猘猊猈狿猏猞玈珶珸珵琄琁珽琇琀珺珼珿琌琋珴琈畤畣痎痒痏"],["d6a1","痋痌痑痐皏皉盓眹眯眭眱眲眴眳眽眥眻眵硈硒硉硍硊硌砦硅硐祤祧祩祪祣祫祡离秺秸秶秷窏窔窐笵筇笴笥笰笢笤笳笘笪笝笱笫笭笯笲笸笚笣粔粘粖粣紵紽紸紶紺絅紬紩絁絇紾紿絊紻紨罣羕羜羝羛翊翋翍翐翑翇翏翉耟"],["d740","耞耛聇聃聈脘脥脙脛脭脟脬脞脡脕脧脝脢舑舸舳舺舴舲艴莐莣莨莍荺荳莤荴莏莁莕莙荵莔莩荽莃莌莝莛莪莋荾莥莯莈莗莰荿莦莇莮荶莚虙虖蚿蚷"],["d7a1","蛂蛁蛅蚺蚰蛈蚹蚳蚸蛌蚴蚻蚼蛃蚽蚾衒袉袕袨袢袪袚袑袡袟袘袧袙袛袗袤袬袌袓袎覂觖觙觕訰訧訬訞谹谻豜豝豽貥赽赻赹趼跂趹趿跁軘軞軝軜軗軠軡逤逋逑逜逌逡郯郪郰郴郲郳郔郫郬郩酖酘酚酓酕釬釴釱釳釸釤釹釪"],["d840","釫釷釨釮镺閆閈陼陭陫陱陯隿靪頄飥馗傛傕傔傞傋傣傃傌傎傝偨傜傒傂傇兟凔匒匑厤厧喑喨喥喭啷噅喢喓喈喏喵喁喣喒喤啽喌喦啿喕喡喎圌堩堷"],["d8a1","堙堞堧堣堨埵塈堥堜堛堳堿堶堮堹堸堭堬堻奡媯媔媟婺媢媞婸媦婼媥媬媕媮娷媄媊媗媃媋媩婻婽媌媜媏媓媝寪寍寋寔寑寊寎尌尰崷嵃嵫嵁嵋崿崵嵑嵎嵕崳崺嵒崽崱嵙嵂崹嵉崸崼崲崶嵀嵅幄幁彘徦徥徫惉悹惌惢惎惄愔"],["d940","惲愊愖愅惵愓惸惼惾惁愃愘愝愐惿愄愋扊掔掱掰揎揥揨揯揃撝揳揊揠揶揕揲揵摡揟掾揝揜揄揘揓揂揇揌揋揈揰揗揙攲敧敪敤敜敨敥斌斝斞斮旐旒"],["d9a1","晼晬晻暀晱晹晪晲朁椌棓椄棜椪棬棪棱椏棖棷棫棤棶椓椐棳棡椇棌椈楰梴椑棯棆椔棸棐棽棼棨椋椊椗棎棈棝棞棦棴棑椆棔棩椕椥棇欹欻欿欼殔殗殙殕殽毰毲毳氰淼湆湇渟湉溈渼渽湅湢渫渿湁湝湳渜渳湋湀湑渻渃渮湞"],["da40","湨湜湡渱渨湠湱湫渹渢渰湓湥渧湸湤湷湕湹湒湦渵渶湚焠焞焯烻焮焱焣焥焢焲焟焨焺焛牋牚犈犉犆犅犋猒猋猰猢猱猳猧猲猭猦猣猵猌琮琬琰琫琖"],["daa1","琚琡琭琱琤琣琝琩琠琲瓻甯畯畬痧痚痡痦痝痟痤痗皕皒盚睆睇睄睍睅睊睎睋睌矞矬硠硤硥硜硭硱硪确硰硩硨硞硢祴祳祲祰稂稊稃稌稄窙竦竤筊笻筄筈筌筎筀筘筅粢粞粨粡絘絯絣絓絖絧絪絏絭絜絫絒絔絩絑絟絎缾缿罥"],["db40","罦羢羠羡翗聑聏聐胾胔腃腊腒腏腇脽腍脺臦臮臷臸臹舄舼舽舿艵茻菏菹萣菀菨萒菧菤菼菶萐菆菈菫菣莿萁菝菥菘菿菡菋菎菖菵菉萉萏菞萑萆菂菳"],["dba1","菕菺菇菑菪萓菃菬菮菄菻菗菢萛菛菾蛘蛢蛦蛓蛣蛚蛪蛝蛫蛜蛬蛩蛗蛨蛑衈衖衕袺裗袹袸裀袾袶袼袷袽袲褁裉覕覘覗觝觚觛詎詍訹詙詀詗詘詄詅詒詈詑詊詌詏豟貁貀貺貾貰貹貵趄趀趉跘跓跍跇跖跜跏跕跙跈跗跅軯軷軺"],["dc40","軹軦軮軥軵軧軨軶軫軱軬軴軩逭逴逯鄆鄬鄄郿郼鄈郹郻鄁鄀鄇鄅鄃酡酤酟酢酠鈁鈊鈥鈃鈚鈦鈏鈌鈀鈒釿釽鈆鈄鈧鈂鈜鈤鈙鈗鈅鈖镻閍閌閐隇陾隈"],["dca1","隉隃隀雂雈雃雱雰靬靰靮頇颩飫鳦黹亃亄亶傽傿僆傮僄僊傴僈僂傰僁傺傱僋僉傶傸凗剺剸剻剼嗃嗛嗌嗐嗋嗊嗝嗀嗔嗄嗩喿嗒喍嗏嗕嗢嗖嗈嗲嗍嗙嗂圔塓塨塤塏塍塉塯塕塎塝塙塥塛堽塣塱壼嫇嫄嫋媺媸媱媵媰媿嫈媻嫆"],["dd40","媷嫀嫊媴媶嫍媹媐寖寘寙尟尳嵱嵣嵊嵥嵲嵬嵞嵨嵧嵢巰幏幎幊幍幋廅廌廆廋廇彀徯徭惷慉慊愫慅愶愲愮慆愯慏愩慀戠酨戣戥戤揅揱揫搐搒搉搠搤"],["dda1","搳摃搟搕搘搹搷搢搣搌搦搰搨摁搵搯搊搚摀搥搧搋揧搛搮搡搎敯斒旓暆暌暕暐暋暊暙暔晸朠楦楟椸楎楢楱椿楅楪椹楂楗楙楺楈楉椵楬椳椽楥棰楸椴楩楀楯楄楶楘楁楴楌椻楋椷楜楏楑椲楒椯楻椼歆歅歃歂歈歁殛嗀毻毼"],["de40","毹毷毸溛滖滈溏滀溟溓溔溠溱溹滆滒溽滁溞滉溷溰滍溦滏溲溾滃滜滘溙溒溎溍溤溡溿溳滐滊溗溮溣煇煔煒煣煠煁煝煢煲煸煪煡煂煘煃煋煰煟煐煓"],["dea1","煄煍煚牏犍犌犑犐犎猼獂猻猺獀獊獉瑄瑊瑋瑒瑑瑗瑀瑏瑐瑎瑂瑆瑍瑔瓡瓿瓾瓽甝畹畷榃痯瘏瘃痷痾痼痹痸瘐痻痶痭痵痽皙皵盝睕睟睠睒睖睚睩睧睔睙睭矠碇碚碔碏碄碕碅碆碡碃硹碙碀碖硻祼禂祽祹稑稘稙稒稗稕稢稓"],["df40","稛稐窣窢窞竫筦筤筭筴筩筲筥筳筱筰筡筸筶筣粲粴粯綈綆綀綍絿綅絺綎絻綃絼綌綔綄絽綒罭罫罧罨罬羦羥羧翛翜耡腤腠腷腜腩腛腢腲朡腞腶腧腯"],["dfa1","腄腡舝艉艄艀艂艅蓱萿葖葶葹蒏蒍葥葑葀蒆葧萰葍葽葚葙葴葳葝蔇葞萷萺萴葺葃葸萲葅萩菙葋萯葂萭葟葰萹葎葌葒葯蓅蒎萻葇萶萳葨葾葄萫葠葔葮葐蜋蜄蛷蜌蛺蛖蛵蝍蛸蜎蜉蜁蛶蜍蜅裖裋裍裎裞裛裚裌裐覅覛觟觥觤"],["e040","觡觠觢觜触詶誆詿詡訿詷誂誄詵誃誁詴詺谼豋豊豥豤豦貆貄貅賌赨赩趑趌趎趏趍趓趔趐趒跰跠跬跱跮跐跩跣跢跧跲跫跴輆軿輁輀輅輇輈輂輋遒逿"],["e0a1","遄遉逽鄐鄍鄏鄑鄖鄔鄋鄎酮酯鉈鉒鈰鈺鉦鈳鉥鉞銃鈮鉊鉆鉭鉬鉏鉠鉧鉯鈶鉡鉰鈱鉔鉣鉐鉲鉎鉓鉌鉖鈲閟閜閞閛隒隓隑隗雎雺雽雸雵靳靷靸靲頏頍頎颬飶飹馯馲馰馵骭骫魛鳪鳭鳧麀黽僦僔僗僨僳僛僪僝僤僓僬僰僯僣僠"],["e140","凘劀劁勩勫匰厬嘧嘕嘌嘒嗼嘏嘜嘁嘓嘂嗺嘝嘄嗿嗹墉塼墐墘墆墁塿塴墋塺墇墑墎塶墂墈塻墔墏壾奫嫜嫮嫥嫕嫪嫚嫭嫫嫳嫢嫠嫛嫬嫞嫝嫙嫨嫟孷寠"],["e1a1","寣屣嶂嶀嵽嶆嵺嶁嵷嶊嶉嶈嵾嵼嶍嵹嵿幘幙幓廘廑廗廎廜廕廙廒廔彄彃彯徶愬愨慁慞慱慳慒慓慲慬憀慴慔慺慛慥愻慪慡慖戩戧戫搫摍摛摝摴摶摲摳摽摵摦撦摎撂摞摜摋摓摠摐摿搿摬摫摙摥摷敳斠暡暠暟朅朄朢榱榶槉"],["e240","榠槎榖榰榬榼榑榙榎榧榍榩榾榯榿槄榽榤槔榹槊榚槏榳榓榪榡榞槙榗榐槂榵榥槆歊歍歋殞殟殠毃毄毾滎滵滱漃漥滸漷滻漮漉潎漙漚漧漘漻漒滭漊"],["e2a1","漶潳滹滮漭潀漰漼漵滫漇漎潃漅滽滶漹漜滼漺漟漍漞漈漡熇熐熉熀熅熂熏煻熆熁熗牄牓犗犕犓獃獍獑獌瑢瑳瑱瑵瑲瑧瑮甀甂甃畽疐瘖瘈瘌瘕瘑瘊瘔皸瞁睼瞅瞂睮瞀睯睾瞃碲碪碴碭碨硾碫碞碥碠碬碢碤禘禊禋禖禕禔禓"],["e340","禗禈禒禐稫穊稰稯稨稦窨窫窬竮箈箜箊箑箐箖箍箌箛箎箅箘劄箙箤箂粻粿粼粺綧綷緂綣綪緁緀緅綝緎緄緆緋緌綯綹綖綼綟綦綮綩綡緉罳翢翣翥翞"],["e3a1","耤聝聜膉膆膃膇膍膌膋舕蒗蒤蒡蒟蒺蓎蓂蒬蒮蒫蒹蒴蓁蓍蒪蒚蒱蓐蒝蒧蒻蒢蒔蓇蓌蒛蒩蒯蒨蓖蒘蒶蓏蒠蓗蓔蓒蓛蒰蒑虡蜳蜣蜨蝫蝀蜮蜞蜡蜙蜛蝃蜬蝁蜾蝆蜠蜲蜪蜭蜼蜒蜺蜱蜵蝂蜦蜧蜸蜤蜚蜰蜑裷裧裱裲裺裾裮裼裶裻"],["e440","裰裬裫覝覡覟覞觩觫觨誫誙誋誒誏誖谽豨豩賕賏賗趖踉踂跿踍跽踊踃踇踆踅跾踀踄輐輑輎輍鄣鄜鄠鄢鄟鄝鄚鄤鄡鄛酺酲酹酳銥銤鉶銛鉺銠銔銪銍"],["e4a1","銦銚銫鉹銗鉿銣鋮銎銂銕銢鉽銈銡銊銆銌銙銧鉾銇銩銝銋鈭隞隡雿靘靽靺靾鞃鞀鞂靻鞄鞁靿韎韍頖颭颮餂餀餇馝馜駃馹馻馺駂馽駇骱髣髧鬾鬿魠魡魟鳱鳲鳵麧僿儃儰僸儆儇僶僾儋儌僽儊劋劌勱勯噈噂噌嘵噁噊噉噆噘"],["e540","噚噀嘳嘽嘬嘾嘸嘪嘺圚墫墝墱墠墣墯墬墥墡壿嫿嫴嫽嫷嫶嬃嫸嬂嫹嬁嬇嬅嬏屧嶙嶗嶟嶒嶢嶓嶕嶠嶜嶡嶚嶞幩幝幠幜緳廛廞廡彉徲憋憃慹憱憰憢憉"],["e5a1","憛憓憯憭憟憒憪憡憍慦憳戭摮摰撖撠撅撗撜撏撋撊撌撣撟摨撱撘敶敺敹敻斲斳暵暰暩暲暷暪暯樀樆樗槥槸樕槱槤樠槿槬槢樛樝槾樧槲槮樔槷槧橀樈槦槻樍槼槫樉樄樘樥樏槶樦樇槴樖歑殥殣殢殦氁氀毿氂潁漦潾澇濆澒"],["e640","澍澉澌潢潏澅潚澖潶潬澂潕潲潒潐潗澔澓潝漀潡潫潽潧澐潓澋潩潿澕潣潷潪潻熲熯熛熰熠熚熩熵熝熥熞熤熡熪熜熧熳犘犚獘獒獞獟獠獝獛獡獚獙"],["e6a1","獢璇璉璊璆璁瑽璅璈瑼瑹甈甇畾瘥瘞瘙瘝瘜瘣瘚瘨瘛皜皝皞皛瞍瞏瞉瞈磍碻磏磌磑磎磔磈磃磄磉禚禡禠禜禢禛歶稹窲窴窳箷篋箾箬篎箯箹篊箵糅糈糌糋緷緛緪緧緗緡縃緺緦緶緱緰緮緟罶羬羰羭翭翫翪翬翦翨聤聧膣膟"],["e740","膞膕膢膙膗舖艏艓艒艐艎艑蔤蔻蔏蔀蔩蔎蔉蔍蔟蔊蔧蔜蓻蔫蓺蔈蔌蓴蔪蓲蔕蓷蓫蓳蓼蔒蓪蓩蔖蓾蔨蔝蔮蔂蓽蔞蓶蔱蔦蓧蓨蓰蓯蓹蔘蔠蔰蔋蔙蔯虢"],["e7a1","蝖蝣蝤蝷蟡蝳蝘蝔蝛蝒蝡蝚蝑蝞蝭蝪蝐蝎蝟蝝蝯蝬蝺蝮蝜蝥蝏蝻蝵蝢蝧蝩衚褅褌褔褋褗褘褙褆褖褑褎褉覢覤覣觭觰觬諏諆誸諓諑諔諕誻諗誾諀諅諘諃誺誽諙谾豍貏賥賟賙賨賚賝賧趠趜趡趛踠踣踥踤踮踕踛踖踑踙踦踧"],["e840","踔踒踘踓踜踗踚輬輤輘輚輠輣輖輗遳遰遯遧遫鄯鄫鄩鄪鄲鄦鄮醅醆醊醁醂醄醀鋐鋃鋄鋀鋙銶鋏鋱鋟鋘鋩鋗鋝鋌鋯鋂鋨鋊鋈鋎鋦鋍鋕鋉鋠鋞鋧鋑鋓"],["e8a1","銵鋡鋆銴镼閬閫閮閰隤隢雓霅霈霂靚鞊鞎鞈韐韏頞頝頦頩頨頠頛頧颲餈飺餑餔餖餗餕駜駍駏駓駔駎駉駖駘駋駗駌骳髬髫髳髲髱魆魃魧魴魱魦魶魵魰魨魤魬鳼鳺鳽鳿鳷鴇鴀鳹鳻鴈鴅鴄麃黓鼏鼐儜儓儗儚儑凞匴叡噰噠噮"],["e940","噳噦噣噭噲噞噷圜圛壈墽壉墿墺壂墼壆嬗嬙嬛嬡嬔嬓嬐嬖嬨嬚嬠嬞寯嶬嶱嶩嶧嶵嶰嶮嶪嶨嶲嶭嶯嶴幧幨幦幯廩廧廦廨廥彋徼憝憨憖懅憴懆懁懌憺"],["e9a1","憿憸憌擗擖擐擏擉撽撉擃擛擳擙攳敿敼斢曈暾曀曊曋曏暽暻暺曌朣樴橦橉橧樲橨樾橝橭橶橛橑樨橚樻樿橁橪橤橐橏橔橯橩橠樼橞橖橕橍橎橆歕歔歖殧殪殫毈毇氄氃氆澭濋澣濇澼濎濈潞濄澽澞濊澨瀄澥澮澺澬澪濏澿澸"],["ea40","澢濉澫濍澯澲澰燅燂熿熸燖燀燁燋燔燊燇燏熽燘熼燆燚燛犝犞獩獦獧獬獥獫獪瑿璚璠璔璒璕璡甋疀瘯瘭瘱瘽瘳瘼瘵瘲瘰皻盦瞚瞝瞡瞜瞛瞢瞣瞕瞙"],["eaa1","瞗磝磩磥磪磞磣磛磡磢磭磟磠禤穄穈穇窶窸窵窱窷篞篣篧篝篕篥篚篨篹篔篪篢篜篫篘篟糒糔糗糐糑縒縡縗縌縟縠縓縎縜縕縚縢縋縏縖縍縔縥縤罃罻罼罺羱翯耪耩聬膱膦膮膹膵膫膰膬膴膲膷膧臲艕艖艗蕖蕅蕫蕍蕓蕡蕘"],["eb40","蕀蕆蕤蕁蕢蕄蕑蕇蕣蔾蕛蕱蕎蕮蕵蕕蕧蕠薌蕦蕝蕔蕥蕬虣虥虤螛螏螗螓螒螈螁螖螘蝹螇螣螅螐螑螝螄螔螜螚螉褞褦褰褭褮褧褱褢褩褣褯褬褟觱諠"],["eba1","諢諲諴諵諝謔諤諟諰諈諞諡諨諿諯諻貑貒貐賵賮賱賰賳赬赮趥趧踳踾踸蹀蹅踶踼踽蹁踰踿躽輶輮輵輲輹輷輴遶遹遻邆郺鄳鄵鄶醓醐醑醍醏錧錞錈錟錆錏鍺錸錼錛錣錒錁鍆錭錎錍鋋錝鋺錥錓鋹鋷錴錂錤鋿錩錹錵錪錔錌"],["ec40","錋鋾錉錀鋻錖閼闍閾閹閺閶閿閵閽隩雔霋霒霐鞙鞗鞔韰韸頵頯頲餤餟餧餩馞駮駬駥駤駰駣駪駩駧骹骿骴骻髶髺髹髷鬳鮀鮅鮇魼魾魻鮂鮓鮒鮐魺鮕"],["eca1","魽鮈鴥鴗鴠鴞鴔鴩鴝鴘鴢鴐鴙鴟麈麆麇麮麭黕黖黺鼒鼽儦儥儢儤儠儩勴嚓嚌嚍嚆嚄嚃噾嚂噿嚁壖壔壏壒嬭嬥嬲嬣嬬嬧嬦嬯嬮孻寱寲嶷幬幪徾徻懃憵憼懧懠懥懤懨懞擯擩擣擫擤擨斁斀斶旚曒檍檖檁檥檉檟檛檡檞檇檓檎"],["ed40","檕檃檨檤檑橿檦檚檅檌檒歛殭氉濌澩濴濔濣濜濭濧濦濞濲濝濢濨燡燱燨燲燤燰燢獳獮獯璗璲璫璐璪璭璱璥璯甐甑甒甏疄癃癈癉癇皤盩瞵瞫瞲瞷瞶"],["eda1","瞴瞱瞨矰磳磽礂磻磼磲礅磹磾礄禫禨穜穛穖穘穔穚窾竀竁簅簏篲簀篿篻簎篴簋篳簂簉簃簁篸篽簆篰篱簐簊糨縭縼繂縳顈縸縪繉繀繇縩繌縰縻縶繄縺罅罿罾罽翴翲耬膻臄臌臊臅臇膼臩艛艚艜薃薀薏薧薕薠薋薣蕻薤薚薞"],["ee40","蕷蕼薉薡蕺蕸蕗薎薖薆薍薙薝薁薢薂薈薅蕹蕶薘薐薟虨螾螪螭蟅螰螬螹螵螼螮蟉蟃蟂蟌螷螯蟄蟊螴螶螿螸螽蟞螲褵褳褼褾襁襒褷襂覭覯覮觲觳謞"],["eea1","謘謖謑謅謋謢謏謒謕謇謍謈謆謜謓謚豏豰豲豱豯貕貔賹赯蹎蹍蹓蹐蹌蹇轃轀邅遾鄸醚醢醛醙醟醡醝醠鎡鎃鎯鍤鍖鍇鍼鍘鍜鍶鍉鍐鍑鍠鍭鎏鍌鍪鍹鍗鍕鍒鍏鍱鍷鍻鍡鍞鍣鍧鎀鍎鍙闇闀闉闃闅閷隮隰隬霠霟霘霝霙鞚鞡鞜"],["ef40","鞞鞝韕韔韱顁顄顊顉顅顃餥餫餬餪餳餲餯餭餱餰馘馣馡騂駺駴駷駹駸駶駻駽駾駼騃骾髾髽鬁髼魈鮚鮨鮞鮛鮦鮡鮥鮤鮆鮢鮠鮯鴳鵁鵧鴶鴮鴯鴱鴸鴰"],["efa1","鵅鵂鵃鴾鴷鵀鴽翵鴭麊麉麍麰黈黚黻黿鼤鼣鼢齔龠儱儭儮嚘嚜嚗嚚嚝嚙奰嬼屩屪巀幭幮懘懟懭懮懱懪懰懫懖懩擿攄擽擸攁攃擼斔旛曚曛曘櫅檹檽櫡櫆檺檶檷櫇檴檭歞毉氋瀇瀌瀍瀁瀅瀔瀎濿瀀濻瀦濼濷瀊爁燿燹爃燽獶"],["f040","璸瓀璵瓁璾璶璻瓂甔甓癜癤癙癐癓癗癚皦皽盬矂瞺磿礌礓礔礉礐礒礑禭禬穟簜簩簙簠簟簭簝簦簨簢簥簰繜繐繖繣繘繢繟繑繠繗繓羵羳翷翸聵臑臒"],["f0a1","臐艟艞薴藆藀藃藂薳薵薽藇藄薿藋藎藈藅薱薶藒蘤薸薷薾虩蟧蟦蟢蟛蟫蟪蟥蟟蟳蟤蟔蟜蟓蟭蟘蟣螤蟗蟙蠁蟴蟨蟝襓襋襏襌襆襐襑襉謪謧謣謳謰謵譇謯謼謾謱謥謷謦謶謮謤謻謽謺豂豵貙貘貗賾贄贂贀蹜蹢蹠蹗蹖蹞蹥蹧"],["f140","蹛蹚蹡蹝蹩蹔轆轇轈轋鄨鄺鄻鄾醨醥醧醯醪鎵鎌鎒鎷鎛鎝鎉鎧鎎鎪鎞鎦鎕鎈鎙鎟鎍鎱鎑鎲鎤鎨鎴鎣鎥闒闓闑隳雗雚巂雟雘雝霣霢霥鞬鞮鞨鞫鞤鞪"],["f1a1","鞢鞥韗韙韖韘韺顐顑顒颸饁餼餺騏騋騉騍騄騑騊騅騇騆髀髜鬈鬄鬅鬩鬵魊魌魋鯇鯆鯃鮿鯁鮵鮸鯓鮶鯄鮹鮽鵜鵓鵏鵊鵛鵋鵙鵖鵌鵗鵒鵔鵟鵘鵚麎麌黟鼁鼀鼖鼥鼫鼪鼩鼨齌齕儴儵劖勷厴嚫嚭嚦嚧嚪嚬壚壝壛夒嬽嬾嬿巃幰"],["f240","徿懻攇攐攍攉攌攎斄旞旝曞櫧櫠櫌櫑櫙櫋櫟櫜櫐櫫櫏櫍櫞歠殰氌瀙瀧瀠瀖瀫瀡瀢瀣瀩瀗瀤瀜瀪爌爊爇爂爅犥犦犤犣犡瓋瓅璷瓃甖癠矉矊矄矱礝礛"],["f2a1","礡礜礗礞禰穧穨簳簼簹簬簻糬糪繶繵繸繰繷繯繺繲繴繨罋罊羃羆羷翽翾聸臗臕艤艡艣藫藱藭藙藡藨藚藗藬藲藸藘藟藣藜藑藰藦藯藞藢蠀蟺蠃蟶蟷蠉蠌蠋蠆蟼蠈蟿蠊蠂襢襚襛襗襡襜襘襝襙覈覷覶觶譐譈譊譀譓譖譔譋譕"],["f340","譑譂譒譗豃豷豶貚贆贇贉趬趪趭趫蹭蹸蹳蹪蹯蹻軂轒轑轏轐轓辴酀鄿醰醭鏞鏇鏏鏂鏚鏐鏹鏬鏌鏙鎩鏦鏊鏔鏮鏣鏕鏄鏎鏀鏒鏧镽闚闛雡霩霫霬霨霦"],["f3a1","鞳鞷鞶韝韞韟顜顙顝顗颿颽颻颾饈饇饃馦馧騚騕騥騝騤騛騢騠騧騣騞騜騔髂鬋鬊鬎鬌鬷鯪鯫鯠鯞鯤鯦鯢鯰鯔鯗鯬鯜鯙鯥鯕鯡鯚鵷鶁鶊鶄鶈鵱鶀鵸鶆鶋鶌鵽鵫鵴鵵鵰鵩鶅鵳鵻鶂鵯鵹鵿鶇鵨麔麑黀黼鼭齀齁齍齖齗齘匷嚲"],["f440","嚵嚳壣孅巆巇廮廯忀忁懹攗攖攕攓旟曨曣曤櫳櫰櫪櫨櫹櫱櫮櫯瀼瀵瀯瀷瀴瀱灂瀸瀿瀺瀹灀瀻瀳灁爓爔犨獽獼璺皫皪皾盭矌矎矏矍矲礥礣礧礨礤礩"],["f4a1","禲穮穬穭竷籉籈籊籇籅糮繻繾纁纀羺翿聹臛臙舋艨艩蘢藿蘁藾蘛蘀藶蘄蘉蘅蘌藽蠙蠐蠑蠗蠓蠖襣襦覹觷譠譪譝譨譣譥譧譭趮躆躈躄轙轖轗轕轘轚邍酃酁醷醵醲醳鐋鐓鏻鐠鐏鐔鏾鐕鐐鐨鐙鐍鏵鐀鏷鐇鐎鐖鐒鏺鐉鏸鐊鏿"],["f540","鏼鐌鏶鐑鐆闞闠闟霮霯鞹鞻韽韾顠顢顣顟飁飂饐饎饙饌饋饓騲騴騱騬騪騶騩騮騸騭髇髊髆鬐鬒鬑鰋鰈鯷鰅鰒鯸鱀鰇鰎鰆鰗鰔鰉鶟鶙鶤鶝鶒鶘鶐鶛"],["f5a1","鶠鶔鶜鶪鶗鶡鶚鶢鶨鶞鶣鶿鶩鶖鶦鶧麙麛麚黥黤黧黦鼰鼮齛齠齞齝齙龑儺儹劘劗囃嚽嚾孈孇巋巏廱懽攛欂櫼欃櫸欀灃灄灊灈灉灅灆爝爚爙獾甗癪矐礭礱礯籔籓糲纊纇纈纋纆纍罍羻耰臝蘘蘪蘦蘟蘣蘜蘙蘧蘮蘡蘠蘩蘞蘥"],["f640","蠩蠝蠛蠠蠤蠜蠫衊襭襩襮襫觺譹譸譅譺譻贐贔趯躎躌轞轛轝酆酄酅醹鐿鐻鐶鐩鐽鐼鐰鐹鐪鐷鐬鑀鐱闥闤闣霵霺鞿韡顤飉飆飀饘饖騹騽驆驄驂驁騺"],["f6a1","騿髍鬕鬗鬘鬖鬺魒鰫鰝鰜鰬鰣鰨鰩鰤鰡鶷鶶鶼鷁鷇鷊鷏鶾鷅鷃鶻鶵鷎鶹鶺鶬鷈鶱鶭鷌鶳鷍鶲鹺麜黫黮黭鼛鼘鼚鼱齎齥齤龒亹囆囅囋奱孋孌巕巑廲攡攠攦攢欋欈欉氍灕灖灗灒爞爟犩獿瓘瓕瓙瓗癭皭礵禴穰穱籗籜籙籛籚"],["f740","糴糱纑罏羇臞艫蘴蘵蘳蘬蘲蘶蠬蠨蠦蠪蠥襱覿覾觻譾讄讂讆讅譿贕躕躔躚躒躐躖躗轠轢酇鑌鑐鑊鑋鑏鑇鑅鑈鑉鑆霿韣顪顩飋饔饛驎驓驔驌驏驈驊"],["f7a1","驉驒驐髐鬙鬫鬻魖魕鱆鱈鰿鱄鰹鰳鱁鰼鰷鰴鰲鰽鰶鷛鷒鷞鷚鷋鷐鷜鷑鷟鷩鷙鷘鷖鷵鷕鷝麶黰鼵鼳鼲齂齫龕龢儽劙壨壧奲孍巘蠯彏戁戃戄攩攥斖曫欑欒欏毊灛灚爢玂玁玃癰矔籧籦纕艬蘺虀蘹蘼蘱蘻蘾蠰蠲蠮蠳襶襴襳觾"],["f840","讌讎讋讈豅贙躘轤轣醼鑢鑕鑝鑗鑞韄韅頀驖驙鬞鬟鬠鱒鱘鱐鱊鱍鱋鱕鱙鱌鱎鷻鷷鷯鷣鷫鷸鷤鷶鷡鷮鷦鷲鷰鷢鷬鷴鷳鷨鷭黂黐黲黳鼆鼜鼸鼷鼶齃齏"],["f8a1","齱齰齮齯囓囍孎屭攭曭曮欓灟灡灝灠爣瓛瓥矕礸禷禶籪纗羉艭虃蠸蠷蠵衋讔讕躞躟躠躝醾醽釂鑫鑨鑩雥靆靃靇韇韥驞髕魙鱣鱧鱦鱢鱞鱠鸂鷾鸇鸃鸆鸅鸀鸁鸉鷿鷽鸄麠鼞齆齴齵齶囔攮斸欘欙欗欚灢爦犪矘矙礹籩籫糶纚"],["f940","纘纛纙臠臡虆虇虈襹襺襼襻觿讘讙躥躤躣鑮鑭鑯鑱鑳靉顲饟鱨鱮鱭鸋鸍鸐鸏鸒鸑麡黵鼉齇齸齻齺齹圞灦籯蠼趲躦釃鑴鑸鑶鑵驠鱴鱳鱱鱵鸔鸓黶鼊"],["f9a1","龤灨灥糷虪蠾蠽蠿讞貜躩軉靋顳顴飌饡馫驤驦驧鬤鸕鸗齈戇欞爧虌躨钂钀钁驩驨鬮鸙爩虋讟钃鱹麷癵驫鱺鸝灩灪麤齾齉龘碁銹裏墻恒粧嫺╔╦╗╠╬╣╚╩╝╒╤╕╞╪╡╘╧╛╓╥╖╟╫╢╙╨╜║═╭╮╰╯▓"]]');
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/eucjp.json": function(module) {
        "use strict";
        module.exports = JSON.parse('[["0","\\u0000",127],["8ea1","｡",62],["a1a1","　、。，．・：；？！゛゜´｀¨＾￣＿ヽヾゝゞ〃仝々〆〇ー―‐／＼～∥｜…‥‘’“”（）〔〕［］｛｝〈",9,"＋－±×÷＝≠＜＞≦≧∞∴♂♀°′″℃￥＄￠￡％＃＆＊＠§☆★○●◎◇"],["a2a1","◆□■△▲▽▼※〒→←↑↓〓"],["a2ba","∈∋⊆⊇⊂⊃∪∩"],["a2ca","∧∨￢⇒⇔∀∃"],["a2dc","∠⊥⌒∂∇≡≒≪≫√∽∝∵∫∬"],["a2f2","Å‰♯♭♪†‡¶"],["a2fe","◯"],["a3b0","０",9],["a3c1","Ａ",25],["a3e1","ａ",25],["a4a1","ぁ",82],["a5a1","ァ",85],["a6a1","Α",16,"Σ",6],["a6c1","α",16,"σ",6],["a7a1","А",5,"ЁЖ",25],["a7d1","а",5,"ёж",25],["a8a1","─│┌┐┘└├┬┤┴┼━┃┏┓┛┗┣┳┫┻╋┠┯┨┷┿┝┰┥┸╂"],["ada1","①",19,"Ⅰ",9],["adc0","㍉㌔㌢㍍㌘㌧㌃㌶㍑㍗㌍㌦㌣㌫㍊㌻㎜㎝㎞㎎㎏㏄㎡"],["addf","㍻〝〟№㏍℡㊤",4,"㈱㈲㈹㍾㍽㍼≒≡∫∮∑√⊥∠∟⊿∵∩∪"],["b0a1","亜唖娃阿哀愛挨姶逢葵茜穐悪握渥旭葦芦鯵梓圧斡扱宛姐虻飴絢綾鮎或粟袷安庵按暗案闇鞍杏以伊位依偉囲夷委威尉惟意慰易椅為畏異移維緯胃萎衣謂違遺医井亥域育郁磯一壱溢逸稲茨芋鰯允印咽員因姻引飲淫胤蔭"],["b1a1","院陰隠韻吋右宇烏羽迂雨卯鵜窺丑碓臼渦嘘唄欝蔚鰻姥厩浦瓜閏噂云運雲荏餌叡営嬰影映曳栄永泳洩瑛盈穎頴英衛詠鋭液疫益駅悦謁越閲榎厭円園堰奄宴延怨掩援沿演炎焔煙燕猿縁艶苑薗遠鉛鴛塩於汚甥凹央奥往応"],["b2a1","押旺横欧殴王翁襖鴬鴎黄岡沖荻億屋憶臆桶牡乙俺卸恩温穏音下化仮何伽価佳加可嘉夏嫁家寡科暇果架歌河火珂禍禾稼箇花苛茄荷華菓蝦課嘩貨迦過霞蚊俄峨我牙画臥芽蛾賀雅餓駕介会解回塊壊廻快怪悔恢懐戒拐改"],["b3a1","魁晦械海灰界皆絵芥蟹開階貝凱劾外咳害崖慨概涯碍蓋街該鎧骸浬馨蛙垣柿蛎鈎劃嚇各廓拡撹格核殻獲確穫覚角赫較郭閣隔革学岳楽額顎掛笠樫橿梶鰍潟割喝恰括活渇滑葛褐轄且鰹叶椛樺鞄株兜竃蒲釜鎌噛鴨栢茅萱"],["b4a1","粥刈苅瓦乾侃冠寒刊勘勧巻喚堪姦完官寛干幹患感慣憾換敢柑桓棺款歓汗漢澗潅環甘監看竿管簡緩缶翰肝艦莞観諌貫還鑑間閑関陥韓館舘丸含岸巌玩癌眼岩翫贋雁頑顔願企伎危喜器基奇嬉寄岐希幾忌揮机旗既期棋棄"],["b5a1","機帰毅気汽畿祈季稀紀徽規記貴起軌輝飢騎鬼亀偽儀妓宜戯技擬欺犠疑祇義蟻誼議掬菊鞠吉吃喫桔橘詰砧杵黍却客脚虐逆丘久仇休及吸宮弓急救朽求汲泣灸球究窮笈級糾給旧牛去居巨拒拠挙渠虚許距鋸漁禦魚亨享京"],["b6a1","供侠僑兇競共凶協匡卿叫喬境峡強彊怯恐恭挟教橋況狂狭矯胸脅興蕎郷鏡響饗驚仰凝尭暁業局曲極玉桐粁僅勤均巾錦斤欣欽琴禁禽筋緊芹菌衿襟謹近金吟銀九倶句区狗玖矩苦躯駆駈駒具愚虞喰空偶寓遇隅串櫛釧屑屈"],["b7a1","掘窟沓靴轡窪熊隈粂栗繰桑鍬勲君薫訓群軍郡卦袈祁係傾刑兄啓圭珪型契形径恵慶慧憩掲携敬景桂渓畦稽系経継繋罫茎荊蛍計詣警軽頚鶏芸迎鯨劇戟撃激隙桁傑欠決潔穴結血訣月件倹倦健兼券剣喧圏堅嫌建憲懸拳捲"],["b8a1","検権牽犬献研硯絹県肩見謙賢軒遣鍵険顕験鹸元原厳幻弦減源玄現絃舷言諺限乎個古呼固姑孤己庫弧戸故枯湖狐糊袴股胡菰虎誇跨鈷雇顧鼓五互伍午呉吾娯後御悟梧檎瑚碁語誤護醐乞鯉交佼侯候倖光公功効勾厚口向"],["b9a1","后喉坑垢好孔孝宏工巧巷幸広庚康弘恒慌抗拘控攻昂晃更杭校梗構江洪浩港溝甲皇硬稿糠紅紘絞綱耕考肯肱腔膏航荒行衡講貢購郊酵鉱砿鋼閤降項香高鴻剛劫号合壕拷濠豪轟麹克刻告国穀酷鵠黒獄漉腰甑忽惚骨狛込"],["baa1","此頃今困坤墾婚恨懇昏昆根梱混痕紺艮魂些佐叉唆嵯左差査沙瑳砂詐鎖裟坐座挫債催再最哉塞妻宰彩才採栽歳済災采犀砕砦祭斎細菜裁載際剤在材罪財冴坂阪堺榊肴咲崎埼碕鷺作削咋搾昨朔柵窄策索錯桜鮭笹匙冊刷"],["bba1","察拶撮擦札殺薩雑皐鯖捌錆鮫皿晒三傘参山惨撒散桟燦珊産算纂蚕讃賛酸餐斬暫残仕仔伺使刺司史嗣四士始姉姿子屍市師志思指支孜斯施旨枝止死氏獅祉私糸紙紫肢脂至視詞詩試誌諮資賜雌飼歯事似侍児字寺慈持時"],["bca1","次滋治爾璽痔磁示而耳自蒔辞汐鹿式識鴫竺軸宍雫七叱執失嫉室悉湿漆疾質実蔀篠偲柴芝屡蕊縞舎写射捨赦斜煮社紗者謝車遮蛇邪借勺尺杓灼爵酌釈錫若寂弱惹主取守手朱殊狩珠種腫趣酒首儒受呪寿授樹綬需囚収周"],["bda1","宗就州修愁拾洲秀秋終繍習臭舟蒐衆襲讐蹴輯週酋酬集醜什住充十従戎柔汁渋獣縦重銃叔夙宿淑祝縮粛塾熟出術述俊峻春瞬竣舜駿准循旬楯殉淳準潤盾純巡遵醇順処初所暑曙渚庶緒署書薯藷諸助叙女序徐恕鋤除傷償"],["bea1","勝匠升召哨商唱嘗奨妾娼宵将小少尚庄床廠彰承抄招掌捷昇昌昭晶松梢樟樵沼消渉湘焼焦照症省硝礁祥称章笑粧紹肖菖蒋蕉衝裳訟証詔詳象賞醤鉦鍾鐘障鞘上丈丞乗冗剰城場壌嬢常情擾条杖浄状畳穣蒸譲醸錠嘱埴飾"],["bfa1","拭植殖燭織職色触食蝕辱尻伸信侵唇娠寝審心慎振新晋森榛浸深申疹真神秦紳臣芯薪親診身辛進針震人仁刃塵壬尋甚尽腎訊迅陣靭笥諏須酢図厨逗吹垂帥推水炊睡粋翠衰遂酔錐錘随瑞髄崇嵩数枢趨雛据杉椙菅頗雀裾"],["c0a1","澄摺寸世瀬畝是凄制勢姓征性成政整星晴棲栖正清牲生盛精聖声製西誠誓請逝醒青静斉税脆隻席惜戚斥昔析石積籍績脊責赤跡蹟碩切拙接摂折設窃節説雪絶舌蝉仙先千占宣専尖川戦扇撰栓栴泉浅洗染潜煎煽旋穿箭線"],["c1a1","繊羨腺舛船薦詮賎践選遷銭銑閃鮮前善漸然全禅繕膳糎噌塑岨措曾曽楚狙疏疎礎祖租粗素組蘇訴阻遡鼠僧創双叢倉喪壮奏爽宋層匝惣想捜掃挿掻操早曹巣槍槽漕燥争痩相窓糟総綜聡草荘葬蒼藻装走送遭鎗霜騒像増憎"],["c2a1","臓蔵贈造促側則即息捉束測足速俗属賊族続卒袖其揃存孫尊損村遜他多太汰詑唾堕妥惰打柁舵楕陀駄騨体堆対耐岱帯待怠態戴替泰滞胎腿苔袋貸退逮隊黛鯛代台大第醍題鷹滝瀧卓啄宅托択拓沢濯琢託鐸濁諾茸凧蛸只"],["c3a1","叩但達辰奪脱巽竪辿棚谷狸鱈樽誰丹単嘆坦担探旦歎淡湛炭短端箪綻耽胆蛋誕鍛団壇弾断暖檀段男談値知地弛恥智池痴稚置致蜘遅馳築畜竹筑蓄逐秩窒茶嫡着中仲宙忠抽昼柱注虫衷註酎鋳駐樗瀦猪苧著貯丁兆凋喋寵"],["c4a1","帖帳庁弔張彫徴懲挑暢朝潮牒町眺聴脹腸蝶調諜超跳銚長頂鳥勅捗直朕沈珍賃鎮陳津墜椎槌追鎚痛通塚栂掴槻佃漬柘辻蔦綴鍔椿潰坪壷嬬紬爪吊釣鶴亭低停偵剃貞呈堤定帝底庭廷弟悌抵挺提梯汀碇禎程締艇訂諦蹄逓"],["c5a1","邸鄭釘鼎泥摘擢敵滴的笛適鏑溺哲徹撤轍迭鉄典填天展店添纏甜貼転顛点伝殿澱田電兎吐堵塗妬屠徒斗杜渡登菟賭途都鍍砥砺努度土奴怒倒党冬凍刀唐塔塘套宕島嶋悼投搭東桃梼棟盗淘湯涛灯燈当痘祷等答筒糖統到"],["c6a1","董蕩藤討謄豆踏逃透鐙陶頭騰闘働動同堂導憧撞洞瞳童胴萄道銅峠鴇匿得徳涜特督禿篤毒独読栃橡凸突椴届鳶苫寅酉瀞噸屯惇敦沌豚遁頓呑曇鈍奈那内乍凪薙謎灘捺鍋楢馴縄畷南楠軟難汝二尼弐迩匂賑肉虹廿日乳入"],["c7a1","如尿韮任妊忍認濡禰祢寧葱猫熱年念捻撚燃粘乃廼之埜嚢悩濃納能脳膿農覗蚤巴把播覇杷波派琶破婆罵芭馬俳廃拝排敗杯盃牌背肺輩配倍培媒梅楳煤狽買売賠陪這蝿秤矧萩伯剥博拍柏泊白箔粕舶薄迫曝漠爆縛莫駁麦"],["c8a1","函箱硲箸肇筈櫨幡肌畑畠八鉢溌発醗髪伐罰抜筏閥鳩噺塙蛤隼伴判半反叛帆搬斑板氾汎版犯班畔繁般藩販範釆煩頒飯挽晩番盤磐蕃蛮匪卑否妃庇彼悲扉批披斐比泌疲皮碑秘緋罷肥被誹費避非飛樋簸備尾微枇毘琵眉美"],["c9a1","鼻柊稗匹疋髭彦膝菱肘弼必畢筆逼桧姫媛紐百謬俵彪標氷漂瓢票表評豹廟描病秒苗錨鋲蒜蛭鰭品彬斌浜瀕貧賓頻敏瓶不付埠夫婦富冨布府怖扶敷斧普浮父符腐膚芙譜負賦赴阜附侮撫武舞葡蕪部封楓風葺蕗伏副復幅服"],["caa1","福腹複覆淵弗払沸仏物鮒分吻噴墳憤扮焚奮粉糞紛雰文聞丙併兵塀幣平弊柄並蔽閉陛米頁僻壁癖碧別瞥蔑箆偏変片篇編辺返遍便勉娩弁鞭保舗鋪圃捕歩甫補輔穂募墓慕戊暮母簿菩倣俸包呆報奉宝峰峯崩庖抱捧放方朋"],["cba1","法泡烹砲縫胞芳萌蓬蜂褒訪豊邦鋒飽鳳鵬乏亡傍剖坊妨帽忘忙房暴望某棒冒紡肪膨謀貌貿鉾防吠頬北僕卜墨撲朴牧睦穆釦勃没殆堀幌奔本翻凡盆摩磨魔麻埋妹昧枚毎哩槙幕膜枕鮪柾鱒桝亦俣又抹末沫迄侭繭麿万慢満"],["cca1","漫蔓味未魅巳箕岬密蜜湊蓑稔脈妙粍民眠務夢無牟矛霧鵡椋婿娘冥名命明盟迷銘鳴姪牝滅免棉綿緬面麺摸模茂妄孟毛猛盲網耗蒙儲木黙目杢勿餅尤戻籾貰問悶紋門匁也冶夜爺耶野弥矢厄役約薬訳躍靖柳薮鑓愉愈油癒"],["cda1","諭輸唯佑優勇友宥幽悠憂揖有柚湧涌猶猷由祐裕誘遊邑郵雄融夕予余与誉輿預傭幼妖容庸揚揺擁曜楊様洋溶熔用窯羊耀葉蓉要謡踊遥陽養慾抑欲沃浴翌翼淀羅螺裸来莱頼雷洛絡落酪乱卵嵐欄濫藍蘭覧利吏履李梨理璃"],["cea1","痢裏裡里離陸律率立葎掠略劉流溜琉留硫粒隆竜龍侶慮旅虜了亮僚両凌寮料梁涼猟療瞭稜糧良諒遼量陵領力緑倫厘林淋燐琳臨輪隣鱗麟瑠塁涙累類令伶例冷励嶺怜玲礼苓鈴隷零霊麗齢暦歴列劣烈裂廉恋憐漣煉簾練聯"],["cfa1","蓮連錬呂魯櫓炉賂路露労婁廊弄朗楼榔浪漏牢狼篭老聾蝋郎六麓禄肋録論倭和話歪賄脇惑枠鷲亙亘鰐詫藁蕨椀湾碗腕"],["d0a1","弌丐丕个丱丶丼丿乂乖乘亂亅豫亊舒弍于亞亟亠亢亰亳亶从仍仄仆仂仗仞仭仟价伉佚估佛佝佗佇佶侈侏侘佻佩佰侑佯來侖儘俔俟俎俘俛俑俚俐俤俥倚倨倔倪倥倅伜俶倡倩倬俾俯們倆偃假會偕偐偈做偖偬偸傀傚傅傴傲"],["d1a1","僉僊傳僂僖僞僥僭僣僮價僵儉儁儂儖儕儔儚儡儺儷儼儻儿兀兒兌兔兢竸兩兪兮冀冂囘册冉冏冑冓冕冖冤冦冢冩冪冫决冱冲冰况冽凅凉凛几處凩凭凰凵凾刄刋刔刎刧刪刮刳刹剏剄剋剌剞剔剪剴剩剳剿剽劍劔劒剱劈劑辨"],["d2a1","辧劬劭劼劵勁勍勗勞勣勦飭勠勳勵勸勹匆匈甸匍匐匏匕匚匣匯匱匳匸區卆卅丗卉卍凖卞卩卮夘卻卷厂厖厠厦厥厮厰厶參簒雙叟曼燮叮叨叭叺吁吽呀听吭吼吮吶吩吝呎咏呵咎呟呱呷呰咒呻咀呶咄咐咆哇咢咸咥咬哄哈咨"],["d3a1","咫哂咤咾咼哘哥哦唏唔哽哮哭哺哢唹啀啣啌售啜啅啖啗唸唳啝喙喀咯喊喟啻啾喘喞單啼喃喩喇喨嗚嗅嗟嗄嗜嗤嗔嘔嗷嘖嗾嗽嘛嗹噎噐營嘴嘶嘲嘸噫噤嘯噬噪嚆嚀嚊嚠嚔嚏嚥嚮嚶嚴囂嚼囁囃囀囈囎囑囓囗囮囹圀囿圄圉"],["d4a1","圈國圍圓團圖嗇圜圦圷圸坎圻址坏坩埀垈坡坿垉垓垠垳垤垪垰埃埆埔埒埓堊埖埣堋堙堝塲堡塢塋塰毀塒堽塹墅墹墟墫墺壞墻墸墮壅壓壑壗壙壘壥壜壤壟壯壺壹壻壼壽夂夊夐夛梦夥夬夭夲夸夾竒奕奐奎奚奘奢奠奧奬奩"],["d5a1","奸妁妝佞侫妣妲姆姨姜妍姙姚娥娟娑娜娉娚婀婬婉娵娶婢婪媚媼媾嫋嫂媽嫣嫗嫦嫩嫖嫺嫻嬌嬋嬖嬲嫐嬪嬶嬾孃孅孀孑孕孚孛孥孩孰孳孵學斈孺宀它宦宸寃寇寉寔寐寤實寢寞寥寫寰寶寳尅將專對尓尠尢尨尸尹屁屆屎屓"],["d6a1","屐屏孱屬屮乢屶屹岌岑岔妛岫岻岶岼岷峅岾峇峙峩峽峺峭嶌峪崋崕崗嵜崟崛崑崔崢崚崙崘嵌嵒嵎嵋嵬嵳嵶嶇嶄嶂嶢嶝嶬嶮嶽嶐嶷嶼巉巍巓巒巖巛巫已巵帋帚帙帑帛帶帷幄幃幀幎幗幔幟幢幤幇幵并幺麼广庠廁廂廈廐廏"],["d7a1","廖廣廝廚廛廢廡廨廩廬廱廳廰廴廸廾弃弉彝彜弋弑弖弩弭弸彁彈彌彎弯彑彖彗彙彡彭彳彷徃徂彿徊很徑徇從徙徘徠徨徭徼忖忻忤忸忱忝悳忿怡恠怙怐怩怎怱怛怕怫怦怏怺恚恁恪恷恟恊恆恍恣恃恤恂恬恫恙悁悍惧悃悚"],["d8a1","悄悛悖悗悒悧悋惡悸惠惓悴忰悽惆悵惘慍愕愆惶惷愀惴惺愃愡惻惱愍愎慇愾愨愧慊愿愼愬愴愽慂慄慳慷慘慙慚慫慴慯慥慱慟慝慓慵憙憖憇憬憔憚憊憑憫憮懌懊應懷懈懃懆憺懋罹懍懦懣懶懺懴懿懽懼懾戀戈戉戍戌戔戛"],["d9a1","戞戡截戮戰戲戳扁扎扞扣扛扠扨扼抂抉找抒抓抖拔抃抔拗拑抻拏拿拆擔拈拜拌拊拂拇抛拉挌拮拱挧挂挈拯拵捐挾捍搜捏掖掎掀掫捶掣掏掉掟掵捫捩掾揩揀揆揣揉插揶揄搖搴搆搓搦搶攝搗搨搏摧摯摶摎攪撕撓撥撩撈撼"],["daa1","據擒擅擇撻擘擂擱擧舉擠擡抬擣擯攬擶擴擲擺攀擽攘攜攅攤攣攫攴攵攷收攸畋效敖敕敍敘敞敝敲數斂斃變斛斟斫斷旃旆旁旄旌旒旛旙无旡旱杲昊昃旻杳昵昶昴昜晏晄晉晁晞晝晤晧晨晟晢晰暃暈暎暉暄暘暝曁暹曉暾暼"],["dba1","曄暸曖曚曠昿曦曩曰曵曷朏朖朞朦朧霸朮朿朶杁朸朷杆杞杠杙杣杤枉杰枩杼杪枌枋枦枡枅枷柯枴柬枳柩枸柤柞柝柢柮枹柎柆柧檜栞框栩桀桍栲桎梳栫桙档桷桿梟梏梭梔條梛梃檮梹桴梵梠梺椏梍桾椁棊椈棘椢椦棡椌棍"],["dca1","棔棧棕椶椒椄棗棣椥棹棠棯椨椪椚椣椡棆楹楷楜楸楫楔楾楮椹楴椽楙椰楡楞楝榁楪榲榮槐榿槁槓榾槎寨槊槝榻槃榧樮榑榠榜榕榴槞槨樂樛槿權槹槲槧樅榱樞槭樔槫樊樒櫁樣樓橄樌橲樶橸橇橢橙橦橈樸樢檐檍檠檄檢檣"],["dda1","檗蘗檻櫃櫂檸檳檬櫞櫑櫟檪櫚櫪櫻欅蘖櫺欒欖鬱欟欸欷盜欹飮歇歃歉歐歙歔歛歟歡歸歹歿殀殄殃殍殘殕殞殤殪殫殯殲殱殳殷殼毆毋毓毟毬毫毳毯麾氈氓气氛氤氣汞汕汢汪沂沍沚沁沛汾汨汳沒沐泄泱泓沽泗泅泝沮沱沾"],["dea1","沺泛泯泙泪洟衍洶洫洽洸洙洵洳洒洌浣涓浤浚浹浙涎涕濤涅淹渕渊涵淇淦涸淆淬淞淌淨淒淅淺淙淤淕淪淮渭湮渮渙湲湟渾渣湫渫湶湍渟湃渺湎渤滿渝游溂溪溘滉溷滓溽溯滄溲滔滕溏溥滂溟潁漑灌滬滸滾漿滲漱滯漲滌"],["dfa1","漾漓滷澆潺潸澁澀潯潛濳潭澂潼潘澎澑濂潦澳澣澡澤澹濆澪濟濕濬濔濘濱濮濛瀉瀋濺瀑瀁瀏濾瀛瀚潴瀝瀘瀟瀰瀾瀲灑灣炙炒炯烱炬炸炳炮烟烋烝烙焉烽焜焙煥煕熈煦煢煌煖煬熏燻熄熕熨熬燗熹熾燒燉燔燎燠燬燧燵燼"],["e0a1","燹燿爍爐爛爨爭爬爰爲爻爼爿牀牆牋牘牴牾犂犁犇犒犖犢犧犹犲狃狆狄狎狒狢狠狡狹狷倏猗猊猜猖猝猴猯猩猥猾獎獏默獗獪獨獰獸獵獻獺珈玳珎玻珀珥珮珞璢琅瑯琥珸琲琺瑕琿瑟瑙瑁瑜瑩瑰瑣瑪瑶瑾璋璞璧瓊瓏瓔珱"],["e1a1","瓠瓣瓧瓩瓮瓲瓰瓱瓸瓷甄甃甅甌甎甍甕甓甞甦甬甼畄畍畊畉畛畆畚畩畤畧畫畭畸當疆疇畴疊疉疂疔疚疝疥疣痂疳痃疵疽疸疼疱痍痊痒痙痣痞痾痿痼瘁痰痺痲痳瘋瘍瘉瘟瘧瘠瘡瘢瘤瘴瘰瘻癇癈癆癜癘癡癢癨癩癪癧癬癰"],["e2a1","癲癶癸發皀皃皈皋皎皖皓皙皚皰皴皸皹皺盂盍盖盒盞盡盥盧盪蘯盻眈眇眄眩眤眞眥眦眛眷眸睇睚睨睫睛睥睿睾睹瞎瞋瞑瞠瞞瞰瞶瞹瞿瞼瞽瞻矇矍矗矚矜矣矮矼砌砒礦砠礪硅碎硴碆硼碚碌碣碵碪碯磑磆磋磔碾碼磅磊磬"],["e3a1","磧磚磽磴礇礒礑礙礬礫祀祠祗祟祚祕祓祺祿禊禝禧齋禪禮禳禹禺秉秕秧秬秡秣稈稍稘稙稠稟禀稱稻稾稷穃穗穉穡穢穩龝穰穹穽窈窗窕窘窖窩竈窰窶竅竄窿邃竇竊竍竏竕竓站竚竝竡竢竦竭竰笂笏笊笆笳笘笙笞笵笨笶筐"],["e4a1","筺笄筍笋筌筅筵筥筴筧筰筱筬筮箝箘箟箍箜箚箋箒箏筝箙篋篁篌篏箴篆篝篩簑簔篦篥籠簀簇簓篳篷簗簍篶簣簧簪簟簷簫簽籌籃籔籏籀籐籘籟籤籖籥籬籵粃粐粤粭粢粫粡粨粳粲粱粮粹粽糀糅糂糘糒糜糢鬻糯糲糴糶糺紆"],["e5a1","紂紜紕紊絅絋紮紲紿紵絆絳絖絎絲絨絮絏絣經綉絛綏絽綛綺綮綣綵緇綽綫總綢綯緜綸綟綰緘緝緤緞緻緲緡縅縊縣縡縒縱縟縉縋縢繆繦縻縵縹繃縷縲縺繧繝繖繞繙繚繹繪繩繼繻纃緕繽辮繿纈纉續纒纐纓纔纖纎纛纜缸缺"],["e6a1","罅罌罍罎罐网罕罔罘罟罠罨罩罧罸羂羆羃羈羇羌羔羞羝羚羣羯羲羹羮羶羸譱翅翆翊翕翔翡翦翩翳翹飜耆耄耋耒耘耙耜耡耨耿耻聊聆聒聘聚聟聢聨聳聲聰聶聹聽聿肄肆肅肛肓肚肭冐肬胛胥胙胝胄胚胖脉胯胱脛脩脣脯腋"],["e7a1","隋腆脾腓腑胼腱腮腥腦腴膃膈膊膀膂膠膕膤膣腟膓膩膰膵膾膸膽臀臂膺臉臍臑臙臘臈臚臟臠臧臺臻臾舁舂舅與舊舍舐舖舩舫舸舳艀艙艘艝艚艟艤艢艨艪艫舮艱艷艸艾芍芒芫芟芻芬苡苣苟苒苴苳苺莓范苻苹苞茆苜茉苙"],["e8a1","茵茴茖茲茱荀茹荐荅茯茫茗茘莅莚莪莟莢莖茣莎莇莊荼莵荳荵莠莉莨菴萓菫菎菽萃菘萋菁菷萇菠菲萍萢萠莽萸蔆菻葭萪萼蕚蒄葷葫蒭葮蒂葩葆萬葯葹萵蓊葢蒹蒿蒟蓙蓍蒻蓚蓐蓁蓆蓖蒡蔡蓿蓴蔗蔘蔬蔟蔕蔔蓼蕀蕣蕘蕈"],["e9a1","蕁蘂蕋蕕薀薤薈薑薊薨蕭薔薛藪薇薜蕷蕾薐藉薺藏薹藐藕藝藥藜藹蘊蘓蘋藾藺蘆蘢蘚蘰蘿虍乕虔號虧虱蚓蚣蚩蚪蚋蚌蚶蚯蛄蛆蚰蛉蠣蚫蛔蛞蛩蛬蛟蛛蛯蜒蜆蜈蜀蜃蛻蜑蜉蜍蛹蜊蜴蜿蜷蜻蜥蜩蜚蝠蝟蝸蝌蝎蝴蝗蝨蝮蝙"],["eaa1","蝓蝣蝪蠅螢螟螂螯蟋螽蟀蟐雖螫蟄螳蟇蟆螻蟯蟲蟠蠏蠍蟾蟶蟷蠎蟒蠑蠖蠕蠢蠡蠱蠶蠹蠧蠻衄衂衒衙衞衢衫袁衾袞衵衽袵衲袂袗袒袮袙袢袍袤袰袿袱裃裄裔裘裙裝裹褂裼裴裨裲褄褌褊褓襃褞褥褪褫襁襄褻褶褸襌褝襠襞"],["eba1","襦襤襭襪襯襴襷襾覃覈覊覓覘覡覩覦覬覯覲覺覽覿觀觚觜觝觧觴觸訃訖訐訌訛訝訥訶詁詛詒詆詈詼詭詬詢誅誂誄誨誡誑誥誦誚誣諄諍諂諚諫諳諧諤諱謔諠諢諷諞諛謌謇謚諡謖謐謗謠謳鞫謦謫謾謨譁譌譏譎證譖譛譚譫"],["eca1","譟譬譯譴譽讀讌讎讒讓讖讙讚谺豁谿豈豌豎豐豕豢豬豸豺貂貉貅貊貍貎貔豼貘戝貭貪貽貲貳貮貶賈賁賤賣賚賽賺賻贄贅贊贇贏贍贐齎贓賍贔贖赧赭赱赳趁趙跂趾趺跏跚跖跌跛跋跪跫跟跣跼踈踉跿踝踞踐踟蹂踵踰踴蹊"],["eda1","蹇蹉蹌蹐蹈蹙蹤蹠踪蹣蹕蹶蹲蹼躁躇躅躄躋躊躓躑躔躙躪躡躬躰軆躱躾軅軈軋軛軣軼軻軫軾輊輅輕輒輙輓輜輟輛輌輦輳輻輹轅轂輾轌轉轆轎轗轜轢轣轤辜辟辣辭辯辷迚迥迢迪迯邇迴逅迹迺逑逕逡逍逞逖逋逧逶逵逹迸"],["eea1","遏遐遑遒逎遉逾遖遘遞遨遯遶隨遲邂遽邁邀邊邉邏邨邯邱邵郢郤扈郛鄂鄒鄙鄲鄰酊酖酘酣酥酩酳酲醋醉醂醢醫醯醪醵醴醺釀釁釉釋釐釖釟釡釛釼釵釶鈞釿鈔鈬鈕鈑鉞鉗鉅鉉鉤鉈銕鈿鉋鉐銜銖銓銛鉚鋏銹銷鋩錏鋺鍄錮"],["efa1","錙錢錚錣錺錵錻鍜鍠鍼鍮鍖鎰鎬鎭鎔鎹鏖鏗鏨鏥鏘鏃鏝鏐鏈鏤鐚鐔鐓鐃鐇鐐鐶鐫鐵鐡鐺鑁鑒鑄鑛鑠鑢鑞鑪鈩鑰鑵鑷鑽鑚鑼鑾钁鑿閂閇閊閔閖閘閙閠閨閧閭閼閻閹閾闊濶闃闍闌闕闔闖關闡闥闢阡阨阮阯陂陌陏陋陷陜陞"],["f0a1","陝陟陦陲陬隍隘隕隗險隧隱隲隰隴隶隸隹雎雋雉雍襍雜霍雕雹霄霆霈霓霎霑霏霖霙霤霪霰霹霽霾靄靆靈靂靉靜靠靤靦靨勒靫靱靹鞅靼鞁靺鞆鞋鞏鞐鞜鞨鞦鞣鞳鞴韃韆韈韋韜韭齏韲竟韶韵頏頌頸頤頡頷頽顆顏顋顫顯顰"],["f1a1","顱顴顳颪颯颱颶飄飃飆飩飫餃餉餒餔餘餡餝餞餤餠餬餮餽餾饂饉饅饐饋饑饒饌饕馗馘馥馭馮馼駟駛駝駘駑駭駮駱駲駻駸騁騏騅駢騙騫騷驅驂驀驃騾驕驍驛驗驟驢驥驤驩驫驪骭骰骼髀髏髑髓體髞髟髢髣髦髯髫髮髴髱髷"],["f2a1","髻鬆鬘鬚鬟鬢鬣鬥鬧鬨鬩鬪鬮鬯鬲魄魃魏魍魎魑魘魴鮓鮃鮑鮖鮗鮟鮠鮨鮴鯀鯊鮹鯆鯏鯑鯒鯣鯢鯤鯔鯡鰺鯲鯱鯰鰕鰔鰉鰓鰌鰆鰈鰒鰊鰄鰮鰛鰥鰤鰡鰰鱇鰲鱆鰾鱚鱠鱧鱶鱸鳧鳬鳰鴉鴈鳫鴃鴆鴪鴦鶯鴣鴟鵄鴕鴒鵁鴿鴾鵆鵈"],["f3a1","鵝鵞鵤鵑鵐鵙鵲鶉鶇鶫鵯鵺鶚鶤鶩鶲鷄鷁鶻鶸鶺鷆鷏鷂鷙鷓鷸鷦鷭鷯鷽鸚鸛鸞鹵鹹鹽麁麈麋麌麒麕麑麝麥麩麸麪麭靡黌黎黏黐黔黜點黝黠黥黨黯黴黶黷黹黻黼黽鼇鼈皷鼕鼡鼬鼾齊齒齔齣齟齠齡齦齧齬齪齷齲齶龕龜龠"],["f4a1","堯槇遙瑤凜熙"],["f9a1","纊褜鍈銈蓜俉炻昱棈鋹曻彅丨仡仼伀伃伹佖侒侊侚侔俍偀倢俿倞偆偰偂傔僴僘兊兤冝冾凬刕劜劦勀勛匀匇匤卲厓厲叝﨎咜咊咩哿喆坙坥垬埈埇﨏塚增墲夋奓奛奝奣妤妺孖寀甯寘寬尞岦岺峵崧嵓﨑嵂嵭嶸嶹巐弡弴彧德"],["faa1","忞恝悅悊惞惕愠惲愑愷愰憘戓抦揵摠撝擎敎昀昕昻昉昮昞昤晥晗晙晴晳暙暠暲暿曺朎朗杦枻桒柀栁桄棏﨓楨﨔榘槢樰橫橆橳橾櫢櫤毖氿汜沆汯泚洄涇浯涖涬淏淸淲淼渹湜渧渼溿澈澵濵瀅瀇瀨炅炫焏焄煜煆煇凞燁燾犱"],["fba1","犾猤猪獷玽珉珖珣珒琇珵琦琪琩琮瑢璉璟甁畯皂皜皞皛皦益睆劯砡硎硤硺礰礼神祥禔福禛竑竧靖竫箞精絈絜綷綠緖繒罇羡羽茁荢荿菇菶葈蒴蕓蕙蕫﨟薰蘒﨡蠇裵訒訷詹誧誾諟諸諶譓譿賰賴贒赶﨣軏﨤逸遧郞都鄕鄧釚"],["fca1","釗釞釭釮釤釥鈆鈐鈊鈺鉀鈼鉎鉙鉑鈹鉧銧鉷鉸鋧鋗鋙鋐﨧鋕鋠鋓錥錡鋻﨨錞鋿錝錂鍰鍗鎤鏆鏞鏸鐱鑅鑈閒隆﨩隝隯霳霻靃靍靏靑靕顗顥飯飼餧館馞驎髙髜魵魲鮏鮱鮻鰀鵰鵫鶴鸙黑"],["fcf1","ⅰ",9,"￢￤＇＂"],["8fa2af","˘ˇ¸˙˝¯˛˚～΄΅"],["8fa2c2","¡¦¿"],["8fa2eb","ºª©®™¤№"],["8fa6e1","ΆΈΉΊΪ"],["8fa6e7","Ό"],["8fa6e9","ΎΫ"],["8fa6ec","Ώ"],["8fa6f1","άέήίϊΐόςύϋΰώ"],["8fa7c2","Ђ",10,"ЎЏ"],["8fa7f2","ђ",10,"ўџ"],["8fa9a1","ÆĐ"],["8fa9a4","Ħ"],["8fa9a6","Ĳ"],["8fa9a8","ŁĿ"],["8fa9ab","ŊØŒ"],["8fa9af","ŦÞ"],["8fa9c1","æđðħıĳĸłŀŉŋøœßŧþ"],["8faaa1","ÁÀÄÂĂǍĀĄÅÃĆĈČÇĊĎÉÈËÊĚĖĒĘ"],["8faaba","ĜĞĢĠĤÍÌÏÎǏİĪĮĨĴĶĹĽĻŃŇŅÑÓÒÖÔǑŐŌÕŔŘŖŚŜŠŞŤŢÚÙÜÛŬǓŰŪŲŮŨǗǛǙǕŴÝŸŶŹŽŻ"],["8faba1","áàäâăǎāąåãćĉčçċďéèëêěėēęǵĝğ"],["8fabbd","ġĥíìïîǐ"],["8fabc5","īįĩĵķĺľļńňņñóòöôǒőōõŕřŗśŝšşťţúùüûŭǔűūųůũǘǜǚǖŵýÿŷźžż"],["8fb0a1","丂丄丅丌丒丟丣两丨丫丮丯丰丵乀乁乄乇乑乚乜乣乨乩乴乵乹乿亍亖亗亝亯亹仃仐仚仛仠仡仢仨仯仱仳仵份仾仿伀伂伃伈伋伌伒伕伖众伙伮伱你伳伵伷伹伻伾佀佂佈佉佋佌佒佔佖佘佟佣佪佬佮佱佷佸佹佺佽佾侁侂侄"],["8fb1a1","侅侉侊侌侎侐侒侓侔侗侙侚侞侟侲侷侹侻侼侽侾俀俁俅俆俈俉俋俌俍俏俒俜俠俢俰俲俼俽俿倀倁倄倇倊倌倎倐倓倗倘倛倜倝倞倢倧倮倰倲倳倵偀偁偂偅偆偊偌偎偑偒偓偗偙偟偠偢偣偦偧偪偭偰偱倻傁傃傄傆傊傎傏傐"],["8fb2a1","傒傓傔傖傛傜傞",4,"傪傯傰傹傺傽僀僃僄僇僌僎僐僓僔僘僜僝僟僢僤僦僨僩僯僱僶僺僾儃儆儇儈儋儌儍儎僲儐儗儙儛儜儝儞儣儧儨儬儭儯儱儳儴儵儸儹兂兊兏兓兕兗兘兟兤兦兾冃冄冋冎冘冝冡冣冭冸冺冼冾冿凂"],["8fb3a1","凈减凑凒凓凕凘凞凢凥凮凲凳凴凷刁刂刅划刓刕刖刘刢刨刱刲刵刼剅剉剕剗剘剚剜剟剠剡剦剮剷剸剹劀劂劅劊劌劓劕劖劗劘劚劜劤劥劦劧劯劰劶劷劸劺劻劽勀勄勆勈勌勏勑勔勖勛勜勡勥勨勩勪勬勰勱勴勶勷匀匃匊匋"],["8fb4a1","匌匑匓匘匛匜匞匟匥匧匨匩匫匬匭匰匲匵匼匽匾卂卌卋卙卛卡卣卥卬卭卲卹卾厃厇厈厎厓厔厙厝厡厤厪厫厯厲厴厵厷厸厺厽叀叅叏叒叓叕叚叝叞叠另叧叵吂吓吚吡吧吨吪启吱吴吵呃呄呇呍呏呞呢呤呦呧呩呫呭呮呴呿"],["8fb5a1","咁咃咅咈咉咍咑咕咖咜咟咡咦咧咩咪咭咮咱咷咹咺咻咿哆哊响哎哠哪哬哯哶哼哾哿唀唁唅唈唉唌唍唎唕唪唫唲唵唶唻唼唽啁啇啉啊啍啐啑啘啚啛啞啠啡啤啦啿喁喂喆喈喎喏喑喒喓喔喗喣喤喭喲喿嗁嗃嗆嗉嗋嗌嗎嗑嗒"],["8fb6a1","嗓嗗嗘嗛嗞嗢嗩嗶嗿嘅嘈嘊嘍",5,"嘙嘬嘰嘳嘵嘷嘹嘻嘼嘽嘿噀噁噃噄噆噉噋噍噏噔噞噠噡噢噣噦噩噭噯噱噲噵嚄嚅嚈嚋嚌嚕嚙嚚嚝嚞嚟嚦嚧嚨嚩嚫嚬嚭嚱嚳嚷嚾囅囉囊囋囏囐囌囍囙囜囝囟囡囤",4,"囱囫园"],["8fb7a1","囶囷圁圂圇圊圌圑圕圚圛圝圠圢圣圤圥圩圪圬圮圯圳圴圽圾圿坅坆坌坍坒坢坥坧坨坫坭",4,"坳坴坵坷坹坺坻坼坾垁垃垌垔垗垙垚垜垝垞垟垡垕垧垨垩垬垸垽埇埈埌埏埕埝埞埤埦埧埩埭埰埵埶埸埽埾埿堃堄堈堉埡"],["8fb8a1","堌堍堛堞堟堠堦堧堭堲堹堿塉塌塍塏塐塕塟塡塤塧塨塸塼塿墀墁墇墈墉墊墌墍墏墐墔墖墝墠墡墢墦墩墱墲壄墼壂壈壍壎壐壒壔壖壚壝壡壢壩壳夅夆夋夌夒夓夔虁夝夡夣夤夨夯夰夳夵夶夿奃奆奒奓奙奛奝奞奟奡奣奫奭"],["8fb9a1","奯奲奵奶她奻奼妋妌妎妒妕妗妟妤妧妭妮妯妰妳妷妺妼姁姃姄姈姊姍姒姝姞姟姣姤姧姮姯姱姲姴姷娀娄娌娍娎娒娓娞娣娤娧娨娪娭娰婄婅婇婈婌婐婕婞婣婥婧婭婷婺婻婾媋媐媓媖媙媜媞媟媠媢媧媬媱媲媳媵媸媺媻媿"],["8fbaa1","嫄嫆嫈嫏嫚嫜嫠嫥嫪嫮嫵嫶嫽嬀嬁嬈嬗嬴嬙嬛嬝嬡嬥嬭嬸孁孋孌孒孖孞孨孮孯孼孽孾孿宁宄宆宊宎宐宑宓宔宖宨宩宬宭宯宱宲宷宺宼寀寁寍寏寖",4,"寠寯寱寴寽尌尗尞尟尣尦尩尫尬尮尰尲尵尶屙屚屜屢屣屧屨屩"],["8fbba1","屭屰屴屵屺屻屼屽岇岈岊岏岒岝岟岠岢岣岦岪岲岴岵岺峉峋峒峝峗峮峱峲峴崁崆崍崒崫崣崤崦崧崱崴崹崽崿嵂嵃嵆嵈嵕嵑嵙嵊嵟嵠嵡嵢嵤嵪嵭嵰嵹嵺嵾嵿嶁嶃嶈嶊嶒嶓嶔嶕嶙嶛嶟嶠嶧嶫嶰嶴嶸嶹巃巇巋巐巎巘巙巠巤"],["8fbca1","巩巸巹帀帇帍帒帔帕帘帟帠帮帨帲帵帾幋幐幉幑幖幘幛幜幞幨幪",4,"幰庀庋庎庢庤庥庨庪庬庱庳庽庾庿廆廌廋廎廑廒廔廕廜廞廥廫异弆弇弈弎弙弜弝弡弢弣弤弨弫弬弮弰弴弶弻弽弿彀彄彅彇彍彐彔彘彛彠彣彤彧"],["8fbda1","彯彲彴彵彸彺彽彾徉徍徏徖徜徝徢徧徫徤徬徯徰徱徸忄忇忈忉忋忐",4,"忞忡忢忨忩忪忬忭忮忯忲忳忶忺忼怇怊怍怓怔怗怘怚怟怤怭怳怵恀恇恈恉恌恑恔恖恗恝恡恧恱恾恿悂悆悈悊悎悑悓悕悘悝悞悢悤悥您悰悱悷"],["8fbea1","悻悾惂惄惈惉惊惋惎惏惔惕惙惛惝惞惢惥惲惵惸惼惽愂愇愊愌愐",4,"愖愗愙愜愞愢愪愫愰愱愵愶愷愹慁慅慆慉慞慠慬慲慸慻慼慿憀憁憃憄憋憍憒憓憗憘憜憝憟憠憥憨憪憭憸憹憼懀懁懂懎懏懕懜懝懞懟懡懢懧懩懥"],["8fbfa1","懬懭懯戁戃戄戇戓戕戜戠戢戣戧戩戫戹戽扂扃扄扆扌扐扑扒扔扖扚扜扤扭扯扳扺扽抍抎抏抐抦抨抳抶抷抺抾抿拄拎拕拖拚拪拲拴拼拽挃挄挊挋挍挐挓挖挘挩挪挭挵挶挹挼捁捂捃捄捆捊捋捎捒捓捔捘捛捥捦捬捭捱捴捵"],["8fc0a1","捸捼捽捿掂掄掇掊掐掔掕掙掚掞掤掦掭掮掯掽揁揅揈揎揑揓揔揕揜揠揥揪揬揲揳揵揸揹搉搊搐搒搔搘搞搠搢搤搥搩搪搯搰搵搽搿摋摏摑摒摓摔摚摛摜摝摟摠摡摣摭摳摴摻摽撅撇撏撐撑撘撙撛撝撟撡撣撦撨撬撳撽撾撿"],["8fc1a1","擄擉擊擋擌擎擐擑擕擗擤擥擩擪擭擰擵擷擻擿攁攄攈攉攊攏攓攔攖攙攛攞攟攢攦攩攮攱攺攼攽敃敇敉敐敒敔敟敠敧敫敺敽斁斅斊斒斕斘斝斠斣斦斮斲斳斴斿旂旈旉旎旐旔旖旘旟旰旲旴旵旹旾旿昀昄昈昉昍昑昒昕昖昝"],["8fc2a1","昞昡昢昣昤昦昩昪昫昬昮昰昱昳昹昷晀晅晆晊晌晑晎晗晘晙晛晜晠晡曻晪晫晬晾晳晵晿晷晸晹晻暀晼暋暌暍暐暒暙暚暛暜暟暠暤暭暱暲暵暻暿曀曂曃曈曌曎曏曔曛曟曨曫曬曮曺朅朇朎朓朙朜朠朢朳朾杅杇杈杌杔杕杝"],["8fc3a1","杦杬杮杴杶杻极构枎枏枑枓枖枘枙枛枰枱枲枵枻枼枽柹柀柂柃柅柈柉柒柗柙柜柡柦柰柲柶柷桒栔栙栝栟栨栧栬栭栯栰栱栳栻栿桄桅桊桌桕桗桘桛桫桮",4,"桵桹桺桻桼梂梄梆梈梖梘梚梜梡梣梥梩梪梮梲梻棅棈棌棏"],["8fc4a1","棐棑棓棖棙棜棝棥棨棪棫棬棭棰棱棵棶棻棼棽椆椉椊椐椑椓椖椗椱椳椵椸椻楂楅楉楎楗楛楣楤楥楦楨楩楬楰楱楲楺楻楿榀榍榒榖榘榡榥榦榨榫榭榯榷榸榺榼槅槈槑槖槗槢槥槮槯槱槳槵槾樀樁樃樏樑樕樚樝樠樤樨樰樲"],["8fc5a1","樴樷樻樾樿橅橆橉橊橎橐橑橒橕橖橛橤橧橪橱橳橾檁檃檆檇檉檋檑檛檝檞檟檥檫檯檰檱檴檽檾檿櫆櫉櫈櫌櫐櫔櫕櫖櫜櫝櫤櫧櫬櫰櫱櫲櫼櫽欂欃欆欇欉欏欐欑欗欛欞欤欨欫欬欯欵欶欻欿歆歊歍歒歖歘歝歠歧歫歮歰歵歽"],["8fc6a1","歾殂殅殗殛殟殠殢殣殨殩殬殭殮殰殸殹殽殾毃毄毉毌毖毚毡毣毦毧毮毱毷毹毿氂氄氅氉氍氎氐氒氙氟氦氧氨氬氮氳氵氶氺氻氿汊汋汍汏汒汔汙汛汜汫汭汯汴汶汸汹汻沅沆沇沉沔沕沗沘沜沟沰沲沴泂泆泍泏泐泑泒泔泖"],["8fc7a1","泚泜泠泧泩泫泬泮泲泴洄洇洊洎洏洑洓洚洦洧洨汧洮洯洱洹洼洿浗浞浟浡浥浧浯浰浼涂涇涑涒涔涖涗涘涪涬涴涷涹涽涿淄淈淊淎淏淖淛淝淟淠淢淥淩淯淰淴淶淼渀渄渞渢渧渲渶渹渻渼湄湅湈湉湋湏湑湒湓湔湗湜湝湞"],["8fc8a1","湢湣湨湳湻湽溍溓溙溠溧溭溮溱溳溻溿滀滁滃滇滈滊滍滎滏滫滭滮滹滻滽漄漈漊漌漍漖漘漚漛漦漩漪漯漰漳漶漻漼漭潏潑潒潓潗潙潚潝潞潡潢潨潬潽潾澃澇澈澋澌澍澐澒澓澔澖澚澟澠澥澦澧澨澮澯澰澵澶澼濅濇濈濊"],["8fc9a1","濚濞濨濩濰濵濹濼濽瀀瀅瀆瀇瀍瀗瀠瀣瀯瀴瀷瀹瀼灃灄灈灉灊灋灔灕灝灞灎灤灥灬灮灵灶灾炁炅炆炔",4,"炛炤炫炰炱炴炷烊烑烓烔烕烖烘烜烤烺焃",4,"焋焌焏焞焠焫焭焯焰焱焸煁煅煆煇煊煋煐煒煗煚煜煞煠"],["8fcaa1","煨煹熀熅熇熌熒熚熛熠熢熯熰熲熳熺熿燀燁燄燋燌燓燖燙燚燜燸燾爀爇爈爉爓爗爚爝爟爤爫爯爴爸爹牁牂牃牅牎牏牐牓牕牖牚牜牞牠牣牨牫牮牯牱牷牸牻牼牿犄犉犍犎犓犛犨犭犮犱犴犾狁狇狉狌狕狖狘狟狥狳狴狺狻"],["8fcba1","狾猂猄猅猇猋猍猒猓猘猙猞猢猤猧猨猬猱猲猵猺猻猽獃獍獐獒獖獘獝獞獟獠獦獧獩獫獬獮獯獱獷獹獼玀玁玃玅玆玎玐玓玕玗玘玜玞玟玠玢玥玦玪玫玭玵玷玹玼玽玿珅珆珉珋珌珏珒珓珖珙珝珡珣珦珧珩珴珵珷珹珺珻珽"],["8fcca1","珿琀琁琄琇琊琑琚琛琤琦琨",9,"琹瑀瑃瑄瑆瑇瑋瑍瑑瑒瑗瑝瑢瑦瑧瑨瑫瑭瑮瑱瑲璀璁璅璆璇璉璏璐璑璒璘璙璚璜璟璠璡璣璦璨璩璪璫璮璯璱璲璵璹璻璿瓈瓉瓌瓐瓓瓘瓚瓛瓞瓟瓤瓨瓪瓫瓯瓴瓺瓻瓼瓿甆"],["8fcda1","甒甖甗甠甡甤甧甩甪甯甶甹甽甾甿畀畃畇畈畎畐畒畗畞畟畡畯畱畹",5,"疁疅疐疒疓疕疙疜疢疤疴疺疿痀痁痄痆痌痎痏痗痜痟痠痡痤痧痬痮痯痱痹瘀瘂瘃瘄瘇瘈瘊瘌瘏瘒瘓瘕瘖瘙瘛瘜瘝瘞瘣瘥瘦瘩瘭瘲瘳瘵瘸瘹"],["8fcea1","瘺瘼癊癀癁癃癄癅癉癋癕癙癟癤癥癭癮癯癱癴皁皅皌皍皕皛皜皝皟皠皢",6,"皪皭皽盁盅盉盋盌盎盔盙盠盦盨盬盰盱盶盹盼眀眆眊眎眒眔眕眗眙眚眜眢眨眭眮眯眴眵眶眹眽眾睂睅睆睊睍睎睏睒睖睗睜睞睟睠睢"],["8fcfa1","睤睧睪睬睰睲睳睴睺睽瞀瞄瞌瞍瞔瞕瞖瞚瞟瞢瞧瞪瞮瞯瞱瞵瞾矃矉矑矒矕矙矞矟矠矤矦矪矬矰矱矴矸矻砅砆砉砍砎砑砝砡砢砣砭砮砰砵砷硃硄硇硈硌硎硒硜硞硠硡硣硤硨硪确硺硾碊碏碔碘碡碝碞碟碤碨碬碭碰碱碲碳"],["8fd0a1","碻碽碿磇磈磉磌磎磒磓磕磖磤磛磟磠磡磦磪磲磳礀磶磷磺磻磿礆礌礐礚礜礞礟礠礥礧礩礭礱礴礵礻礽礿祄祅祆祊祋祏祑祔祘祛祜祧祩祫祲祹祻祼祾禋禌禑禓禔禕禖禘禛禜禡禨禩禫禯禱禴禸离秂秄秇秈秊秏秔秖秚秝秞"],["8fd1a1","秠秢秥秪秫秭秱秸秼稂稃稇稉稊稌稑稕稛稞稡稧稫稭稯稰稴稵稸稹稺穄穅穇穈穌穕穖穙穜穝穟穠穥穧穪穭穵穸穾窀窂窅窆窊窋窐窑窔窞窠窣窬窳窵窹窻窼竆竉竌竎竑竛竨竩竫竬竱竴竻竽竾笇笔笟笣笧笩笪笫笭笮笯笰"],["8fd2a1","笱笴笽笿筀筁筇筎筕筠筤筦筩筪筭筯筲筳筷箄箉箎箐箑箖箛箞箠箥箬箯箰箲箵箶箺箻箼箽篂篅篈篊篔篖篗篙篚篛篨篪篲篴篵篸篹篺篼篾簁簂簃簄簆簉簋簌簎簏簙簛簠簥簦簨簬簱簳簴簶簹簺籆籊籕籑籒籓籙",5],["8fd3a1","籡籣籧籩籭籮籰籲籹籼籽粆粇粏粔粞粠粦粰粶粷粺粻粼粿糄糇糈糉糍糏糓糔糕糗糙糚糝糦糩糫糵紃紇紈紉紏紑紒紓紖紝紞紣紦紪紭紱紼紽紾絀絁絇絈絍絑絓絗絙絚絜絝絥絧絪絰絸絺絻絿綁綂綃綅綆綈綋綌綍綑綖綗綝"],["8fd4a1","綞綦綧綪綳綶綷綹緂",4,"緌緍緎緗緙縀緢緥緦緪緫緭緱緵緶緹緺縈縐縑縕縗縜縝縠縧縨縬縭縯縳縶縿繄繅繇繎繐繒繘繟繡繢繥繫繮繯繳繸繾纁纆纇纊纍纑纕纘纚纝纞缼缻缽缾缿罃罄罇罏罒罓罛罜罝罡罣罤罥罦罭"],["8fd5a1","罱罽罾罿羀羋羍羏羐羑羖羗羜羡羢羦羪羭羴羼羿翀翃翈翎翏翛翟翣翥翨翬翮翯翲翺翽翾翿耇耈耊耍耎耏耑耓耔耖耝耞耟耠耤耦耬耮耰耴耵耷耹耺耼耾聀聄聠聤聦聭聱聵肁肈肎肜肞肦肧肫肸肹胈胍胏胒胔胕胗胘胠胭胮"],["8fd6a1","胰胲胳胶胹胺胾脃脋脖脗脘脜脞脠脤脧脬脰脵脺脼腅腇腊腌腒腗腠腡腧腨腩腭腯腷膁膐膄膅膆膋膎膖膘膛膞膢膮膲膴膻臋臃臅臊臎臏臕臗臛臝臞臡臤臫臬臰臱臲臵臶臸臹臽臿舀舃舏舓舔舙舚舝舡舢舨舲舴舺艃艄艅艆"],["8fd7a1","艋艎艏艑艖艜艠艣艧艭艴艻艽艿芀芁芃芄芇芉芊芎芑芔芖芘芚芛芠芡芣芤芧芨芩芪芮芰芲芴芷芺芼芾芿苆苐苕苚苠苢苤苨苪苭苯苶苷苽苾茀茁茇茈茊茋荔茛茝茞茟茡茢茬茭茮茰茳茷茺茼茽荂荃荄荇荍荎荑荕荖荗荰荸"],["8fd8a1","荽荿莀莂莄莆莍莒莔莕莘莙莛莜莝莦莧莩莬莾莿菀菇菉菏菐菑菔菝荓菨菪菶菸菹菼萁萆萊萏萑萕萙莭萯萹葅葇葈葊葍葏葑葒葖葘葙葚葜葠葤葥葧葪葰葳葴葶葸葼葽蒁蒅蒒蒓蒕蒞蒦蒨蒩蒪蒯蒱蒴蒺蒽蒾蓀蓂蓇蓈蓌蓏蓓"],["8fd9a1","蓜蓧蓪蓯蓰蓱蓲蓷蔲蓺蓻蓽蔂蔃蔇蔌蔎蔐蔜蔞蔢蔣蔤蔥蔧蔪蔫蔯蔳蔴蔶蔿蕆蕏",4,"蕖蕙蕜",6,"蕤蕫蕯蕹蕺蕻蕽蕿薁薅薆薉薋薌薏薓薘薝薟薠薢薥薧薴薶薷薸薼薽薾薿藂藇藊藋藎薭藘藚藟藠藦藨藭藳藶藼"],["8fdaa1","藿蘀蘄蘅蘍蘎蘐蘑蘒蘘蘙蘛蘞蘡蘧蘩蘶蘸蘺蘼蘽虀虂虆虒虓虖虗虘虙虝虠",4,"虩虬虯虵虶虷虺蚍蚑蚖蚘蚚蚜蚡蚦蚧蚨蚭蚱蚳蚴蚵蚷蚸蚹蚿蛀蛁蛃蛅蛑蛒蛕蛗蛚蛜蛠蛣蛥蛧蚈蛺蛼蛽蜄蜅蜇蜋蜎蜏蜐蜓蜔蜙蜞蜟蜡蜣"],["8fdba1","蜨蜮蜯蜱蜲蜹蜺蜼蜽蜾蝀蝃蝅蝍蝘蝝蝡蝤蝥蝯蝱蝲蝻螃",6,"螋螌螐螓螕螗螘螙螞螠螣螧螬螭螮螱螵螾螿蟁蟈蟉蟊蟎蟕蟖蟙蟚蟜蟟蟢蟣蟤蟪蟫蟭蟱蟳蟸蟺蟿蠁蠃蠆蠉蠊蠋蠐蠙蠒蠓蠔蠘蠚蠛蠜蠞蠟蠨蠭蠮蠰蠲蠵"],["8fdca1","蠺蠼衁衃衅衈衉衊衋衎衑衕衖衘衚衜衟衠衤衩衱衹衻袀袘袚袛袜袟袠袨袪袺袽袾裀裊",4,"裑裒裓裛裞裧裯裰裱裵裷褁褆褍褎褏褕褖褘褙褚褜褠褦褧褨褰褱褲褵褹褺褾襀襂襅襆襉襏襒襗襚襛襜襡襢襣襫襮襰襳襵襺"],["8fdda1","襻襼襽覉覍覐覔覕覛覜覟覠覥覰覴覵覶覷覼觔",4,"觥觩觫觭觱觳觶觹觽觿訄訅訇訏訑訒訔訕訞訠訢訤訦訫訬訯訵訷訽訾詀詃詅詇詉詍詎詓詖詗詘詜詝詡詥詧詵詶詷詹詺詻詾詿誀誃誆誋誏誐誒誖誗誙誟誧誩誮誯誳"],["8fdea1","誶誷誻誾諃諆諈諉諊諑諓諔諕諗諝諟諬諰諴諵諶諼諿謅謆謋謑謜謞謟謊謭謰謷謼譂",4,"譈譒譓譔譙譍譞譣譭譶譸譹譼譾讁讄讅讋讍讏讔讕讜讞讟谸谹谽谾豅豇豉豋豏豑豓豔豗豘豛豝豙豣豤豦豨豩豭豳豵豶豻豾貆"],["8fdfa1","貇貋貐貒貓貙貛貜貤貹貺賅賆賉賋賏賖賕賙賝賡賨賬賯賰賲賵賷賸賾賿贁贃贉贒贗贛赥赩赬赮赿趂趄趈趍趐趑趕趞趟趠趦趫趬趯趲趵趷趹趻跀跅跆跇跈跊跎跑跔跕跗跙跤跥跧跬跰趼跱跲跴跽踁踄踅踆踋踑踔踖踠踡踢"],["8fe0a1","踣踦踧踱踳踶踷踸踹踽蹀蹁蹋蹍蹎蹏蹔蹛蹜蹝蹞蹡蹢蹩蹬蹭蹯蹰蹱蹹蹺蹻躂躃躉躐躒躕躚躛躝躞躢躧躩躭躮躳躵躺躻軀軁軃軄軇軏軑軔軜軨軮軰軱軷軹軺軭輀輂輇輈輏輐輖輗輘輞輠輡輣輥輧輨輬輭輮輴輵輶輷輺轀轁"],["8fe1a1","轃轇轏轑",4,"轘轝轞轥辝辠辡辤辥辦辵辶辸达迀迁迆迊迋迍运迒迓迕迠迣迤迨迮迱迵迶迻迾适逄逈逌逘逛逨逩逯逪逬逭逳逴逷逿遃遄遌遛遝遢遦遧遬遰遴遹邅邈邋邌邎邐邕邗邘邙邛邠邡邢邥邰邲邳邴邶邽郌邾郃"],["8fe2a1","郄郅郇郈郕郗郘郙郜郝郟郥郒郶郫郯郰郴郾郿鄀鄄鄅鄆鄈鄍鄐鄔鄖鄗鄘鄚鄜鄞鄠鄥鄢鄣鄧鄩鄮鄯鄱鄴鄶鄷鄹鄺鄼鄽酃酇酈酏酓酗酙酚酛酡酤酧酭酴酹酺酻醁醃醅醆醊醎醑醓醔醕醘醞醡醦醨醬醭醮醰醱醲醳醶醻醼醽醿"],["8fe3a1","釂釃釅釓釔釗釙釚釞釤釥釩釪釬",5,"釷釹釻釽鈀鈁鈄鈅鈆鈇鈉鈊鈌鈐鈒鈓鈖鈘鈜鈝鈣鈤鈥鈦鈨鈮鈯鈰鈳鈵鈶鈸鈹鈺鈼鈾鉀鉂鉃鉆鉇鉊鉍鉎鉏鉑鉘鉙鉜鉝鉠鉡鉥鉧鉨鉩鉮鉯鉰鉵",4,"鉻鉼鉽鉿銈銉銊銍銎銒銗"],["8fe4a1","銙銟銠銤銥銧銨銫銯銲銶銸銺銻銼銽銿",4,"鋅鋆鋇鋈鋋鋌鋍鋎鋐鋓鋕鋗鋘鋙鋜鋝鋟鋠鋡鋣鋥鋧鋨鋬鋮鋰鋹鋻鋿錀錂錈錍錑錔錕錜錝錞錟錡錤錥錧錩錪錳錴錶錷鍇鍈鍉鍐鍑鍒鍕鍗鍘鍚鍞鍤鍥鍧鍩鍪鍭鍯鍰鍱鍳鍴鍶"],["8fe5a1","鍺鍽鍿鎀鎁鎂鎈鎊鎋鎍鎏鎒鎕鎘鎛鎞鎡鎣鎤鎦鎨鎫鎴鎵鎶鎺鎩鏁鏄鏅鏆鏇鏉",4,"鏓鏙鏜鏞鏟鏢鏦鏧鏹鏷鏸鏺鏻鏽鐁鐂鐄鐈鐉鐍鐎鐏鐕鐖鐗鐟鐮鐯鐱鐲鐳鐴鐻鐿鐽鑃鑅鑈鑊鑌鑕鑙鑜鑟鑡鑣鑨鑫鑭鑮鑯鑱鑲钄钃镸镹"],["8fe6a1","镾閄閈閌閍閎閝閞閟閡閦閩閫閬閴閶閺閽閿闆闈闉闋闐闑闒闓闙闚闝闞闟闠闤闦阝阞阢阤阥阦阬阱阳阷阸阹阺阼阽陁陒陔陖陗陘陡陮陴陻陼陾陿隁隂隃隄隉隑隖隚隝隟隤隥隦隩隮隯隳隺雊雒嶲雘雚雝雞雟雩雯雱雺霂"],["8fe7a1","霃霅霉霚霛霝霡霢霣霨霱霳靁靃靊靎靏靕靗靘靚靛靣靧靪靮靳靶靷靸靻靽靿鞀鞉鞕鞖鞗鞙鞚鞞鞟鞢鞬鞮鞱鞲鞵鞶鞸鞹鞺鞼鞾鞿韁韄韅韇韉韊韌韍韎韐韑韔韗韘韙韝韞韠韛韡韤韯韱韴韷韸韺頇頊頙頍頎頔頖頜頞頠頣頦"],["8fe8a1","頫頮頯頰頲頳頵頥頾顄顇顊顑顒顓顖顗顙顚顢顣顥顦顪顬颫颭颮颰颴颷颸颺颻颿飂飅飈飌飡飣飥飦飧飪飳飶餂餇餈餑餕餖餗餚餛餜餟餢餦餧餫餱",4,"餹餺餻餼饀饁饆饇饈饍饎饔饘饙饛饜饞饟饠馛馝馟馦馰馱馲馵"],["8fe9a1","馹馺馽馿駃駉駓駔駙駚駜駞駧駪駫駬駰駴駵駹駽駾騂騃騄騋騌騐騑騖騞騠騢騣騤騧騭騮騳騵騶騸驇驁驄驊驋驌驎驑驔驖驝骪骬骮骯骲骴骵骶骹骻骾骿髁髃髆髈髎髐髒髕髖髗髛髜髠髤髥髧髩髬髲髳髵髹髺髽髿",4],["8feaa1","鬄鬅鬈鬉鬋鬌鬍鬎鬐鬒鬖鬙鬛鬜鬠鬦鬫鬭鬳鬴鬵鬷鬹鬺鬽魈魋魌魕魖魗魛魞魡魣魥魦魨魪",4,"魳魵魷魸魹魿鮀鮄鮅鮆鮇鮉鮊鮋鮍鮏鮐鮔鮚鮝鮞鮦鮧鮩鮬鮰鮱鮲鮷鮸鮻鮼鮾鮿鯁鯇鯈鯎鯐鯗鯘鯝鯟鯥鯧鯪鯫鯯鯳鯷鯸"],["8feba1","鯹鯺鯽鯿鰀鰂鰋鰏鰑鰖鰘鰙鰚鰜鰞鰢鰣鰦",4,"鰱鰵鰶鰷鰽鱁鱃鱄鱅鱉鱊鱎鱏鱐鱓鱔鱖鱘鱛鱝鱞鱟鱣鱩鱪鱜鱫鱨鱮鱰鱲鱵鱷鱻鳦鳲鳷鳹鴋鴂鴑鴗鴘鴜鴝鴞鴯鴰鴲鴳鴴鴺鴼鵅鴽鵂鵃鵇鵊鵓鵔鵟鵣鵢鵥鵩鵪鵫鵰鵶鵷鵻"],["8feca1","鵼鵾鶃鶄鶆鶊鶍鶎鶒鶓鶕鶖鶗鶘鶡鶪鶬鶮鶱鶵鶹鶼鶿鷃鷇鷉鷊鷔鷕鷖鷗鷚鷞鷟鷠鷥鷧鷩鷫鷮鷰鷳鷴鷾鸊鸂鸇鸎鸐鸑鸒鸕鸖鸙鸜鸝鹺鹻鹼麀麂麃麄麅麇麎麏麖麘麛麞麤麨麬麮麯麰麳麴麵黆黈黋黕黟黤黧黬黭黮黰黱黲黵"],["8feda1","黸黿鼂鼃鼉鼏鼐鼑鼒鼔鼖鼗鼙鼚鼛鼟鼢鼦鼪鼫鼯鼱鼲鼴鼷鼹鼺鼼鼽鼿齁齃",4,"齓齕齖齗齘齚齝齞齨齩齭",4,"齳齵齺齽龏龐龑龒龔龖龗龞龡龢龣龥"]]');
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json": function(module) {
        "use strict";
        module.exports = JSON.parse('{"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}');
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/gbk-added.json": function(module) {
        "use strict";
        module.exports = JSON.parse('[["a140","",62],["a180","",32],["a240","",62],["a280","",32],["a2ab","",5],["a2e3","€"],["a2ef",""],["a2fd",""],["a340","",62],["a380","",31,"　"],["a440","",62],["a480","",32],["a4f4","",10],["a540","",62],["a580","",32],["a5f7","",7],["a640","",62],["a680","",32],["a6b9","",7],["a6d9","",6],["a6ec",""],["a6f3",""],["a6f6","",8],["a740","",62],["a780","",32],["a7c2","",14],["a7f2","",12],["a896","",10],["a8bc",""],["a8bf","ǹ"],["a8c1",""],["a8ea","",20],["a958",""],["a95b",""],["a95d",""],["a989","〾⿰",11],["a997","",12],["a9f0","",14],["aaa1","",93],["aba1","",93],["aca1","",93],["ada1","",93],["aea1","",93],["afa1","",93],["d7fa","",4],["f8a1","",93],["f9a1","",93],["faa1","",93],["fba1","",93],["fca1","",93],["fda1","",93],["fe50","⺁⺄㑳㑇⺈⺋㖞㘚㘎⺌⺗㥮㤘㧏㧟㩳㧐㭎㱮㳠⺧⺪䁖䅟⺮䌷⺳⺶⺷䎱䎬⺻䏝䓖䙡䙌"],["fe80","䜣䜩䝼䞍⻊䥇䥺䥽䦂䦃䦅䦆䦟䦛䦷䦶䲣䲟䲠䲡䱷䲢䴓",6,"䶮",93]]');
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/shiftjis.json": function(module) {
        "use strict";
        module.exports = JSON.parse('[["0","\\u0000",128],["a1","｡",62],["8140","　、。，．・：；？！゛゜´｀¨＾￣＿ヽヾゝゞ〃仝々〆〇ー―‐／＼～∥｜…‥‘’“”（）〔〕［］｛｝〈",9,"＋－±×"],["8180","÷＝≠＜＞≦≧∞∴♂♀°′″℃￥＄￠￡％＃＆＊＠§☆★○●◎◇◆□■△▲▽▼※〒→←↑↓〓"],["81b8","∈∋⊆⊇⊂⊃∪∩"],["81c8","∧∨￢⇒⇔∀∃"],["81da","∠⊥⌒∂∇≡≒≪≫√∽∝∵∫∬"],["81f0","Å‰♯♭♪†‡¶"],["81fc","◯"],["824f","０",9],["8260","Ａ",25],["8281","ａ",25],["829f","ぁ",82],["8340","ァ",62],["8380","ム",22],["839f","Α",16,"Σ",6],["83bf","α",16,"σ",6],["8440","А",5,"ЁЖ",25],["8470","а",5,"ёж",7],["8480","о",17],["849f","─│┌┐┘└├┬┤┴┼━┃┏┓┛┗┣┳┫┻╋┠┯┨┷┿┝┰┥┸╂"],["8740","①",19,"Ⅰ",9],["875f","㍉㌔㌢㍍㌘㌧㌃㌶㍑㍗㌍㌦㌣㌫㍊㌻㎜㎝㎞㎎㎏㏄㎡"],["877e","㍻"],["8780","〝〟№㏍℡㊤",4,"㈱㈲㈹㍾㍽㍼≒≡∫∮∑√⊥∠∟⊿∵∩∪"],["889f","亜唖娃阿哀愛挨姶逢葵茜穐悪握渥旭葦芦鯵梓圧斡扱宛姐虻飴絢綾鮎或粟袷安庵按暗案闇鞍杏以伊位依偉囲夷委威尉惟意慰易椅為畏異移維緯胃萎衣謂違遺医井亥域育郁磯一壱溢逸稲茨芋鰯允印咽員因姻引飲淫胤蔭"],["8940","院陰隠韻吋右宇烏羽迂雨卯鵜窺丑碓臼渦嘘唄欝蔚鰻姥厩浦瓜閏噂云運雲荏餌叡営嬰影映曳栄永泳洩瑛盈穎頴英衛詠鋭液疫益駅悦謁越閲榎厭円"],["8980","園堰奄宴延怨掩援沿演炎焔煙燕猿縁艶苑薗遠鉛鴛塩於汚甥凹央奥往応押旺横欧殴王翁襖鴬鴎黄岡沖荻億屋憶臆桶牡乙俺卸恩温穏音下化仮何伽価佳加可嘉夏嫁家寡科暇果架歌河火珂禍禾稼箇花苛茄荷華菓蝦課嘩貨迦過霞蚊俄峨我牙画臥芽蛾賀雅餓駕介会解回塊壊廻快怪悔恢懐戒拐改"],["8a40","魁晦械海灰界皆絵芥蟹開階貝凱劾外咳害崖慨概涯碍蓋街該鎧骸浬馨蛙垣柿蛎鈎劃嚇各廓拡撹格核殻獲確穫覚角赫較郭閣隔革学岳楽額顎掛笠樫"],["8a80","橿梶鰍潟割喝恰括活渇滑葛褐轄且鰹叶椛樺鞄株兜竃蒲釜鎌噛鴨栢茅萱粥刈苅瓦乾侃冠寒刊勘勧巻喚堪姦完官寛干幹患感慣憾換敢柑桓棺款歓汗漢澗潅環甘監看竿管簡緩缶翰肝艦莞観諌貫還鑑間閑関陥韓館舘丸含岸巌玩癌眼岩翫贋雁頑顔願企伎危喜器基奇嬉寄岐希幾忌揮机旗既期棋棄"],["8b40","機帰毅気汽畿祈季稀紀徽規記貴起軌輝飢騎鬼亀偽儀妓宜戯技擬欺犠疑祇義蟻誼議掬菊鞠吉吃喫桔橘詰砧杵黍却客脚虐逆丘久仇休及吸宮弓急救"],["8b80","朽求汲泣灸球究窮笈級糾給旧牛去居巨拒拠挙渠虚許距鋸漁禦魚亨享京供侠僑兇競共凶協匡卿叫喬境峡強彊怯恐恭挟教橋況狂狭矯胸脅興蕎郷鏡響饗驚仰凝尭暁業局曲極玉桐粁僅勤均巾錦斤欣欽琴禁禽筋緊芹菌衿襟謹近金吟銀九倶句区狗玖矩苦躯駆駈駒具愚虞喰空偶寓遇隅串櫛釧屑屈"],["8c40","掘窟沓靴轡窪熊隈粂栗繰桑鍬勲君薫訓群軍郡卦袈祁係傾刑兄啓圭珪型契形径恵慶慧憩掲携敬景桂渓畦稽系経継繋罫茎荊蛍計詣警軽頚鶏芸迎鯨"],["8c80","劇戟撃激隙桁傑欠決潔穴結血訣月件倹倦健兼券剣喧圏堅嫌建憲懸拳捲検権牽犬献研硯絹県肩見謙賢軒遣鍵険顕験鹸元原厳幻弦減源玄現絃舷言諺限乎個古呼固姑孤己庫弧戸故枯湖狐糊袴股胡菰虎誇跨鈷雇顧鼓五互伍午呉吾娯後御悟梧檎瑚碁語誤護醐乞鯉交佼侯候倖光公功効勾厚口向"],["8d40","后喉坑垢好孔孝宏工巧巷幸広庚康弘恒慌抗拘控攻昂晃更杭校梗構江洪浩港溝甲皇硬稿糠紅紘絞綱耕考肯肱腔膏航荒行衡講貢購郊酵鉱砿鋼閤降"],["8d80","項香高鴻剛劫号合壕拷濠豪轟麹克刻告国穀酷鵠黒獄漉腰甑忽惚骨狛込此頃今困坤墾婚恨懇昏昆根梱混痕紺艮魂些佐叉唆嵯左差査沙瑳砂詐鎖裟坐座挫債催再最哉塞妻宰彩才採栽歳済災采犀砕砦祭斎細菜裁載際剤在材罪財冴坂阪堺榊肴咲崎埼碕鷺作削咋搾昨朔柵窄策索錯桜鮭笹匙冊刷"],["8e40","察拶撮擦札殺薩雑皐鯖捌錆鮫皿晒三傘参山惨撒散桟燦珊産算纂蚕讃賛酸餐斬暫残仕仔伺使刺司史嗣四士始姉姿子屍市師志思指支孜斯施旨枝止"],["8e80","死氏獅祉私糸紙紫肢脂至視詞詩試誌諮資賜雌飼歯事似侍児字寺慈持時次滋治爾璽痔磁示而耳自蒔辞汐鹿式識鴫竺軸宍雫七叱執失嫉室悉湿漆疾質実蔀篠偲柴芝屡蕊縞舎写射捨赦斜煮社紗者謝車遮蛇邪借勺尺杓灼爵酌釈錫若寂弱惹主取守手朱殊狩珠種腫趣酒首儒受呪寿授樹綬需囚収周"],["8f40","宗就州修愁拾洲秀秋終繍習臭舟蒐衆襲讐蹴輯週酋酬集醜什住充十従戎柔汁渋獣縦重銃叔夙宿淑祝縮粛塾熟出術述俊峻春瞬竣舜駿准循旬楯殉淳"],["8f80","準潤盾純巡遵醇順処初所暑曙渚庶緒署書薯藷諸助叙女序徐恕鋤除傷償勝匠升召哨商唱嘗奨妾娼宵将小少尚庄床廠彰承抄招掌捷昇昌昭晶松梢樟樵沼消渉湘焼焦照症省硝礁祥称章笑粧紹肖菖蒋蕉衝裳訟証詔詳象賞醤鉦鍾鐘障鞘上丈丞乗冗剰城場壌嬢常情擾条杖浄状畳穣蒸譲醸錠嘱埴飾"],["9040","拭植殖燭織職色触食蝕辱尻伸信侵唇娠寝審心慎振新晋森榛浸深申疹真神秦紳臣芯薪親診身辛進針震人仁刃塵壬尋甚尽腎訊迅陣靭笥諏須酢図厨"],["9080","逗吹垂帥推水炊睡粋翠衰遂酔錐錘随瑞髄崇嵩数枢趨雛据杉椙菅頗雀裾澄摺寸世瀬畝是凄制勢姓征性成政整星晴棲栖正清牲生盛精聖声製西誠誓請逝醒青静斉税脆隻席惜戚斥昔析石積籍績脊責赤跡蹟碩切拙接摂折設窃節説雪絶舌蝉仙先千占宣専尖川戦扇撰栓栴泉浅洗染潜煎煽旋穿箭線"],["9140","繊羨腺舛船薦詮賎践選遷銭銑閃鮮前善漸然全禅繕膳糎噌塑岨措曾曽楚狙疏疎礎祖租粗素組蘇訴阻遡鼠僧創双叢倉喪壮奏爽宋層匝惣想捜掃挿掻"],["9180","操早曹巣槍槽漕燥争痩相窓糟総綜聡草荘葬蒼藻装走送遭鎗霜騒像増憎臓蔵贈造促側則即息捉束測足速俗属賊族続卒袖其揃存孫尊損村遜他多太汰詑唾堕妥惰打柁舵楕陀駄騨体堆対耐岱帯待怠態戴替泰滞胎腿苔袋貸退逮隊黛鯛代台大第醍題鷹滝瀧卓啄宅托択拓沢濯琢託鐸濁諾茸凧蛸只"],["9240","叩但達辰奪脱巽竪辿棚谷狸鱈樽誰丹単嘆坦担探旦歎淡湛炭短端箪綻耽胆蛋誕鍛団壇弾断暖檀段男談値知地弛恥智池痴稚置致蜘遅馳築畜竹筑蓄"],["9280","逐秩窒茶嫡着中仲宙忠抽昼柱注虫衷註酎鋳駐樗瀦猪苧著貯丁兆凋喋寵帖帳庁弔張彫徴懲挑暢朝潮牒町眺聴脹腸蝶調諜超跳銚長頂鳥勅捗直朕沈珍賃鎮陳津墜椎槌追鎚痛通塚栂掴槻佃漬柘辻蔦綴鍔椿潰坪壷嬬紬爪吊釣鶴亭低停偵剃貞呈堤定帝底庭廷弟悌抵挺提梯汀碇禎程締艇訂諦蹄逓"],["9340","邸鄭釘鼎泥摘擢敵滴的笛適鏑溺哲徹撤轍迭鉄典填天展店添纏甜貼転顛点伝殿澱田電兎吐堵塗妬屠徒斗杜渡登菟賭途都鍍砥砺努度土奴怒倒党冬"],["9380","凍刀唐塔塘套宕島嶋悼投搭東桃梼棟盗淘湯涛灯燈当痘祷等答筒糖統到董蕩藤討謄豆踏逃透鐙陶頭騰闘働動同堂導憧撞洞瞳童胴萄道銅峠鴇匿得徳涜特督禿篤毒独読栃橡凸突椴届鳶苫寅酉瀞噸屯惇敦沌豚遁頓呑曇鈍奈那内乍凪薙謎灘捺鍋楢馴縄畷南楠軟難汝二尼弐迩匂賑肉虹廿日乳入"],["9440","如尿韮任妊忍認濡禰祢寧葱猫熱年念捻撚燃粘乃廼之埜嚢悩濃納能脳膿農覗蚤巴把播覇杷波派琶破婆罵芭馬俳廃拝排敗杯盃牌背肺輩配倍培媒梅"],["9480","楳煤狽買売賠陪這蝿秤矧萩伯剥博拍柏泊白箔粕舶薄迫曝漠爆縛莫駁麦函箱硲箸肇筈櫨幡肌畑畠八鉢溌発醗髪伐罰抜筏閥鳩噺塙蛤隼伴判半反叛帆搬斑板氾汎版犯班畔繁般藩販範釆煩頒飯挽晩番盤磐蕃蛮匪卑否妃庇彼悲扉批披斐比泌疲皮碑秘緋罷肥被誹費避非飛樋簸備尾微枇毘琵眉美"],["9540","鼻柊稗匹疋髭彦膝菱肘弼必畢筆逼桧姫媛紐百謬俵彪標氷漂瓢票表評豹廟描病秒苗錨鋲蒜蛭鰭品彬斌浜瀕貧賓頻敏瓶不付埠夫婦富冨布府怖扶敷"],["9580","斧普浮父符腐膚芙譜負賦赴阜附侮撫武舞葡蕪部封楓風葺蕗伏副復幅服福腹複覆淵弗払沸仏物鮒分吻噴墳憤扮焚奮粉糞紛雰文聞丙併兵塀幣平弊柄並蔽閉陛米頁僻壁癖碧別瞥蔑箆偏変片篇編辺返遍便勉娩弁鞭保舗鋪圃捕歩甫補輔穂募墓慕戊暮母簿菩倣俸包呆報奉宝峰峯崩庖抱捧放方朋"],["9640","法泡烹砲縫胞芳萌蓬蜂褒訪豊邦鋒飽鳳鵬乏亡傍剖坊妨帽忘忙房暴望某棒冒紡肪膨謀貌貿鉾防吠頬北僕卜墨撲朴牧睦穆釦勃没殆堀幌奔本翻凡盆"],["9680","摩磨魔麻埋妹昧枚毎哩槙幕膜枕鮪柾鱒桝亦俣又抹末沫迄侭繭麿万慢満漫蔓味未魅巳箕岬密蜜湊蓑稔脈妙粍民眠務夢無牟矛霧鵡椋婿娘冥名命明盟迷銘鳴姪牝滅免棉綿緬面麺摸模茂妄孟毛猛盲網耗蒙儲木黙目杢勿餅尤戻籾貰問悶紋門匁也冶夜爺耶野弥矢厄役約薬訳躍靖柳薮鑓愉愈油癒"],["9740","諭輸唯佑優勇友宥幽悠憂揖有柚湧涌猶猷由祐裕誘遊邑郵雄融夕予余与誉輿預傭幼妖容庸揚揺擁曜楊様洋溶熔用窯羊耀葉蓉要謡踊遥陽養慾抑欲"],["9780","沃浴翌翼淀羅螺裸来莱頼雷洛絡落酪乱卵嵐欄濫藍蘭覧利吏履李梨理璃痢裏裡里離陸律率立葎掠略劉流溜琉留硫粒隆竜龍侶慮旅虜了亮僚両凌寮料梁涼猟療瞭稜糧良諒遼量陵領力緑倫厘林淋燐琳臨輪隣鱗麟瑠塁涙累類令伶例冷励嶺怜玲礼苓鈴隷零霊麗齢暦歴列劣烈裂廉恋憐漣煉簾練聯"],["9840","蓮連錬呂魯櫓炉賂路露労婁廊弄朗楼榔浪漏牢狼篭老聾蝋郎六麓禄肋録論倭和話歪賄脇惑枠鷲亙亘鰐詫藁蕨椀湾碗腕"],["989f","弌丐丕个丱丶丼丿乂乖乘亂亅豫亊舒弍于亞亟亠亢亰亳亶从仍仄仆仂仗仞仭仟价伉佚估佛佝佗佇佶侈侏侘佻佩佰侑佯來侖儘俔俟俎俘俛俑俚俐俤俥倚倨倔倪倥倅伜俶倡倩倬俾俯們倆偃假會偕偐偈做偖偬偸傀傚傅傴傲"],["9940","僉僊傳僂僖僞僥僭僣僮價僵儉儁儂儖儕儔儚儡儺儷儼儻儿兀兒兌兔兢竸兩兪兮冀冂囘册冉冏冑冓冕冖冤冦冢冩冪冫决冱冲冰况冽凅凉凛几處凩凭"],["9980","凰凵凾刄刋刔刎刧刪刮刳刹剏剄剋剌剞剔剪剴剩剳剿剽劍劔劒剱劈劑辨辧劬劭劼劵勁勍勗勞勣勦飭勠勳勵勸勹匆匈甸匍匐匏匕匚匣匯匱匳匸區卆卅丗卉卍凖卞卩卮夘卻卷厂厖厠厦厥厮厰厶參簒雙叟曼燮叮叨叭叺吁吽呀听吭吼吮吶吩吝呎咏呵咎呟呱呷呰咒呻咀呶咄咐咆哇咢咸咥咬哄哈咨"],["9a40","咫哂咤咾咼哘哥哦唏唔哽哮哭哺哢唹啀啣啌售啜啅啖啗唸唳啝喙喀咯喊喟啻啾喘喞單啼喃喩喇喨嗚嗅嗟嗄嗜嗤嗔嘔嗷嘖嗾嗽嘛嗹噎噐營嘴嘶嘲嘸"],["9a80","噫噤嘯噬噪嚆嚀嚊嚠嚔嚏嚥嚮嚶嚴囂嚼囁囃囀囈囎囑囓囗囮囹圀囿圄圉圈國圍圓團圖嗇圜圦圷圸坎圻址坏坩埀垈坡坿垉垓垠垳垤垪垰埃埆埔埒埓堊埖埣堋堙堝塲堡塢塋塰毀塒堽塹墅墹墟墫墺壞墻墸墮壅壓壑壗壙壘壥壜壤壟壯壺壹壻壼壽夂夊夐夛梦夥夬夭夲夸夾竒奕奐奎奚奘奢奠奧奬奩"],["9b40","奸妁妝佞侫妣妲姆姨姜妍姙姚娥娟娑娜娉娚婀婬婉娵娶婢婪媚媼媾嫋嫂媽嫣嫗嫦嫩嫖嫺嫻嬌嬋嬖嬲嫐嬪嬶嬾孃孅孀孑孕孚孛孥孩孰孳孵學斈孺宀"],["9b80","它宦宸寃寇寉寔寐寤實寢寞寥寫寰寶寳尅將專對尓尠尢尨尸尹屁屆屎屓屐屏孱屬屮乢屶屹岌岑岔妛岫岻岶岼岷峅岾峇峙峩峽峺峭嶌峪崋崕崗嵜崟崛崑崔崢崚崙崘嵌嵒嵎嵋嵬嵳嵶嶇嶄嶂嶢嶝嶬嶮嶽嶐嶷嶼巉巍巓巒巖巛巫已巵帋帚帙帑帛帶帷幄幃幀幎幗幔幟幢幤幇幵并幺麼广庠廁廂廈廐廏"],["9c40","廖廣廝廚廛廢廡廨廩廬廱廳廰廴廸廾弃弉彝彜弋弑弖弩弭弸彁彈彌彎弯彑彖彗彙彡彭彳彷徃徂彿徊很徑徇從徙徘徠徨徭徼忖忻忤忸忱忝悳忿怡恠"],["9c80","怙怐怩怎怱怛怕怫怦怏怺恚恁恪恷恟恊恆恍恣恃恤恂恬恫恙悁悍惧悃悚悄悛悖悗悒悧悋惡悸惠惓悴忰悽惆悵惘慍愕愆惶惷愀惴惺愃愡惻惱愍愎慇愾愨愧慊愿愼愬愴愽慂慄慳慷慘慙慚慫慴慯慥慱慟慝慓慵憙憖憇憬憔憚憊憑憫憮懌懊應懷懈懃懆憺懋罹懍懦懣懶懺懴懿懽懼懾戀戈戉戍戌戔戛"],["9d40","戞戡截戮戰戲戳扁扎扞扣扛扠扨扼抂抉找抒抓抖拔抃抔拗拑抻拏拿拆擔拈拜拌拊拂拇抛拉挌拮拱挧挂挈拯拵捐挾捍搜捏掖掎掀掫捶掣掏掉掟掵捫"],["9d80","捩掾揩揀揆揣揉插揶揄搖搴搆搓搦搶攝搗搨搏摧摯摶摎攪撕撓撥撩撈撼據擒擅擇撻擘擂擱擧舉擠擡抬擣擯攬擶擴擲擺攀擽攘攜攅攤攣攫攴攵攷收攸畋效敖敕敍敘敞敝敲數斂斃變斛斟斫斷旃旆旁旄旌旒旛旙无旡旱杲昊昃旻杳昵昶昴昜晏晄晉晁晞晝晤晧晨晟晢晰暃暈暎暉暄暘暝曁暹曉暾暼"],["9e40","曄暸曖曚曠昿曦曩曰曵曷朏朖朞朦朧霸朮朿朶杁朸朷杆杞杠杙杣杤枉杰枩杼杪枌枋枦枡枅枷柯枴柬枳柩枸柤柞柝柢柮枹柎柆柧檜栞框栩桀桍栲桎"],["9e80","梳栫桙档桷桿梟梏梭梔條梛梃檮梹桴梵梠梺椏梍桾椁棊椈棘椢椦棡椌棍棔棧棕椶椒椄棗棣椥棹棠棯椨椪椚椣椡棆楹楷楜楸楫楔楾楮椹楴椽楙椰楡楞楝榁楪榲榮槐榿槁槓榾槎寨槊槝榻槃榧樮榑榠榜榕榴槞槨樂樛槿權槹槲槧樅榱樞槭樔槫樊樒櫁樣樓橄樌橲樶橸橇橢橙橦橈樸樢檐檍檠檄檢檣"],["9f40","檗蘗檻櫃櫂檸檳檬櫞櫑櫟檪櫚櫪櫻欅蘖櫺欒欖鬱欟欸欷盜欹飮歇歃歉歐歙歔歛歟歡歸歹歿殀殄殃殍殘殕殞殤殪殫殯殲殱殳殷殼毆毋毓毟毬毫毳毯"],["9f80","麾氈氓气氛氤氣汞汕汢汪沂沍沚沁沛汾汨汳沒沐泄泱泓沽泗泅泝沮沱沾沺泛泯泙泪洟衍洶洫洽洸洙洵洳洒洌浣涓浤浚浹浙涎涕濤涅淹渕渊涵淇淦涸淆淬淞淌淨淒淅淺淙淤淕淪淮渭湮渮渙湲湟渾渣湫渫湶湍渟湃渺湎渤滿渝游溂溪溘滉溷滓溽溯滄溲滔滕溏溥滂溟潁漑灌滬滸滾漿滲漱滯漲滌"],["e040","漾漓滷澆潺潸澁澀潯潛濳潭澂潼潘澎澑濂潦澳澣澡澤澹濆澪濟濕濬濔濘濱濮濛瀉瀋濺瀑瀁瀏濾瀛瀚潴瀝瀘瀟瀰瀾瀲灑灣炙炒炯烱炬炸炳炮烟烋烝"],["e080","烙焉烽焜焙煥煕熈煦煢煌煖煬熏燻熄熕熨熬燗熹熾燒燉燔燎燠燬燧燵燼燹燿爍爐爛爨爭爬爰爲爻爼爿牀牆牋牘牴牾犂犁犇犒犖犢犧犹犲狃狆狄狎狒狢狠狡狹狷倏猗猊猜猖猝猴猯猩猥猾獎獏默獗獪獨獰獸獵獻獺珈玳珎玻珀珥珮珞璢琅瑯琥珸琲琺瑕琿瑟瑙瑁瑜瑩瑰瑣瑪瑶瑾璋璞璧瓊瓏瓔珱"],["e140","瓠瓣瓧瓩瓮瓲瓰瓱瓸瓷甄甃甅甌甎甍甕甓甞甦甬甼畄畍畊畉畛畆畚畩畤畧畫畭畸當疆疇畴疊疉疂疔疚疝疥疣痂疳痃疵疽疸疼疱痍痊痒痙痣痞痾痿"],["e180","痼瘁痰痺痲痳瘋瘍瘉瘟瘧瘠瘡瘢瘤瘴瘰瘻癇癈癆癜癘癡癢癨癩癪癧癬癰癲癶癸發皀皃皈皋皎皖皓皙皚皰皴皸皹皺盂盍盖盒盞盡盥盧盪蘯盻眈眇眄眩眤眞眥眦眛眷眸睇睚睨睫睛睥睿睾睹瞎瞋瞑瞠瞞瞰瞶瞹瞿瞼瞽瞻矇矍矗矚矜矣矮矼砌砒礦砠礪硅碎硴碆硼碚碌碣碵碪碯磑磆磋磔碾碼磅磊磬"],["e240","磧磚磽磴礇礒礑礙礬礫祀祠祗祟祚祕祓祺祿禊禝禧齋禪禮禳禹禺秉秕秧秬秡秣稈稍稘稙稠稟禀稱稻稾稷穃穗穉穡穢穩龝穰穹穽窈窗窕窘窖窩竈窰"],["e280","窶竅竄窿邃竇竊竍竏竕竓站竚竝竡竢竦竭竰笂笏笊笆笳笘笙笞笵笨笶筐筺笄筍笋筌筅筵筥筴筧筰筱筬筮箝箘箟箍箜箚箋箒箏筝箙篋篁篌篏箴篆篝篩簑簔篦篥籠簀簇簓篳篷簗簍篶簣簧簪簟簷簫簽籌籃籔籏籀籐籘籟籤籖籥籬籵粃粐粤粭粢粫粡粨粳粲粱粮粹粽糀糅糂糘糒糜糢鬻糯糲糴糶糺紆"],["e340","紂紜紕紊絅絋紮紲紿紵絆絳絖絎絲絨絮絏絣經綉絛綏絽綛綺綮綣綵緇綽綫總綢綯緜綸綟綰緘緝緤緞緻緲緡縅縊縣縡縒縱縟縉縋縢繆繦縻縵縹繃縷"],["e380","縲縺繧繝繖繞繙繚繹繪繩繼繻纃緕繽辮繿纈纉續纒纐纓纔纖纎纛纜缸缺罅罌罍罎罐网罕罔罘罟罠罨罩罧罸羂羆羃羈羇羌羔羞羝羚羣羯羲羹羮羶羸譱翅翆翊翕翔翡翦翩翳翹飜耆耄耋耒耘耙耜耡耨耿耻聊聆聒聘聚聟聢聨聳聲聰聶聹聽聿肄肆肅肛肓肚肭冐肬胛胥胙胝胄胚胖脉胯胱脛脩脣脯腋"],["e440","隋腆脾腓腑胼腱腮腥腦腴膃膈膊膀膂膠膕膤膣腟膓膩膰膵膾膸膽臀臂膺臉臍臑臙臘臈臚臟臠臧臺臻臾舁舂舅與舊舍舐舖舩舫舸舳艀艙艘艝艚艟艤"],["e480","艢艨艪艫舮艱艷艸艾芍芒芫芟芻芬苡苣苟苒苴苳苺莓范苻苹苞茆苜茉苙茵茴茖茲茱荀茹荐荅茯茫茗茘莅莚莪莟莢莖茣莎莇莊荼莵荳荵莠莉莨菴萓菫菎菽萃菘萋菁菷萇菠菲萍萢萠莽萸蔆菻葭萪萼蕚蒄葷葫蒭葮蒂葩葆萬葯葹萵蓊葢蒹蒿蒟蓙蓍蒻蓚蓐蓁蓆蓖蒡蔡蓿蓴蔗蔘蔬蔟蔕蔔蓼蕀蕣蕘蕈"],["e540","蕁蘂蕋蕕薀薤薈薑薊薨蕭薔薛藪薇薜蕷蕾薐藉薺藏薹藐藕藝藥藜藹蘊蘓蘋藾藺蘆蘢蘚蘰蘿虍乕虔號虧虱蚓蚣蚩蚪蚋蚌蚶蚯蛄蛆蚰蛉蠣蚫蛔蛞蛩蛬"],["e580","蛟蛛蛯蜒蜆蜈蜀蜃蛻蜑蜉蜍蛹蜊蜴蜿蜷蜻蜥蜩蜚蝠蝟蝸蝌蝎蝴蝗蝨蝮蝙蝓蝣蝪蠅螢螟螂螯蟋螽蟀蟐雖螫蟄螳蟇蟆螻蟯蟲蟠蠏蠍蟾蟶蟷蠎蟒蠑蠖蠕蠢蠡蠱蠶蠹蠧蠻衄衂衒衙衞衢衫袁衾袞衵衽袵衲袂袗袒袮袙袢袍袤袰袿袱裃裄裔裘裙裝裹褂裼裴裨裲褄褌褊褓襃褞褥褪褫襁襄褻褶褸襌褝襠襞"],["e640","襦襤襭襪襯襴襷襾覃覈覊覓覘覡覩覦覬覯覲覺覽覿觀觚觜觝觧觴觸訃訖訐訌訛訝訥訶詁詛詒詆詈詼詭詬詢誅誂誄誨誡誑誥誦誚誣諄諍諂諚諫諳諧"],["e680","諤諱謔諠諢諷諞諛謌謇謚諡謖謐謗謠謳鞫謦謫謾謨譁譌譏譎證譖譛譚譫譟譬譯譴譽讀讌讎讒讓讖讙讚谺豁谿豈豌豎豐豕豢豬豸豺貂貉貅貊貍貎貔豼貘戝貭貪貽貲貳貮貶賈賁賤賣賚賽賺賻贄贅贊贇贏贍贐齎贓賍贔贖赧赭赱赳趁趙跂趾趺跏跚跖跌跛跋跪跫跟跣跼踈踉跿踝踞踐踟蹂踵踰踴蹊"],["e740","蹇蹉蹌蹐蹈蹙蹤蹠踪蹣蹕蹶蹲蹼躁躇躅躄躋躊躓躑躔躙躪躡躬躰軆躱躾軅軈軋軛軣軼軻軫軾輊輅輕輒輙輓輜輟輛輌輦輳輻輹轅轂輾轌轉轆轎轗轜"],["e780","轢轣轤辜辟辣辭辯辷迚迥迢迪迯邇迴逅迹迺逑逕逡逍逞逖逋逧逶逵逹迸遏遐遑遒逎遉逾遖遘遞遨遯遶隨遲邂遽邁邀邊邉邏邨邯邱邵郢郤扈郛鄂鄒鄙鄲鄰酊酖酘酣酥酩酳酲醋醉醂醢醫醯醪醵醴醺釀釁釉釋釐釖釟釡釛釼釵釶鈞釿鈔鈬鈕鈑鉞鉗鉅鉉鉤鉈銕鈿鉋鉐銜銖銓銛鉚鋏銹銷鋩錏鋺鍄錮"],["e840","錙錢錚錣錺錵錻鍜鍠鍼鍮鍖鎰鎬鎭鎔鎹鏖鏗鏨鏥鏘鏃鏝鏐鏈鏤鐚鐔鐓鐃鐇鐐鐶鐫鐵鐡鐺鑁鑒鑄鑛鑠鑢鑞鑪鈩鑰鑵鑷鑽鑚鑼鑾钁鑿閂閇閊閔閖閘閙"],["e880","閠閨閧閭閼閻閹閾闊濶闃闍闌闕闔闖關闡闥闢阡阨阮阯陂陌陏陋陷陜陞陝陟陦陲陬隍隘隕隗險隧隱隲隰隴隶隸隹雎雋雉雍襍雜霍雕雹霄霆霈霓霎霑霏霖霙霤霪霰霹霽霾靄靆靈靂靉靜靠靤靦靨勒靫靱靹鞅靼鞁靺鞆鞋鞏鞐鞜鞨鞦鞣鞳鞴韃韆韈韋韜韭齏韲竟韶韵頏頌頸頤頡頷頽顆顏顋顫顯顰"],["e940","顱顴顳颪颯颱颶飄飃飆飩飫餃餉餒餔餘餡餝餞餤餠餬餮餽餾饂饉饅饐饋饑饒饌饕馗馘馥馭馮馼駟駛駝駘駑駭駮駱駲駻駸騁騏騅駢騙騫騷驅驂驀驃"],["e980","騾驕驍驛驗驟驢驥驤驩驫驪骭骰骼髀髏髑髓體髞髟髢髣髦髯髫髮髴髱髷髻鬆鬘鬚鬟鬢鬣鬥鬧鬨鬩鬪鬮鬯鬲魄魃魏魍魎魑魘魴鮓鮃鮑鮖鮗鮟鮠鮨鮴鯀鯊鮹鯆鯏鯑鯒鯣鯢鯤鯔鯡鰺鯲鯱鯰鰕鰔鰉鰓鰌鰆鰈鰒鰊鰄鰮鰛鰥鰤鰡鰰鱇鰲鱆鰾鱚鱠鱧鱶鱸鳧鳬鳰鴉鴈鳫鴃鴆鴪鴦鶯鴣鴟鵄鴕鴒鵁鴿鴾鵆鵈"],["ea40","鵝鵞鵤鵑鵐鵙鵲鶉鶇鶫鵯鵺鶚鶤鶩鶲鷄鷁鶻鶸鶺鷆鷏鷂鷙鷓鷸鷦鷭鷯鷽鸚鸛鸞鹵鹹鹽麁麈麋麌麒麕麑麝麥麩麸麪麭靡黌黎黏黐黔黜點黝黠黥黨黯"],["ea80","黴黶黷黹黻黼黽鼇鼈皷鼕鼡鼬鼾齊齒齔齣齟齠齡齦齧齬齪齷齲齶龕龜龠堯槇遙瑤凜熙"],["ed40","纊褜鍈銈蓜俉炻昱棈鋹曻彅丨仡仼伀伃伹佖侒侊侚侔俍偀倢俿倞偆偰偂傔僴僘兊兤冝冾凬刕劜劦勀勛匀匇匤卲厓厲叝﨎咜咊咩哿喆坙坥垬埈埇﨏"],["ed80","塚增墲夋奓奛奝奣妤妺孖寀甯寘寬尞岦岺峵崧嵓﨑嵂嵭嶸嶹巐弡弴彧德忞恝悅悊惞惕愠惲愑愷愰憘戓抦揵摠撝擎敎昀昕昻昉昮昞昤晥晗晙晴晳暙暠暲暿曺朎朗杦枻桒柀栁桄棏﨓楨﨔榘槢樰橫橆橳橾櫢櫤毖氿汜沆汯泚洄涇浯涖涬淏淸淲淼渹湜渧渼溿澈澵濵瀅瀇瀨炅炫焏焄煜煆煇凞燁燾犱"],["ee40","犾猤猪獷玽珉珖珣珒琇珵琦琪琩琮瑢璉璟甁畯皂皜皞皛皦益睆劯砡硎硤硺礰礼神祥禔福禛竑竧靖竫箞精絈絜綷綠緖繒罇羡羽茁荢荿菇菶葈蒴蕓蕙"],["ee80","蕫﨟薰蘒﨡蠇裵訒訷詹誧誾諟諸諶譓譿賰賴贒赶﨣軏﨤逸遧郞都鄕鄧釚釗釞釭釮釤釥鈆鈐鈊鈺鉀鈼鉎鉙鉑鈹鉧銧鉷鉸鋧鋗鋙鋐﨧鋕鋠鋓錥錡鋻﨨錞鋿錝錂鍰鍗鎤鏆鏞鏸鐱鑅鑈閒隆﨩隝隯霳霻靃靍靏靑靕顗顥飯飼餧館馞驎髙髜魵魲鮏鮱鮻鰀鵰鵫鶴鸙黑"],["eeef","ⅰ",9,"￢￤＇＂"],["f040","",62],["f080","",124],["f140","",62],["f180","",124],["f240","",62],["f280","",124],["f340","",62],["f380","",124],["f440","",62],["f480","",124],["f540","",62],["f580","",124],["f640","",62],["f680","",124],["f740","",62],["f780","",124],["f840","",62],["f880","",124],["f940",""],["fa40","ⅰ",9,"Ⅰ",9,"￢￤＇＂㈱№℡∵纊褜鍈銈蓜俉炻昱棈鋹曻彅丨仡仼伀伃伹佖侒侊侚侔俍偀倢俿倞偆偰偂傔僴僘兊"],["fa80","兤冝冾凬刕劜劦勀勛匀匇匤卲厓厲叝﨎咜咊咩哿喆坙坥垬埈埇﨏塚增墲夋奓奛奝奣妤妺孖寀甯寘寬尞岦岺峵崧嵓﨑嵂嵭嶸嶹巐弡弴彧德忞恝悅悊惞惕愠惲愑愷愰憘戓抦揵摠撝擎敎昀昕昻昉昮昞昤晥晗晙晴晳暙暠暲暿曺朎朗杦枻桒柀栁桄棏﨓楨﨔榘槢樰橫橆橳橾櫢櫤毖氿汜沆汯泚洄涇浯"],["fb40","涖涬淏淸淲淼渹湜渧渼溿澈澵濵瀅瀇瀨炅炫焏焄煜煆煇凞燁燾犱犾猤猪獷玽珉珖珣珒琇珵琦琪琩琮瑢璉璟甁畯皂皜皞皛皦益睆劯砡硎硤硺礰礼神"],["fb80","祥禔福禛竑竧靖竫箞精絈絜綷綠緖繒罇羡羽茁荢荿菇菶葈蒴蕓蕙蕫﨟薰蘒﨡蠇裵訒訷詹誧誾諟諸諶譓譿賰賴贒赶﨣軏﨤逸遧郞都鄕鄧釚釗釞釭釮釤釥鈆鈐鈊鈺鉀鈼鉎鉙鉑鈹鉧銧鉷鉸鋧鋗鋙鋐﨧鋕鋠鋓錥錡鋻﨨錞鋿錝錂鍰鍗鎤鏆鏞鏸鐱鑅鑈閒隆﨩隝隯霳霻靃靍靏靑靕顗顥飯飼餧館馞驎髙"],["fc40","髜魵魲鮏鮱鮻鰀鵰鵫鶴鸙黑"]]');
    },
    "../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json": function(module) {
        "use strict";
        module.exports = JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');
    },
    "../node_modules/.pnpm/mime@1.6.0/node_modules/mime/types.json": function(module) {
        "use strict";
        module.exports = JSON.parse('{"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomsvc+xml":["atomsvc"],"application/bdoc":["bdoc"],"application/ccxml+xml":["ccxml"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["ecma"],"application/emma+xml":["emma"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/font-tdpfr":["pfr"],"application/font-woff":[],"application/font-woff2":[],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/patch-ops-error+xml":["xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/prs.cww":["cww"],"application/pskc+xml":["pskcxml"],"application/raml+yaml":["raml"],"application/rdf+xml":["rdf"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/vnd.3gpp.pic-bw-large":["plb"],"application/vnd.3gpp.pic-bw-small":["psb"],"application/vnd.3gpp.pic-bw-var":["pvb"],"application/vnd.3gpp2.tcap":["tcap"],"application/vnd.3m.post-it-notes":["pwn"],"application/vnd.accpac.simply.aso":["aso"],"application/vnd.accpac.simply.imp":["imp"],"application/vnd.acucobol":["acu"],"application/vnd.acucorp":["atc","acutc"],"application/vnd.adobe.air-application-installer-package+zip":["air"],"application/vnd.adobe.formscentral.fcdt":["fcdt"],"application/vnd.adobe.fxp":["fxp","fxpl"],"application/vnd.adobe.xdp+xml":["xdp"],"application/vnd.adobe.xfdf":["xfdf"],"application/vnd.ahead.space":["ahead"],"application/vnd.airzip.filesecure.azf":["azf"],"application/vnd.airzip.filesecure.azs":["azs"],"application/vnd.amazon.ebook":["azw"],"application/vnd.americandynamics.acc":["acc"],"application/vnd.amiga.ami":["ami"],"application/vnd.android.package-archive":["apk"],"application/vnd.anser-web-certificate-issue-initiation":["cii"],"application/vnd.anser-web-funds-transfer-initiation":["fti"],"application/vnd.antix.game-component":["atx"],"application/vnd.apple.installer+xml":["mpkg"],"application/vnd.apple.mpegurl":["m3u8"],"application/vnd.apple.pkpass":["pkpass"],"application/vnd.aristanetworks.swi":["swi"],"application/vnd.astraea-software.iota":["iota"],"application/vnd.audiograph":["aep"],"application/vnd.blueice.multipass":["mpm"],"application/vnd.bmi":["bmi"],"application/vnd.businessobjects":["rep"],"application/vnd.chemdraw+xml":["cdxml"],"application/vnd.chipnuts.karaoke-mmd":["mmd"],"application/vnd.cinderella":["cdy"],"application/vnd.claymore":["cla"],"application/vnd.cloanto.rp9":["rp9"],"application/vnd.clonk.c4group":["c4g","c4d","c4f","c4p","c4u"],"application/vnd.cluetrust.cartomobile-config":["c11amc"],"application/vnd.cluetrust.cartomobile-config-pkg":["c11amz"],"application/vnd.commonspace":["csp"],"application/vnd.contact.cmsg":["cdbcmsg"],"application/vnd.cosmocaller":["cmc"],"application/vnd.crick.clicker":["clkx"],"application/vnd.crick.clicker.keyboard":["clkk"],"application/vnd.crick.clicker.palette":["clkp"],"application/vnd.crick.clicker.template":["clkt"],"application/vnd.crick.clicker.wordbank":["clkw"],"application/vnd.criticaltools.wbs+xml":["wbs"],"application/vnd.ctc-posml":["pml"],"application/vnd.cups-ppd":["ppd"],"application/vnd.curl.car":["car"],"application/vnd.curl.pcurl":["pcurl"],"application/vnd.dart":["dart"],"application/vnd.data-vision.rdz":["rdz"],"application/vnd.dece.data":["uvf","uvvf","uvd","uvvd"],"application/vnd.dece.ttml+xml":["uvt","uvvt"],"application/vnd.dece.unspecified":["uvx","uvvx"],"application/vnd.dece.zip":["uvz","uvvz"],"application/vnd.denovo.fcselayout-link":["fe_launch"],"application/vnd.dna":["dna"],"application/vnd.dolby.mlp":["mlp"],"application/vnd.dpgraph":["dpg"],"application/vnd.dreamfactory":["dfac"],"application/vnd.ds-keypoint":["kpxx"],"application/vnd.dvb.ait":["ait"],"application/vnd.dvb.service":["svc"],"application/vnd.dynageo":["geo"],"application/vnd.ecowin.chart":["mag"],"application/vnd.enliven":["nml"],"application/vnd.epson.esf":["esf"],"application/vnd.epson.msf":["msf"],"application/vnd.epson.quickanime":["qam"],"application/vnd.epson.salt":["slt"],"application/vnd.epson.ssf":["ssf"],"application/vnd.eszigno3+xml":["es3","et3"],"application/vnd.ezpix-album":["ez2"],"application/vnd.ezpix-package":["ez3"],"application/vnd.fdf":["fdf"],"application/vnd.fdsn.mseed":["mseed"],"application/vnd.fdsn.seed":["seed","dataless"],"application/vnd.flographit":["gph"],"application/vnd.fluxtime.clip":["ftc"],"application/vnd.framemaker":["fm","frame","maker","book"],"application/vnd.frogans.fnc":["fnc"],"application/vnd.frogans.ltf":["ltf"],"application/vnd.fsc.weblaunch":["fsc"],"application/vnd.fujitsu.oasys":["oas"],"application/vnd.fujitsu.oasys2":["oa2"],"application/vnd.fujitsu.oasys3":["oa3"],"application/vnd.fujitsu.oasysgp":["fg5"],"application/vnd.fujitsu.oasysprs":["bh2"],"application/vnd.fujixerox.ddd":["ddd"],"application/vnd.fujixerox.docuworks":["xdw"],"application/vnd.fujixerox.docuworks.binder":["xbd"],"application/vnd.fuzzysheet":["fzs"],"application/vnd.genomatix.tuxedo":["txd"],"application/vnd.geogebra.file":["ggb"],"application/vnd.geogebra.tool":["ggt"],"application/vnd.geometry-explorer":["gex","gre"],"application/vnd.geonext":["gxt"],"application/vnd.geoplan":["g2w"],"application/vnd.geospace":["g3w"],"application/vnd.gmx":["gmx"],"application/vnd.google-apps.document":["gdoc"],"application/vnd.google-apps.presentation":["gslides"],"application/vnd.google-apps.spreadsheet":["gsheet"],"application/vnd.google-earth.kml+xml":["kml"],"application/vnd.google-earth.kmz":["kmz"],"application/vnd.grafeq":["gqf","gqs"],"application/vnd.groove-account":["gac"],"application/vnd.groove-help":["ghf"],"application/vnd.groove-identity-message":["gim"],"application/vnd.groove-injector":["grv"],"application/vnd.groove-tool-message":["gtm"],"application/vnd.groove-tool-template":["tpl"],"application/vnd.groove-vcard":["vcg"],"application/vnd.hal+xml":["hal"],"application/vnd.handheld-entertainment+xml":["zmm"],"application/vnd.hbci":["hbci"],"application/vnd.hhe.lesson-player":["les"],"application/vnd.hp-hpgl":["hpgl"],"application/vnd.hp-hpid":["hpid"],"application/vnd.hp-hps":["hps"],"application/vnd.hp-jlyt":["jlt"],"application/vnd.hp-pcl":["pcl"],"application/vnd.hp-pclxl":["pclxl"],"application/vnd.hydrostatix.sof-data":["sfd-hdstx"],"application/vnd.ibm.minipay":["mpy"],"application/vnd.ibm.modcap":["afp","listafp","list3820"],"application/vnd.ibm.rights-management":["irm"],"application/vnd.ibm.secure-container":["sc"],"application/vnd.iccprofile":["icc","icm"],"application/vnd.igloader":["igl"],"application/vnd.immervision-ivp":["ivp"],"application/vnd.immervision-ivu":["ivu"],"application/vnd.insors.igm":["igm"],"application/vnd.intercon.formnet":["xpw","xpx"],"application/vnd.intergeo":["i2g"],"application/vnd.intu.qbo":["qbo"],"application/vnd.intu.qfx":["qfx"],"application/vnd.ipunplugged.rcprofile":["rcprofile"],"application/vnd.irepository.package+xml":["irp"],"application/vnd.is-xpr":["xpr"],"application/vnd.isac.fcs":["fcs"],"application/vnd.jam":["jam"],"application/vnd.jcp.javame.midlet-rms":["rms"],"application/vnd.jisp":["jisp"],"application/vnd.joost.joda-archive":["joda"],"application/vnd.kahootz":["ktz","ktr"],"application/vnd.kde.karbon":["karbon"],"application/vnd.kde.kchart":["chrt"],"application/vnd.kde.kformula":["kfo"],"application/vnd.kde.kivio":["flw"],"application/vnd.kde.kontour":["kon"],"application/vnd.kde.kpresenter":["kpr","kpt"],"application/vnd.kde.kspread":["ksp"],"application/vnd.kde.kword":["kwd","kwt"],"application/vnd.kenameaapp":["htke"],"application/vnd.kidspiration":["kia"],"application/vnd.kinar":["kne","knp"],"application/vnd.koan":["skp","skd","skt","skm"],"application/vnd.kodak-descriptor":["sse"],"application/vnd.las.las+xml":["lasxml"],"application/vnd.llamagraphics.life-balance.desktop":["lbd"],"application/vnd.llamagraphics.life-balance.exchange+xml":["lbe"],"application/vnd.lotus-1-2-3":["123"],"application/vnd.lotus-approach":["apr"],"application/vnd.lotus-freelance":["pre"],"application/vnd.lotus-notes":["nsf"],"application/vnd.lotus-organizer":["org"],"application/vnd.lotus-screencam":["scm"],"application/vnd.lotus-wordpro":["lwp"],"application/vnd.macports.portpkg":["portpkg"],"application/vnd.mcd":["mcd"],"application/vnd.medcalcdata":["mc1"],"application/vnd.mediastation.cdkey":["cdkey"],"application/vnd.mfer":["mwf"],"application/vnd.mfmp":["mfm"],"application/vnd.micrografx.flo":["flo"],"application/vnd.micrografx.igx":["igx"],"application/vnd.mif":["mif"],"application/vnd.mobius.daf":["daf"],"application/vnd.mobius.dis":["dis"],"application/vnd.mobius.mbk":["mbk"],"application/vnd.mobius.mqy":["mqy"],"application/vnd.mobius.msl":["msl"],"application/vnd.mobius.plc":["plc"],"application/vnd.mobius.txf":["txf"],"application/vnd.mophun.application":["mpn"],"application/vnd.mophun.certificate":["mpc"],"application/vnd.mozilla.xul+xml":["xul"],"application/vnd.ms-artgalry":["cil"],"application/vnd.ms-cab-compressed":["cab"],"application/vnd.ms-excel":["xls","xlm","xla","xlc","xlt","xlw"],"application/vnd.ms-excel.addin.macroenabled.12":["xlam"],"application/vnd.ms-excel.sheet.binary.macroenabled.12":["xlsb"],"application/vnd.ms-excel.sheet.macroenabled.12":["xlsm"],"application/vnd.ms-excel.template.macroenabled.12":["xltm"],"application/vnd.ms-fontobject":["eot"],"application/vnd.ms-htmlhelp":["chm"],"application/vnd.ms-ims":["ims"],"application/vnd.ms-lrm":["lrm"],"application/vnd.ms-officetheme":["thmx"],"application/vnd.ms-outlook":["msg"],"application/vnd.ms-pki.seccat":["cat"],"application/vnd.ms-pki.stl":["stl"],"application/vnd.ms-powerpoint":["ppt","pps","pot"],"application/vnd.ms-powerpoint.addin.macroenabled.12":["ppam"],"application/vnd.ms-powerpoint.presentation.macroenabled.12":["pptm"],"application/vnd.ms-powerpoint.slide.macroenabled.12":["sldm"],"application/vnd.ms-powerpoint.slideshow.macroenabled.12":["ppsm"],"application/vnd.ms-powerpoint.template.macroenabled.12":["potm"],"application/vnd.ms-project":["mpp","mpt"],"application/vnd.ms-word.document.macroenabled.12":["docm"],"application/vnd.ms-word.template.macroenabled.12":["dotm"],"application/vnd.ms-works":["wps","wks","wcm","wdb"],"application/vnd.ms-wpl":["wpl"],"application/vnd.ms-xpsdocument":["xps"],"application/vnd.mseq":["mseq"],"application/vnd.musician":["mus"],"application/vnd.muvee.style":["msty"],"application/vnd.mynfc":["taglet"],"application/vnd.neurolanguage.nlu":["nlu"],"application/vnd.nitf":["ntf","nitf"],"application/vnd.noblenet-directory":["nnd"],"application/vnd.noblenet-sealer":["nns"],"application/vnd.noblenet-web":["nnw"],"application/vnd.nokia.n-gage.data":["ngdat"],"application/vnd.nokia.n-gage.symbian.install":["n-gage"],"application/vnd.nokia.radio-preset":["rpst"],"application/vnd.nokia.radio-presets":["rpss"],"application/vnd.novadigm.edm":["edm"],"application/vnd.novadigm.edx":["edx"],"application/vnd.novadigm.ext":["ext"],"application/vnd.oasis.opendocument.chart":["odc"],"application/vnd.oasis.opendocument.chart-template":["otc"],"application/vnd.oasis.opendocument.database":["odb"],"application/vnd.oasis.opendocument.formula":["odf"],"application/vnd.oasis.opendocument.formula-template":["odft"],"application/vnd.oasis.opendocument.graphics":["odg"],"application/vnd.oasis.opendocument.graphics-template":["otg"],"application/vnd.oasis.opendocument.image":["odi"],"application/vnd.oasis.opendocument.image-template":["oti"],"application/vnd.oasis.opendocument.presentation":["odp"],"application/vnd.oasis.opendocument.presentation-template":["otp"],"application/vnd.oasis.opendocument.spreadsheet":["ods"],"application/vnd.oasis.opendocument.spreadsheet-template":["ots"],"application/vnd.oasis.opendocument.text":["odt"],"application/vnd.oasis.opendocument.text-master":["odm"],"application/vnd.oasis.opendocument.text-template":["ott"],"application/vnd.oasis.opendocument.text-web":["oth"],"application/vnd.olpc-sugar":["xo"],"application/vnd.oma.dd2+xml":["dd2"],"application/vnd.openofficeorg.extension":["oxt"],"application/vnd.openxmlformats-officedocument.presentationml.presentation":["pptx"],"application/vnd.openxmlformats-officedocument.presentationml.slide":["sldx"],"application/vnd.openxmlformats-officedocument.presentationml.slideshow":["ppsx"],"application/vnd.openxmlformats-officedocument.presentationml.template":["potx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":["xlsx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.template":["xltx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.document":["docx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.template":["dotx"],"application/vnd.osgeo.mapguide.package":["mgp"],"application/vnd.osgi.dp":["dp"],"application/vnd.osgi.subsystem":["esa"],"application/vnd.palm":["pdb","pqa","oprc"],"application/vnd.pawaafile":["paw"],"application/vnd.pg.format":["str"],"application/vnd.pg.osasli":["ei6"],"application/vnd.picsel":["efif"],"application/vnd.pmi.widget":["wg"],"application/vnd.pocketlearn":["plf"],"application/vnd.powerbuilder6":["pbd"],"application/vnd.previewsystems.box":["box"],"application/vnd.proteus.magazine":["mgz"],"application/vnd.publishare-delta-tree":["qps"],"application/vnd.pvi.ptid1":["ptid"],"application/vnd.quark.quarkxpress":["qxd","qxt","qwd","qwt","qxl","qxb"],"application/vnd.realvnc.bed":["bed"],"application/vnd.recordare.musicxml":["mxl"],"application/vnd.recordare.musicxml+xml":["musicxml"],"application/vnd.rig.cryptonote":["cryptonote"],"application/vnd.rim.cod":["cod"],"application/vnd.rn-realmedia":["rm"],"application/vnd.rn-realmedia-vbr":["rmvb"],"application/vnd.route66.link66+xml":["link66"],"application/vnd.sailingtracker.track":["st"],"application/vnd.seemail":["see"],"application/vnd.sema":["sema"],"application/vnd.semd":["semd"],"application/vnd.semf":["semf"],"application/vnd.shana.informed.formdata":["ifm"],"application/vnd.shana.informed.formtemplate":["itp"],"application/vnd.shana.informed.interchange":["iif"],"application/vnd.shana.informed.package":["ipk"],"application/vnd.simtech-mindmapper":["twd","twds"],"application/vnd.smaf":["mmf"],"application/vnd.smart.teacher":["teacher"],"application/vnd.solent.sdkm+xml":["sdkm","sdkd"],"application/vnd.spotfire.dxp":["dxp"],"application/vnd.spotfire.sfs":["sfs"],"application/vnd.stardivision.calc":["sdc"],"application/vnd.stardivision.draw":["sda"],"application/vnd.stardivision.impress":["sdd"],"application/vnd.stardivision.math":["smf"],"application/vnd.stardivision.writer":["sdw","vor"],"application/vnd.stardivision.writer-global":["sgl"],"application/vnd.stepmania.package":["smzip"],"application/vnd.stepmania.stepchart":["sm"],"application/vnd.sun.wadl+xml":["wadl"],"application/vnd.sun.xml.calc":["sxc"],"application/vnd.sun.xml.calc.template":["stc"],"application/vnd.sun.xml.draw":["sxd"],"application/vnd.sun.xml.draw.template":["std"],"application/vnd.sun.xml.impress":["sxi"],"application/vnd.sun.xml.impress.template":["sti"],"application/vnd.sun.xml.math":["sxm"],"application/vnd.sun.xml.writer":["sxw"],"application/vnd.sun.xml.writer.global":["sxg"],"application/vnd.sun.xml.writer.template":["stw"],"application/vnd.sus-calendar":["sus","susp"],"application/vnd.svd":["svd"],"application/vnd.symbian.install":["sis","sisx"],"application/vnd.syncml+xml":["xsm"],"application/vnd.syncml.dm+wbxml":["bdm"],"application/vnd.syncml.dm+xml":["xdm"],"application/vnd.tao.intent-module-archive":["tao"],"application/vnd.tcpdump.pcap":["pcap","cap","dmp"],"application/vnd.tmobile-livetv":["tmo"],"application/vnd.trid.tpt":["tpt"],"application/vnd.triscape.mxs":["mxs"],"application/vnd.trueapp":["tra"],"application/vnd.ufdl":["ufd","ufdl"],"application/vnd.uiq.theme":["utz"],"application/vnd.umajin":["umj"],"application/vnd.unity":["unityweb"],"application/vnd.uoml+xml":["uoml"],"application/vnd.vcx":["vcx"],"application/vnd.visio":["vsd","vst","vss","vsw"],"application/vnd.visionary":["vis"],"application/vnd.vsf":["vsf"],"application/vnd.wap.wbxml":["wbxml"],"application/vnd.wap.wmlc":["wmlc"],"application/vnd.wap.wmlscriptc":["wmlsc"],"application/vnd.webturbo":["wtb"],"application/vnd.wolfram.player":["nbp"],"application/vnd.wordperfect":["wpd"],"application/vnd.wqd":["wqd"],"application/vnd.wt.stf":["stf"],"application/vnd.xara":["xar"],"application/vnd.xfdl":["xfdl"],"application/vnd.yamaha.hv-dic":["hvd"],"application/vnd.yamaha.hv-script":["hvs"],"application/vnd.yamaha.hv-voice":["hvp"],"application/vnd.yamaha.openscoreformat":["osf"],"application/vnd.yamaha.openscoreformat.osfpvg+xml":["osfpvg"],"application/vnd.yamaha.smaf-audio":["saf"],"application/vnd.yamaha.smaf-phrase":["spf"],"application/vnd.yellowriver-custom-menu":["cmp"],"application/vnd.zul":["zir","zirz"],"application/vnd.zzazz.deck+xml":["zaz"],"application/voicexml+xml":["vxml"],"application/wasm":["wasm"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/x-7z-compressed":["7z"],"application/x-abiword":["abw"],"application/x-ace-compressed":["ace"],"application/x-apple-diskimage":[],"application/x-arj":["arj"],"application/x-authorware-bin":["aab","x32","u32","vox"],"application/x-authorware-map":["aam"],"application/x-authorware-seg":["aas"],"application/x-bcpio":["bcpio"],"application/x-bdoc":[],"application/x-bittorrent":["torrent"],"application/x-blorb":["blb","blorb"],"application/x-bzip":["bz"],"application/x-bzip2":["bz2","boz"],"application/x-cbr":["cbr","cba","cbt","cbz","cb7"],"application/x-cdlink":["vcd"],"application/x-cfs-compressed":["cfs"],"application/x-chat":["chat"],"application/x-chess-pgn":["pgn"],"application/x-chrome-extension":["crx"],"application/x-cocoa":["cco"],"application/x-conference":["nsc"],"application/x-cpio":["cpio"],"application/x-csh":["csh"],"application/x-debian-package":["udeb"],"application/x-dgc-compressed":["dgc"],"application/x-director":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"],"application/x-doom":["wad"],"application/x-dtbncx+xml":["ncx"],"application/x-dtbook+xml":["dtb"],"application/x-dtbresource+xml":["res"],"application/x-dvi":["dvi"],"application/x-envoy":["evy"],"application/x-eva":["eva"],"application/x-font-bdf":["bdf"],"application/x-font-ghostscript":["gsf"],"application/x-font-linux-psf":["psf"],"application/x-font-pcf":["pcf"],"application/x-font-snf":["snf"],"application/x-font-type1":["pfa","pfb","pfm","afm"],"application/x-freearc":["arc"],"application/x-futuresplash":["spl"],"application/x-gca-compressed":["gca"],"application/x-glulx":["ulx"],"application/x-gnumeric":["gnumeric"],"application/x-gramps-xml":["gramps"],"application/x-gtar":["gtar"],"application/x-hdf":["hdf"],"application/x-httpd-php":["php"],"application/x-install-instructions":["install"],"application/x-iso9660-image":[],"application/x-java-archive-diff":["jardiff"],"application/x-java-jnlp-file":["jnlp"],"application/x-latex":["latex"],"application/x-lua-bytecode":["luac"],"application/x-lzh-compressed":["lzh","lha"],"application/x-makeself":["run"],"application/x-mie":["mie"],"application/x-mobipocket-ebook":["prc","mobi"],"application/x-ms-application":["application"],"application/x-ms-shortcut":["lnk"],"application/x-ms-wmd":["wmd"],"application/x-ms-wmz":["wmz"],"application/x-ms-xbap":["xbap"],"application/x-msaccess":["mdb"],"application/x-msbinder":["obd"],"application/x-mscardfile":["crd"],"application/x-msclip":["clp"],"application/x-msdos-program":[],"application/x-msdownload":["com","bat"],"application/x-msmediaview":["mvb","m13","m14"],"application/x-msmetafile":["wmf","emf","emz"],"application/x-msmoney":["mny"],"application/x-mspublisher":["pub"],"application/x-msschedule":["scd"],"application/x-msterminal":["trm"],"application/x-mswrite":["wri"],"application/x-netcdf":["nc","cdf"],"application/x-ns-proxy-autoconfig":["pac"],"application/x-nzb":["nzb"],"application/x-perl":["pl","pm"],"application/x-pilot":[],"application/x-pkcs12":["p12","pfx"],"application/x-pkcs7-certificates":["p7b","spc"],"application/x-pkcs7-certreqresp":["p7r"],"application/x-rar-compressed":["rar"],"application/x-redhat-package-manager":["rpm"],"application/x-research-info-systems":["ris"],"application/x-sea":["sea"],"application/x-sh":["sh"],"application/x-shar":["shar"],"application/x-shockwave-flash":["swf"],"application/x-silverlight-app":["xap"],"application/x-sql":["sql"],"application/x-stuffit":["sit"],"application/x-stuffitx":["sitx"],"application/x-subrip":["srt"],"application/x-sv4cpio":["sv4cpio"],"application/x-sv4crc":["sv4crc"],"application/x-t3vm-image":["t3"],"application/x-tads":["gam"],"application/x-tar":["tar"],"application/x-tcl":["tcl","tk"],"application/x-tex":["tex"],"application/x-tex-tfm":["tfm"],"application/x-texinfo":["texinfo","texi"],"application/x-tgif":["obj"],"application/x-ustar":["ustar"],"application/x-virtualbox-hdd":["hdd"],"application/x-virtualbox-ova":["ova"],"application/x-virtualbox-ovf":["ovf"],"application/x-virtualbox-vbox":["vbox"],"application/x-virtualbox-vbox-extpack":["vbox-extpack"],"application/x-virtualbox-vdi":["vdi"],"application/x-virtualbox-vhd":["vhd"],"application/x-virtualbox-vmdk":["vmdk"],"application/x-wais-source":["src"],"application/x-web-app-manifest+json":["webapp"],"application/x-x509-ca-cert":["der","crt","pem"],"application/x-xfig":["fig"],"application/x-xliff+xml":["xlf"],"application/x-xpinstall":["xpi"],"application/x-xz":["xz"],"application/x-zmachine":["z1","z2","z3","z4","z5","z6","z7","z8"],"application/xaml+xml":["xaml"],"application/xcap-diff+xml":["xdf"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":[],"audio/adpcm":["adp"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mp3":[],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/vnd.dece.audio":["uva","uvva"],"audio/vnd.digital-winds":["eol"],"audio/vnd.dra":["dra"],"audio/vnd.dts":["dts"],"audio/vnd.dts.hd":["dtshd"],"audio/vnd.lucent.voice":["lvp"],"audio/vnd.ms-playready.media.pya":["pya"],"audio/vnd.nuera.ecelp4800":["ecelp4800"],"audio/vnd.nuera.ecelp7470":["ecelp7470"],"audio/vnd.nuera.ecelp9600":["ecelp9600"],"audio/vnd.rip":["rip"],"audio/wav":["wav"],"audio/wave":[],"audio/webm":["weba"],"audio/x-aac":["aac"],"audio/x-aiff":["aif","aiff","aifc"],"audio/x-caf":["caf"],"audio/x-flac":["flac"],"audio/x-m4a":[],"audio/x-matroska":["mka"],"audio/x-mpegurl":["m3u"],"audio/x-ms-wax":["wax"],"audio/x-ms-wma":["wma"],"audio/x-pn-realaudio":["ram","ra"],"audio/x-pn-realaudio-plugin":["rmp"],"audio/x-realaudio":[],"audio/x-wav":[],"audio/xm":["xm"],"chemical/x-cdx":["cdx"],"chemical/x-cif":["cif"],"chemical/x-cmdf":["cmdf"],"chemical/x-cml":["cml"],"chemical/x-csml":["csml"],"chemical/x-xyz":["xyz"],"font/collection":["ttc"],"font/otf":["otf"],"font/ttf":["ttf"],"font/woff":["woff"],"font/woff2":["woff2"],"image/apng":["apng"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/g3fax":["g3"],"image/gif":["gif"],"image/ief":["ief"],"image/jp2":["jp2","jpg2"],"image/jpeg":["jpeg","jpg","jpe"],"image/jpm":["jpm"],"image/jpx":["jpx","jpf"],"image/ktx":["ktx"],"image/png":["png"],"image/prs.btif":["btif"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/tiff":["tiff","tif"],"image/vnd.adobe.photoshop":["psd"],"image/vnd.dece.graphic":["uvi","uvvi","uvg","uvvg"],"image/vnd.djvu":["djvu","djv"],"image/vnd.dvb.subtitle":[],"image/vnd.dwg":["dwg"],"image/vnd.dxf":["dxf"],"image/vnd.fastbidsheet":["fbs"],"image/vnd.fpx":["fpx"],"image/vnd.fst":["fst"],"image/vnd.fujixerox.edmics-mmr":["mmr"],"image/vnd.fujixerox.edmics-rlc":["rlc"],"image/vnd.ms-modi":["mdi"],"image/vnd.ms-photo":["wdp"],"image/vnd.net-fpx":["npx"],"image/vnd.wap.wbmp":["wbmp"],"image/vnd.xiff":["xif"],"image/webp":["webp"],"image/x-3ds":["3ds"],"image/x-cmu-raster":["ras"],"image/x-cmx":["cmx"],"image/x-freehand":["fh","fhc","fh4","fh5","fh7"],"image/x-icon":["ico"],"image/x-jng":["jng"],"image/x-mrsid-image":["sid"],"image/x-ms-bmp":[],"image/x-pcx":["pcx"],"image/x-pict":["pic","pct"],"image/x-portable-anymap":["pnm"],"image/x-portable-bitmap":["pbm"],"image/x-portable-graymap":["pgm"],"image/x-portable-pixmap":["ppm"],"image/x-rgb":["rgb"],"image/x-tga":["tga"],"image/x-xbitmap":["xbm"],"image/x-xpixmap":["xpm"],"image/x-xwindowdump":["xwd"],"message/rfc822":["eml","mime"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/vnd.collada+xml":["dae"],"model/vnd.dwf":["dwf"],"model/vnd.gdl":["gdl"],"model/vnd.gtw":["gtw"],"model/vnd.mts":["mts"],"model/vnd.vtu":["vtu"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["x3db","x3dbz"],"model/x3d+vrml":["x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/hjson":["hjson"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/prs.lines.tag":["dsc"],"text/richtext":["rtx"],"text/rtf":[],"text/sgml":["sgml","sgm"],"text/slim":["slim","slm"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vnd.curl":["curl"],"text/vnd.curl.dcurl":["dcurl"],"text/vnd.curl.mcurl":["mcurl"],"text/vnd.curl.scurl":["scurl"],"text/vnd.dvb.subtitle":["sub"],"text/vnd.fly":["fly"],"text/vnd.fmi.flexstor":["flx"],"text/vnd.graphviz":["gv"],"text/vnd.in3d.3dml":["3dml"],"text/vnd.in3d.spot":["spot"],"text/vnd.sun.j2me.app-descriptor":["jad"],"text/vnd.wap.wml":["wml"],"text/vnd.wap.wmlscript":["wmls"],"text/vtt":["vtt"],"text/x-asm":["s","asm"],"text/x-c":["c","cc","cxx","cpp","h","hh","dic"],"text/x-component":["htc"],"text/x-fortran":["f","for","f77","f90"],"text/x-handlebars-template":["hbs"],"text/x-java-source":["java"],"text/x-lua":["lua"],"text/x-markdown":["mkd"],"text/x-nfo":["nfo"],"text/x-opml":["opml"],"text/x-org":[],"text/x-pascal":["p","pas"],"text/x-processing":["pde"],"text/x-sass":["sass"],"text/x-scss":["scss"],"text/x-setext":["etx"],"text/x-sfv":["sfv"],"text/x-suse-ymp":["ymp"],"text/x-uuencode":["uu"],"text/x-vcalendar":["vcs"],"text/x-vcard":["vcf"],"text/xml":[],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/jpeg":["jpgv"],"video/jpm":["jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/vnd.dece.hd":["uvh","uvvh"],"video/vnd.dece.mobile":["uvm","uvvm"],"video/vnd.dece.pd":["uvp","uvvp"],"video/vnd.dece.sd":["uvs","uvvs"],"video/vnd.dece.video":["uvv","uvvv"],"video/vnd.dvb.file":["dvb"],"video/vnd.fvt":["fvt"],"video/vnd.mpegurl":["mxu","m4u"],"video/vnd.ms-playready.media.pyv":["pyv"],"video/vnd.uvvu.mp4":["uvu","uvvu"],"video/vnd.vivo":["viv"],"video/webm":["webm"],"video/x-f4v":["f4v"],"video/x-fli":["fli"],"video/x-flv":["flv"],"video/x-m4v":["m4v"],"video/x-matroska":["mkv","mk3d","mks"],"video/x-mng":["mng"],"video/x-ms-asf":["asf","asx"],"video/x-ms-vob":["vob"],"video/x-ms-wm":["wm"],"video/x-ms-wmv":["wmv"],"video/x-ms-wmx":["wmx"],"video/x-ms-wvx":["wvx"],"video/x-msvideo":["avi"],"video/x-sgi-movie":["movie"],"video/x-smv":["smv"],"x-conference/x-cooltalk":["ice"]}');
    },
    "../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/package.json": function(module) {
        "use strict";
        module.exports = {
            i8: "4.8.1"
        };
    },
    "../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/codes.json": function(module) {
        "use strict";
        module.exports = JSON.parse('{"100":"Continue","101":"Switching Protocols","102":"Processing","103":"Early Hints","200":"OK","201":"Created","202":"Accepted","203":"Non-Authoritative Information","204":"No Content","205":"Reset Content","206":"Partial Content","207":"Multi-Status","208":"Already Reported","226":"IM Used","300":"Multiple Choices","301":"Moved Permanently","302":"Found","303":"See Other","304":"Not Modified","305":"Use Proxy","307":"Temporary Redirect","308":"Permanent Redirect","400":"Bad Request","401":"Unauthorized","402":"Payment Required","403":"Forbidden","404":"Not Found","405":"Method Not Allowed","406":"Not Acceptable","407":"Proxy Authentication Required","408":"Request Timeout","409":"Conflict","410":"Gone","411":"Length Required","412":"Precondition Failed","413":"Payload Too Large","414":"URI Too Long","415":"Unsupported Media Type","416":"Range Not Satisfiable","417":"Expectation Failed","418":"I\'m a Teapot","421":"Misdirected Request","422":"Unprocessable Entity","423":"Locked","424":"Failed Dependency","425":"Too Early","426":"Upgrade Required","428":"Precondition Required","429":"Too Many Requests","431":"Request Header Fields Too Large","451":"Unavailable For Legal Reasons","500":"Internal Server Error","501":"Not Implemented","502":"Bad Gateway","503":"Service Unavailable","504":"Gateway Timeout","505":"HTTP Version Not Supported","506":"Variant Also Negotiates","507":"Insufficient Storage","508":"Loop Detected","509":"Bandwidth Limit Exceeded","510":"Not Extended","511":"Network Authentication Required"}');
    }
};
var __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
        id: moduleId,
        loaded: false,
        exports: {}
    };
    __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    module.loaded = true;
    return module.exports;
}
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
(()=>{
    __webpack_require__.nmd = (module)=>{
        module.paths = [];
        if (!module.children) module.children = [];
        return module;
    };
})();
var __webpack_exports__ = {};
(()=>{
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
        AgentSession: ()=>_core__WEBPACK_IMPORTED_MODULE_0__.ZT,
        AgentTARSServer: ()=>_server__WEBPACK_IMPORTED_MODULE_1__.t,
        AgioProvider: ()=>_core__WEBPACK_IMPORTED_MODULE_0__.iF,
        ErrorWithCode: ()=>_utils__WEBPACK_IMPORTED_MODULE_2__.G8,
        ShareService: ()=>_services__WEBPACK_IMPORTED_MODULE_5__.t,
        SocketHandlers: ()=>_core__WEBPACK_IMPORTED_MODULE_0__.Lw,
        createErrorResponse: ()=>_utils__WEBPACK_IMPORTED_MODULE_2__.jl,
        createStorageProvider: ()=>_storage__WEBPACK_IMPORTED_MODULE_3__.E,
        ensureWorkingDirectory: ()=>_utils__WEBPACK_IMPORTED_MODULE_2__.st,
        express: ()=>_server__WEBPACK_IMPORTED_MODULE_1__.z,
        handleAgentError: ()=>_utils__WEBPACK_IMPORTED_MODULE_2__.rB,
        setupSocketIO: ()=>_core__WEBPACK_IMPORTED_MODULE_0__.sI
    });
    var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/core/index.ts");
    var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/server.ts");
    var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/index.ts");
    var _storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/storage/index.ts");
    var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/types.ts");
    var __WEBPACK_REEXPORT_OBJECT__ = {};
    for(var __WEBPACK_IMPORT_KEY__ in _types__WEBPACK_IMPORTED_MODULE_4__)if ([
        "default",
        "AgioProvider",
        "ErrorWithCode",
        "setupSocketIO",
        "AgentTARSServer",
        "express",
        "SocketHandlers",
        "createErrorResponse",
        "ensureWorkingDirectory",
        "handleAgentError",
        "createStorageProvider",
        "AgentSession"
    ].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = (function(key) {
        return _types__WEBPACK_IMPORTED_MODULE_4__[key];
    }).bind(0, __WEBPACK_IMPORT_KEY__);
    __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
    var _services__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/services/index.ts");
})();
exports.AgentSession = __webpack_exports__.AgentSession;
exports.AgentTARSServer = __webpack_exports__.AgentTARSServer;
exports.AgioProvider = __webpack_exports__.AgioProvider;
exports.ErrorWithCode = __webpack_exports__.ErrorWithCode;
exports.ShareService = __webpack_exports__.ShareService;
exports.SocketHandlers = __webpack_exports__.SocketHandlers;
exports.createErrorResponse = __webpack_exports__.createErrorResponse;
exports.createStorageProvider = __webpack_exports__.createStorageProvider;
exports.ensureWorkingDirectory = __webpack_exports__.ensureWorkingDirectory;
exports.express = __webpack_exports__.express;
exports.handleAgentError = __webpack_exports__.handleAgentError;
exports.setupSocketIO = __webpack_exports__.setupSocketIO;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "AgentSession",
    "AgentTARSServer",
    "AgioProvider",
    "ErrorWithCode",
    "ShareService",
    "SocketHandlers",
    "createErrorResponse",
    "createStorageProvider",
    "ensureWorkingDirectory",
    "express",
    "handleAgentError",
    "setupSocketIO"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});

//# sourceMappingURL=index.js.map