/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
/*! For license information please see index.js.LICENSE.txt */
var __webpack_modules__ = {
    "../node_modules/.pnpm/accepts@1.3.8/node_modules/accepts/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Negotiator = __webpack_require__("../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/index.js");
        var mime = __webpack_require__("../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js");
        module.exports = Accepts;
        function Accepts(req) {
            if (!(this instanceof Accepts)) return new Accepts(req);
            this.headers = req.headers;
            this.negotiator = new Negotiator(req);
        }
        Accepts.prototype.type = Accepts.prototype.types = function(types_) {
            var types = types_;
            if (types && !Array.isArray(types)) {
                types = new Array(arguments.length);
                for(var i = 0; i < types.length; i++)types[i] = arguments[i];
            }
            if (!types || 0 === types.length) return this.negotiator.mediaTypes();
            if (!this.headers.accept) return types[0];
            var mimes = types.map(extToMime);
            var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
            var first = accepts[0];
            return first ? types[mimes.indexOf(first)] : false;
        };
        Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
            var encodings = encodings_;
            if (encodings && !Array.isArray(encodings)) {
                encodings = new Array(arguments.length);
                for(var i = 0; i < encodings.length; i++)encodings[i] = arguments[i];
            }
            if (!encodings || 0 === encodings.length) return this.negotiator.encodings();
            return this.negotiator.encodings(encodings)[0] || false;
        };
        Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
            var charsets = charsets_;
            if (charsets && !Array.isArray(charsets)) {
                charsets = new Array(arguments.length);
                for(var i = 0; i < charsets.length; i++)charsets[i] = arguments[i];
            }
            if (!charsets || 0 === charsets.length) return this.negotiator.charsets();
            return this.negotiator.charsets(charsets)[0] || false;
        };
        Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
            var languages = languages_;
            if (languages && !Array.isArray(languages)) {
                languages = new Array(arguments.length);
                for(var i = 0; i < languages.length; i++)languages[i] = arguments[i];
            }
            if (!languages || 0 === languages.length) return this.negotiator.languages();
            return this.negotiator.languages(languages)[0] || false;
        };
        function extToMime(type) {
            return -1 === type.indexOf('/') ? mime.lookup(type) : type;
        }
        function validMime(type) {
            return 'string' == typeof type;
        }
    },
    "../node_modules/.pnpm/array-flatten@1.1.1/node_modules/array-flatten/array-flatten.js": function(module) {
        "use strict";
        module.exports = arrayFlatten;
        function flattenWithDepth(array, result, depth) {
            for(var i = 0; i < array.length; i++){
                var value = array[i];
                if (depth > 0 && Array.isArray(value)) flattenWithDepth(value, result, depth - 1);
                else result.push(value);
            }
            return result;
        }
        function flattenForever(array, result) {
            for(var i = 0; i < array.length; i++){
                var value = array[i];
                if (Array.isArray(value)) flattenForever(value, result);
                else result.push(value);
            }
            return result;
        }
        function arrayFlatten(array, depth) {
            if (null == depth) return flattenForever(array, []);
            return flattenWithDepth(array, [], depth);
        }
    },
    "../node_modules/.pnpm/base64id@2.0.0/node_modules/base64id/lib/base64id.js": function(module, exports1, __webpack_require__) {
        /*!
 * base64id v0.1.0
 */ var crypto = __webpack_require__("crypto");
        var Base64Id = function() {};
        Base64Id.prototype.getRandomBytes = function(bytes) {
            var BUFFER_SIZE = 4096;
            var self = this;
            bytes = bytes || 12;
            if (bytes > BUFFER_SIZE) return crypto.randomBytes(bytes);
            var bytesInBuffer = parseInt(BUFFER_SIZE / bytes);
            var threshold = parseInt(0.85 * bytesInBuffer);
            if (!threshold) return crypto.randomBytes(bytes);
            if (null == this.bytesBufferIndex) this.bytesBufferIndex = -1;
            if (this.bytesBufferIndex == bytesInBuffer) {
                this.bytesBuffer = null;
                this.bytesBufferIndex = -1;
            }
            if (-1 == this.bytesBufferIndex || this.bytesBufferIndex > threshold) {
                if (!this.isGeneratingBytes) {
                    this.isGeneratingBytes = true;
                    crypto.randomBytes(BUFFER_SIZE, function(err, bytes) {
                        self.bytesBuffer = bytes;
                        self.bytesBufferIndex = 0;
                        self.isGeneratingBytes = false;
                    });
                }
                if (-1 == this.bytesBufferIndex) return crypto.randomBytes(bytes);
            }
            var result = this.bytesBuffer.slice(bytes * this.bytesBufferIndex, bytes * (this.bytesBufferIndex + 1));
            this.bytesBufferIndex++;
            return result;
        };
        Base64Id.prototype.generateId = function() {
            var rand = Buffer.alloc(15);
            if (!rand.writeInt32BE) return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString() + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();
            this.sequenceNumber = this.sequenceNumber + 1 | 0;
            rand.writeInt32BE(this.sequenceNumber, 11);
            if (crypto.randomBytes) this.getRandomBytes(12).copy(rand);
            else [
                0,
                4,
                8
            ].forEach(function(i) {
                rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i);
            });
            return rand.toString('base64').replace(/\//g, '_').replace(/\+/g, '-');
        };
        module.exports = new Base64Id();
    },
    "../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/index.js": function(module, exports1, __webpack_require__) {
        "use strict";
        /*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var deprecate = __webpack_require__("../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('body-parser');
        var parsers = Object.create(null);
        exports1 = module.exports = deprecate.function(bodyParser, 'bodyParser: use individual json/urlencoded middlewares');
        Object.defineProperty(exports1, "json", {
            configurable: true,
            enumerable: true,
            get: createParserGetter('json')
        });
        Object.defineProperty(exports1, "raw", {
            configurable: true,
            enumerable: true,
            get: createParserGetter('raw')
        });
        Object.defineProperty(exports1, "text", {
            configurable: true,
            enumerable: true,
            get: createParserGetter('text')
        });
        Object.defineProperty(exports1, "urlencoded", {
            configurable: true,
            enumerable: true,
            get: createParserGetter('urlencoded')
        });
        function bodyParser(options) {
            var opts = Object.create(options || null, {
                type: {
                    configurable: true,
                    enumerable: true,
                    value: void 0,
                    writable: true
                }
            });
            var _urlencoded = exports1.urlencoded(opts);
            var _json = exports1.json(opts);
            return function(req, res, next) {
                _json(req, res, function(err) {
                    if (err) return next(err);
                    _urlencoded(req, res, next);
                });
            };
        }
        function createParserGetter(name) {
            return function() {
                return loadParser(name);
            };
        }
        function loadParser(parserName) {
            var parser = parsers[parserName];
            if (void 0 !== parser) return parser;
            switch(parserName){
                case 'json':
                    parser = __webpack_require__("../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/json.js");
                    break;
                case 'raw':
                    parser = __webpack_require__("../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/raw.js");
                    break;
                case 'text':
                    parser = __webpack_require__("../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/text.js");
                    break;
                case 'urlencoded':
                    parser = __webpack_require__("../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/urlencoded.js");
                    break;
            }
            return parsers[parserName] = parser;
        }
    },
    "../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/read.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var createError = __webpack_require__("../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js");
        var destroy = __webpack_require__("../node_modules/.pnpm/destroy@1.2.0/node_modules/destroy/index.js");
        var getBody = __webpack_require__("../node_modules/.pnpm/raw-body@2.5.2/node_modules/raw-body/index.js");
        var iconv = __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/index.js");
        var onFinished = __webpack_require__("../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js");
        var unpipe = __webpack_require__("../node_modules/.pnpm/unpipe@1.0.0/node_modules/unpipe/index.js");
        var zlib = __webpack_require__("zlib");
        module.exports = read;
        function read(req, res, next, parse, debug, options) {
            var length;
            var opts = options;
            var stream;
            req._body = true;
            var encoding = null !== opts.encoding ? opts.encoding : null;
            var verify = opts.verify;
            try {
                stream = contentstream(req, debug, opts.inflate);
                length = stream.length;
                stream.length = void 0;
            } catch (err) {
                return next(err);
            }
            opts.length = length;
            opts.encoding = verify ? null : encoding;
            if (null === opts.encoding && null !== encoding && !iconv.encodingExists(encoding)) return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
                charset: encoding.toLowerCase(),
                type: 'charset.unsupported'
            }));
            debug('read body');
            getBody(stream, opts, function(error, body) {
                if (error) {
                    var _error;
                    _error = 'encoding.unsupported' === error.type ? createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
                        charset: encoding.toLowerCase(),
                        type: 'charset.unsupported'
                    }) : createError(400, error);
                    if (stream !== req) {
                        unpipe(req);
                        destroy(stream, true);
                    }
                    dump(req, function() {
                        next(createError(400, _error));
                    });
                    return;
                }
                if (verify) try {
                    debug('verify body');
                    verify(req, res, body, encoding);
                } catch (err) {
                    next(createError(403, err, {
                        body: body,
                        type: err.type || 'entity.verify.failed'
                    }));
                    return;
                }
                var str = body;
                try {
                    debug('parse body');
                    str = 'string' != typeof body && null !== encoding ? iconv.decode(body, encoding) : body;
                    req.body = parse(str);
                } catch (err) {
                    next(createError(400, err, {
                        body: str,
                        type: err.type || 'entity.parse.failed'
                    }));
                    return;
                }
                next();
            });
        }
        function contentstream(req, debug, inflate) {
            var encoding = (req.headers['content-encoding'] || 'identity').toLowerCase();
            var length = req.headers['content-length'];
            var stream;
            debug('content-encoding "%s"', encoding);
            if (false === inflate && 'identity' !== encoding) throw createError(415, 'content encoding unsupported', {
                encoding: encoding,
                type: 'encoding.unsupported'
            });
            switch(encoding){
                case 'deflate':
                    stream = zlib.createInflate();
                    debug('inflate body');
                    req.pipe(stream);
                    break;
                case 'gzip':
                    stream = zlib.createGunzip();
                    debug('gunzip body');
                    req.pipe(stream);
                    break;
                case 'identity':
                    stream = req;
                    stream.length = length;
                    break;
                default:
                    throw createError(415, 'unsupported content encoding "' + encoding + '"', {
                        encoding: encoding,
                        type: 'encoding.unsupported'
                    });
            }
            return stream;
        }
        function dump(req, callback) {
            if (onFinished.isFinished(req)) callback(null);
            else {
                onFinished(req, callback);
                req.resume();
            }
        }
    },
    "../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/json.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var bytes = __webpack_require__("../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js");
        var contentType = __webpack_require__("../node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js");
        var createError = __webpack_require__("../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js");
        var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('body-parser:json');
        var read = __webpack_require__("../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/read.js");
        var typeis = __webpack_require__("../node_modules/.pnpm/type-is@1.6.18/node_modules/type-is/index.js");
        module.exports = json;
        var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
        var JSON_SYNTAX_CHAR = '#';
        var JSON_SYNTAX_REGEXP = /#+/g;
        function json(options) {
            var opts = options || {};
            var limit = 'number' != typeof opts.limit ? bytes.parse(opts.limit || '100kb') : opts.limit;
            var inflate = false !== opts.inflate;
            var reviver = opts.reviver;
            var strict = false !== opts.strict;
            var type = opts.type || 'application/json';
            var verify = opts.verify || false;
            if (false !== verify && 'function' != typeof verify) throw new TypeError('option verify must be function');
            var shouldParse = 'function' != typeof type ? typeChecker(type) : type;
            function parse(body) {
                if (0 === body.length) return {};
                if (strict) {
                    var first = firstchar(body);
                    if ('{' !== first && '[' !== first) {
                        debug('strict violation');
                        throw createStrictSyntaxError(body, first);
                    }
                }
                try {
                    debug('parse json');
                    return JSON.parse(body, reviver);
                } catch (e) {
                    throw normalizeJsonSyntaxError(e, {
                        message: e.message,
                        stack: e.stack
                    });
                }
            }
            return function(req, res, next) {
                if (req._body) {
                    debug('body already parsed');
                    next();
                    return;
                }
                req.body = req.body || {};
                if (!typeis.hasBody(req)) {
                    debug('skip empty body');
                    next();
                    return;
                }
                debug('content-type %j', req.headers['content-type']);
                if (!shouldParse(req)) {
                    debug('skip parsing');
                    next();
                    return;
                }
                var charset = getCharset(req) || 'utf-8';
                if ('utf-' !== charset.slice(0, 4)) {
                    debug('invalid charset');
                    next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
                        charset: charset,
                        type: 'charset.unsupported'
                    }));
                    return;
                }
                read(req, res, next, parse, debug, {
                    encoding: charset,
                    inflate: inflate,
                    limit: limit,
                    verify: verify
                });
            };
        }
        function createStrictSyntaxError(str, char) {
            var index = str.indexOf(char);
            var partial = '';
            if (-1 !== index) {
                partial = str.substring(0, index) + JSON_SYNTAX_CHAR;
                for(var i = index + 1; i < str.length; i++)partial += JSON_SYNTAX_CHAR;
            }
            try {
                JSON.parse(partial);
                throw new SyntaxError('strict violation');
            } catch (e) {
                return normalizeJsonSyntaxError(e, {
                    message: e.message.replace(JSON_SYNTAX_REGEXP, function(placeholder) {
                        return str.substring(index, index + placeholder.length);
                    }),
                    stack: e.stack
                });
            }
        }
        function firstchar(str) {
            var match = FIRST_CHAR_REGEXP.exec(str);
            return match ? match[1] : void 0;
        }
        function getCharset(req) {
            try {
                return (contentType.parse(req).parameters.charset || '').toLowerCase();
            } catch (e) {
                return;
            }
        }
        function normalizeJsonSyntaxError(error, obj) {
            var keys = Object.getOwnPropertyNames(error);
            for(var i = 0; i < keys.length; i++){
                var key = keys[i];
                if ('stack' !== key && 'message' !== key) delete error[key];
            }
            error.stack = obj.stack.replace(error.message, obj.message);
            error.message = obj.message;
            return error;
        }
        function typeChecker(type) {
            return function(req) {
                return Boolean(typeis(req, type));
            };
        }
    },
    "../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/raw.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var bytes = __webpack_require__("../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js");
        var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('body-parser:raw');
        var read = __webpack_require__("../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/read.js");
        var typeis = __webpack_require__("../node_modules/.pnpm/type-is@1.6.18/node_modules/type-is/index.js");
        module.exports = raw;
        function raw(options) {
            var opts = options || {};
            var inflate = false !== opts.inflate;
            var limit = 'number' != typeof opts.limit ? bytes.parse(opts.limit || '100kb') : opts.limit;
            var type = opts.type || 'application/octet-stream';
            var verify = opts.verify || false;
            if (false !== verify && 'function' != typeof verify) throw new TypeError('option verify must be function');
            var shouldParse = 'function' != typeof type ? typeChecker(type) : type;
            function parse(buf) {
                return buf;
            }
            return function(req, res, next) {
                if (req._body) {
                    debug('body already parsed');
                    next();
                    return;
                }
                req.body = req.body || {};
                if (!typeis.hasBody(req)) {
                    debug('skip empty body');
                    next();
                    return;
                }
                debug('content-type %j', req.headers['content-type']);
                if (!shouldParse(req)) {
                    debug('skip parsing');
                    next();
                    return;
                }
                read(req, res, next, parse, debug, {
                    encoding: null,
                    inflate: inflate,
                    limit: limit,
                    verify: verify
                });
            };
        }
        function typeChecker(type) {
            return function(req) {
                return Boolean(typeis(req, type));
            };
        }
    },
    "../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/text.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var bytes = __webpack_require__("../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js");
        var contentType = __webpack_require__("../node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js");
        var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('body-parser:text');
        var read = __webpack_require__("../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/read.js");
        var typeis = __webpack_require__("../node_modules/.pnpm/type-is@1.6.18/node_modules/type-is/index.js");
        module.exports = text;
        function text(options) {
            var opts = options || {};
            var defaultCharset = opts.defaultCharset || 'utf-8';
            var inflate = false !== opts.inflate;
            var limit = 'number' != typeof opts.limit ? bytes.parse(opts.limit || '100kb') : opts.limit;
            var type = opts.type || 'text/plain';
            var verify = opts.verify || false;
            if (false !== verify && 'function' != typeof verify) throw new TypeError('option verify must be function');
            var shouldParse = 'function' != typeof type ? typeChecker(type) : type;
            function parse(buf) {
                return buf;
            }
            return function(req, res, next) {
                if (req._body) {
                    debug('body already parsed');
                    next();
                    return;
                }
                req.body = req.body || {};
                if (!typeis.hasBody(req)) {
                    debug('skip empty body');
                    next();
                    return;
                }
                debug('content-type %j', req.headers['content-type']);
                if (!shouldParse(req)) {
                    debug('skip parsing');
                    next();
                    return;
                }
                var charset = getCharset(req) || defaultCharset;
                read(req, res, next, parse, debug, {
                    encoding: charset,
                    inflate: inflate,
                    limit: limit,
                    verify: verify
                });
            };
        }
        function getCharset(req) {
            try {
                return (contentType.parse(req).parameters.charset || '').toLowerCase();
            } catch (e) {
                return;
            }
        }
        function typeChecker(type) {
            return function(req) {
                return Boolean(typeis(req, type));
            };
        }
    },
    "../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/types/urlencoded.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var bytes = __webpack_require__("../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js");
        var contentType = __webpack_require__("../node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js");
        var createError = __webpack_require__("../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js");
        var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('body-parser:urlencoded');
        var deprecate = __webpack_require__("../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('body-parser');
        var read = __webpack_require__("../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/lib/read.js");
        var typeis = __webpack_require__("../node_modules/.pnpm/type-is@1.6.18/node_modules/type-is/index.js");
        module.exports = urlencoded;
        var parsers = Object.create(null);
        function urlencoded(options) {
            var opts = options || {};
            if (void 0 === opts.extended) deprecate('undefined extended: provide extended option');
            var extended = false !== opts.extended;
            var inflate = false !== opts.inflate;
            var limit = 'number' != typeof opts.limit ? bytes.parse(opts.limit || '100kb') : opts.limit;
            var type = opts.type || 'application/x-www-form-urlencoded';
            var verify = opts.verify || false;
            var depth = 'number' != typeof opts.depth ? Number(opts.depth || 32) : opts.depth;
            if (false !== verify && 'function' != typeof verify) throw new TypeError('option verify must be function');
            var queryparse = extended ? extendedparser(opts) : simpleparser(opts);
            var shouldParse = 'function' != typeof type ? typeChecker(type) : type;
            function parse(body) {
                return body.length ? queryparse(body) : {};
            }
            return function(req, res, next) {
                if (req._body) {
                    debug('body already parsed');
                    next();
                    return;
                }
                req.body = req.body || {};
                if (!typeis.hasBody(req)) {
                    debug('skip empty body');
                    next();
                    return;
                }
                debug('content-type %j', req.headers['content-type']);
                if (!shouldParse(req)) {
                    debug('skip parsing');
                    next();
                    return;
                }
                var charset = getCharset(req) || 'utf-8';
                if ('utf-8' !== charset) {
                    debug('invalid charset');
                    next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
                        charset: charset,
                        type: 'charset.unsupported'
                    }));
                    return;
                }
                read(req, res, next, parse, debug, {
                    debug: debug,
                    encoding: charset,
                    inflate: inflate,
                    limit: limit,
                    verify: verify,
                    depth: depth
                });
            };
        }
        function extendedparser(options) {
            var parameterLimit = void 0 !== options.parameterLimit ? options.parameterLimit : 1000;
            var depth = 'number' != typeof options.depth ? Number(options.depth || 32) : options.depth;
            var parse = parser('qs');
            if (isNaN(parameterLimit) || parameterLimit < 1) throw new TypeError('option parameterLimit must be a positive number');
            if (isNaN(depth) || depth < 0) throw new TypeError('option depth must be a zero or a positive number');
            if (isFinite(parameterLimit)) parameterLimit |= 0;
            return function(body) {
                var paramCount = parameterCount(body, parameterLimit);
                if (void 0 === paramCount) {
                    debug('too many parameters');
                    throw createError(413, 'too many parameters', {
                        type: 'parameters.too.many'
                    });
                }
                var arrayLimit = Math.max(100, paramCount);
                debug('parse extended urlencoding');
                try {
                    return parse(body, {
                        allowPrototypes: true,
                        arrayLimit: arrayLimit,
                        depth: depth,
                        strictDepth: true,
                        parameterLimit: parameterLimit
                    });
                } catch (err) {
                    if (err instanceof RangeError) throw createError(400, 'The input exceeded the depth', {
                        type: 'querystring.parse.rangeError'
                    });
                    throw err;
                }
            };
        }
        function getCharset(req) {
            try {
                return (contentType.parse(req).parameters.charset || '').toLowerCase();
            } catch (e) {
                return;
            }
        }
        function parameterCount(body, limit) {
            var count = 0;
            var index = 0;
            while(-1 !== (index = body.indexOf('&', index))){
                count++;
                index++;
                if (count === limit) return;
            }
            return count;
        }
        function parser(name) {
            var mod = parsers[name];
            if (void 0 !== mod) return mod.parse;
            switch(name){
                case 'qs':
                    mod = __webpack_require__("../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/index.js");
                    break;
                case 'querystring':
                    mod = __webpack_require__("querystring");
                    break;
            }
            parsers[name] = mod;
            return mod.parse;
        }
        function simpleparser(options) {
            var parameterLimit = void 0 !== options.parameterLimit ? options.parameterLimit : 1000;
            var parse = parser('querystring');
            if (isNaN(parameterLimit) || parameterLimit < 1) throw new TypeError('option parameterLimit must be a positive number');
            if (isFinite(parameterLimit)) parameterLimit |= 0;
            return function(body) {
                var paramCount = parameterCount(body, parameterLimit);
                if (void 0 === paramCount) {
                    debug('too many parameters');
                    throw createError(413, 'too many parameters', {
                        type: 'parameters.too.many'
                    });
                }
                debug('parse urlencoding');
                return parse(body, void 0, void 0, {
                    maxKeys: parameterLimit
                });
            };
        }
        function typeChecker(type) {
            return function(req) {
                return Boolean(typeis(req, type));
            };
        }
    },
    "../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js": function(module) {
        "use strict";
        /*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */ module.exports = bytes;
        module.exports.format = format;
        module.exports.parse = parse;
        var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
        var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
        var map = {
            b: 1,
            kb: 1024,
            mb: 1048576,
            gb: 1073741824,
            tb: Math.pow(1024, 4),
            pb: Math.pow(1024, 5)
        };
        var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
        function bytes(value, options) {
            if ('string' == typeof value) return parse(value);
            if ('number' == typeof value) return format(value, options);
            return null;
        }
        function format(value, options) {
            if (!Number.isFinite(value)) return null;
            var mag = Math.abs(value);
            var thousandsSeparator = options && options.thousandsSeparator || '';
            var unitSeparator = options && options.unitSeparator || '';
            var decimalPlaces = options && void 0 !== options.decimalPlaces ? options.decimalPlaces : 2;
            var fixedDecimals = Boolean(options && options.fixedDecimals);
            var unit = options && options.unit || '';
            if (!unit || !map[unit.toLowerCase()]) unit = mag >= map.pb ? 'PB' : mag >= map.tb ? 'TB' : mag >= map.gb ? 'GB' : mag >= map.mb ? 'MB' : mag >= map.kb ? 'KB' : 'B';
            var val = value / map[unit.toLowerCase()];
            var str = val.toFixed(decimalPlaces);
            if (!fixedDecimals) str = str.replace(formatDecimalsRegExp, '$1');
            if (thousandsSeparator) str = str.split('.').map(function(s, i) {
                return 0 === i ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
            }).join('.');
            return str + unitSeparator + unit;
        }
        function parse(val) {
            if ('number' == typeof val && !isNaN(val)) return val;
            if ('string' != typeof val) return null;
            var results = parseRegExp.exec(val);
            var floatValue;
            var unit = 'b';
            if (results) {
                floatValue = parseFloat(results[1]);
                unit = results[4].toLowerCase();
            } else {
                floatValue = parseInt(val, 10);
                unit = 'b';
            }
            if (isNaN(floatValue)) return null;
            return Math.floor(map[unit] * floatValue);
        }
    },
    "../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var bind = __webpack_require__("../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
        var $apply = __webpack_require__("../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js");
        var $call = __webpack_require__("../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js");
        var $reflectApply = __webpack_require__("../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js");
        module.exports = $reflectApply || bind.call($call, $apply);
    },
    "../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js": function(module) {
        "use strict";
        module.exports = Function.prototype.apply;
    },
    "../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js": function(module) {
        "use strict";
        module.exports = Function.prototype.call;
    },
    "../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var bind = __webpack_require__("../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
        var $TypeError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
        var $call = __webpack_require__("../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js");
        var $actualApply = __webpack_require__("../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js");
        module.exports = function(args) {
            if (args.length < 1 || 'function' != typeof args[0]) throw new $TypeError('a function is required');
            return $actualApply(bind, $call, args);
        };
    },
    "../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js": function(module) {
        "use strict";
        module.exports = 'undefined' != typeof Reflect && Reflect && Reflect.apply;
    },
    "../node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var GetIntrinsic = __webpack_require__("../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js");
        var callBindBasic = __webpack_require__("../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js");
        var $indexOf = callBindBasic([
            GetIntrinsic('%String.prototype.indexOf%')
        ]);
        module.exports = function(name, allowMissing) {
            var intrinsic = GetIntrinsic(name, !!allowMissing);
            if ('function' == typeof intrinsic && $indexOf(name, '.prototype.') > -1) return callBindBasic([
                intrinsic
            ]);
            return intrinsic;
        };
    },
    "../node_modules/.pnpm/content-disposition@0.5.4/node_modules/content-disposition/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = contentDisposition;
        module.exports.parse = parse;
        var basename = __webpack_require__("path").basename;
        var Buffer1 = __webpack_require__("../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer;
        var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
        var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
        var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
        var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
        var QESC_REGEXP = /\\([\u0000-\u007f])/g;
        var QUOTE_REGEXP = /([\\"])/g;
        var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
        var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
        var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
        var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
        var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
        function contentDisposition(filename, options) {
            var opts = options || {};
            var type = opts.type || 'attachment';
            var params = createparams(filename, opts.fallback);
            return format(new ContentDisposition(type, params));
        }
        function createparams(filename, fallback) {
            if (void 0 === filename) return;
            var params = {};
            if ('string' != typeof filename) throw new TypeError('filename must be a string');
            if (void 0 === fallback) fallback = true;
            if ('string' != typeof fallback && 'boolean' != typeof fallback) throw new TypeError('fallback must be a string or boolean');
            if ('string' == typeof fallback && NON_LATIN1_REGEXP.test(fallback)) throw new TypeError('fallback must be ISO-8859-1 string');
            var name = basename(filename);
            var isQuotedString = TEXT_REGEXP.test(name);
            var fallbackName = 'string' != typeof fallback ? fallback && getlatin1(name) : basename(fallback);
            var hasFallback = 'string' == typeof fallbackName && fallbackName !== name;
            if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) params['filename*'] = name;
            if (isQuotedString || hasFallback) params.filename = hasFallback ? fallbackName : name;
            return params;
        }
        function format(obj) {
            var parameters = obj.parameters;
            var type = obj.type;
            if (!type || 'string' != typeof type || !TOKEN_REGEXP.test(type)) throw new TypeError('invalid type');
            var string = String(type).toLowerCase();
            if (parameters && 'object' == typeof parameters) {
                var param;
                var params = Object.keys(parameters).sort();
                for(var i = 0; i < params.length; i++){
                    param = params[i];
                    var val = '*' === param.substr(-1) ? ustring(parameters[param]) : qstring(parameters[param]);
                    string += '; ' + param + '=' + val;
                }
            }
            return string;
        }
        function decodefield(str) {
            var match = EXT_VALUE_REGEXP.exec(str);
            if (!match) throw new TypeError('invalid extended field value');
            var charset = match[1].toLowerCase();
            var encoded = match[2];
            var value;
            var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
            switch(charset){
                case 'iso-8859-1':
                    value = getlatin1(binary);
                    break;
                case 'utf-8':
                    value = Buffer1.from(binary, 'binary').toString('utf8');
                    break;
                default:
                    throw new TypeError('unsupported charset in extended field');
            }
            return value;
        }
        function getlatin1(val) {
            return String(val).replace(NON_LATIN1_REGEXP, '?');
        }
        function parse(string) {
            if (!string || 'string' != typeof string) throw new TypeError('argument string is required');
            var match = DISPOSITION_TYPE_REGEXP.exec(string);
            if (!match) throw new TypeError('invalid type format');
            var index = match[0].length;
            var type = match[1].toLowerCase();
            var key;
            var names = [];
            var params = {};
            var value;
            index = PARAM_REGEXP.lastIndex = ';' === match[0].substr(-1) ? index - 1 : index;
            while(match = PARAM_REGEXP.exec(string)){
                if (match.index !== index) throw new TypeError('invalid parameter format');
                index += match[0].length;
                key = match[1].toLowerCase();
                value = match[2];
                if (-1 !== names.indexOf(key)) throw new TypeError('invalid duplicate parameter');
                names.push(key);
                if (key.indexOf('*') + 1 === key.length) {
                    key = key.slice(0, -1);
                    value = decodefield(value);
                    params[key] = value;
                    continue;
                }
                if ('string' == typeof params[key]) continue;
                if ('"' === value[0]) value = value.substr(1, value.length - 2).replace(QESC_REGEXP, '$1');
                params[key] = value;
            }
            if (-1 !== index && index !== string.length) throw new TypeError('invalid parameter format');
            return new ContentDisposition(type, params);
        }
        function pdecode(str, hex) {
            return String.fromCharCode(parseInt(hex, 16));
        }
        function pencode(char) {
            return '%' + String(char).charCodeAt(0).toString(16).toUpperCase();
        }
        function qstring(val) {
            var str = String(val);
            return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"';
        }
        function ustring(val) {
            var str = String(val);
            var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
            return 'UTF-8\'\'' + encoded;
        }
        function ContentDisposition(type, parameters) {
            this.type = type;
            this.parameters = parameters;
        }
    },
    "../node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js": function(__unused_webpack_module, exports1) {
        "use strict";
        /*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
        var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
        var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
        var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
        var QUOTE_REGEXP = /([\\"])/g;
        var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
        exports1.format = format;
        exports1.parse = parse;
        function format(obj) {
            if (!obj || 'object' != typeof obj) throw new TypeError('argument obj is required');
            var parameters = obj.parameters;
            var type = obj.type;
            if (!type || !TYPE_REGEXP.test(type)) throw new TypeError('invalid type');
            var string = type;
            if (parameters && 'object' == typeof parameters) {
                var param;
                var params = Object.keys(parameters).sort();
                for(var i = 0; i < params.length; i++){
                    param = params[i];
                    if (!TOKEN_REGEXP.test(param)) throw new TypeError('invalid parameter name');
                    string += '; ' + param + '=' + qstring(parameters[param]);
                }
            }
            return string;
        }
        function parse(string) {
            if (!string) throw new TypeError('argument string is required');
            var header = 'object' == typeof string ? getcontenttype(string) : string;
            if ('string' != typeof header) throw new TypeError('argument string is required to be a string');
            var index = header.indexOf(';');
            var type = -1 !== index ? header.slice(0, index).trim() : header.trim();
            if (!TYPE_REGEXP.test(type)) throw new TypeError('invalid media type');
            var obj = new ContentType(type.toLowerCase());
            if (-1 !== index) {
                var key;
                var match;
                var value;
                PARAM_REGEXP.lastIndex = index;
                while(match = PARAM_REGEXP.exec(header)){
                    if (match.index !== index) throw new TypeError('invalid parameter format');
                    index += match[0].length;
                    key = match[1].toLowerCase();
                    value = match[2];
                    if (0x22 === value.charCodeAt(0)) {
                        value = value.slice(1, -1);
                        if (-1 !== value.indexOf('\\')) value = value.replace(QESC_REGEXP, '$1');
                    }
                    obj.parameters[key] = value;
                }
                if (index !== header.length) throw new TypeError('invalid parameter format');
            }
            return obj;
        }
        function getcontenttype(obj) {
            var header;
            if ('function' == typeof obj.getHeader) header = obj.getHeader('content-type');
            else if ('object' == typeof obj.headers) header = obj.headers && obj.headers['content-type'];
            if ('string' != typeof header) throw new TypeError('content-type header is missing from object');
            return header;
        }
        function qstring(val) {
            var str = String(val);
            if (TOKEN_REGEXP.test(str)) return str;
            if (str.length > 0 && !TEXT_REGEXP.test(str)) throw new TypeError('invalid parameter value');
            return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"';
        }
        function ContentType(type) {
            this.parameters = Object.create(null);
            this.type = type;
        }
    },
    "../node_modules/.pnpm/cookie-signature@1.0.6/node_modules/cookie-signature/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        var crypto = __webpack_require__("crypto");
        exports1.sign = function(val, secret) {
            if ('string' != typeof val) throw new TypeError("Cookie value must be provided as a string.");
            if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
            return val + '.' + crypto.createHmac('sha256', secret).update(val).digest('base64').replace(/\=+$/, '');
        };
        exports1.unsign = function(val, secret) {
            if ('string' != typeof val) throw new TypeError("Signed cookie string must be provided.");
            if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
            var str = val.slice(0, val.lastIndexOf('.')), mac = exports1.sign(str, secret);
            return sha1(mac) == sha1(val) ? str : false;
        };
        function sha1(str) {
            return crypto.createHash('sha1').update(str).digest('hex');
        }
    },
    "../node_modules/.pnpm/cookie@0.7.1/node_modules/cookie/index.js": function(__unused_webpack_module, exports1) {
        "use strict";
        /*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ exports1.parse = parse;
        exports1.serialize = serialize;
        var __toString = Object.prototype.toString;
        var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
        var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;
        var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
        var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
        function parse(str, opt) {
            if ('string' != typeof str) throw new TypeError('argument str must be a string');
            var obj = {};
            var len = str.length;
            if (len < 2) return obj;
            var dec = opt && opt.decode || decode;
            var index = 0;
            var eqIdx = 0;
            var endIdx = 0;
            do {
                eqIdx = str.indexOf('=', index);
                if (-1 === eqIdx) break;
                endIdx = str.indexOf(';', index);
                if (-1 === endIdx) endIdx = len;
                else if (eqIdx > endIdx) {
                    index = str.lastIndexOf(';', eqIdx - 1) + 1;
                    continue;
                }
                var keyStartIdx = startIndex(str, index, eqIdx);
                var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
                var key = str.slice(keyStartIdx, keyEndIdx);
                if (!obj.hasOwnProperty(key)) {
                    var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
                    var valEndIdx = endIndex(str, endIdx, valStartIdx);
                    if (0x22 === str.charCodeAt(valStartIdx) && 0x22 === str.charCodeAt(valEndIdx - 1)) {
                        valStartIdx++;
                        valEndIdx--;
                    }
                    var val = str.slice(valStartIdx, valEndIdx);
                    obj[key] = tryDecode(val, dec);
                }
                index = endIdx + 1;
            }while (index < len);
            return obj;
        }
        function startIndex(str, index, max) {
            do {
                var code = str.charCodeAt(index);
                if (0x20 !== code && 0x09 !== code) return index;
            }while (++index < max);
            return max;
        }
        function endIndex(str, index, min) {
            while(index > min){
                var code = str.charCodeAt(--index);
                if (0x20 !== code && 0x09 !== code) return index + 1;
            }
            return min;
        }
        function serialize(name, val, opt) {
            var enc = opt && opt.encode || encodeURIComponent;
            if ('function' != typeof enc) throw new TypeError('option encode is invalid');
            if (!cookieNameRegExp.test(name)) throw new TypeError('argument name is invalid');
            var value = enc(val);
            if (!cookieValueRegExp.test(value)) throw new TypeError('argument val is invalid');
            var str = name + '=' + value;
            if (!opt) return str;
            if (null != opt.maxAge) {
                var maxAge = Math.floor(opt.maxAge);
                if (!isFinite(maxAge)) throw new TypeError('option maxAge is invalid');
                str += '; Max-Age=' + maxAge;
            }
            if (opt.domain) {
                if (!domainValueRegExp.test(opt.domain)) throw new TypeError('option domain is invalid');
                str += '; Domain=' + opt.domain;
            }
            if (opt.path) {
                if (!pathValueRegExp.test(opt.path)) throw new TypeError('option path is invalid');
                str += '; Path=' + opt.path;
            }
            if (opt.expires) {
                var expires = opt.expires;
                if (!isDate(expires) || isNaN(expires.valueOf())) throw new TypeError('option expires is invalid');
                str += '; Expires=' + expires.toUTCString();
            }
            if (opt.httpOnly) str += '; HttpOnly';
            if (opt.secure) str += '; Secure';
            if (opt.partitioned) str += '; Partitioned';
            if (opt.priority) {
                var priority = 'string' == typeof opt.priority ? opt.priority.toLowerCase() : opt.priority;
                switch(priority){
                    case 'low':
                        str += '; Priority=Low';
                        break;
                    case 'medium':
                        str += '; Priority=Medium';
                        break;
                    case 'high':
                        str += '; Priority=High';
                        break;
                    default:
                        throw new TypeError('option priority is invalid');
                }
            }
            if (opt.sameSite) {
                var sameSite = 'string' == typeof opt.sameSite ? opt.sameSite.toLowerCase() : opt.sameSite;
                switch(sameSite){
                    case true:
                        str += '; SameSite=Strict';
                        break;
                    case 'lax':
                        str += '; SameSite=Lax';
                        break;
                    case 'strict':
                        str += '; SameSite=Strict';
                        break;
                    case 'none':
                        str += '; SameSite=None';
                        break;
                    default:
                        throw new TypeError('option sameSite is invalid');
                }
            }
            return str;
        }
        function decode(str) {
            return -1 !== str.indexOf('%') ? decodeURIComponent(str) : str;
        }
        function isDate(val) {
            return '[object Date]' === __toString.call(val);
        }
        function tryDecode(str, decode) {
            try {
                return decode(str);
            } catch (e) {
                return str;
            }
        }
    },
    "../node_modules/.pnpm/cookie@0.7.2/node_modules/cookie/index.js": function(__unused_webpack_module, exports1) {
        "use strict";
        /*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ exports1.parse = parse;
        exports1.serialize = serialize;
        var __toString = Object.prototype.toString;
        var __hasOwnProperty = Object.prototype.hasOwnProperty;
        var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
        var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;
        var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
        var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
        function parse(str, opt) {
            if ('string' != typeof str) throw new TypeError('argument str must be a string');
            var obj = {};
            var len = str.length;
            if (len < 2) return obj;
            var dec = opt && opt.decode || decode;
            var index = 0;
            var eqIdx = 0;
            var endIdx = 0;
            do {
                eqIdx = str.indexOf('=', index);
                if (-1 === eqIdx) break;
                endIdx = str.indexOf(';', index);
                if (-1 === endIdx) endIdx = len;
                else if (eqIdx > endIdx) {
                    index = str.lastIndexOf(';', eqIdx - 1) + 1;
                    continue;
                }
                var keyStartIdx = startIndex(str, index, eqIdx);
                var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
                var key = str.slice(keyStartIdx, keyEndIdx);
                if (!__hasOwnProperty.call(obj, key)) {
                    var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
                    var valEndIdx = endIndex(str, endIdx, valStartIdx);
                    if (0x22 === str.charCodeAt(valStartIdx) && 0x22 === str.charCodeAt(valEndIdx - 1)) {
                        valStartIdx++;
                        valEndIdx--;
                    }
                    var val = str.slice(valStartIdx, valEndIdx);
                    obj[key] = tryDecode(val, dec);
                }
                index = endIdx + 1;
            }while (index < len);
            return obj;
        }
        function startIndex(str, index, max) {
            do {
                var code = str.charCodeAt(index);
                if (0x20 !== code && 0x09 !== code) return index;
            }while (++index < max);
            return max;
        }
        function endIndex(str, index, min) {
            while(index > min){
                var code = str.charCodeAt(--index);
                if (0x20 !== code && 0x09 !== code) return index + 1;
            }
            return min;
        }
        function serialize(name, val, opt) {
            var enc = opt && opt.encode || encodeURIComponent;
            if ('function' != typeof enc) throw new TypeError('option encode is invalid');
            if (!cookieNameRegExp.test(name)) throw new TypeError('argument name is invalid');
            var value = enc(val);
            if (!cookieValueRegExp.test(value)) throw new TypeError('argument val is invalid');
            var str = name + '=' + value;
            if (!opt) return str;
            if (null != opt.maxAge) {
                var maxAge = Math.floor(opt.maxAge);
                if (!isFinite(maxAge)) throw new TypeError('option maxAge is invalid');
                str += '; Max-Age=' + maxAge;
            }
            if (opt.domain) {
                if (!domainValueRegExp.test(opt.domain)) throw new TypeError('option domain is invalid');
                str += '; Domain=' + opt.domain;
            }
            if (opt.path) {
                if (!pathValueRegExp.test(opt.path)) throw new TypeError('option path is invalid');
                str += '; Path=' + opt.path;
            }
            if (opt.expires) {
                var expires = opt.expires;
                if (!isDate(expires) || isNaN(expires.valueOf())) throw new TypeError('option expires is invalid');
                str += '; Expires=' + expires.toUTCString();
            }
            if (opt.httpOnly) str += '; HttpOnly';
            if (opt.secure) str += '; Secure';
            if (opt.partitioned) str += '; Partitioned';
            if (opt.priority) {
                var priority = 'string' == typeof opt.priority ? opt.priority.toLowerCase() : opt.priority;
                switch(priority){
                    case 'low':
                        str += '; Priority=Low';
                        break;
                    case 'medium':
                        str += '; Priority=Medium';
                        break;
                    case 'high':
                        str += '; Priority=High';
                        break;
                    default:
                        throw new TypeError('option priority is invalid');
                }
            }
            if (opt.sameSite) {
                var sameSite = 'string' == typeof opt.sameSite ? opt.sameSite.toLowerCase() : opt.sameSite;
                switch(sameSite){
                    case true:
                        str += '; SameSite=Strict';
                        break;
                    case 'lax':
                        str += '; SameSite=Lax';
                        break;
                    case 'strict':
                        str += '; SameSite=Strict';
                        break;
                    case 'none':
                        str += '; SameSite=None';
                        break;
                    default:
                        throw new TypeError('option sameSite is invalid');
                }
            }
            return str;
        }
        function decode(str) {
            return -1 !== str.indexOf('%') ? decodeURIComponent(str) : str;
        }
        function isDate(val) {
            return '[object Date]' === __toString.call(val);
        }
        function tryDecode(str, decode) {
            try {
                return decode(str);
            } catch (e) {
                return str;
            }
        }
    },
    "../node_modules/.pnpm/cors@2.8.5/node_modules/cors/lib/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        (function() {
            'use strict';
            var assign = __webpack_require__("../node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js");
            var vary = __webpack_require__("../node_modules/.pnpm/vary@1.1.2/node_modules/vary/index.js");
            var defaults = {
                origin: '*',
                methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
                preflightContinue: false,
                optionsSuccessStatus: 204
            };
            function isString(s) {
                return 'string' == typeof s || s instanceof String;
            }
            function isOriginAllowed(origin, allowedOrigin) {
                if (Array.isArray(allowedOrigin)) {
                    for(var i = 0; i < allowedOrigin.length; ++i)if (isOriginAllowed(origin, allowedOrigin[i])) return true;
                    return false;
                }
                if (isString(allowedOrigin)) return origin === allowedOrigin;
                if (allowedOrigin instanceof RegExp) return allowedOrigin.test(origin);
                return !!allowedOrigin;
            }
            function configureOrigin(options, req) {
                var requestOrigin = req.headers.origin, headers = [], isAllowed;
                if (options.origin && '*' !== options.origin) if (isString(options.origin)) {
                    headers.push([
                        {
                            key: 'Access-Control-Allow-Origin',
                            value: options.origin
                        }
                    ]);
                    headers.push([
                        {
                            key: 'Vary',
                            value: 'Origin'
                        }
                    ]);
                } else {
                    isAllowed = isOriginAllowed(requestOrigin, options.origin);
                    headers.push([
                        {
                            key: 'Access-Control-Allow-Origin',
                            value: isAllowed ? requestOrigin : false
                        }
                    ]);
                    headers.push([
                        {
                            key: 'Vary',
                            value: 'Origin'
                        }
                    ]);
                }
                else headers.push([
                    {
                        key: 'Access-Control-Allow-Origin',
                        value: '*'
                    }
                ]);
                return headers;
            }
            function configureMethods(options) {
                var methods = options.methods;
                if (methods.join) methods = options.methods.join(',');
                return {
                    key: 'Access-Control-Allow-Methods',
                    value: methods
                };
            }
            function configureCredentials(options) {
                if (true === options.credentials) return {
                    key: 'Access-Control-Allow-Credentials',
                    value: 'true'
                };
                return null;
            }
            function configureAllowedHeaders(options, req) {
                var allowedHeaders = options.allowedHeaders || options.headers;
                var headers = [];
                if (allowedHeaders) {
                    if (allowedHeaders.join) allowedHeaders = allowedHeaders.join(',');
                } else {
                    allowedHeaders = req.headers['access-control-request-headers'];
                    headers.push([
                        {
                            key: 'Vary',
                            value: 'Access-Control-Request-Headers'
                        }
                    ]);
                }
                if (allowedHeaders && allowedHeaders.length) headers.push([
                    {
                        key: 'Access-Control-Allow-Headers',
                        value: allowedHeaders
                    }
                ]);
                return headers;
            }
            function configureExposedHeaders(options) {
                var headers = options.exposedHeaders;
                if (!headers) return null;
                if (headers.join) headers = headers.join(',');
                if (headers && headers.length) return {
                    key: 'Access-Control-Expose-Headers',
                    value: headers
                };
                return null;
            }
            function configureMaxAge(options) {
                var maxAge = ('number' == typeof options.maxAge || options.maxAge) && options.maxAge.toString();
                if (maxAge && maxAge.length) return {
                    key: 'Access-Control-Max-Age',
                    value: maxAge
                };
                return null;
            }
            function applyHeaders(headers, res) {
                for(var i = 0, n = headers.length; i < n; i++){
                    var header = headers[i];
                    if (header) {
                        if (Array.isArray(header)) applyHeaders(header, res);
                        else if ('Vary' === header.key && header.value) vary(res, header.value);
                        else if (header.value) res.setHeader(header.key, header.value);
                    }
                }
            }
            function cors(options, req, res, next) {
                var headers = [], method = req.method && req.method.toUpperCase && req.method.toUpperCase();
                if ('OPTIONS' === method) {
                    headers.push(configureOrigin(options, req));
                    headers.push(configureCredentials(options, req));
                    headers.push(configureMethods(options, req));
                    headers.push(configureAllowedHeaders(options, req));
                    headers.push(configureMaxAge(options, req));
                    headers.push(configureExposedHeaders(options, req));
                    applyHeaders(headers, res);
                    if (options.preflightContinue) next();
                    else {
                        res.statusCode = options.optionsSuccessStatus;
                        res.setHeader('Content-Length', '0');
                        res.end();
                    }
                } else {
                    headers.push(configureOrigin(options, req));
                    headers.push(configureCredentials(options, req));
                    headers.push(configureExposedHeaders(options, req));
                    applyHeaders(headers, res);
                    next();
                }
            }
            function middlewareWrapper(o) {
                var optionsCallback = null;
                optionsCallback = 'function' == typeof o ? o : function(req, cb) {
                    cb(null, o);
                };
                return function(req, res, next) {
                    optionsCallback(req, function(err, options) {
                        if (err) next(err);
                        else {
                            var corsOptions = assign({}, defaults, options);
                            var originCallback = null;
                            if (corsOptions.origin && 'function' == typeof corsOptions.origin) originCallback = corsOptions.origin;
                            else if (corsOptions.origin) originCallback = function(origin, cb) {
                                cb(null, corsOptions.origin);
                            };
                            if (originCallback) originCallback(req.headers.origin, function(err2, origin) {
                                if (err2 || !origin) next(err2);
                                else {
                                    corsOptions.origin = origin;
                                    cors(corsOptions, req, res, next);
                                }
                            });
                            else next();
                        }
                    });
                };
            }
            module.exports = middlewareWrapper;
        })();
    },
    "../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/browser.js": function(module, exports1, __webpack_require__) {
        exports1 = module.exports = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/debug.js");
        exports1.log = log;
        exports1.formatArgs = formatArgs;
        exports1.save = save;
        exports1.load = load;
        exports1.useColors = useColors;
        exports1.storage = 'undefined' != typeof chrome && void 0 !== chrome.storage ? chrome.storage.local : localstorage();
        exports1.colors = [
            'lightseagreen',
            'forestgreen',
            'goldenrod',
            'dodgerblue',
            'darkorchid',
            'crimson'
        ];
        function useColors() {
            if ('undefined' != typeof window && window.process && 'renderer' === window.process.type) return true;
            return 'undefined' != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || 'undefined' != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || 'undefined' != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || 'undefined' != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        exports1.formatters.j = function(v) {
            try {
                return JSON.stringify(v);
            } catch (err) {
                return '[UnexpectedJSONParseError]: ' + err.message;
            }
        };
        function formatArgs(args) {
            var useColors = this.useColors;
            args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports1.humanize(this.diff);
            if (!useColors) return;
            var c = 'color: ' + this.color;
            args.splice(1, 0, c, 'color: inherit');
            var index = 0;
            var lastC = 0;
            args[0].replace(/%[a-zA-Z%]/g, function(match) {
                if ('%%' === match) return;
                index++;
                if ('%c' === match) lastC = index;
            });
            args.splice(lastC, 0, c);
        }
        function log() {
            return 'object' == typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
        }
        function save(namespaces) {
            try {
                if (null == namespaces) exports1.storage.removeItem('debug');
                else exports1.storage.debug = namespaces;
            } catch (e) {}
        }
        function load() {
            var r;
            try {
                r = exports1.storage.debug;
            } catch (e) {}
            if (!r && 'undefined' != typeof process && 'env' in process) r = process.env.DEBUG;
            return r;
        }
        exports1.enable(load());
        function localstorage() {
            try {
                return window.localStorage;
            } catch (e) {}
        }
    },
    "../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/debug.js": function(module, exports1, __webpack_require__) {
        exports1 = module.exports = createDebug.debug = createDebug['default'] = createDebug;
        exports1.coerce = coerce;
        exports1.disable = disable;
        exports1.enable = enable;
        exports1.enabled = enabled;
        exports1.humanize = __webpack_require__("../node_modules/.pnpm/ms@2.0.0/node_modules/ms/index.js");
        exports1.names = [];
        exports1.skips = [];
        exports1.formatters = {};
        var prevTime;
        function selectColor(namespace) {
            var hash = 0, i;
            for(i in namespace){
                hash = (hash << 5) - hash + namespace.charCodeAt(i);
                hash |= 0;
            }
            return exports1.colors[Math.abs(hash) % exports1.colors.length];
        }
        function createDebug(namespace) {
            function debug() {
                if (!debug.enabled) return;
                var self = debug;
                var curr = +new Date();
                var ms = curr - (prevTime || curr);
                self.diff = ms;
                self.prev = prevTime;
                self.curr = curr;
                prevTime = curr;
                var args = new Array(arguments.length);
                for(var i = 0; i < args.length; i++)args[i] = arguments[i];
                args[0] = exports1.coerce(args[0]);
                if ('string' != typeof args[0]) args.unshift('%O');
                var index = 0;
                args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
                    if ('%%' === match) return match;
                    index++;
                    var formatter = exports1.formatters[format];
                    if ('function' == typeof formatter) {
                        var val = args[index];
                        match = formatter.call(self, val);
                        args.splice(index, 1);
                        index--;
                    }
                    return match;
                });
                exports1.formatArgs.call(self, args);
                var logFn = debug.log || exports1.log || console.log.bind(console);
                logFn.apply(self, args);
            }
            debug.namespace = namespace;
            debug.enabled = exports1.enabled(namespace);
            debug.useColors = exports1.useColors();
            debug.color = selectColor(namespace);
            if ('function' == typeof exports1.init) exports1.init(debug);
            return debug;
        }
        function enable(namespaces) {
            exports1.save(namespaces);
            exports1.names = [];
            exports1.skips = [];
            var split = ('string' == typeof namespaces ? namespaces : '').split(/[\s,]+/);
            var len = split.length;
            for(var i = 0; i < len; i++)if (split[i]) {
                namespaces = split[i].replace(/\*/g, '.*?');
                if ('-' === namespaces[0]) exports1.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
                else exports1.names.push(new RegExp('^' + namespaces + '$'));
            }
        }
        function disable() {
            exports1.enable('');
        }
        function enabled(name) {
            var i, len;
            for(i = 0, len = exports1.skips.length; i < len; i++)if (exports1.skips[i].test(name)) return false;
            for(i = 0, len = exports1.names.length; i < len; i++)if (exports1.names[i].test(name)) return true;
            return false;
        }
        function coerce(val) {
            if (val instanceof Error) return val.stack || val.message;
            return val;
        }
    },
    "../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        if ('undefined' != typeof process && 'renderer' === process.type) module.exports = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/browser.js");
        else module.exports = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/node.js");
    },
    "../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/node.js": function(module, exports1, __webpack_require__) {
        var tty = __webpack_require__("tty");
        var util = __webpack_require__("util");
        exports1 = module.exports = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/debug.js");
        exports1.init = init;
        exports1.log = log;
        exports1.formatArgs = formatArgs;
        exports1.save = save;
        exports1.load = load;
        exports1.useColors = useColors;
        exports1.colors = [
            6,
            2,
            3,
            4,
            5,
            1
        ];
        exports1.inspectOpts = Object.keys(process.env).filter(function(key) {
            return /^debug_/i.test(key);
        }).reduce(function(obj, key) {
            var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
                return k.toUpperCase();
            });
            var val = process.env[key];
            val = /^(yes|on|true|enabled)$/i.test(val) ? true : /^(no|off|false|disabled)$/i.test(val) ? false : 'null' === val ? null : Number(val);
            obj[prop] = val;
            return obj;
        }, {});
        var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
        if (1 !== fd && 2 !== fd) util.deprecate(function() {}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();
        var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
        function useColors() {
            return 'colors' in exports1.inspectOpts ? Boolean(exports1.inspectOpts.colors) : tty.isatty(fd);
        }
        exports1.formatters.o = function(v) {
            this.inspectOpts.colors = this.useColors;
            return util.inspect(v, this.inspectOpts).split('\n').map(function(str) {
                return str.trim();
            }).join(' ');
        };
        exports1.formatters.O = function(v) {
            this.inspectOpts.colors = this.useColors;
            return util.inspect(v, this.inspectOpts);
        };
        function formatArgs(args) {
            var name = this.namespace;
            var useColors = this.useColors;
            if (useColors) {
                var c = this.color;
                var prefix = '  \u001b[3' + c + ';1m' + name + " \x1b[0m";
                args[0] = prefix + args[0].split('\n').join('\n' + prefix);
                args.push('\u001b[3' + c + 'm+' + exports1.humanize(this.diff) + '\u001b[0m');
            } else args[0] = new Date().toUTCString() + ' ' + name + ' ' + args[0];
        }
        function log() {
            return stream.write(util.format.apply(util, arguments) + '\n');
        }
        function save(namespaces) {
            if (null == namespaces) delete process.env.DEBUG;
            else process.env.DEBUG = namespaces;
        }
        function load() {
            return process.env.DEBUG;
        }
        function createWritableStdioStream(fd) {
            var stream;
            var tty_wrap = process.binding('tty_wrap');
            switch(tty_wrap.guessHandleType(fd)){
                case 'TTY':
                    stream = new tty.WriteStream(fd);
                    stream._type = 'tty';
                    if (stream._handle && stream._handle.unref) stream._handle.unref();
                    break;
                case 'FILE':
                    var fs = __webpack_require__("fs");
                    stream = new fs.SyncWriteStream(fd, {
                        autoClose: false
                    });
                    stream._type = 'fs';
                    break;
                case 'PIPE':
                case 'TCP':
                    var net = __webpack_require__("net");
                    stream = new net.Socket({
                        fd: fd,
                        readable: false,
                        writable: true
                    });
                    stream.readable = false;
                    stream.read = null;
                    stream._type = 'pipe';
                    if (stream._handle && stream._handle.unref) stream._handle.unref();
                    break;
                default:
                    throw new Error('Implement me. Unknown stream file type!');
            }
            stream.fd = fd;
            stream._isStdio = true;
            return stream;
        }
        function init(debug) {
            debug.inspectOpts = {};
            var keys = Object.keys(exports1.inspectOpts);
            for(var i = 0; i < keys.length; i++)debug.inspectOpts[keys[i]] = exports1.inspectOpts[keys[i]];
        }
        exports1.enable(load());
    },
    "../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/browser.js": function(module, exports1, __webpack_require__) {
        exports1.formatArgs = formatArgs;
        exports1.save = save;
        exports1.load = load;
        exports1.useColors = useColors;
        exports1.storage = localstorage();
        exports1.destroy = (()=>{
            let warned = false;
            return ()=>{
                if (!warned) {
                    warned = true;
                    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
                }
            };
        })();
        exports1.colors = [
            '#0000CC',
            '#0000FF',
            '#0033CC',
            '#0033FF',
            '#0066CC',
            '#0066FF',
            '#0099CC',
            '#0099FF',
            '#00CC00',
            '#00CC33',
            '#00CC66',
            '#00CC99',
            '#00CCCC',
            '#00CCFF',
            '#3300CC',
            '#3300FF',
            '#3333CC',
            '#3333FF',
            '#3366CC',
            '#3366FF',
            '#3399CC',
            '#3399FF',
            '#33CC00',
            '#33CC33',
            '#33CC66',
            '#33CC99',
            '#33CCCC',
            '#33CCFF',
            '#6600CC',
            '#6600FF',
            '#6633CC',
            '#6633FF',
            '#66CC00',
            '#66CC33',
            '#9900CC',
            '#9900FF',
            '#9933CC',
            '#9933FF',
            '#99CC00',
            '#99CC33',
            '#CC0000',
            '#CC0033',
            '#CC0066',
            '#CC0099',
            '#CC00CC',
            '#CC00FF',
            '#CC3300',
            '#CC3333',
            '#CC3366',
            '#CC3399',
            '#CC33CC',
            '#CC33FF',
            '#CC6600',
            '#CC6633',
            '#CC9900',
            '#CC9933',
            '#CCCC00',
            '#CCCC33',
            '#FF0000',
            '#FF0033',
            '#FF0066',
            '#FF0099',
            '#FF00CC',
            '#FF00FF',
            '#FF3300',
            '#FF3333',
            '#FF3366',
            '#FF3399',
            '#FF33CC',
            '#FF33FF',
            '#FF6600',
            '#FF6633',
            '#FF9900',
            '#FF9933',
            '#FFCC00',
            '#FFCC33'
        ];
        function useColors() {
            if ('undefined' != typeof window && window.process && ('renderer' === window.process.type || window.process.__nwjs)) return true;
            if ('undefined' != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
            let m;
            return 'undefined' != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || 'undefined' != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || 'undefined' != typeof navigator && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || 'undefined' != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        function formatArgs(args) {
            args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
            if (!this.useColors) return;
            const c = 'color: ' + this.color;
            args.splice(1, 0, c, 'color: inherit');
            let index = 0;
            let lastC = 0;
            args[0].replace(/%[a-zA-Z%]/g, (match)=>{
                if ('%%' === match) return;
                index++;
                if ('%c' === match) lastC = index;
            });
            args.splice(lastC, 0, c);
        }
        exports1.log = console.debug || console.log || (()=>{});
        function save(namespaces) {
            try {
                if (namespaces) exports1.storage.setItem('debug', namespaces);
                else exports1.storage.removeItem('debug');
            } catch (error) {}
        }
        function load() {
            let r;
            try {
                r = exports1.storage.getItem('debug');
            } catch (error) {}
            if (!r && 'undefined' != typeof process && 'env' in process) r = process.env.DEBUG;
            return r;
        }
        function localstorage() {
            try {
                return localStorage;
            } catch (error) {}
        }
        module.exports = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/common.js")(exports1);
        const { formatters } = module.exports;
        formatters.j = function(v) {
            try {
                return JSON.stringify(v);
            } catch (error) {
                return '[UnexpectedJSONParseError]: ' + error.message;
            }
        };
    },
    "../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/common.js": function(module, __unused_webpack_exports, __webpack_require__) {
        function setup(env) {
            createDebug.debug = createDebug;
            createDebug.default = createDebug;
            createDebug.coerce = coerce;
            createDebug.disable = disable;
            createDebug.enable = enable;
            createDebug.enabled = enabled;
            createDebug.humanize = __webpack_require__("../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js");
            createDebug.destroy = destroy;
            Object.keys(env).forEach((key)=>{
                createDebug[key] = env[key];
            });
            createDebug.names = [];
            createDebug.skips = [];
            createDebug.formatters = {};
            function selectColor(namespace) {
                let hash = 0;
                for(let i = 0; i < namespace.length; i++){
                    hash = (hash << 5) - hash + namespace.charCodeAt(i);
                    hash |= 0;
                }
                return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
            }
            createDebug.selectColor = selectColor;
            function createDebug(namespace) {
                let prevTime;
                let enableOverride = null;
                let namespacesCache;
                let enabledCache;
                function debug(...args) {
                    if (!debug.enabled) return;
                    const self = debug;
                    const curr = Number(new Date());
                    const ms = curr - (prevTime || curr);
                    self.diff = ms;
                    self.prev = prevTime;
                    self.curr = curr;
                    prevTime = curr;
                    args[0] = createDebug.coerce(args[0]);
                    if ('string' != typeof args[0]) args.unshift('%O');
                    let index = 0;
                    args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                        if ('%%' === match) return '%';
                        index++;
                        const formatter = createDebug.formatters[format];
                        if ('function' == typeof formatter) {
                            const val = args[index];
                            match = formatter.call(self, val);
                            args.splice(index, 1);
                            index--;
                        }
                        return match;
                    });
                    createDebug.formatArgs.call(self, args);
                    const logFn = self.log || createDebug.log;
                    logFn.apply(self, args);
                }
                debug.namespace = namespace;
                debug.useColors = createDebug.useColors();
                debug.color = createDebug.selectColor(namespace);
                debug.extend = extend;
                debug.destroy = createDebug.destroy;
                Object.defineProperty(debug, 'enabled', {
                    enumerable: true,
                    configurable: false,
                    get: ()=>{
                        if (null !== enableOverride) return enableOverride;
                        if (namespacesCache !== createDebug.namespaces) {
                            namespacesCache = createDebug.namespaces;
                            enabledCache = createDebug.enabled(namespace);
                        }
                        return enabledCache;
                    },
                    set: (v)=>{
                        enableOverride = v;
                    }
                });
                if ('function' == typeof createDebug.init) createDebug.init(debug);
                return debug;
            }
            function extend(namespace, delimiter) {
                const newDebug = createDebug(this.namespace + (void 0 === delimiter ? ':' : delimiter) + namespace);
                newDebug.log = this.log;
                return newDebug;
            }
            function enable(namespaces) {
                createDebug.save(namespaces);
                createDebug.namespaces = namespaces;
                createDebug.names = [];
                createDebug.skips = [];
                let i;
                const split = ('string' == typeof namespaces ? namespaces : '').split(/[\s,]+/);
                const len = split.length;
                for(i = 0; i < len; i++)if (split[i]) {
                    namespaces = split[i].replace(/\*/g, '.*?');
                    if ('-' === namespaces[0]) createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
                    else createDebug.names.push(new RegExp('^' + namespaces + '$'));
                }
            }
            function disable() {
                const namespaces = [
                    ...createDebug.names.map(toNamespace),
                    ...createDebug.skips.map(toNamespace).map((namespace)=>'-' + namespace)
                ].join(',');
                createDebug.enable('');
                return namespaces;
            }
            function enabled(name) {
                if ('*' === name[name.length - 1]) return true;
                let i;
                let len;
                for(i = 0, len = createDebug.skips.length; i < len; i++)if (createDebug.skips[i].test(name)) return false;
                for(i = 0, len = createDebug.names.length; i < len; i++)if (createDebug.names[i].test(name)) return true;
                return false;
            }
            function toNamespace(regexp) {
                return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
            }
            function coerce(val) {
                if (val instanceof Error) return val.stack || val.message;
                return val;
            }
            function destroy() {
                console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
            }
            createDebug.enable(createDebug.load());
            return createDebug;
        }
        module.exports = setup;
    },
    "../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        if ('undefined' == typeof process || 'renderer' === process.type || true === process.browser || process.__nwjs) module.exports = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/browser.js");
        else module.exports = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/node.js");
    },
    "../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/node.js": function(module, exports1, __webpack_require__) {
        const tty = __webpack_require__("tty");
        const util = __webpack_require__("util");
        exports1.init = init;
        exports1.log = log;
        exports1.formatArgs = formatArgs;
        exports1.save = save;
        exports1.load = load;
        exports1.useColors = useColors;
        exports1.destroy = util.deprecate(()=>{}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        exports1.colors = [
            6,
            2,
            3,
            4,
            5,
            1
        ];
        try {
            const supportsColor = __webpack_require__("../node_modules/.pnpm/supports-color@5.5.0/node_modules/supports-color/index.js");
            if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) exports1.colors = [
                20,
                21,
                26,
                27,
                32,
                33,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                56,
                57,
                62,
                63,
                68,
                69,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                92,
                93,
                98,
                99,
                112,
                113,
                128,
                129,
                134,
                135,
                148,
                149,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                178,
                179,
                184,
                185,
                196,
                197,
                198,
                199,
                200,
                201,
                202,
                203,
                204,
                205,
                206,
                207,
                208,
                209,
                214,
                215,
                220,
                221
            ];
        } catch (error) {}
        exports1.inspectOpts = Object.keys(process.env).filter((key)=>/^debug_/i.test(key)).reduce((obj, key)=>{
            const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>k.toUpperCase());
            let val = process.env[key];
            val = /^(yes|on|true|enabled)$/i.test(val) ? true : /^(no|off|false|disabled)$/i.test(val) ? false : 'null' === val ? null : Number(val);
            obj[prop] = val;
            return obj;
        }, {});
        function useColors() {
            return 'colors' in exports1.inspectOpts ? Boolean(exports1.inspectOpts.colors) : tty.isatty(process.stderr.fd);
        }
        function formatArgs(args) {
            const { namespace: name, useColors } = this;
            if (useColors) {
                const c = this.color;
                const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
                const prefix = `  ${colorCode};1m${name} \u001B[0m`;
                args[0] = prefix + args[0].split('\n').join('\n' + prefix);
                args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
            } else args[0] = getDate() + name + ' ' + args[0];
        }
        function getDate() {
            if (exports1.inspectOpts.hideDate) return '';
            return new Date().toISOString() + ' ';
        }
        function log(...args) {
            return process.stderr.write(util.formatWithOptions(exports1.inspectOpts, ...args) + '\n');
        }
        function save(namespaces) {
            if (namespaces) process.env.DEBUG = namespaces;
            else delete process.env.DEBUG;
        }
        function load() {
            return process.env.DEBUG;
        }
        function init(debug) {
            debug.inspectOpts = {};
            const keys = Object.keys(exports1.inspectOpts);
            for(let i = 0; i < keys.length; i++)debug.inspectOpts[keys[i]] = exports1.inspectOpts[keys[i]];
        }
        module.exports = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/common.js")(exports1);
        const { formatters } = module.exports;
        formatters.o = function(v) {
            this.inspectOpts.colors = this.useColors;
            return util.inspect(v, this.inspectOpts).split('\n').map((str)=>str.trim()).join(' ');
        };
        formatters.O = function(v) {
            this.inspectOpts.colors = this.useColors;
            return util.inspect(v, this.inspectOpts);
        };
    },
    "../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        /*!
 * depd
 * Copyright(c) 2014-2018 Douglas Christopher Wilson
 * MIT Licensed
 */ var relative = __webpack_require__("path").relative;
        module.exports = depd;
        var basePath = process.cwd();
        function containsNamespace(str, namespace) {
            var vals = str.split(/[ ,]+/);
            var ns = String(namespace).toLowerCase();
            for(var i = 0; i < vals.length; i++){
                var val = vals[i];
                if (val && ('*' === val || val.toLowerCase() === ns)) return true;
            }
            return false;
        }
        function convertDataDescriptorToAccessor(obj, prop, message) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            var value = descriptor.value;
            descriptor.get = function() {
                return value;
            };
            if (descriptor.writable) descriptor.set = function(val) {
                return value = val;
            };
            delete descriptor.value;
            delete descriptor.writable;
            Object.defineProperty(obj, prop, descriptor);
            return descriptor;
        }
        function createArgumentsString(arity) {
            var str = '';
            for(var i = 0; i < arity; i++)str += ', arg' + i;
            return str.substr(2);
        }
        function createStackString(stack) {
            var str = this.name + ': ' + this.namespace;
            if (this.message) str += ' deprecated ' + this.message;
            for(var i = 0; i < stack.length; i++)str += '\n    at ' + stack[i].toString();
            return str;
        }
        function depd(namespace) {
            if (!namespace) throw new TypeError('argument namespace is required');
            var stack = getStack();
            var site = callSiteLocation(stack[1]);
            var file = site[0];
            function deprecate(message) {
                log.call(deprecate, message);
            }
            deprecate._file = file;
            deprecate._ignored = isignored(namespace);
            deprecate._namespace = namespace;
            deprecate._traced = istraced(namespace);
            deprecate._warned = Object.create(null);
            deprecate.function = wrapfunction;
            deprecate.property = wrapproperty;
            return deprecate;
        }
        function eehaslisteners(emitter, type) {
            var count = 'function' != typeof emitter.listenerCount ? emitter.listeners(type).length : emitter.listenerCount(type);
            return count > 0;
        }
        function isignored(namespace) {
            if (process.noDeprecation) return true;
            var str = process.env.NO_DEPRECATION || '';
            return containsNamespace(str, namespace);
        }
        function istraced(namespace) {
            if (process.traceDeprecation) return true;
            var str = process.env.TRACE_DEPRECATION || '';
            return containsNamespace(str, namespace);
        }
        function log(message, site) {
            var haslisteners = eehaslisteners(process, 'deprecation');
            if (!haslisteners && this._ignored) return;
            var caller;
            var callFile;
            var callSite;
            var depSite;
            var i = 0;
            var seen = false;
            var stack = getStack();
            var file = this._file;
            if (site) {
                depSite = site;
                callSite = callSiteLocation(stack[1]);
                callSite.name = depSite.name;
                file = callSite[0];
            } else {
                i = 2;
                depSite = callSiteLocation(stack[i]);
                callSite = depSite;
            }
            for(; i < stack.length; i++){
                caller = callSiteLocation(stack[i]);
                callFile = caller[0];
                if (callFile === file) seen = true;
                else if (callFile === this._file) file = this._file;
                else if (seen) break;
            }
            var key = caller ? depSite.join(':') + '__' + caller.join(':') : void 0;
            if (void 0 !== key && key in this._warned) return;
            this._warned[key] = true;
            var msg = message;
            if (!msg) msg = callSite !== depSite && callSite.name ? defaultMessage(callSite) : defaultMessage(depSite);
            if (haslisteners) {
                var err = DeprecationError(this._namespace, msg, stack.slice(i));
                process.emit('deprecation', err);
                return;
            }
            var format = process.stderr.isTTY ? formatColor : formatPlain;
            var output = format.call(this, msg, caller, stack.slice(i));
            process.stderr.write(output + '\n', 'utf8');
        }
        function callSiteLocation(callSite) {
            var file = callSite.getFileName() || '<anonymous>';
            var line = callSite.getLineNumber();
            var colm = callSite.getColumnNumber();
            if (callSite.isEval()) file = callSite.getEvalOrigin() + ', ' + file;
            var site = [
                file,
                line,
                colm
            ];
            site.callSite = callSite;
            site.name = callSite.getFunctionName();
            return site;
        }
        function defaultMessage(site) {
            var callSite = site.callSite;
            var funcName = site.name;
            if (!funcName) funcName = '<anonymous@' + formatLocation(site) + '>';
            var context = callSite.getThis();
            var typeName = context && callSite.getTypeName();
            if ('Object' === typeName) typeName = void 0;
            if ('Function' === typeName) typeName = context.name || typeName;
            return typeName && callSite.getMethodName() ? typeName + '.' + funcName : funcName;
        }
        function formatPlain(msg, caller, stack) {
            var timestamp = new Date().toUTCString();
            var formatted = timestamp + ' ' + this._namespace + ' deprecated ' + msg;
            if (this._traced) {
                for(var i = 0; i < stack.length; i++)formatted += '\n    at ' + stack[i].toString();
                return formatted;
            }
            if (caller) formatted += ' at ' + formatLocation(caller);
            return formatted;
        }
        function formatColor(msg, caller, stack) {
            var formatted = '\x1b[36;1m' + this._namespace + "\x1b[22;39m \x1b[33;1mdeprecated\x1b[22;39m \x1b[0m" + msg + '\x1b[39m';
            if (this._traced) {
                for(var i = 0; i < stack.length; i++)formatted += '\n    \x1b[36mat ' + stack[i].toString() + '\x1b[39m';
                return formatted;
            }
            if (caller) formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m';
            return formatted;
        }
        function formatLocation(callSite) {
            return relative(basePath, callSite[0]) + ':' + callSite[1] + ':' + callSite[2];
        }
        function getStack() {
            var limit = Error.stackTraceLimit;
            var obj = {};
            var prep = Error.prepareStackTrace;
            Error.prepareStackTrace = prepareObjectStackTrace;
            Error.stackTraceLimit = Math.max(10, limit);
            Error.captureStackTrace(obj);
            var stack = obj.stack.slice(1);
            Error.prepareStackTrace = prep;
            Error.stackTraceLimit = limit;
            return stack;
        }
        function prepareObjectStackTrace(obj, stack) {
            return stack;
        }
        function wrapfunction(fn, message) {
            if ('function' != typeof fn) throw new TypeError('argument fn must be a function');
            var args = createArgumentsString(fn.length);
            var stack = getStack();
            var site = callSiteLocation(stack[1]);
            site.name = fn.name;
            var deprecatedfn = new Function('fn', 'log', 'deprecate', 'message', 'site', '"use strict"\nreturn function (' + args + ") {log.call(deprecate, message, site)\nreturn fn.apply(this, arguments)\n}")(fn, log, this, message, site);
            return deprecatedfn;
        }
        function wrapproperty(obj, prop, message) {
            if (!obj || 'object' != typeof obj && 'function' != typeof obj) throw new TypeError('argument obj must be object');
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            if (!descriptor) throw new TypeError('must call property on owner object');
            if (!descriptor.configurable) throw new TypeError('property must be configurable');
            var deprecate = this;
            var stack = getStack();
            var site = callSiteLocation(stack[1]);
            site.name = prop;
            if ('value' in descriptor) descriptor = convertDataDescriptorToAccessor(obj, prop, message);
            var get = descriptor.get;
            var set = descriptor.set;
            if ('function' == typeof get) descriptor.get = function() {
                log.call(deprecate, message, site);
                return get.apply(this, arguments);
            };
            if ('function' == typeof set) descriptor.set = function() {
                log.call(deprecate, message, site);
                return set.apply(this, arguments);
            };
            Object.defineProperty(obj, prop, descriptor);
        }
        function DeprecationError(namespace, message, stack) {
            var error = new Error();
            var stackString;
            Object.defineProperty(error, 'constructor', {
                value: DeprecationError
            });
            Object.defineProperty(error, 'message', {
                configurable: true,
                enumerable: false,
                value: message,
                writable: true
            });
            Object.defineProperty(error, 'name', {
                enumerable: false,
                configurable: true,
                value: 'DeprecationError',
                writable: true
            });
            Object.defineProperty(error, 'namespace', {
                configurable: true,
                enumerable: false,
                value: namespace,
                writable: true
            });
            Object.defineProperty(error, 'stack', {
                configurable: true,
                enumerable: false,
                get: function() {
                    if (void 0 !== stackString) return stackString;
                    return stackString = createStackString.call(this, stack);
                },
                set: function(val) {
                    stackString = val;
                }
            });
            return error;
        }
    },
    "../node_modules/.pnpm/destroy@1.2.0/node_modules/destroy/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * destroy
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var EventEmitter = __webpack_require__("events").EventEmitter;
        var ReadStream = __webpack_require__("fs").ReadStream;
        var Stream = __webpack_require__("stream");
        var Zlib = __webpack_require__("zlib");
        module.exports = destroy;
        function destroy(stream, suppress) {
            if (isFsReadStream(stream)) destroyReadStream(stream);
            else if (isZlibStream(stream)) destroyZlibStream(stream);
            else if (hasDestroy(stream)) stream.destroy();
            if (isEventEmitter(stream) && suppress) {
                stream.removeAllListeners('error');
                stream.addListener('error', noop);
            }
            return stream;
        }
        function destroyReadStream(stream) {
            stream.destroy();
            if ('function' == typeof stream.close) stream.on('open', onOpenClose);
        }
        function closeZlibStream(stream) {
            if (true === stream._hadError) {
                var prop = null === stream._binding ? '_binding' : '_handle';
                stream[prop] = {
                    close: function() {
                        this[prop] = null;
                    }
                };
            }
            stream.close();
        }
        function destroyZlibStream(stream) {
            if ('function' == typeof stream.destroy) if (stream._binding) {
                stream.destroy();
                if (stream._processing) {
                    stream._needDrain = true;
                    stream.once('drain', onDrainClearBinding);
                } else stream._binding.clear();
            } else if (stream._destroy && stream._destroy !== Stream.Transform.prototype._destroy) stream.destroy();
            else if (stream._destroy && 'function' == typeof stream.close) {
                stream.destroyed = true;
                stream.close();
            } else stream.destroy();
            else if ('function' == typeof stream.close) closeZlibStream(stream);
        }
        function hasDestroy(stream) {
            return stream instanceof Stream && 'function' == typeof stream.destroy;
        }
        function isEventEmitter(val) {
            return val instanceof EventEmitter;
        }
        function isFsReadStream(stream) {
            return stream instanceof ReadStream;
        }
        function isZlibStream(stream) {
            return stream instanceof Zlib.Gzip || stream instanceof Zlib.Gunzip || stream instanceof Zlib.Deflate || stream instanceof Zlib.DeflateRaw || stream instanceof Zlib.Inflate || stream instanceof Zlib.InflateRaw || stream instanceof Zlib.Unzip;
        }
        function noop() {}
        function onDrainClearBinding() {
            this._binding.clear();
        }
        function onOpenClose() {
            if ('number' == typeof this.fd) this.close();
        }
    },
    "../node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var callBind = __webpack_require__("../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js");
        var gOPD = __webpack_require__("../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");
        var hasProtoAccessor;
        try {
            hasProtoAccessor = [].__proto__ === Array.prototype;
        } catch (e) {
            if (!e || 'object' != typeof e || !('code' in e) || 'ERR_PROTO_ACCESS' !== e.code) throw e;
        }
        var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, '__proto__');
        var $Object = Object;
        var $getPrototypeOf = $Object.getPrototypeOf;
        module.exports = desc && 'function' == typeof desc.get ? callBind([
            desc.get
        ]) : 'function' == typeof $getPrototypeOf ? function(value) {
            return $getPrototypeOf(null == value ? value : $Object(value));
        } : false;
    },
    "../node_modules/.pnpm/ee-first@1.1.1/node_modules/ee-first/index.js": function(module) {
        "use strict";
        /*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */ module.exports = first;
        function first(stuff, done) {
            if (!Array.isArray(stuff)) throw new TypeError('arg must be an array of [ee, events...] arrays');
            var cleanups = [];
            for(var i = 0; i < stuff.length; i++){
                var arr = stuff[i];
                if (!Array.isArray(arr) || arr.length < 2) throw new TypeError('each array member must be [ee, events...]');
                var ee = arr[0];
                for(var j = 1; j < arr.length; j++){
                    var event = arr[j];
                    var fn = listener(event, callback);
                    ee.on(event, fn);
                    cleanups.push({
                        ee: ee,
                        event: event,
                        fn: fn
                    });
                }
            }
            function callback() {
                cleanup();
                done.apply(null, arguments);
            }
            function cleanup() {
                var x;
                for(var i = 0; i < cleanups.length; i++){
                    x = cleanups[i];
                    x.ee.removeListener(x.event, x.fn);
                }
            }
            function thunk(fn) {
                done = fn;
            }
            thunk.cancel = cleanup;
            return thunk;
        }
        function listener(event, done) {
            return function(arg1) {
                var args = new Array(arguments.length);
                var ee = this;
                var err = 'error' === event ? arg1 : null;
                for(var i = 0; i < args.length; i++)args[i] = arguments[i];
                done(err, ee, event, args);
            };
        }
    },
    "../node_modules/.pnpm/encodeurl@1.0.2/node_modules/encodeurl/index.js": function(module) {
        "use strict";
        /*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = encodeUrl;
        var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
        var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
        var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2';
        function encodeUrl(url) {
            return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
        }
    },
    "../node_modules/.pnpm/encodeurl@2.0.0/node_modules/encodeurl/index.js": function(module) {
        "use strict";
        /*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = encodeUrl;
        var ENCODE_CHARS_REGEXP = /(?:[^\x21\x23-\x3B\x3D\x3F-\x5F\x61-\x7A\x7C\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
        var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
        var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2';
        function encodeUrl(url) {
            return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
        }
    },
    "../node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js": function(module) {
        "use strict";
        var $defineProperty = Object.defineProperty || false;
        if ($defineProperty) try {
            $defineProperty({}, 'a', {
                value: 1
            });
        } catch (e) {
            $defineProperty = false;
        }
        module.exports = $defineProperty;
    },
    "../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js": function(module) {
        "use strict";
        module.exports = EvalError;
    },
    "../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js": function(module) {
        "use strict";
        module.exports = Error;
    },
    "../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js": function(module) {
        "use strict";
        module.exports = RangeError;
    },
    "../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js": function(module) {
        "use strict";
        module.exports = ReferenceError;
    },
    "../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js": function(module) {
        "use strict";
        module.exports = SyntaxError;
    },
    "../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js": function(module) {
        "use strict";
        module.exports = TypeError;
    },
    "../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js": function(module) {
        "use strict";
        module.exports = URIError;
    },
    "../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js": function(module) {
        "use strict";
        module.exports = Object;
    },
    "../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js": function(module) {
        "use strict";
        /*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */ var matchHtmlRegExp = /["'&<>]/;
        module.exports = escapeHtml;
        function escapeHtml(string) {
            var str = '' + string;
            var match = matchHtmlRegExp.exec(str);
            if (!match) return str;
            var escape1;
            var html = '';
            var index = 0;
            var lastIndex = 0;
            for(index = match.index; index < str.length; index++){
                switch(str.charCodeAt(index)){
                    case 34:
                        escape1 = '&quot;';
                        break;
                    case 38:
                        escape1 = '&amp;';
                        break;
                    case 39:
                        escape1 = '&#39;';
                        break;
                    case 60:
                        escape1 = '&lt;';
                        break;
                    case 62:
                        escape1 = '&gt;';
                        break;
                    default:
                        continue;
                }
                if (lastIndex !== index) html += str.substring(lastIndex, index);
                lastIndex = index + 1;
                html += escape1;
            }
            return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
        }
    },
    "../node_modules/.pnpm/etag@1.8.1/node_modules/etag/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = etag;
        var crypto = __webpack_require__("crypto");
        var Stats = __webpack_require__("fs").Stats;
        var toString = Object.prototype.toString;
        function entitytag(entity) {
            if (0 === entity.length) return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
            var hash = crypto.createHash('sha1').update(entity, 'utf8').digest('base64').substring(0, 27);
            var len = 'string' == typeof entity ? Buffer.byteLength(entity, 'utf8') : entity.length;
            return '"' + len.toString(16) + '-' + hash + '"';
        }
        function etag(entity, options) {
            if (null == entity) throw new TypeError('argument entity is required');
            var isStats = isstats(entity);
            var weak = options && 'boolean' == typeof options.weak ? options.weak : isStats;
            if (!isStats && 'string' != typeof entity && !Buffer.isBuffer(entity)) throw new TypeError('argument entity must be string, Buffer, or fs.Stats');
            var tag = isStats ? stattag(entity) : entitytag(entity);
            return weak ? 'W/' + tag : tag;
        }
        function isstats(obj) {
            if ('function' == typeof Stats && obj instanceof Stats) return true;
            return obj && 'object' == typeof obj && 'ctime' in obj && '[object Date]' === toString.call(obj.ctime) && 'mtime' in obj && '[object Date]' === toString.call(obj.mtime) && 'ino' in obj && 'number' == typeof obj.ino && 'size' in obj && 'number' == typeof obj.size;
        }
        function stattag(stat) {
            var mtime = stat.mtime.getTime().toString(16);
            var size = stat.size.toString(16);
            return '"' + size + '-' + mtime + '"';
        }
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/express.js");
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/application.js": function(module, exports1, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var finalhandler = __webpack_require__("../node_modules/.pnpm/finalhandler@1.3.1/node_modules/finalhandler/index.js");
        var Router = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/index.js");
        var methods = __webpack_require__("../node_modules/.pnpm/methods@1.1.2/node_modules/methods/index.js");
        var middleware = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/middleware/init.js");
        var query = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/middleware/query.js");
        var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('express:application');
        var View = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/view.js");
        var http = __webpack_require__("http");
        var compileETag = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/utils.js").compileETag;
        var compileQueryParser = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/utils.js").compileQueryParser;
        var compileTrust = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/utils.js").compileTrust;
        var deprecate = __webpack_require__("../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('express');
        var flatten = __webpack_require__("../node_modules/.pnpm/array-flatten@1.1.1/node_modules/array-flatten/array-flatten.js");
        var merge = __webpack_require__("../node_modules/.pnpm/utils-merge@1.0.1/node_modules/utils-merge/index.js");
        var resolve = __webpack_require__("path").resolve;
        var setPrototypeOf = __webpack_require__("../node_modules/.pnpm/setprototypeof@1.2.0/node_modules/setprototypeof/index.js");
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var slice = Array.prototype.slice;
        var app = module.exports = {};
        var trustProxyDefaultSymbol = '@@symbol:trust_proxy_default';
        app.init = function() {
            this.cache = {};
            this.engines = {};
            this.settings = {};
            this.defaultConfiguration();
        };
        app.defaultConfiguration = function() {
            var env = process.env.NODE_ENV || 'development';
            this.enable('x-powered-by');
            this.set('etag', 'weak');
            this.set('env', env);
            this.set('query parser', 'extended');
            this.set('subdomain offset', 2);
            this.set('trust proxy', false);
            Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
                configurable: true,
                value: true
            });
            debug('booting in %s mode', env);
            this.on('mount', function(parent) {
                if (true === this.settings[trustProxyDefaultSymbol] && 'function' == typeof parent.settings['trust proxy fn']) {
                    delete this.settings['trust proxy'];
                    delete this.settings['trust proxy fn'];
                }
                setPrototypeOf(this.request, parent.request);
                setPrototypeOf(this.response, parent.response);
                setPrototypeOf(this.engines, parent.engines);
                setPrototypeOf(this.settings, parent.settings);
            });
            this.locals = Object.create(null);
            this.mountpath = '/';
            this.locals.settings = this.settings;
            this.set('view', View);
            this.set('views', resolve('views'));
            this.set('jsonp callback name', 'callback');
            if ('production' === env) this.enable('view cache');
            Object.defineProperty(this, 'router', {
                get: function() {
                    throw new Error('\'app.router\' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.');
                }
            });
        };
        app.lazyrouter = function() {
            if (!this._router) {
                this._router = new Router({
                    caseSensitive: this.enabled('case sensitive routing'),
                    strict: this.enabled('strict routing')
                });
                this._router.use(query(this.get('query parser fn')));
                this._router.use(middleware.init(this));
            }
        };
        app.handle = function(req, res, callback) {
            var router = this._router;
            var done = callback || finalhandler(req, res, {
                env: this.get('env'),
                onerror: logerror.bind(this)
            });
            if (!router) {
                debug('no routes defined on app');
                done();
                return;
            }
            router.handle(req, res, done);
        };
        app.use = function(fn) {
            var offset = 0;
            var path = '/';
            if ('function' != typeof fn) {
                var arg = fn;
                while(Array.isArray(arg) && 0 !== arg.length)arg = arg[0];
                if ('function' != typeof arg) {
                    offset = 1;
                    path = fn;
                }
            }
            var fns = flatten(slice.call(arguments, offset));
            if (0 === fns.length) throw new TypeError('app.use() requires a middleware function');
            this.lazyrouter();
            var router = this._router;
            fns.forEach(function(fn) {
                if (!fn || !fn.handle || !fn.set) return router.use(path, fn);
                debug('.use app under %s', path);
                fn.mountpath = path;
                fn.parent = this;
                router.use(path, function(req, res, next) {
                    var orig = req.app;
                    fn.handle(req, res, function(err) {
                        setPrototypeOf(req, orig.request);
                        setPrototypeOf(res, orig.response);
                        next(err);
                    });
                });
                fn.emit('mount', this);
            }, this);
            return this;
        };
        app.route = function(path) {
            this.lazyrouter();
            return this._router.route(path);
        };
        app.engine = function(ext, fn) {
            if ('function' != typeof fn) throw new Error('callback function required');
            var extension = '.' !== ext[0] ? '.' + ext : ext;
            this.engines[extension] = fn;
            return this;
        };
        app.param = function(name, fn) {
            this.lazyrouter();
            if (Array.isArray(name)) {
                for(var i = 0; i < name.length; i++)this.param(name[i], fn);
                return this;
            }
            this._router.param(name, fn);
            return this;
        };
        app.set = function(setting, val) {
            if (1 === arguments.length) {
                var settings = this.settings;
                while(settings && settings !== Object.prototype){
                    if (hasOwnProperty.call(settings, setting)) return settings[setting];
                    settings = Object.getPrototypeOf(settings);
                }
                return;
            }
            debug('set "%s" to %o', setting, val);
            this.settings[setting] = val;
            switch(setting){
                case 'etag':
                    this.set('etag fn', compileETag(val));
                    break;
                case 'query parser':
                    this.set('query parser fn', compileQueryParser(val));
                    break;
                case 'trust proxy':
                    this.set('trust proxy fn', compileTrust(val));
                    Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
                        configurable: true,
                        value: false
                    });
                    break;
            }
            return this;
        };
        app.path = function() {
            return this.parent ? this.parent.path() + this.mountpath : '';
        };
        app.enabled = function(setting) {
            return Boolean(this.set(setting));
        };
        app.disabled = function(setting) {
            return !this.set(setting);
        };
        app.enable = function(setting) {
            return this.set(setting, true);
        };
        app.disable = function(setting) {
            return this.set(setting, false);
        };
        methods.forEach(function(method) {
            app[method] = function(path) {
                if ('get' === method && 1 === arguments.length) return this.set(path);
                this.lazyrouter();
                var route = this._router.route(path);
                route[method].apply(route, slice.call(arguments, 1));
                return this;
            };
        });
        app.all = function(path) {
            this.lazyrouter();
            var route = this._router.route(path);
            var args = slice.call(arguments, 1);
            for(var i = 0; i < methods.length; i++)route[methods[i]].apply(route, args);
            return this;
        };
        app.del = deprecate.function(app.delete, 'app.del: Use app.delete instead');
        app.render = function(name, options, callback) {
            var cache = this.cache;
            var done = callback;
            var engines = this.engines;
            var opts = options;
            var renderOptions = {};
            var view;
            if ('function' == typeof options) {
                done = options;
                opts = {};
            }
            merge(renderOptions, this.locals);
            if (opts._locals) merge(renderOptions, opts._locals);
            merge(renderOptions, opts);
            if (null == renderOptions.cache) renderOptions.cache = this.enabled('view cache');
            if (renderOptions.cache) view = cache[name];
            if (!view) {
                var View = this.get('view');
                view = new View(name, {
                    defaultEngine: this.get('view engine'),
                    root: this.get('views'),
                    engines: engines
                });
                if (!view.path) {
                    var dirs = Array.isArray(view.root) && view.root.length > 1 ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"' : 'directory "' + view.root + '"';
                    var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
                    err.view = view;
                    return done(err);
                }
                if (renderOptions.cache) cache[name] = view;
            }
            tryRender(view, renderOptions, done);
        };
        app.listen = function() {
            var server = http.createServer(this);
            return server.listen.apply(server, arguments);
        };
        function logerror(err) {
            if ('test' !== this.get('env')) console.error(err.stack || err.toString());
        }
        function tryRender(view, options, callback) {
            try {
                view.render(options, callback);
            } catch (err) {
                callback(err);
            }
        }
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/express.js": function(module, exports1, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var bodyParser = __webpack_require__("../node_modules/.pnpm/body-parser@1.20.3/node_modules/body-parser/index.js");
        var EventEmitter = __webpack_require__("events").EventEmitter;
        var mixin = __webpack_require__("../node_modules/.pnpm/merge-descriptors@1.0.3/node_modules/merge-descriptors/index.js");
        var proto = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/application.js");
        var Route = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/route.js");
        var Router = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/index.js");
        var req = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/request.js");
        var res = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/response.js");
        exports1 = module.exports = createApplication;
        function createApplication() {
            var app = function(req, res, next) {
                app.handle(req, res, next);
            };
            mixin(app, EventEmitter.prototype, false);
            mixin(app, proto, false);
            app.request = Object.create(req, {
                app: {
                    configurable: true,
                    enumerable: true,
                    writable: true,
                    value: app
                }
            });
            app.response = Object.create(res, {
                app: {
                    configurable: true,
                    enumerable: true,
                    writable: true,
                    value: app
                }
            });
            app.init();
            return app;
        }
        exports1.application = proto;
        exports1.request = req;
        exports1.response = res;
        exports1.Route = Route;
        exports1.Router = Router;
        exports1.json = bodyParser.json;
        exports1.query = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/middleware/query.js");
        exports1.raw = bodyParser.raw;
        exports1["static"] = __webpack_require__("../node_modules/.pnpm/serve-static@1.16.2/node_modules/serve-static/index.js");
        exports1.text = bodyParser.text;
        exports1.urlencoded = bodyParser.urlencoded;
        var removedMiddlewares = [
            'bodyParser',
            'compress',
            'cookieSession',
            'session',
            'logger',
            'cookieParser',
            'favicon',
            'responseTime',
            'errorHandler',
            'timeout',
            'methodOverride',
            'vhost',
            'csrf',
            'directory',
            'limit',
            'multipart',
            'staticCache'
        ];
        removedMiddlewares.forEach(function(name) {
            Object.defineProperty(exports1, name, {
                get: function() {
                    throw new Error('Most middleware (like ' + name + ') is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.');
                },
                configurable: true
            });
        });
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/middleware/init.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var setPrototypeOf = __webpack_require__("../node_modules/.pnpm/setprototypeof@1.2.0/node_modules/setprototypeof/index.js");
        exports1.init = function(app) {
            return function(req, res, next) {
                if (app.enabled('x-powered-by')) res.setHeader('X-Powered-By', 'Express');
                req.res = res;
                res.req = req;
                req.next = next;
                setPrototypeOf(req, app.request);
                setPrototypeOf(res, app.response);
                res.locals = res.locals || Object.create(null);
                next();
            };
        };
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/middleware/query.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var merge = __webpack_require__("../node_modules/.pnpm/utils-merge@1.0.1/node_modules/utils-merge/index.js");
        var parseUrl = __webpack_require__("../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js");
        var qs = __webpack_require__("../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/index.js");
        module.exports = function(options) {
            var opts = merge({}, options);
            var queryparse = qs.parse;
            if ('function' == typeof options) {
                queryparse = options;
                opts = void 0;
            }
            if (void 0 !== opts && void 0 === opts.allowPrototypes) opts.allowPrototypes = true;
            return function(req, res, next) {
                if (!req.query) {
                    var val = parseUrl(req).query;
                    req.query = queryparse(val, opts);
                }
                next();
            };
        };
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/request.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var accepts = __webpack_require__("../node_modules/.pnpm/accepts@1.3.8/node_modules/accepts/index.js");
        var deprecate = __webpack_require__("../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('express');
        var isIP = __webpack_require__("net").isIP;
        var typeis = __webpack_require__("../node_modules/.pnpm/type-is@1.6.18/node_modules/type-is/index.js");
        var http = __webpack_require__("http");
        var fresh = __webpack_require__("../node_modules/.pnpm/fresh@0.5.2/node_modules/fresh/index.js");
        var parseRange = __webpack_require__("../node_modules/.pnpm/range-parser@1.2.1/node_modules/range-parser/index.js");
        var parse = __webpack_require__("../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js");
        var proxyaddr = __webpack_require__("../node_modules/.pnpm/proxy-addr@2.0.7/node_modules/proxy-addr/index.js");
        var req = Object.create(http.IncomingMessage.prototype);
        module.exports = req;
        req.get = req.header = function(name) {
            if (!name) throw new TypeError('name argument is required to req.get');
            if ('string' != typeof name) throw new TypeError('name must be a string to req.get');
            var lc = name.toLowerCase();
            switch(lc){
                case 'referer':
                case 'referrer':
                    return this.headers.referrer || this.headers.referer;
                default:
                    return this.headers[lc];
            }
        };
        req.accepts = function() {
            var accept = accepts(this);
            return accept.types.apply(accept, arguments);
        };
        req.acceptsEncodings = function() {
            var accept = accepts(this);
            return accept.encodings.apply(accept, arguments);
        };
        req.acceptsEncoding = deprecate.function(req.acceptsEncodings, 'req.acceptsEncoding: Use acceptsEncodings instead');
        req.acceptsCharsets = function() {
            var accept = accepts(this);
            return accept.charsets.apply(accept, arguments);
        };
        req.acceptsCharset = deprecate.function(req.acceptsCharsets, 'req.acceptsCharset: Use acceptsCharsets instead');
        req.acceptsLanguages = function() {
            var accept = accepts(this);
            return accept.languages.apply(accept, arguments);
        };
        req.acceptsLanguage = deprecate.function(req.acceptsLanguages, 'req.acceptsLanguage: Use acceptsLanguages instead');
        req.range = function(size, options) {
            var range = this.get('Range');
            if (!range) return;
            return parseRange(size, range, options);
        };
        req.param = function(name, defaultValue) {
            var params = this.params || {};
            var body = this.body || {};
            var query = this.query || {};
            var args = 1 === arguments.length ? 'name' : 'name, default';
            deprecate('req.param(' + args + '): Use req.params, req.body, or req.query instead');
            if (null != params[name] && params.hasOwnProperty(name)) return params[name];
            if (null != body[name]) return body[name];
            if (null != query[name]) return query[name];
            return defaultValue;
        };
        req.is = function(types) {
            var arr = types;
            if (!Array.isArray(types)) {
                arr = new Array(arguments.length);
                for(var i = 0; i < arr.length; i++)arr[i] = arguments[i];
            }
            return typeis(this, arr);
        };
        defineGetter(req, 'protocol', function() {
            var proto = this.connection.encrypted ? 'https' : 'http';
            var trust = this.app.get('trust proxy fn');
            if (!trust(this.connection.remoteAddress, 0)) return proto;
            var header = this.get('X-Forwarded-Proto') || proto;
            var index = header.indexOf(',');
            return -1 !== index ? header.substring(0, index).trim() : header.trim();
        });
        defineGetter(req, 'secure', function() {
            return 'https' === this.protocol;
        });
        defineGetter(req, 'ip', function() {
            var trust = this.app.get('trust proxy fn');
            return proxyaddr(this, trust);
        });
        defineGetter(req, 'ips', function() {
            var trust = this.app.get('trust proxy fn');
            var addrs = proxyaddr.all(this, trust);
            addrs.reverse().pop();
            return addrs;
        });
        defineGetter(req, 'subdomains', function() {
            var hostname = this.hostname;
            if (!hostname) return [];
            var offset = this.app.get('subdomain offset');
            var subdomains = isIP(hostname) ? [
                hostname
            ] : hostname.split('.').reverse();
            return subdomains.slice(offset);
        });
        defineGetter(req, 'path', function() {
            return parse(this).pathname;
        });
        defineGetter(req, 'hostname', function() {
            var trust = this.app.get('trust proxy fn');
            var host = this.get('X-Forwarded-Host');
            if (host && trust(this.connection.remoteAddress, 0)) {
                if (-1 !== host.indexOf(',')) host = host.substring(0, host.indexOf(',')).trimRight();
            } else host = this.get('Host');
            if (!host) return;
            var offset = '[' === host[0] ? host.indexOf(']') + 1 : 0;
            var index = host.indexOf(':', offset);
            return -1 !== index ? host.substring(0, index) : host;
        });
        defineGetter(req, 'host', deprecate.function(function() {
            return this.hostname;
        }, 'req.host: Use req.hostname instead'));
        defineGetter(req, 'fresh', function() {
            var method = this.method;
            var res = this.res;
            var status = res.statusCode;
            if ('GET' !== method && 'HEAD' !== method) return false;
            if (status >= 200 && status < 300 || 304 === status) return fresh(this.headers, {
                etag: res.get('ETag'),
                'last-modified': res.get('Last-Modified')
            });
            return false;
        });
        defineGetter(req, 'stale', function() {
            return !this.fresh;
        });
        defineGetter(req, 'xhr', function() {
            var val = this.get('X-Requested-With') || '';
            return 'xmlhttprequest' === val.toLowerCase();
        });
        function defineGetter(obj, name, getter) {
            Object.defineProperty(obj, name, {
                configurable: true,
                enumerable: true,
                get: getter
            });
        }
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/response.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Buffer1 = __webpack_require__("../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer;
        var contentDisposition = __webpack_require__("../node_modules/.pnpm/content-disposition@0.5.4/node_modules/content-disposition/index.js");
        var createError = __webpack_require__("../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js");
        var deprecate = __webpack_require__("../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('express');
        var encodeUrl = __webpack_require__("../node_modules/.pnpm/encodeurl@2.0.0/node_modules/encodeurl/index.js");
        var escapeHtml = __webpack_require__("../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js");
        var http = __webpack_require__("http");
        var isAbsolute = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/utils.js").isAbsolute;
        var onFinished = __webpack_require__("../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js");
        var path = __webpack_require__("path");
        var statuses = __webpack_require__("../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/index.js");
        var merge = __webpack_require__("../node_modules/.pnpm/utils-merge@1.0.1/node_modules/utils-merge/index.js");
        var sign = __webpack_require__("../node_modules/.pnpm/cookie-signature@1.0.6/node_modules/cookie-signature/index.js").sign;
        var normalizeType = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/utils.js").normalizeType;
        var normalizeTypes = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/utils.js").normalizeTypes;
        var setCharset = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/utils.js").setCharset;
        var cookie = __webpack_require__("../node_modules/.pnpm/cookie@0.7.1/node_modules/cookie/index.js");
        var send = __webpack_require__("../node_modules/.pnpm/send@0.19.0/node_modules/send/index.js");
        var extname = path.extname;
        var mime = send.mime;
        var resolve = path.resolve;
        var vary = __webpack_require__("../node_modules/.pnpm/vary@1.1.2/node_modules/vary/index.js");
        var res = Object.create(http.ServerResponse.prototype);
        module.exports = res;
        var charsetRegExp = /;\s*charset\s*=/;
        res.status = function(code) {
            if (('string' == typeof code || Math.floor(code) !== code) && code > 99 && code < 1000) deprecate('res.status(' + JSON.stringify(code) + '): use res.status(' + Math.floor(code) + ') instead');
            this.statusCode = code;
            return this;
        };
        res.links = function(links) {
            var link = this.get('Link') || '';
            if (link) link += ', ';
            return this.set('Link', link + Object.keys(links).map(function(rel) {
                return '<' + links[rel] + '>; rel="' + rel + '"';
            }).join(', '));
        };
        res.send = function(body) {
            var chunk = body;
            var encoding;
            var req = this.req;
            var type;
            var app = this.app;
            if (2 === arguments.length) if ('number' != typeof arguments[0] && 'number' == typeof arguments[1]) {
                deprecate('res.send(body, status): Use res.status(status).send(body) instead');
                this.statusCode = arguments[1];
            } else {
                deprecate('res.send(status, body): Use res.status(status).send(body) instead');
                this.statusCode = arguments[0];
                chunk = arguments[1];
            }
            if ('number' == typeof chunk && 1 === arguments.length) {
                if (!this.get('Content-Type')) this.type('txt');
                deprecate('res.send(status): Use res.sendStatus(status) instead');
                this.statusCode = chunk;
                chunk = statuses.message[chunk];
            }
            switch(typeof chunk){
                case 'string':
                    if (!this.get('Content-Type')) this.type('html');
                    break;
                case 'boolean':
                case 'number':
                case 'object':
                    if (null === chunk) chunk = '';
                    else if (!Buffer1.isBuffer(chunk)) return this.json(chunk);
                    else if (!this.get('Content-Type')) this.type('bin');
                    break;
            }
            if ('string' == typeof chunk) {
                encoding = 'utf8';
                type = this.get('Content-Type');
                if ('string' == typeof type) this.set('Content-Type', setCharset(type, 'utf-8'));
            }
            var etagFn = app.get('etag fn');
            var generateETag = !this.get('ETag') && 'function' == typeof etagFn;
            var len;
            if (void 0 !== chunk) {
                if (Buffer1.isBuffer(chunk)) len = chunk.length;
                else if (!generateETag && chunk.length < 1000) len = Buffer1.byteLength(chunk, encoding);
                else {
                    chunk = Buffer1.from(chunk, encoding);
                    encoding = void 0;
                    len = chunk.length;
                }
                this.set('Content-Length', len);
            }
            var etag;
            if (generateETag && void 0 !== len) {
                if (etag = etagFn(chunk, encoding)) this.set('ETag', etag);
            }
            if (req.fresh) this.statusCode = 304;
            if (204 === this.statusCode || 304 === this.statusCode) {
                this.removeHeader('Content-Type');
                this.removeHeader('Content-Length');
                this.removeHeader('Transfer-Encoding');
                chunk = '';
            }
            if (205 === this.statusCode) {
                this.set('Content-Length', '0');
                this.removeHeader('Transfer-Encoding');
                chunk = '';
            }
            if ('HEAD' === req.method) this.end();
            else this.end(chunk, encoding);
            return this;
        };
        res.json = function(obj) {
            var val = obj;
            if (2 === arguments.length) if ('number' == typeof arguments[1]) {
                deprecate('res.json(obj, status): Use res.status(status).json(obj) instead');
                this.statusCode = arguments[1];
            } else {
                deprecate('res.json(status, obj): Use res.status(status).json(obj) instead');
                this.statusCode = arguments[0];
                val = arguments[1];
            }
            var app = this.app;
            var escape1 = app.get('json escape');
            var replacer = app.get('json replacer');
            var spaces = app.get('json spaces');
            var body = stringify(val, replacer, spaces, escape1);
            if (!this.get('Content-Type')) this.set('Content-Type', 'application/json');
            return this.send(body);
        };
        res.jsonp = function(obj) {
            var val = obj;
            if (2 === arguments.length) if ('number' == typeof arguments[1]) {
                deprecate('res.jsonp(obj, status): Use res.status(status).jsonp(obj) instead');
                this.statusCode = arguments[1];
            } else {
                deprecate('res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead');
                this.statusCode = arguments[0];
                val = arguments[1];
            }
            var app = this.app;
            var escape1 = app.get('json escape');
            var replacer = app.get('json replacer');
            var spaces = app.get('json spaces');
            var body = stringify(val, replacer, spaces, escape1);
            var callback = this.req.query[app.get('jsonp callback name')];
            if (!this.get('Content-Type')) {
                this.set('X-Content-Type-Options', 'nosniff');
                this.set('Content-Type', 'application/json');
            }
            if (Array.isArray(callback)) callback = callback[0];
            if ('string' == typeof callback && 0 !== callback.length) {
                this.set('X-Content-Type-Options', 'nosniff');
                this.set('Content-Type', "text/javascript");
                callback = callback.replace(/[^\[\]\w$.]/g, '');
                if (void 0 === body) body = '';
                else if ('string' == typeof body) body = body.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
                body = '/**/ typeof ' + callback + ' === \'function\' && ' + callback + '(' + body + ');';
            }
            return this.send(body);
        };
        res.sendStatus = function(statusCode) {
            var body = statuses.message[statusCode] || String(statusCode);
            this.statusCode = statusCode;
            this.type('txt');
            return this.send(body);
        };
        res.sendFile = function(path, options, callback) {
            var done = callback;
            var req = this.req;
            var res = this;
            var next = req.next;
            var opts = options || {};
            if (!path) throw new TypeError('path argument is required to res.sendFile');
            if ('string' != typeof path) throw new TypeError('path must be a string to res.sendFile');
            if ('function' == typeof options) {
                done = options;
                opts = {};
            }
            if (!opts.root && !isAbsolute(path)) throw new TypeError('path must be absolute or specify root to res.sendFile');
            var pathname = encodeURI(path);
            var file = send(req, pathname, opts);
            sendfile(res, file, opts, function(err) {
                if (done) return done(err);
                if (err && 'EISDIR' === err.code) return next();
                if (err && 'ECONNABORTED' !== err.code && 'write' !== err.syscall) next(err);
            });
        };
        res.sendfile = function(path, options, callback) {
            var done = callback;
            var req = this.req;
            var res = this;
            var next = req.next;
            var opts = options || {};
            if ('function' == typeof options) {
                done = options;
                opts = {};
            }
            var file = send(req, path, opts);
            sendfile(res, file, opts, function(err) {
                if (done) return done(err);
                if (err && 'EISDIR' === err.code) return next();
                if (err && 'ECONNABORTED' !== err.code && 'write' !== err.syscall) next(err);
            });
        };
        res.sendfile = deprecate.function(res.sendfile, 'res.sendfile: Use res.sendFile instead');
        res.download = function(path, filename, options, callback) {
            var done = callback;
            var name = filename;
            var opts = options || null;
            if ('function' == typeof filename) {
                done = filename;
                name = null;
                opts = null;
            } else if ('function' == typeof options) {
                done = options;
                opts = null;
            }
            if ('object' == typeof filename && ('function' == typeof options || void 0 === options)) {
                name = null;
                opts = filename;
            }
            var headers = {
                'Content-Disposition': contentDisposition(name || path)
            };
            if (opts && opts.headers) {
                var keys = Object.keys(opts.headers);
                for(var i = 0; i < keys.length; i++){
                    var key = keys[i];
                    if ('content-disposition' !== key.toLowerCase()) headers[key] = opts.headers[key];
                }
            }
            opts = Object.create(opts);
            opts.headers = headers;
            var fullPath = opts.root ? path : resolve(path);
            return this.sendFile(fullPath, opts, done);
        };
        res.contentType = res.type = function(type) {
            var ct = -1 === type.indexOf('/') ? mime.lookup(type) : type;
            return this.set('Content-Type', ct);
        };
        res.format = function(obj) {
            var req = this.req;
            var next = req.next;
            var keys = Object.keys(obj).filter(function(v) {
                return 'default' !== v;
            });
            var key = keys.length > 0 ? req.accepts(keys) : false;
            this.vary("Accept");
            if (key) {
                this.set('Content-Type', normalizeType(key).value);
                obj[key](req, this, next);
            } else if (obj.default) obj.default(req, this, next);
            else next(createError(406, {
                types: normalizeTypes(keys).map(function(o) {
                    return o.value;
                })
            }));
            return this;
        };
        res.attachment = function(filename) {
            if (filename) this.type(extname(filename));
            this.set('Content-Disposition', contentDisposition(filename));
            return this;
        };
        res.append = function(field, val) {
            var prev = this.get(field);
            var value = val;
            if (prev) value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [
                prev
            ].concat(val) : [
                prev,
                val
            ];
            return this.set(field, value);
        };
        res.set = res.header = function(field, val) {
            if (2 === arguments.length) {
                var value = Array.isArray(val) ? val.map(String) : String(val);
                if ('content-type' === field.toLowerCase()) {
                    if (Array.isArray(value)) throw new TypeError('Content-Type cannot be set to an Array');
                    if (!charsetRegExp.test(value)) {
                        var charset = mime.charsets.lookup(value.split(';')[0]);
                        if (charset) value += '; charset=' + charset.toLowerCase();
                    }
                }
                this.setHeader(field, value);
            } else for(var key in field)this.set(key, field[key]);
            return this;
        };
        res.get = function(field) {
            return this.getHeader(field);
        };
        res.clearCookie = function(name, options) {
            if (options) {
                if (options.maxAge) deprecate('res.clearCookie: Passing "options.maxAge" is deprecated. In v5.0.0 of Express, this option will be ignored, as res.clearCookie will automatically set cookies to expire immediately. Please update your code to omit this option.');
                if (options.expires) deprecate('res.clearCookie: Passing "options.expires" is deprecated. In v5.0.0 of Express, this option will be ignored, as res.clearCookie will automatically set cookies to expire immediately. Please update your code to omit this option.');
            }
            var opts = merge({
                expires: new Date(1),
                path: '/'
            }, options);
            return this.cookie(name, '', opts);
        };
        res.cookie = function(name, value, options) {
            var opts = merge({}, options);
            var secret = this.req.secret;
            var signed = opts.signed;
            if (signed && !secret) throw new Error('cookieParser("secret") required for signed cookies');
            var val = 'object' == typeof value ? 'j:' + JSON.stringify(value) : String(value);
            if (signed) val = 's:' + sign(val, secret);
            if (null != opts.maxAge) {
                var maxAge = opts.maxAge - 0;
                if (!isNaN(maxAge)) {
                    opts.expires = new Date(Date.now() + maxAge);
                    opts.maxAge = Math.floor(maxAge / 1000);
                }
            }
            if (null == opts.path) opts.path = '/';
            this.append('Set-Cookie', cookie.serialize(name, String(val), opts));
            return this;
        };
        res.location = function(url) {
            var loc;
            if ('back' === url) {
                deprecate('res.location("back"): use res.location(req.get("Referrer") || "/") and refer to https://dub.sh/security-redirect for best practices');
                loc = this.req.get('Referrer') || '/';
            } else loc = String(url);
            return this.set('Location', encodeUrl(loc));
        };
        res.redirect = function(url) {
            var address = url;
            var body;
            var status = 302;
            if (2 === arguments.length) if ('number' == typeof arguments[0]) {
                status = arguments[0];
                address = arguments[1];
            } else {
                deprecate('res.redirect(url, status): Use res.redirect(status, url) instead');
                status = arguments[1];
            }
            address = this.location(address).get('Location');
            this.format({
                text: function() {
                    body = statuses.message[status] + '. Redirecting to ' + address;
                },
                html: function() {
                    var u = escapeHtml(address);
                    body = '<p>' + statuses.message[status] + '. Redirecting to ' + u + '</p>';
                },
                default: function() {
                    body = '';
                }
            });
            this.statusCode = status;
            this.set('Content-Length', Buffer1.byteLength(body));
            if ('HEAD' === this.req.method) this.end();
            else this.end(body);
        };
        res.vary = function(field) {
            if (!field || Array.isArray(field) && !field.length) {
                deprecate('res.vary(): Provide a field name');
                return this;
            }
            vary(this, field);
            return this;
        };
        res.render = function(view, options, callback) {
            var app = this.req.app;
            var done = callback;
            var opts = options || {};
            var req = this.req;
            var self = this;
            if ('function' == typeof options) {
                done = options;
                opts = {};
            }
            opts._locals = self.locals;
            done = done || function(err, str) {
                if (err) return req.next(err);
                self.send(str);
            };
            app.render(view, opts, done);
        };
        function sendfile(res, file, options, callback) {
            var done = false;
            var streaming;
            function onaborted() {
                if (done) return;
                done = true;
                var err = new Error('Request aborted');
                err.code = 'ECONNABORTED';
                callback(err);
            }
            function ondirectory() {
                if (done) return;
                done = true;
                var err = new Error('EISDIR, read');
                err.code = 'EISDIR';
                callback(err);
            }
            function onerror(err) {
                if (done) return;
                done = true;
                callback(err);
            }
            function onend() {
                if (done) return;
                done = true;
                callback();
            }
            function onfile() {
                streaming = false;
            }
            function onfinish(err) {
                if (err && 'ECONNRESET' === err.code) return onaborted();
                if (err) return onerror(err);
                if (done) return;
                setImmediate(function() {
                    if (false !== streaming && !done) return void onaborted();
                    if (done) return;
                    done = true;
                    callback();
                });
            }
            function onstream() {
                streaming = true;
            }
            file.on('directory', ondirectory);
            file.on('end', onend);
            file.on('error', onerror);
            file.on('file', onfile);
            file.on('stream', onstream);
            onFinished(res, onfinish);
            if (options.headers) file.on('headers', function(res) {
                var obj = options.headers;
                var keys = Object.keys(obj);
                for(var i = 0; i < keys.length; i++){
                    var k = keys[i];
                    res.setHeader(k, obj[k]);
                }
            });
            file.pipe(res);
        }
        function stringify(value, replacer, spaces, escape1) {
            var json = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
            if (escape1 && 'string' == typeof json) json = json.replace(/[<>&]/g, function(c) {
                switch(c.charCodeAt(0)){
                    case 0x3c:
                        return '\\u003c';
                    case 0x3e:
                        return '\\u003e';
                    case 0x26:
                        return '\\u0026';
                    default:
                        return c;
                }
            });
            return json;
        }
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Route = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/route.js");
        var Layer = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/layer.js");
        var methods = __webpack_require__("../node_modules/.pnpm/methods@1.1.2/node_modules/methods/index.js");
        var mixin = __webpack_require__("../node_modules/.pnpm/utils-merge@1.0.1/node_modules/utils-merge/index.js");
        var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('express:router');
        var deprecate = __webpack_require__("../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('express');
        var flatten = __webpack_require__("../node_modules/.pnpm/array-flatten@1.1.1/node_modules/array-flatten/array-flatten.js");
        var parseUrl = __webpack_require__("../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js");
        var setPrototypeOf = __webpack_require__("../node_modules/.pnpm/setprototypeof@1.2.0/node_modules/setprototypeof/index.js");
        var objectRegExp = /^\[object (\S+)\]$/;
        var slice = Array.prototype.slice;
        var toString = Object.prototype.toString;
        var proto = module.exports = function(options) {
            var opts = options || {};
            function router(req, res, next) {
                router.handle(req, res, next);
            }
            setPrototypeOf(router, proto);
            router.params = {};
            router._params = [];
            router.caseSensitive = opts.caseSensitive;
            router.mergeParams = opts.mergeParams;
            router.strict = opts.strict;
            router.stack = [];
            return router;
        };
        proto.param = function(name, fn) {
            if ('function' == typeof name) {
                deprecate('router.param(fn): Refactor to use path params');
                this._params.push(name);
                return;
            }
            var params = this._params;
            var len = params.length;
            var ret;
            if (':' === name[0]) {
                deprecate('router.param(' + JSON.stringify(name) + ', fn): Use router.param(' + JSON.stringify(name.slice(1)) + ', fn) instead');
                name = name.slice(1);
            }
            for(var i = 0; i < len; ++i)if (ret = params[i](name, fn)) fn = ret;
            if ('function' != typeof fn) throw new Error('invalid param() call for ' + name + ', got ' + fn);
            (this.params[name] = this.params[name] || []).push(fn);
            return this;
        };
        proto.handle = function(req, res, out) {
            var self = this;
            debug('dispatching %s %s', req.method, req.url);
            var idx = 0;
            var protohost = getProtohost(req.url) || '';
            var removed = '';
            var slashAdded = false;
            var sync = 0;
            var paramcalled = {};
            var options = [];
            var stack = self.stack;
            var parentParams = req.params;
            var parentUrl = req.baseUrl || '';
            var done = restore(out, req, 'baseUrl', 'next', 'params');
            req.next = next;
            if ('OPTIONS' === req.method) done = wrap(done, function(old, err) {
                if (err || 0 === options.length) return old(err);
                sendOptionsResponse(res, options, old);
            });
            req.baseUrl = parentUrl;
            req.originalUrl = req.originalUrl || req.url;
            next();
            function next(err) {
                var layerError = 'route' === err ? null : err;
                if (slashAdded) {
                    req.url = req.url.slice(1);
                    slashAdded = false;
                }
                if (0 !== removed.length) {
                    req.baseUrl = parentUrl;
                    req.url = protohost + removed + req.url.slice(protohost.length);
                    removed = '';
                }
                if ('router' === layerError) return void setImmediate(done, null);
                if (idx >= stack.length) return void setImmediate(done, layerError);
                if (++sync > 100) return setImmediate(next, err);
                var path = getPathname(req);
                if (null == path) return done(layerError);
                var layer;
                var match;
                var route;
                while(true !== match && idx < stack.length){
                    layer = stack[idx++];
                    match = matchLayer(layer, path);
                    route = layer.route;
                    if ('boolean' != typeof match) layerError = layerError || match;
                    if (true !== match) continue;
                    if (!route) continue;
                    if (layerError) {
                        match = false;
                        continue;
                    }
                    var method = req.method;
                    var has_method = route._handles_method(method);
                    if (!has_method && 'OPTIONS' === method) appendMethods(options, route._options());
                    if (!has_method && 'HEAD' !== method) match = false;
                }
                if (true !== match) return done(layerError);
                if (route) req.route = route;
                req.params = self.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;
                var layerPath = layer.path;
                self.process_params(layer, paramcalled, req, res, function(err) {
                    if (err) next(layerError || err);
                    else if (route) layer.handle_request(req, res, next);
                    else trim_prefix(layer, layerError, layerPath, path);
                    sync = 0;
                });
            }
            function trim_prefix(layer, layerError, layerPath, path) {
                if (0 !== layerPath.length) {
                    if (layerPath !== path.slice(0, layerPath.length)) return void next(layerError);
                    var c = path[layerPath.length];
                    if (c && '/' !== c && '.' !== c) return next(layerError);
                    debug('trim prefix (%s) from url %s', layerPath, req.url);
                    removed = layerPath;
                    req.url = protohost + req.url.slice(protohost.length + removed.length);
                    if (!protohost && '/' !== req.url[0]) {
                        req.url = '/' + req.url;
                        slashAdded = true;
                    }
                    req.baseUrl = parentUrl + ('/' === removed[removed.length - 1] ? removed.substring(0, removed.length - 1) : removed);
                }
                debug('%s %s : %s', layer.name, layerPath, req.originalUrl);
                if (layerError) layer.handle_error(layerError, req, res, next);
                else layer.handle_request(req, res, next);
            }
        };
        proto.process_params = function(layer, called, req, res, done) {
            var params = this.params;
            var keys = layer.keys;
            if (!keys || 0 === keys.length) return done();
            var i = 0;
            var name;
            var paramIndex = 0;
            var key;
            var paramVal;
            var paramCallbacks;
            var paramCalled;
            function param(err) {
                if (err) return done(err);
                if (i >= keys.length) return done();
                paramIndex = 0;
                key = keys[i++];
                name = key.name;
                paramVal = req.params[name];
                paramCallbacks = params[name];
                paramCalled = called[name];
                if (void 0 === paramVal || !paramCallbacks) return param();
                if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && 'route' !== paramCalled.error)) {
                    req.params[name] = paramCalled.value;
                    return param(paramCalled.error);
                }
                called[name] = paramCalled = {
                    error: null,
                    match: paramVal,
                    value: paramVal
                };
                paramCallback();
            }
            function paramCallback(err) {
                var fn = paramCallbacks[paramIndex++];
                paramCalled.value = req.params[key.name];
                if (err) {
                    paramCalled.error = err;
                    param(err);
                    return;
                }
                if (!fn) return param();
                try {
                    fn(req, res, paramCallback, paramVal, key.name);
                } catch (e) {
                    paramCallback(e);
                }
            }
            param();
        };
        proto.use = function(fn) {
            var offset = 0;
            var path = '/';
            if ('function' != typeof fn) {
                var arg = fn;
                while(Array.isArray(arg) && 0 !== arg.length)arg = arg[0];
                if ('function' != typeof arg) {
                    offset = 1;
                    path = fn;
                }
            }
            var callbacks = flatten(slice.call(arguments, offset));
            if (0 === callbacks.length) throw new TypeError('Router.use() requires a middleware function');
            for(var i = 0; i < callbacks.length; i++){
                var fn = callbacks[i];
                if ('function' != typeof fn) throw new TypeError('Router.use() requires a middleware function but got a ' + gettype(fn));
                debug('use %o %s', path, fn.name || '<anonymous>');
                var layer = new Layer(path, {
                    sensitive: this.caseSensitive,
                    strict: false,
                    end: false
                }, fn);
                layer.route = void 0;
                this.stack.push(layer);
            }
            return this;
        };
        proto.route = function(path) {
            var route = new Route(path);
            var layer = new Layer(path, {
                sensitive: this.caseSensitive,
                strict: this.strict,
                end: true
            }, route.dispatch.bind(route));
            layer.route = route;
            this.stack.push(layer);
            return route;
        };
        methods.concat('all').forEach(function(method) {
            proto[method] = function(path) {
                var route = this.route(path);
                route[method].apply(route, slice.call(arguments, 1));
                return this;
            };
        });
        function appendMethods(list, addition) {
            for(var i = 0; i < addition.length; i++){
                var method = addition[i];
                if (-1 === list.indexOf(method)) list.push(method);
            }
        }
        function getPathname(req) {
            try {
                return parseUrl(req).pathname;
            } catch (err) {
                return;
            }
        }
        function getProtohost(url) {
            if ('string' != typeof url || 0 === url.length || '/' === url[0]) return;
            var searchIndex = url.indexOf('?');
            var pathLength = -1 !== searchIndex ? searchIndex : url.length;
            var fqdnIndex = url.slice(0, pathLength).indexOf('://');
            return -1 !== fqdnIndex ? url.substring(0, url.indexOf('/', 3 + fqdnIndex)) : void 0;
        }
        function gettype(obj) {
            var type = typeof obj;
            if ('object' !== type) return type;
            return toString.call(obj).replace(objectRegExp, '$1');
        }
        function matchLayer(layer, path) {
            try {
                return layer.match(path);
            } catch (err) {
                return err;
            }
        }
        function mergeParams(params, parent) {
            if ('object' != typeof parent || !parent) return params;
            var obj = mixin({}, parent);
            if (!(0 in params) || !(0 in parent)) return mixin(obj, params);
            var i = 0;
            var o = 0;
            while(i in params)i++;
            while(o in parent)o++;
            for(i--; i >= 0; i--){
                params[i + o] = params[i];
                if (i < o) delete params[i];
            }
            return mixin(obj, params);
        }
        function restore(fn, obj) {
            var props = new Array(arguments.length - 2);
            var vals = new Array(arguments.length - 2);
            for(var i = 0; i < props.length; i++){
                props[i] = arguments[i + 2];
                vals[i] = obj[props[i]];
            }
            return function() {
                for(var i = 0; i < props.length; i++)obj[props[i]] = vals[i];
                return fn.apply(this, arguments);
            };
        }
        function sendOptionsResponse(res, options, next) {
            try {
                var body = options.join(',');
                res.set('Allow', body);
                res.send(body);
            } catch (err) {
                next(err);
            }
        }
        function wrap(old, fn) {
            return function() {
                var args = new Array(arguments.length + 1);
                args[0] = old;
                for(var i = 0, len = arguments.length; i < len; i++)args[i + 1] = arguments[i];
                fn.apply(this, args);
            };
        }
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/layer.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var pathRegexp = __webpack_require__("../node_modules/.pnpm/path-to-regexp@0.1.12/node_modules/path-to-regexp/index.js");
        var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('express:router:layer');
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        module.exports = Layer;
        function Layer(path, options, fn) {
            if (!(this instanceof Layer)) return new Layer(path, options, fn);
            debug('new %o', path);
            var opts = options || {};
            this.handle = fn;
            this.name = fn.name || '<anonymous>';
            this.params = void 0;
            this.path = void 0;
            this.regexp = pathRegexp(path, this.keys = [], opts);
            this.regexp.fast_star = '*' === path;
            this.regexp.fast_slash = '/' === path && false === opts.end;
        }
        Layer.prototype.handle_error = function(error, req, res, next) {
            var fn = this.handle;
            if (4 !== fn.length) return next(error);
            try {
                fn(error, req, res, next);
            } catch (err) {
                next(err);
            }
        };
        Layer.prototype.handle_request = function(req, res, next) {
            var fn = this.handle;
            if (fn.length > 3) return next();
            try {
                fn(req, res, next);
            } catch (err) {
                next(err);
            }
        };
        Layer.prototype.match = function(path) {
            var match;
            if (null != path) {
                if (this.regexp.fast_slash) {
                    this.params = {};
                    this.path = '';
                    return true;
                }
                if (this.regexp.fast_star) {
                    this.params = {
                        0: decode_param(path)
                    };
                    this.path = path;
                    return true;
                }
                match = this.regexp.exec(path);
            }
            if (!match) {
                this.params = void 0;
                this.path = void 0;
                return false;
            }
            this.params = {};
            this.path = match[0];
            var keys = this.keys;
            var params = this.params;
            for(var i = 1; i < match.length; i++){
                var key = keys[i - 1];
                var prop = key.name;
                var val = decode_param(match[i]);
                if (void 0 !== val || !hasOwnProperty.call(params, prop)) params[prop] = val;
            }
            return true;
        };
        function decode_param(val) {
            if ('string' != typeof val || 0 === val.length) return val;
            try {
                return decodeURIComponent(val);
            } catch (err) {
                if (err instanceof URIError) {
                    err.message = 'Failed to decode param \'' + val + '\'';
                    err.status = err.statusCode = 400;
                }
                throw err;
            }
        }
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/route.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('express:router:route');
        var flatten = __webpack_require__("../node_modules/.pnpm/array-flatten@1.1.1/node_modules/array-flatten/array-flatten.js");
        var Layer = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/router/layer.js");
        var methods = __webpack_require__("../node_modules/.pnpm/methods@1.1.2/node_modules/methods/index.js");
        var slice = Array.prototype.slice;
        var toString = Object.prototype.toString;
        module.exports = Route;
        function Route(path) {
            this.path = path;
            this.stack = [];
            debug('new %o', path);
            this.methods = {};
        }
        Route.prototype._handles_method = function(method) {
            if (this.methods._all) return true;
            var name = 'string' == typeof method ? method.toLowerCase() : method;
            if ('head' === name && !this.methods['head']) name = 'get';
            return Boolean(this.methods[name]);
        };
        Route.prototype._options = function() {
            var methods = Object.keys(this.methods);
            if (this.methods.get && !this.methods.head) methods.push('head');
            for(var i = 0; i < methods.length; i++)methods[i] = methods[i].toUpperCase();
            return methods;
        };
        Route.prototype.dispatch = function(req, res, done) {
            var idx = 0;
            var stack = this.stack;
            var sync = 0;
            if (0 === stack.length) return done();
            var method = 'string' == typeof req.method ? req.method.toLowerCase() : req.method;
            if ('head' === method && !this.methods['head']) method = 'get';
            req.route = this;
            next();
            function next(err) {
                if (err && 'route' === err) return done();
                if (err && 'router' === err) return done(err);
                if (++sync > 100) return setImmediate(next, err);
                var layer = stack[idx++];
                if (!layer) return done(err);
                if (layer.method && layer.method !== method) next(err);
                else if (err) layer.handle_error(err, req, res, next);
                else layer.handle_request(req, res, next);
                sync = 0;
            }
        };
        Route.prototype.all = function() {
            var handles = flatten(slice.call(arguments));
            for(var i = 0; i < handles.length; i++){
                var handle = handles[i];
                if ('function' != typeof handle) {
                    var type = toString.call(handle);
                    var msg = 'Route.all() requires a callback function but got a ' + type;
                    throw new TypeError(msg);
                }
                var layer = Layer('/', {}, handle);
                layer.method = void 0;
                this.methods._all = true;
                this.stack.push(layer);
            }
            return this;
        };
        methods.forEach(function(method) {
            Route.prototype[method] = function() {
                var handles = flatten(slice.call(arguments));
                for(var i = 0; i < handles.length; i++){
                    var handle = handles[i];
                    if ('function' != typeof handle) {
                        var type = toString.call(handle);
                        var msg = 'Route.' + method + '() requires a callback function but got a ' + type;
                        throw new Error(msg);
                    }
                    debug('%s %o', method, this.path);
                    var layer = Layer('/', {}, handle);
                    layer.method = method;
                    this.methods[method] = true;
                    this.stack.push(layer);
                }
                return this;
            };
        });
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/utils.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Buffer1 = __webpack_require__("../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer;
        var contentDisposition = __webpack_require__("../node_modules/.pnpm/content-disposition@0.5.4/node_modules/content-disposition/index.js");
        var contentType = __webpack_require__("../node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js");
        var deprecate = __webpack_require__("../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('express');
        var flatten = __webpack_require__("../node_modules/.pnpm/array-flatten@1.1.1/node_modules/array-flatten/array-flatten.js");
        var mime = __webpack_require__("../node_modules/.pnpm/send@0.19.0/node_modules/send/index.js").mime;
        var etag = __webpack_require__("../node_modules/.pnpm/etag@1.8.1/node_modules/etag/index.js");
        var proxyaddr = __webpack_require__("../node_modules/.pnpm/proxy-addr@2.0.7/node_modules/proxy-addr/index.js");
        var qs = __webpack_require__("../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/index.js");
        var querystring = __webpack_require__("querystring");
        exports1.etag = createETagGenerator({
            weak: false
        });
        exports1.wetag = createETagGenerator({
            weak: true
        });
        exports1.isAbsolute = function(path) {
            if ('/' === path[0]) return true;
            if (':' === path[1] && ('\\' === path[2] || '/' === path[2])) return true;
            if ('\\\\' === path.substring(0, 2)) return true;
        };
        exports1.flatten = deprecate.function(flatten, 'utils.flatten: use array-flatten npm module instead');
        exports1.normalizeType = function(type) {
            return ~type.indexOf('/') ? acceptParams(type) : {
                value: mime.lookup(type),
                params: {}
            };
        };
        exports1.normalizeTypes = function(types) {
            var ret = [];
            for(var i = 0; i < types.length; ++i)ret.push(exports1.normalizeType(types[i]));
            return ret;
        };
        exports1.contentDisposition = deprecate.function(contentDisposition, 'utils.contentDisposition: use content-disposition npm module instead');
        function acceptParams(str) {
            var parts = str.split(/ *; */);
            var ret = {
                value: parts[0],
                quality: 1,
                params: {}
            };
            for(var i = 1; i < parts.length; ++i){
                var pms = parts[i].split(/ *= */);
                if ('q' === pms[0]) ret.quality = parseFloat(pms[1]);
                else ret.params[pms[0]] = pms[1];
            }
            return ret;
        }
        exports1.compileETag = function(val) {
            var fn;
            if ('function' == typeof val) return val;
            switch(val){
                case true:
                case 'weak':
                    fn = exports1.wetag;
                    break;
                case false:
                    break;
                case 'strong':
                    fn = exports1.etag;
                    break;
                default:
                    throw new TypeError('unknown value for etag function: ' + val);
            }
            return fn;
        };
        exports1.compileQueryParser = function(val) {
            var fn;
            if ('function' == typeof val) return val;
            switch(val){
                case true:
                case 'simple':
                    fn = querystring.parse;
                    break;
                case false:
                    fn = newObject;
                    break;
                case 'extended':
                    fn = parseExtendedQueryString;
                    break;
                default:
                    throw new TypeError('unknown value for query parser function: ' + val);
            }
            return fn;
        };
        exports1.compileTrust = function(val) {
            if ('function' == typeof val) return val;
            if (true === val) return function() {
                return true;
            };
            if ('number' == typeof val) return function(a, i) {
                return i < val;
            };
            if ('string' == typeof val) val = val.split(',').map(function(v) {
                return v.trim();
            });
            return proxyaddr.compile(val || []);
        };
        exports1.setCharset = function(type, charset) {
            if (!type || !charset) return type;
            var parsed = contentType.parse(type);
            parsed.parameters.charset = charset;
            return contentType.format(parsed);
        };
        function createETagGenerator(options) {
            return function(body, encoding) {
                var buf = Buffer1.isBuffer(body) ? body : Buffer1.from(body, encoding);
                return etag(buf, options);
            };
        }
        function parseExtendedQueryString(str) {
            return qs.parse(str, {
                allowPrototypes: true
            });
        }
        function newObject() {
            return {};
        }
    },
    "../node_modules/.pnpm/express@4.21.2/node_modules/express/lib/view.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('express:view');
        var path = __webpack_require__("path");
        var fs = __webpack_require__("fs");
        var dirname = path.dirname;
        var basename = path.basename;
        var extname = path.extname;
        var join = path.join;
        var resolve = path.resolve;
        module.exports = View;
        function View(name, options) {
            var opts = options || {};
            this.defaultEngine = opts.defaultEngine;
            this.ext = extname(name);
            this.name = name;
            this.root = opts.root;
            if (!this.ext && !this.defaultEngine) throw new Error('No default engine was specified and no extension was provided.');
            var fileName = name;
            if (!this.ext) {
                this.ext = '.' !== this.defaultEngine[0] ? '.' + this.defaultEngine : this.defaultEngine;
                fileName += this.ext;
            }
            if (!opts.engines[this.ext]) {
                var mod = this.ext.slice(1);
                debug('require "%s"', mod);
                var fn = require(mod).__express;
                if ('function' != typeof fn) throw new Error('Module "' + mod + '" does not provide a view engine.');
                opts.engines[this.ext] = fn;
            }
            this.engine = opts.engines[this.ext];
            this.path = this.lookup(fileName);
        }
        View.prototype.lookup = function(name) {
            var path;
            var roots = [].concat(this.root);
            debug('lookup "%s"', name);
            for(var i = 0; i < roots.length && !path; i++){
                var root = roots[i];
                var loc = resolve(root, name);
                var dir = dirname(loc);
                var file = basename(loc);
                path = this.resolve(dir, file);
            }
            return path;
        };
        View.prototype.render = function(options, callback) {
            debug('render "%s"', this.path);
            this.engine(this.path, options, callback);
        };
        View.prototype.resolve = function(dir, file) {
            var ext = this.ext;
            var path = join(dir, file);
            var stat = tryStat(path);
            if (stat && stat.isFile()) return path;
            path = join(dir, basename(file, ext), 'index' + ext);
            stat = tryStat(path);
            if (stat && stat.isFile()) return path;
        };
        function tryStat(path) {
            debug('stat "%s"', path);
            try {
                return fs.statSync(path);
            } catch (e) {
                return;
            }
        }
    },
    "../node_modules/.pnpm/fast-json-stable-stringify@2.1.0/node_modules/fast-json-stable-stringify/index.js": function(module) {
        "use strict";
        module.exports = function(data, opts) {
            if (!opts) opts = {};
            if ('function' == typeof opts) opts = {
                cmp: opts
            };
            var cycles = 'boolean' == typeof opts.cycles ? opts.cycles : false;
            var cmp = opts.cmp && function(f) {
                return function(node) {
                    return function(a, b) {
                        var aobj = {
                            key: a,
                            value: node[a]
                        };
                        var bobj = {
                            key: b,
                            value: node[b]
                        };
                        return f(aobj, bobj);
                    };
                };
            }(opts.cmp);
            var seen = [];
            return function stringify(node) {
                if (node && node.toJSON && 'function' == typeof node.toJSON) node = node.toJSON();
                if (void 0 === node) return;
                if ('number' == typeof node) return isFinite(node) ? '' + node : 'null';
                if ('object' != typeof node) return JSON.stringify(node);
                var i, out;
                if (Array.isArray(node)) {
                    out = '[';
                    for(i = 0; i < node.length; i++){
                        if (i) out += ',';
                        out += stringify(node[i]) || 'null';
                    }
                    return out + ']';
                }
                if (null === node) return 'null';
                if (-1 !== seen.indexOf(node)) {
                    if (cycles) return JSON.stringify('__cycle__');
                    throw new TypeError('Converting circular structure to JSON');
                }
                var seenIndex = seen.push(node) - 1;
                var keys = Object.keys(node).sort(cmp && cmp(node));
                out = '';
                for(i = 0; i < keys.length; i++){
                    var key = keys[i];
                    var value = stringify(node[key]);
                    if (value) {
                        if (out) out += ',';
                        out += JSON.stringify(key) + ':' + value;
                    }
                }
                seen.splice(seenIndex, 1);
                return '{' + out + '}';
            }(data);
        };
    },
    "../node_modules/.pnpm/finalhandler@1.3.1/node_modules/finalhandler/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * finalhandler
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('finalhandler');
        var encodeUrl = __webpack_require__("../node_modules/.pnpm/encodeurl@2.0.0/node_modules/encodeurl/index.js");
        var escapeHtml = __webpack_require__("../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js");
        var onFinished = __webpack_require__("../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js");
        var parseUrl = __webpack_require__("../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js");
        var statuses = __webpack_require__("../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/index.js");
        var unpipe = __webpack_require__("../node_modules/.pnpm/unpipe@1.0.0/node_modules/unpipe/index.js");
        var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
        var NEWLINE_REGEXP = /\n/g;
        var defer = 'function' == typeof setImmediate ? setImmediate : function(fn) {
            process.nextTick(fn.bind.apply(fn, arguments));
        };
        var isFinished = onFinished.isFinished;
        function createHtmlDocument(message) {
            var body = escapeHtml(message).replace(NEWLINE_REGEXP, '<br>').replace(DOUBLE_SPACE_REGEXP, ' &nbsp;');
            return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
        }
        module.exports = finalhandler;
        function finalhandler(req, res, options) {
            var opts = options || {};
            var env = opts.env || process.env.NODE_ENV || 'development';
            var onerror = opts.onerror;
            return function(err) {
                var headers;
                var msg;
                var status;
                if (!err && headersSent(res)) return void debug('cannot 404 after headers sent');
                if (err) {
                    status = getErrorStatusCode(err);
                    if (void 0 === status) status = getResponseStatusCode(res);
                    else headers = getErrorHeaders(err);
                    msg = getErrorMessage(err, status, env);
                } else {
                    status = 404;
                    msg = 'Cannot ' + req.method + ' ' + encodeUrl(getResourceName(req));
                }
                debug('default %s', status);
                if (err && onerror) defer(onerror, err, req, res);
                if (headersSent(res)) {
                    debug('cannot %d after headers sent', status);
                    if (req.socket) req.socket.destroy();
                    return;
                }
                send(req, res, status, headers, msg);
            };
        }
        function getErrorHeaders(err) {
            if (!err.headers || 'object' != typeof err.headers) return;
            var headers = Object.create(null);
            var keys = Object.keys(err.headers);
            for(var i = 0; i < keys.length; i++){
                var key = keys[i];
                headers[key] = err.headers[key];
            }
            return headers;
        }
        function getErrorMessage(err, status, env) {
            var msg;
            if ('production' !== env) {
                msg = err.stack;
                if (!msg && 'function' == typeof err.toString) msg = err.toString();
            }
            return msg || statuses.message[status];
        }
        function getErrorStatusCode(err) {
            if ('number' == typeof err.status && err.status >= 400 && err.status < 600) return err.status;
            if ('number' == typeof err.statusCode && err.statusCode >= 400 && err.statusCode < 600) return err.statusCode;
        }
        function getResourceName(req) {
            try {
                return parseUrl.original(req).pathname;
            } catch (e) {
                return 'resource';
            }
        }
        function getResponseStatusCode(res) {
            var status = res.statusCode;
            if ('number' != typeof status || status < 400 || status > 599) status = 500;
            return status;
        }
        function headersSent(res) {
            return 'boolean' != typeof res.headersSent ? Boolean(res._header) : res.headersSent;
        }
        function send(req, res, status, headers, message) {
            function write() {
                var body = createHtmlDocument(message);
                res.statusCode = status;
                if (req.httpVersionMajor < 2) res.statusMessage = statuses.message[status];
                res.removeHeader('Content-Encoding');
                res.removeHeader('Content-Language');
                res.removeHeader('Content-Range');
                setHeaders(res, headers);
                res.setHeader('Content-Security-Policy', "default-src 'none'");
                res.setHeader('X-Content-Type-Options', 'nosniff');
                res.setHeader('Content-Type', 'text/html; charset=utf-8');
                res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'));
                if ('HEAD' === req.method) return void res.end();
                res.end(body, 'utf8');
            }
            if (isFinished(req)) return void write();
            unpipe(req);
            onFinished(req, write);
            req.resume();
        }
        function setHeaders(res, headers) {
            if (!headers) return;
            var keys = Object.keys(headers);
            for(var i = 0; i < keys.length; i++){
                var key = keys[i];
                res.setHeader(key, headers[key]);
            }
        }
    },
    "../node_modules/.pnpm/forwarded@0.2.0/node_modules/forwarded/index.js": function(module) {
        "use strict";
        /*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = forwarded;
        function forwarded(req) {
            if (!req) throw new TypeError('argument req is required');
            var proxyAddrs = parse(req.headers['x-forwarded-for'] || '');
            var socketAddr = getSocketAddr(req);
            var addrs = [
                socketAddr
            ].concat(proxyAddrs);
            return addrs;
        }
        function getSocketAddr(req) {
            return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
        }
        function parse(header) {
            var end = header.length;
            var list = [];
            var start = header.length;
            for(var i = header.length - 1; i >= 0; i--)switch(header.charCodeAt(i)){
                case 0x20:
                    if (start === end) start = end = i;
                    break;
                case 0x2c:
                    if (start !== end) list.push(header.substring(start, end));
                    start = end = i;
                    break;
                default:
                    start = i;
                    break;
            }
            if (start !== end) list.push(header.substring(start, end));
            return list;
        }
    },
    "../node_modules/.pnpm/fresh@0.5.2/node_modules/fresh/index.js": function(module) {
        "use strict";
        /*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
        module.exports = fresh;
        function fresh(reqHeaders, resHeaders) {
            var modifiedSince = reqHeaders['if-modified-since'];
            var noneMatch = reqHeaders['if-none-match'];
            if (!modifiedSince && !noneMatch) return false;
            var cacheControl = reqHeaders['cache-control'];
            if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) return false;
            if (noneMatch && '*' !== noneMatch) {
                var etag = resHeaders['etag'];
                if (!etag) return false;
                var etagStale = true;
                var matches = parseTokenList(noneMatch);
                for(var i = 0; i < matches.length; i++){
                    var match = matches[i];
                    if (match === etag || match === 'W/' + etag || 'W/' + match === etag) {
                        etagStale = false;
                        break;
                    }
                }
                if (etagStale) return false;
            }
            if (modifiedSince) {
                var lastModified = resHeaders['last-modified'];
                var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));
                if (modifiedStale) return false;
            }
            return true;
        }
        function parseHttpDate(date) {
            var timestamp = date && Date.parse(date);
            return 'number' == typeof timestamp ? timestamp : NaN;
        }
        function parseTokenList(str) {
            var end = 0;
            var list = [];
            var start = 0;
            for(var i = 0, len = str.length; i < len; i++)switch(str.charCodeAt(i)){
                case 0x20:
                    if (start === end) start = end = i + 1;
                    break;
                case 0x2c:
                    list.push(str.substring(start, end));
                    start = end = i + 1;
                    break;
                default:
                    end = i + 1;
                    break;
            }
            list.push(str.substring(start, end));
            return list;
        }
    },
    "../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js": function(module) {
        "use strict";
        var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
        var toStr = Object.prototype.toString;
        var max = Math.max;
        var funcType = '[object Function]';
        var concatty = function(a, b) {
            var arr = [];
            for(var i = 0; i < a.length; i += 1)arr[i] = a[i];
            for(var j = 0; j < b.length; j += 1)arr[j + a.length] = b[j];
            return arr;
        };
        var slicy = function(arrLike, offset) {
            var arr = [];
            for(var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1)arr[j] = arrLike[i];
            return arr;
        };
        var joiny = function(arr, joiner) {
            var str = '';
            for(var i = 0; i < arr.length; i += 1){
                str += arr[i];
                if (i + 1 < arr.length) str += joiner;
            }
            return str;
        };
        module.exports = function(that) {
            var target = this;
            if ('function' != typeof target || toStr.apply(target) !== funcType) throw new TypeError(ERROR_MESSAGE + target);
            var args = slicy(arguments, 1);
            var bound;
            var binder = function() {
                if (this instanceof bound) {
                    var result = target.apply(this, concatty(args, arguments));
                    if (Object(result) === result) return result;
                    return this;
                }
                return target.apply(that, concatty(args, arguments));
            };
            var boundLength = max(0, target.length - args.length);
            var boundArgs = [];
            for(var i = 0; i < boundLength; i++)boundArgs[i] = '$' + i;
            bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
            if (target.prototype) {
                var Empty = function() {};
                Empty.prototype = target.prototype;
                bound.prototype = new Empty();
                Empty.prototype = null;
            }
            return bound;
        };
    },
    "../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var implementation = __webpack_require__("../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js");
        module.exports = Function.prototype.bind || implementation;
    },
    "../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var undefined;
        var $Object = __webpack_require__("../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js");
        var $Error = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js");
        var $EvalError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js");
        var $RangeError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js");
        var $ReferenceError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js");
        var $SyntaxError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js");
        var $TypeError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
        var $URIError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js");
        var abs = __webpack_require__("../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js");
        var floor = __webpack_require__("../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js");
        var max = __webpack_require__("../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js");
        var min = __webpack_require__("../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js");
        var pow = __webpack_require__("../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js");
        var round = __webpack_require__("../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js");
        var sign = __webpack_require__("../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js");
        var $Function = Function;
        var getEvalledConstructor = function(expressionSyntax) {
            try {
                return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
            } catch (e) {}
        };
        var $gOPD = __webpack_require__("../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js");
        var $defineProperty = __webpack_require__("../node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js");
        var throwTypeError = function() {
            throw new $TypeError();
        };
        var ThrowTypeError = $gOPD ? function() {
            try {
                arguments.callee;
                return throwTypeError;
            } catch (calleeThrows) {
                try {
                    return $gOPD(arguments, 'callee').get;
                } catch (gOPDthrows) {
                    return throwTypeError;
                }
            }
        }() : throwTypeError;
        var hasSymbols = __webpack_require__("../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js")();
        var getProto = __webpack_require__("../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js");
        var $ObjectGPO = __webpack_require__("../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js");
        var $ReflectGPO = __webpack_require__("../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js");
        var $apply = __webpack_require__("../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js");
        var $call = __webpack_require__("../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js");
        var needsEval = {};
        var TypedArray = 'undefined' != typeof Uint8Array && getProto ? getProto(Uint8Array) : undefined;
        var INTRINSICS = {
            __proto__: null,
            '%AggregateError%': 'undefined' == typeof AggregateError ? undefined : AggregateError,
            '%Array%': Array,
            '%ArrayBuffer%': 'undefined' == typeof ArrayBuffer ? undefined : ArrayBuffer,
            '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
            '%AsyncFromSyncIteratorPrototype%': undefined,
            '%AsyncFunction%': needsEval,
            '%AsyncGenerator%': needsEval,
            '%AsyncGeneratorFunction%': needsEval,
            '%AsyncIteratorPrototype%': needsEval,
            '%Atomics%': 'undefined' == typeof Atomics ? undefined : Atomics,
            '%BigInt%': 'undefined' == typeof BigInt ? undefined : BigInt,
            '%BigInt64Array%': 'undefined' == typeof BigInt64Array ? undefined : BigInt64Array,
            '%BigUint64Array%': 'undefined' == typeof BigUint64Array ? undefined : BigUint64Array,
            '%Boolean%': Boolean,
            '%DataView%': 'undefined' == typeof DataView ? undefined : DataView,
            '%Date%': Date,
            '%decodeURI%': decodeURI,
            '%decodeURIComponent%': decodeURIComponent,
            '%encodeURI%': encodeURI,
            '%encodeURIComponent%': encodeURIComponent,
            '%Error%': $Error,
            '%eval%': eval,
            '%EvalError%': $EvalError,
            '%Float16Array%': 'undefined' == typeof Float16Array ? undefined : Float16Array,
            '%Float32Array%': 'undefined' == typeof Float32Array ? undefined : Float32Array,
            '%Float64Array%': 'undefined' == typeof Float64Array ? undefined : Float64Array,
            '%FinalizationRegistry%': 'undefined' == typeof FinalizationRegistry ? undefined : FinalizationRegistry,
            '%Function%': $Function,
            '%GeneratorFunction%': needsEval,
            '%Int8Array%': 'undefined' == typeof Int8Array ? undefined : Int8Array,
            '%Int16Array%': 'undefined' == typeof Int16Array ? undefined : Int16Array,
            '%Int32Array%': 'undefined' == typeof Int32Array ? undefined : Int32Array,
            '%isFinite%': isFinite,
            '%isNaN%': isNaN,
            '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
            '%JSON%': 'object' == typeof JSON ? JSON : undefined,
            '%Map%': 'undefined' == typeof Map ? undefined : Map,
            '%MapIteratorPrototype%': 'undefined' != typeof Map && hasSymbols && getProto ? getProto(new Map()[Symbol.iterator]()) : undefined,
            '%Math%': Math,
            '%Number%': Number,
            '%Object%': $Object,
            "%Object.getOwnPropertyDescriptor%": $gOPD,
            '%parseFloat%': parseFloat,
            '%parseInt%': parseInt,
            '%Promise%': 'undefined' == typeof Promise ? undefined : Promise,
            '%Proxy%': 'undefined' == typeof Proxy ? undefined : Proxy,
            '%RangeError%': $RangeError,
            '%ReferenceError%': $ReferenceError,
            '%Reflect%': 'undefined' == typeof Reflect ? undefined : Reflect,
            '%RegExp%': RegExp,
            '%Set%': 'undefined' == typeof Set ? undefined : Set,
            '%SetIteratorPrototype%': 'undefined' != typeof Set && hasSymbols && getProto ? getProto(new Set()[Symbol.iterator]()) : undefined,
            '%SharedArrayBuffer%': 'undefined' == typeof SharedArrayBuffer ? undefined : SharedArrayBuffer,
            '%String%': String,
            '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
            '%Symbol%': hasSymbols ? Symbol : undefined,
            '%SyntaxError%': $SyntaxError,
            '%ThrowTypeError%': ThrowTypeError,
            '%TypedArray%': TypedArray,
            '%TypeError%': $TypeError,
            '%Uint8Array%': 'undefined' == typeof Uint8Array ? undefined : Uint8Array,
            '%Uint8ClampedArray%': 'undefined' == typeof Uint8ClampedArray ? undefined : Uint8ClampedArray,
            '%Uint16Array%': 'undefined' == typeof Uint16Array ? undefined : Uint16Array,
            '%Uint32Array%': 'undefined' == typeof Uint32Array ? undefined : Uint32Array,
            '%URIError%': $URIError,
            '%WeakMap%': 'undefined' == typeof WeakMap ? undefined : WeakMap,
            '%WeakRef%': 'undefined' == typeof WeakRef ? undefined : WeakRef,
            '%WeakSet%': 'undefined' == typeof WeakSet ? undefined : WeakSet,
            '%Function.prototype.call%': $call,
            '%Function.prototype.apply%': $apply,
            '%Object.defineProperty%': $defineProperty,
            '%Object.getPrototypeOf%': $ObjectGPO,
            '%Math.abs%': abs,
            '%Math.floor%': floor,
            '%Math.max%': max,
            '%Math.min%': min,
            '%Math.pow%': pow,
            '%Math.round%': round,
            '%Math.sign%': sign,
            '%Reflect.getPrototypeOf%': $ReflectGPO
        };
        if (getProto) try {
            null.error;
        } catch (e) {
            var errorProto = getProto(getProto(e));
            INTRINSICS['%Error.prototype%'] = errorProto;
        }
        var doEval = function doEval(name) {
            var value;
            if ('%AsyncFunction%' === name) value = getEvalledConstructor('async function () {}');
            else if ('%GeneratorFunction%' === name) value = getEvalledConstructor('function* () {}');
            else if ('%AsyncGeneratorFunction%' === name) value = getEvalledConstructor('async function* () {}');
            else if ('%AsyncGenerator%' === name) {
                var fn = doEval('%AsyncGeneratorFunction%');
                if (fn) value = fn.prototype;
            } else if ('%AsyncIteratorPrototype%' === name) {
                var gen = doEval('%AsyncGenerator%');
                if (gen && getProto) value = getProto(gen.prototype);
            }
            INTRINSICS[name] = value;
            return value;
        };
        var LEGACY_ALIASES = {
            __proto__: null,
            '%ArrayBufferPrototype%': [
                'ArrayBuffer',
                'prototype'
            ],
            '%ArrayPrototype%': [
                'Array',
                'prototype'
            ],
            '%ArrayProto_entries%': [
                'Array',
                'prototype',
                'entries'
            ],
            '%ArrayProto_forEach%': [
                'Array',
                'prototype',
                'forEach'
            ],
            '%ArrayProto_keys%': [
                'Array',
                'prototype',
                'keys'
            ],
            '%ArrayProto_values%': [
                'Array',
                'prototype',
                'values'
            ],
            '%AsyncFunctionPrototype%': [
                'AsyncFunction',
                'prototype'
            ],
            '%AsyncGenerator%': [
                'AsyncGeneratorFunction',
                'prototype'
            ],
            '%AsyncGeneratorPrototype%': [
                'AsyncGeneratorFunction',
                'prototype',
                'prototype'
            ],
            '%BooleanPrototype%': [
                'Boolean',
                'prototype'
            ],
            '%DataViewPrototype%': [
                'DataView',
                'prototype'
            ],
            '%DatePrototype%': [
                'Date',
                'prototype'
            ],
            '%ErrorPrototype%': [
                'Error',
                'prototype'
            ],
            '%EvalErrorPrototype%': [
                'EvalError',
                'prototype'
            ],
            '%Float32ArrayPrototype%': [
                'Float32Array',
                'prototype'
            ],
            '%Float64ArrayPrototype%': [
                'Float64Array',
                'prototype'
            ],
            '%FunctionPrototype%': [
                'Function',
                'prototype'
            ],
            '%Generator%': [
                'GeneratorFunction',
                'prototype'
            ],
            '%GeneratorPrototype%': [
                'GeneratorFunction',
                'prototype',
                'prototype'
            ],
            '%Int8ArrayPrototype%': [
                'Int8Array',
                'prototype'
            ],
            '%Int16ArrayPrototype%': [
                'Int16Array',
                'prototype'
            ],
            '%Int32ArrayPrototype%': [
                'Int32Array',
                'prototype'
            ],
            '%JSONParse%': [
                'JSON',
                'parse'
            ],
            '%JSONStringify%': [
                'JSON',
                'stringify'
            ],
            '%MapPrototype%': [
                'Map',
                'prototype'
            ],
            '%NumberPrototype%': [
                'Number',
                'prototype'
            ],
            '%ObjectPrototype%': [
                'Object',
                'prototype'
            ],
            '%ObjProto_toString%': [
                'Object',
                'prototype',
                'toString'
            ],
            '%ObjProto_valueOf%': [
                'Object',
                'prototype',
                'valueOf'
            ],
            '%PromisePrototype%': [
                'Promise',
                'prototype'
            ],
            '%PromiseProto_then%': [
                'Promise',
                'prototype',
                'then'
            ],
            '%Promise_all%': [
                'Promise',
                'all'
            ],
            '%Promise_reject%': [
                'Promise',
                'reject'
            ],
            '%Promise_resolve%': [
                'Promise',
                'resolve'
            ],
            '%RangeErrorPrototype%': [
                'RangeError',
                'prototype'
            ],
            '%ReferenceErrorPrototype%': [
                'ReferenceError',
                'prototype'
            ],
            '%RegExpPrototype%': [
                'RegExp',
                'prototype'
            ],
            '%SetPrototype%': [
                'Set',
                'prototype'
            ],
            '%SharedArrayBufferPrototype%': [
                'SharedArrayBuffer',
                'prototype'
            ],
            '%StringPrototype%': [
                'String',
                'prototype'
            ],
            '%SymbolPrototype%': [
                'Symbol',
                'prototype'
            ],
            '%SyntaxErrorPrototype%': [
                'SyntaxError',
                'prototype'
            ],
            '%TypedArrayPrototype%': [
                'TypedArray',
                'prototype'
            ],
            '%TypeErrorPrototype%': [
                'TypeError',
                'prototype'
            ],
            '%Uint8ArrayPrototype%': [
                'Uint8Array',
                'prototype'
            ],
            '%Uint8ClampedArrayPrototype%': [
                'Uint8ClampedArray',
                'prototype'
            ],
            '%Uint16ArrayPrototype%': [
                'Uint16Array',
                'prototype'
            ],
            '%Uint32ArrayPrototype%': [
                'Uint32Array',
                'prototype'
            ],
            '%URIErrorPrototype%': [
                'URIError',
                'prototype'
            ],
            '%WeakMapPrototype%': [
                'WeakMap',
                'prototype'
            ],
            '%WeakSetPrototype%': [
                'WeakSet',
                'prototype'
            ]
        };
        var bind = __webpack_require__("../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
        var hasOwn = __webpack_require__("../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js");
        var $concat = bind.call($call, Array.prototype.concat);
        var $spliceApply = bind.call($apply, Array.prototype.splice);
        var $replace = bind.call($call, String.prototype.replace);
        var $strSlice = bind.call($call, String.prototype.slice);
        var $exec = bind.call($call, RegExp.prototype.exec);
        var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
        var reEscapeChar = /\\(\\)?/g;
        var stringToPath = function(string) {
            var first = $strSlice(string, 0, 1);
            var last = $strSlice(string, -1);
            if ('%' === first && '%' !== last) throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
            if ('%' === last && '%' !== first) throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
            var result = [];
            $replace(string, rePropName, function(match, number, quote, subString) {
                result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
            });
            return result;
        };
        var getBaseIntrinsic = function(name, allowMissing) {
            var intrinsicName = name;
            var alias;
            if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
                alias = LEGACY_ALIASES[intrinsicName];
                intrinsicName = '%' + alias[0] + '%';
            }
            if (hasOwn(INTRINSICS, intrinsicName)) {
                var value = INTRINSICS[intrinsicName];
                if (value === needsEval) value = doEval(intrinsicName);
                if (void 0 === value && !allowMissing) throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
                return {
                    alias: alias,
                    name: intrinsicName,
                    value: value
                };
            }
            throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
        };
        module.exports = function(name, allowMissing) {
            if ('string' != typeof name || 0 === name.length) throw new $TypeError('intrinsic name must be a non-empty string');
            if (arguments.length > 1 && 'boolean' != typeof allowMissing) throw new $TypeError('"allowMissing" argument must be a boolean');
            if (null === $exec(/^%?[^%]*%?$/, name)) throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
            var parts = stringToPath(name);
            var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
            var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
            var intrinsicRealName = intrinsic.name;
            var value = intrinsic.value;
            var skipFurtherCaching = false;
            var alias = intrinsic.alias;
            if (alias) {
                intrinsicBaseName = alias[0];
                $spliceApply(parts, $concat([
                    0,
                    1
                ], alias));
            }
            for(var i = 1, isOwn = true; i < parts.length; i += 1){
                var part = parts[i];
                var first = $strSlice(part, 0, 1);
                var last = $strSlice(part, -1);
                if (('"' === first || "'" === first || '`' === first || '"' === last || "'" === last || '`' === last) && first !== last) throw new $SyntaxError('property names with quotes must have matching quotes');
                if ('constructor' === part || !isOwn) skipFurtherCaching = true;
                intrinsicBaseName += '.' + part;
                intrinsicRealName = '%' + intrinsicBaseName + '%';
                if (hasOwn(INTRINSICS, intrinsicRealName)) value = INTRINSICS[intrinsicRealName];
                else if (null != value) {
                    if (!(part in value)) {
                        if (!allowMissing) throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                        return;
                    }
                    if ($gOPD && i + 1 >= parts.length) {
                        var desc = $gOPD(value, part);
                        isOwn = !!desc;
                        value = isOwn && 'get' in desc && !('originalValue' in desc.get) ? desc.get : value[part];
                    } else {
                        isOwn = hasOwn(value, part);
                        value = value[part];
                    }
                    if (isOwn && !skipFurtherCaching) INTRINSICS[intrinsicRealName] = value;
                }
            }
            return value;
        };
    },
    "../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var $Object = __webpack_require__("../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js");
        module.exports = $Object.getPrototypeOf || null;
    },
    "../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js": function(module) {
        "use strict";
        module.exports = 'undefined' != typeof Reflect && Reflect.getPrototypeOf || null;
    },
    "../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var reflectGetProto = __webpack_require__("../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js");
        var originalGetProto = __webpack_require__("../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js");
        var getDunderProto = __webpack_require__("../node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js");
        module.exports = reflectGetProto ? function(O) {
            return reflectGetProto(O);
        } : originalGetProto ? function(O) {
            if (!O || 'object' != typeof O && 'function' != typeof O) throw new TypeError('getProto: not an object');
            return originalGetProto(O);
        } : getDunderProto ? function(O) {
            return getDunderProto(O);
        } : null;
    },
    "../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js": function(module) {
        "use strict";
        module.exports = Object.getOwnPropertyDescriptor;
    },
    "../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var $gOPD = __webpack_require__("../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js");
        if ($gOPD) try {
            $gOPD([], 'length');
        } catch (e) {
            $gOPD = null;
        }
        module.exports = $gOPD;
    },
    "../node_modules/.pnpm/has-flag@3.0.0/node_modules/has-flag/index.js": function(module) {
        "use strict";
        module.exports = (flag, argv)=>{
            argv = argv || process.argv;
            const prefix = flag.startsWith('-') ? '' : 1 === flag.length ? '-' : '--';
            const pos = argv.indexOf(prefix + flag);
            const terminatorPos = argv.indexOf('--');
            return -1 !== pos && (-1 === terminatorPos ? true : pos < terminatorPos);
        };
    },
    "../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var origSymbol = 'undefined' != typeof Symbol && Symbol;
        var hasSymbolSham = __webpack_require__("../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js");
        module.exports = function() {
            if ('function' != typeof origSymbol) return false;
            if ('function' != typeof Symbol) return false;
            if ('symbol' != typeof origSymbol('foo')) return false;
            if ('symbol' != typeof Symbol('bar')) return false;
            return hasSymbolSham();
        };
    },
    "../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js": function(module) {
        "use strict";
        module.exports = function() {
            if ('function' != typeof Symbol || 'function' != typeof Object.getOwnPropertySymbols) return false;
            if ('symbol' == typeof Symbol.iterator) return true;
            var obj = {};
            var sym = Symbol('test');
            var symObj = Object(sym);
            if ('string' == typeof sym) return false;
            if ('[object Symbol]' !== Object.prototype.toString.call(sym)) return false;
            if ('[object Symbol]' !== Object.prototype.toString.call(symObj)) return false;
            var symVal = 42;
            obj[sym] = symVal;
            for(var _ in obj)return false;
            if ('function' == typeof Object.keys && 0 !== Object.keys(obj).length) return false;
            if ('function' == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(obj).length) return false;
            var syms = Object.getOwnPropertySymbols(obj);
            if (1 !== syms.length || syms[0] !== sym) return false;
            if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) return false;
            if ('function' == typeof Object.getOwnPropertyDescriptor) {
                var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
                if (descriptor.value !== symVal || true !== descriptor.enumerable) return false;
            }
            return true;
        };
    },
    "../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var call = Function.prototype.call;
        var $hasOwn = Object.prototype.hasOwnProperty;
        var bind = __webpack_require__("../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js");
        module.exports = bind.call(call, $hasOwn);
    },
    "../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var deprecate = __webpack_require__("../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('http-errors');
        var setPrototypeOf = __webpack_require__("../node_modules/.pnpm/setprototypeof@1.2.0/node_modules/setprototypeof/index.js");
        var statuses = __webpack_require__("../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/index.js");
        var inherits = __webpack_require__("../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js");
        var toIdentifier = __webpack_require__("../node_modules/.pnpm/toidentifier@1.0.1/node_modules/toidentifier/index.js");
        module.exports = createError;
        module.exports.HttpError = createHttpErrorConstructor();
        module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
        populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);
        function codeClass(status) {
            return Number(String(status).charAt(0) + '00');
        }
        function createError() {
            var err;
            var msg;
            var status = 500;
            var props = {};
            for(var i = 0; i < arguments.length; i++){
                var arg = arguments[i];
                var type = typeof arg;
                if ('object' === type && arg instanceof Error) {
                    err = arg;
                    status = err.status || err.statusCode || status;
                } else if ('number' === type && 0 === i) status = arg;
                else if ('string' === type) msg = arg;
                else if ('object' === type) props = arg;
                else throw new TypeError('argument #' + (i + 1) + ' unsupported type ' + type);
            }
            if ('number' == typeof status && (status < 400 || status >= 600)) deprecate('non-error status code; use only 4xx or 5xx status codes');
            if ('number' != typeof status || !statuses.message[status] && (status < 400 || status >= 600)) status = 500;
            var HttpError = createError[status] || createError[codeClass(status)];
            if (!err) {
                err = HttpError ? new HttpError(msg) : new Error(msg || statuses.message[status]);
                Error.captureStackTrace(err, createError);
            }
            if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
                err.expose = status < 500;
                err.status = err.statusCode = status;
            }
            for(var key in props)if ('status' !== key && 'statusCode' !== key) err[key] = props[key];
            return err;
        }
        function createHttpErrorConstructor() {
            function HttpError() {
                throw new TypeError('cannot construct abstract class');
            }
            inherits(HttpError, Error);
            return HttpError;
        }
        function createClientErrorConstructor(HttpError, name, code) {
            var className = toClassName(name);
            function ClientError(message) {
                var msg = null != message ? message : statuses.message[code];
                var err = new Error(msg);
                Error.captureStackTrace(err, ClientError);
                setPrototypeOf(err, ClientError.prototype);
                Object.defineProperty(err, 'message', {
                    enumerable: true,
                    configurable: true,
                    value: msg,
                    writable: true
                });
                Object.defineProperty(err, 'name', {
                    enumerable: false,
                    configurable: true,
                    value: className,
                    writable: true
                });
                return err;
            }
            inherits(ClientError, HttpError);
            nameFunc(ClientError, className);
            ClientError.prototype.status = code;
            ClientError.prototype.statusCode = code;
            ClientError.prototype.expose = true;
            return ClientError;
        }
        function createIsHttpErrorFunction(HttpError) {
            return function(val) {
                if (!val || 'object' != typeof val) return false;
                if (val instanceof HttpError) return true;
                return val instanceof Error && 'boolean' == typeof val.expose && 'number' == typeof val.statusCode && val.status === val.statusCode;
            };
        }
        function createServerErrorConstructor(HttpError, name, code) {
            var className = toClassName(name);
            function ServerError(message) {
                var msg = null != message ? message : statuses.message[code];
                var err = new Error(msg);
                Error.captureStackTrace(err, ServerError);
                setPrototypeOf(err, ServerError.prototype);
                Object.defineProperty(err, 'message', {
                    enumerable: true,
                    configurable: true,
                    value: msg,
                    writable: true
                });
                Object.defineProperty(err, 'name', {
                    enumerable: false,
                    configurable: true,
                    value: className,
                    writable: true
                });
                return err;
            }
            inherits(ServerError, HttpError);
            nameFunc(ServerError, className);
            ServerError.prototype.status = code;
            ServerError.prototype.statusCode = code;
            ServerError.prototype.expose = false;
            return ServerError;
        }
        function nameFunc(func, name) {
            var desc = Object.getOwnPropertyDescriptor(func, 'name');
            if (desc && desc.configurable) {
                desc.value = name;
                Object.defineProperty(func, 'name', desc);
            }
        }
        function populateConstructorExports(exports1, codes, HttpError) {
            codes.forEach(function(code) {
                var CodeError;
                var name = toIdentifier(statuses.message[code]);
                switch(codeClass(code)){
                    case 400:
                        CodeError = createClientErrorConstructor(HttpError, name, code);
                        break;
                    case 500:
                        CodeError = createServerErrorConstructor(HttpError, name, code);
                        break;
                }
                if (CodeError) {
                    exports1[code] = CodeError;
                    exports1[name] = CodeError;
                }
            });
        }
        function toClassName(name) {
            return 'Error' !== name.substr(-5) ? name + 'Error' : name;
        }
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/dbcs-codec.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js").Buffer;
        exports1._dbcs = DBCSCodec;
        var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1000, UNASSIGNED_NODE = new Array(0x100), DEF_CHAR = -1;
        for(var i = 0; i < 0x100; i++)UNASSIGNED_NODE[i] = UNASSIGNED;
        function DBCSCodec(codecOptions, iconv) {
            this.encodingName = codecOptions.encodingName;
            if (!codecOptions) throw new Error("DBCS codec is called without the data.");
            if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");
            var mappingTable = codecOptions.table();
            this.decodeTables = [];
            this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
            this.decodeTableSeq = [];
            for(var i = 0; i < mappingTable.length; i++)this._addDecodeChunk(mappingTable[i]);
            this.defaultCharUnicode = iconv.defaultCharUnicode;
            this.encodeTable = [];
            this.encodeTableSeq = [];
            var skipEncodeChars = {};
            if (codecOptions.encodeSkipVals) for(var i = 0; i < codecOptions.encodeSkipVals.length; i++){
                var val = codecOptions.encodeSkipVals[i];
                if ('number' == typeof val) skipEncodeChars[val] = true;
                else for(var j = val.from; j <= val.to; j++)skipEncodeChars[j] = true;
            }
            this._fillEncodeTable(0, 0, skipEncodeChars);
            if (codecOptions.encodeAdd) {
                for(var uChar in codecOptions.encodeAdd)if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
            }
            this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
            if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
            if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
            if ('function' == typeof codecOptions.gb18030) {
                this.gb18030 = codecOptions.gb18030();
                var thirdByteNodeIdx = this.decodeTables.length;
                var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
                var fourthByteNodeIdx = this.decodeTables.length;
                var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
                for(var i = 0x81; i <= 0xFE; i++){
                    var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
                    var secondByteNode = this.decodeTables[secondByteNodeIdx];
                    for(var j = 0x30; j <= 0x39; j++)secondByteNode[j] = NODE_START - thirdByteNodeIdx;
                }
                for(var i = 0x81; i <= 0xFE; i++)thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
                for(var i = 0x30; i <= 0x39; i++)fourthByteNode[i] = GB18030_CODE;
            }
        }
        DBCSCodec.prototype.encoder = DBCSEncoder;
        DBCSCodec.prototype.decoder = DBCSDecoder;
        DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
            var bytes = [];
            for(; addr > 0; addr >>= 8)bytes.push(0xFF & addr);
            if (0 == bytes.length) bytes.push(0);
            var node = this.decodeTables[0];
            for(var i = bytes.length - 1; i > 0; i--){
                var val = node[bytes[i]];
                if (val == UNASSIGNED) {
                    node[bytes[i]] = NODE_START - this.decodeTables.length;
                    this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
                } else if (val <= NODE_START) node = this.decodeTables[NODE_START - val];
                else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
            }
            return node;
        };
        DBCSCodec.prototype._addDecodeChunk = function(chunk) {
            var curAddr = parseInt(chunk[0], 16);
            var writeTable = this._getDecodeTrieNode(curAddr);
            curAddr &= 0xFF;
            for(var k = 1; k < chunk.length; k++){
                var part = chunk[k];
                if ("string" == typeof part) for(var l = 0; l < part.length;){
                    var code = part.charCodeAt(l++);
                    if (0xD800 <= code && code < 0xDC00) {
                        var codeTrail = part.charCodeAt(l++);
                        if (0xDC00 <= codeTrail && codeTrail < 0xE000) writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
                        else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
                    } else if (0x0FF0 < code && code <= 0x0FFF) {
                        var len = 0xFFF - code + 2;
                        var seq = [];
                        for(var m = 0; m < len; m++)seq.push(part.charCodeAt(l++));
                        writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                        this.decodeTableSeq.push(seq);
                    } else writeTable[curAddr++] = code;
                }
                else if ("number" == typeof part) {
                    var charCode = writeTable[curAddr - 1] + 1;
                    for(var l = 0; l < part; l++)writeTable[curAddr++] = charCode++;
                } else throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
            }
            if (curAddr > 0xFF) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
        };
        DBCSCodec.prototype._getEncodeBucket = function(uCode) {
            var high = uCode >> 8;
            if (void 0 === this.encodeTable[high]) this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
            return this.encodeTable[high];
        };
        DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
            var bucket = this._getEncodeBucket(uCode);
            var low = 0xFF & uCode;
            if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
            else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
        };
        DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
            var uCode = seq[0];
            var bucket = this._getEncodeBucket(uCode);
            var low = 0xFF & uCode;
            var node;
            if (bucket[low] <= SEQ_START) node = this.encodeTableSeq[SEQ_START - bucket[low]];
            else {
                node = {};
                if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
                bucket[low] = SEQ_START - this.encodeTableSeq.length;
                this.encodeTableSeq.push(node);
            }
            for(var j = 1; j < seq.length - 1; j++){
                var oldVal = node[uCode];
                if ('object' == typeof oldVal) node = oldVal;
                else {
                    node = node[uCode] = {};
                    if (void 0 !== oldVal) node[DEF_CHAR] = oldVal;
                }
            }
            uCode = seq[seq.length - 1];
            node[uCode] = dbcsCode;
        };
        DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
            var node = this.decodeTables[nodeIdx];
            for(var i = 0; i < 0x100; i++){
                var uCode = node[i];
                var mbCode = prefix + i;
                if (!skipEncodeChars[mbCode]) {
                    if (uCode >= 0) this._setEncodeChar(uCode, mbCode);
                    else if (uCode <= NODE_START) this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
                    else if (uCode <= SEQ_START) this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
                }
            }
        };
        function DBCSEncoder(options, codec) {
            this.leadSurrogate = -1;
            this.seqObj = void 0;
            this.encodeTable = codec.encodeTable;
            this.encodeTableSeq = codec.encodeTableSeq;
            this.defaultCharSingleByte = codec.defCharSB;
            this.gb18030 = codec.gb18030;
        }
        DBCSEncoder.prototype.write = function(str) {
            var newBuf = Buffer1.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i = 0, j = 0;
            while(true){
                if (-1 === nextChar) {
                    if (i == str.length) break;
                    var uCode = str.charCodeAt(i++);
                } else {
                    var uCode = nextChar;
                    nextChar = -1;
                }
                if (0xD800 <= uCode && uCode < 0xE000) if (uCode < 0xDC00) if (-1 === leadSurrogate) {
                    leadSurrogate = uCode;
                    continue;
                } else {
                    leadSurrogate = uCode;
                    uCode = UNASSIGNED;
                }
                else if (-1 !== leadSurrogate) {
                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
                    leadSurrogate = -1;
                } else uCode = UNASSIGNED;
                else if (-1 !== leadSurrogate) {
                    nextChar = uCode;
                    uCode = UNASSIGNED;
                    leadSurrogate = -1;
                }
                var dbcsCode = UNASSIGNED;
                if (void 0 !== seqObj && uCode != UNASSIGNED) {
                    var resCode = seqObj[uCode];
                    if ('object' == typeof resCode) {
                        seqObj = resCode;
                        continue;
                    }
                    if ('number' == typeof resCode) dbcsCode = resCode;
                    else if (void 0 == resCode) {
                        resCode = seqObj[DEF_CHAR];
                        if (void 0 !== resCode) {
                            dbcsCode = resCode;
                            nextChar = uCode;
                        }
                    }
                    seqObj = void 0;
                } else if (uCode >= 0) {
                    var subtable = this.encodeTable[uCode >> 8];
                    if (void 0 !== subtable) dbcsCode = subtable[0xFF & uCode];
                    if (dbcsCode <= SEQ_START) {
                        seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
                        continue;
                    }
                    if (dbcsCode == UNASSIGNED && this.gb18030) {
                        var idx = findIdx(this.gb18030.uChars, uCode);
                        if (-1 != idx) {
                            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                            newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);
                            dbcsCode %= 12600;
                            newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);
                            dbcsCode %= 1260;
                            newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);
                            dbcsCode %= 10;
                            newBuf[j++] = 0x30 + dbcsCode;
                            continue;
                        }
                    }
                }
                if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
                if (dbcsCode < 0x100) newBuf[j++] = dbcsCode;
                else if (dbcsCode < 0x10000) {
                    newBuf[j++] = dbcsCode >> 8;
                    newBuf[j++] = 0xFF & dbcsCode;
                } else {
                    newBuf[j++] = dbcsCode >> 16;
                    newBuf[j++] = dbcsCode >> 8 & 0xFF;
                    newBuf[j++] = 0xFF & dbcsCode;
                }
            }
            this.seqObj = seqObj;
            this.leadSurrogate = leadSurrogate;
            return newBuf.slice(0, j);
        };
        DBCSEncoder.prototype.end = function() {
            if (-1 === this.leadSurrogate && void 0 === this.seqObj) return;
            var newBuf = Buffer1.alloc(10), j = 0;
            if (this.seqObj) {
                var dbcsCode = this.seqObj[DEF_CHAR];
                if (void 0 !== dbcsCode) if (dbcsCode < 0x100) newBuf[j++] = dbcsCode;
                else {
                    newBuf[j++] = dbcsCode >> 8;
                    newBuf[j++] = 0xFF & dbcsCode;
                }
                this.seqObj = void 0;
            }
            if (-1 !== this.leadSurrogate) {
                newBuf[j++] = this.defaultCharSingleByte;
                this.leadSurrogate = -1;
            }
            return newBuf.slice(0, j);
        };
        DBCSEncoder.prototype.findIdx = findIdx;
        function DBCSDecoder(options, codec) {
            this.nodeIdx = 0;
            this.prevBuf = Buffer1.alloc(0);
            this.decodeTables = codec.decodeTables;
            this.decodeTableSeq = codec.decodeTableSeq;
            this.defaultCharUnicode = codec.defaultCharUnicode;
            this.gb18030 = codec.gb18030;
        }
        DBCSDecoder.prototype.write = function(buf) {
            var newBuf = Buffer1.alloc(2 * buf.length), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
            if (prevBufOffset > 0) prevBuf = Buffer1.concat([
                prevBuf,
                buf.slice(0, 10)
            ]);
            for(var i = 0, j = 0; i < buf.length; i++){
                var curByte = i >= 0 ? buf[i] : prevBuf[i + prevBufOffset];
                var uCode = this.decodeTables[nodeIdx][curByte];
                if (uCode >= 0) ;
                else if (uCode === UNASSIGNED) {
                    i = seqStart;
                    uCode = this.defaultCharUnicode.charCodeAt(0);
                } else if (uCode === GB18030_CODE) {
                    var curSeq = seqStart >= 0 ? buf.slice(seqStart, i + 1) : prevBuf.slice(seqStart + prevBufOffset, i + 1 + prevBufOffset);
                    var ptr = (curSeq[0] - 0x81) * 12600 + (curSeq[1] - 0x30) * 1260 + (curSeq[2] - 0x81) * 10 + (curSeq[3] - 0x30);
                    var idx = findIdx(this.gb18030.gbChars, ptr);
                    uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
                } else if (uCode <= NODE_START) {
                    nodeIdx = NODE_START - uCode;
                    continue;
                } else if (uCode <= SEQ_START) {
                    var seq = this.decodeTableSeq[SEQ_START - uCode];
                    for(var k = 0; k < seq.length - 1; k++){
                        uCode = seq[k];
                        newBuf[j++] = 0xFF & uCode;
                        newBuf[j++] = uCode >> 8;
                    }
                    uCode = seq[seq.length - 1];
                } else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
                if (uCode > 0xFFFF) {
                    uCode -= 0x10000;
                    var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
                    newBuf[j++] = 0xFF & uCodeLead;
                    newBuf[j++] = uCodeLead >> 8;
                    uCode = 0xDC00 + uCode % 0x400;
                }
                newBuf[j++] = 0xFF & uCode;
                newBuf[j++] = uCode >> 8;
                nodeIdx = 0;
                seqStart = i + 1;
            }
            this.nodeIdx = nodeIdx;
            this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
            return newBuf.slice(0, j).toString('ucs2');
        };
        DBCSDecoder.prototype.end = function() {
            var ret = '';
            while(this.prevBuf.length > 0){
                ret += this.defaultCharUnicode;
                var buf = this.prevBuf.slice(1);
                this.prevBuf = Buffer1.alloc(0);
                this.nodeIdx = 0;
                if (buf.length > 0) ret += this.write(buf);
            }
            this.nodeIdx = 0;
            return ret;
        };
        function findIdx(table, val) {
            if (table[0] > val) return -1;
            var l = 0, r = table.length;
            while(l < r - 1){
                var mid = l + Math.floor((r - l + 1) / 2);
                if (table[mid] <= val) l = mid;
                else r = mid;
            }
            return l;
        }
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/dbcs-data.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        module.exports = {
            shiftjis: {
                type: '_dbcs',
                table: function() {
                    return __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/shiftjis.json");
                },
                encodeAdd: {
                    '\u00a5': 0x5C,
                    '\u203E': 0x7E
                },
                encodeSkipVals: [
                    {
                        from: 0xED40,
                        to: 0xF940
                    }
                ]
            },
            csshiftjis: 'shiftjis',
            mskanji: 'shiftjis',
            sjis: 'shiftjis',
            windows31j: 'shiftjis',
            ms31j: 'shiftjis',
            xsjis: 'shiftjis',
            windows932: 'shiftjis',
            ms932: 'shiftjis',
            932: 'shiftjis',
            cp932: 'shiftjis',
            eucjp: {
                type: '_dbcs',
                table: function() {
                    return __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/eucjp.json");
                },
                encodeAdd: {
                    '\u00a5': 0x5C,
                    '\u203E': 0x7E
                }
            },
            gb2312: 'cp936',
            gb231280: 'cp936',
            gb23121980: 'cp936',
            csgb2312: 'cp936',
            csiso58gb231280: 'cp936',
            euccn: 'cp936',
            windows936: 'cp936',
            ms936: 'cp936',
            936: 'cp936',
            cp936: {
                type: '_dbcs',
                table: function() {
                    return __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp936.json");
                }
            },
            gbk: {
                type: '_dbcs',
                table: function() {
                    return __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp936.json").concat(__webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/gbk-added.json"));
                }
            },
            xgbk: 'gbk',
            isoir58: 'gbk',
            gb18030: {
                type: '_dbcs',
                table: function() {
                    return __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp936.json").concat(__webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/gbk-added.json"));
                },
                gb18030: function() {
                    return __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json");
                },
                encodeSkipVals: [
                    0x80
                ],
                encodeAdd: {
                    '': 0xA2E3
                }
            },
            chinese: 'gb18030',
            windows949: 'cp949',
            ms949: 'cp949',
            949: 'cp949',
            cp949: {
                type: '_dbcs',
                table: function() {
                    return __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp949.json");
                }
            },
            cseuckr: 'cp949',
            csksc56011987: 'cp949',
            euckr: 'cp949',
            isoir149: 'cp949',
            korean: 'cp949',
            ksc56011987: 'cp949',
            ksc56011989: 'cp949',
            ksc5601: 'cp949',
            windows950: 'cp950',
            ms950: 'cp950',
            950: 'cp950',
            cp950: {
                type: '_dbcs',
                table: function() {
                    return __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp950.json");
                }
            },
            big5: 'big5hkscs',
            big5hkscs: {
                type: '_dbcs',
                table: function() {
                    return __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp950.json").concat(__webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/big5-added.json"));
                },
                encodeSkipVals: [
                    0xa2cc
                ]
            },
            cnbig5: 'big5hkscs',
            csbig5: 'big5hkscs',
            xxbig5: 'big5hkscs'
        };
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var modules = [
            __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/internal.js"),
            __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/utf16.js"),
            __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/utf7.js"),
            __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-codec.js"),
            __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-data.js"),
            __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-data-generated.js"),
            __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/dbcs-codec.js"),
            __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/dbcs-data.js")
        ];
        for(var i = 0; i < modules.length; i++){
            var module = modules[i];
            for(var enc in module)if (Object.prototype.hasOwnProperty.call(module, enc)) exports1[enc] = module[enc];
        }
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/internal.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js").Buffer;
        module.exports = {
            utf8: {
                type: "_internal",
                bomAware: true
            },
            cesu8: {
                type: "_internal",
                bomAware: true
            },
            unicode11utf8: "utf8",
            ucs2: {
                type: "_internal",
                bomAware: true
            },
            utf16le: "ucs2",
            binary: {
                type: "_internal"
            },
            base64: {
                type: "_internal"
            },
            hex: {
                type: "_internal"
            },
            _internal: InternalCodec
        };
        function InternalCodec(codecOptions, iconv) {
            this.enc = codecOptions.encodingName;
            this.bomAware = codecOptions.bomAware;
            if ("base64" === this.enc) this.encoder = InternalEncoderBase64;
            else if ("cesu8" === this.enc) {
                this.enc = "utf8";
                this.encoder = InternalEncoderCesu8;
                if ('' !== Buffer1.from('eda0bdedb2a9', 'hex').toString()) {
                    this.decoder = InternalDecoderCesu8;
                    this.defaultCharUnicode = iconv.defaultCharUnicode;
                }
            }
        }
        InternalCodec.prototype.encoder = InternalEncoder;
        InternalCodec.prototype.decoder = InternalDecoder;
        var StringDecoder = __webpack_require__("string_decoder").StringDecoder;
        if (!StringDecoder.prototype.end) StringDecoder.prototype.end = function() {};
        function InternalDecoder(options, codec) {
            StringDecoder.call(this, codec.enc);
        }
        InternalDecoder.prototype = StringDecoder.prototype;
        function InternalEncoder(options, codec) {
            this.enc = codec.enc;
        }
        InternalEncoder.prototype.write = function(str) {
            return Buffer1.from(str, this.enc);
        };
        InternalEncoder.prototype.end = function() {};
        function InternalEncoderBase64(options, codec) {
            this.prevStr = '';
        }
        InternalEncoderBase64.prototype.write = function(str) {
            str = this.prevStr + str;
            var completeQuads = str.length - str.length % 4;
            this.prevStr = str.slice(completeQuads);
            str = str.slice(0, completeQuads);
            return Buffer1.from(str, "base64");
        };
        InternalEncoderBase64.prototype.end = function() {
            return Buffer1.from(this.prevStr, "base64");
        };
        function InternalEncoderCesu8(options, codec) {}
        InternalEncoderCesu8.prototype.write = function(str) {
            var buf = Buffer1.alloc(3 * str.length), bufIdx = 0;
            for(var i = 0; i < str.length; i++){
                var charCode = str.charCodeAt(i);
                if (charCode < 0x80) buf[bufIdx++] = charCode;
                else if (charCode < 0x800) {
                    buf[bufIdx++] = 0xC0 + (charCode >>> 6);
                    buf[bufIdx++] = 0x80 + (0x3f & charCode);
                } else {
                    buf[bufIdx++] = 0xE0 + (charCode >>> 12);
                    buf[bufIdx++] = 0x80 + (charCode >>> 6 & 0x3f);
                    buf[bufIdx++] = 0x80 + (0x3f & charCode);
                }
            }
            return buf.slice(0, bufIdx);
        };
        InternalEncoderCesu8.prototype.end = function() {};
        function InternalDecoderCesu8(options, codec) {
            this.acc = 0;
            this.contBytes = 0;
            this.accBytes = 0;
            this.defaultCharUnicode = codec.defaultCharUnicode;
        }
        InternalDecoderCesu8.prototype.write = function(buf) {
            var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = '';
            for(var i = 0; i < buf.length; i++){
                var curByte = buf[i];
                if ((0xC0 & curByte) !== 0x80) {
                    if (contBytes > 0) {
                        res += this.defaultCharUnicode;
                        contBytes = 0;
                    }
                    if (curByte < 0x80) res += String.fromCharCode(curByte);
                    else if (curByte < 0xE0) {
                        acc = 0x1F & curByte;
                        contBytes = 1;
                        accBytes = 1;
                    } else if (curByte < 0xF0) {
                        acc = 0x0F & curByte;
                        contBytes = 2;
                        accBytes = 1;
                    } else res += this.defaultCharUnicode;
                } else if (contBytes > 0) {
                    acc = acc << 6 | 0x3f & curByte;
                    contBytes--;
                    accBytes++;
                    if (0 === contBytes) if (2 === accBytes && acc < 0x80 && acc > 0) res += this.defaultCharUnicode;
                    else if (3 === accBytes && acc < 0x800) res += this.defaultCharUnicode;
                    else res += String.fromCharCode(acc);
                } else res += this.defaultCharUnicode;
            }
            this.acc = acc;
            this.contBytes = contBytes;
            this.accBytes = accBytes;
            return res;
        };
        InternalDecoderCesu8.prototype.end = function() {
            var res = 0;
            if (this.contBytes > 0) res += this.defaultCharUnicode;
            return res;
        };
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-codec.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js").Buffer;
        exports1._sbcs = SBCSCodec;
        function SBCSCodec(codecOptions, iconv) {
            if (!codecOptions) throw new Error("SBCS codec is called without the data.");
            if (!codecOptions.chars || 128 !== codecOptions.chars.length && 256 !== codecOptions.chars.length) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
            if (128 === codecOptions.chars.length) {
                var asciiString = "";
                for(var i = 0; i < 128; i++)asciiString += String.fromCharCode(i);
                codecOptions.chars = asciiString + codecOptions.chars;
            }
            this.decodeBuf = Buffer1.from(codecOptions.chars, 'ucs2');
            var encodeBuf = Buffer1.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
            for(var i = 0; i < codecOptions.chars.length; i++)encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
            this.encodeBuf = encodeBuf;
        }
        SBCSCodec.prototype.encoder = SBCSEncoder;
        SBCSCodec.prototype.decoder = SBCSDecoder;
        function SBCSEncoder(options, codec) {
            this.encodeBuf = codec.encodeBuf;
        }
        SBCSEncoder.prototype.write = function(str) {
            var buf = Buffer1.alloc(str.length);
            for(var i = 0; i < str.length; i++)buf[i] = this.encodeBuf[str.charCodeAt(i)];
            return buf;
        };
        SBCSEncoder.prototype.end = function() {};
        function SBCSDecoder(options, codec) {
            this.decodeBuf = codec.decodeBuf;
        }
        SBCSDecoder.prototype.write = function(buf) {
            var decodeBuf = this.decodeBuf;
            var newBuf = Buffer1.alloc(2 * buf.length);
            var idx1 = 0, idx2 = 0;
            for(var i = 0; i < buf.length; i++){
                idx1 = 2 * buf[i];
                idx2 = 2 * i;
                newBuf[idx2] = decodeBuf[idx1];
                newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
            }
            return newBuf.toString('ucs2');
        };
        SBCSDecoder.prototype.end = function() {};
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-data-generated.js": function(module) {
        "use strict";
        module.exports = {
            437: "cp437",
            737: "cp737",
            775: "cp775",
            850: "cp850",
            852: "cp852",
            855: "cp855",
            856: "cp856",
            857: "cp857",
            858: "cp858",
            860: "cp860",
            861: "cp861",
            862: "cp862",
            863: "cp863",
            864: "cp864",
            865: "cp865",
            866: "cp866",
            869: "cp869",
            874: "windows874",
            922: "cp922",
            1046: "cp1046",
            1124: "cp1124",
            1125: "cp1125",
            1129: "cp1129",
            1133: "cp1133",
            1161: "cp1161",
            1162: "cp1162",
            1163: "cp1163",
            1250: "windows1250",
            1251: "windows1251",
            1252: "windows1252",
            1253: "windows1253",
            1254: "windows1254",
            1255: "windows1255",
            1256: "windows1256",
            1257: "windows1257",
            1258: "windows1258",
            28591: "iso88591",
            28592: "iso88592",
            28593: "iso88593",
            28594: "iso88594",
            28595: "iso88595",
            28596: "iso88596",
            28597: "iso88597",
            28598: "iso88598",
            28599: "iso88599",
            28600: "iso885910",
            28601: "iso885911",
            28603: "iso885913",
            28604: "iso885914",
            28605: "iso885915",
            28606: "iso885916",
            windows874: {
                type: "_sbcs",
                chars: ""
            },
            win874: "windows874",
            cp874: "windows874",
            windows1250: {
                type: "_sbcs",
                chars: ""
            },
            win1250: "windows1250",
            cp1250: "windows1250",
            windows1251: {
                type: "_sbcs",
                chars: ""
            },
            win1251: "windows1251",
            cp1251: "windows1251",
            windows1252: {
                type: "_sbcs",
                chars: ""
            },
            win1252: "windows1252",
            cp1252: "windows1252",
            windows1253: {
                type: "_sbcs",
                chars: ""
            },
            win1253: "windows1253",
            cp1253: "windows1253",
            windows1254: {
                type: "_sbcs",
                chars: ""
            },
            win1254: "windows1254",
            cp1254: "windows1254",
            windows1255: {
                type: "_sbcs",
                chars: ""
            },
            win1255: "windows1255",
            cp1255: "windows1255",
            windows1256: {
                type: "_sbcs",
                chars: ""
            },
            win1256: "windows1256",
            cp1256: "windows1256",
            windows1257: {
                type: "_sbcs",
                chars: ""
            },
            win1257: "windows1257",
            cp1257: "windows1257",
            windows1258: {
                type: "_sbcs",
                chars: ""
            },
            win1258: "windows1258",
            cp1258: "windows1258",
            iso88591: {
                type: "_sbcs",
                chars: ""
            },
            cp28591: "iso88591",
            iso88592: {
                type: "_sbcs",
                chars: ""
            },
            cp28592: "iso88592",
            iso88593: {
                type: "_sbcs",
                chars: ""
            },
            cp28593: "iso88593",
            iso88594: {
                type: "_sbcs",
                chars: ""
            },
            cp28594: "iso88594",
            iso88595: {
                type: "_sbcs",
                chars: ""
            },
            cp28595: "iso88595",
            iso88596: {
                type: "_sbcs",
                chars: ""
            },
            cp28596: "iso88596",
            iso88597: {
                type: "_sbcs",
                chars: ""
            },
            cp28597: "iso88597",
            iso88598: {
                type: "_sbcs",
                chars: ""
            },
            cp28598: "iso88598",
            iso88599: {
                type: "_sbcs",
                chars: ""
            },
            cp28599: "iso88599",
            iso885910: {
                type: "_sbcs",
                chars: ""
            },
            cp28600: "iso885910",
            iso885911: {
                type: "_sbcs",
                chars: ""
            },
            cp28601: "iso885911",
            iso885913: {
                type: "_sbcs",
                chars: ""
            },
            cp28603: "iso885913",
            iso885914: {
                type: "_sbcs",
                chars: ""
            },
            cp28604: "iso885914",
            iso885915: {
                type: "_sbcs",
                chars: ""
            },
            cp28605: "iso885915",
            iso885916: {
                type: "_sbcs",
                chars: ""
            },
            cp28606: "iso885916",
            cp437: {
                type: "_sbcs",
                chars: ""
            },
            ibm437: "cp437",
            csibm437: "cp437",
            cp737: {
                type: "_sbcs",
                chars: ""
            },
            ibm737: "cp737",
            csibm737: "cp737",
            cp775: {
                type: "_sbcs",
                chars: ""
            },
            ibm775: "cp775",
            csibm775: "cp775",
            cp850: {
                type: "_sbcs",
                chars: ""
            },
            ibm850: "cp850",
            csibm850: "cp850",
            cp852: {
                type: "_sbcs",
                chars: ""
            },
            ibm852: "cp852",
            csibm852: "cp852",
            cp855: {
                type: "_sbcs",
                chars: ""
            },
            ibm855: "cp855",
            csibm855: "cp855",
            cp856: {
                type: "_sbcs",
                chars: ""
            },
            ibm856: "cp856",
            csibm856: "cp856",
            cp857: {
                type: "_sbcs",
                chars: ""
            },
            ibm857: "cp857",
            csibm857: "cp857",
            cp858: {
                type: "_sbcs",
                chars: ""
            },
            ibm858: "cp858",
            csibm858: "cp858",
            cp860: {
                type: "_sbcs",
                chars: ""
            },
            ibm860: "cp860",
            csibm860: "cp860",
            cp861: {
                type: "_sbcs",
                chars: ""
            },
            ibm861: "cp861",
            csibm861: "cp861",
            cp862: {
                type: "_sbcs",
                chars: ""
            },
            ibm862: "cp862",
            csibm862: "cp862",
            cp863: {
                type: "_sbcs",
                chars: ""
            },
            ibm863: "cp863",
            csibm863: "cp863",
            cp864: {
                type: "_sbcs",
                chars: "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
            },
            ibm864: "cp864",
            csibm864: "cp864",
            cp865: {
                type: "_sbcs",
                chars: ""
            },
            ibm865: "cp865",
            csibm865: "cp865",
            cp866: {
                type: "_sbcs",
                chars: ""
            },
            ibm866: "cp866",
            csibm866: "cp866",
            cp869: {
                type: "_sbcs",
                chars: ""
            },
            ibm869: "cp869",
            csibm869: "cp869",
            cp922: {
                type: "_sbcs",
                chars: ""
            },
            ibm922: "cp922",
            csibm922: "cp922",
            cp1046: {
                type: "_sbcs",
                chars: ""
            },
            ibm1046: "cp1046",
            csibm1046: "cp1046",
            cp1124: {
                type: "_sbcs",
                chars: ""
            },
            ibm1124: "cp1124",
            csibm1124: "cp1124",
            cp1125: {
                type: "_sbcs",
                chars: ""
            },
            ibm1125: "cp1125",
            csibm1125: "cp1125",
            cp1129: {
                type: "_sbcs",
                chars: ""
            },
            ibm1129: "cp1129",
            csibm1129: "cp1129",
            cp1133: {
                type: "_sbcs",
                chars: ""
            },
            ibm1133: "cp1133",
            csibm1133: "cp1133",
            cp1161: {
                type: "_sbcs",
                chars: ""
            },
            ibm1161: "cp1161",
            csibm1161: "cp1161",
            cp1162: {
                type: "_sbcs",
                chars: ""
            },
            ibm1162: "cp1162",
            csibm1162: "cp1162",
            cp1163: {
                type: "_sbcs",
                chars: ""
            },
            ibm1163: "cp1163",
            csibm1163: "cp1163",
            maccroatian: {
                type: "_sbcs",
                chars: ""
            },
            maccyrillic: {
                type: "_sbcs",
                chars: ""
            },
            macgreek: {
                type: "_sbcs",
                chars: ""
            },
            maciceland: {
                type: "_sbcs",
                chars: ""
            },
            macroman: {
                type: "_sbcs",
                chars: ""
            },
            macromania: {
                type: "_sbcs",
                chars: ""
            },
            macthai: {
                type: "_sbcs",
                chars: ""
            },
            macturkish: {
                type: "_sbcs",
                chars: ""
            },
            macukraine: {
                type: "_sbcs",
                chars: ""
            },
            koi8r: {
                type: "_sbcs",
                chars: ""
            },
            koi8u: {
                type: "_sbcs",
                chars: ""
            },
            koi8ru: {
                type: "_sbcs",
                chars: ""
            },
            koi8t: {
                type: "_sbcs",
                chars: ""
            },
            armscii8: {
                type: "_sbcs",
                chars: ")(.,-"
            },
            rk1048: {
                type: "_sbcs",
                chars: ""
            },
            tcvn: {
                type: "_sbcs",
                chars: "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
            },
            georgianacademy: {
                type: "_sbcs",
                chars: ""
            },
            georgianps: {
                type: "_sbcs",
                chars: ""
            },
            pt154: {
                type: "_sbcs",
                chars: ""
            },
            viscii: {
                type: "_sbcs",
                chars: "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
            },
            iso646cn: {
                type: "_sbcs",
                chars: "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
            },
            iso646jp: {
                type: "_sbcs",
                chars: "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
            },
            hproman8: {
                type: "_sbcs",
                chars: ""
            },
            macintosh: {
                type: "_sbcs",
                chars: ""
            },
            ascii: {
                type: "_sbcs",
                chars: ""
            },
            tis620: {
                type: "_sbcs",
                chars: ""
            }
        };
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/sbcs-data.js": function(module) {
        "use strict";
        module.exports = {
            10029: "maccenteuro",
            maccenteuro: {
                type: "_sbcs",
                chars: ""
            },
            808: "cp808",
            ibm808: "cp808",
            cp808: {
                type: "_sbcs",
                chars: ""
            },
            mik: {
                type: "_sbcs",
                chars: ""
            },
            ascii8bit: "ascii",
            usascii: "ascii",
            ansix34: "ascii",
            ansix341968: "ascii",
            ansix341986: "ascii",
            csascii: "ascii",
            cp367: "ascii",
            ibm367: "ascii",
            isoir6: "ascii",
            iso646us: "ascii",
            iso646irv: "ascii",
            us: "ascii",
            latin1: "iso88591",
            latin2: "iso88592",
            latin3: "iso88593",
            latin4: "iso88594",
            latin5: "iso88599",
            latin6: "iso885910",
            latin7: "iso885913",
            latin8: "iso885914",
            latin9: "iso885915",
            latin10: "iso885916",
            csisolatin1: "iso88591",
            csisolatin2: "iso88592",
            csisolatin3: "iso88593",
            csisolatin4: "iso88594",
            csisolatincyrillic: "iso88595",
            csisolatinarabic: "iso88596",
            csisolatingreek: "iso88597",
            csisolatinhebrew: "iso88598",
            csisolatin5: "iso88599",
            csisolatin6: "iso885910",
            l1: "iso88591",
            l2: "iso88592",
            l3: "iso88593",
            l4: "iso88594",
            l5: "iso88599",
            l6: "iso885910",
            l7: "iso885913",
            l8: "iso885914",
            l9: "iso885915",
            l10: "iso885916",
            isoir14: "iso646jp",
            isoir57: "iso646cn",
            isoir100: "iso88591",
            isoir101: "iso88592",
            isoir109: "iso88593",
            isoir110: "iso88594",
            isoir144: "iso88595",
            isoir127: "iso88596",
            isoir126: "iso88597",
            isoir138: "iso88598",
            isoir148: "iso88599",
            isoir157: "iso885910",
            isoir166: "tis620",
            isoir179: "iso885913",
            isoir199: "iso885914",
            isoir203: "iso885915",
            isoir226: "iso885916",
            cp819: "iso88591",
            ibm819: "iso88591",
            cyrillic: "iso88595",
            arabic: "iso88596",
            arabic8: "iso88596",
            ecma114: "iso88596",
            asmo708: "iso88596",
            greek: "iso88597",
            greek8: "iso88597",
            ecma118: "iso88597",
            elot928: "iso88597",
            hebrew: "iso88598",
            hebrew8: "iso88598",
            turkish: "iso88599",
            turkish8: "iso88599",
            thai: "iso885911",
            thai8: "iso885911",
            celtic: "iso885914",
            celtic8: "iso885914",
            isoceltic: "iso885914",
            tis6200: "tis620",
            tis62025291: "tis620",
            tis62025330: "tis620",
            10000: "macroman",
            10006: "macgreek",
            10007: "maccyrillic",
            10079: "maciceland",
            10081: "macturkish",
            cspc8codepage437: "cp437",
            cspc775baltic: "cp775",
            cspc850multilingual: "cp850",
            cspcp852: "cp852",
            cspc862latinhebrew: "cp862",
            cpgr: "cp869",
            msee: "cp1250",
            mscyrl: "cp1251",
            msansi: "cp1252",
            msgreek: "cp1253",
            msturk: "cp1254",
            mshebr: "cp1255",
            msarab: "cp1256",
            winbaltrim: "cp1257",
            cp20866: "koi8r",
            20866: "koi8r",
            ibm878: "koi8r",
            cskoi8r: "koi8r",
            cp21866: "koi8u",
            21866: "koi8u",
            ibm1168: "koi8u",
            strk10482002: "rk1048",
            tcvn5712: "tcvn",
            tcvn57121: "tcvn",
            gb198880: "iso646cn",
            cn: "iso646cn",
            csiso14jisc6220ro: "iso646jp",
            jisc62201969ro: "iso646jp",
            jp: "iso646jp",
            cshproman8: "hproman8",
            r8: "hproman8",
            roman8: "hproman8",
            xroman8: "hproman8",
            ibm1051: "hproman8",
            mac: "macintosh",
            csmacintosh: "macintosh"
        };
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/utf16.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js").Buffer;
        exports1.utf16be = Utf16BECodec;
        function Utf16BECodec() {}
        Utf16BECodec.prototype.encoder = Utf16BEEncoder;
        Utf16BECodec.prototype.decoder = Utf16BEDecoder;
        Utf16BECodec.prototype.bomAware = true;
        function Utf16BEEncoder() {}
        Utf16BEEncoder.prototype.write = function(str) {
            var buf = Buffer1.from(str, 'ucs2');
            for(var i = 0; i < buf.length; i += 2){
                var tmp = buf[i];
                buf[i] = buf[i + 1];
                buf[i + 1] = tmp;
            }
            return buf;
        };
        Utf16BEEncoder.prototype.end = function() {};
        function Utf16BEDecoder() {
            this.overflowByte = -1;
        }
        Utf16BEDecoder.prototype.write = function(buf) {
            if (0 == buf.length) return '';
            var buf2 = Buffer1.alloc(buf.length + 1), i = 0, j = 0;
            if (-1 !== this.overflowByte) {
                buf2[0] = buf[0];
                buf2[1] = this.overflowByte;
                i = 1;
                j = 2;
            }
            for(; i < buf.length - 1; i += 2, j += 2){
                buf2[j] = buf[i + 1];
                buf2[j + 1] = buf[i];
            }
            this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
            return buf2.slice(0, j).toString('ucs2');
        };
        Utf16BEDecoder.prototype.end = function() {};
        exports1.utf16 = Utf16Codec;
        function Utf16Codec(codecOptions, iconv) {
            this.iconv = iconv;
        }
        Utf16Codec.prototype.encoder = Utf16Encoder;
        Utf16Codec.prototype.decoder = Utf16Decoder;
        function Utf16Encoder(options, codec) {
            options = options || {};
            if (void 0 === options.addBOM) options.addBOM = true;
            this.encoder = codec.iconv.getEncoder('utf-16le', options);
        }
        Utf16Encoder.prototype.write = function(str) {
            return this.encoder.write(str);
        };
        Utf16Encoder.prototype.end = function() {
            return this.encoder.end();
        };
        function Utf16Decoder(options, codec) {
            this.decoder = null;
            this.initialBytes = [];
            this.initialBytesLen = 0;
            this.options = options || {};
            this.iconv = codec.iconv;
        }
        Utf16Decoder.prototype.write = function(buf) {
            if (!this.decoder) {
                this.initialBytes.push(buf);
                this.initialBytesLen += buf.length;
                if (this.initialBytesLen < 16) return '';
                var buf = Buffer1.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
                this.decoder = this.iconv.getDecoder(encoding, this.options);
                this.initialBytes.length = this.initialBytesLen = 0;
            }
            return this.decoder.write(buf);
        };
        Utf16Decoder.prototype.end = function() {
            if (!this.decoder) {
                var buf = Buffer1.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
                this.decoder = this.iconv.getDecoder(encoding, this.options);
                var res = this.decoder.write(buf), trail = this.decoder.end();
                return trail ? res + trail : res;
            }
            return this.decoder.end();
        };
        function detectEncoding(buf, defaultEncoding) {
            var enc = defaultEncoding || 'utf-16le';
            if (buf.length >= 2) if (0xFE == buf[0] && 0xFF == buf[1]) enc = 'utf-16be';
            else if (0xFF == buf[0] && 0xFE == buf[1]) enc = 'utf-16le';
            else {
                var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
                for(var i = 0; i < _len; i += 2){
                    if (0 === buf[i] && 0 !== buf[i + 1]) asciiCharsBE++;
                    if (0 !== buf[i] && 0 === buf[i + 1]) asciiCharsLE++;
                }
                if (asciiCharsBE > asciiCharsLE) enc = 'utf-16be';
                else if (asciiCharsBE < asciiCharsLE) enc = 'utf-16le';
            }
            return enc;
        }
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/utf7.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js").Buffer;
        exports1.utf7 = Utf7Codec;
        exports1.unicode11utf7 = 'utf7';
        function Utf7Codec(codecOptions, iconv) {
            this.iconv = iconv;
        }
        Utf7Codec.prototype.encoder = Utf7Encoder;
        Utf7Codec.prototype.decoder = Utf7Decoder;
        Utf7Codec.prototype.bomAware = true;
        var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
        function Utf7Encoder(options, codec) {
            this.iconv = codec.iconv;
        }
        Utf7Encoder.prototype.write = function(str) {
            return Buffer1.from(str.replace(nonDirectChars, (function(chunk) {
                return "+" + ('+' === chunk ? '' : this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) + "-";
            }).bind(this)));
        };
        Utf7Encoder.prototype.end = function() {};
        function Utf7Decoder(options, codec) {
            this.iconv = codec.iconv;
            this.inBase64 = false;
            this.base64Accum = '';
        }
        var base64Regex = /[A-Za-z0-9\/+]/;
        var base64Chars = [];
        for(var i = 0; i < 256; i++)base64Chars[i] = base64Regex.test(String.fromCharCode(i));
        var plusChar = '+'.charCodeAt(0), minusChar = '-'.charCodeAt(0), andChar = '&'.charCodeAt(0);
        Utf7Decoder.prototype.write = function(buf) {
            var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
            for(var i = 0; i < buf.length; i++)if (inBase64) {
                if (!base64Chars[buf[i]]) {
                    if (i == lastI && buf[i] == minusChar) res += "+";
                    else {
                        var b64str = base64Accum + buf.slice(lastI, i).toString();
                        res += this.iconv.decode(Buffer1.from(b64str, 'base64'), "utf16-be");
                    }
                    if (buf[i] != minusChar) i--;
                    lastI = i + 1;
                    inBase64 = false;
                    base64Accum = '';
                }
            } else if (buf[i] == plusChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii");
                lastI = i + 1;
                inBase64 = true;
            }
            if (inBase64) {
                var b64str = base64Accum + buf.slice(lastI).toString();
                var canBeDecoded = b64str.length - b64str.length % 8;
                base64Accum = b64str.slice(canBeDecoded);
                b64str = b64str.slice(0, canBeDecoded);
                res += this.iconv.decode(Buffer1.from(b64str, 'base64'), "utf16-be");
            } else res += this.iconv.decode(buf.slice(lastI), "ascii");
            this.inBase64 = inBase64;
            this.base64Accum = base64Accum;
            return res;
        };
        Utf7Decoder.prototype.end = function() {
            var res = "";
            if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer1.from(this.base64Accum, 'base64'), "utf16-be");
            this.inBase64 = false;
            this.base64Accum = '';
            return res;
        };
        exports1.utf7imap = Utf7IMAPCodec;
        function Utf7IMAPCodec(codecOptions, iconv) {
            this.iconv = iconv;
        }
        Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
        Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
        Utf7IMAPCodec.prototype.bomAware = true;
        function Utf7IMAPEncoder(options, codec) {
            this.iconv = codec.iconv;
            this.inBase64 = false;
            this.base64Accum = Buffer1.alloc(6);
            this.base64AccumIdx = 0;
        }
        Utf7IMAPEncoder.prototype.write = function(str) {
            var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer1.alloc(5 * str.length + 10), bufIdx = 0;
            for(var i = 0; i < str.length; i++){
                var uChar = str.charCodeAt(i);
                if (0x20 <= uChar && uChar <= 0x7E) {
                    if (inBase64) {
                        if (base64AccumIdx > 0) {
                            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                            base64AccumIdx = 0;
                        }
                        buf[bufIdx++] = minusChar;
                        inBase64 = false;
                    }
                    if (!inBase64) {
                        buf[bufIdx++] = uChar;
                        if (uChar === andChar) buf[bufIdx++] = minusChar;
                    }
                } else {
                    if (!inBase64) {
                        buf[bufIdx++] = andChar;
                        inBase64 = true;
                    }
                    if (inBase64) {
                        base64Accum[base64AccumIdx++] = uChar >> 8;
                        base64Accum[base64AccumIdx++] = 0xFF & uChar;
                        if (base64AccumIdx == base64Accum.length) {
                            bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
                            base64AccumIdx = 0;
                        }
                    }
                }
            }
            this.inBase64 = inBase64;
            this.base64AccumIdx = base64AccumIdx;
            return buf.slice(0, bufIdx);
        };
        Utf7IMAPEncoder.prototype.end = function() {
            var buf = Buffer1.alloc(10), bufIdx = 0;
            if (this.inBase64) {
                if (this.base64AccumIdx > 0) {
                    bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                    this.base64AccumIdx = 0;
                }
                buf[bufIdx++] = minusChar;
                this.inBase64 = false;
            }
            return buf.slice(0, bufIdx);
        };
        function Utf7IMAPDecoder(options, codec) {
            this.iconv = codec.iconv;
            this.inBase64 = false;
            this.base64Accum = '';
        }
        var base64IMAPChars = base64Chars.slice();
        base64IMAPChars[','.charCodeAt(0)] = true;
        Utf7IMAPDecoder.prototype.write = function(buf) {
            var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
            for(var i = 0; i < buf.length; i++)if (inBase64) {
                if (!base64IMAPChars[buf[i]]) {
                    if (i == lastI && buf[i] == minusChar) res += "&";
                    else {
                        var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
                        res += this.iconv.decode(Buffer1.from(b64str, 'base64'), "utf16-be");
                    }
                    if (buf[i] != minusChar) i--;
                    lastI = i + 1;
                    inBase64 = false;
                    base64Accum = '';
                }
            } else if (buf[i] == andChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii");
                lastI = i + 1;
                inBase64 = true;
            }
            if (inBase64) {
                var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');
                var canBeDecoded = b64str.length - b64str.length % 8;
                base64Accum = b64str.slice(canBeDecoded);
                b64str = b64str.slice(0, canBeDecoded);
                res += this.iconv.decode(Buffer1.from(b64str, 'base64'), "utf16-be");
            } else res += this.iconv.decode(buf.slice(lastI), "ascii");
            this.inBase64 = inBase64;
            this.base64Accum = base64Accum;
            return res;
        };
        Utf7IMAPDecoder.prototype.end = function() {
            var res = "";
            if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer1.from(this.base64Accum, 'base64'), "utf16-be");
            this.inBase64 = false;
            this.base64Accum = '';
            return res;
        };
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/bom-handling.js": function(__unused_webpack_module, exports1) {
        "use strict";
        var BOMChar = '\uFEFF';
        exports1.PrependBOM = PrependBOMWrapper;
        function PrependBOMWrapper(encoder, options) {
            this.encoder = encoder;
            this.addBOM = true;
        }
        PrependBOMWrapper.prototype.write = function(str) {
            if (this.addBOM) {
                str = BOMChar + str;
                this.addBOM = false;
            }
            return this.encoder.write(str);
        };
        PrependBOMWrapper.prototype.end = function() {
            return this.encoder.end();
        };
        exports1.StripBOM = StripBOMWrapper;
        function StripBOMWrapper(decoder, options) {
            this.decoder = decoder;
            this.pass = false;
            this.options = options || {};
        }
        StripBOMWrapper.prototype.write = function(buf) {
            var res = this.decoder.write(buf);
            if (this.pass || !res) return res;
            if (res[0] === BOMChar) {
                res = res.slice(1);
                if ('function' == typeof this.options.stripBOM) this.options.stripBOM();
            }
            this.pass = true;
            return res;
        };
        StripBOMWrapper.prototype.end = function() {
            return this.decoder.end();
        };
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/extend-node.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("buffer").Buffer;
        module.exports = function(iconv) {
            var original = void 0;
            iconv.supportsNodeEncodingsExtension = !(Buffer1.from || new Buffer1(0) instanceof Uint8Array);
            iconv.extendNodeEncodings = function() {
                if (original) return;
                original = {};
                if (!iconv.supportsNodeEncodingsExtension) {
                    console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
                    console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
                    return;
                }
                var nodeNativeEncodings = {
                    hex: true,
                    utf8: true,
                    'utf-8': true,
                    ascii: true,
                    binary: true,
                    base64: true,
                    ucs2: true,
                    'ucs-2': true,
                    utf16le: true,
                    'utf-16le': true
                };
                Buffer1.isNativeEncoding = function(enc) {
                    return enc && nodeNativeEncodings[enc.toLowerCase()];
                };
                var SlowBuffer = __webpack_require__("buffer").SlowBuffer;
                original.SlowBufferToString = SlowBuffer.prototype.toString;
                SlowBuffer.prototype.toString = function(encoding, start, end) {
                    encoding = String(encoding || 'utf8').toLowerCase();
                    if (Buffer1.isNativeEncoding(encoding)) return original.SlowBufferToString.call(this, encoding, start, end);
                    if (void 0 === start) start = 0;
                    if (void 0 === end) end = this.length;
                    return iconv.decode(this.slice(start, end), encoding);
                };
                original.SlowBufferWrite = SlowBuffer.prototype.write;
                SlowBuffer.prototype.write = function(string, offset, length, encoding) {
                    if (isFinite(offset)) {
                        if (!isFinite(length)) {
                            encoding = length;
                            length = void 0;
                        }
                    } else {
                        var swap = encoding;
                        encoding = offset;
                        offset = length;
                        length = swap;
                    }
                    offset = +offset || 0;
                    var remaining = this.length - offset;
                    if (length) {
                        length *= 1;
                        if (length > remaining) length = remaining;
                    } else length = remaining;
                    encoding = String(encoding || 'utf8').toLowerCase();
                    if (Buffer1.isNativeEncoding(encoding)) return original.SlowBufferWrite.call(this, string, offset, length, encoding);
                    if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError('attempt to write beyond buffer bounds');
                    var buf = iconv.encode(string, encoding);
                    if (buf.length < length) length = buf.length;
                    buf.copy(this, offset, 0, length);
                    return length;
                };
                original.BufferIsEncoding = Buffer1.isEncoding;
                Buffer1.isEncoding = function(encoding) {
                    return Buffer1.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
                };
                original.BufferByteLength = Buffer1.byteLength;
                Buffer1.byteLength = SlowBuffer.byteLength = function(str, encoding) {
                    encoding = String(encoding || 'utf8').toLowerCase();
                    if (Buffer1.isNativeEncoding(encoding)) return original.BufferByteLength.call(this, str, encoding);
                    return iconv.encode(str, encoding).length;
                };
                original.BufferToString = Buffer1.prototype.toString;
                Buffer1.prototype.toString = function(encoding, start, end) {
                    encoding = String(encoding || 'utf8').toLowerCase();
                    if (Buffer1.isNativeEncoding(encoding)) return original.BufferToString.call(this, encoding, start, end);
                    if (void 0 === start) start = 0;
                    if (void 0 === end) end = this.length;
                    return iconv.decode(this.slice(start, end), encoding);
                };
                original.BufferWrite = Buffer1.prototype.write;
                Buffer1.prototype.write = function(string, offset, length, encoding) {
                    var _offset = offset, _length = length, _encoding = encoding;
                    if (isFinite(offset)) {
                        if (!isFinite(length)) {
                            encoding = length;
                            length = void 0;
                        }
                    } else {
                        var swap = encoding;
                        encoding = offset;
                        offset = length;
                        length = swap;
                    }
                    encoding = String(encoding || 'utf8').toLowerCase();
                    if (Buffer1.isNativeEncoding(encoding)) return original.BufferWrite.call(this, string, _offset, _length, _encoding);
                    offset = +offset || 0;
                    var remaining = this.length - offset;
                    if (length) {
                        length *= 1;
                        if (length > remaining) length = remaining;
                    } else length = remaining;
                    if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError('attempt to write beyond buffer bounds');
                    var buf = iconv.encode(string, encoding);
                    if (buf.length < length) length = buf.length;
                    buf.copy(this, offset, 0, length);
                    return length;
                };
                if (iconv.supportsStreams) {
                    var Readable = __webpack_require__("stream").Readable;
                    original.ReadableSetEncoding = Readable.prototype.setEncoding;
                    Readable.prototype.setEncoding = function(enc, options) {
                        this._readableState.decoder = iconv.getDecoder(enc, options);
                        this._readableState.encoding = enc;
                    };
                    Readable.prototype.collect = iconv._collect;
                }
            };
            iconv.undoExtendNodeEncodings = function() {
                if (!iconv.supportsNodeEncodingsExtension) return;
                if (!original) throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
                delete Buffer1.isNativeEncoding;
                var SlowBuffer = __webpack_require__("buffer").SlowBuffer;
                SlowBuffer.prototype.toString = original.SlowBufferToString;
                SlowBuffer.prototype.write = original.SlowBufferWrite;
                Buffer1.isEncoding = original.BufferIsEncoding;
                Buffer1.byteLength = original.BufferByteLength;
                Buffer1.prototype.toString = original.BufferToString;
                Buffer1.prototype.write = original.BufferWrite;
                if (iconv.supportsStreams) {
                    var Readable = __webpack_require__("stream").Readable;
                    Readable.prototype.setEncoding = original.ReadableSetEncoding;
                    delete Readable.prototype.collect;
                }
                original = void 0;
            };
        };
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js").Buffer;
        var bomHandling = __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/bom-handling.js"), iconv = module.exports;
        iconv.encodings = null;
        iconv.defaultCharUnicode = '';
        iconv.defaultCharSingleByte = '?';
        iconv.encode = function(str, encoding, options) {
            str = "" + (str || "");
            var encoder = iconv.getEncoder(encoding, options);
            var res = encoder.write(str);
            var trail = encoder.end();
            return trail && trail.length > 0 ? Buffer1.concat([
                res,
                trail
            ]) : res;
        };
        iconv.decode = function(buf, encoding, options) {
            if ('string' == typeof buf) {
                if (!iconv.skipDecodeWarning) {
                    console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
                    iconv.skipDecodeWarning = true;
                }
                buf = Buffer1.from("" + (buf || ""), "binary");
            }
            var decoder = iconv.getDecoder(encoding, options);
            var res = decoder.write(buf);
            var trail = decoder.end();
            return trail ? res + trail : res;
        };
        iconv.encodingExists = function(enc) {
            try {
                iconv.getCodec(enc);
                return true;
            } catch (e) {
                return false;
            }
        };
        iconv.toEncoding = iconv.encode;
        iconv.fromEncoding = iconv.decode;
        iconv._codecDataCache = {};
        iconv.getCodec = function(encoding) {
            if (!iconv.encodings) iconv.encodings = __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/index.js");
            var enc = iconv._canonicalizeEncoding(encoding);
            var codecOptions = {};
            while(true){
                var codec = iconv._codecDataCache[enc];
                if (codec) return codec;
                var codecDef = iconv.encodings[enc];
                switch(typeof codecDef){
                    case "string":
                        enc = codecDef;
                        break;
                    case "object":
                        for(var key in codecDef)codecOptions[key] = codecDef[key];
                        if (!codecOptions.encodingName) codecOptions.encodingName = enc;
                        enc = codecDef.type;
                        break;
                    case "function":
                        if (!codecOptions.encodingName) codecOptions.encodingName = enc;
                        codec = new codecDef(codecOptions, iconv);
                        iconv._codecDataCache[codecOptions.encodingName] = codec;
                        return codec;
                    default:
                        throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
                }
            }
        };
        iconv._canonicalizeEncoding = function(encoding) {
            return ('' + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
        };
        iconv.getEncoder = function(encoding, options) {
            var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
            if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);
            return encoder;
        };
        iconv.getDecoder = function(encoding, options) {
            var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
            if (codec.bomAware && !(options && false === options.stripBOM)) decoder = new bomHandling.StripBOM(decoder, options);
            return decoder;
        };
        var nodeVer = 'undefined' != typeof process && process.versions && process.versions.node;
        if (nodeVer) {
            var nodeVerArr = nodeVer.split(".").map(Number);
            if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/streams.js")(iconv);
            __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/extend-node.js")(iconv);
        }
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/streams.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var Buffer1 = __webpack_require__("buffer").Buffer, Transform = __webpack_require__("stream").Transform;
        module.exports = function(iconv) {
            iconv.encodeStream = function(encoding, options) {
                return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
            };
            iconv.decodeStream = function(encoding, options) {
                return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
            };
            iconv.supportsStreams = true;
            iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
            iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
            iconv._collect = IconvLiteDecoderStream.prototype.collect;
        };
        function IconvLiteEncoderStream(conv, options) {
            this.conv = conv;
            options = options || {};
            options.decodeStrings = false;
            Transform.call(this, options);
        }
        IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
            constructor: {
                value: IconvLiteEncoderStream
            }
        });
        IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
            if ('string' != typeof chunk) return done(new Error("Iconv encoding stream needs strings as its input."));
            try {
                var res = this.conv.write(chunk);
                if (res && res.length) this.push(res);
                done();
            } catch (e) {
                done(e);
            }
        };
        IconvLiteEncoderStream.prototype._flush = function(done) {
            try {
                var res = this.conv.end();
                if (res && res.length) this.push(res);
                done();
            } catch (e) {
                done(e);
            }
        };
        IconvLiteEncoderStream.prototype.collect = function(cb) {
            var chunks = [];
            this.on('error', cb);
            this.on('data', function(chunk) {
                chunks.push(chunk);
            });
            this.on('end', function() {
                cb(null, Buffer1.concat(chunks));
            });
            return this;
        };
        function IconvLiteDecoderStream(conv, options) {
            this.conv = conv;
            options = options || {};
            options.encoding = this.encoding = 'utf8';
            Transform.call(this, options);
        }
        IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
            constructor: {
                value: IconvLiteDecoderStream
            }
        });
        IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
            if (!Buffer1.isBuffer(chunk)) return done(new Error("Iconv decoding stream needs buffers as its input."));
            try {
                var res = this.conv.write(chunk);
                if (res && res.length) this.push(res, this.encoding);
                done();
            } catch (e) {
                done(e);
            }
        };
        IconvLiteDecoderStream.prototype._flush = function(done) {
            try {
                var res = this.conv.end();
                if (res && res.length) this.push(res, this.encoding);
                done();
            } catch (e) {
                done(e);
            }
        };
        IconvLiteDecoderStream.prototype.collect = function(cb) {
            var res = '';
            this.on('error', cb);
            this.on('data', function(chunk) {
                res += chunk;
            });
            this.on('end', function() {
                cb(null, res);
            });
            return this;
        };
    },
    "../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js": function(module, __unused_webpack_exports, __webpack_require__) {
        try {
            var util = __webpack_require__("util");
            if ('function' != typeof util.inherits) throw '';
            module.exports = util.inherits;
        } catch (e) {
            module.exports = __webpack_require__("../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js");
        }
    },
    "../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js": function(module) {
        if ('function' == typeof Object.create) module.exports = function(ctor, superCtor) {
            if (superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
            }
        };
        else module.exports = function(ctor, superCtor) {
            if (superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function() {};
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor();
                ctor.prototype.constructor = ctor;
            }
        };
    },
    "../node_modules/.pnpm/ipaddr.js@1.9.1/node_modules/ipaddr.js/lib/ipaddr.js": function(module, __unused_webpack_exports, __webpack_require__) {
        module = __webpack_require__.nmd(module);
        (function() {
            var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;
            ipaddr = {};
            root = this;
            if (null !== module && module.exports) module.exports = ipaddr;
            else root['ipaddr'] = ipaddr;
            matchCIDR = function(first, second, partSize, cidrBits) {
                var part, shift;
                if (first.length !== second.length) throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
                part = 0;
                while(cidrBits > 0){
                    shift = partSize - cidrBits;
                    if (shift < 0) shift = 0;
                    if (first[part] >> shift !== second[part] >> shift) return false;
                    cidrBits -= partSize;
                    part += 1;
                }
                return true;
            };
            ipaddr.subnetMatch = function(address, rangeList, defaultName) {
                var k, len, rangeName, rangeSubnets, subnet;
                if (null == defaultName) defaultName = 'unicast';
                for(rangeName in rangeList){
                    rangeSubnets = rangeList[rangeName];
                    if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) rangeSubnets = [
                        rangeSubnets
                    ];
                    for(k = 0, len = rangeSubnets.length; k < len; k++){
                        subnet = rangeSubnets[k];
                        if (address.kind() === subnet[0].kind()) {
                            if (address.match.apply(address, subnet)) return rangeName;
                        }
                    }
                }
                return defaultName;
            };
            ipaddr.IPv4 = function() {
                function IPv4(octets) {
                    var k, len, octet;
                    if (4 !== octets.length) throw new Error("ipaddr: ipv4 octet count should be 4");
                    for(k = 0, len = octets.length; k < len; k++){
                        octet = octets[k];
                        if (!(0 <= octet && octet <= 255)) throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
                    }
                    this.octets = octets;
                }
                IPv4.prototype.kind = function() {
                    return 'ipv4';
                };
                IPv4.prototype.toString = function() {
                    return this.octets.join(".");
                };
                IPv4.prototype.toNormalizedString = function() {
                    return this.toString();
                };
                IPv4.prototype.toByteArray = function() {
                    return this.octets.slice(0);
                };
                IPv4.prototype.match = function(other, cidrRange) {
                    var ref;
                    if (void 0 === cidrRange) ref = other, other = ref[0], cidrRange = ref[1];
                    if ('ipv4' !== other.kind()) throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
                    return matchCIDR(this.octets, other.octets, 8, cidrRange);
                };
                IPv4.prototype.SpecialRanges = {
                    unspecified: [
                        [
                            new IPv4([
                                0,
                                0,
                                0,
                                0
                            ]),
                            8
                        ]
                    ],
                    broadcast: [
                        [
                            new IPv4([
                                255,
                                255,
                                255,
                                255
                            ]),
                            32
                        ]
                    ],
                    multicast: [
                        [
                            new IPv4([
                                224,
                                0,
                                0,
                                0
                            ]),
                            4
                        ]
                    ],
                    linkLocal: [
                        [
                            new IPv4([
                                169,
                                254,
                                0,
                                0
                            ]),
                            16
                        ]
                    ],
                    loopback: [
                        [
                            new IPv4([
                                127,
                                0,
                                0,
                                0
                            ]),
                            8
                        ]
                    ],
                    carrierGradeNat: [
                        [
                            new IPv4([
                                100,
                                64,
                                0,
                                0
                            ]),
                            10
                        ]
                    ],
                    private: [
                        [
                            new IPv4([
                                10,
                                0,
                                0,
                                0
                            ]),
                            8
                        ],
                        [
                            new IPv4([
                                172,
                                16,
                                0,
                                0
                            ]),
                            12
                        ],
                        [
                            new IPv4([
                                192,
                                168,
                                0,
                                0
                            ]),
                            16
                        ]
                    ],
                    reserved: [
                        [
                            new IPv4([
                                192,
                                0,
                                0,
                                0
                            ]),
                            24
                        ],
                        [
                            new IPv4([
                                192,
                                0,
                                2,
                                0
                            ]),
                            24
                        ],
                        [
                            new IPv4([
                                192,
                                88,
                                99,
                                0
                            ]),
                            24
                        ],
                        [
                            new IPv4([
                                198,
                                51,
                                100,
                                0
                            ]),
                            24
                        ],
                        [
                            new IPv4([
                                203,
                                0,
                                113,
                                0
                            ]),
                            24
                        ],
                        [
                            new IPv4([
                                240,
                                0,
                                0,
                                0
                            ]),
                            4
                        ]
                    ]
                };
                IPv4.prototype.range = function() {
                    return ipaddr.subnetMatch(this, this.SpecialRanges);
                };
                IPv4.prototype.toIPv4MappedAddress = function() {
                    return ipaddr.IPv6.parse("::ffff:" + this.toString());
                };
                IPv4.prototype.prefixLengthFromSubnetMask = function() {
                    var cidr, i, k, octet, stop, zeros, zerotable;
                    zerotable = {
                        0: 8,
                        128: 7,
                        192: 6,
                        224: 5,
                        240: 4,
                        248: 3,
                        252: 2,
                        254: 1,
                        255: 0
                    };
                    cidr = 0;
                    stop = false;
                    for(i = k = 3; k >= 0; i = k += -1){
                        octet = this.octets[i];
                        if (!(octet in zerotable)) return null;
                        zeros = zerotable[octet];
                        if (stop && 0 !== zeros) return null;
                        if (8 !== zeros) stop = true;
                        cidr += zeros;
                    }
                    return 32 - cidr;
                };
                return IPv4;
            }();
            ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
            ipv4Regexes = {
                fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
                longValue: new RegExp("^" + ipv4Part + "$", 'i')
            };
            ipaddr.IPv4.parser = function(string) {
                var match, parseIntAuto, part, shift, value;
                parseIntAuto = function(string) {
                    if ("0" === string[0] && "x" !== string[1]) return parseInt(string, 8);
                    return parseInt(string);
                };
                if (match = string.match(ipv4Regexes.fourOctet)) return function() {
                    var k, len, ref, results;
                    ref = match.slice(1, 6);
                    results = [];
                    for(k = 0, len = ref.length; k < len; k++){
                        part = ref[k];
                        results.push(parseIntAuto(part));
                    }
                    return results;
                }();
                if (!(match = string.match(ipv4Regexes.longValue))) return null;
                value = parseIntAuto(match[1]);
                if (value > 0xffffffff || value < 0) throw new Error("ipaddr: address outside defined range");
                return (function() {
                    var k, results;
                    results = [];
                    for(shift = k = 0; k <= 24; shift = k += 8)results.push(value >> shift & 0xff);
                    return results;
                })().reverse();
            };
            ipaddr.IPv6 = function() {
                function IPv6(parts, zoneId) {
                    var i, k, l, len, part, ref;
                    if (16 === parts.length) {
                        this.parts = [];
                        for(i = k = 0; k <= 14; i = k += 2)this.parts.push(parts[i] << 8 | parts[i + 1]);
                    } else if (8 === parts.length) this.parts = parts;
                    else throw new Error("ipaddr: ipv6 part count should be 8 or 16");
                    ref = this.parts;
                    for(l = 0, len = ref.length; l < len; l++){
                        part = ref[l];
                        if (!(0 <= part && part <= 0xffff)) throw new Error("ipaddr: ipv6 part should fit in 16 bits");
                    }
                    if (zoneId) this.zoneId = zoneId;
                }
                IPv6.prototype.kind = function() {
                    return 'ipv6';
                };
                IPv6.prototype.toString = function() {
                    return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');
                };
                IPv6.prototype.toRFC5952String = function() {
                    var bestMatchIndex, bestMatchLength, match, regex, string;
                    regex = /((^|:)(0(:|$)){2,})/g;
                    string = this.toNormalizedString();
                    bestMatchIndex = 0;
                    bestMatchLength = -1;
                    while(match = regex.exec(string))if (match[0].length > bestMatchLength) {
                        bestMatchIndex = match.index;
                        bestMatchLength = match[0].length;
                    }
                    if (bestMatchLength < 0) return string;
                    return string.substring(0, bestMatchIndex) + '::' + string.substring(bestMatchIndex + bestMatchLength);
                };
                IPv6.prototype.toByteArray = function() {
                    var bytes, k, len, part, ref;
                    bytes = [];
                    ref = this.parts;
                    for(k = 0, len = ref.length; k < len; k++){
                        part = ref[k];
                        bytes.push(part >> 8);
                        bytes.push(0xff & part);
                    }
                    return bytes;
                };
                IPv6.prototype.toNormalizedString = function() {
                    var addr, part, suffix;
                    addr = (function() {
                        var k, len, ref, results;
                        ref = this.parts;
                        results = [];
                        for(k = 0, len = ref.length; k < len; k++){
                            part = ref[k];
                            results.push(part.toString(16));
                        }
                        return results;
                    }).call(this).join(":");
                    suffix = '';
                    if (this.zoneId) suffix = '%' + this.zoneId;
                    return addr + suffix;
                };
                IPv6.prototype.toFixedLengthString = function() {
                    var addr, part, suffix;
                    addr = (function() {
                        var k, len, ref, results;
                        ref = this.parts;
                        results = [];
                        for(k = 0, len = ref.length; k < len; k++){
                            part = ref[k];
                            results.push(part.toString(16).padStart(4, '0'));
                        }
                        return results;
                    }).call(this).join(":");
                    suffix = '';
                    if (this.zoneId) suffix = '%' + this.zoneId;
                    return addr + suffix;
                };
                IPv6.prototype.match = function(other, cidrRange) {
                    var ref;
                    if (void 0 === cidrRange) ref = other, other = ref[0], cidrRange = ref[1];
                    if ('ipv6' !== other.kind()) throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
                    return matchCIDR(this.parts, other.parts, 16, cidrRange);
                };
                IPv6.prototype.SpecialRanges = {
                    unspecified: [
                        new IPv6([
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        128
                    ],
                    linkLocal: [
                        new IPv6([
                            0xfe80,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        10
                    ],
                    multicast: [
                        new IPv6([
                            0xff00,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        8
                    ],
                    loopback: [
                        new IPv6([
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            1
                        ]),
                        128
                    ],
                    uniqueLocal: [
                        new IPv6([
                            0xfc00,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        7
                    ],
                    ipv4Mapped: [
                        new IPv6([
                            0,
                            0,
                            0,
                            0,
                            0,
                            0xffff,
                            0,
                            0
                        ]),
                        96
                    ],
                    rfc6145: [
                        new IPv6([
                            0,
                            0,
                            0,
                            0,
                            0xffff,
                            0,
                            0,
                            0
                        ]),
                        96
                    ],
                    rfc6052: [
                        new IPv6([
                            0x64,
                            0xff9b,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        96
                    ],
                    '6to4': [
                        new IPv6([
                            0x2002,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        16
                    ],
                    teredo: [
                        new IPv6([
                            0x2001,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0
                        ]),
                        32
                    ],
                    reserved: [
                        [
                            new IPv6([
                                0x2001,
                                0xdb8,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0
                            ]),
                            32
                        ]
                    ]
                };
                IPv6.prototype.range = function() {
                    return ipaddr.subnetMatch(this, this.SpecialRanges);
                };
                IPv6.prototype.isIPv4MappedAddress = function() {
                    return 'ipv4Mapped' === this.range();
                };
                IPv6.prototype.toIPv4Address = function() {
                    var high, low, ref;
                    if (!this.isIPv4MappedAddress()) throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
                    ref = this.parts.slice(-2), high = ref[0], low = ref[1];
                    return new ipaddr.IPv4([
                        high >> 8,
                        0xff & high,
                        low >> 8,
                        0xff & low
                    ]);
                };
                IPv6.prototype.prefixLengthFromSubnetMask = function() {
                    var cidr, i, k, part, stop, zeros, zerotable;
                    zerotable = {
                        0: 16,
                        32768: 15,
                        49152: 14,
                        57344: 13,
                        61440: 12,
                        63488: 11,
                        64512: 10,
                        65024: 9,
                        65280: 8,
                        65408: 7,
                        65472: 6,
                        65504: 5,
                        65520: 4,
                        65528: 3,
                        65532: 2,
                        65534: 1,
                        65535: 0
                    };
                    cidr = 0;
                    stop = false;
                    for(i = k = 7; k >= 0; i = k += -1){
                        part = this.parts[i];
                        if (!(part in zerotable)) return null;
                        zeros = zerotable[part];
                        if (stop && 0 !== zeros) return null;
                        if (16 !== zeros) stop = true;
                        cidr += zeros;
                    }
                    return 128 - cidr;
                };
                return IPv6;
            }();
            ipv6Part = "(?:[0-9a-f]+::?)+";
            zoneIndex = "%[0-9a-z]{1,}";
            ipv6Regexes = {
                zoneIndex: new RegExp(zoneIndex, 'i'),
                native: new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", 'i'),
                transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + "\\." + ipv4Part + "(" + zoneIndex + ")?$", 'i')
            };
            expandIPv6 = function(string, parts) {
                var colonCount, lastColon, part, replacement, replacementCount, zoneId;
                if (string.indexOf('::') !== string.lastIndexOf('::')) return null;
                zoneId = (string.match(ipv6Regexes['zoneIndex']) || [])[0];
                if (zoneId) {
                    zoneId = zoneId.substring(1);
                    string = string.replace(/%.+$/, '');
                }
                colonCount = 0;
                lastColon = -1;
                while((lastColon = string.indexOf(':', lastColon + 1)) >= 0)colonCount++;
                if ('::' === string.substr(0, 2)) colonCount--;
                if ('::' === string.substr(-2, 2)) colonCount--;
                if (colonCount > parts) return null;
                replacementCount = parts - colonCount;
                replacement = ':';
                while(replacementCount--)replacement += '0:';
                string = string.replace('::', replacement);
                if (':' === string[0]) string = string.slice(1);
                if (':' === string[string.length - 1]) string = string.slice(0, -1);
                parts = function() {
                    var k, len, ref, results;
                    ref = string.split(":");
                    results = [];
                    for(k = 0, len = ref.length; k < len; k++){
                        part = ref[k];
                        results.push(parseInt(part, 16));
                    }
                    return results;
                }();
                return {
                    parts: parts,
                    zoneId: zoneId
                };
            };
            ipaddr.IPv6.parser = function(string) {
                var addr, k, len, match, octet, octets, zoneId;
                if (ipv6Regexes['native'].test(string)) return expandIPv6(string, 8);
                if (match = string.match(ipv6Regexes['transitional'])) {
                    zoneId = match[6] || '';
                    addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
                    if (addr.parts) {
                        octets = [
                            parseInt(match[2]),
                            parseInt(match[3]),
                            parseInt(match[4]),
                            parseInt(match[5])
                        ];
                        for(k = 0, len = octets.length; k < len; k++){
                            octet = octets[k];
                            if (!(0 <= octet && octet <= 255)) return null;
                        }
                        addr.parts.push(octets[0] << 8 | octets[1]);
                        addr.parts.push(octets[2] << 8 | octets[3]);
                        return {
                            parts: addr.parts,
                            zoneId: addr.zoneId
                        };
                    }
                }
                return null;
            };
            ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
                return null !== this.parser(string);
            };
            ipaddr.IPv4.isValid = function(string) {
                try {
                    new this(this.parser(string));
                    return true;
                } catch (error1) {
                    return false;
                }
            };
            ipaddr.IPv4.isValidFourPartDecimal = function(string) {
                if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) return true;
                return false;
            };
            ipaddr.IPv6.isValid = function(string) {
                var addr;
                if ("string" == typeof string && -1 === string.indexOf(":")) return false;
                try {
                    addr = this.parser(string);
                    new this(addr.parts, addr.zoneId);
                    return true;
                } catch (error1) {
                    return false;
                }
            };
            ipaddr.IPv4.parse = function(string) {
                var parts;
                parts = this.parser(string);
                if (null === parts) throw new Error("ipaddr: string is not formatted like ip address");
                return new this(parts);
            };
            ipaddr.IPv6.parse = function(string) {
                var addr;
                addr = this.parser(string);
                if (null === addr.parts) throw new Error("ipaddr: string is not formatted like ip address");
                return new this(addr.parts, addr.zoneId);
            };
            ipaddr.IPv4.parseCIDR = function(string) {
                var maskLength, match, parsed;
                if (match = string.match(/^(.+)\/(\d+)$/)) {
                    maskLength = parseInt(match[2]);
                    if (maskLength >= 0 && maskLength <= 32) {
                        parsed = [
                            this.parse(match[1]),
                            maskLength
                        ];
                        Object.defineProperty(parsed, 'toString', {
                            value: function() {
                                return this.join('/');
                            }
                        });
                        return parsed;
                    }
                }
                throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
            };
            ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
                var filledOctetCount, j, octets;
                prefix = parseInt(prefix);
                if (prefix < 0 || prefix > 32) throw new Error('ipaddr: invalid IPv4 prefix length');
                octets = [
                    0,
                    0,
                    0,
                    0
                ];
                j = 0;
                filledOctetCount = Math.floor(prefix / 8);
                while(j < filledOctetCount){
                    octets[j] = 255;
                    j++;
                }
                if (filledOctetCount < 4) octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
                return new this(octets);
            };
            ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
                var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
                try {
                    cidr = this.parseCIDR(string);
                    ipInterfaceOctets = cidr[0].toByteArray();
                    subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
                    octets = [];
                    i = 0;
                    while(i < 4){
                        octets.push(parseInt(ipInterfaceOctets[i], 10) | 255 ^ parseInt(subnetMaskOctets[i], 10));
                        i++;
                    }
                    return new this(octets);
                } catch (error1) {
                    throw new Error('ipaddr: the address does not have IPv4 CIDR format');
                }
            };
            ipaddr.IPv4.networkAddressFromCIDR = function(string) {
                var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
                try {
                    cidr = this.parseCIDR(string);
                    ipInterfaceOctets = cidr[0].toByteArray();
                    subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
                    octets = [];
                    i = 0;
                    while(i < 4){
                        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
                        i++;
                    }
                    return new this(octets);
                } catch (error1) {
                    throw new Error('ipaddr: the address does not have IPv4 CIDR format');
                }
            };
            ipaddr.IPv6.parseCIDR = function(string) {
                var maskLength, match, parsed;
                if (match = string.match(/^(.+)\/(\d+)$/)) {
                    maskLength = parseInt(match[2]);
                    if (maskLength >= 0 && maskLength <= 128) {
                        parsed = [
                            this.parse(match[1]),
                            maskLength
                        ];
                        Object.defineProperty(parsed, 'toString', {
                            value: function() {
                                return this.join('/');
                            }
                        });
                        return parsed;
                    }
                }
                throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
            };
            ipaddr.isValid = function(string) {
                return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
            };
            ipaddr.parse = function(string) {
                if (ipaddr.IPv6.isValid(string)) return ipaddr.IPv6.parse(string);
                if (ipaddr.IPv4.isValid(string)) return ipaddr.IPv4.parse(string);
                throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
            };
            ipaddr.parseCIDR = function(string) {
                try {
                    return ipaddr.IPv6.parseCIDR(string);
                } catch (error1) {
                    try {
                        return ipaddr.IPv4.parseCIDR(string);
                    } catch (error1) {
                        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
                    }
                }
            };
            ipaddr.fromByteArray = function(bytes) {
                var length;
                length = bytes.length;
                if (4 === length) return new ipaddr.IPv4(bytes);
                if (16 === length) return new ipaddr.IPv6(bytes);
                throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
            };
            ipaddr.process = function(string) {
                var addr;
                addr = this.parse(string);
                if ('ipv6' === addr.kind() && addr.isIPv4MappedAddress()) return addr.toIPv4Address();
                return addr;
            };
        }).call(this);
    },
    "../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js": function(module) {
        "use strict";
        module.exports = Math.abs;
    },
    "../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js": function(module) {
        "use strict";
        module.exports = Math.floor;
    },
    "../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js": function(module) {
        "use strict";
        module.exports = Number.isNaN || function(a) {
            return a !== a;
        };
    },
    "../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js": function(module) {
        "use strict";
        module.exports = Math.max;
    },
    "../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js": function(module) {
        "use strict";
        module.exports = Math.min;
    },
    "../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js": function(module) {
        "use strict";
        module.exports = Math.pow;
    },
    "../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js": function(module) {
        "use strict";
        module.exports = Math.round;
    },
    "../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var $isNaN = __webpack_require__("../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js");
        module.exports = function(number) {
            if ($isNaN(number) || 0 === number) return number;
            return number < 0 ? -1 : 1;
        };
    },
    "../node_modules/.pnpm/media-typer@0.3.0/node_modules/media-typer/index.js": function(__unused_webpack_module, exports1) {
        /*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */ var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
        var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
        var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
        var qescRegExp = /\\([\u0000-\u007f])/g;
        var quoteRegExp = /([\\"])/g;
        var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
        var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
        var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
        exports1.format = format;
        exports1.parse = parse;
        function format(obj) {
            if (!obj || 'object' != typeof obj) throw new TypeError('argument obj is required');
            var parameters = obj.parameters;
            var subtype = obj.subtype;
            var suffix = obj.suffix;
            var type = obj.type;
            if (!type || !typeNameRegExp.test(type)) throw new TypeError('invalid type');
            if (!subtype || !subtypeNameRegExp.test(subtype)) throw new TypeError('invalid subtype');
            var string = type + '/' + subtype;
            if (suffix) {
                if (!typeNameRegExp.test(suffix)) throw new TypeError('invalid suffix');
                string += '+' + suffix;
            }
            if (parameters && 'object' == typeof parameters) {
                var param;
                var params = Object.keys(parameters).sort();
                for(var i = 0; i < params.length; i++){
                    param = params[i];
                    if (!tokenRegExp.test(param)) throw new TypeError('invalid parameter name');
                    string += '; ' + param + '=' + qstring(parameters[param]);
                }
            }
            return string;
        }
        function parse(string) {
            if (!string) throw new TypeError('argument string is required');
            if ('object' == typeof string) string = getcontenttype(string);
            if ('string' != typeof string) throw new TypeError('argument string is required to be a string');
            var index = string.indexOf(';');
            var type = -1 !== index ? string.substr(0, index) : string;
            var key;
            var match;
            var obj = splitType(type);
            var params = {};
            var value;
            paramRegExp.lastIndex = index;
            while(match = paramRegExp.exec(string)){
                if (match.index !== index) throw new TypeError('invalid parameter format');
                index += match[0].length;
                key = match[1].toLowerCase();
                value = match[2];
                if ('"' === value[0]) value = value.substr(1, value.length - 2).replace(qescRegExp, '$1');
                params[key] = value;
            }
            if (-1 !== index && index !== string.length) throw new TypeError('invalid parameter format');
            obj.parameters = params;
            return obj;
        }
        function getcontenttype(obj) {
            if ('function' == typeof obj.getHeader) return obj.getHeader('content-type');
            if ('object' == typeof obj.headers) return obj.headers && obj.headers['content-type'];
        }
        function qstring(val) {
            var str = String(val);
            if (tokenRegExp.test(str)) return str;
            if (str.length > 0 && !textRegExp.test(str)) throw new TypeError('invalid parameter value');
            return '"' + str.replace(quoteRegExp, '\\$1') + '"';
        }
        function splitType(string) {
            var match = typeRegExp.exec(string.toLowerCase());
            if (!match) throw new TypeError('invalid media type');
            var type = match[1];
            var subtype = match[2];
            var suffix;
            var index = subtype.lastIndexOf('+');
            if (-1 !== index) {
                suffix = subtype.substr(index + 1);
                subtype = subtype.substr(0, index);
            }
            var obj = {
                type: type,
                subtype: subtype,
                suffix: suffix
            };
            return obj;
        }
    },
    "../node_modules/.pnpm/merge-descriptors@1.0.3/node_modules/merge-descriptors/index.js": function(module) {
        "use strict";
        /*!
 * merge-descriptors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = merge;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function merge(dest, src, redefine) {
            if (!dest) throw new TypeError('argument dest is required');
            if (!src) throw new TypeError('argument src is required');
            if (void 0 === redefine) redefine = true;
            Object.getOwnPropertyNames(src).forEach(function(name) {
                if (!redefine && hasOwnProperty.call(dest, name)) return;
                var descriptor = Object.getOwnPropertyDescriptor(src, name);
                Object.defineProperty(dest, name, descriptor);
            });
            return dest;
        }
    },
    "../node_modules/.pnpm/methods@1.1.2/node_modules/methods/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * methods
 * Copyright(c) 2013-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var http = __webpack_require__("http");
        module.exports = getCurrentNodeMethods() || getBasicNodeMethods();
        function getCurrentNodeMethods() {
            return http.METHODS && http.METHODS.map(function(method) {
                return method.toLowerCase();
            });
        }
        function getBasicNodeMethods() {
            return [
                'get',
                'post',
                'put',
                'head',
                'delete',
                'options',
                'trace',
                'copy',
                'lock',
                'mkcol',
                'move',
                'purge',
                'propfind',
                'proppatch',
                'unlock',
                'report',
                'mkactivity',
                'checkout',
                'merge',
                'm-search',
                'notify',
                'subscribe',
                'unsubscribe',
                'patch',
                'search',
                'connect'
            ];
        }
    },
    "../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        /*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = __webpack_require__("../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json");
    },
    "../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        /*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var db = __webpack_require__("../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js");
        var extname = __webpack_require__("path").extname;
        var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
        var TEXT_TYPE_REGEXP = /^text\//i;
        exports1.charset = charset;
        exports1.charsets = {
            lookup: charset
        };
        exports1.contentType = contentType;
        exports1.extension = extension;
        exports1.extensions = Object.create(null);
        exports1.lookup = lookup;
        exports1.types = Object.create(null);
        populateMaps(exports1.extensions, exports1.types);
        function charset(type) {
            if (!type || 'string' != typeof type) return false;
            var match = EXTRACT_TYPE_REGEXP.exec(type);
            var mime = match && db[match[1].toLowerCase()];
            if (mime && mime.charset) return mime.charset;
            if (match && TEXT_TYPE_REGEXP.test(match[1])) return 'UTF-8';
            return false;
        }
        function contentType(str) {
            if (!str || 'string' != typeof str) return false;
            var mime = -1 === str.indexOf('/') ? exports1.lookup(str) : str;
            if (!mime) return false;
            if (-1 === mime.indexOf('charset')) {
                var charset = exports1.charset(mime);
                if (charset) mime += '; charset=' + charset.toLowerCase();
            }
            return mime;
        }
        function extension(type) {
            if (!type || 'string' != typeof type) return false;
            var match = EXTRACT_TYPE_REGEXP.exec(type);
            var exts = match && exports1.extensions[match[1].toLowerCase()];
            if (!exts || !exts.length) return false;
            return exts[0];
        }
        function lookup(path) {
            if (!path || 'string' != typeof path) return false;
            var extension = extname('x.' + path).toLowerCase().substr(1);
            if (!extension) return false;
            return exports1.types[extension] || false;
        }
        function populateMaps(extensions, types) {
            var preference = [
                'nginx',
                'apache',
                void 0,
                'iana'
            ];
            Object.keys(db).forEach(function(type) {
                var mime = db[type];
                var exts = mime.extensions;
                if (!exts || !exts.length) return;
                extensions[type] = exts;
                for(var i = 0; i < exts.length; i++){
                    var extension = exts[i];
                    if (types[extension]) {
                        var from = preference.indexOf(db[types[extension]].source);
                        var to = preference.indexOf(mime.source);
                        if ('application/octet-stream' !== types[extension] && (from > to || from === to && 'application/' === types[extension].substr(0, 12))) continue;
                    }
                    types[extension] = type;
                }
            });
        }
    },
    "../node_modules/.pnpm/mime@1.6.0/node_modules/mime/mime.js": function(module, __unused_webpack_exports, __webpack_require__) {
        __webpack_require__("path");
        var fs = __webpack_require__("fs");
        function Mime() {
            this.types = Object.create(null);
            this.extensions = Object.create(null);
        }
        Mime.prototype.define = function(map) {
            for(var type in map){
                var exts = map[type];
                for(var i = 0; i < exts.length; i++){
                    if (process.env.DEBUG_MIME && this.types[exts[i]]) console.warn((this._loading || "define()").replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' + this.types[exts[i]] + ' to ' + type);
                    this.types[exts[i]] = type;
                }
                if (!this.extensions[type]) this.extensions[type] = exts[0];
            }
        };
        Mime.prototype.load = function(file) {
            this._loading = file;
            var map = {}, content = fs.readFileSync(file, 'ascii'), lines = content.split(/[\r\n]+/);
            lines.forEach(function(line) {
                var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
                map[fields.shift()] = fields;
            });
            this.define(map);
            this._loading = null;
        };
        Mime.prototype.lookup = function(path, fallback) {
            var ext = path.replace(/^.*[\.\/\\]/, '').toLowerCase();
            return this.types[ext] || fallback || this.default_type;
        };
        Mime.prototype.extension = function(mimeType) {
            var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
            return this.extensions[type];
        };
        var mime = new Mime();
        mime.define(__webpack_require__("../node_modules/.pnpm/mime@1.6.0/node_modules/mime/types.json"));
        mime.default_type = mime.lookup('bin');
        mime.Mime = Mime;
        mime.charsets = {
            lookup: function(mimeType, fallback) {
                return /^text\/|^application\/(javascript|json)/.test(mimeType) ? 'UTF-8' : fallback;
            }
        };
        module.exports = mime;
    },
    "../node_modules/.pnpm/ms@2.0.0/node_modules/ms/index.js": function(module) {
        var s = 1000;
        var m = 60 * s;
        var h = 60 * m;
        var d = 24 * h;
        var y = 365.25 * d;
        module.exports = function(val, options) {
            options = options || {};
            var type = typeof val;
            if ('string' === type && val.length > 0) return parse(val);
            if ('number' === type && false === isNaN(val)) return options.long ? fmtLong(val) : fmtShort(val);
            throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
        };
        function parse(str) {
            str = String(str);
            if (str.length > 100) return;
            var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
            if (!match) return;
            var n = parseFloat(match[1]);
            var type = (match[2] || 'ms').toLowerCase();
            switch(type){
                case 'years':
                case 'year':
                case 'yrs':
                case 'yr':
                case 'y':
                    return n * y;
                case 'days':
                case 'day':
                case 'd':
                    return n * d;
                case 'hours':
                case 'hour':
                case 'hrs':
                case 'hr':
                case 'h':
                    return n * h;
                case 'minutes':
                case 'minute':
                case 'mins':
                case 'min':
                case 'm':
                    return n * m;
                case 'seconds':
                case 'second':
                case 'secs':
                case 'sec':
                case 's':
                    return n * s;
                case 'milliseconds':
                case 'millisecond':
                case 'msecs':
                case 'msec':
                case 'ms':
                    return n;
                default:
                    return;
            }
        }
        function fmtShort(ms) {
            if (ms >= d) return Math.round(ms / d) + 'd';
            if (ms >= h) return Math.round(ms / h) + 'h';
            if (ms >= m) return Math.round(ms / m) + 'm';
            if (ms >= s) return Math.round(ms / s) + 's';
            return ms + 'ms';
        }
        function fmtLong(ms) {
            return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
        }
        function plural(ms, n, name) {
            if (ms < n) return;
            if (ms < 1.5 * n) return Math.floor(ms / n) + ' ' + name;
            return Math.ceil(ms / n) + ' ' + name + 's';
        }
    },
    "../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js": function(module) {
        var s = 1000;
        var m = 60 * s;
        var h = 60 * m;
        var d = 24 * h;
        var w = 7 * d;
        var y = 365.25 * d;
        module.exports = function(val, options) {
            options = options || {};
            var type = typeof val;
            if ('string' === type && val.length > 0) return parse(val);
            if ('number' === type && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
            throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
        };
        function parse(str) {
            str = String(str);
            if (str.length > 100) return;
            var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
            if (!match) return;
            var n = parseFloat(match[1]);
            var type = (match[2] || 'ms').toLowerCase();
            switch(type){
                case 'years':
                case 'year':
                case 'yrs':
                case 'yr':
                case 'y':
                    return n * y;
                case 'weeks':
                case 'week':
                case 'w':
                    return n * w;
                case 'days':
                case 'day':
                case 'd':
                    return n * d;
                case 'hours':
                case 'hour':
                case 'hrs':
                case 'hr':
                case 'h':
                    return n * h;
                case 'minutes':
                case 'minute':
                case 'mins':
                case 'min':
                case 'm':
                    return n * m;
                case 'seconds':
                case 'second':
                case 'secs':
                case 'sec':
                case 's':
                    return n * s;
                case 'milliseconds':
                case 'millisecond':
                case 'msecs':
                case 'msec':
                case 'ms':
                    return n;
                default:
                    return;
            }
        }
        function fmtShort(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) return Math.round(ms / d) + 'd';
            if (msAbs >= h) return Math.round(ms / h) + 'h';
            if (msAbs >= m) return Math.round(ms / m) + 'm';
            if (msAbs >= s) return Math.round(ms / s) + 's';
            return ms + 'ms';
        }
        function fmtLong(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) return plural(ms, msAbs, d, 'day');
            if (msAbs >= h) return plural(ms, msAbs, h, 'hour');
            if (msAbs >= m) return plural(ms, msAbs, m, 'minute');
            if (msAbs >= s) return plural(ms, msAbs, s, 'second');
            return ms + ' ms';
        }
        function plural(ms, msAbs, n, name) {
            var isPlural = msAbs >= 1.5 * n;
            return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
        }
    },
    "../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var preferredCharsets = __webpack_require__("../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/charset.js");
        var preferredEncodings = __webpack_require__("../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/encoding.js");
        var preferredLanguages = __webpack_require__("../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/language.js");
        var preferredMediaTypes = __webpack_require__("../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/mediaType.js");
        module.exports = Negotiator;
        module.exports.Negotiator = Negotiator;
        function Negotiator(request) {
            if (!(this instanceof Negotiator)) return new Negotiator(request);
            this.request = request;
        }
        Negotiator.prototype.charset = function(available) {
            var set = this.charsets(available);
            return set && set[0];
        };
        Negotiator.prototype.charsets = function(available) {
            return preferredCharsets(this.request.headers['accept-charset'], available);
        };
        Negotiator.prototype.encoding = function(available) {
            var set = this.encodings(available);
            return set && set[0];
        };
        Negotiator.prototype.encodings = function(available) {
            return preferredEncodings(this.request.headers['accept-encoding'], available);
        };
        Negotiator.prototype.language = function(available) {
            var set = this.languages(available);
            return set && set[0];
        };
        Negotiator.prototype.languages = function(available) {
            return preferredLanguages(this.request.headers['accept-language'], available);
        };
        Negotiator.prototype.mediaType = function(available) {
            var set = this.mediaTypes(available);
            return set && set[0];
        };
        Negotiator.prototype.mediaTypes = function(available) {
            return preferredMediaTypes(this.request.headers.accept, available);
        };
        Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
        Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
        Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
        Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
        Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
        Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
        Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
        Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
    },
    "../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/charset.js": function(module) {
        "use strict";
        module.exports = preferredCharsets;
        module.exports.preferredCharsets = preferredCharsets;
        var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
        function parseAcceptCharset(accept) {
            var accepts = accept.split(',');
            for(var i = 0, j = 0; i < accepts.length; i++){
                var charset = parseCharset(accepts[i].trim(), i);
                if (charset) accepts[j++] = charset;
            }
            accepts.length = j;
            return accepts;
        }
        function parseCharset(str, i) {
            var match = simpleCharsetRegExp.exec(str);
            if (!match) return null;
            var charset = match[1];
            var q = 1;
            if (match[2]) {
                var params = match[2].split(';');
                for(var j = 0; j < params.length; j++){
                    var p = params[j].trim().split('=');
                    if ('q' === p[0]) {
                        q = parseFloat(p[1]);
                        break;
                    }
                }
            }
            return {
                charset: charset,
                q: q,
                i: i
            };
        }
        function getCharsetPriority(charset, accepted, index) {
            var priority = {
                o: -1,
                q: 0,
                s: 0
            };
            for(var i = 0; i < accepted.length; i++){
                var spec = specify(charset, accepted[i], index);
                if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
            }
            return priority;
        }
        function specify(charset, spec, index) {
            var s = 0;
            if (spec.charset.toLowerCase() === charset.toLowerCase()) s |= 1;
            else if ('*' !== spec.charset) return null;
            return {
                i: index,
                o: spec.i,
                q: spec.q,
                s: s
            };
        }
        function preferredCharsets(accept, provided) {
            var accepts = parseAcceptCharset(void 0 === accept ? '*' : accept || '');
            if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
            var priorities = provided.map(function(type, index) {
                return getCharsetPriority(type, accepts, index);
            });
            return priorities.filter(isQuality).sort(compareSpecs).map(function(priority) {
                return provided[priorities.indexOf(priority)];
            });
        }
        function compareSpecs(a, b) {
            return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
        }
        function getFullCharset(spec) {
            return spec.charset;
        }
        function isQuality(spec) {
            return spec.q > 0;
        }
    },
    "../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/encoding.js": function(module) {
        "use strict";
        module.exports = preferredEncodings;
        module.exports.preferredEncodings = preferredEncodings;
        var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
        function parseAcceptEncoding(accept) {
            var accepts = accept.split(',');
            var hasIdentity = false;
            var minQuality = 1;
            for(var i = 0, j = 0; i < accepts.length; i++){
                var encoding = parseEncoding(accepts[i].trim(), i);
                if (encoding) {
                    accepts[j++] = encoding;
                    hasIdentity = hasIdentity || specify('identity', encoding);
                    minQuality = Math.min(minQuality, encoding.q || 1);
                }
            }
            if (!hasIdentity) accepts[j++] = {
                encoding: 'identity',
                q: minQuality,
                i: i
            };
            accepts.length = j;
            return accepts;
        }
        function parseEncoding(str, i) {
            var match = simpleEncodingRegExp.exec(str);
            if (!match) return null;
            var encoding = match[1];
            var q = 1;
            if (match[2]) {
                var params = match[2].split(';');
                for(var j = 0; j < params.length; j++){
                    var p = params[j].trim().split('=');
                    if ('q' === p[0]) {
                        q = parseFloat(p[1]);
                        break;
                    }
                }
            }
            return {
                encoding: encoding,
                q: q,
                i: i
            };
        }
        function getEncodingPriority(encoding, accepted, index) {
            var priority = {
                o: -1,
                q: 0,
                s: 0
            };
            for(var i = 0; i < accepted.length; i++){
                var spec = specify(encoding, accepted[i], index);
                if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
            }
            return priority;
        }
        function specify(encoding, spec, index) {
            var s = 0;
            if (spec.encoding.toLowerCase() === encoding.toLowerCase()) s |= 1;
            else if ('*' !== spec.encoding) return null;
            return {
                i: index,
                o: spec.i,
                q: spec.q,
                s: s
            };
        }
        function preferredEncodings(accept, provided) {
            var accepts = parseAcceptEncoding(accept || '');
            if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
            var priorities = provided.map(function(type, index) {
                return getEncodingPriority(type, accepts, index);
            });
            return priorities.filter(isQuality).sort(compareSpecs).map(function(priority) {
                return provided[priorities.indexOf(priority)];
            });
        }
        function compareSpecs(a, b) {
            return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
        }
        function getFullEncoding(spec) {
            return spec.encoding;
        }
        function isQuality(spec) {
            return spec.q > 0;
        }
    },
    "../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/language.js": function(module) {
        "use strict";
        module.exports = preferredLanguages;
        module.exports.preferredLanguages = preferredLanguages;
        var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
        function parseAcceptLanguage(accept) {
            var accepts = accept.split(',');
            for(var i = 0, j = 0; i < accepts.length; i++){
                var language = parseLanguage(accepts[i].trim(), i);
                if (language) accepts[j++] = language;
            }
            accepts.length = j;
            return accepts;
        }
        function parseLanguage(str, i) {
            var match = simpleLanguageRegExp.exec(str);
            if (!match) return null;
            var prefix = match[1];
            var suffix = match[2];
            var full = prefix;
            if (suffix) full += "-" + suffix;
            var q = 1;
            if (match[3]) {
                var params = match[3].split(';');
                for(var j = 0; j < params.length; j++){
                    var p = params[j].split('=');
                    if ('q' === p[0]) q = parseFloat(p[1]);
                }
            }
            return {
                prefix: prefix,
                suffix: suffix,
                q: q,
                i: i,
                full: full
            };
        }
        function getLanguagePriority(language, accepted, index) {
            var priority = {
                o: -1,
                q: 0,
                s: 0
            };
            for(var i = 0; i < accepted.length; i++){
                var spec = specify(language, accepted[i], index);
                if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
            }
            return priority;
        }
        function specify(language, spec, index) {
            var p = parseLanguage(language);
            if (!p) return null;
            var s = 0;
            if (spec.full.toLowerCase() === p.full.toLowerCase()) s |= 4;
            else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) s |= 2;
            else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) s |= 1;
            else if ('*' !== spec.full) return null;
            return {
                i: index,
                o: spec.i,
                q: spec.q,
                s: s
            };
        }
        function preferredLanguages(accept, provided) {
            var accepts = parseAcceptLanguage(void 0 === accept ? '*' : accept || '');
            if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
            var priorities = provided.map(function(type, index) {
                return getLanguagePriority(type, accepts, index);
            });
            return priorities.filter(isQuality).sort(compareSpecs).map(function(priority) {
                return provided[priorities.indexOf(priority)];
            });
        }
        function compareSpecs(a, b) {
            return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
        }
        function getFullLanguage(spec) {
            return spec.full;
        }
        function isQuality(spec) {
            return spec.q > 0;
        }
    },
    "../node_modules/.pnpm/negotiator@0.6.3/node_modules/negotiator/lib/mediaType.js": function(module) {
        "use strict";
        module.exports = preferredMediaTypes;
        module.exports.preferredMediaTypes = preferredMediaTypes;
        var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
        function parseAccept(accept) {
            var accepts = splitMediaTypes(accept);
            for(var i = 0, j = 0; i < accepts.length; i++){
                var mediaType = parseMediaType(accepts[i].trim(), i);
                if (mediaType) accepts[j++] = mediaType;
            }
            accepts.length = j;
            return accepts;
        }
        function parseMediaType(str, i) {
            var match = simpleMediaTypeRegExp.exec(str);
            if (!match) return null;
            var params = Object.create(null);
            var q = 1;
            var subtype = match[2];
            var type = match[1];
            if (match[3]) {
                var kvps = splitParameters(match[3]).map(splitKeyValuePair);
                for(var j = 0; j < kvps.length; j++){
                    var pair = kvps[j];
                    var key = pair[0].toLowerCase();
                    var val = pair[1];
                    var value = val && '"' === val[0] && '"' === val[val.length - 1] ? val.substr(1, val.length - 2) : val;
                    if ('q' === key) {
                        q = parseFloat(value);
                        break;
                    }
                    params[key] = value;
                }
            }
            return {
                type: type,
                subtype: subtype,
                params: params,
                q: q,
                i: i
            };
        }
        function getMediaTypePriority(type, accepted, index) {
            var priority = {
                o: -1,
                q: 0,
                s: 0
            };
            for(var i = 0; i < accepted.length; i++){
                var spec = specify(type, accepted[i], index);
                if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) priority = spec;
            }
            return priority;
        }
        function specify(type, spec, index) {
            var p = parseMediaType(type);
            var s = 0;
            if (!p) return null;
            if (spec.type.toLowerCase() == p.type.toLowerCase()) s |= 4;
            else if ('*' != spec.type) return null;
            if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) s |= 2;
            else if ('*' != spec.subtype) return null;
            var keys = Object.keys(spec.params);
            if (keys.length > 0) if (!keys.every(function(k) {
                return '*' == spec.params[k] || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
            })) return null;
            else s |= 1;
            return {
                i: index,
                o: spec.i,
                q: spec.q,
                s: s
            };
        }
        function preferredMediaTypes(accept, provided) {
            var accepts = parseAccept(void 0 === accept ? '*/*' : accept || '');
            if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
            var priorities = provided.map(function(type, index) {
                return getMediaTypePriority(type, accepts, index);
            });
            return priorities.filter(isQuality).sort(compareSpecs).map(function(priority) {
                return provided[priorities.indexOf(priority)];
            });
        }
        function compareSpecs(a, b) {
            return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
        }
        function getFullType(spec) {
            return spec.type + '/' + spec.subtype;
        }
        function isQuality(spec) {
            return spec.q > 0;
        }
        function quoteCount(string) {
            var count = 0;
            var index = 0;
            while(-1 !== (index = string.indexOf('"', index))){
                count++;
                index++;
            }
            return count;
        }
        function splitKeyValuePair(str) {
            var index = str.indexOf('=');
            var key;
            var val;
            if (-1 === index) key = str;
            else {
                key = str.substr(0, index);
                val = str.substr(index + 1);
            }
            return [
                key,
                val
            ];
        }
        function splitMediaTypes(accept) {
            var accepts = accept.split(',');
            for(var i = 1, j = 0; i < accepts.length; i++)if (quoteCount(accepts[j]) % 2 == 0) accepts[++j] = accepts[i];
            else accepts[j] += ',' + accepts[i];
            accepts.length = j + 1;
            return accepts;
        }
        function splitParameters(str) {
            var parameters = str.split(';');
            for(var i = 1, j = 0; i < parameters.length; i++)if (quoteCount(parameters[j]) % 2 == 0) parameters[++j] = parameters[i];
            else parameters[j] += ';' + parameters[i];
            parameters.length = j + 1;
            for(var i = 0; i < parameters.length; i++)parameters[i] = parameters[i].trim();
            return parameters;
        }
    },
    "../node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js": function(module) {
        "use strict";
        /*
object-assign
(c) Sindre Sorhus
@license MIT
*/ var getOwnPropertySymbols = Object.getOwnPropertySymbols;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var propIsEnumerable = Object.prototype.propertyIsEnumerable;
        function toObject(val) {
            if (null == val) throw new TypeError('Object.assign cannot be called with null or undefined');
            return Object(val);
        }
        function shouldUseNative() {
            try {
                if (!Object.assign) return false;
                var test1 = new String('abc');
                test1[5] = 'de';
                if ('5' === Object.getOwnPropertyNames(test1)[0]) return false;
                var test2 = {};
                for(var i = 0; i < 10; i++)test2['_' + String.fromCharCode(i)] = i;
                var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
                    return test2[n];
                });
                if ('0123456789' !== order2.join('')) return false;
                var test3 = {};
                'abcdefghijklmnopqrst'.split('').forEach(function(letter) {
                    test3[letter] = letter;
                });
                if ('abcdefghijklmnopqrst' !== Object.keys(Object.assign({}, test3)).join('')) return false;
                return true;
            } catch (err) {
                return false;
            }
        }
        module.exports = shouldUseNative() ? Object.assign : function(target, source) {
            var from;
            var to = toObject(target);
            var symbols;
            for(var s = 1; s < arguments.length; s++){
                from = Object(arguments[s]);
                for(var key in from)if (hasOwnProperty.call(from, key)) to[key] = from[key];
                if (getOwnPropertySymbols) {
                    symbols = getOwnPropertySymbols(from);
                    for(var i = 0; i < symbols.length; i++)if (propIsEnumerable.call(from, symbols[i])) to[symbols[i]] = from[symbols[i]];
                }
            }
            return to;
        };
    },
    "../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        var hasMap = 'function' == typeof Map && Map.prototype;
        var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
        var mapSize = hasMap && mapSizeDescriptor && 'function' == typeof mapSizeDescriptor.get ? mapSizeDescriptor.get : null;
        var mapForEach = hasMap && Map.prototype.forEach;
        var hasSet = 'function' == typeof Set && Set.prototype;
        var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
        var setSize = hasSet && setSizeDescriptor && 'function' == typeof setSizeDescriptor.get ? setSizeDescriptor.get : null;
        var setForEach = hasSet && Set.prototype.forEach;
        var hasWeakMap = 'function' == typeof WeakMap && WeakMap.prototype;
        var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
        var hasWeakSet = 'function' == typeof WeakSet && WeakSet.prototype;
        var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
        var hasWeakRef = 'function' == typeof WeakRef && WeakRef.prototype;
        var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
        var booleanValueOf = Boolean.prototype.valueOf;
        var objectToString = Object.prototype.toString;
        var functionToString = Function.prototype.toString;
        var $match = String.prototype.match;
        var $slice = String.prototype.slice;
        var $replace = String.prototype.replace;
        var $toUpperCase = String.prototype.toUpperCase;
        var $toLowerCase = String.prototype.toLowerCase;
        var $test = RegExp.prototype.test;
        var $concat = Array.prototype.concat;
        var $join = Array.prototype.join;
        var $arrSlice = Array.prototype.slice;
        var $floor = Math.floor;
        var bigIntValueOf = 'function' == typeof BigInt ? BigInt.prototype.valueOf : null;
        var gOPS = Object.getOwnPropertySymbols;
        var symToString = 'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator ? Symbol.prototype.toString : null;
        var hasShammedSymbols = 'function' == typeof Symbol && 'object' == typeof Symbol.iterator;
        var toStringTag = 'function' == typeof Symbol && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol') ? Symbol.toStringTag : null;
        var isEnumerable = Object.prototype.propertyIsEnumerable;
        var gPO = ('function' == typeof Reflect ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
            return O.__proto__;
        } : null);
        function addNumericSeparator(num, str) {
            if (num === 1 / 0 || num === -1 / 0 || num !== num || num && num > -1000 && num < 1000 || $test.call(/e/, str)) return str;
            var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
            if ('number' == typeof num) {
                var int = num < 0 ? -$floor(-num) : $floor(num);
                if (int !== num) {
                    var intStr = String(int);
                    var dec = $slice.call(str, intStr.length + 1);
                    return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
                }
            }
            return $replace.call(str, sepRegex, '$&_');
        }
        var utilInspect = __webpack_require__("../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/util.inspect.js");
        var inspectCustom = utilInspect.custom;
        var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
        var quotes = {
            __proto__: null,
            double: '"',
            single: "'"
        };
        var quoteREs = {
            __proto__: null,
            double: /(["\\])/g,
            single: /(['\\])/g
        };
        module.exports = function inspect_(obj, options, depth, seen) {
            var opts = options || {};
            if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) throw new TypeError('option "quoteStyle" must be "single" or "double"');
            if (has(opts, 'maxStringLength') && ('number' == typeof opts.maxStringLength ? opts.maxStringLength < 0 && opts.maxStringLength !== 1 / 0 : null !== opts.maxStringLength)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
            var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
            if ('boolean' != typeof customInspect && 'symbol' !== customInspect) throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
            if (has(opts, 'indent') && null !== opts.indent && '\t' !== opts.indent && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
            if (has(opts, 'numericSeparator') && 'boolean' != typeof opts.numericSeparator) throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
            var numericSeparator = opts.numericSeparator;
            if (void 0 === obj) return 'undefined';
            if (null === obj) return 'null';
            if ('boolean' == typeof obj) return obj ? 'true' : 'false';
            if ('string' == typeof obj) return inspectString(obj, opts);
            if ('number' == typeof obj) {
                if (0 === obj) return 1 / 0 / obj > 0 ? '0' : '-0';
                var str = String(obj);
                return numericSeparator ? addNumericSeparator(obj, str) : str;
            }
            if ('bigint' == typeof obj) {
                var bigIntStr = String(obj) + 'n';
                return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
            }
            var maxDepth = void 0 === opts.depth ? 5 : opts.depth;
            if (void 0 === depth) depth = 0;
            if (depth >= maxDepth && maxDepth > 0 && 'object' == typeof obj) return isArray(obj) ? '[Array]' : '[Object]';
            var indent = getIndent(opts, depth);
            if (void 0 === seen) seen = [];
            else if (indexOf(seen, obj) >= 0) return '[Circular]';
            function inspect(value, from, noIndent) {
                if (from) {
                    seen = $arrSlice.call(seen);
                    seen.push(from);
                }
                if (noIndent) {
                    var newOpts = {
                        depth: opts.depth
                    };
                    if (has(opts, 'quoteStyle')) newOpts.quoteStyle = opts.quoteStyle;
                    return inspect_(value, newOpts, depth + 1, seen);
                }
                return inspect_(value, opts, depth + 1, seen);
            }
            if ('function' == typeof obj && !isRegExp(obj)) {
                var name = nameOf(obj);
                var keys = arrObjKeys(obj, inspect);
                return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
            }
            if (isSymbol(obj)) {
                var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
                return 'object' != typeof obj || hasShammedSymbols ? symString : markBoxed(symString);
            }
            if (isElement(obj)) {
                var s = '<' + $toLowerCase.call(String(obj.nodeName));
                var attrs = obj.attributes || [];
                for(var i = 0; i < attrs.length; i++)s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
                s += '>';
                if (obj.childNodes && obj.childNodes.length) s += '...';
                s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
                return s;
            }
            if (isArray(obj)) {
                if (0 === obj.length) return '[]';
                var xs = arrObjKeys(obj, inspect);
                if (indent && !singleLineValues(xs)) return '[' + indentedJoin(xs, indent) + ']';
                return '[ ' + $join.call(xs, ', ') + ' ]';
            }
            if (isError(obj)) {
                var parts = arrObjKeys(obj, inspect);
                if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
                if (0 === parts.length) return '[' + String(obj) + ']';
                return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
            }
            if ('object' == typeof obj && customInspect) {
                if (inspectSymbol && 'function' == typeof obj[inspectSymbol] && utilInspect) return utilInspect(obj, {
                    depth: maxDepth - depth
                });
                else if ('symbol' !== customInspect && 'function' == typeof obj.inspect) return obj.inspect();
            }
            if (isMap(obj)) {
                var mapParts = [];
                if (mapForEach) mapForEach.call(obj, function(value, key) {
                    mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
                });
                return collectionOf('Map', mapSize.call(obj), mapParts, indent);
            }
            if (isSet(obj)) {
                var setParts = [];
                if (setForEach) setForEach.call(obj, function(value) {
                    setParts.push(inspect(value, obj));
                });
                return collectionOf('Set', setSize.call(obj), setParts, indent);
            }
            if (isWeakMap(obj)) return weakCollectionOf('WeakMap');
            if (isWeakSet(obj)) return weakCollectionOf('WeakSet');
            if (isWeakRef(obj)) return weakCollectionOf('WeakRef');
            if (isNumber(obj)) return markBoxed(inspect(Number(obj)));
            if (isBigInt(obj)) return markBoxed(inspect(bigIntValueOf.call(obj)));
            if (isBoolean(obj)) return markBoxed(booleanValueOf.call(obj));
            if (isString(obj)) return markBoxed(inspect(String(obj)));
            if ('undefined' != typeof window && obj === window) return '{ [object Window] }';
            if ('undefined' != typeof globalThis && obj === globalThis || 'undefined' != typeof global && obj === global) return '{ [object globalThis] }';
            if (!isDate(obj) && !isRegExp(obj)) {
                var ys = arrObjKeys(obj, inspect);
                var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
                var protoTag = obj instanceof Object ? '' : 'null prototype';
                var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
                var constructorTag = isPlainObject || 'function' != typeof obj.constructor ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
                var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
                if (0 === ys.length) return tag + '{}';
                if (indent) return tag + '{' + indentedJoin(ys, indent) + '}';
                return tag + '{ ' + $join.call(ys, ', ') + ' }';
            }
            return String(obj);
        };
        function wrapQuotes(s, defaultStyle, opts) {
            var style = opts.quoteStyle || defaultStyle;
            var quoteChar = quotes[style];
            return quoteChar + s + quoteChar;
        }
        function quote(s) {
            return $replace.call(String(s), /"/g, '&quot;');
        }
        function canTrustToString(obj) {
            return !toStringTag || !('object' == typeof obj && (toStringTag in obj || void 0 !== obj[toStringTag]));
        }
        function isArray(obj) {
            return '[object Array]' === toStr(obj) && canTrustToString(obj);
        }
        function isDate(obj) {
            return '[object Date]' === toStr(obj) && canTrustToString(obj);
        }
        function isRegExp(obj) {
            return '[object RegExp]' === toStr(obj) && canTrustToString(obj);
        }
        function isError(obj) {
            return '[object Error]' === toStr(obj) && canTrustToString(obj);
        }
        function isString(obj) {
            return '[object String]' === toStr(obj) && canTrustToString(obj);
        }
        function isNumber(obj) {
            return '[object Number]' === toStr(obj) && canTrustToString(obj);
        }
        function isBoolean(obj) {
            return '[object Boolean]' === toStr(obj) && canTrustToString(obj);
        }
        function isSymbol(obj) {
            if (hasShammedSymbols) return obj && 'object' == typeof obj && obj instanceof Symbol;
            if ('symbol' == typeof obj) return true;
            if (!obj || 'object' != typeof obj || !symToString) return false;
            try {
                symToString.call(obj);
                return true;
            } catch (e) {}
            return false;
        }
        function isBigInt(obj) {
            if (!obj || 'object' != typeof obj || !bigIntValueOf) return false;
            try {
                bigIntValueOf.call(obj);
                return true;
            } catch (e) {}
            return false;
        }
        var hasOwn = Object.prototype.hasOwnProperty || function(key) {
            return key in this;
        };
        function has(obj, key) {
            return hasOwn.call(obj, key);
        }
        function toStr(obj) {
            return objectToString.call(obj);
        }
        function nameOf(f) {
            if (f.name) return f.name;
            var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
            if (m) return m[1];
            return null;
        }
        function indexOf(xs, x) {
            if (xs.indexOf) return xs.indexOf(x);
            for(var i = 0, l = xs.length; i < l; i++)if (xs[i] === x) return i;
            return -1;
        }
        function isMap(x) {
            if (!mapSize || !x || 'object' != typeof x) return false;
            try {
                mapSize.call(x);
                try {
                    setSize.call(x);
                } catch (s) {
                    return true;
                }
                return x instanceof Map;
            } catch (e) {}
            return false;
        }
        function isWeakMap(x) {
            if (!weakMapHas || !x || 'object' != typeof x) return false;
            try {
                weakMapHas.call(x, weakMapHas);
                try {
                    weakSetHas.call(x, weakSetHas);
                } catch (s) {
                    return true;
                }
                return x instanceof WeakMap;
            } catch (e) {}
            return false;
        }
        function isWeakRef(x) {
            if (!weakRefDeref || !x || 'object' != typeof x) return false;
            try {
                weakRefDeref.call(x);
                return true;
            } catch (e) {}
            return false;
        }
        function isSet(x) {
            if (!setSize || !x || 'object' != typeof x) return false;
            try {
                setSize.call(x);
                try {
                    mapSize.call(x);
                } catch (m) {
                    return true;
                }
                return x instanceof Set;
            } catch (e) {}
            return false;
        }
        function isWeakSet(x) {
            if (!weakSetHas || !x || 'object' != typeof x) return false;
            try {
                weakSetHas.call(x, weakSetHas);
                try {
                    weakMapHas.call(x, weakMapHas);
                } catch (s) {
                    return true;
                }
                return x instanceof WeakSet;
            } catch (e) {}
            return false;
        }
        function isElement(x) {
            if (!x || 'object' != typeof x) return false;
            if ('undefined' != typeof HTMLElement && x instanceof HTMLElement) return true;
            return 'string' == typeof x.nodeName && 'function' == typeof x.getAttribute;
        }
        function inspectString(str, opts) {
            if (str.length > opts.maxStringLength) {
                var remaining = str.length - opts.maxStringLength;
                var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
                return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
            }
            var quoteRE = quoteREs[opts.quoteStyle || 'single'];
            quoteRE.lastIndex = 0;
            var s = $replace.call($replace.call(str, quoteRE, '\\$1'), /[\x00-\x1f]/g, lowbyte);
            return wrapQuotes(s, 'single', opts);
        }
        function lowbyte(c) {
            var n = c.charCodeAt(0);
            var x = {
                8: 'b',
                9: 't',
                10: 'n',
                12: 'f',
                13: 'r'
            }[n];
            if (x) return '\\' + x;
            return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
        }
        function markBoxed(str) {
            return 'Object(' + str + ')';
        }
        function weakCollectionOf(type) {
            return type + ' { ? }';
        }
        function collectionOf(type, size, entries, indent) {
            var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
            return type + ' (' + size + ') {' + joinedEntries + '}';
        }
        function singleLineValues(xs) {
            for(var i = 0; i < xs.length; i++)if (indexOf(xs[i], '\n') >= 0) return false;
            return true;
        }
        function getIndent(opts, depth) {
            var baseIndent;
            if ('\t' === opts.indent) baseIndent = '\t';
            else {
                if ('number' != typeof opts.indent || !(opts.indent > 0)) return null;
                baseIndent = $join.call(Array(opts.indent + 1), ' ');
            }
            return {
                base: baseIndent,
                prev: $join.call(Array(depth + 1), baseIndent)
            };
        }
        function indentedJoin(xs, indent) {
            if (0 === xs.length) return '';
            var lineJoiner = '\n' + indent.prev + indent.base;
            return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
        }
        function arrObjKeys(obj, inspect) {
            var isArr = isArray(obj);
            var xs = [];
            if (isArr) {
                xs.length = obj.length;
                for(var i = 0; i < obj.length; i++)xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
            }
            var syms = 'function' == typeof gOPS ? gOPS(obj) : [];
            var symMap;
            if (hasShammedSymbols) {
                symMap = {};
                for(var k = 0; k < syms.length; k++)symMap['$' + syms[k]] = syms[k];
            }
            for(var key in obj)if (has(obj, key)) {
                if (!isArr || String(Number(key)) !== key || !(key < obj.length)) if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) continue;
                else if ($test.call(/[^\w$]/, key)) xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
                else xs.push(key + ': ' + inspect(obj[key], obj));
            }
            if ('function' == typeof gOPS) {
                for(var j = 0; j < syms.length; j++)if (isEnumerable.call(obj, syms[j])) xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
            return xs;
        }
    },
    "../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/util.inspect.js": function(module, __unused_webpack_exports, __webpack_require__) {
        module.exports = __webpack_require__("util").inspect;
    },
    "../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = onFinished;
        module.exports.isFinished = isFinished;
        var asyncHooks = tryRequireAsyncHooks();
        var first = __webpack_require__("../node_modules/.pnpm/ee-first@1.1.1/node_modules/ee-first/index.js");
        var defer = 'function' == typeof setImmediate ? setImmediate : function(fn) {
            process.nextTick(fn.bind.apply(fn, arguments));
        };
        function onFinished(msg, listener) {
            if (false !== isFinished(msg)) {
                defer(listener, null, msg);
                return msg;
            }
            attachListener(msg, wrap(listener));
            return msg;
        }
        function isFinished(msg) {
            var socket = msg.socket;
            if ('boolean' == typeof msg.finished) return Boolean(msg.finished || socket && !socket.writable);
            if ('boolean' == typeof msg.complete) return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
        }
        function attachFinishedListener(msg, callback) {
            var eeMsg;
            var eeSocket;
            var finished = false;
            function onFinish(error) {
                eeMsg.cancel();
                eeSocket.cancel();
                finished = true;
                callback(error);
            }
            eeMsg = eeSocket = first([
                [
                    msg,
                    'end',
                    'finish'
                ]
            ], onFinish);
            function onSocket(socket) {
                msg.removeListener('socket', onSocket);
                if (finished) return;
                if (eeMsg !== eeSocket) return;
                eeSocket = first([
                    [
                        socket,
                        'error',
                        'close'
                    ]
                ], onFinish);
            }
            if (msg.socket) return void onSocket(msg.socket);
            msg.on('socket', onSocket);
            if (void 0 === msg.socket) patchAssignSocket(msg, onSocket);
        }
        function attachListener(msg, listener) {
            var attached = msg.__onFinished;
            if (!attached || !attached.queue) {
                attached = msg.__onFinished = createListener(msg);
                attachFinishedListener(msg, attached);
            }
            attached.queue.push(listener);
        }
        function createListener(msg) {
            function listener(err) {
                if (msg.__onFinished === listener) msg.__onFinished = null;
                if (!listener.queue) return;
                var queue = listener.queue;
                listener.queue = null;
                for(var i = 0; i < queue.length; i++)queue[i](err, msg);
            }
            listener.queue = [];
            return listener;
        }
        function patchAssignSocket(res, callback) {
            var assignSocket = res.assignSocket;
            if ('function' != typeof assignSocket) return;
            res.assignSocket = function(socket) {
                assignSocket.call(this, socket);
                callback(socket);
            };
        }
        function tryRequireAsyncHooks() {
            try {
                return __webpack_require__("async_hooks");
            } catch (e) {
                return {};
            }
        }
        function wrap(fn) {
            var res;
            if (asyncHooks.AsyncResource) res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');
            if (!res || !res.runInAsyncScope) return fn;
            return res.runInAsyncScope.bind(res, fn, null);
        }
    },
    "../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ var url = __webpack_require__("url");
        var parse = url.parse;
        var Url = url.Url;
        module.exports = parseurl;
        module.exports.original = originalurl;
        function parseurl(req) {
            var url = req.url;
            if (void 0 === url) return;
            var parsed = req._parsedUrl;
            if (fresh(url, parsed)) return parsed;
            parsed = fastparse(url);
            parsed._raw = url;
            return req._parsedUrl = parsed;
        }
        function originalurl(req) {
            var url = req.originalUrl;
            if ('string' != typeof url) return parseurl(req);
            var parsed = req._parsedOriginalUrl;
            if (fresh(url, parsed)) return parsed;
            parsed = fastparse(url);
            parsed._raw = url;
            return req._parsedOriginalUrl = parsed;
        }
        function fastparse(str) {
            if ('string' != typeof str || 0x2f !== str.charCodeAt(0)) return parse(str);
            var pathname = str;
            var query = null;
            var search = null;
            for(var i = 1; i < str.length; i++)switch(str.charCodeAt(i)){
                case 0x3f:
                    if (null === search) {
                        pathname = str.substring(0, i);
                        query = str.substring(i + 1);
                        search = str.substring(i);
                    }
                    break;
                case 0x09:
                case 0x0a:
                case 0x0c:
                case 0x0d:
                case 0x20:
                case 0x23:
                case 0xa0:
                case 0xfeff:
                    return parse(str);
            }
            var url = void 0 !== Url ? new Url() : {};
            url.path = str;
            url.href = str;
            url.pathname = pathname;
            if (null !== search) {
                url.query = query;
                url.search = search;
            }
            return url;
        }
        function fresh(url, parsedUrl) {
            return 'object' == typeof parsedUrl && null !== parsedUrl && (void 0 === Url || parsedUrl instanceof Url) && parsedUrl._raw === url;
        }
    },
    "../node_modules/.pnpm/path-to-regexp@0.1.12/node_modules/path-to-regexp/index.js": function(module) {
        module.exports = pathToRegexp;
        var MATCHING_GROUP_REGEXP = /\\.|\((?:\?<(.*?)>)?(?!\?)/g;
        function pathToRegexp(path, keys, options) {
            options = options || {};
            keys = keys || [];
            var strict = options.strict;
            var end = false !== options.end;
            var flags = options.sensitive ? '' : 'i';
            var lookahead = false !== options.lookahead;
            var extraOffset = 0;
            var keysOffset = keys.length;
            var i = 0;
            var name = 0;
            var pos = 0;
            var backtrack = '';
            var m;
            if (path instanceof RegExp) {
                while(m = MATCHING_GROUP_REGEXP.exec(path.source)){
                    if ('\\' === m[0][0]) continue;
                    keys.push({
                        name: m[1] || name++,
                        optional: false,
                        offset: m.index
                    });
                }
                return path;
            }
            if (Array.isArray(path)) {
                path = path.map(function(value) {
                    return pathToRegexp(value, keys, options).source;
                });
                return new RegExp(path.join('|'), flags);
            }
            if ('string' != typeof path) throw new TypeError('path must be a string, array of strings, or regular expression');
            path = path.replace(/\\.|(\/)?(\.)?:(\w+)(\(.*?\))?(\*)?(\?)?|[.*]|\/\(/g, function(match, slash, format, key, capture, star, optional, offset) {
                if ('\\' === match[0]) {
                    backtrack += match;
                    pos += 2;
                    return match;
                }
                if ('.' === match) {
                    backtrack += '\\.';
                    extraOffset += 1;
                    pos += 1;
                    return '\\.';
                }
                if (slash || format) backtrack = '';
                else backtrack += path.slice(pos, offset);
                pos = offset + match.length;
                if ('*' === match) {
                    extraOffset += 3;
                    return '(.*)';
                }
                if ('/(' === match) {
                    backtrack += '/';
                    extraOffset += 2;
                    return '/(?:';
                }
                slash = slash || '';
                format = format ? '\\.' : '';
                optional = optional || '';
                capture = capture ? capture.replace(/\\.|\*/, function(m) {
                    return '*' === m ? '(.*)' : m;
                }) : backtrack ? '((?:(?!/|' + backtrack + ').)+?)' : '([^/' + format + ']+?)';
                keys.push({
                    name: key,
                    optional: !!optional,
                    offset: offset + extraOffset
                });
                var result = '(?:' + format + slash + capture + (star ? '((?:[/' + format + '].+?)?)' : '') + ')' + optional;
                extraOffset += result.length - match.length;
                return result;
            });
            while(m = MATCHING_GROUP_REGEXP.exec(path)){
                if ('\\' === m[0][0]) continue;
                if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) keys.splice(keysOffset + i, 0, {
                    name: name++,
                    optional: false,
                    offset: m.index
                });
                i++;
            }
            path += strict ? '' : '/' === path[path.length - 1] ? '?' : '/?';
            if (end) path += '$';
            else if ('/' !== path[path.length - 1]) path += lookahead ? '(?=/|$)' : '(?:/|$)';
            return new RegExp('^' + path, flags);
        }
    },
    "../node_modules/.pnpm/proxy-addr@2.0.7/node_modules/proxy-addr/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = proxyaddr;
        module.exports.all = alladdrs;
        module.exports.compile = compile;
        var forwarded = __webpack_require__("../node_modules/.pnpm/forwarded@0.2.0/node_modules/forwarded/index.js");
        var ipaddr = __webpack_require__("../node_modules/.pnpm/ipaddr.js@1.9.1/node_modules/ipaddr.js/lib/ipaddr.js");
        var DIGIT_REGEXP = /^[0-9]+$/;
        var isip = ipaddr.isValid;
        var parseip = ipaddr.parse;
        var IP_RANGES = {
            linklocal: [
                '169.254.0.0/16',
                'fe80::/10'
            ],
            loopback: [
                '127.0.0.1/8',
                '::1/128'
            ],
            uniquelocal: [
                '10.0.0.0/8',
                '172.16.0.0/12',
                '192.168.0.0/16',
                'fc00::/7'
            ]
        };
        function alladdrs(req, trust) {
            var addrs = forwarded(req);
            if (!trust) return addrs;
            if ('function' != typeof trust) trust = compile(trust);
            for(var i = 0; i < addrs.length - 1; i++)if (!trust(addrs[i], i)) addrs.length = i + 1;
            return addrs;
        }
        function compile(val) {
            if (!val) throw new TypeError('argument is required');
            var trust;
            if ('string' == typeof val) trust = [
                val
            ];
            else if (Array.isArray(val)) trust = val.slice();
            else throw new TypeError('unsupported trust argument');
            for(var i = 0; i < trust.length; i++){
                val = trust[i];
                if (Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
                    val = IP_RANGES[val];
                    trust.splice.apply(trust, [
                        i,
                        1
                    ].concat(val));
                    i += val.length - 1;
                }
            }
            return compileTrust(compileRangeSubnets(trust));
        }
        function compileRangeSubnets(arr) {
            var rangeSubnets = new Array(arr.length);
            for(var i = 0; i < arr.length; i++)rangeSubnets[i] = parseipNotation(arr[i]);
            return rangeSubnets;
        }
        function compileTrust(rangeSubnets) {
            var len = rangeSubnets.length;
            return 0 === len ? trustNone : 1 === len ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
        }
        function parseipNotation(note) {
            var pos = note.lastIndexOf('/');
            var str = -1 !== pos ? note.substring(0, pos) : note;
            if (!isip(str)) throw new TypeError('invalid IP address: ' + str);
            var ip = parseip(str);
            if (-1 === pos && 'ipv6' === ip.kind() && ip.isIPv4MappedAddress()) ip = ip.toIPv4Address();
            var max = 'ipv6' === ip.kind() ? 128 : 32;
            var range = -1 !== pos ? note.substring(pos + 1, note.length) : null;
            range = null === range ? max : DIGIT_REGEXP.test(range) ? parseInt(range, 10) : 'ipv4' === ip.kind() && isip(range) ? parseNetmask(range) : null;
            if (range <= 0 || range > max) throw new TypeError('invalid range on address: ' + note);
            return [
                ip,
                range
            ];
        }
        function parseNetmask(netmask) {
            var ip = parseip(netmask);
            var kind = ip.kind();
            return 'ipv4' === kind ? ip.prefixLengthFromSubnetMask() : null;
        }
        function proxyaddr(req, trust) {
            if (!req) throw new TypeError('req argument is required');
            if (!trust) throw new TypeError('trust argument is required');
            var addrs = alladdrs(req, trust);
            var addr = addrs[addrs.length - 1];
            return addr;
        }
        function trustNone() {
            return false;
        }
        function trustMulti(subnets) {
            return function(addr) {
                if (!isip(addr)) return false;
                var ip = parseip(addr);
                var ipconv;
                var kind = ip.kind();
                for(var i = 0; i < subnets.length; i++){
                    var subnet = subnets[i];
                    var subnetip = subnet[0];
                    var subnetkind = subnetip.kind();
                    var subnetrange = subnet[1];
                    var trusted = ip;
                    if (kind !== subnetkind) {
                        if ('ipv4' === subnetkind && !ip.isIPv4MappedAddress()) continue;
                        if (!ipconv) ipconv = 'ipv4' === subnetkind ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
                        trusted = ipconv;
                    }
                    if (trusted.match(subnetip, subnetrange)) return true;
                }
                return false;
            };
        }
        function trustSingle(subnet) {
            var subnetip = subnet[0];
            var subnetkind = subnetip.kind();
            var subnetisipv4 = 'ipv4' === subnetkind;
            var subnetrange = subnet[1];
            return function(addr) {
                if (!isip(addr)) return false;
                var ip = parseip(addr);
                var kind = ip.kind();
                if (kind !== subnetkind) {
                    if (subnetisipv4 && !ip.isIPv4MappedAddress()) return false;
                    ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
                }
                return ip.match(subnetip, subnetrange);
            };
        }
    },
    "../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/formats.js": function(module) {
        "use strict";
        var replace = String.prototype.replace;
        var percentTwenties = /%20/g;
        var Format = {
            RFC1738: 'RFC1738',
            RFC3986: 'RFC3986'
        };
        module.exports = {
            default: Format.RFC3986,
            formatters: {
                RFC1738: function(value) {
                    return replace.call(value, percentTwenties, '+');
                },
                RFC3986: function(value) {
                    return String(value);
                }
            },
            RFC1738: Format.RFC1738,
            RFC3986: Format.RFC3986
        };
    },
    "../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var stringify = __webpack_require__("../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/stringify.js");
        var parse = __webpack_require__("../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/parse.js");
        var formats = __webpack_require__("../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/formats.js");
        module.exports = {
            formats: formats,
            parse: parse,
            stringify: stringify
        };
    },
    "../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/parse.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var utils = __webpack_require__("../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/utils.js");
        var has = Object.prototype.hasOwnProperty;
        var isArray = Array.isArray;
        var defaults = {
            allowDots: false,
            allowEmptyArrays: false,
            allowPrototypes: false,
            allowSparse: false,
            arrayLimit: 20,
            charset: 'utf-8',
            charsetSentinel: false,
            comma: false,
            decodeDotInKeys: false,
            decoder: utils.decode,
            delimiter: '&',
            depth: 5,
            duplicates: 'combine',
            ignoreQueryPrefix: false,
            interpretNumericEntities: false,
            parameterLimit: 1000,
            parseArrays: true,
            plainObjects: false,
            strictDepth: false,
            strictNullHandling: false
        };
        var interpretNumericEntities = function(str) {
            return str.replace(/&#(\d+);/g, function($0, numberStr) {
                return String.fromCharCode(parseInt(numberStr, 10));
            });
        };
        var parseArrayValue = function(val, options) {
            if (val && 'string' == typeof val && options.comma && val.indexOf(',') > -1) return val.split(',');
            return val;
        };
        var isoSentinel = 'utf8=%26%2310003%3B';
        var charsetSentinel = 'utf8=%E2%9C%93';
        var parseValues = function(str, options) {
            var obj = {
                __proto__: null
            };
            var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
            cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');
            var limit = options.parameterLimit === 1 / 0 ? void 0 : options.parameterLimit;
            var parts = cleanStr.split(options.delimiter, limit);
            var skipIndex = -1;
            var i;
            var charset = options.charset;
            if (options.charsetSentinel) {
                for(i = 0; i < parts.length; ++i)if (0 === parts[i].indexOf('utf8=')) {
                    if (parts[i] === charsetSentinel) charset = 'utf-8';
                    else if (parts[i] === isoSentinel) charset = 'iso-8859-1';
                    skipIndex = i;
                    i = parts.length;
                }
            }
            for(i = 0; i < parts.length; ++i)if (i !== skipIndex) {
                var part = parts[i];
                var bracketEqualsPos = part.indexOf(']=');
                var pos = -1 === bracketEqualsPos ? part.indexOf('=') : bracketEqualsPos + 1;
                var key, val;
                if (-1 === pos) {
                    key = options.decoder(part, defaults.decoder, charset, 'key');
                    val = options.strictNullHandling ? null : '';
                } else {
                    key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
                    val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
                        return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                    });
                }
                if (val && options.interpretNumericEntities && 'iso-8859-1' === charset) val = interpretNumericEntities(val);
                if (part.indexOf('[]=') > -1) val = isArray(val) ? [
                    val
                ] : val;
                var existing = has.call(obj, key);
                if (existing && 'combine' === options.duplicates) obj[key] = utils.combine(obj[key], val);
                else if (!existing || 'last' === options.duplicates) obj[key] = val;
            }
            return obj;
        };
        var parseObject = function(chain, val, options, valuesParsed) {
            var leaf = valuesParsed ? val : parseArrayValue(val, options);
            for(var i = chain.length - 1; i >= 0; --i){
                var obj;
                var root = chain[i];
                if ('[]' === root && options.parseArrays) obj = options.allowEmptyArrays && ('' === leaf || options.strictNullHandling && null === leaf) ? [] : [].concat(leaf);
                else {
                    obj = options.plainObjects ? Object.create(null) : {};
                    var cleanRoot = '[' === root.charAt(0) && ']' === root.charAt(root.length - 1) ? root.slice(1, -1) : root;
                    var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
                    var index = parseInt(decodedRoot, 10);
                    if (options.parseArrays || '' !== decodedRoot) {
                        if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
                            obj = [];
                            obj[index] = leaf;
                        } else if ('__proto__' !== decodedRoot) obj[decodedRoot] = leaf;
                    } else obj = {
                        0: leaf
                    };
                }
                leaf = obj;
            }
            return leaf;
        };
        var parseKeys = function(givenKey, val, options, valuesParsed) {
            if (!givenKey) return;
            var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;
            var brackets = /(\[[^[\]]*])/;
            var child = /(\[[^[\]]*])/g;
            var segment = options.depth > 0 && brackets.exec(key);
            var parent = segment ? key.slice(0, segment.index) : key;
            var keys = [];
            if (parent) {
                if (!options.plainObjects && has.call(Object.prototype, parent)) {
                    if (!options.allowPrototypes) return;
                }
                keys.push(parent);
            }
            var i = 0;
            while(options.depth > 0 && null !== (segment = child.exec(key)) && i < options.depth){
                i += 1;
                if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
                    if (!options.allowPrototypes) return;
                }
                keys.push(segment[1]);
            }
            if (segment) {
                if (true === options.strictDepth) throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
                keys.push('[' + key.slice(segment.index) + ']');
            }
            return parseObject(keys, val, options, valuesParsed);
        };
        var normalizeParseOptions = function(opts) {
            if (!opts) return defaults;
            if (void 0 !== opts.allowEmptyArrays && 'boolean' != typeof opts.allowEmptyArrays) throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
            if (void 0 !== opts.decodeDotInKeys && 'boolean' != typeof opts.decodeDotInKeys) throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
            if (null !== opts.decoder && void 0 !== opts.decoder && 'function' != typeof opts.decoder) throw new TypeError('Decoder has to be a function.');
            if (void 0 !== opts.charset && 'utf-8' !== opts.charset && 'iso-8859-1' !== opts.charset) throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
            var charset = void 0 === opts.charset ? defaults.charset : opts.charset;
            var duplicates = void 0 === opts.duplicates ? defaults.duplicates : opts.duplicates;
            if ('combine' !== duplicates && 'first' !== duplicates && 'last' !== duplicates) throw new TypeError('The duplicates option must be either combine, first, or last');
            var allowDots = void 0 === opts.allowDots ? true === opts.decodeDotInKeys ? true : defaults.allowDots : !!opts.allowDots;
            return {
                allowDots: allowDots,
                allowEmptyArrays: 'boolean' == typeof opts.allowEmptyArrays ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
                allowPrototypes: 'boolean' == typeof opts.allowPrototypes ? opts.allowPrototypes : defaults.allowPrototypes,
                allowSparse: 'boolean' == typeof opts.allowSparse ? opts.allowSparse : defaults.allowSparse,
                arrayLimit: 'number' == typeof opts.arrayLimit ? opts.arrayLimit : defaults.arrayLimit,
                charset: charset,
                charsetSentinel: 'boolean' == typeof opts.charsetSentinel ? opts.charsetSentinel : defaults.charsetSentinel,
                comma: 'boolean' == typeof opts.comma ? opts.comma : defaults.comma,
                decodeDotInKeys: 'boolean' == typeof opts.decodeDotInKeys ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
                decoder: 'function' == typeof opts.decoder ? opts.decoder : defaults.decoder,
                delimiter: 'string' == typeof opts.delimiter || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
                depth: 'number' == typeof opts.depth || false === opts.depth ? +opts.depth : defaults.depth,
                duplicates: duplicates,
                ignoreQueryPrefix: true === opts.ignoreQueryPrefix,
                interpretNumericEntities: 'boolean' == typeof opts.interpretNumericEntities ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
                parameterLimit: 'number' == typeof opts.parameterLimit ? opts.parameterLimit : defaults.parameterLimit,
                parseArrays: false !== opts.parseArrays,
                plainObjects: 'boolean' == typeof opts.plainObjects ? opts.plainObjects : defaults.plainObjects,
                strictDepth: 'boolean' == typeof opts.strictDepth ? !!opts.strictDepth : defaults.strictDepth,
                strictNullHandling: 'boolean' == typeof opts.strictNullHandling ? opts.strictNullHandling : defaults.strictNullHandling
            };
        };
        module.exports = function(str, opts) {
            var options = normalizeParseOptions(opts);
            if ('' === str || null == str) return options.plainObjects ? Object.create(null) : {};
            var tempObj = 'string' == typeof str ? parseValues(str, options) : str;
            var obj = options.plainObjects ? Object.create(null) : {};
            var keys = Object.keys(tempObj);
            for(var i = 0; i < keys.length; ++i){
                var key = keys[i];
                var newObj = parseKeys(key, tempObj[key], options, 'string' == typeof str);
                obj = utils.merge(obj, newObj, options);
            }
            if (true === options.allowSparse) return obj;
            return utils.compact(obj);
        };
    },
    "../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/stringify.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var getSideChannel = __webpack_require__("../node_modules/.pnpm/side-channel@1.1.0/node_modules/side-channel/index.js");
        var utils = __webpack_require__("../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/utils.js");
        var formats = __webpack_require__("../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/formats.js");
        var has = Object.prototype.hasOwnProperty;
        var arrayPrefixGenerators = {
            brackets: function(prefix) {
                return prefix + '[]';
            },
            comma: 'comma',
            indices: function(prefix, key) {
                return prefix + '[' + key + ']';
            },
            repeat: function(prefix) {
                return prefix;
            }
        };
        var isArray = Array.isArray;
        var push = Array.prototype.push;
        var pushToArray = function(arr, valueOrArray) {
            push.apply(arr, isArray(valueOrArray) ? valueOrArray : [
                valueOrArray
            ]);
        };
        var toISO = Date.prototype.toISOString;
        var defaultFormat = formats['default'];
        var defaults = {
            addQueryPrefix: false,
            allowDots: false,
            allowEmptyArrays: false,
            arrayFormat: 'indices',
            charset: 'utf-8',
            charsetSentinel: false,
            delimiter: '&',
            encode: true,
            encodeDotInKeys: false,
            encoder: utils.encode,
            encodeValuesOnly: false,
            format: defaultFormat,
            formatter: formats.formatters[defaultFormat],
            indices: false,
            serializeDate: function(date) {
                return toISO.call(date);
            },
            skipNulls: false,
            strictNullHandling: false
        };
        var isNonNullishPrimitive = function(v) {
            return 'string' == typeof v || 'number' == typeof v || 'boolean' == typeof v || 'symbol' == typeof v || 'bigint' == typeof v;
        };
        var sentinel = {};
        var stringify = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
            var obj = object;
            var tmpSc = sideChannel;
            var step = 0;
            var findFlag = false;
            while(void 0 !== (tmpSc = tmpSc.get(sentinel)) && !findFlag){
                var pos = tmpSc.get(object);
                step += 1;
                if (void 0 !== pos) if (pos === step) throw new RangeError('Cyclic object value');
                else findFlag = true;
                if (void 0 === tmpSc.get(sentinel)) step = 0;
            }
            if ('function' == typeof filter) obj = filter(prefix, obj);
            else if (obj instanceof Date) obj = serializeDate(obj);
            else if ('comma' === generateArrayPrefix && isArray(obj)) obj = utils.maybeMap(obj, function(value) {
                if (value instanceof Date) return serializeDate(value);
                return value;
            });
            if (null === obj) {
                if (strictNullHandling) return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
                obj = '';
            }
            if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
                if (encoder) {
                    var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
                    return [
                        formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))
                    ];
                }
                return [
                    formatter(prefix) + '=' + formatter(String(obj))
                ];
            }
            var values = [];
            if (void 0 === obj) return values;
            var objKeys;
            if ('comma' === generateArrayPrefix && isArray(obj)) {
                if (encodeValuesOnly && encoder) obj = utils.maybeMap(obj, encoder);
                objKeys = [
                    {
                        value: obj.length > 0 ? obj.join(',') || null : void 0
                    }
                ];
            } else if (isArray(filter)) objKeys = filter;
            else {
                var keys = Object.keys(obj);
                objKeys = sort ? keys.sort(sort) : keys;
            }
            var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, '%2E') : prefix;
            var adjustedPrefix = commaRoundTrip && isArray(obj) && 1 === obj.length ? encodedPrefix + '[]' : encodedPrefix;
            if (allowEmptyArrays && isArray(obj) && 0 === obj.length) return adjustedPrefix + '[]';
            for(var j = 0; j < objKeys.length; ++j){
                var key = objKeys[j];
                var value = 'object' == typeof key && void 0 !== key.value ? key.value : obj[key];
                if (!skipNulls || null !== value) {
                    var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, '%2E') : key;
                    var keyPrefix = isArray(obj) ? 'function' == typeof generateArrayPrefix ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');
                    sideChannel.set(object, step);
                    var valueSideChannel = getSideChannel();
                    valueSideChannel.set(sentinel, sideChannel);
                    pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, 'comma' === generateArrayPrefix && encodeValuesOnly && isArray(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
                }
            }
            return values;
        };
        var normalizeStringifyOptions = function(opts) {
            if (!opts) return defaults;
            if (void 0 !== opts.allowEmptyArrays && 'boolean' != typeof opts.allowEmptyArrays) throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
            if (void 0 !== opts.encodeDotInKeys && 'boolean' != typeof opts.encodeDotInKeys) throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
            if (null !== opts.encoder && void 0 !== opts.encoder && 'function' != typeof opts.encoder) throw new TypeError('Encoder has to be a function.');
            var charset = opts.charset || defaults.charset;
            if (void 0 !== opts.charset && 'utf-8' !== opts.charset && 'iso-8859-1' !== opts.charset) throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
            var format = formats['default'];
            if (void 0 !== opts.format) {
                if (!has.call(formats.formatters, opts.format)) throw new TypeError('Unknown format option provided.');
                format = opts.format;
            }
            var formatter = formats.formatters[format];
            var filter = defaults.filter;
            if ('function' == typeof opts.filter || isArray(opts.filter)) filter = opts.filter;
            var arrayFormat;
            arrayFormat = opts.arrayFormat in arrayPrefixGenerators ? opts.arrayFormat : 'indices' in opts ? opts.indices ? 'indices' : 'repeat' : defaults.arrayFormat;
            if ('commaRoundTrip' in opts && 'boolean' != typeof opts.commaRoundTrip) throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
            var allowDots = void 0 === opts.allowDots ? true === opts.encodeDotInKeys ? true : defaults.allowDots : !!opts.allowDots;
            return {
                addQueryPrefix: 'boolean' == typeof opts.addQueryPrefix ? opts.addQueryPrefix : defaults.addQueryPrefix,
                allowDots: allowDots,
                allowEmptyArrays: 'boolean' == typeof opts.allowEmptyArrays ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
                arrayFormat: arrayFormat,
                charset: charset,
                charsetSentinel: 'boolean' == typeof opts.charsetSentinel ? opts.charsetSentinel : defaults.charsetSentinel,
                commaRoundTrip: opts.commaRoundTrip,
                delimiter: void 0 === opts.delimiter ? defaults.delimiter : opts.delimiter,
                encode: 'boolean' == typeof opts.encode ? opts.encode : defaults.encode,
                encodeDotInKeys: 'boolean' == typeof opts.encodeDotInKeys ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
                encoder: 'function' == typeof opts.encoder ? opts.encoder : defaults.encoder,
                encodeValuesOnly: 'boolean' == typeof opts.encodeValuesOnly ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
                filter: filter,
                format: format,
                formatter: formatter,
                serializeDate: 'function' == typeof opts.serializeDate ? opts.serializeDate : defaults.serializeDate,
                skipNulls: 'boolean' == typeof opts.skipNulls ? opts.skipNulls : defaults.skipNulls,
                sort: 'function' == typeof opts.sort ? opts.sort : null,
                strictNullHandling: 'boolean' == typeof opts.strictNullHandling ? opts.strictNullHandling : defaults.strictNullHandling
            };
        };
        module.exports = function(object, opts) {
            var obj = object;
            var options = normalizeStringifyOptions(opts);
            var objKeys;
            var filter;
            if ('function' == typeof options.filter) {
                filter = options.filter;
                obj = filter('', obj);
            } else if (isArray(options.filter)) {
                filter = options.filter;
                objKeys = filter;
            }
            var keys = [];
            if ('object' != typeof obj || null === obj) return '';
            var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
            var commaRoundTrip = 'comma' === generateArrayPrefix && options.commaRoundTrip;
            if (!objKeys) objKeys = Object.keys(obj);
            if (options.sort) objKeys.sort(options.sort);
            var sideChannel = getSideChannel();
            for(var i = 0; i < objKeys.length; ++i){
                var key = objKeys[i];
                if (!options.skipNulls || null !== obj[key]) pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
            }
            var joined = keys.join(options.delimiter);
            var prefix = true === options.addQueryPrefix ? '?' : '';
            if (options.charsetSentinel) if ('iso-8859-1' === options.charset) prefix += 'utf8=%26%2310003%3B&';
            else prefix += 'utf8=%E2%9C%93&';
            return joined.length > 0 ? prefix + joined : '';
        };
    },
    "../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/utils.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var formats = __webpack_require__("../node_modules/.pnpm/qs@6.13.0/node_modules/qs/lib/formats.js");
        var has = Object.prototype.hasOwnProperty;
        var isArray = Array.isArray;
        var hexTable = function() {
            var array = [];
            for(var i = 0; i < 256; ++i)array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
            return array;
        }();
        var compactQueue = function(queue) {
            while(queue.length > 1){
                var item = queue.pop();
                var obj = item.obj[item.prop];
                if (isArray(obj)) {
                    var compacted = [];
                    for(var j = 0; j < obj.length; ++j)if (void 0 !== obj[j]) compacted.push(obj[j]);
                    item.obj[item.prop] = compacted;
                }
            }
        };
        var arrayToObject = function(source, options) {
            var obj = options && options.plainObjects ? Object.create(null) : {};
            for(var i = 0; i < source.length; ++i)if (void 0 !== source[i]) obj[i] = source[i];
            return obj;
        };
        var merge = function merge(target, source, options) {
            if (!source) return target;
            if ('object' != typeof source) {
                if (isArray(target)) target.push(source);
                else if (!target || 'object' != typeof target) return [
                    target,
                    source
                ];
                else if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) target[source] = true;
                return target;
            }
            if (!target || 'object' != typeof target) return [
                target
            ].concat(source);
            var mergeTarget = target;
            if (isArray(target) && !isArray(source)) mergeTarget = arrayToObject(target, options);
            if (isArray(target) && isArray(source)) {
                source.forEach(function(item, i) {
                    if (has.call(target, i)) {
                        var targetItem = target[i];
                        if (targetItem && 'object' == typeof targetItem && item && 'object' == typeof item) target[i] = merge(targetItem, item, options);
                        else target.push(item);
                    } else target[i] = item;
                });
                return target;
            }
            return Object.keys(source).reduce(function(acc, key) {
                var value = source[key];
                if (has.call(acc, key)) acc[key] = merge(acc[key], value, options);
                else acc[key] = value;
                return acc;
            }, mergeTarget);
        };
        var assign = function(target, source) {
            return Object.keys(source).reduce(function(acc, key) {
                acc[key] = source[key];
                return acc;
            }, target);
        };
        var decode = function(str, decoder, charset) {
            var strWithoutPlus = str.replace(/\+/g, ' ');
            if ('iso-8859-1' === charset) return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
            try {
                return decodeURIComponent(strWithoutPlus);
            } catch (e) {
                return strWithoutPlus;
            }
        };
        var limit = 1024;
        var encode = function(str, defaultEncoder, charset, kind, format) {
            if (0 === str.length) return str;
            var string = str;
            if ('symbol' == typeof str) string = Symbol.prototype.toString.call(str);
            else if ('string' != typeof str) string = String(str);
            if ('iso-8859-1' === charset) return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
                return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
            });
            var out = '';
            for(var j = 0; j < string.length; j += limit){
                var segment = string.length >= limit ? string.slice(j, j + limit) : string;
                var arr = [];
                for(var i = 0; i < segment.length; ++i){
                    var c = segment.charCodeAt(i);
                    if (0x2D === c || 0x2E === c || 0x5F === c || 0x7E === c || c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A || format === formats.RFC1738 && (0x28 === c || 0x29 === c)) {
                        arr[arr.length] = segment.charAt(i);
                        continue;
                    }
                    if (c < 0x80) {
                        arr[arr.length] = hexTable[c];
                        continue;
                    }
                    if (c < 0x800) {
                        arr[arr.length] = hexTable[0xC0 | c >> 6] + hexTable[0x80 | 0x3F & c];
                        continue;
                    }
                    if (c < 0xD800 || c >= 0xE000) {
                        arr[arr.length] = hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | 0x3F & c];
                        continue;
                    }
                    i += 1;
                    c = 0x10000 + ((0x3FF & c) << 10 | 0x3FF & segment.charCodeAt(i));
                    arr[arr.length] = hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | 0x3F & c];
                }
                out += arr.join('');
            }
            return out;
        };
        var compact = function(value) {
            var queue = [
                {
                    obj: {
                        o: value
                    },
                    prop: 'o'
                }
            ];
            var refs = [];
            for(var i = 0; i < queue.length; ++i){
                var item = queue[i];
                var obj = item.obj[item.prop];
                var keys = Object.keys(obj);
                for(var j = 0; j < keys.length; ++j){
                    var key = keys[j];
                    var val = obj[key];
                    if ('object' == typeof val && null !== val && -1 === refs.indexOf(val)) {
                        queue.push({
                            obj: obj,
                            prop: key
                        });
                        refs.push(val);
                    }
                }
            }
            compactQueue(queue);
            return value;
        };
        var isRegExp = function(obj) {
            return '[object RegExp]' === Object.prototype.toString.call(obj);
        };
        var isBuffer = function(obj) {
            if (!obj || 'object' != typeof obj) return false;
            return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
        };
        var combine = function(a, b) {
            return [].concat(a, b);
        };
        var maybeMap = function(val, fn) {
            if (isArray(val)) {
                var mapped = [];
                for(var i = 0; i < val.length; i += 1)mapped.push(fn(val[i]));
                return mapped;
            }
            return fn(val);
        };
        module.exports = {
            arrayToObject: arrayToObject,
            assign: assign,
            combine: combine,
            compact: compact,
            decode: decode,
            encode: encode,
            isBuffer: isBuffer,
            isRegExp: isRegExp,
            maybeMap: maybeMap,
            merge: merge
        };
    },
    "../node_modules/.pnpm/range-parser@1.2.1/node_modules/range-parser/index.js": function(module) {
        "use strict";
        /*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = rangeParser;
        function rangeParser(size, str, options) {
            if ('string' != typeof str) throw new TypeError('argument str must be a string');
            var index = str.indexOf('=');
            if (-1 === index) return -2;
            var arr = str.slice(index + 1).split(',');
            var ranges = [];
            ranges.type = str.slice(0, index);
            for(var i = 0; i < arr.length; i++){
                var range = arr[i].split('-');
                var start = parseInt(range[0], 10);
                var end = parseInt(range[1], 10);
                if (isNaN(start)) {
                    start = size - end;
                    end = size - 1;
                } else if (isNaN(end)) end = size - 1;
                if (end > size - 1) end = size - 1;
                if (!(isNaN(start) || isNaN(end)) && !(start > end) && !(start < 0)) ranges.push({
                    start: start,
                    end: end
                });
            }
            if (ranges.length < 1) return -1;
            return options && options.combine ? combineRanges(ranges) : ranges;
        }
        function combineRanges(ranges) {
            var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
            for(var j = 0, i = 1; i < ordered.length; i++){
                var range = ordered[i];
                var current = ordered[j];
                if (range.start > current.end + 1) ordered[++j] = range;
                else if (range.end > current.end) {
                    current.end = range.end;
                    current.index = Math.min(current.index, range.index);
                }
            }
            ordered.length = j + 1;
            var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
            combined.type = ranges.type;
            return combined;
        }
        function mapWithIndex(range, index) {
            return {
                start: range.start,
                end: range.end,
                index: index
            };
        }
        function mapWithoutIndex(range) {
            return {
                start: range.start,
                end: range.end
            };
        }
        function sortByRangeIndex(a, b) {
            return a.index - b.index;
        }
        function sortByRangeStart(a, b) {
            return a.start - b.start;
        }
    },
    "../node_modules/.pnpm/raw-body@2.5.2/node_modules/raw-body/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var asyncHooks = tryRequireAsyncHooks();
        var bytes = __webpack_require__("../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js");
        var createError = __webpack_require__("../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js");
        var iconv = __webpack_require__("../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/lib/index.js");
        var unpipe = __webpack_require__("../node_modules/.pnpm/unpipe@1.0.0/node_modules/unpipe/index.js");
        module.exports = getRawBody;
        var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
        function getDecoder(encoding) {
            if (!encoding) return null;
            try {
                return iconv.getDecoder(encoding);
            } catch (e) {
                if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;
                throw createError(415, 'specified encoding unsupported', {
                    encoding: encoding,
                    type: 'encoding.unsupported'
                });
            }
        }
        function getRawBody(stream, options, callback) {
            var done = callback;
            var opts = options || {};
            if (void 0 === stream) throw new TypeError('argument stream is required');
            if ('object' != typeof stream || null === stream || 'function' != typeof stream.on) throw new TypeError('argument stream must be a stream');
            if (true === options || 'string' == typeof options) opts = {
                encoding: options
            };
            if ('function' == typeof options) {
                done = options;
                opts = {};
            }
            if (void 0 !== done && 'function' != typeof done) throw new TypeError('argument callback must be a function');
            if (!done && !global.Promise) throw new TypeError('argument callback is required');
            var encoding = true !== opts.encoding ? opts.encoding : 'utf-8';
            var limit = bytes.parse(opts.limit);
            var length = null == opts.length || isNaN(opts.length) ? null : parseInt(opts.length, 10);
            if (done) return readStream(stream, encoding, length, limit, wrap(done));
            return new Promise(function(resolve, reject) {
                readStream(stream, encoding, length, limit, function(err, buf) {
                    if (err) return reject(err);
                    resolve(buf);
                });
            });
        }
        function halt(stream) {
            unpipe(stream);
            if ('function' == typeof stream.pause) stream.pause();
        }
        function readStream(stream, encoding, length, limit, callback) {
            var complete = false;
            var sync = true;
            if (null !== limit && null !== length && length > limit) return done(createError(413, 'request entity too large', {
                expected: length,
                length: length,
                limit: limit,
                type: 'entity.too.large'
            }));
            var state = stream._readableState;
            if (stream._decoder || state && (state.encoding || state.decoder)) return done(createError(500, 'stream encoding should not be set', {
                type: 'stream.encoding.set'
            }));
            if (void 0 !== stream.readable && !stream.readable) return done(createError(500, 'stream is not readable', {
                type: 'stream.not.readable'
            }));
            var received = 0;
            var decoder;
            try {
                decoder = getDecoder(encoding);
            } catch (err) {
                return done(err);
            }
            var buffer = decoder ? '' : [];
            stream.on('aborted', onAborted);
            stream.on('close', cleanup);
            stream.on('data', onData);
            stream.on('end', onEnd);
            stream.on('error', onEnd);
            sync = false;
            function done() {
                var args = new Array(arguments.length);
                for(var i = 0; i < args.length; i++)args[i] = arguments[i];
                complete = true;
                if (sync) process.nextTick(invokeCallback);
                else invokeCallback();
                function invokeCallback() {
                    cleanup();
                    if (args[0]) halt(stream);
                    callback.apply(null, args);
                }
            }
            function onAborted() {
                if (complete) return;
                done(createError(400, 'request aborted', {
                    code: 'ECONNABORTED',
                    expected: length,
                    length: length,
                    received: received,
                    type: 'request.aborted'
                }));
            }
            function onData(chunk) {
                if (complete) return;
                received += chunk.length;
                if (null !== limit && received > limit) done(createError(413, 'request entity too large', {
                    limit: limit,
                    received: received,
                    type: 'entity.too.large'
                }));
                else if (decoder) buffer += decoder.write(chunk);
                else buffer.push(chunk);
            }
            function onEnd(err) {
                if (complete) return;
                if (err) return done(err);
                if (null !== length && received !== length) done(createError(400, 'request size did not match content length', {
                    expected: length,
                    length: length,
                    received: received,
                    type: 'request.size.invalid'
                }));
                else {
                    var string = decoder ? buffer + (decoder.end() || '') : Buffer.concat(buffer);
                    done(null, string);
                }
            }
            function cleanup() {
                buffer = null;
                stream.removeListener('aborted', onAborted);
                stream.removeListener('data', onData);
                stream.removeListener('end', onEnd);
                stream.removeListener('error', onEnd);
                stream.removeListener('close', cleanup);
            }
        }
        function tryRequireAsyncHooks() {
            try {
                return __webpack_require__("async_hooks");
            } catch (e) {
                return {};
            }
        }
        function wrap(fn) {
            var res;
            if (asyncHooks.AsyncResource) res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn');
            if (!res || !res.runInAsyncScope) return fn;
            return res.runInAsyncScope.bind(res, fn, null);
        }
    },
    "../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js": function(module, exports1, __webpack_require__) {
        /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ var buffer = __webpack_require__("buffer");
        var Buffer1 = buffer.Buffer;
        function copyProps(src, dst) {
            for(var key in src)dst[key] = src[key];
        }
        if (Buffer1.from && Buffer1.alloc && Buffer1.allocUnsafe && Buffer1.allocUnsafeSlow) module.exports = buffer;
        else {
            copyProps(buffer, exports1);
            exports1.Buffer = SafeBuffer;
        }
        function SafeBuffer(arg, encodingOrOffset, length) {
            return Buffer1(arg, encodingOrOffset, length);
        }
        SafeBuffer.prototype = Object.create(Buffer1.prototype);
        copyProps(Buffer1, SafeBuffer);
        SafeBuffer.from = function(arg, encodingOrOffset, length) {
            if ('number' == typeof arg) throw new TypeError('Argument must not be a number');
            return Buffer1(arg, encodingOrOffset, length);
        };
        SafeBuffer.alloc = function(size, fill, encoding) {
            if ('number' != typeof size) throw new TypeError('Argument must be a number');
            var buf = Buffer1(size);
            if (void 0 !== fill) if ('string' == typeof encoding) buf.fill(fill, encoding);
            else buf.fill(fill);
            else buf.fill(0);
            return buf;
        };
        SafeBuffer.allocUnsafe = function(size) {
            if ('number' != typeof size) throw new TypeError('Argument must be a number');
            return Buffer1(size);
        };
        SafeBuffer.allocUnsafeSlow = function(size) {
            if ('number' != typeof size) throw new TypeError('Argument must be a number');
            return buffer.SlowBuffer(size);
        };
    },
    "../node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var buffer = __webpack_require__("buffer");
        var Buffer1 = buffer.Buffer;
        var safer = {};
        var key;
        for(key in buffer)if (buffer.hasOwnProperty(key)) {
            if ('SlowBuffer' !== key && 'Buffer' !== key) safer[key] = buffer[key];
        }
        var Safer = safer.Buffer = {};
        for(key in Buffer1)if (Buffer1.hasOwnProperty(key)) {
            if ('allocUnsafe' !== key && 'allocUnsafeSlow' !== key) Safer[key] = Buffer1[key];
        }
        safer.Buffer.prototype = Buffer1.prototype;
        if (!Safer.from || Safer.from === Uint8Array.from) Safer.from = function(value, encodingOrOffset, length) {
            if ('number' == typeof value) throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
            if (value && void 0 === value.length) throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value);
            return Buffer1(value, encodingOrOffset, length);
        };
        if (!Safer.alloc) Safer.alloc = function(size, fill, encoding) {
            if ('number' != typeof size) throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
            if (size < 0 || size >= 2 * 1073741824) throw new RangeError('The value "' + size + '" is invalid for option "size"');
            var buf = Buffer1(size);
            if (fill && 0 !== fill.length) if ('string' == typeof encoding) buf.fill(fill, encoding);
            else buf.fill(fill);
            else buf.fill(0);
            return buf;
        };
        if (!safer.kStringMaxLength) try {
            safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
        } catch (e) {}
        if (!safer.constants) {
            safer.constants = {
                MAX_LENGTH: safer.kMaxLength
            };
            if (safer.kStringMaxLength) safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
        }
        module.exports = safer;
    },
    "../node_modules/.pnpm/send@0.19.0/node_modules/send/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var createError = __webpack_require__("../node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js");
        var debug = __webpack_require__("../node_modules/.pnpm/debug@2.6.9/node_modules/debug/src/index.js")('send');
        var deprecate = __webpack_require__("../node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js")('send');
        var destroy = __webpack_require__("../node_modules/.pnpm/destroy@1.2.0/node_modules/destroy/index.js");
        var encodeUrl = __webpack_require__("../node_modules/.pnpm/encodeurl@1.0.2/node_modules/encodeurl/index.js");
        var escapeHtml = __webpack_require__("../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js");
        var etag = __webpack_require__("../node_modules/.pnpm/etag@1.8.1/node_modules/etag/index.js");
        var fresh = __webpack_require__("../node_modules/.pnpm/fresh@0.5.2/node_modules/fresh/index.js");
        var fs = __webpack_require__("fs");
        var mime = __webpack_require__("../node_modules/.pnpm/mime@1.6.0/node_modules/mime/mime.js");
        var ms = __webpack_require__("../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js");
        var onFinished = __webpack_require__("../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js");
        var parseRange = __webpack_require__("../node_modules/.pnpm/range-parser@1.2.1/node_modules/range-parser/index.js");
        var path = __webpack_require__("path");
        var statuses = __webpack_require__("../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/index.js");
        var Stream = __webpack_require__("stream");
        var util = __webpack_require__("util");
        var extname = path.extname;
        var join = path.join;
        var normalize = path.normalize;
        var resolve = path.resolve;
        var sep = path.sep;
        var BYTES_RANGE_REGEXP = /^ *bytes=/;
        var MAX_MAXAGE = 31536000000;
        var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
        module.exports = send;
        module.exports.mime = mime;
        function send(req, path, options) {
            return new SendStream(req, path, options);
        }
        function SendStream(req, path, options) {
            Stream.call(this);
            var opts = options || {};
            this.options = opts;
            this.path = path;
            this.req = req;
            this._acceptRanges = void 0 !== opts.acceptRanges ? Boolean(opts.acceptRanges) : true;
            this._cacheControl = void 0 !== opts.cacheControl ? Boolean(opts.cacheControl) : true;
            this._etag = void 0 !== opts.etag ? Boolean(opts.etag) : true;
            this._dotfiles = void 0 !== opts.dotfiles ? opts.dotfiles : 'ignore';
            if ('ignore' !== this._dotfiles && 'allow' !== this._dotfiles && 'deny' !== this._dotfiles) throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
            this._hidden = Boolean(opts.hidden);
            if (void 0 !== opts.hidden) deprecate('hidden: use dotfiles: \'' + (this._hidden ? 'allow' : 'ignore') + '\' instead');
            if (void 0 === opts.dotfiles) this._dotfiles = void 0;
            this._extensions = void 0 !== opts.extensions ? normalizeList(opts.extensions, 'extensions option') : [];
            this._immutable = void 0 !== opts.immutable ? Boolean(opts.immutable) : false;
            this._index = void 0 !== opts.index ? normalizeList(opts.index, 'index option') : [
                'index.html'
            ];
            this._lastModified = void 0 !== opts.lastModified ? Boolean(opts.lastModified) : true;
            this._maxage = opts.maxAge || opts.maxage;
            this._maxage = 'string' == typeof this._maxage ? ms(this._maxage) : Number(this._maxage);
            this._maxage = isNaN(this._maxage) ? 0 : Math.min(Math.max(0, this._maxage), MAX_MAXAGE);
            this._root = opts.root ? resolve(opts.root) : null;
            if (!this._root && opts.from) this.from(opts.from);
        }
        util.inherits(SendStream, Stream);
        SendStream.prototype.etag = deprecate.function(function(val) {
            this._etag = Boolean(val);
            debug('etag %s', this._etag);
            return this;
        }, 'send.etag: pass etag as option');
        SendStream.prototype.hidden = deprecate.function(function(val) {
            this._hidden = Boolean(val);
            this._dotfiles = void 0;
            debug('hidden %s', this._hidden);
            return this;
        }, 'send.hidden: use dotfiles option');
        SendStream.prototype.index = deprecate.function(function(paths) {
            var index = paths ? normalizeList(paths, 'paths argument') : [];
            debug('index %o', paths);
            this._index = index;
            return this;
        }, 'send.index: pass index as option');
        SendStream.prototype.root = function(path) {
            this._root = resolve(String(path));
            debug('root %s', this._root);
            return this;
        };
        SendStream.prototype.from = deprecate.function(SendStream.prototype.root, 'send.from: pass root as option');
        SendStream.prototype.root = deprecate.function(SendStream.prototype.root, 'send.root: pass root as option');
        SendStream.prototype.maxage = deprecate.function(function(maxAge) {
            this._maxage = 'string' == typeof maxAge ? ms(maxAge) : Number(maxAge);
            this._maxage = isNaN(this._maxage) ? 0 : Math.min(Math.max(0, this._maxage), MAX_MAXAGE);
            debug('max-age %d', this._maxage);
            return this;
        }, 'send.maxage: pass maxAge as option');
        SendStream.prototype.error = function(status, err) {
            if (hasListeners(this, 'error')) return this.emit('error', createHttpError(status, err));
            var res = this.res;
            var msg = statuses.message[status] || String(status);
            var doc = createHtmlDocument('Error', escapeHtml(msg));
            clearHeaders(res);
            if (err && err.headers) setHeaders(res, err.headers);
            res.statusCode = status;
            res.setHeader('Content-Type', 'text/html; charset=UTF-8');
            res.setHeader('Content-Length', Buffer.byteLength(doc));
            res.setHeader('Content-Security-Policy', "default-src 'none'");
            res.setHeader('X-Content-Type-Options', 'nosniff');
            res.end(doc);
        };
        SendStream.prototype.hasTrailingSlash = function() {
            return '/' === this.path[this.path.length - 1];
        };
        SendStream.prototype.isConditionalGET = function() {
            return this.req.headers['if-match'] || this.req.headers['if-unmodified-since'] || this.req.headers['if-none-match'] || this.req.headers['if-modified-since'];
        };
        SendStream.prototype.isPreconditionFailure = function() {
            var req = this.req;
            var res = this.res;
            var match = req.headers['if-match'];
            if (match) {
                var etag = res.getHeader('ETag');
                return !etag || '*' !== match && parseTokenList(match).every(function(match) {
                    return match !== etag && match !== 'W/' + etag && 'W/' + match !== etag;
                });
            }
            var unmodifiedSince = parseHttpDate(req.headers['if-unmodified-since']);
            if (!isNaN(unmodifiedSince)) {
                var lastModified = parseHttpDate(res.getHeader('Last-Modified'));
                return isNaN(lastModified) || lastModified > unmodifiedSince;
            }
            return false;
        };
        SendStream.prototype.removeContentHeaderFields = function() {
            var res = this.res;
            res.removeHeader('Content-Encoding');
            res.removeHeader('Content-Language');
            res.removeHeader('Content-Length');
            res.removeHeader('Content-Range');
            res.removeHeader('Content-Type');
        };
        SendStream.prototype.notModified = function() {
            var res = this.res;
            debug('not modified');
            this.removeContentHeaderFields();
            res.statusCode = 304;
            res.end();
        };
        SendStream.prototype.headersAlreadySent = function() {
            var err = new Error('Can\'t set headers after they are sent.');
            debug('headers already sent');
            this.error(500, err);
        };
        SendStream.prototype.isCachable = function() {
            var statusCode = this.res.statusCode;
            return statusCode >= 200 && statusCode < 300 || 304 === statusCode;
        };
        SendStream.prototype.onStatError = function(error) {
            switch(error.code){
                case 'ENAMETOOLONG':
                case 'ENOENT':
                case 'ENOTDIR':
                    this.error(404, error);
                    break;
                default:
                    this.error(500, error);
                    break;
            }
        };
        SendStream.prototype.isFresh = function() {
            return fresh(this.req.headers, {
                etag: this.res.getHeader('ETag'),
                'last-modified': this.res.getHeader('Last-Modified')
            });
        };
        SendStream.prototype.isRangeFresh = function() {
            var ifRange = this.req.headers['if-range'];
            if (!ifRange) return true;
            if (-1 !== ifRange.indexOf('"')) {
                var etag = this.res.getHeader('ETag');
                return Boolean(etag && -1 !== ifRange.indexOf(etag));
            }
            var lastModified = this.res.getHeader('Last-Modified');
            return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
        };
        SendStream.prototype.redirect = function(path) {
            var res = this.res;
            if (hasListeners(this, 'directory')) return void this.emit('directory', res, path);
            if (this.hasTrailingSlash()) return void this.error(403);
            var loc = encodeUrl(collapseLeadingSlashes(this.path + '/'));
            var doc = createHtmlDocument('Redirecting', 'Redirecting to ' + escapeHtml(loc));
            res.statusCode = 301;
            res.setHeader('Content-Type', 'text/html; charset=UTF-8');
            res.setHeader('Content-Length', Buffer.byteLength(doc));
            res.setHeader('Content-Security-Policy', "default-src 'none'");
            res.setHeader('X-Content-Type-Options', 'nosniff');
            res.setHeader('Location', loc);
            res.end(doc);
        };
        SendStream.prototype.pipe = function(res) {
            var root = this._root;
            this.res = res;
            var path = decode(this.path);
            if (-1 === path) {
                this.error(400);
                return res;
            }
            if (~path.indexOf('\0')) {
                this.error(400);
                return res;
            }
            var parts;
            if (null !== root) {
                if (path) path = normalize('.' + sep + path);
                if (UP_PATH_REGEXP.test(path)) {
                    debug('malicious path "%s"', path);
                    this.error(403);
                    return res;
                }
                parts = path.split(sep);
                path = normalize(join(root, path));
            } else {
                if (UP_PATH_REGEXP.test(path)) {
                    debug('malicious path "%s"', path);
                    this.error(403);
                    return res;
                }
                parts = normalize(path).split(sep);
                path = resolve(path);
            }
            if (containsDotFile(parts)) {
                var access = this._dotfiles;
                if (void 0 === access) access = '.' === parts[parts.length - 1][0] ? this._hidden ? 'allow' : 'ignore' : 'allow';
                debug('%s dotfile "%s"', access, path);
                switch(access){
                    case 'allow':
                        break;
                    case 'deny':
                        this.error(403);
                        return res;
                    case 'ignore':
                    default:
                        this.error(404);
                        return res;
                }
            }
            if (this._index.length && this.hasTrailingSlash()) {
                this.sendIndex(path);
                return res;
            }
            this.sendFile(path);
            return res;
        };
        SendStream.prototype.send = function(path, stat) {
            var len = stat.size;
            var options = this.options;
            var opts = {};
            var res = this.res;
            var req = this.req;
            var ranges = req.headers.range;
            var offset = options.start || 0;
            if (headersSent(res)) return void this.headersAlreadySent();
            debug('pipe "%s"', path);
            this.setHeader(path, stat);
            this.type(path);
            if (this.isConditionalGET()) {
                if (this.isPreconditionFailure()) return void this.error(412);
                if (this.isCachable() && this.isFresh()) return void this.notModified();
            }
            len = Math.max(0, len - offset);
            if (void 0 !== options.end) {
                var bytes = options.end - offset + 1;
                if (len > bytes) len = bytes;
            }
            if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
                ranges = parseRange(len, ranges, {
                    combine: true
                });
                if (!this.isRangeFresh()) {
                    debug('range stale');
                    ranges = -2;
                }
                if (-1 === ranges) {
                    debug('range unsatisfiable');
                    res.setHeader('Content-Range', contentRange('bytes', len));
                    return this.error(416, {
                        headers: {
                            'Content-Range': res.getHeader('Content-Range')
                        }
                    });
                }
                if (-2 !== ranges && 1 === ranges.length) {
                    debug('range %j', ranges);
                    res.statusCode = 206;
                    res.setHeader('Content-Range', contentRange('bytes', len, ranges[0]));
                    offset += ranges[0].start;
                    len = ranges[0].end - ranges[0].start + 1;
                }
            }
            for(var prop in options)opts[prop] = options[prop];
            opts.start = offset;
            opts.end = Math.max(offset, offset + len - 1);
            res.setHeader('Content-Length', len);
            if ('HEAD' === req.method) return void res.end();
            this.stream(path, opts);
        };
        SendStream.prototype.sendFile = function(path) {
            var i = 0;
            var self = this;
            debug('stat "%s"', path);
            fs.stat(path, function(err, stat) {
                if (err && 'ENOENT' === err.code && !extname(path) && path[path.length - 1] !== sep) return next(err);
                if (err) return self.onStatError(err);
                if (stat.isDirectory()) return self.redirect(path);
                self.emit('file', path, stat);
                self.send(path, stat);
            });
            function next(err) {
                if (self._extensions.length <= i) return err ? self.onStatError(err) : self.error(404);
                var p = path + '.' + self._extensions[i++];
                debug('stat "%s"', p);
                fs.stat(p, function(err, stat) {
                    if (err) return next(err);
                    if (stat.isDirectory()) return next();
                    self.emit('file', p, stat);
                    self.send(p, stat);
                });
            }
        };
        SendStream.prototype.sendIndex = function(path) {
            var i = -1;
            var self = this;
            function next(err) {
                if (++i >= self._index.length) {
                    if (err) return self.onStatError(err);
                    return self.error(404);
                }
                var p = join(path, self._index[i]);
                debug('stat "%s"', p);
                fs.stat(p, function(err, stat) {
                    if (err) return next(err);
                    if (stat.isDirectory()) return next();
                    self.emit('file', p, stat);
                    self.send(p, stat);
                });
            }
            next();
        };
        SendStream.prototype.stream = function(path, options) {
            var self = this;
            var res = this.res;
            var stream = fs.createReadStream(path, options);
            this.emit('stream', stream);
            stream.pipe(res);
            function cleanup() {
                destroy(stream, true);
            }
            onFinished(res, cleanup);
            stream.on('error', function(err) {
                cleanup();
                self.onStatError(err);
            });
            stream.on('end', function() {
                self.emit('end');
            });
        };
        SendStream.prototype.type = function(path) {
            var res = this.res;
            if (res.getHeader('Content-Type')) return;
            var type = mime.lookup(path);
            if (!type) return void debug('no content-type');
            var charset = mime.charsets.lookup(type);
            debug('content-type %s', type);
            res.setHeader('Content-Type', type + (charset ? '; charset=' + charset : ''));
        };
        SendStream.prototype.setHeader = function(path, stat) {
            var res = this.res;
            this.emit('headers', res, path, stat);
            if (this._acceptRanges && !res.getHeader('Accept-Ranges')) {
                debug('accept ranges');
                res.setHeader('Accept-Ranges', 'bytes');
            }
            if (this._cacheControl && !res.getHeader('Cache-Control')) {
                var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000);
                if (this._immutable) cacheControl += ', immutable';
                debug('cache-control %s', cacheControl);
                res.setHeader('Cache-Control', cacheControl);
            }
            if (this._lastModified && !res.getHeader('Last-Modified')) {
                var modified = stat.mtime.toUTCString();
                debug('modified %s', modified);
                res.setHeader('Last-Modified', modified);
            }
            if (this._etag && !res.getHeader('ETag')) {
                var val = etag(stat);
                debug('etag %s', val);
                res.setHeader('ETag', val);
            }
        };
        function clearHeaders(res) {
            var headers = getHeaderNames(res);
            for(var i = 0; i < headers.length; i++)res.removeHeader(headers[i]);
        }
        function collapseLeadingSlashes(str) {
            for(var i = 0; i < str.length && '/' === str[i]; i++);
            return i > 1 ? '/' + str.substr(i) : str;
        }
        function containsDotFile(parts) {
            for(var i = 0; i < parts.length; i++){
                var part = parts[i];
                if (part.length > 1 && '.' === part[0]) return true;
            }
            return false;
        }
        function contentRange(type, size, range) {
            return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size;
        }
        function createHtmlDocument(title, body) {
            return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
        }
        function createHttpError(status, err) {
            if (!err) return createError(status);
            return err instanceof Error ? createError(status, err, {
                expose: false
            }) : createError(status, err);
        }
        function decode(path) {
            try {
                return decodeURIComponent(path);
            } catch (err) {
                return -1;
            }
        }
        function getHeaderNames(res) {
            return 'function' != typeof res.getHeaderNames ? Object.keys(res._headers || {}) : res.getHeaderNames();
        }
        function hasListeners(emitter, type) {
            var count = 'function' != typeof emitter.listenerCount ? emitter.listeners(type).length : emitter.listenerCount(type);
            return count > 0;
        }
        function headersSent(res) {
            return 'boolean' != typeof res.headersSent ? Boolean(res._header) : res.headersSent;
        }
        function normalizeList(val, name) {
            var list = [].concat(val || []);
            for(var i = 0; i < list.length; i++)if ('string' != typeof list[i]) throw new TypeError(name + ' must be array of strings or false');
            return list;
        }
        function parseHttpDate(date) {
            var timestamp = date && Date.parse(date);
            return 'number' == typeof timestamp ? timestamp : NaN;
        }
        function parseTokenList(str) {
            var end = 0;
            var list = [];
            var start = 0;
            for(var i = 0, len = str.length; i < len; i++)switch(str.charCodeAt(i)){
                case 0x20:
                    if (start === end) start = end = i + 1;
                    break;
                case 0x2c:
                    if (start !== end) list.push(str.substring(start, end));
                    start = end = i + 1;
                    break;
                default:
                    end = i + 1;
                    break;
            }
            if (start !== end) list.push(str.substring(start, end));
            return list;
        }
        function setHeaders(res, headers) {
            var keys = Object.keys(headers);
            for(var i = 0; i < keys.length; i++){
                var key = keys[i];
                res.setHeader(key, headers[key]);
            }
        }
    },
    "../node_modules/.pnpm/serve-static@1.16.2/node_modules/serve-static/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var encodeUrl = __webpack_require__("../node_modules/.pnpm/encodeurl@2.0.0/node_modules/encodeurl/index.js");
        var escapeHtml = __webpack_require__("../node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js");
        var parseUrl = __webpack_require__("../node_modules/.pnpm/parseurl@1.3.3/node_modules/parseurl/index.js");
        var resolve = __webpack_require__("path").resolve;
        var send = __webpack_require__("../node_modules/.pnpm/send@0.19.0/node_modules/send/index.js");
        var url = __webpack_require__("url");
        module.exports = serveStatic;
        module.exports.mime = send.mime;
        function serveStatic(root, options) {
            if (!root) throw new TypeError('root path required');
            if ('string' != typeof root) throw new TypeError('root path must be a string');
            var opts = Object.create(options || null);
            var fallthrough = false !== opts.fallthrough;
            var redirect = false !== opts.redirect;
            var setHeaders = opts.setHeaders;
            if (setHeaders && 'function' != typeof setHeaders) throw new TypeError('option setHeaders must be function');
            opts.maxage = opts.maxage || opts.maxAge || 0;
            opts.root = resolve(root);
            var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
            return function(req, res, next) {
                if ('GET' !== req.method && 'HEAD' !== req.method) {
                    if (fallthrough) return next();
                    res.statusCode = 405;
                    res.setHeader('Allow', 'GET, HEAD');
                    res.setHeader('Content-Length', '0');
                    res.end();
                    return;
                }
                var forwardError = !fallthrough;
                var originalUrl = parseUrl.original(req);
                var path = parseUrl(req).pathname;
                if ('/' === path && '/' !== originalUrl.pathname.substr(-1)) path = '';
                var stream = send(req, path, opts);
                stream.on('directory', onDirectory);
                if (setHeaders) stream.on('headers', setHeaders);
                if (fallthrough) stream.on('file', function() {
                    forwardError = true;
                });
                stream.on('error', function(err) {
                    if (forwardError || !(err.statusCode < 500)) return void next(err);
                    next();
                });
                stream.pipe(res);
            };
        }
        function collapseLeadingSlashes(str) {
            for(var i = 0; i < str.length && 0x2f === str.charCodeAt(i); i++);
            return i > 1 ? '/' + str.substr(i) : str;
        }
        function createHtmlDocument(title, body) {
            return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
        }
        function createNotFoundDirectoryListener() {
            return function() {
                this.error(404);
            };
        }
        function createRedirectDirectoryListener() {
            return function(res) {
                if (this.hasTrailingSlash()) return void this.error(404);
                var originalUrl = parseUrl.original(this.req);
                originalUrl.path = null;
                originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + '/');
                var loc = encodeUrl(url.format(originalUrl));
                var doc = createHtmlDocument('Redirecting', 'Redirecting to ' + escapeHtml(loc));
                res.statusCode = 301;
                res.setHeader('Content-Type', 'text/html; charset=UTF-8');
                res.setHeader('Content-Length', Buffer.byteLength(doc));
                res.setHeader('Content-Security-Policy', "default-src 'none'");
                res.setHeader('X-Content-Type-Options', 'nosniff');
                res.setHeader('Location', loc);
                res.end(doc);
            };
        }
    },
    "../node_modules/.pnpm/setprototypeof@1.2.0/node_modules/setprototypeof/index.js": function(module) {
        "use strict";
        module.exports = Object.setPrototypeOf || (({
            __proto__: []
        }) instanceof Array ? setProtoOf : mixinProperties);
        function setProtoOf(obj, proto) {
            obj.__proto__ = proto;
            return obj;
        }
        function mixinProperties(obj, proto) {
            for(var prop in proto)if (!Object.prototype.hasOwnProperty.call(obj, prop)) obj[prop] = proto[prop];
            return obj;
        }
    },
    "../node_modules/.pnpm/side-channel-list@1.0.0/node_modules/side-channel-list/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var inspect = __webpack_require__("../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js");
        var $TypeError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
        var listGetNode = function(list, key, isDelete) {
            var prev = list;
            var curr;
            for(; null != (curr = prev.next); prev = curr)if (curr.key === key) {
                prev.next = curr.next;
                if (!isDelete) {
                    curr.next = list.next;
                    list.next = curr;
                }
                return curr;
            }
        };
        var listGet = function(objects, key) {
            if (!objects) return;
            var node = listGetNode(objects, key);
            return node && node.value;
        };
        var listSet = function(objects, key, value) {
            var node = listGetNode(objects, key);
            if (node) node.value = value;
            else objects.next = {
                key: key,
                next: objects.next,
                value: value
            };
        };
        var listHas = function(objects, key) {
            if (!objects) return false;
            return !!listGetNode(objects, key);
        };
        var listDelete = function(objects, key) {
            if (objects) return listGetNode(objects, key, true);
        };
        module.exports = function() {
            var $o;
            var channel = {
                assert: function(key) {
                    if (!channel.has(key)) throw new $TypeError('Side channel does not contain ' + inspect(key));
                },
                delete: function(key) {
                    var root = $o && $o.next;
                    var deletedNode = listDelete($o, key);
                    if (deletedNode && root && root === deletedNode) $o = void 0;
                    return !!deletedNode;
                },
                get: function(key) {
                    return listGet($o, key);
                },
                has: function(key) {
                    return listHas($o, key);
                },
                set: function(key, value) {
                    if (!$o) $o = {
                        next: void 0
                    };
                    listSet($o, key, value);
                }
            };
            return channel;
        };
    },
    "../node_modules/.pnpm/side-channel-map@1.0.1/node_modules/side-channel-map/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var GetIntrinsic = __webpack_require__("../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js");
        var callBound = __webpack_require__("../node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
        var inspect = __webpack_require__("../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js");
        var $TypeError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
        var $Map = GetIntrinsic('%Map%', true);
        var $mapGet = callBound('Map.prototype.get', true);
        var $mapSet = callBound('Map.prototype.set', true);
        var $mapHas = callBound('Map.prototype.has', true);
        var $mapDelete = callBound('Map.prototype.delete', true);
        var $mapSize = callBound('Map.prototype.size', true);
        module.exports = !!$Map && function() {
            var $m;
            var channel = {
                assert: function(key) {
                    if (!channel.has(key)) throw new $TypeError('Side channel does not contain ' + inspect(key));
                },
                delete: function(key) {
                    if ($m) {
                        var result = $mapDelete($m, key);
                        if (0 === $mapSize($m)) $m = void 0;
                        return result;
                    }
                    return false;
                },
                get: function(key) {
                    if ($m) return $mapGet($m, key);
                },
                has: function(key) {
                    if ($m) return $mapHas($m, key);
                    return false;
                },
                set: function(key, value) {
                    if (!$m) $m = new $Map();
                    $mapSet($m, key, value);
                }
            };
            return channel;
        };
    },
    "../node_modules/.pnpm/side-channel-weakmap@1.0.2/node_modules/side-channel-weakmap/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var GetIntrinsic = __webpack_require__("../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js");
        var callBound = __webpack_require__("../node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js");
        var inspect = __webpack_require__("../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js");
        var getSideChannelMap = __webpack_require__("../node_modules/.pnpm/side-channel-map@1.0.1/node_modules/side-channel-map/index.js");
        var $TypeError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
        var $WeakMap = GetIntrinsic('%WeakMap%', true);
        var $weakMapGet = callBound('WeakMap.prototype.get', true);
        var $weakMapSet = callBound('WeakMap.prototype.set', true);
        var $weakMapHas = callBound('WeakMap.prototype.has', true);
        var $weakMapDelete = callBound('WeakMap.prototype.delete', true);
        module.exports = $WeakMap ? function() {
            var $wm;
            var $m;
            var channel = {
                assert: function(key) {
                    if (!channel.has(key)) throw new $TypeError('Side channel does not contain ' + inspect(key));
                },
                delete: function(key) {
                    if ($WeakMap && key && ('object' == typeof key || 'function' == typeof key)) {
                        if ($wm) return $weakMapDelete($wm, key);
                    } else if (getSideChannelMap) {
                        if ($m) return $m['delete'](key);
                    }
                    return false;
                },
                get: function(key) {
                    if ($WeakMap && key && ('object' == typeof key || 'function' == typeof key)) {
                        if ($wm) return $weakMapGet($wm, key);
                    }
                    return $m && $m.get(key);
                },
                has: function(key) {
                    if ($WeakMap && key && ('object' == typeof key || 'function' == typeof key)) {
                        if ($wm) return $weakMapHas($wm, key);
                    }
                    return !!$m && $m.has(key);
                },
                set: function(key, value) {
                    if ($WeakMap && key && ('object' == typeof key || 'function' == typeof key)) {
                        if (!$wm) $wm = new $WeakMap();
                        $weakMapSet($wm, key, value);
                    } else if (getSideChannelMap) {
                        if (!$m) $m = getSideChannelMap();
                        $m.set(key, value);
                    }
                }
            };
            return channel;
        } : getSideChannelMap;
    },
    "../node_modules/.pnpm/side-channel@1.1.0/node_modules/side-channel/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var $TypeError = __webpack_require__("../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js");
        var inspect = __webpack_require__("../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js");
        var getSideChannelList = __webpack_require__("../node_modules/.pnpm/side-channel-list@1.0.0/node_modules/side-channel-list/index.js");
        var getSideChannelMap = __webpack_require__("../node_modules/.pnpm/side-channel-map@1.0.1/node_modules/side-channel-map/index.js");
        var getSideChannelWeakMap = __webpack_require__("../node_modules/.pnpm/side-channel-weakmap@1.0.2/node_modules/side-channel-weakmap/index.js");
        var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
        module.exports = function() {
            var $channelData;
            var channel = {
                assert: function(key) {
                    if (!channel.has(key)) throw new $TypeError('Side channel does not contain ' + inspect(key));
                },
                delete: function(key) {
                    return !!$channelData && $channelData['delete'](key);
                },
                get: function(key) {
                    return $channelData && $channelData.get(key);
                },
                has: function(key) {
                    return !!$channelData && $channelData.has(key);
                },
                set: function(key, value) {
                    if (!$channelData) $channelData = makeChannel();
                    $channelData.set(key, value);
                }
            };
            return channel;
        };
    },
    "../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/cluster-adapter.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var __rest = this && this.__rest || function(s, e) {
            var t = {};
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
            if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
                for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
            }
            return t;
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.ClusterAdapterWithHeartbeat = exports1.ClusterAdapter = exports1.MessageType = void 0;
        const in_memory_adapter_1 = __webpack_require__("../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/in-memory-adapter.js");
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const crypto_1 = __webpack_require__("crypto");
        const debug = (0, debug_1.debug)("socket.io-adapter");
        const EMITTER_UID = "emitter";
        const DEFAULT_TIMEOUT = 5000;
        function randomId() {
            return (0, crypto_1.randomBytes)(8).toString("hex");
        }
        var MessageType;
        (function(MessageType) {
            MessageType[MessageType["INITIAL_HEARTBEAT"] = 1] = "INITIAL_HEARTBEAT";
            MessageType[MessageType["HEARTBEAT"] = 2] = "HEARTBEAT";
            MessageType[MessageType["BROADCAST"] = 3] = "BROADCAST";
            MessageType[MessageType["SOCKETS_JOIN"] = 4] = "SOCKETS_JOIN";
            MessageType[MessageType["SOCKETS_LEAVE"] = 5] = "SOCKETS_LEAVE";
            MessageType[MessageType["DISCONNECT_SOCKETS"] = 6] = "DISCONNECT_SOCKETS";
            MessageType[MessageType["FETCH_SOCKETS"] = 7] = "FETCH_SOCKETS";
            MessageType[MessageType["FETCH_SOCKETS_RESPONSE"] = 8] = "FETCH_SOCKETS_RESPONSE";
            MessageType[MessageType["SERVER_SIDE_EMIT"] = 9] = "SERVER_SIDE_EMIT";
            MessageType[MessageType["SERVER_SIDE_EMIT_RESPONSE"] = 10] = "SERVER_SIDE_EMIT_RESPONSE";
            MessageType[MessageType["BROADCAST_CLIENT_COUNT"] = 11] = "BROADCAST_CLIENT_COUNT";
            MessageType[MessageType["BROADCAST_ACK"] = 12] = "BROADCAST_ACK";
            MessageType[MessageType["ADAPTER_CLOSE"] = 13] = "ADAPTER_CLOSE";
        })(MessageType = exports1.MessageType || (exports1.MessageType = {}));
        function encodeOptions(opts) {
            return {
                rooms: [
                    ...opts.rooms
                ],
                except: [
                    ...opts.except
                ],
                flags: opts.flags
            };
        }
        function decodeOptions(opts) {
            return {
                rooms: new Set(opts.rooms),
                except: new Set(opts.except),
                flags: opts.flags
            };
        }
        class ClusterAdapter extends in_memory_adapter_1.Adapter {
            constructor(nsp){
                super(nsp);
                this.requests = new Map();
                this.ackRequests = new Map();
                this.uid = randomId();
            }
            onMessage(message, offset) {
                if (message.uid === this.uid) return debug("[%s] ignore message from self", this.uid);
                debug("[%s] new event of type %d from %s", this.uid, message.type, message.uid);
                switch(message.type){
                    case MessageType.BROADCAST:
                        {
                            const withAck = void 0 !== message.data.requestId;
                            if (withAck) super.broadcastWithAck(message.data.packet, decodeOptions(message.data.opts), (clientCount)=>{
                                debug("[%s] waiting for %d client acknowledgements", this.uid, clientCount);
                                this.publishResponse(message.uid, {
                                    type: MessageType.BROADCAST_CLIENT_COUNT,
                                    data: {
                                        requestId: message.data.requestId,
                                        clientCount
                                    }
                                });
                            }, (arg)=>{
                                debug("[%s] received acknowledgement with value %j", this.uid, arg);
                                this.publishResponse(message.uid, {
                                    type: MessageType.BROADCAST_ACK,
                                    data: {
                                        requestId: message.data.requestId,
                                        packet: arg
                                    }
                                });
                            });
                            else {
                                const packet = message.data.packet;
                                const opts = decodeOptions(message.data.opts);
                                this.addOffsetIfNecessary(packet, opts, offset);
                                super.broadcast(packet, opts);
                            }
                            break;
                        }
                    case MessageType.SOCKETS_JOIN:
                        super.addSockets(decodeOptions(message.data.opts), message.data.rooms);
                        break;
                    case MessageType.SOCKETS_LEAVE:
                        super.delSockets(decodeOptions(message.data.opts), message.data.rooms);
                        break;
                    case MessageType.DISCONNECT_SOCKETS:
                        super.disconnectSockets(decodeOptions(message.data.opts), message.data.close);
                        break;
                    case MessageType.FETCH_SOCKETS:
                        debug("[%s] calling fetchSockets with opts %j", this.uid, message.data.opts);
                        super.fetchSockets(decodeOptions(message.data.opts)).then((localSockets)=>{
                            this.publishResponse(message.uid, {
                                type: MessageType.FETCH_SOCKETS_RESPONSE,
                                data: {
                                    requestId: message.data.requestId,
                                    sockets: localSockets.map((socket)=>{
                                        const _a = socket.handshake, { sessionStore } = _a, handshake = __rest(_a, [
                                            "sessionStore"
                                        ]);
                                        return {
                                            id: socket.id,
                                            handshake,
                                            rooms: [
                                                ...socket.rooms
                                            ],
                                            data: socket.data
                                        };
                                    })
                                }
                            });
                        });
                        break;
                    case MessageType.SERVER_SIDE_EMIT:
                        {
                            const packet = message.data.packet;
                            const withAck = void 0 !== message.data.requestId;
                            if (!withAck) return void this.nsp._onServerSideEmit(packet);
                            let called = false;
                            const callback = (arg)=>{
                                if (called) return;
                                called = true;
                                debug("[%s] calling acknowledgement with %j", this.uid, arg);
                                this.publishResponse(message.uid, {
                                    type: MessageType.SERVER_SIDE_EMIT_RESPONSE,
                                    data: {
                                        requestId: message.data.requestId,
                                        packet: arg
                                    }
                                });
                            };
                            this.nsp._onServerSideEmit([
                                ...packet,
                                callback
                            ]);
                            break;
                        }
                    case MessageType.BROADCAST_CLIENT_COUNT:
                    case MessageType.BROADCAST_ACK:
                    case MessageType.FETCH_SOCKETS_RESPONSE:
                    case MessageType.SERVER_SIDE_EMIT_RESPONSE:
                        this.onResponse(message);
                        break;
                    default:
                        debug("[%s] unknown message type: %s", this.uid, message.type);
                }
            }
            onResponse(response) {
                var _a, _b;
                const requestId = response.data.requestId;
                debug("[%s] received response %s to request %s", this.uid, response.type, requestId);
                switch(response.type){
                    case MessageType.BROADCAST_CLIENT_COUNT:
                        null == (_a = this.ackRequests.get(requestId)) || _a.clientCountCallback(response.data.clientCount);
                        break;
                    case MessageType.BROADCAST_ACK:
                        null == (_b = this.ackRequests.get(requestId)) || _b.ack(response.data.packet);
                        break;
                    case MessageType.FETCH_SOCKETS_RESPONSE:
                        {
                            const request = this.requests.get(requestId);
                            if (!request) return;
                            request.current++;
                            response.data.sockets.forEach((socket)=>request.responses.push(socket));
                            if (request.current === request.expected) {
                                clearTimeout(request.timeout);
                                request.resolve(request.responses);
                                this.requests.delete(requestId);
                            }
                            break;
                        }
                    case MessageType.SERVER_SIDE_EMIT_RESPONSE:
                        {
                            const request = this.requests.get(requestId);
                            if (!request) return;
                            request.current++;
                            request.responses.push(response.data.packet);
                            if (request.current === request.expected) {
                                clearTimeout(request.timeout);
                                request.resolve(null, request.responses);
                                this.requests.delete(requestId);
                            }
                            break;
                        }
                    default:
                        debug("[%s] unknown response type: %s", this.uid, response.type);
                }
            }
            async broadcast(packet, opts) {
                var _a;
                const onlyLocal = null == (_a = opts.flags) ? void 0 : _a.local;
                if (!onlyLocal) try {
                    const offset = await this.publishAndReturnOffset({
                        type: MessageType.BROADCAST,
                        data: {
                            packet,
                            opts: encodeOptions(opts)
                        }
                    });
                    this.addOffsetIfNecessary(packet, opts, offset);
                } catch (e) {
                    return debug("[%s] error while broadcasting message: %s", this.uid, e.message);
                }
                super.broadcast(packet, opts);
            }
            addOffsetIfNecessary(packet, opts, offset) {
                var _a;
                if (!this.nsp.server.opts.connectionStateRecovery) return;
                const isEventPacket = 2 === packet.type;
                const withoutAcknowledgement = void 0 === packet.id;
                const notVolatile = (null == (_a = opts.flags) ? void 0 : _a.volatile) === void 0;
                if (isEventPacket && withoutAcknowledgement && notVolatile) packet.data.push(offset);
            }
            broadcastWithAck(packet, opts, clientCountCallback, ack) {
                var _a;
                const onlyLocal = null == (_a = null == opts ? void 0 : opts.flags) ? void 0 : _a.local;
                if (!onlyLocal) {
                    const requestId = randomId();
                    this.ackRequests.set(requestId, {
                        clientCountCallback,
                        ack
                    });
                    this.publish({
                        type: MessageType.BROADCAST,
                        data: {
                            packet,
                            requestId,
                            opts: encodeOptions(opts)
                        }
                    });
                    setTimeout(()=>{
                        this.ackRequests.delete(requestId);
                    }, opts.flags.timeout);
                }
                super.broadcastWithAck(packet, opts, clientCountCallback, ack);
            }
            async addSockets(opts, rooms) {
                var _a;
                const onlyLocal = null == (_a = opts.flags) ? void 0 : _a.local;
                if (!onlyLocal) try {
                    await this.publishAndReturnOffset({
                        type: MessageType.SOCKETS_JOIN,
                        data: {
                            opts: encodeOptions(opts),
                            rooms
                        }
                    });
                } catch (e) {
                    debug("[%s] error while publishing message: %s", this.uid, e.message);
                }
                super.addSockets(opts, rooms);
            }
            async delSockets(opts, rooms) {
                var _a;
                const onlyLocal = null == (_a = opts.flags) ? void 0 : _a.local;
                if (!onlyLocal) try {
                    await this.publishAndReturnOffset({
                        type: MessageType.SOCKETS_LEAVE,
                        data: {
                            opts: encodeOptions(opts),
                            rooms
                        }
                    });
                } catch (e) {
                    debug("[%s] error while publishing message: %s", this.uid, e.message);
                }
                super.delSockets(opts, rooms);
            }
            async disconnectSockets(opts, close) {
                var _a;
                const onlyLocal = null == (_a = opts.flags) ? void 0 : _a.local;
                if (!onlyLocal) try {
                    await this.publishAndReturnOffset({
                        type: MessageType.DISCONNECT_SOCKETS,
                        data: {
                            opts: encodeOptions(opts),
                            close
                        }
                    });
                } catch (e) {
                    debug("[%s] error while publishing message: %s", this.uid, e.message);
                }
                super.disconnectSockets(opts, close);
            }
            async fetchSockets(opts) {
                var _a;
                const [localSockets, serverCount] = await Promise.all([
                    super.fetchSockets(opts),
                    this.serverCount()
                ]);
                const expectedResponseCount = serverCount - 1;
                if ((null == (_a = opts.flags) ? void 0 : _a.local) || expectedResponseCount <= 0) return localSockets;
                const requestId = randomId();
                return new Promise((resolve, reject)=>{
                    const timeout = setTimeout(()=>{
                        const storedRequest = this.requests.get(requestId);
                        if (storedRequest) {
                            reject(new Error(`timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`));
                            this.requests.delete(requestId);
                        }
                    }, opts.flags.timeout || DEFAULT_TIMEOUT);
                    const storedRequest = {
                        type: MessageType.FETCH_SOCKETS,
                        resolve,
                        timeout,
                        current: 0,
                        expected: expectedResponseCount,
                        responses: localSockets
                    };
                    this.requests.set(requestId, storedRequest);
                    this.publish({
                        type: MessageType.FETCH_SOCKETS,
                        data: {
                            opts: encodeOptions(opts),
                            requestId
                        }
                    });
                });
            }
            async serverSideEmit(packet) {
                const withAck = "function" == typeof packet[packet.length - 1];
                if (!withAck) return this.publish({
                    type: MessageType.SERVER_SIDE_EMIT,
                    data: {
                        packet
                    }
                });
                const ack = packet.pop();
                const expectedResponseCount = await this.serverCount() - 1;
                debug('[%s] waiting for %d responses to "serverSideEmit" request', this.uid, expectedResponseCount);
                if (expectedResponseCount <= 0) return ack(null, []);
                const requestId = randomId();
                const timeout = setTimeout(()=>{
                    const storedRequest = this.requests.get(requestId);
                    if (storedRequest) {
                        ack(new Error(`timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`), storedRequest.responses);
                        this.requests.delete(requestId);
                    }
                }, DEFAULT_TIMEOUT);
                const storedRequest = {
                    type: MessageType.SERVER_SIDE_EMIT,
                    resolve: ack,
                    timeout,
                    current: 0,
                    expected: expectedResponseCount,
                    responses: []
                };
                this.requests.set(requestId, storedRequest);
                this.publish({
                    type: MessageType.SERVER_SIDE_EMIT,
                    data: {
                        requestId,
                        packet
                    }
                });
            }
            publish(message) {
                this.publishAndReturnOffset(message).catch((err)=>{
                    debug("[%s] error while publishing message: %s", this.uid, err);
                });
            }
            publishAndReturnOffset(message) {
                message.uid = this.uid;
                message.nsp = this.nsp.name;
                return this.doPublish(message);
            }
            publishResponse(requesterUid, response) {
                response.uid = this.uid;
                response.nsp = this.nsp.name;
                this.doPublishResponse(requesterUid, response).catch((err)=>{
                    debug("[%s] error while publishing response: %s", this.uid, err);
                });
            }
        }
        exports1.ClusterAdapter = ClusterAdapter;
        class ClusterAdapterWithHeartbeat extends ClusterAdapter {
            constructor(nsp, opts){
                super(nsp);
                this.nodesMap = new Map();
                this.customRequests = new Map();
                this._opts = Object.assign({
                    heartbeatInterval: 5000,
                    heartbeatTimeout: 10000
                }, opts);
                this.cleanupTimer = setInterval(()=>{
                    const now = Date.now();
                    this.nodesMap.forEach((lastSeen, uid)=>{
                        const nodeSeemsDown = now - lastSeen > this._opts.heartbeatTimeout;
                        if (nodeSeemsDown) {
                            debug("[%s] node %s seems down", this.uid, uid);
                            this.removeNode(uid);
                        }
                    });
                }, 1000);
            }
            init() {
                this.publish({
                    type: MessageType.INITIAL_HEARTBEAT
                });
            }
            scheduleHeartbeat() {
                if (this.heartbeatTimer) this.heartbeatTimer.refresh();
                else this.heartbeatTimer = setTimeout(()=>{
                    this.publish({
                        type: MessageType.HEARTBEAT
                    });
                }, this._opts.heartbeatInterval);
            }
            close() {
                this.publish({
                    type: MessageType.ADAPTER_CLOSE
                });
                clearTimeout(this.heartbeatTimer);
                if (this.cleanupTimer) clearInterval(this.cleanupTimer);
            }
            onMessage(message, offset) {
                if (message.uid === this.uid) return debug("[%s] ignore message from self", this.uid);
                if (message.uid && message.uid !== EMITTER_UID) this.nodesMap.set(message.uid, Date.now());
                debug("[%s] new event of type %d from %s", this.uid, message.type, message.uid);
                switch(message.type){
                    case MessageType.INITIAL_HEARTBEAT:
                        this.publish({
                            type: MessageType.HEARTBEAT
                        });
                        break;
                    case MessageType.HEARTBEAT:
                        break;
                    case MessageType.ADAPTER_CLOSE:
                        this.removeNode(message.uid);
                        break;
                    default:
                        super.onMessage(message, offset);
                }
            }
            serverCount() {
                return Promise.resolve(1 + this.nodesMap.size);
            }
            publish(message) {
                this.scheduleHeartbeat();
                return super.publish(message);
            }
            async serverSideEmit(packet) {
                const withAck = "function" == typeof packet[packet.length - 1];
                if (!withAck) return this.publish({
                    type: MessageType.SERVER_SIDE_EMIT,
                    data: {
                        packet
                    }
                });
                const ack = packet.pop();
                const expectedResponseCount = this.nodesMap.size;
                debug('[%s] waiting for %d responses to "serverSideEmit" request', this.uid, expectedResponseCount);
                if (expectedResponseCount <= 0) return ack(null, []);
                const requestId = randomId();
                const timeout = setTimeout(()=>{
                    const storedRequest = this.customRequests.get(requestId);
                    if (storedRequest) {
                        ack(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`), storedRequest.responses);
                        this.customRequests.delete(requestId);
                    }
                }, DEFAULT_TIMEOUT);
                const storedRequest = {
                    type: MessageType.SERVER_SIDE_EMIT,
                    resolve: ack,
                    timeout,
                    missingUids: new Set([
                        ...this.nodesMap.keys()
                    ]),
                    responses: []
                };
                this.customRequests.set(requestId, storedRequest);
                this.publish({
                    type: MessageType.SERVER_SIDE_EMIT,
                    data: {
                        requestId,
                        packet
                    }
                });
            }
            async fetchSockets(opts) {
                var _a;
                const [localSockets, serverCount] = await Promise.all([
                    super.fetchSockets({
                        rooms: opts.rooms,
                        except: opts.except,
                        flags: {
                            local: true
                        }
                    }),
                    this.serverCount()
                ]);
                const expectedResponseCount = serverCount - 1;
                if ((null == (_a = opts.flags) ? void 0 : _a.local) || expectedResponseCount <= 0) return localSockets;
                const requestId = randomId();
                return new Promise((resolve, reject)=>{
                    const timeout = setTimeout(()=>{
                        const storedRequest = this.customRequests.get(requestId);
                        if (storedRequest) {
                            reject(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`));
                            this.customRequests.delete(requestId);
                        }
                    }, opts.flags.timeout || DEFAULT_TIMEOUT);
                    const storedRequest = {
                        type: MessageType.FETCH_SOCKETS,
                        resolve,
                        timeout,
                        missingUids: new Set([
                            ...this.nodesMap.keys()
                        ]),
                        responses: localSockets
                    };
                    this.customRequests.set(requestId, storedRequest);
                    this.publish({
                        type: MessageType.FETCH_SOCKETS,
                        data: {
                            opts: encodeOptions(opts),
                            requestId
                        }
                    });
                });
            }
            onResponse(response) {
                const requestId = response.data.requestId;
                debug("[%s] received response %s to request %s", this.uid, response.type, requestId);
                switch(response.type){
                    case MessageType.FETCH_SOCKETS_RESPONSE:
                        {
                            const request = this.customRequests.get(requestId);
                            if (!request) return;
                            response.data.sockets.forEach((socket)=>request.responses.push(socket));
                            request.missingUids.delete(response.uid);
                            if (0 === request.missingUids.size) {
                                clearTimeout(request.timeout);
                                request.resolve(request.responses);
                                this.customRequests.delete(requestId);
                            }
                            break;
                        }
                    case MessageType.SERVER_SIDE_EMIT_RESPONSE:
                        {
                            const request = this.customRequests.get(requestId);
                            if (!request) return;
                            request.responses.push(response.data.packet);
                            request.missingUids.delete(response.uid);
                            if (0 === request.missingUids.size) {
                                clearTimeout(request.timeout);
                                request.resolve(null, request.responses);
                                this.customRequests.delete(requestId);
                            }
                            break;
                        }
                    default:
                        super.onResponse(response);
                }
            }
            removeNode(uid) {
                this.customRequests.forEach((request, requestId)=>{
                    request.missingUids.delete(uid);
                    if (0 === request.missingUids.size) {
                        clearTimeout(request.timeout);
                        if (request.type === MessageType.FETCH_SOCKETS) request.resolve(request.responses);
                        else if (request.type === MessageType.SERVER_SIDE_EMIT) request.resolve(null, request.responses);
                        this.customRequests.delete(requestId);
                    }
                });
                this.nodesMap.delete(uid);
            }
        }
        exports1.ClusterAdapterWithHeartbeat = ClusterAdapterWithHeartbeat;
    },
    "../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/contrib/yeast.js": function(__unused_webpack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.yeast = exports1.decode = exports1.encode = void 0;
        const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map = {};
        let seed = 0, i = 0, prev;
        function encode(num) {
            let encoded = "";
            do {
                encoded = alphabet[num % length] + encoded;
                num = Math.floor(num / length);
            }while (num > 0);
            return encoded;
        }
        exports1.encode = encode;
        function decode(str) {
            let decoded = 0;
            for(i = 0; i < str.length; i++)decoded = decoded * length + map[str.charAt(i)];
            return decoded;
        }
        exports1.decode = decode;
        function yeast() {
            const now = encode(+new Date());
            if (now !== prev) return seed = 0, prev = now;
            return now + "." + encode(seed++);
        }
        exports1.yeast = yeast;
        for(; i < length; i++)map[alphabet[i]] = i;
    },
    "../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/in-memory-adapter.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var _a;
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.SessionAwareAdapter = exports1.Adapter = void 0;
        const events_1 = __webpack_require__("events");
        const yeast_1 = __webpack_require__("../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/contrib/yeast.js");
        const WebSocket = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/index.js");
        const canPreComputeFrame = "function" == typeof (null == (_a = null == WebSocket ? void 0 : WebSocket.Sender) ? void 0 : _a.frame);
        class Adapter extends events_1.EventEmitter {
            constructor(nsp){
                super();
                this.nsp = nsp;
                this.rooms = new Map();
                this.sids = new Map();
                this.encoder = nsp.server.encoder;
            }
            init() {}
            close() {}
            serverCount() {
                return Promise.resolve(1);
            }
            addAll(id, rooms) {
                if (!this.sids.has(id)) this.sids.set(id, new Set());
                for (const room of rooms){
                    this.sids.get(id).add(room);
                    if (!this.rooms.has(room)) {
                        this.rooms.set(room, new Set());
                        this.emit("create-room", room);
                    }
                    if (!this.rooms.get(room).has(id)) {
                        this.rooms.get(room).add(id);
                        this.emit("join-room", room, id);
                    }
                }
            }
            del(id, room) {
                if (this.sids.has(id)) this.sids.get(id).delete(room);
                this._del(room, id);
            }
            _del(room, id) {
                const _room = this.rooms.get(room);
                if (null != _room) {
                    const deleted = _room.delete(id);
                    if (deleted) this.emit("leave-room", room, id);
                    if (0 === _room.size && this.rooms.delete(room)) this.emit("delete-room", room);
                }
            }
            delAll(id) {
                if (!this.sids.has(id)) return;
                for (const room of this.sids.get(id))this._del(room, id);
                this.sids.delete(id);
            }
            broadcast(packet, opts) {
                const flags = opts.flags || {};
                const packetOpts = {
                    preEncoded: true,
                    volatile: flags.volatile,
                    compress: flags.compress
                };
                packet.nsp = this.nsp.name;
                const encodedPackets = this._encode(packet, packetOpts);
                this.apply(opts, (socket)=>{
                    if ("function" == typeof socket.notifyOutgoingListeners) socket.notifyOutgoingListeners(packet);
                    socket.client.writeToEngine(encodedPackets, packetOpts);
                });
            }
            broadcastWithAck(packet, opts, clientCountCallback, ack) {
                const flags = opts.flags || {};
                const packetOpts = {
                    preEncoded: true,
                    volatile: flags.volatile,
                    compress: flags.compress
                };
                packet.nsp = this.nsp.name;
                packet.id = this.nsp._ids++;
                const encodedPackets = this._encode(packet, packetOpts);
                let clientCount = 0;
                this.apply(opts, (socket)=>{
                    clientCount++;
                    socket.acks.set(packet.id, ack);
                    if ("function" == typeof socket.notifyOutgoingListeners) socket.notifyOutgoingListeners(packet);
                    socket.client.writeToEngine(encodedPackets, packetOpts);
                });
                clientCountCallback(clientCount);
            }
            _encode(packet, packetOpts) {
                const encodedPackets = this.encoder.encode(packet);
                if (canPreComputeFrame && 1 === encodedPackets.length && "string" == typeof encodedPackets[0]) {
                    const data = Buffer.from("4" + encodedPackets[0]);
                    packetOpts.wsPreEncodedFrame = WebSocket.Sender.frame(data, {
                        readOnly: false,
                        mask: false,
                        rsv1: false,
                        opcode: 1,
                        fin: true
                    });
                }
                return encodedPackets;
            }
            sockets(rooms) {
                const sids = new Set();
                this.apply({
                    rooms
                }, (socket)=>{
                    sids.add(socket.id);
                });
                return Promise.resolve(sids);
            }
            socketRooms(id) {
                return this.sids.get(id);
            }
            fetchSockets(opts) {
                const sockets = [];
                this.apply(opts, (socket)=>{
                    sockets.push(socket);
                });
                return Promise.resolve(sockets);
            }
            addSockets(opts, rooms) {
                this.apply(opts, (socket)=>{
                    socket.join(rooms);
                });
            }
            delSockets(opts, rooms) {
                this.apply(opts, (socket)=>{
                    rooms.forEach((room)=>socket.leave(room));
                });
            }
            disconnectSockets(opts, close) {
                this.apply(opts, (socket)=>{
                    socket.disconnect(close);
                });
            }
            apply(opts, callback) {
                const rooms = opts.rooms;
                const except = this.computeExceptSids(opts.except);
                if (rooms.size) {
                    const ids = new Set();
                    for (const room of rooms)if (this.rooms.has(room)) for (const id of this.rooms.get(room)){
                        if (ids.has(id) || except.has(id)) continue;
                        const socket = this.nsp.sockets.get(id);
                        if (socket) {
                            callback(socket);
                            ids.add(id);
                        }
                    }
                } else for (const [id] of this.sids){
                    if (except.has(id)) continue;
                    const socket = this.nsp.sockets.get(id);
                    if (socket) callback(socket);
                }
            }
            computeExceptSids(exceptRooms) {
                const exceptSids = new Set();
                if (exceptRooms && exceptRooms.size > 0) {
                    for (const room of exceptRooms)if (this.rooms.has(room)) this.rooms.get(room).forEach((sid)=>exceptSids.add(sid));
                }
                return exceptSids;
            }
            serverSideEmit(packet) {
                console.warn("this adapter does not support the serverSideEmit() functionality");
            }
            persistSession(session) {}
            restoreSession(pid, offset) {
                return null;
            }
        }
        exports1.Adapter = Adapter;
        class SessionAwareAdapter extends Adapter {
            constructor(nsp){
                super(nsp);
                this.nsp = nsp;
                this.sessions = new Map();
                this.packets = [];
                this.maxDisconnectionDuration = nsp.server.opts.connectionStateRecovery.maxDisconnectionDuration;
                const timer = setInterval(()=>{
                    const threshold = Date.now() - this.maxDisconnectionDuration;
                    this.sessions.forEach((session, sessionId)=>{
                        const hasExpired = session.disconnectedAt < threshold;
                        if (hasExpired) this.sessions.delete(sessionId);
                    });
                    for(let i = this.packets.length - 1; i >= 0; i--){
                        const hasExpired = this.packets[i].emittedAt < threshold;
                        if (hasExpired) {
                            this.packets.splice(0, i + 1);
                            break;
                        }
                    }
                }, 60000);
                timer.unref();
            }
            persistSession(session) {
                session.disconnectedAt = Date.now();
                this.sessions.set(session.pid, session);
            }
            restoreSession(pid, offset) {
                const session = this.sessions.get(pid);
                if (!session) return null;
                const hasExpired = session.disconnectedAt + this.maxDisconnectionDuration < Date.now();
                if (hasExpired) {
                    this.sessions.delete(pid);
                    return null;
                }
                const index = this.packets.findIndex((packet)=>packet.id === offset);
                if (-1 === index) return null;
                const missedPackets = [];
                for(let i = index + 1; i < this.packets.length; i++){
                    const packet = this.packets[i];
                    if (shouldIncludePacket(session.rooms, packet.opts)) missedPackets.push(packet.data);
                }
                return Promise.resolve(Object.assign(Object.assign({}, session), {
                    missedPackets
                }));
            }
            broadcast(packet, opts) {
                var _a;
                const isEventPacket = 2 === packet.type;
                const withoutAcknowledgement = void 0 === packet.id;
                const notVolatile = (null == (_a = opts.flags) ? void 0 : _a.volatile) === void 0;
                if (isEventPacket && withoutAcknowledgement && notVolatile) {
                    const id = (0, yeast_1.yeast)();
                    packet.data.push(id);
                    this.packets.push({
                        id,
                        opts,
                        data: packet.data,
                        emittedAt: Date.now()
                    });
                }
                super.broadcast(packet, opts);
            }
        }
        exports1.SessionAwareAdapter = SessionAwareAdapter;
        function shouldIncludePacket(sessionRooms, opts) {
            const included = 0 === opts.rooms.size || sessionRooms.some((room)=>opts.rooms.has(room));
            const notExcluded = sessionRooms.every((room)=>!opts.except.has(room));
            return included && notExcluded;
        }
    },
    "../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.MessageType = exports1.ClusterAdapterWithHeartbeat = exports1.ClusterAdapter = exports1.SessionAwareAdapter = exports1.Adapter = void 0;
        var in_memory_adapter_1 = __webpack_require__("../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/in-memory-adapter.js");
        Object.defineProperty(exports1, "Adapter", {
            enumerable: true,
            get: function() {
                return in_memory_adapter_1.Adapter;
            }
        });
        Object.defineProperty(exports1, "SessionAwareAdapter", {
            enumerable: true,
            get: function() {
                return in_memory_adapter_1.SessionAwareAdapter;
            }
        });
        var cluster_adapter_1 = __webpack_require__("../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/cluster-adapter.js");
        Object.defineProperty(exports1, "ClusterAdapter", {
            enumerable: true,
            get: function() {
                return cluster_adapter_1.ClusterAdapter;
            }
        });
        Object.defineProperty(exports1, "ClusterAdapterWithHeartbeat", {
            enumerable: true,
            get: function() {
                return cluster_adapter_1.ClusterAdapterWithHeartbeat;
            }
        });
        Object.defineProperty(exports1, "MessageType", {
            enumerable: true,
            get: function() {
                return cluster_adapter_1.MessageType;
            }
        });
    },
    "../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var codes = __webpack_require__("../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/codes.json");
        module.exports = status;
        status.message = codes;
        status.code = createMessageToStatusCodeMap(codes);
        status.codes = createStatusCodeList(codes);
        status.redirect = {
            300: true,
            301: true,
            302: true,
            303: true,
            305: true,
            307: true,
            308: true
        };
        status.empty = {
            204: true,
            205: true,
            304: true
        };
        status.retry = {
            502: true,
            503: true,
            504: true
        };
        function createMessageToStatusCodeMap(codes) {
            var map = {};
            Object.keys(codes).forEach(function(code) {
                var message = codes[code];
                var status = Number(code);
                map[message.toLowerCase()] = status;
            });
            return map;
        }
        function createStatusCodeList(codes) {
            return Object.keys(codes).map(function(code) {
                return Number(code);
            });
        }
        function getStatusCode(message) {
            var msg = message.toLowerCase();
            if (!Object.prototype.hasOwnProperty.call(status.code, msg)) throw new Error('invalid status message: "' + message + '"');
            return status.code[msg];
        }
        function getStatusMessage(code) {
            if (!Object.prototype.hasOwnProperty.call(status.message, code)) throw new Error('invalid status code: ' + code);
            return status.message[code];
        }
        function status(code) {
            if ('number' == typeof code) return getStatusMessage(code);
            if ('string' != typeof code) throw new TypeError('code must be a number or string');
            var n = parseInt(code, 10);
            if (!isNaN(n)) return getStatusMessage(n);
            return getStatusCode(code);
        }
    },
    "../node_modules/.pnpm/supports-color@5.5.0/node_modules/supports-color/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const os = __webpack_require__("os");
        const hasFlag = __webpack_require__("../node_modules/.pnpm/has-flag@3.0.0/node_modules/has-flag/index.js");
        const env = process.env;
        let forceColor;
        if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) forceColor = false;
        else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) forceColor = true;
        if ('FORCE_COLOR' in env) forceColor = 0 === env.FORCE_COLOR.length || 0 !== parseInt(env.FORCE_COLOR, 10);
        function translateLevel(level) {
            if (0 === level) return false;
            return {
                level,
                hasBasic: true,
                has256: level >= 2,
                has16m: level >= 3
            };
        }
        function supportsColor(stream) {
            if (false === forceColor) return 0;
            if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) return 3;
            if (hasFlag('color=256')) return 2;
            if (stream && !stream.isTTY && true !== forceColor) return 0;
            const min = forceColor ? 1 : 0;
            if ('win32' === process.platform) {
                const osRelease = os.release().split('.');
                if (Number(process.versions.node.split('.')[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) return Number(osRelease[2]) >= 14931 ? 3 : 2;
                return 1;
            }
            if ('CI' in env) {
                if ([
                    'TRAVIS',
                    'CIRCLECI',
                    'APPVEYOR',
                    'GITLAB_CI'
                ].some((sign)=>sign in env) || 'codeship' === env.CI_NAME) return 1;
                return min;
            }
            if ('TEAMCITY_VERSION' in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
            if ('truecolor' === env.COLORTERM) return 3;
            if ('TERM_PROGRAM' in env) {
                const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
                switch(env.TERM_PROGRAM){
                    case 'iTerm.app':
                        return version >= 3 ? 3 : 2;
                    case 'Apple_Terminal':
                        return 2;
                }
            }
            if (/-256(color)?$/i.test(env.TERM)) return 2;
            if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) return 1;
            if ('COLORTERM' in env) return 1;
            env.TERM;
            return min;
        }
        function getSupportLevel(stream) {
            const level = supportsColor(stream);
            return translateLevel(level);
        }
        module.exports = {
            supportsColor: getSupportLevel,
            stdout: getSupportLevel(process.stdout),
            stderr: getSupportLevel(process.stderr)
        };
    },
    "../node_modules/.pnpm/toidentifier@1.0.1/node_modules/toidentifier/index.js": function(module) {
        "use strict";
        /*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = toIdentifier;
        function toIdentifier(str) {
            return str.split(' ').map(function(token) {
                return token.slice(0, 1).toUpperCase() + token.slice(1);
            }).join('').replace(/[^ _0-9a-z]/gi, '');
        }
    },
    "../node_modules/.pnpm/type-is@1.6.18/node_modules/type-is/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        /*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var typer = __webpack_require__("../node_modules/.pnpm/media-typer@0.3.0/node_modules/media-typer/index.js");
        var mime = __webpack_require__("../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js");
        module.exports = typeofrequest;
        module.exports.is = typeis;
        module.exports.hasBody = hasbody;
        module.exports.normalize = normalize;
        module.exports.match = mimeMatch;
        function typeis(value, types_) {
            var i;
            var types = types_;
            var val = tryNormalizeType(value);
            if (!val) return false;
            if (types && !Array.isArray(types)) {
                types = new Array(arguments.length - 1);
                for(i = 0; i < types.length; i++)types[i] = arguments[i + 1];
            }
            if (!types || !types.length) return val;
            var type;
            for(i = 0; i < types.length; i++)if (mimeMatch(normalize(type = types[i]), val)) return '+' === type[0] || -1 !== type.indexOf('*') ? val : type;
            return false;
        }
        function hasbody(req) {
            return void 0 !== req.headers['transfer-encoding'] || !isNaN(req.headers['content-length']);
        }
        function typeofrequest(req, types_) {
            var types = types_;
            if (!hasbody(req)) return null;
            if (arguments.length > 2) {
                types = new Array(arguments.length - 1);
                for(var i = 0; i < types.length; i++)types[i] = arguments[i + 1];
            }
            var value = req.headers['content-type'];
            return typeis(value, types);
        }
        function normalize(type) {
            if ('string' != typeof type) return false;
            switch(type){
                case 'urlencoded':
                    return 'application/x-www-form-urlencoded';
                case 'multipart':
                    return 'multipart/*';
            }
            if ('+' === type[0]) return '*/*' + type;
            return -1 === type.indexOf('/') ? mime.lookup(type) : type;
        }
        function mimeMatch(expected, actual) {
            if (false === expected) return false;
            var actualParts = actual.split('/');
            var expectedParts = expected.split('/');
            if (2 !== actualParts.length || 2 !== expectedParts.length) return false;
            if ('*' !== expectedParts[0] && expectedParts[0] !== actualParts[0]) return false;
            if ('*+' === expectedParts[1].substr(0, 2)) return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
            if ('*' !== expectedParts[1] && expectedParts[1] !== actualParts[1]) return false;
            return true;
        }
        function normalizeType(value) {
            var type = typer.parse(value);
            type.parameters = void 0;
            return typer.format(type);
        }
        function tryNormalizeType(value) {
            if (!value) return null;
            try {
                return normalizeType(value);
            } catch (err) {
                return null;
            }
        }
    },
    "../node_modules/.pnpm/unpipe@1.0.0/node_modules/unpipe/index.js": function(module) {
        "use strict";
        /*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = unpipe;
        function hasPipeDataListeners(stream) {
            var listeners = stream.listeners('data');
            for(var i = 0; i < listeners.length; i++)if ('ondata' === listeners[i].name) return true;
            return false;
        }
        function unpipe(stream) {
            if (!stream) throw new TypeError('argument stream is required');
            if ('function' == typeof stream.unpipe) return void stream.unpipe();
            if (!hasPipeDataListeners(stream)) return;
            var listener;
            var listeners = stream.listeners('close');
            for(var i = 0; i < listeners.length; i++){
                listener = listeners[i];
                if ('cleanup' === listener.name || 'onclose' === listener.name) listener.call(stream);
            }
        }
    },
    "../node_modules/.pnpm/utils-merge@1.0.1/node_modules/utils-merge/index.js": function(module, exports1) {
        module.exports = function(a, b) {
            if (a && b) for(var key in b)a[key] = b[key];
            return a;
        };
    },
    "../node_modules/.pnpm/vary@1.1.2/node_modules/vary/index.js": function(module) {
        "use strict";
        /*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ module.exports = vary;
        module.exports.append = append;
        var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
        function append(header, field) {
            if ('string' != typeof header) throw new TypeError('header argument is required');
            if (!field) throw new TypeError('field argument is required');
            var fields = Array.isArray(field) ? field : parse(String(field));
            for(var j = 0; j < fields.length; j++)if (!FIELD_NAME_REGEXP.test(fields[j])) throw new TypeError('field argument contains an invalid header name');
            if ('*' === header) return header;
            var val = header;
            var vals = parse(header.toLowerCase());
            if (-1 !== fields.indexOf('*') || -1 !== vals.indexOf('*')) return '*';
            for(var i = 0; i < fields.length; i++){
                var fld = fields[i].toLowerCase();
                if (-1 === vals.indexOf(fld)) {
                    vals.push(fld);
                    val = val ? val + ', ' + fields[i] : fields[i];
                }
            }
            return val;
        }
        function parse(header) {
            var end = 0;
            var list = [];
            var start = 0;
            for(var i = 0, len = header.length; i < len; i++)switch(header.charCodeAt(i)){
                case 0x20:
                    if (start === end) start = end = i + 1;
                    break;
                case 0x2c:
                    list.push(header.substring(start, end));
                    start = end = i + 1;
                    break;
                default:
                    end = i + 1;
                    break;
            }
            list.push(header.substring(start, end));
            return list;
        }
        function vary(res, field) {
            if (!res || !res.getHeader || !res.setHeader) throw new TypeError('res argument is required');
            var val = res.getHeader('Vary') || '';
            var header = Array.isArray(val) ? val.join(', ') : String(val);
            if (val = append(header, field)) res.setHeader('Vary', val);
        }
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const WebSocket = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/websocket.js");
        WebSocket.createWebSocketStream = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/stream.js");
        WebSocket.Server = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/websocket-server.js");
        WebSocket.Receiver = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/receiver.js");
        WebSocket.Sender = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/sender.js");
        WebSocket.WebSocket = WebSocket;
        WebSocket.WebSocketServer = WebSocket.Server;
        module.exports = WebSocket;
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/buffer-util.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const { EMPTY_BUFFER } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/constants.js");
        const FastBuffer = Buffer[Symbol.species];
        function concat(list, totalLength) {
            if (0 === list.length) return EMPTY_BUFFER;
            if (1 === list.length) return list[0];
            const target = Buffer.allocUnsafe(totalLength);
            let offset = 0;
            for(let i = 0; i < list.length; i++){
                const buf = list[i];
                target.set(buf, offset);
                offset += buf.length;
            }
            if (offset < totalLength) return new FastBuffer(target.buffer, target.byteOffset, offset);
            return target;
        }
        function _mask(source, mask, output, offset, length) {
            for(let i = 0; i < length; i++)output[offset + i] = source[i] ^ mask[3 & i];
        }
        function _unmask(buffer, mask) {
            for(let i = 0; i < buffer.length; i++)buffer[i] ^= mask[3 & i];
        }
        function toArrayBuffer(buf) {
            if (buf.length === buf.buffer.byteLength) return buf.buffer;
            return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
        }
        function toBuffer(data) {
            toBuffer.readOnly = true;
            if (Buffer.isBuffer(data)) return data;
            let buf;
            if (data instanceof ArrayBuffer) buf = new FastBuffer(data);
            else if (ArrayBuffer.isView(data)) buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
            else {
                buf = Buffer.from(data);
                toBuffer.readOnly = false;
            }
            return buf;
        }
        module.exports = {
            concat,
            mask: _mask,
            toArrayBuffer,
            toBuffer,
            unmask: _unmask
        };
        if (!process.env.WS_NO_BUFFER_UTIL) try {
            const bufferUtil = __webpack_require__("../../node_modules/bufferutil/index.js");
            module.exports.mask = function(source, mask, output, offset, length) {
                if (length < 48) _mask(source, mask, output, offset, length);
                else bufferUtil.mask(source, mask, output, offset, length);
            };
            module.exports.unmask = function(buffer, mask) {
                if (buffer.length < 32) _unmask(buffer, mask);
                else bufferUtil.unmask(buffer, mask);
            };
        } catch (e) {}
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/constants.js": function(module) {
        "use strict";
        module.exports = {
            BINARY_TYPES: [
                'nodebuffer',
                'arraybuffer',
                'fragments'
            ],
            EMPTY_BUFFER: Buffer.alloc(0),
            GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
            kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
            kListener: Symbol('kListener'),
            kStatusCode: Symbol('status-code'),
            kWebSocket: Symbol('websocket'),
            NOOP: ()=>{}
        };
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/event-target.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const { kForOnEventAttribute, kListener } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/constants.js");
        const kCode = Symbol('kCode');
        const kData = Symbol('kData');
        const kError = Symbol('kError');
        const kMessage = Symbol('kMessage');
        const kReason = Symbol('kReason');
        const kTarget = Symbol('kTarget');
        const kType = Symbol('kType');
        const kWasClean = Symbol('kWasClean');
        class Event {
            constructor(type){
                this[kTarget] = null;
                this[kType] = type;
            }
            get target() {
                return this[kTarget];
            }
            get type() {
                return this[kType];
            }
        }
        Object.defineProperty(Event.prototype, 'target', {
            enumerable: true
        });
        Object.defineProperty(Event.prototype, 'type', {
            enumerable: true
        });
        class CloseEvent extends Event {
            constructor(type, options = {}){
                super(type);
                this[kCode] = void 0 === options.code ? 0 : options.code;
                this[kReason] = void 0 === options.reason ? '' : options.reason;
                this[kWasClean] = void 0 === options.wasClean ? false : options.wasClean;
            }
            get code() {
                return this[kCode];
            }
            get reason() {
                return this[kReason];
            }
            get wasClean() {
                return this[kWasClean];
            }
        }
        Object.defineProperty(CloseEvent.prototype, 'code', {
            enumerable: true
        });
        Object.defineProperty(CloseEvent.prototype, 'reason', {
            enumerable: true
        });
        Object.defineProperty(CloseEvent.prototype, 'wasClean', {
            enumerable: true
        });
        class ErrorEvent extends Event {
            constructor(type, options = {}){
                super(type);
                this[kError] = void 0 === options.error ? null : options.error;
                this[kMessage] = void 0 === options.message ? '' : options.message;
            }
            get error() {
                return this[kError];
            }
            get message() {
                return this[kMessage];
            }
        }
        Object.defineProperty(ErrorEvent.prototype, 'error', {
            enumerable: true
        });
        Object.defineProperty(ErrorEvent.prototype, 'message', {
            enumerable: true
        });
        class MessageEvent extends Event {
            constructor(type, options = {}){
                super(type);
                this[kData] = void 0 === options.data ? null : options.data;
            }
            get data() {
                return this[kData];
            }
        }
        Object.defineProperty(MessageEvent.prototype, 'data', {
            enumerable: true
        });
        const EventTarget = {
            addEventListener (type, handler, options = {}) {
                for (const listener of this.listeners(type))if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) return;
                let wrapper;
                if ('message' === type) wrapper = function(data, isBinary) {
                    const event = new MessageEvent('message', {
                        data: isBinary ? data : data.toString()
                    });
                    event[kTarget] = this;
                    callListener(handler, this, event);
                };
                else if ('close' === type) wrapper = function(code, message) {
                    const event = new CloseEvent('close', {
                        code,
                        reason: message.toString(),
                        wasClean: this._closeFrameReceived && this._closeFrameSent
                    });
                    event[kTarget] = this;
                    callListener(handler, this, event);
                };
                else if ('error' === type) wrapper = function(error) {
                    const event = new ErrorEvent('error', {
                        error,
                        message: error.message
                    });
                    event[kTarget] = this;
                    callListener(handler, this, event);
                };
                else {
                    if ('open' !== type) return;
                    wrapper = function() {
                        const event = new Event('open');
                        event[kTarget] = this;
                        callListener(handler, this, event);
                    };
                }
                wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
                wrapper[kListener] = handler;
                if (options.once) this.once(type, wrapper);
                else this.on(type, wrapper);
            },
            removeEventListener (type, handler) {
                for (const listener of this.listeners(type))if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
                    this.removeListener(type, listener);
                    break;
                }
            }
        };
        module.exports = {
            CloseEvent,
            ErrorEvent,
            Event,
            EventTarget,
            MessageEvent
        };
        function callListener(listener, thisArg, event) {
            if ('object' == typeof listener && listener.handleEvent) listener.handleEvent.call(listener, event);
            else listener.call(thisArg, event);
        }
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/extension.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const { tokenChars } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/validation.js");
        function push(dest, name, elem) {
            if (void 0 === dest[name]) dest[name] = [
                elem
            ];
            else dest[name].push(elem);
        }
        function parse(header) {
            const offers = Object.create(null);
            let params = Object.create(null);
            let mustUnescape = false;
            let isEscaping = false;
            let inQuotes = false;
            let extensionName;
            let paramName;
            let start = -1;
            let code = -1;
            let end = -1;
            let i = 0;
            for(; i < header.length; i++){
                code = header.charCodeAt(i);
                if (void 0 === extensionName) if (-1 === end && 1 === tokenChars[code]) {
                    if (-1 === start) start = i;
                } else if (0 !== i && (0x20 === code || 0x09 === code)) {
                    if (-1 === end && -1 !== start) end = i;
                } else if (0x3b === code || 0x2c === code) {
                    if (-1 === start) throw new SyntaxError(`Unexpected character at index ${i}`);
                    if (-1 === end) end = i;
                    const name = header.slice(start, end);
                    if (0x2c === code) {
                        push(offers, name, params);
                        params = Object.create(null);
                    } else extensionName = name;
                    start = end = -1;
                } else throw new SyntaxError(`Unexpected character at index ${i}`);
                else if (void 0 === paramName) if (-1 === end && 1 === tokenChars[code]) {
                    if (-1 === start) start = i;
                } else if (0x20 === code || 0x09 === code) {
                    if (-1 === end && -1 !== start) end = i;
                } else if (0x3b === code || 0x2c === code) {
                    if (-1 === start) throw new SyntaxError(`Unexpected character at index ${i}`);
                    if (-1 === end) end = i;
                    push(params, header.slice(start, end), true);
                    if (0x2c === code) {
                        push(offers, extensionName, params);
                        params = Object.create(null);
                        extensionName = void 0;
                    }
                    start = end = -1;
                } else if (0x3d === code && -1 !== start && -1 === end) {
                    paramName = header.slice(start, i);
                    start = end = -1;
                } else throw new SyntaxError(`Unexpected character at index ${i}`);
                else if (isEscaping) {
                    if (1 !== tokenChars[code]) throw new SyntaxError(`Unexpected character at index ${i}`);
                    if (-1 === start) start = i;
                    else if (!mustUnescape) mustUnescape = true;
                    isEscaping = false;
                } else if (inQuotes) if (1 === tokenChars[code]) {
                    if (-1 === start) start = i;
                } else if (0x22 === code && -1 !== start) {
                    inQuotes = false;
                    end = i;
                } else if (0x5c === code) isEscaping = true;
                else throw new SyntaxError(`Unexpected character at index ${i}`);
                else if (0x22 === code && 0x3d === header.charCodeAt(i - 1)) inQuotes = true;
                else if (-1 === end && 1 === tokenChars[code]) {
                    if (-1 === start) start = i;
                } else if (-1 !== start && (0x20 === code || 0x09 === code)) {
                    if (-1 === end) end = i;
                } else if (0x3b === code || 0x2c === code) {
                    if (-1 === start) throw new SyntaxError(`Unexpected character at index ${i}`);
                    if (-1 === end) end = i;
                    let value = header.slice(start, end);
                    if (mustUnescape) {
                        value = value.replace(/\\/g, '');
                        mustUnescape = false;
                    }
                    push(params, paramName, value);
                    if (0x2c === code) {
                        push(offers, extensionName, params);
                        params = Object.create(null);
                        extensionName = void 0;
                    }
                    paramName = void 0;
                    start = end = -1;
                } else throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (-1 === start || inQuotes || 0x20 === code || 0x09 === code) throw new SyntaxError('Unexpected end of input');
            if (-1 === end) end = i;
            const token = header.slice(start, end);
            if (void 0 === extensionName) push(offers, token, params);
            else {
                if (void 0 === paramName) push(params, token, true);
                else mustUnescape ? push(params, paramName, token.replace(/\\/g, '')) : push(params, paramName, token);
                push(offers, extensionName, params);
            }
            return offers;
        }
        function format(extensions) {
            return Object.keys(extensions).map((extension)=>{
                let configurations = extensions[extension];
                if (!Array.isArray(configurations)) configurations = [
                    configurations
                ];
                return configurations.map((params)=>[
                        extension
                    ].concat(Object.keys(params).map((k)=>{
                        let values = params[k];
                        if (!Array.isArray(values)) values = [
                            values
                        ];
                        return values.map((v)=>true === v ? k : `${k}=${v}`).join('; ');
                    })).join('; ')).join(', ');
            }).join(', ');
        }
        module.exports = {
            format,
            parse
        };
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/limiter.js": function(module) {
        "use strict";
        const kDone = Symbol('kDone');
        const kRun = Symbol('kRun');
        class Limiter {
            constructor(concurrency){
                this[kDone] = ()=>{
                    this.pending--;
                    this[kRun]();
                };
                this.concurrency = concurrency || 1 / 0;
                this.jobs = [];
                this.pending = 0;
            }
            add(job) {
                this.jobs.push(job);
                this[kRun]();
            }
            [kRun]() {
                if (this.pending === this.concurrency) return;
                if (this.jobs.length) {
                    const job = this.jobs.shift();
                    this.pending++;
                    job(this[kDone]);
                }
            }
        }
        module.exports = Limiter;
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/permessage-deflate.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const zlib = __webpack_require__("zlib");
        const bufferUtil = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/buffer-util.js");
        const Limiter = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/limiter.js");
        const { kStatusCode } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/constants.js");
        const FastBuffer = Buffer[Symbol.species];
        const TRAILER = Buffer.from([
            0x00,
            0x00,
            0xff,
            0xff
        ]);
        const kPerMessageDeflate = Symbol('permessage-deflate');
        const kTotalLength = Symbol('total-length');
        const kCallback = Symbol('callback');
        const kBuffers = Symbol('buffers');
        const kError = Symbol('error');
        let zlibLimiter;
        class PerMessageDeflate {
            constructor(options, isServer, maxPayload){
                this._maxPayload = 0 | maxPayload;
                this._options = options || {};
                this._threshold = void 0 !== this._options.threshold ? this._options.threshold : 1024;
                this._isServer = !!isServer;
                this._deflate = null;
                this._inflate = null;
                this.params = null;
                if (!zlibLimiter) {
                    const concurrency = void 0 !== this._options.concurrencyLimit ? this._options.concurrencyLimit : 10;
                    zlibLimiter = new Limiter(concurrency);
                }
            }
            static get extensionName() {
                return 'permessage-deflate';
            }
            offer() {
                const params = {};
                if (this._options.serverNoContextTakeover) params.server_no_context_takeover = true;
                if (this._options.clientNoContextTakeover) params.client_no_context_takeover = true;
                if (this._options.serverMaxWindowBits) params.server_max_window_bits = this._options.serverMaxWindowBits;
                if (this._options.clientMaxWindowBits) params.client_max_window_bits = this._options.clientMaxWindowBits;
                else if (null == this._options.clientMaxWindowBits) params.client_max_window_bits = true;
                return params;
            }
            accept(configurations) {
                configurations = this.normalizeParams(configurations);
                this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
                return this.params;
            }
            cleanup() {
                if (this._inflate) {
                    this._inflate.close();
                    this._inflate = null;
                }
                if (this._deflate) {
                    const callback = this._deflate[kCallback];
                    this._deflate.close();
                    this._deflate = null;
                    if (callback) callback(new Error('The deflate stream was closed while data was being processed'));
                }
            }
            acceptAsServer(offers) {
                const opts = this._options;
                const accepted = offers.find((params)=>{
                    if (false === opts.serverNoContextTakeover && params.server_no_context_takeover || params.server_max_window_bits && (false === opts.serverMaxWindowBits || 'number' == typeof opts.serverMaxWindowBits && opts.serverMaxWindowBits > params.server_max_window_bits) || 'number' == typeof opts.clientMaxWindowBits && !params.client_max_window_bits) return false;
                    return true;
                });
                if (!accepted) throw new Error('None of the extension offers can be accepted');
                if (opts.serverNoContextTakeover) accepted.server_no_context_takeover = true;
                if (opts.clientNoContextTakeover) accepted.client_no_context_takeover = true;
                if ('number' == typeof opts.serverMaxWindowBits) accepted.server_max_window_bits = opts.serverMaxWindowBits;
                if ('number' == typeof opts.clientMaxWindowBits) accepted.client_max_window_bits = opts.clientMaxWindowBits;
                else if (true === accepted.client_max_window_bits || false === opts.clientMaxWindowBits) delete accepted.client_max_window_bits;
                return accepted;
            }
            acceptAsClient(response) {
                const params = response[0];
                if (false === this._options.clientNoContextTakeover && params.client_no_context_takeover) throw new Error('Unexpected parameter "client_no_context_takeover"');
                if (params.client_max_window_bits) {
                    if (false === this._options.clientMaxWindowBits || 'number' == typeof this._options.clientMaxWindowBits && params.client_max_window_bits > this._options.clientMaxWindowBits) throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
                } else if ('number' == typeof this._options.clientMaxWindowBits) params.client_max_window_bits = this._options.clientMaxWindowBits;
                return params;
            }
            normalizeParams(configurations) {
                configurations.forEach((params)=>{
                    Object.keys(params).forEach((key)=>{
                        let value = params[key];
                        if (value.length > 1) throw new Error(`Parameter "${key}" must have only a single value`);
                        value = value[0];
                        if ('client_max_window_bits' === key) {
                            if (true !== value) {
                                const num = +value;
                                if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                                value = num;
                            } else if (!this._isServer) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                        } else if ('server_max_window_bits' === key) {
                            const num = +value;
                            if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                            value = num;
                        } else if ('client_no_context_takeover' === key || 'server_no_context_takeover' === key) {
                            if (true !== value) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                        } else throw new Error(`Unknown parameter "${key}"`);
                        params[key] = value;
                    });
                });
                return configurations;
            }
            decompress(data, fin, callback) {
                zlibLimiter.add((done)=>{
                    this._decompress(data, fin, (err, result)=>{
                        done();
                        callback(err, result);
                    });
                });
            }
            compress(data, fin, callback) {
                zlibLimiter.add((done)=>{
                    this._compress(data, fin, (err, result)=>{
                        done();
                        callback(err, result);
                    });
                });
            }
            _decompress(data, fin, callback) {
                const endpoint = this._isServer ? 'client' : 'server';
                if (!this._inflate) {
                    const key = `${endpoint}_max_window_bits`;
                    const windowBits = 'number' != typeof this.params[key] ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
                    this._inflate = zlib.createInflateRaw({
                        ...this._options.zlibInflateOptions,
                        windowBits
                    });
                    this._inflate[kPerMessageDeflate] = this;
                    this._inflate[kTotalLength] = 0;
                    this._inflate[kBuffers] = [];
                    this._inflate.on('error', inflateOnError);
                    this._inflate.on('data', inflateOnData);
                }
                this._inflate[kCallback] = callback;
                this._inflate.write(data);
                if (fin) this._inflate.write(TRAILER);
                this._inflate.flush(()=>{
                    const err = this._inflate[kError];
                    if (err) {
                        this._inflate.close();
                        this._inflate = null;
                        callback(err);
                        return;
                    }
                    const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
                    if (this._inflate._readableState.endEmitted) {
                        this._inflate.close();
                        this._inflate = null;
                    } else {
                        this._inflate[kTotalLength] = 0;
                        this._inflate[kBuffers] = [];
                        if (fin && this.params[`${endpoint}_no_context_takeover`]) this._inflate.reset();
                    }
                    callback(null, data);
                });
            }
            _compress(data, fin, callback) {
                const endpoint = this._isServer ? 'server' : 'client';
                if (!this._deflate) {
                    const key = `${endpoint}_max_window_bits`;
                    const windowBits = 'number' != typeof this.params[key] ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
                    this._deflate = zlib.createDeflateRaw({
                        ...this._options.zlibDeflateOptions,
                        windowBits
                    });
                    this._deflate[kTotalLength] = 0;
                    this._deflate[kBuffers] = [];
                    this._deflate.on('data', deflateOnData);
                }
                this._deflate[kCallback] = callback;
                this._deflate.write(data);
                this._deflate.flush(zlib.Z_SYNC_FLUSH, ()=>{
                    if (!this._deflate) return;
                    let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
                    if (fin) data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
                    this._deflate[kCallback] = null;
                    this._deflate[kTotalLength] = 0;
                    this._deflate[kBuffers] = [];
                    if (fin && this.params[`${endpoint}_no_context_takeover`]) this._deflate.reset();
                    callback(null, data);
                });
            }
        }
        module.exports = PerMessageDeflate;
        function deflateOnData(chunk) {
            this[kBuffers].push(chunk);
            this[kTotalLength] += chunk.length;
        }
        function inflateOnData(chunk) {
            this[kTotalLength] += chunk.length;
            if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) return void this[kBuffers].push(chunk);
            this[kError] = new RangeError('Max payload size exceeded');
            this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
            this[kError][kStatusCode] = 1009;
            this.removeListener('data', inflateOnData);
            this.reset();
        }
        function inflateOnError(err) {
            this[kPerMessageDeflate]._inflate = null;
            err[kStatusCode] = 1007;
            this[kCallback](err);
        }
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/receiver.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const { Writable } = __webpack_require__("stream");
        const PerMessageDeflate = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/permessage-deflate.js");
        const { BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/constants.js");
        const { concat, toArrayBuffer, unmask } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/buffer-util.js");
        const { isValidStatusCode, isValidUTF8 } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/validation.js");
        const FastBuffer = Buffer[Symbol.species];
        const GET_INFO = 0;
        const GET_PAYLOAD_LENGTH_16 = 1;
        const GET_PAYLOAD_LENGTH_64 = 2;
        const GET_MASK = 3;
        const GET_DATA = 4;
        const INFLATING = 5;
        const DEFER_EVENT = 6;
        class Receiver extends Writable {
            constructor(options = {}){
                super();
                this._allowSynchronousEvents = void 0 !== options.allowSynchronousEvents ? options.allowSynchronousEvents : true;
                this._binaryType = options.binaryType || BINARY_TYPES[0];
                this._extensions = options.extensions || {};
                this._isServer = !!options.isServer;
                this._maxPayload = 0 | options.maxPayload;
                this._skipUTF8Validation = !!options.skipUTF8Validation;
                this[kWebSocket] = void 0;
                this._bufferedBytes = 0;
                this._buffers = [];
                this._compressed = false;
                this._payloadLength = 0;
                this._mask = void 0;
                this._fragmented = 0;
                this._masked = false;
                this._fin = false;
                this._opcode = 0;
                this._totalPayloadLength = 0;
                this._messageLength = 0;
                this._fragments = [];
                this._errored = false;
                this._loop = false;
                this._state = GET_INFO;
            }
            _write(chunk, encoding, cb) {
                if (0x08 === this._opcode && this._state == GET_INFO) return cb();
                this._bufferedBytes += chunk.length;
                this._buffers.push(chunk);
                this.startLoop(cb);
            }
            consume(n) {
                this._bufferedBytes -= n;
                if (n === this._buffers[0].length) return this._buffers.shift();
                if (n < this._buffers[0].length) {
                    const buf = this._buffers[0];
                    this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
                    return new FastBuffer(buf.buffer, buf.byteOffset, n);
                }
                const dst = Buffer.allocUnsafe(n);
                do {
                    const buf = this._buffers[0];
                    const offset = dst.length - n;
                    if (n >= buf.length) dst.set(this._buffers.shift(), offset);
                    else {
                        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
                        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
                    }
                    n -= buf.length;
                }while (n > 0);
                return dst;
            }
            startLoop(cb) {
                this._loop = true;
                do switch(this._state){
                    case GET_INFO:
                        this.getInfo(cb);
                        break;
                    case GET_PAYLOAD_LENGTH_16:
                        this.getPayloadLength16(cb);
                        break;
                    case GET_PAYLOAD_LENGTH_64:
                        this.getPayloadLength64(cb);
                        break;
                    case GET_MASK:
                        this.getMask();
                        break;
                    case GET_DATA:
                        this.getData(cb);
                        break;
                    case INFLATING:
                    case DEFER_EVENT:
                        this._loop = false;
                        return;
                }
                while (this._loop);
                if (!this._errored) cb();
            }
            getInfo(cb) {
                if (this._bufferedBytes < 2) {
                    this._loop = false;
                    return;
                }
                const buf = this.consume(2);
                if ((0x30 & buf[0]) !== 0x00) {
                    const error = this.createError(RangeError, 'RSV2 and RSV3 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_2_3');
                    cb(error);
                    return;
                }
                const compressed = (0x40 & buf[0]) === 0x40;
                if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
                    const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
                    cb(error);
                    return;
                }
                this._fin = (0x80 & buf[0]) === 0x80;
                this._opcode = 0x0f & buf[0];
                this._payloadLength = 0x7f & buf[1];
                if (0x00 === this._opcode) {
                    if (compressed) {
                        const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
                        cb(error);
                        return;
                    }
                    if (!this._fragmented) {
                        const error = this.createError(RangeError, 'invalid opcode 0', true, 1002, 'WS_ERR_INVALID_OPCODE');
                        cb(error);
                        return;
                    }
                    this._opcode = this._fragmented;
                } else if (0x01 === this._opcode || 0x02 === this._opcode) {
                    if (this._fragmented) {
                        const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');
                        cb(error);
                        return;
                    }
                    this._compressed = compressed;
                } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
                    if (!this._fin) {
                        const error = this.createError(RangeError, 'FIN must be set', true, 1002, 'WS_ERR_EXPECTED_FIN');
                        cb(error);
                        return;
                    }
                    if (compressed) {
                        const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
                        cb(error);
                        return;
                    }
                    if (this._payloadLength > 0x7d || 0x08 === this._opcode && 1 === this._payloadLength) {
                        const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');
                        cb(error);
                        return;
                    }
                } else {
                    const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');
                    cb(error);
                    return;
                }
                if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
                this._masked = (0x80 & buf[1]) === 0x80;
                if (this._isServer) {
                    if (!this._masked) {
                        const error = this.createError(RangeError, 'MASK must be set', true, 1002, 'WS_ERR_EXPECTED_MASK');
                        cb(error);
                        return;
                    }
                } else if (this._masked) {
                    const error = this.createError(RangeError, 'MASK must be clear', true, 1002, 'WS_ERR_UNEXPECTED_MASK');
                    cb(error);
                    return;
                }
                if (126 === this._payloadLength) this._state = GET_PAYLOAD_LENGTH_16;
                else if (127 === this._payloadLength) this._state = GET_PAYLOAD_LENGTH_64;
                else this.haveLength(cb);
            }
            getPayloadLength16(cb) {
                if (this._bufferedBytes < 2) {
                    this._loop = false;
                    return;
                }
                this._payloadLength = this.consume(2).readUInt16BE(0);
                this.haveLength(cb);
            }
            getPayloadLength64(cb) {
                if (this._bufferedBytes < 8) {
                    this._loop = false;
                    return;
                }
                const buf = this.consume(8);
                const num = buf.readUInt32BE(0);
                if (num > Math.pow(2, 21) - 1) {
                    const error = this.createError(RangeError, 'Unsupported WebSocket frame: payload length > 2^53 - 1', false, 1009, 'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH');
                    cb(error);
                    return;
                }
                this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
                this.haveLength(cb);
            }
            haveLength(cb) {
                if (this._payloadLength && this._opcode < 0x08) {
                    this._totalPayloadLength += this._payloadLength;
                    if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
                        const error = this.createError(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');
                        cb(error);
                        return;
                    }
                }
                if (this._masked) this._state = GET_MASK;
                else this._state = GET_DATA;
            }
            getMask() {
                if (this._bufferedBytes < 4) {
                    this._loop = false;
                    return;
                }
                this._mask = this.consume(4);
                this._state = GET_DATA;
            }
            getData(cb) {
                let data = EMPTY_BUFFER;
                if (this._payloadLength) {
                    if (this._bufferedBytes < this._payloadLength) {
                        this._loop = false;
                        return;
                    }
                    data = this.consume(this._payloadLength);
                    if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) unmask(data, this._mask);
                }
                if (this._opcode > 0x07) return void this.controlMessage(data, cb);
                if (this._compressed) {
                    this._state = INFLATING;
                    this.decompress(data, cb);
                    return;
                }
                if (data.length) {
                    this._messageLength = this._totalPayloadLength;
                    this._fragments.push(data);
                }
                this.dataMessage(cb);
            }
            decompress(data, cb) {
                const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
                perMessageDeflate.decompress(data, this._fin, (err, buf)=>{
                    if (err) return cb(err);
                    if (buf.length) {
                        this._messageLength += buf.length;
                        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
                            const error = this.createError(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');
                            cb(error);
                            return;
                        }
                        this._fragments.push(buf);
                    }
                    this.dataMessage(cb);
                    if (this._state === GET_INFO) this.startLoop(cb);
                });
            }
            dataMessage(cb) {
                if (!this._fin) {
                    this._state = GET_INFO;
                    return;
                }
                const messageLength = this._messageLength;
                const fragments = this._fragments;
                this._totalPayloadLength = 0;
                this._messageLength = 0;
                this._fragmented = 0;
                this._fragments = [];
                if (2 === this._opcode) {
                    let data;
                    data = 'nodebuffer' === this._binaryType ? concat(fragments, messageLength) : 'arraybuffer' === this._binaryType ? toArrayBuffer(concat(fragments, messageLength)) : fragments;
                    if (this._allowSynchronousEvents) {
                        this.emit('message', data, true);
                        this._state = GET_INFO;
                    } else {
                        this._state = DEFER_EVENT;
                        setImmediate(()=>{
                            this.emit('message', data, true);
                            this._state = GET_INFO;
                            this.startLoop(cb);
                        });
                    }
                } else {
                    const buf = concat(fragments, messageLength);
                    if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
                        const error = this.createError(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');
                        cb(error);
                        return;
                    }
                    if (this._state === INFLATING || this._allowSynchronousEvents) {
                        this.emit('message', buf, false);
                        this._state = GET_INFO;
                    } else {
                        this._state = DEFER_EVENT;
                        setImmediate(()=>{
                            this.emit('message', buf, false);
                            this._state = GET_INFO;
                            this.startLoop(cb);
                        });
                    }
                }
            }
            controlMessage(data, cb) {
                if (0x08 === this._opcode) {
                    if (0 === data.length) {
                        this._loop = false;
                        this.emit('conclude', 1005, EMPTY_BUFFER);
                        this.end();
                    } else {
                        const code = data.readUInt16BE(0);
                        if (!isValidStatusCode(code)) {
                            const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, 'WS_ERR_INVALID_CLOSE_CODE');
                            cb(error);
                            return;
                        }
                        const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
                        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
                            const error = this.createError(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');
                            cb(error);
                            return;
                        }
                        this._loop = false;
                        this.emit('conclude', code, buf);
                        this.end();
                    }
                    this._state = GET_INFO;
                    return;
                }
                if (this._allowSynchronousEvents) {
                    this.emit(0x09 === this._opcode ? 'ping' : 'pong', data);
                    this._state = GET_INFO;
                } else {
                    this._state = DEFER_EVENT;
                    setImmediate(()=>{
                        this.emit(0x09 === this._opcode ? 'ping' : 'pong', data);
                        this._state = GET_INFO;
                        this.startLoop(cb);
                    });
                }
            }
            createError(ErrorCtor, message, prefix, statusCode, errorCode) {
                this._loop = false;
                this._errored = true;
                const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
                Error.captureStackTrace(err, this.createError);
                err.code = errorCode;
                err[kStatusCode] = statusCode;
                return err;
            }
        }
        module.exports = Receiver;
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/sender.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const { Duplex } = __webpack_require__("stream");
        const { randomFillSync } = __webpack_require__("crypto");
        const PerMessageDeflate = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/permessage-deflate.js");
        const { EMPTY_BUFFER } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/constants.js");
        const { isValidStatusCode } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/validation.js");
        const { mask: applyMask, toBuffer } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/buffer-util.js");
        const kByteLength = Symbol('kByteLength');
        const maskBuffer = Buffer.alloc(4);
        const RANDOM_POOL_SIZE = 8192;
        let randomPool;
        let randomPoolPointer = RANDOM_POOL_SIZE;
        class Sender {
            constructor(socket, extensions, generateMask){
                this._extensions = extensions || {};
                if (generateMask) {
                    this._generateMask = generateMask;
                    this._maskBuffer = Buffer.alloc(4);
                }
                this._socket = socket;
                this._firstFragment = true;
                this._compress = false;
                this._bufferedBytes = 0;
                this._deflating = false;
                this._queue = [];
            }
            static frame(data, options) {
                let mask;
                let merge = false;
                let offset = 2;
                let skipMasking = false;
                if (options.mask) {
                    mask = options.maskBuffer || maskBuffer;
                    if (options.generateMask) options.generateMask(mask);
                    else {
                        if (randomPoolPointer === RANDOM_POOL_SIZE) {
                            if (void 0 === randomPool) randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
                            randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
                            randomPoolPointer = 0;
                        }
                        mask[0] = randomPool[randomPoolPointer++];
                        mask[1] = randomPool[randomPoolPointer++];
                        mask[2] = randomPool[randomPoolPointer++];
                        mask[3] = randomPool[randomPoolPointer++];
                    }
                    skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
                    offset = 6;
                }
                let dataLength;
                if ('string' == typeof data) if ((!options.mask || skipMasking) && void 0 !== options[kByteLength]) dataLength = options[kByteLength];
                else {
                    data = Buffer.from(data);
                    dataLength = data.length;
                }
                else {
                    dataLength = data.length;
                    merge = options.mask && options.readOnly && !skipMasking;
                }
                let payloadLength = dataLength;
                if (dataLength >= 65536) {
                    offset += 8;
                    payloadLength = 127;
                } else if (dataLength > 125) {
                    offset += 2;
                    payloadLength = 126;
                }
                const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
                target[0] = options.fin ? 0x80 | options.opcode : options.opcode;
                if (options.rsv1) target[0] |= 0x40;
                target[1] = payloadLength;
                if (126 === payloadLength) target.writeUInt16BE(dataLength, 2);
                else if (127 === payloadLength) {
                    target[2] = target[3] = 0;
                    target.writeUIntBE(dataLength, 4, 6);
                }
                if (!options.mask) return [
                    target,
                    data
                ];
                target[1] |= 0x80;
                target[offset - 4] = mask[0];
                target[offset - 3] = mask[1];
                target[offset - 2] = mask[2];
                target[offset - 1] = mask[3];
                if (skipMasking) return [
                    target,
                    data
                ];
                if (merge) {
                    applyMask(data, mask, target, offset, dataLength);
                    return [
                        target
                    ];
                }
                applyMask(data, mask, data, 0, dataLength);
                return [
                    target,
                    data
                ];
            }
            close(code, data, mask, cb) {
                let buf;
                if (void 0 === code) buf = EMPTY_BUFFER;
                else if ('number' == typeof code && isValidStatusCode(code)) if (void 0 !== data && data.length) {
                    const length = Buffer.byteLength(data);
                    if (length > 123) throw new RangeError('The message must not be greater than 123 bytes');
                    buf = Buffer.allocUnsafe(2 + length);
                    buf.writeUInt16BE(code, 0);
                    if ('string' == typeof data) buf.write(data, 2);
                    else buf.set(data, 2);
                } else {
                    buf = Buffer.allocUnsafe(2);
                    buf.writeUInt16BE(code, 0);
                }
                else throw new TypeError('First argument must be a valid error code number');
                const options = {
                    [kByteLength]: buf.length,
                    fin: true,
                    generateMask: this._generateMask,
                    mask,
                    maskBuffer: this._maskBuffer,
                    opcode: 0x08,
                    readOnly: false,
                    rsv1: false
                };
                if (this._deflating) this.enqueue([
                    this.dispatch,
                    buf,
                    false,
                    options,
                    cb
                ]);
                else this.sendFrame(Sender.frame(buf, options), cb);
            }
            ping(data, mask, cb) {
                let byteLength;
                let readOnly;
                if ('string' == typeof data) {
                    byteLength = Buffer.byteLength(data);
                    readOnly = false;
                } else {
                    data = toBuffer(data);
                    byteLength = data.length;
                    readOnly = toBuffer.readOnly;
                }
                if (byteLength > 125) throw new RangeError('The data size must not be greater than 125 bytes');
                const options = {
                    [kByteLength]: byteLength,
                    fin: true,
                    generateMask: this._generateMask,
                    mask,
                    maskBuffer: this._maskBuffer,
                    opcode: 0x09,
                    readOnly,
                    rsv1: false
                };
                if (this._deflating) this.enqueue([
                    this.dispatch,
                    data,
                    false,
                    options,
                    cb
                ]);
                else this.sendFrame(Sender.frame(data, options), cb);
            }
            pong(data, mask, cb) {
                let byteLength;
                let readOnly;
                if ('string' == typeof data) {
                    byteLength = Buffer.byteLength(data);
                    readOnly = false;
                } else {
                    data = toBuffer(data);
                    byteLength = data.length;
                    readOnly = toBuffer.readOnly;
                }
                if (byteLength > 125) throw new RangeError('The data size must not be greater than 125 bytes');
                const options = {
                    [kByteLength]: byteLength,
                    fin: true,
                    generateMask: this._generateMask,
                    mask,
                    maskBuffer: this._maskBuffer,
                    opcode: 0x0a,
                    readOnly,
                    rsv1: false
                };
                if (this._deflating) this.enqueue([
                    this.dispatch,
                    data,
                    false,
                    options,
                    cb
                ]);
                else this.sendFrame(Sender.frame(data, options), cb);
            }
            send(data, options, cb) {
                const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
                let opcode = options.binary ? 2 : 1;
                let rsv1 = options.compress;
                let byteLength;
                let readOnly;
                if ('string' == typeof data) {
                    byteLength = Buffer.byteLength(data);
                    readOnly = false;
                } else {
                    data = toBuffer(data);
                    byteLength = data.length;
                    readOnly = toBuffer.readOnly;
                }
                if (this._firstFragment) {
                    this._firstFragment = false;
                    if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? 'server_no_context_takeover' : 'client_no_context_takeover']) rsv1 = byteLength >= perMessageDeflate._threshold;
                    this._compress = rsv1;
                } else {
                    rsv1 = false;
                    opcode = 0;
                }
                if (options.fin) this._firstFragment = true;
                if (perMessageDeflate) {
                    const opts = {
                        [kByteLength]: byteLength,
                        fin: options.fin,
                        generateMask: this._generateMask,
                        mask: options.mask,
                        maskBuffer: this._maskBuffer,
                        opcode,
                        readOnly,
                        rsv1
                    };
                    if (this._deflating) this.enqueue([
                        this.dispatch,
                        data,
                        this._compress,
                        opts,
                        cb
                    ]);
                    else this.dispatch(data, this._compress, opts, cb);
                } else this.sendFrame(Sender.frame(data, {
                    [kByteLength]: byteLength,
                    fin: options.fin,
                    generateMask: this._generateMask,
                    mask: options.mask,
                    maskBuffer: this._maskBuffer,
                    opcode,
                    readOnly,
                    rsv1: false
                }), cb);
            }
            dispatch(data, compress, options, cb) {
                if (!compress) return void this.sendFrame(Sender.frame(data, options), cb);
                const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
                this._bufferedBytes += options[kByteLength];
                this._deflating = true;
                perMessageDeflate.compress(data, options.fin, (_, buf)=>{
                    if (this._socket.destroyed) {
                        const err = new Error('The socket was closed while data was being compressed');
                        if ('function' == typeof cb) cb(err);
                        for(let i = 0; i < this._queue.length; i++){
                            const params = this._queue[i];
                            const callback = params[params.length - 1];
                            if ('function' == typeof callback) callback(err);
                        }
                        return;
                    }
                    this._bufferedBytes -= options[kByteLength];
                    this._deflating = false;
                    options.readOnly = false;
                    this.sendFrame(Sender.frame(buf, options), cb);
                    this.dequeue();
                });
            }
            dequeue() {
                while(!this._deflating && this._queue.length){
                    const params = this._queue.shift();
                    this._bufferedBytes -= params[3][kByteLength];
                    Reflect.apply(params[0], this, params.slice(1));
                }
            }
            enqueue(params) {
                this._bufferedBytes += params[3][kByteLength];
                this._queue.push(params);
            }
            sendFrame(list, cb) {
                if (2 === list.length) {
                    this._socket.cork();
                    this._socket.write(list[0]);
                    this._socket.write(list[1], cb);
                    this._socket.uncork();
                } else this._socket.write(list[0], cb);
            }
        }
        module.exports = Sender;
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/stream.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const { Duplex } = __webpack_require__("stream");
        function emitClose(stream) {
            stream.emit('close');
        }
        function duplexOnEnd() {
            if (!this.destroyed && this._writableState.finished) this.destroy();
        }
        function duplexOnError(err) {
            this.removeListener('error', duplexOnError);
            this.destroy();
            if (0 === this.listenerCount('error')) this.emit('error', err);
        }
        function createWebSocketStream(ws, options) {
            let terminateOnDestroy = true;
            const duplex = new Duplex({
                ...options,
                autoDestroy: false,
                emitClose: false,
                objectMode: false,
                writableObjectMode: false
            });
            ws.on('message', function(msg, isBinary) {
                const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
                if (!duplex.push(data)) ws.pause();
            });
            ws.once('error', function(err) {
                if (duplex.destroyed) return;
                terminateOnDestroy = false;
                duplex.destroy(err);
            });
            ws.once('close', function() {
                if (duplex.destroyed) return;
                duplex.push(null);
            });
            duplex._destroy = function(err, callback) {
                if (ws.readyState === ws.CLOSED) {
                    callback(err);
                    process.nextTick(emitClose, duplex);
                    return;
                }
                let called = false;
                ws.once('error', function(err) {
                    called = true;
                    callback(err);
                });
                ws.once('close', function() {
                    if (!called) callback(err);
                    process.nextTick(emitClose, duplex);
                });
                if (terminateOnDestroy) ws.terminate();
            };
            duplex._final = function(callback) {
                if (ws.readyState === ws.CONNECTING) return void ws.once('open', function() {
                    duplex._final(callback);
                });
                if (null === ws._socket) return;
                if (ws._socket._writableState.finished) {
                    callback();
                    if (duplex._readableState.endEmitted) duplex.destroy();
                } else {
                    ws._socket.once('finish', function() {
                        callback();
                    });
                    ws.close();
                }
            };
            duplex._read = function() {
                if (ws.isPaused) ws.resume();
            };
            duplex._write = function(chunk, encoding, callback) {
                if (ws.readyState === ws.CONNECTING) return void ws.once('open', function() {
                    duplex._write(chunk, encoding, callback);
                });
                ws.send(chunk, callback);
            };
            duplex.on('end', duplexOnEnd);
            duplex.on('error', duplexOnError);
            return duplex;
        }
        module.exports = createWebSocketStream;
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/subprotocol.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const { tokenChars } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/validation.js");
        function parse(header) {
            const protocols = new Set();
            let start = -1;
            let end = -1;
            let i = 0;
            for(i; i < header.length; i++){
                const code = header.charCodeAt(i);
                if (-1 === end && 1 === tokenChars[code]) {
                    if (-1 === start) start = i;
                } else if (0 !== i && (0x20 === code || 0x09 === code)) {
                    if (-1 === end && -1 !== start) end = i;
                } else if (0x2c === code) {
                    if (-1 === start) throw new SyntaxError(`Unexpected character at index ${i}`);
                    if (-1 === end) end = i;
                    const protocol = header.slice(start, end);
                    if (protocols.has(protocol)) throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
                    protocols.add(protocol);
                    start = end = -1;
                } else throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (-1 === start || -1 !== end) throw new SyntaxError('Unexpected end of input');
            const protocol = header.slice(start, i);
            if (protocols.has(protocol)) throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
            protocols.add(protocol);
            return protocols;
        }
        module.exports = {
            parse
        };
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/validation.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const { isUtf8 } = __webpack_require__("buffer");
        const tokenChars = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            1,
            0,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            0,
            1,
            0
        ];
        function isValidStatusCode(code) {
            return code >= 1000 && code <= 1014 && 1004 !== code && 1005 !== code && 1006 !== code || code >= 3000 && code <= 4999;
        }
        function _isValidUTF8(buf) {
            const len = buf.length;
            let i = 0;
            while(i < len)if ((0x80 & buf[i]) === 0) i++;
            else if ((0xe0 & buf[i]) === 0xc0) {
                if (i + 1 === len || (0xc0 & buf[i + 1]) !== 0x80 || (0xfe & buf[i]) === 0xc0) return false;
                i += 2;
            } else if ((0xf0 & buf[i]) === 0xe0) {
                if (i + 2 >= len || (0xc0 & buf[i + 1]) !== 0x80 || (0xc0 & buf[i + 2]) !== 0x80 || 0xe0 === buf[i] && (0xe0 & buf[i + 1]) === 0x80 || 0xed === buf[i] && (0xe0 & buf[i + 1]) === 0xa0) return false;
                i += 3;
            } else {
                if ((0xf8 & buf[i]) !== 0xf0) return false;
                if (i + 3 >= len || (0xc0 & buf[i + 1]) !== 0x80 || (0xc0 & buf[i + 2]) !== 0x80 || (0xc0 & buf[i + 3]) !== 0x80 || 0xf0 === buf[i] && (0xf0 & buf[i + 1]) === 0x80 || 0xf4 === buf[i] && buf[i + 1] > 0x8f || buf[i] > 0xf4) return false;
                i += 4;
            }
            return true;
        }
        module.exports = {
            isValidStatusCode,
            isValidUTF8: _isValidUTF8,
            tokenChars
        };
        if (isUtf8) module.exports.isValidUTF8 = function(buf) {
            return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
        };
        else if (!process.env.WS_NO_UTF_8_VALIDATE) try {
            const isValidUTF8 = __webpack_require__("../../node_modules/utf-8-validate/index.js");
            module.exports.isValidUTF8 = function(buf) {
                return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
            };
        } catch (e) {}
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/websocket-server.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const EventEmitter = __webpack_require__("events");
        const http = __webpack_require__("http");
        const { Duplex } = __webpack_require__("stream");
        const { createHash } = __webpack_require__("crypto");
        const extension = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/extension.js");
        const PerMessageDeflate = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/permessage-deflate.js");
        const subprotocol = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/subprotocol.js");
        const WebSocket = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/websocket.js");
        const { GUID, kWebSocket } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/constants.js");
        const keyRegex = /^[+/0-9A-Za-z]{22}==$/;
        const RUNNING = 0;
        const CLOSING = 1;
        const CLOSED = 2;
        class WebSocketServer extends EventEmitter {
            constructor(options, callback){
                super();
                options = {
                    allowSynchronousEvents: true,
                    autoPong: true,
                    maxPayload: 104857600,
                    skipUTF8Validation: false,
                    perMessageDeflate: false,
                    handleProtocols: null,
                    clientTracking: true,
                    verifyClient: null,
                    noServer: false,
                    backlog: null,
                    server: null,
                    host: null,
                    path: null,
                    port: null,
                    WebSocket,
                    ...options
                };
                if (null == options.port && !options.server && !options.noServer || null != options.port && (options.server || options.noServer) || options.server && options.noServer) throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
                if (null != options.port) {
                    this._server = http.createServer((req, res)=>{
                        const body = http.STATUS_CODES[426];
                        res.writeHead(426, {
                            'Content-Length': body.length,
                            'Content-Type': 'text/plain'
                        });
                        res.end(body);
                    });
                    this._server.listen(options.port, options.host, options.backlog, callback);
                } else if (options.server) this._server = options.server;
                if (this._server) {
                    const emitConnection = this.emit.bind(this, 'connection');
                    this._removeListeners = addListeners(this._server, {
                        listening: this.emit.bind(this, 'listening'),
                        error: this.emit.bind(this, 'error'),
                        upgrade: (req, socket, head)=>{
                            this.handleUpgrade(req, socket, head, emitConnection);
                        }
                    });
                }
                if (true === options.perMessageDeflate) options.perMessageDeflate = {};
                if (options.clientTracking) {
                    this.clients = new Set();
                    this._shouldEmitClose = false;
                }
                this.options = options;
                this._state = RUNNING;
            }
            address() {
                if (this.options.noServer) throw new Error('The server is operating in "noServer" mode');
                if (!this._server) return null;
                return this._server.address();
            }
            close(cb) {
                if (this._state === CLOSED) {
                    if (cb) this.once('close', ()=>{
                        cb(new Error('The server is not running'));
                    });
                    process.nextTick(emitClose, this);
                    return;
                }
                if (cb) this.once('close', cb);
                if (this._state === CLOSING) return;
                this._state = CLOSING;
                if (this.options.noServer || this.options.server) {
                    if (this._server) {
                        this._removeListeners();
                        this._removeListeners = this._server = null;
                    }
                    if (this.clients) if (this.clients.size) this._shouldEmitClose = true;
                    else process.nextTick(emitClose, this);
                    else process.nextTick(emitClose, this);
                } else {
                    const server = this._server;
                    this._removeListeners();
                    this._removeListeners = this._server = null;
                    server.close(()=>{
                        emitClose(this);
                    });
                }
            }
            shouldHandle(req) {
                if (this.options.path) {
                    const index = req.url.indexOf('?');
                    const pathname = -1 !== index ? req.url.slice(0, index) : req.url;
                    if (pathname !== this.options.path) return false;
                }
                return true;
            }
            handleUpgrade(req, socket, head, cb) {
                socket.on('error', socketOnError);
                const key = req.headers['sec-websocket-key'];
                const upgrade = req.headers.upgrade;
                const version = +req.headers['sec-websocket-version'];
                if ('GET' !== req.method) {
                    const message = 'Invalid HTTP method';
                    abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
                    return;
                }
                if (void 0 === upgrade || 'websocket' !== upgrade.toLowerCase()) {
                    const message = 'Invalid Upgrade header';
                    abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
                    return;
                }
                if (void 0 === key || !keyRegex.test(key)) {
                    const message = 'Missing or invalid Sec-WebSocket-Key header';
                    abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
                    return;
                }
                if (8 !== version && 13 !== version) {
                    const message = 'Missing or invalid Sec-WebSocket-Version header';
                    abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
                    return;
                }
                if (!this.shouldHandle(req)) return void abortHandshake(socket, 400);
                const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
                let protocols = new Set();
                if (void 0 !== secWebSocketProtocol) try {
                    protocols = subprotocol.parse(secWebSocketProtocol);
                } catch (err) {
                    const message = 'Invalid Sec-WebSocket-Protocol header';
                    abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
                    return;
                }
                const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
                const extensions = {};
                if (this.options.perMessageDeflate && void 0 !== secWebSocketExtensions) {
                    const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
                    try {
                        const offers = extension.parse(secWebSocketExtensions);
                        if (offers[PerMessageDeflate.extensionName]) {
                            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
                            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
                        }
                    } catch (err) {
                        const message = 'Invalid or unacceptable Sec-WebSocket-Extensions header';
                        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
                        return;
                    }
                }
                if (this.options.verifyClient) {
                    const info = {
                        origin: req.headers[`${8 === version ? 'sec-websocket-origin' : 'origin'}`],
                        secure: !!(req.socket.authorized || req.socket.encrypted),
                        req
                    };
                    if (2 === this.options.verifyClient.length) return void this.options.verifyClient(info, (verified, code, message, headers)=>{
                        if (!verified) return abortHandshake(socket, code || 401, message, headers);
                        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
                    });
                    if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
                }
                this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
            }
            completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
                if (!socket.readable || !socket.writable) return socket.destroy();
                if (socket[kWebSocket]) throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
                if (this._state > RUNNING) return abortHandshake(socket, 503);
                const digest = createHash('sha1').update(key + GUID).digest('base64');
                const headers = [
                    'HTTP/1.1 101 Switching Protocols',
                    'Upgrade: websocket',
                    'Connection: Upgrade',
                    `Sec-WebSocket-Accept: ${digest}`
                ];
                const ws = new this.options.WebSocket(null, void 0, this.options);
                if (protocols.size) {
                    const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
                    if (protocol) {
                        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
                        ws._protocol = protocol;
                    }
                }
                if (extensions[PerMessageDeflate.extensionName]) {
                    const params = extensions[PerMessageDeflate.extensionName].params;
                    const value = extension.format({
                        [PerMessageDeflate.extensionName]: [
                            params
                        ]
                    });
                    headers.push(`Sec-WebSocket-Extensions: ${value}`);
                    ws._extensions = extensions;
                }
                this.emit('headers', headers, req);
                socket.write(headers.concat('\r\n').join('\r\n'));
                socket.removeListener('error', socketOnError);
                ws.setSocket(socket, head, {
                    allowSynchronousEvents: this.options.allowSynchronousEvents,
                    maxPayload: this.options.maxPayload,
                    skipUTF8Validation: this.options.skipUTF8Validation
                });
                if (this.clients) {
                    this.clients.add(ws);
                    ws.on('close', ()=>{
                        this.clients.delete(ws);
                        if (this._shouldEmitClose && !this.clients.size) process.nextTick(emitClose, this);
                    });
                }
                cb(ws, req);
            }
        }
        module.exports = WebSocketServer;
        function addListeners(server, map) {
            for (const event of Object.keys(map))server.on(event, map[event]);
            return function() {
                for (const event of Object.keys(map))server.removeListener(event, map[event]);
            };
        }
        function emitClose(server) {
            server._state = CLOSED;
            server.emit('close');
        }
        function socketOnError() {
            this.destroy();
        }
        function abortHandshake(socket, code, message, headers) {
            message = message || http.STATUS_CODES[code];
            headers = {
                Connection: 'close',
                'Content-Type': 'text/html',
                'Content-Length': Buffer.byteLength(message),
                ...headers
            };
            socket.once('finish', socket.destroy);
            socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` + Object.keys(headers).map((h)=>`${h}: ${headers[h]}`).join('\r\n') + '\r\n\r\n' + message);
        }
        function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
            if (server.listenerCount('wsClientError')) {
                const err = new Error(message);
                Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
                server.emit('wsClientError', err, socket, req);
            } else abortHandshake(socket, code, message);
        }
    },
    "../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/websocket.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const EventEmitter = __webpack_require__("events");
        const https = __webpack_require__("https");
        const http = __webpack_require__("http");
        const net = __webpack_require__("net");
        const tls = __webpack_require__("tls");
        const { randomBytes, createHash } = __webpack_require__("crypto");
        const { Duplex, Readable } = __webpack_require__("stream");
        const { URL: URL1 } = __webpack_require__("url");
        const PerMessageDeflate = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/permessage-deflate.js");
        const Receiver = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/receiver.js");
        const Sender = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/sender.js");
        const { BINARY_TYPES, EMPTY_BUFFER, GUID, kForOnEventAttribute, kListener, kStatusCode, kWebSocket, NOOP } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/constants.js");
        const { EventTarget: { addEventListener, removeEventListener } } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/event-target.js");
        const { format, parse } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/extension.js");
        const { toBuffer } = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/lib/buffer-util.js");
        const closeTimeout = 30000;
        const kAborted = Symbol('kAborted');
        const protocolVersions = [
            8,
            13
        ];
        const readyStates = [
            'CONNECTING',
            'OPEN',
            'CLOSING',
            'CLOSED'
        ];
        const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
        class WebSocket extends EventEmitter {
            constructor(address, protocols, options){
                super();
                this._binaryType = BINARY_TYPES[0];
                this._closeCode = 1006;
                this._closeFrameReceived = false;
                this._closeFrameSent = false;
                this._closeMessage = EMPTY_BUFFER;
                this._closeTimer = null;
                this._extensions = {};
                this._paused = false;
                this._protocol = '';
                this._readyState = WebSocket.CONNECTING;
                this._receiver = null;
                this._sender = null;
                this._socket = null;
                if (null !== address) {
                    this._bufferedAmount = 0;
                    this._isServer = false;
                    this._redirects = 0;
                    if (void 0 === protocols) protocols = [];
                    else if (!Array.isArray(protocols)) if ('object' == typeof protocols && null !== protocols) {
                        options = protocols;
                        protocols = [];
                    } else protocols = [
                        protocols
                    ];
                    initAsClient(this, address, protocols, options);
                } else {
                    this._autoPong = options.autoPong;
                    this._isServer = true;
                }
            }
            get binaryType() {
                return this._binaryType;
            }
            set binaryType(type) {
                if (!BINARY_TYPES.includes(type)) return;
                this._binaryType = type;
                if (this._receiver) this._receiver._binaryType = type;
            }
            get bufferedAmount() {
                if (!this._socket) return this._bufferedAmount;
                return this._socket._writableState.length + this._sender._bufferedBytes;
            }
            get extensions() {
                return Object.keys(this._extensions).join();
            }
            get isPaused() {
                return this._paused;
            }
            get onclose() {
                return null;
            }
            get onerror() {
                return null;
            }
            get onopen() {
                return null;
            }
            get onmessage() {
                return null;
            }
            get protocol() {
                return this._protocol;
            }
            get readyState() {
                return this._readyState;
            }
            get url() {
                return this._url;
            }
            setSocket(socket, head, options) {
                const receiver = new Receiver({
                    allowSynchronousEvents: options.allowSynchronousEvents,
                    binaryType: this.binaryType,
                    extensions: this._extensions,
                    isServer: this._isServer,
                    maxPayload: options.maxPayload,
                    skipUTF8Validation: options.skipUTF8Validation
                });
                this._sender = new Sender(socket, this._extensions, options.generateMask);
                this._receiver = receiver;
                this._socket = socket;
                receiver[kWebSocket] = this;
                socket[kWebSocket] = this;
                receiver.on('conclude', receiverOnConclude);
                receiver.on('drain', receiverOnDrain);
                receiver.on('error', receiverOnError);
                receiver.on('message', receiverOnMessage);
                receiver.on('ping', receiverOnPing);
                receiver.on('pong', receiverOnPong);
                if (socket.setTimeout) socket.setTimeout(0);
                if (socket.setNoDelay) socket.setNoDelay();
                if (head.length > 0) socket.unshift(head);
                socket.on('close', socketOnClose);
                socket.on('data', socketOnData);
                socket.on('end', socketOnEnd);
                socket.on('error', socketOnError);
                this._readyState = WebSocket.OPEN;
                this.emit('open');
            }
            emitClose() {
                if (!this._socket) {
                    this._readyState = WebSocket.CLOSED;
                    this.emit('close', this._closeCode, this._closeMessage);
                    return;
                }
                if (this._extensions[PerMessageDeflate.extensionName]) this._extensions[PerMessageDeflate.extensionName].cleanup();
                this._receiver.removeAllListeners();
                this._readyState = WebSocket.CLOSED;
                this.emit('close', this._closeCode, this._closeMessage);
            }
            close(code, data) {
                if (this.readyState === WebSocket.CLOSED) return;
                if (this.readyState === WebSocket.CONNECTING) {
                    const msg = 'WebSocket was closed before the connection was established';
                    abortHandshake(this, this._req, msg);
                    return;
                }
                if (this.readyState === WebSocket.CLOSING) {
                    if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) this._socket.end();
                    return;
                }
                this._readyState = WebSocket.CLOSING;
                this._sender.close(code, data, !this._isServer, (err)=>{
                    if (err) return;
                    this._closeFrameSent = true;
                    if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) this._socket.end();
                });
                this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
            }
            pause() {
                if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) return;
                this._paused = true;
                this._socket.pause();
            }
            ping(data, mask, cb) {
                if (this.readyState === WebSocket.CONNECTING) throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
                if ('function' == typeof data) {
                    cb = data;
                    data = mask = void 0;
                } else if ('function' == typeof mask) {
                    cb = mask;
                    mask = void 0;
                }
                if ('number' == typeof data) data = data.toString();
                if (this.readyState !== WebSocket.OPEN) return void sendAfterClose(this, data, cb);
                if (void 0 === mask) mask = !this._isServer;
                this._sender.ping(data || EMPTY_BUFFER, mask, cb);
            }
            pong(data, mask, cb) {
                if (this.readyState === WebSocket.CONNECTING) throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
                if ('function' == typeof data) {
                    cb = data;
                    data = mask = void 0;
                } else if ('function' == typeof mask) {
                    cb = mask;
                    mask = void 0;
                }
                if ('number' == typeof data) data = data.toString();
                if (this.readyState !== WebSocket.OPEN) return void sendAfterClose(this, data, cb);
                if (void 0 === mask) mask = !this._isServer;
                this._sender.pong(data || EMPTY_BUFFER, mask, cb);
            }
            resume() {
                if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) return;
                this._paused = false;
                if (!this._receiver._writableState.needDrain) this._socket.resume();
            }
            send(data, options, cb) {
                if (this.readyState === WebSocket.CONNECTING) throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
                if ('function' == typeof options) {
                    cb = options;
                    options = {};
                }
                if ('number' == typeof data) data = data.toString();
                if (this.readyState !== WebSocket.OPEN) return void sendAfterClose(this, data, cb);
                const opts = {
                    binary: 'string' != typeof data,
                    mask: !this._isServer,
                    compress: true,
                    fin: true,
                    ...options
                };
                if (!this._extensions[PerMessageDeflate.extensionName]) opts.compress = false;
                this._sender.send(data || EMPTY_BUFFER, opts, cb);
            }
            terminate() {
                if (this.readyState === WebSocket.CLOSED) return;
                if (this.readyState === WebSocket.CONNECTING) {
                    const msg = 'WebSocket was closed before the connection was established';
                    abortHandshake(this, this._req, msg);
                    return;
                }
                if (this._socket) {
                    this._readyState = WebSocket.CLOSING;
                    this._socket.destroy();
                }
            }
        }
        Object.defineProperty(WebSocket, 'CONNECTING', {
            enumerable: true,
            value: readyStates.indexOf('CONNECTING')
        });
        Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
            enumerable: true,
            value: readyStates.indexOf('CONNECTING')
        });
        Object.defineProperty(WebSocket, 'OPEN', {
            enumerable: true,
            value: readyStates.indexOf('OPEN')
        });
        Object.defineProperty(WebSocket.prototype, 'OPEN', {
            enumerable: true,
            value: readyStates.indexOf('OPEN')
        });
        Object.defineProperty(WebSocket, 'CLOSING', {
            enumerable: true,
            value: readyStates.indexOf('CLOSING')
        });
        Object.defineProperty(WebSocket.prototype, 'CLOSING', {
            enumerable: true,
            value: readyStates.indexOf('CLOSING')
        });
        Object.defineProperty(WebSocket, 'CLOSED', {
            enumerable: true,
            value: readyStates.indexOf('CLOSED')
        });
        Object.defineProperty(WebSocket.prototype, 'CLOSED', {
            enumerable: true,
            value: readyStates.indexOf('CLOSED')
        });
        [
            'binaryType',
            'bufferedAmount',
            'extensions',
            'isPaused',
            'protocol',
            'readyState',
            'url'
        ].forEach((property)=>{
            Object.defineProperty(WebSocket.prototype, property, {
                enumerable: true
            });
        });
        [
            'open',
            'error',
            'close',
            'message'
        ].forEach((method)=>{
            Object.defineProperty(WebSocket.prototype, `on${method}`, {
                enumerable: true,
                get () {
                    for (const listener of this.listeners(method))if (listener[kForOnEventAttribute]) return listener[kListener];
                    return null;
                },
                set (handler) {
                    for (const listener of this.listeners(method))if (listener[kForOnEventAttribute]) {
                        this.removeListener(method, listener);
                        break;
                    }
                    if ('function' != typeof handler) return;
                    this.addEventListener(method, handler, {
                        [kForOnEventAttribute]: true
                    });
                }
            });
        });
        WebSocket.prototype.addEventListener = addEventListener;
        WebSocket.prototype.removeEventListener = removeEventListener;
        module.exports = WebSocket;
        function initAsClient(websocket, address, protocols, options) {
            const opts = {
                allowSynchronousEvents: true,
                autoPong: true,
                protocolVersion: protocolVersions[1],
                maxPayload: 104857600,
                skipUTF8Validation: false,
                perMessageDeflate: true,
                followRedirects: false,
                maxRedirects: 10,
                ...options,
                socketPath: void 0,
                hostname: void 0,
                protocol: void 0,
                timeout: void 0,
                method: 'GET',
                host: void 0,
                path: void 0,
                port: void 0
            };
            websocket._autoPong = opts.autoPong;
            if (!protocolVersions.includes(opts.protocolVersion)) throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(', ')})`);
            let parsedUrl;
            if (address instanceof URL1) parsedUrl = address;
            else try {
                parsedUrl = new URL1(address);
            } catch (e) {
                throw new SyntaxError(`Invalid URL: ${address}`);
            }
            if ('http:' === parsedUrl.protocol) parsedUrl.protocol = 'ws:';
            else if ('https:' === parsedUrl.protocol) parsedUrl.protocol = 'wss:';
            websocket._url = parsedUrl.href;
            const isSecure = 'wss:' === parsedUrl.protocol;
            const isIpcUrl = 'ws+unix:' === parsedUrl.protocol;
            let invalidUrlMessage;
            if ('ws:' === parsedUrl.protocol || isSecure || isIpcUrl) {
                if (isIpcUrl && !parsedUrl.pathname) invalidUrlMessage = "The URL's pathname is empty";
                else if (parsedUrl.hash) invalidUrlMessage = 'The URL contains a fragment identifier';
            } else invalidUrlMessage = 'The URL\'s protocol must be one of "ws:", "wss:", "http:", "https", or "ws+unix:"';
            if (invalidUrlMessage) {
                const err = new SyntaxError(invalidUrlMessage);
                if (0 !== websocket._redirects) return void emitErrorAndClose(websocket, err);
                throw err;
            }
            const defaultPort = isSecure ? 443 : 80;
            const key = randomBytes(16).toString('base64');
            const request = isSecure ? https.request : http.request;
            const protocolSet = new Set();
            let perMessageDeflate;
            opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
            opts.defaultPort = opts.defaultPort || defaultPort;
            opts.port = parsedUrl.port || defaultPort;
            opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
            opts.headers = {
                ...opts.headers,
                'Sec-WebSocket-Version': opts.protocolVersion,
                'Sec-WebSocket-Key': key,
                Connection: 'Upgrade',
                Upgrade: 'websocket'
            };
            opts.path = parsedUrl.pathname + parsedUrl.search;
            opts.timeout = opts.handshakeTimeout;
            if (opts.perMessageDeflate) {
                perMessageDeflate = new PerMessageDeflate(true !== opts.perMessageDeflate ? opts.perMessageDeflate : {}, false, opts.maxPayload);
                opts.headers['Sec-WebSocket-Extensions'] = format({
                    [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
                });
            }
            if (protocols.length) {
                for (const protocol of protocols){
                    if ('string' != typeof protocol || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) throw new SyntaxError('An invalid or duplicated subprotocol was specified');
                    protocolSet.add(protocol);
                }
                opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
            }
            if (opts.origin) if (opts.protocolVersion < 13) opts.headers['Sec-WebSocket-Origin'] = opts.origin;
            else opts.headers.Origin = opts.origin;
            if (parsedUrl.username || parsedUrl.password) opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
            if (isIpcUrl) {
                const parts = opts.path.split(':');
                opts.socketPath = parts[0];
                opts.path = parts[1];
            }
            let req;
            if (opts.followRedirects) {
                if (0 === websocket._redirects) {
                    websocket._originalIpc = isIpcUrl;
                    websocket._originalSecure = isSecure;
                    websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
                    const headers = options && options.headers;
                    options = {
                        ...options,
                        headers: {}
                    };
                    if (headers) for (const [key, value] of Object.entries(headers))options.headers[key.toLowerCase()] = value;
                } else if (0 === websocket.listenerCount('redirect')) {
                    const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
                    if (!isSameHost || websocket._originalSecure && !isSecure) {
                        delete opts.headers.authorization;
                        delete opts.headers.cookie;
                        if (!isSameHost) delete opts.headers.host;
                        opts.auth = void 0;
                    }
                }
                if (opts.auth && !options.headers.authorization) options.headers.authorization = 'Basic ' + Buffer.from(opts.auth).toString('base64');
                req = websocket._req = request(opts);
                if (websocket._redirects) websocket.emit('redirect', websocket.url, req);
            } else req = websocket._req = request(opts);
            if (opts.timeout) req.on('timeout', ()=>{
                abortHandshake(websocket, req, 'Opening handshake has timed out');
            });
            req.on('error', (err)=>{
                if (null === req || req[kAborted]) return;
                req = websocket._req = null;
                emitErrorAndClose(websocket, err);
            });
            req.on('response', (res)=>{
                const location = res.headers.location;
                const statusCode = res.statusCode;
                if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
                    if (++websocket._redirects > opts.maxRedirects) return void abortHandshake(websocket, req, 'Maximum redirects exceeded');
                    req.abort();
                    let addr;
                    try {
                        addr = new URL1(location, address);
                    } catch (e) {
                        const err = new SyntaxError(`Invalid URL: ${location}`);
                        emitErrorAndClose(websocket, err);
                        return;
                    }
                    initAsClient(websocket, addr, protocols, options);
                } else if (!websocket.emit('unexpected-response', req, res)) abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
            });
            req.on('upgrade', (res, socket, head)=>{
                websocket.emit('upgrade', res);
                if (websocket.readyState !== WebSocket.CONNECTING) return;
                req = websocket._req = null;
                const upgrade = res.headers.upgrade;
                if (void 0 === upgrade || 'websocket' !== upgrade.toLowerCase()) return void abortHandshake(websocket, socket, 'Invalid Upgrade header');
                const digest = createHash('sha1').update(key + GUID).digest('base64');
                if (res.headers['sec-websocket-accept'] !== digest) return void abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
                const serverProt = res.headers['sec-websocket-protocol'];
                let protError;
                if (void 0 !== serverProt) if (protocolSet.size) {
                    if (!protocolSet.has(serverProt)) protError = 'Server sent an invalid subprotocol';
                } else protError = 'Server sent a subprotocol but none was requested';
                else if (protocolSet.size) protError = 'Server sent no subprotocol';
                if (protError) return void abortHandshake(websocket, socket, protError);
                if (serverProt) websocket._protocol = serverProt;
                const secWebSocketExtensions = res.headers['sec-websocket-extensions'];
                if (void 0 !== secWebSocketExtensions) {
                    if (!perMessageDeflate) {
                        const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
                        abortHandshake(websocket, socket, message);
                        return;
                    }
                    let extensions;
                    try {
                        extensions = parse(secWebSocketExtensions);
                    } catch (err) {
                        const message = 'Invalid Sec-WebSocket-Extensions header';
                        abortHandshake(websocket, socket, message);
                        return;
                    }
                    const extensionNames = Object.keys(extensions);
                    if (1 !== extensionNames.length || extensionNames[0] !== PerMessageDeflate.extensionName) {
                        const message = 'Server indicated an extension that was not requested';
                        abortHandshake(websocket, socket, message);
                        return;
                    }
                    try {
                        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
                    } catch (err) {
                        const message = 'Invalid Sec-WebSocket-Extensions header';
                        abortHandshake(websocket, socket, message);
                        return;
                    }
                    websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
                }
                websocket.setSocket(socket, head, {
                    allowSynchronousEvents: opts.allowSynchronousEvents,
                    generateMask: opts.generateMask,
                    maxPayload: opts.maxPayload,
                    skipUTF8Validation: opts.skipUTF8Validation
                });
            });
            if (opts.finishRequest) opts.finishRequest(req, websocket);
            else req.end();
        }
        function emitErrorAndClose(websocket, err) {
            websocket._readyState = WebSocket.CLOSING;
            websocket.emit('error', err);
            websocket.emitClose();
        }
        function netConnect(options) {
            options.path = options.socketPath;
            return net.connect(options);
        }
        function tlsConnect(options) {
            options.path = void 0;
            if (!options.servername && '' !== options.servername) options.servername = net.isIP(options.host) ? '' : options.host;
            return tls.connect(options);
        }
        function abortHandshake(websocket, stream, message) {
            websocket._readyState = WebSocket.CLOSING;
            const err = new Error(message);
            Error.captureStackTrace(err, abortHandshake);
            if (stream.setHeader) {
                stream[kAborted] = true;
                stream.abort();
                if (stream.socket && !stream.socket.destroyed) stream.socket.destroy();
                process.nextTick(emitErrorAndClose, websocket, err);
            } else {
                stream.destroy(err);
                stream.once('error', websocket.emit.bind(websocket, 'error'));
                stream.once('close', websocket.emitClose.bind(websocket));
            }
        }
        function sendAfterClose(websocket, data, cb) {
            if (data) {
                const length = toBuffer(data).length;
                if (websocket._socket) websocket._sender._bufferedBytes += length;
                else websocket._bufferedAmount += length;
            }
            if (cb) {
                const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
                process.nextTick(cb, err);
            }
        }
        function receiverOnConclude(code, reason) {
            const websocket = this[kWebSocket];
            websocket._closeFrameReceived = true;
            websocket._closeMessage = reason;
            websocket._closeCode = code;
            if (void 0 === websocket._socket[kWebSocket]) return;
            websocket._socket.removeListener('data', socketOnData);
            process.nextTick(resume, websocket._socket);
            if (1005 === code) websocket.close();
            else websocket.close(code, reason);
        }
        function receiverOnDrain() {
            const websocket = this[kWebSocket];
            if (!websocket.isPaused) websocket._socket.resume();
        }
        function receiverOnError(err) {
            const websocket = this[kWebSocket];
            if (void 0 !== websocket._socket[kWebSocket]) {
                websocket._socket.removeListener('data', socketOnData);
                process.nextTick(resume, websocket._socket);
                websocket.close(err[kStatusCode]);
            }
            websocket.emit('error', err);
        }
        function receiverOnFinish() {
            this[kWebSocket].emitClose();
        }
        function receiverOnMessage(data, isBinary) {
            this[kWebSocket].emit('message', data, isBinary);
        }
        function receiverOnPing(data) {
            const websocket = this[kWebSocket];
            if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
            websocket.emit('ping', data);
        }
        function receiverOnPong(data) {
            this[kWebSocket].emit('pong', data);
        }
        function resume(stream) {
            stream.resume();
        }
        function socketOnClose() {
            const websocket = this[kWebSocket];
            this.removeListener('close', socketOnClose);
            this.removeListener('data', socketOnData);
            this.removeListener('end', socketOnEnd);
            websocket._readyState = WebSocket.CLOSING;
            let chunk;
            if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && null !== (chunk = websocket._socket.read())) websocket._receiver.write(chunk);
            websocket._receiver.end();
            this[kWebSocket] = void 0;
            clearTimeout(websocket._closeTimer);
            if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) websocket.emitClose();
            else {
                websocket._receiver.on('error', receiverOnFinish);
                websocket._receiver.on('finish', receiverOnFinish);
            }
        }
        function socketOnData(chunk) {
            if (!this[kWebSocket]._receiver.write(chunk)) this.pause();
        }
        function socketOnEnd() {
            const websocket = this[kWebSocket];
            websocket._readyState = WebSocket.CLOSING;
            websocket._receiver.end();
            this.end();
        }
        function socketOnError() {
            const websocket = this[kWebSocket];
            this.removeListener('error', socketOnError);
            this.on('error', NOOP);
            if (websocket) {
                websocket._readyState = WebSocket.CLOSING;
                this.destroy();
            }
        }
    },
    "../../node_modules/bufferutil/fallback.js": function(module) {
        "use strict";
        const mask = (source, mask, output, offset, length)=>{
            for(var i = 0; i < length; i++)output[offset + i] = source[i] ^ mask[3 & i];
        };
        const unmask = (buffer, mask)=>{
            const length = buffer.length;
            for(var i = 0; i < length; i++)buffer[i] ^= mask[3 & i];
        };
        module.exports = {
            mask,
            unmask
        };
    },
    "../../node_modules/bufferutil/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        try {
            module.exports = __webpack_require__("../../node_modules/node-gyp-build/index.js")(__dirname);
        } catch (e) {
            module.exports = __webpack_require__("../../node_modules/bufferutil/fallback.js");
        }
    },
    "../../node_modules/node-gyp-build/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const runtimeRequire = require;
        if ('function' == typeof runtimeRequire.addon) module.exports = runtimeRequire.addon.bind(runtimeRequire);
        else module.exports = __webpack_require__("../../node_modules/node-gyp-build/node-gyp-build.js");
    },
    "../../node_modules/node-gyp-build/node-gyp-build.js": function(module, __unused_webpack_exports, __webpack_require__) {
        var fs = __webpack_require__("fs");
        var path = __webpack_require__("path");
        var os = __webpack_require__("os");
        var runtimeRequire = require;
        var vars = process.config && process.config.variables || {};
        var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
        var abi = process.versions.modules;
        var runtime = isElectron() ? 'electron' : isNwjs() ? 'node-webkit' : 'node';
        var arch = process.env.npm_config_arch || os.arch();
        var platform = process.env.npm_config_platform || os.platform();
        var libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc');
        var armv = process.env.ARM_VERSION || ('arm64' === arch ? '8' : vars.arm_version) || '';
        var uv = (process.versions.uv || '').split('.')[0];
        module.exports = load;
        function load(dir) {
            return runtimeRequire(load.resolve(dir));
        }
        load.resolve = load.path = function(dir) {
            dir = path.resolve(dir || '.');
            try {
                var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_');
                if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD'];
            } catch (err) {}
            if (!prebuildsOnly) {
                var release = getFirst(path.join(dir, 'build/Release'), matchBuild);
                if (release) return release;
                var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild);
                if (debug) return debug;
            }
            var prebuild = resolve(dir);
            if (prebuild) return prebuild;
            var nearby = resolve(path.dirname(process.execPath));
            if (nearby) return nearby;
            var target = [
                'platform=' + platform,
                'arch=' + arch,
                'runtime=' + runtime,
                'abi=' + abi,
                'uv=' + uv,
                armv ? 'armv=' + armv : '',
                'libc=' + libc,
                'node=' + process.versions.node,
                process.versions.electron ? 'electron=' + process.versions.electron : '',
                'webpack=true'
            ].filter(Boolean).join(' ');
            throw new Error('No native build was found for ' + target + '\n    loaded from: ' + dir + '\n');
            function resolve(dir) {
                var tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple);
                var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
                if (!tuple) return;
                var prebuilds = path.join(dir, 'prebuilds', tuple.name);
                var parsed = readdirSync(prebuilds).map(parseTags);
                var candidates = parsed.filter(matchTags(runtime, abi));
                var winner = candidates.sort(compareTags(runtime))[0];
                if (winner) return path.join(prebuilds, winner.file);
            }
        };
        function readdirSync(dir) {
            try {
                return fs.readdirSync(dir);
            } catch (err) {
                return [];
            }
        }
        function getFirst(dir, filter) {
            var files = readdirSync(dir).filter(filter);
            return files[0] && path.join(dir, files[0]);
        }
        function matchBuild(name) {
            return /\.node$/.test(name);
        }
        function parseTuple(name) {
            var arr = name.split('-');
            if (2 !== arr.length) return;
            var platform = arr[0];
            var architectures = arr[1].split('+');
            if (!platform) return;
            if (!architectures.length) return;
            if (!architectures.every(Boolean)) return;
            return {
                name,
                platform,
                architectures
            };
        }
        function matchTuple(platform, arch) {
            return function(tuple) {
                if (null == tuple) return false;
                if (tuple.platform !== platform) return false;
                return tuple.architectures.includes(arch);
            };
        }
        function compareTuples(a, b) {
            return a.architectures.length - b.architectures.length;
        }
        function parseTags(file) {
            var arr = file.split('.');
            var extension = arr.pop();
            var tags = {
                file: file,
                specificity: 0
            };
            if ('node' !== extension) return;
            for(var i = 0; i < arr.length; i++){
                var tag = arr[i];
                if ('node' === tag || 'electron' === tag || 'node-webkit' === tag) tags.runtime = tag;
                else if ('napi' === tag) tags.napi = true;
                else if ('abi' === tag.slice(0, 3)) tags.abi = tag.slice(3);
                else if ('uv' === tag.slice(0, 2)) tags.uv = tag.slice(2);
                else if ('armv' === tag.slice(0, 4)) tags.armv = tag.slice(4);
                else {
                    if ('glibc' !== tag && 'musl' !== tag) continue;
                    tags.libc = tag;
                }
                tags.specificity++;
            }
            return tags;
        }
        function matchTags(runtime, abi) {
            return function(tags) {
                if (null == tags) return false;
                if (tags.runtime && tags.runtime !== runtime && !runtimeAgnostic(tags)) return false;
                if (tags.abi && tags.abi !== abi && !tags.napi) return false;
                if (tags.uv && tags.uv !== uv) return false;
                if (tags.armv && tags.armv !== armv) return false;
                if (tags.libc && tags.libc !== libc) return false;
                return true;
            };
        }
        function runtimeAgnostic(tags) {
            return 'node' === tags.runtime && tags.napi;
        }
        function compareTags(runtime) {
            return function(a, b) {
                if (a.runtime !== b.runtime) return a.runtime === runtime ? -1 : 1;
                if (a.abi !== b.abi) return a.abi ? -1 : 1;
                if (a.specificity !== b.specificity) return a.specificity > b.specificity ? -1 : 1;
                return 0;
            };
        }
        function isNwjs() {
            return !!(process.versions && process.versions.nw);
        }
        function isElectron() {
            if (process.versions && process.versions.electron) return true;
            if (process.env.ELECTRON_RUN_AS_NODE) return true;
            return 'undefined' != typeof window && window.process && 'renderer' === window.process.type;
        }
        function isAlpine(platform) {
            return 'linux' === platform && fs.existsSync('/etc/alpine-release');
        }
        load.parseTags = parseTags;
        load.matchTags = matchTags;
        load.compareTags = compareTags;
        load.parseTuple = parseTuple;
        load.matchTuple = matchTuple;
        load.compareTuples = compareTuples;
    },
    "../../node_modules/utf-8-validate/fallback.js": function(module) {
        "use strict";
        function isValidUTF8(buf) {
            const len = buf.length;
            let i = 0;
            while(i < len)if ((0x80 & buf[i]) === 0x00) i++;
            else if ((0xe0 & buf[i]) === 0xc0) {
                if (i + 1 === len || (0xc0 & buf[i + 1]) !== 0x80 || (0xfe & buf[i]) === 0xc0) return false;
                i += 2;
            } else if ((0xf0 & buf[i]) === 0xe0) {
                if (i + 2 >= len || (0xc0 & buf[i + 1]) !== 0x80 || (0xc0 & buf[i + 2]) !== 0x80 || 0xe0 === buf[i] && (0xe0 & buf[i + 1]) === 0x80 || 0xed === buf[i] && (0xe0 & buf[i + 1]) === 0xa0) return false;
                i += 3;
            } else {
                if ((0xf8 & buf[i]) !== 0xf0) return false;
                if (i + 3 >= len || (0xc0 & buf[i + 1]) !== 0x80 || (0xc0 & buf[i + 2]) !== 0x80 || (0xc0 & buf[i + 3]) !== 0x80 || 0xf0 === buf[i] && (0xf0 & buf[i + 1]) === 0x80 || 0xf4 === buf[i] && buf[i + 1] > 0x8f || buf[i] > 0xf4) return false;
                i += 4;
            }
            return true;
        }
        module.exports = isValidUTF8;
    },
    "../../node_modules/utf-8-validate/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        try {
            module.exports = __webpack_require__("../../node_modules/node-gyp-build/index.js")(__dirname);
        } catch (e) {
            module.exports = __webpack_require__("../../node_modules/utf-8-validate/fallback.js");
        }
    },
    "../agent-interface/dist/agent.mjs": function() {},
    "../agent-interface/dist/index.mjs": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            isStreamingOptions: ()=>isStreamingOptions,
            LogLevel: ()=>dist["in"],
            isAgentRunObjectOptions: ()=>isAgentRunObjectOptions
        });
        __webpack_require__("../agent-interface/dist/agent.mjs");
        var dist = __webpack_require__("../node_modules/.pnpm/@agent-infra+logger@0.0.2-beta.2/node_modules/@agent-infra/logger/dist/index.mjs");
        function isAgentRunObjectOptions(options) {
            return 'string' != typeof options && 'input' in options;
        }
        function isStreamingOptions(options) {
            return true === options.stream;
        }
        var util_util;
        (function(util) {
            util.assertEqual = (_)=>{};
            function assertIs(_arg) {}
            util.assertIs = assertIs;
            function assertNever(_x) {
                throw new Error();
            }
            util.assertNever = assertNever;
            util.arrayToEnum = (items)=>{
                const obj = {};
                for (const item of items)obj[item] = item;
                return obj;
            };
            util.getValidEnumValues = (obj)=>{
                const validKeys = util.objectKeys(obj).filter((k)=>"number" != typeof obj[obj[k]]);
                const filtered = {};
                for (const k of validKeys)filtered[k] = obj[k];
                return util.objectValues(filtered);
            };
            util.objectValues = (obj)=>util.objectKeys(obj).map(function(e) {
                    return obj[e];
                });
            util.objectKeys = "function" == typeof Object.keys ? (obj)=>Object.keys(obj) : (object)=>{
                const keys = [];
                for(const key in object)if (Object.prototype.hasOwnProperty.call(object, key)) keys.push(key);
                return keys;
            };
            util.find = (arr, checker)=>{
                for (const item of arr)if (checker(item)) return item;
            };
            util.isInteger = "function" == typeof Number.isInteger ? (val)=>Number.isInteger(val) : (val)=>"number" == typeof val && Number.isFinite(val) && Math.floor(val) === val;
            function joinValues(array, separator = " | ") {
                return array.map((val)=>"string" == typeof val ? `'${val}'` : val).join(separator);
            }
            util.joinValues = joinValues;
            util.jsonStringifyReplacer = (_, value)=>{
                if ("bigint" == typeof value) return value.toString();
                return value;
            };
        })(util_util || (util_util = {}));
        var util_objectUtil;
        (function(objectUtil) {
            objectUtil.mergeShapes = (first, second)=>({
                    ...first,
                    ...second
                });
        })(util_objectUtil || (util_objectUtil = {}));
        const ZodParsedType = util_util.arrayToEnum([
            "string",
            "nan",
            "number",
            "integer",
            "float",
            "boolean",
            "date",
            "bigint",
            "symbol",
            "function",
            "undefined",
            "null",
            "array",
            "object",
            "unknown",
            "promise",
            "void",
            "never",
            "map",
            "set"
        ]);
        const getParsedType = (data)=>{
            const t = typeof data;
            switch(t){
                case "undefined":
                    return ZodParsedType.undefined;
                case "string":
                    return ZodParsedType.string;
                case "number":
                    return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
                case "boolean":
                    return ZodParsedType.boolean;
                case "function":
                    return ZodParsedType.function;
                case "bigint":
                    return ZodParsedType.bigint;
                case "symbol":
                    return ZodParsedType.symbol;
                case "object":
                    if (Array.isArray(data)) return ZodParsedType.array;
                    if (null === data) return ZodParsedType.null;
                    if (data.then && "function" == typeof data.then && data.catch && "function" == typeof data.catch) return ZodParsedType.promise;
                    if ("undefined" != typeof Map && data instanceof Map) return ZodParsedType.map;
                    if ("undefined" != typeof Set && data instanceof Set) return ZodParsedType.set;
                    if ("undefined" != typeof Date && data instanceof Date) return ZodParsedType.date;
                    return ZodParsedType.object;
                default:
                    return ZodParsedType.unknown;
            }
        };
        const ZodIssueCode = util_util.arrayToEnum([
            "invalid_type",
            "invalid_literal",
            "custom",
            "invalid_union",
            "invalid_union_discriminator",
            "invalid_enum_value",
            "unrecognized_keys",
            "invalid_arguments",
            "invalid_return_type",
            "invalid_date",
            "invalid_string",
            "too_small",
            "too_big",
            "invalid_intersection_types",
            "not_multiple_of",
            "not_finite"
        ]);
        class ZodError extends Error {
            get errors() {
                return this.issues;
            }
            constructor(issues){
                super();
                this.issues = [];
                this.addIssue = (sub)=>{
                    this.issues = [
                        ...this.issues,
                        sub
                    ];
                };
                this.addIssues = (subs = [])=>{
                    this.issues = [
                        ...this.issues,
                        ...subs
                    ];
                };
                const actualProto = new.target.prototype;
                if (Object.setPrototypeOf) Object.setPrototypeOf(this, actualProto);
                else this.__proto__ = actualProto;
                this.name = "ZodError";
                this.issues = issues;
            }
            format(_mapper) {
                const mapper = _mapper || function(issue) {
                    return issue.message;
                };
                const fieldErrors = {
                    _errors: []
                };
                const processError = (error)=>{
                    for (const issue of error.issues)if ("invalid_union" === issue.code) issue.unionErrors.map(processError);
                    else if ("invalid_return_type" === issue.code) processError(issue.returnTypeError);
                    else if ("invalid_arguments" === issue.code) processError(issue.argumentsError);
                    else if (0 === issue.path.length) fieldErrors._errors.push(mapper(issue));
                    else {
                        let curr = fieldErrors;
                        let i = 0;
                        while(i < issue.path.length){
                            const el = issue.path[i];
                            const terminal = i === issue.path.length - 1;
                            if (terminal) {
                                curr[el] = curr[el] || {
                                    _errors: []
                                };
                                curr[el]._errors.push(mapper(issue));
                            } else curr[el] = curr[el] || {
                                _errors: []
                            };
                            curr = curr[el];
                            i++;
                        }
                    }
                };
                processError(this);
                return fieldErrors;
            }
            static assert(value) {
                if (!(value instanceof ZodError)) throw new Error(`Not a ZodError: ${value}`);
            }
            toString() {
                return this.message;
            }
            get message() {
                return JSON.stringify(this.issues, util_util.jsonStringifyReplacer, 2);
            }
            get isEmpty() {
                return 0 === this.issues.length;
            }
            flatten(mapper = (issue)=>issue.message) {
                const fieldErrors = {};
                const formErrors = [];
                for (const sub of this.issues)if (sub.path.length > 0) {
                    fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                    fieldErrors[sub.path[0]].push(mapper(sub));
                } else formErrors.push(mapper(sub));
                return {
                    formErrors,
                    fieldErrors
                };
            }
            get formErrors() {
                return this.flatten();
            }
        }
        ZodError.create = (issues)=>{
            const error = new ZodError(issues);
            return error;
        };
        const en_errorMap = (issue, _ctx)=>{
            let message;
            switch(issue.code){
                case ZodIssueCode.invalid_type:
                    message = issue.received === ZodParsedType.undefined ? "Required" : `Expected ${issue.expected}, received ${issue.received}`;
                    break;
                case ZodIssueCode.invalid_literal:
                    message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_util.jsonStringifyReplacer)}`;
                    break;
                case ZodIssueCode.unrecognized_keys:
                    message = `Unrecognized key(s) in object: ${util_util.joinValues(issue.keys, ", ")}`;
                    break;
                case ZodIssueCode.invalid_union:
                    message = "Invalid input";
                    break;
                case ZodIssueCode.invalid_union_discriminator:
                    message = `Invalid discriminator value. Expected ${util_util.joinValues(issue.options)}`;
                    break;
                case ZodIssueCode.invalid_enum_value:
                    message = `Invalid enum value. Expected ${util_util.joinValues(issue.options)}, received '${issue.received}'`;
                    break;
                case ZodIssueCode.invalid_arguments:
                    message = "Invalid function arguments";
                    break;
                case ZodIssueCode.invalid_return_type:
                    message = "Invalid function return type";
                    break;
                case ZodIssueCode.invalid_date:
                    message = "Invalid date";
                    break;
                case ZodIssueCode.invalid_string:
                    if ("object" == typeof issue.validation) if ("includes" in issue.validation) {
                        message = `Invalid input: must include "${issue.validation.includes}"`;
                        if ("number" == typeof issue.validation.position) message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    } else if ("startsWith" in issue.validation) message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                    else if ("endsWith" in issue.validation) message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                    else util_util.assertNever(issue.validation);
                    else message = "regex" !== issue.validation ? `Invalid ${issue.validation}` : "Invalid";
                    break;
                case ZodIssueCode.too_small:
                    message = "array" === issue.type ? `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? "at least" : "more than"} ${issue.minimum} element(s)` : "string" === issue.type ? `String must contain ${issue.exact ? "exactly" : issue.inclusive ? "at least" : "over"} ${issue.minimum} character(s)` : "number" === issue.type ? `Number must be ${issue.exact ? "exactly equal to " : issue.inclusive ? "greater than or equal to " : "greater than "}${issue.minimum}` : "date" === issue.type ? `Date must be ${issue.exact ? "exactly equal to " : issue.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(issue.minimum))}` : "Invalid input";
                    break;
                case ZodIssueCode.too_big:
                    message = "array" === issue.type ? `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? "at most" : "less than"} ${issue.maximum} element(s)` : "string" === issue.type ? `String must contain ${issue.exact ? "exactly" : issue.inclusive ? "at most" : "under"} ${issue.maximum} character(s)` : "number" === issue.type ? `Number must be ${issue.exact ? "exactly" : issue.inclusive ? "less than or equal to" : "less than"} ${issue.maximum}` : "bigint" === issue.type ? `BigInt must be ${issue.exact ? "exactly" : issue.inclusive ? "less than or equal to" : "less than"} ${issue.maximum}` : "date" === issue.type ? `Date must be ${issue.exact ? "exactly" : issue.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(issue.maximum))}` : "Invalid input";
                    break;
                case ZodIssueCode.custom:
                    message = "Invalid input";
                    break;
                case ZodIssueCode.invalid_intersection_types:
                    message = "Intersection results could not be merged";
                    break;
                case ZodIssueCode.not_multiple_of:
                    message = `Number must be a multiple of ${issue.multipleOf}`;
                    break;
                case ZodIssueCode.not_finite:
                    message = "Number must be finite";
                    break;
                default:
                    message = _ctx.defaultError;
                    util_util.assertNever(issue);
            }
            return {
                message
            };
        };
        const en = en_errorMap;
        let overrideErrorMap = en;
        function getErrorMap() {
            return overrideErrorMap;
        }
        const makeIssue = (params)=>{
            const { data, path, errorMaps, issueData } = params;
            const fullPath = [
                ...path,
                ...issueData.path || []
            ];
            const fullIssue = {
                ...issueData,
                path: fullPath
            };
            if (void 0 !== issueData.message) return {
                ...issueData,
                path: fullPath,
                message: issueData.message
            };
            let errorMessage = "";
            const maps = errorMaps.filter((m)=>!!m).slice().reverse();
            for (const map of maps)errorMessage = map(fullIssue, {
                data,
                defaultError: errorMessage
            }).message;
            return {
                ...issueData,
                path: fullPath,
                message: errorMessage
            };
        };
        function addIssueToContext(ctx, issueData) {
            const overrideMap = getErrorMap();
            const issue = makeIssue({
                issueData: issueData,
                data: ctx.data,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    overrideMap,
                    overrideMap === en ? void 0 : en
                ].filter((x)=>!!x)
            });
            ctx.common.issues.push(issue);
        }
        class ParseStatus {
            constructor(){
                this.value = "valid";
            }
            dirty() {
                if ("valid" === this.value) this.value = "dirty";
            }
            abort() {
                if ("aborted" !== this.value) this.value = "aborted";
            }
            static mergeArray(status, results) {
                const arrayValue = [];
                for (const s of results){
                    if ("aborted" === s.status) return parseUtil_INVALID;
                    if ("dirty" === s.status) status.dirty();
                    arrayValue.push(s.value);
                }
                return {
                    status: status.value,
                    value: arrayValue
                };
            }
            static async mergeObjectAsync(status, pairs) {
                const syncPairs = [];
                for (const pair of pairs){
                    const key = await pair.key;
                    const value = await pair.value;
                    syncPairs.push({
                        key,
                        value
                    });
                }
                return ParseStatus.mergeObjectSync(status, syncPairs);
            }
            static mergeObjectSync(status, pairs) {
                const finalObject = {};
                for (const pair of pairs){
                    const { key, value } = pair;
                    if ("aborted" === key.status) return parseUtil_INVALID;
                    if ("aborted" === value.status) return parseUtil_INVALID;
                    if ("dirty" === key.status) status.dirty();
                    if ("dirty" === value.status) status.dirty();
                    if ("__proto__" !== key.value && (void 0 !== value.value || pair.alwaysSet)) finalObject[key.value] = value.value;
                }
                return {
                    status: status.value,
                    value: finalObject
                };
            }
        }
        const parseUtil_INVALID = Object.freeze({
            status: "aborted"
        });
        const DIRTY = (value)=>({
                status: "dirty",
                value
            });
        const OK = (value)=>({
                status: "valid",
                value
            });
        const isAborted = (x)=>"aborted" === x.status;
        const isDirty = (x)=>"dirty" === x.status;
        const isValid = (x)=>"valid" === x.status;
        const isAsync = (x)=>"undefined" != typeof Promise && x instanceof Promise;
        var errorUtil_errorUtil;
        (function(errorUtil) {
            errorUtil.errToObj = (message)=>"string" == typeof message ? {
                    message
                } : message || {};
            errorUtil.toString = (message)=>"string" == typeof message ? message : message?.message;
        })(errorUtil_errorUtil || (errorUtil_errorUtil = {}));
        class ParseInputLazyPath {
            constructor(parent, value, path, key){
                this._cachedPath = [];
                this.parent = parent;
                this.data = value;
                this._path = path;
                this._key = key;
            }
            get path() {
                if (!this._cachedPath.length) if (Array.isArray(this._key)) this._cachedPath.push(...this._path, ...this._key);
                else this._cachedPath.push(...this._path, this._key);
                return this._cachedPath;
            }
        }
        const handleResult = (ctx, result)=>{
            if (isValid(result)) return {
                success: true,
                data: result.value
            };
            if (!ctx.common.issues.length) throw new Error("Validation failed but no issues detected.");
            return {
                success: false,
                get error () {
                    if (this._error) return this._error;
                    const error = new ZodError(ctx.common.issues);
                    this._error = error;
                    return this._error;
                }
            };
        };
        function processCreateParams(params) {
            if (!params) return {};
            const { errorMap, invalid_type_error, required_error, description } = params;
            if (errorMap && (invalid_type_error || required_error)) throw new Error('Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.');
            if (errorMap) return {
                errorMap: errorMap,
                description
            };
            const customMap = (iss, ctx)=>{
                const { message } = params;
                if ("invalid_enum_value" === iss.code) return {
                    message: message ?? ctx.defaultError
                };
                if (void 0 === ctx.data) return {
                    message: message ?? required_error ?? ctx.defaultError
                };
                if ("invalid_type" !== iss.code) return {
                    message: ctx.defaultError
                };
                return {
                    message: message ?? invalid_type_error ?? ctx.defaultError
                };
            };
            return {
                errorMap: customMap,
                description
            };
        }
        class ZodType {
            get description() {
                return this._def.description;
            }
            _getType(input) {
                return getParsedType(input.data);
            }
            _getOrReturnCtx(input, ctx) {
                return ctx || {
                    common: input.parent.common,
                    data: input.data,
                    parsedType: getParsedType(input.data),
                    schemaErrorMap: this._def.errorMap,
                    path: input.path,
                    parent: input.parent
                };
            }
            _processInputParams(input) {
                return {
                    status: new ParseStatus(),
                    ctx: {
                        common: input.parent.common,
                        data: input.data,
                        parsedType: getParsedType(input.data),
                        schemaErrorMap: this._def.errorMap,
                        path: input.path,
                        parent: input.parent
                    }
                };
            }
            _parseSync(input) {
                const result = this._parse(input);
                if (isAsync(result)) throw new Error("Synchronous parse encountered promise.");
                return result;
            }
            _parseAsync(input) {
                const result = this._parse(input);
                return Promise.resolve(result);
            }
            parse(data, params) {
                const result = this.safeParse(data, params);
                if (result.success) return result.data;
                throw result.error;
            }
            safeParse(data, params) {
                const ctx = {
                    common: {
                        issues: [],
                        async: params?.async ?? false,
                        contextualErrorMap: params?.errorMap
                    },
                    path: params?.path || [],
                    schemaErrorMap: this._def.errorMap,
                    parent: null,
                    data,
                    parsedType: getParsedType(data)
                };
                const result = this._parseSync({
                    data,
                    path: ctx.path,
                    parent: ctx
                });
                return handleResult(ctx, result);
            }
            "~validate"(data) {
                const ctx = {
                    common: {
                        issues: [],
                        async: !!this["~standard"].async
                    },
                    path: [],
                    schemaErrorMap: this._def.errorMap,
                    parent: null,
                    data,
                    parsedType: getParsedType(data)
                };
                if (!this["~standard"].async) try {
                    const result = this._parseSync({
                        data,
                        path: [],
                        parent: ctx
                    });
                    return isValid(result) ? {
                        value: result.value
                    } : {
                        issues: ctx.common.issues
                    };
                } catch (err) {
                    if (err?.message?.toLowerCase()?.includes("encountered")) this["~standard"].async = true;
                    ctx.common = {
                        issues: [],
                        async: true
                    };
                }
                return this._parseAsync({
                    data,
                    path: [],
                    parent: ctx
                }).then((result)=>isValid(result) ? {
                        value: result.value
                    } : {
                        issues: ctx.common.issues
                    });
            }
            async parseAsync(data, params) {
                const result = await this.safeParseAsync(data, params);
                if (result.success) return result.data;
                throw result.error;
            }
            async safeParseAsync(data, params) {
                const ctx = {
                    common: {
                        issues: [],
                        contextualErrorMap: params?.errorMap,
                        async: true
                    },
                    path: params?.path || [],
                    schemaErrorMap: this._def.errorMap,
                    parent: null,
                    data,
                    parsedType: getParsedType(data)
                };
                const maybeAsyncResult = this._parse({
                    data,
                    path: ctx.path,
                    parent: ctx
                });
                const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
                return handleResult(ctx, result);
            }
            refine(check, message) {
                const getIssueProperties = (val)=>{
                    if ("string" == typeof message || void 0 === message) return {
                        message
                    };
                    if ("function" == typeof message) return message(val);
                    return message;
                };
                return this._refinement((val, ctx)=>{
                    const result = check(val);
                    const setError = ()=>ctx.addIssue({
                            code: ZodIssueCode.custom,
                            ...getIssueProperties(val)
                        });
                    if ("undefined" != typeof Promise && result instanceof Promise) return result.then((data)=>{
                        if (data) return true;
                        setError();
                        return false;
                    });
                    if (result) return true;
                    setError();
                    return false;
                });
            }
            refinement(check, refinementData) {
                return this._refinement((val, ctx)=>{
                    if (check(val)) return true;
                    ctx.addIssue("function" == typeof refinementData ? refinementData(val, ctx) : refinementData);
                    return false;
                });
            }
            _refinement(refinement) {
                return new ZodEffects({
                    schema: this,
                    typeName: types_ZodFirstPartyTypeKind.ZodEffects,
                    effect: {
                        type: "refinement",
                        refinement
                    }
                });
            }
            superRefine(refinement) {
                return this._refinement(refinement);
            }
            constructor(def){
                this.spa = this.safeParseAsync;
                this._def = def;
                this.parse = this.parse.bind(this);
                this.safeParse = this.safeParse.bind(this);
                this.parseAsync = this.parseAsync.bind(this);
                this.safeParseAsync = this.safeParseAsync.bind(this);
                this.spa = this.spa.bind(this);
                this.refine = this.refine.bind(this);
                this.refinement = this.refinement.bind(this);
                this.superRefine = this.superRefine.bind(this);
                this.optional = this.optional.bind(this);
                this.nullable = this.nullable.bind(this);
                this.nullish = this.nullish.bind(this);
                this.array = this.array.bind(this);
                this.promise = this.promise.bind(this);
                this.or = this.or.bind(this);
                this.and = this.and.bind(this);
                this.transform = this.transform.bind(this);
                this.brand = this.brand.bind(this);
                this.default = this.default.bind(this);
                this.catch = this.catch.bind(this);
                this.describe = this.describe.bind(this);
                this.pipe = this.pipe.bind(this);
                this.readonly = this.readonly.bind(this);
                this.isNullable = this.isNullable.bind(this);
                this.isOptional = this.isOptional.bind(this);
                this["~standard"] = {
                    version: 1,
                    vendor: "zod",
                    validate: (data)=>this["~validate"](data)
                };
            }
            optional() {
                return ZodOptional.create(this, this._def);
            }
            nullable() {
                return ZodNullable.create(this, this._def);
            }
            nullish() {
                return this.nullable().optional();
            }
            array() {
                return ZodArray.create(this);
            }
            promise() {
                return ZodPromise.create(this, this._def);
            }
            or(option) {
                return ZodUnion.create([
                    this,
                    option
                ], this._def);
            }
            and(incoming) {
                return ZodIntersection.create(this, incoming, this._def);
            }
            transform(transform) {
                return new ZodEffects({
                    ...processCreateParams(this._def),
                    schema: this,
                    typeName: types_ZodFirstPartyTypeKind.ZodEffects,
                    effect: {
                        type: "transform",
                        transform
                    }
                });
            }
            default(def) {
                const defaultValueFunc = "function" == typeof def ? def : ()=>def;
                return new ZodDefault({
                    ...processCreateParams(this._def),
                    innerType: this,
                    defaultValue: defaultValueFunc,
                    typeName: types_ZodFirstPartyTypeKind.ZodDefault
                });
            }
            brand() {
                return new ZodBranded({
                    typeName: types_ZodFirstPartyTypeKind.ZodBranded,
                    type: this,
                    ...processCreateParams(this._def)
                });
            }
            catch(def) {
                const catchValueFunc = "function" == typeof def ? def : ()=>def;
                return new ZodCatch({
                    ...processCreateParams(this._def),
                    innerType: this,
                    catchValue: catchValueFunc,
                    typeName: types_ZodFirstPartyTypeKind.ZodCatch
                });
            }
            describe(description) {
                const This = this.constructor;
                return new This({
                    ...this._def,
                    description
                });
            }
            pipe(target) {
                return ZodPipeline.create(this, target);
            }
            readonly() {
                return ZodReadonly.create(this);
            }
            isOptional() {
                return this.safeParse(void 0).success;
            }
            isNullable() {
                return this.safeParse(null).success;
            }
        }
        const cuidRegex = /^c[^\s-]{8,}$/i;
        const cuid2Regex = /^[0-9a-z]+$/;
        const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
        const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
        const nanoidRegex = /^[a-z0-9_-]{21}$/i;
        const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
        const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
        const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
        const _emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
        let emojiRegex;
        const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
        const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
        const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
        const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
        const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
        const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
        const dateRegexSource = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))";
        const dateRegex = new RegExp(`^${dateRegexSource}$`);
        function timeRegexSource(args) {
            let secondsRegexSource = "[0-5]\\d";
            if (args.precision) secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
            else if (null == args.precision) secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
            const secondsQuantifier = args.precision ? "+" : "?";
            return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
        }
        function timeRegex(args) {
            return new RegExp(`^${timeRegexSource(args)}$`);
        }
        function datetimeRegex(args) {
            let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
            const opts = [];
            opts.push(args.local ? "Z?" : "Z");
            if (args.offset) opts.push("([+-]\\d{2}:?\\d{2})");
            regex = `${regex}(${opts.join("|")})`;
            return new RegExp(`^${regex}$`);
        }
        function isValidIP(ip, version) {
            if (("v4" === version || !version) && ipv4Regex.test(ip)) return true;
            if (("v6" === version || !version) && ipv6Regex.test(ip)) return true;
            return false;
        }
        function isValidJWT(jwt, alg) {
            if (!jwtRegex.test(jwt)) return false;
            try {
                const [header] = jwt.split(".");
                const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
                const decoded = JSON.parse(atob(base64));
                if ("object" != typeof decoded || null === decoded) return false;
                if ("typ" in decoded && decoded?.typ !== "JWT") return false;
                if (!decoded.alg) return false;
                if (alg && decoded.alg !== alg) return false;
                return true;
            } catch  {
                return false;
            }
        }
        function isValidCidr(ip, version) {
            if (("v4" === version || !version) && ipv4CidrRegex.test(ip)) return true;
            if (("v6" === version || !version) && ipv6CidrRegex.test(ip)) return true;
            return false;
        }
        class ZodString extends ZodType {
            _parse(input) {
                if (this._def.coerce) input.data = String(input.data);
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.string) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.string,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                const status = new ParseStatus();
                let ctx;
                for (const check of this._def.checks)if ("min" === check.kind) {
                    if (input.data.length < check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: false,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("max" === check.kind) {
                    if (input.data.length > check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: false,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("length" === check.kind) {
                    const tooBig = input.data.length > check.value;
                    const tooSmall = input.data.length < check.value;
                    if (tooBig || tooSmall) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        if (tooBig) addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message
                        });
                        else if (tooSmall) addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("email" === check.kind) {
                    if (!emailRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "email",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("emoji" === check.kind) {
                    if (!emojiRegex) emojiRegex = new RegExp(_emojiRegex, "u");
                    if (!emojiRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "emoji",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("uuid" === check.kind) {
                    if (!uuidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "uuid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("nanoid" === check.kind) {
                    if (!nanoidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "nanoid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("cuid" === check.kind) {
                    if (!cuidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "cuid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("cuid2" === check.kind) {
                    if (!cuid2Regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "cuid2",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("ulid" === check.kind) {
                    if (!ulidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "ulid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("url" === check.kind) try {
                    new URL(input.data);
                } catch  {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
                else if ("regex" === check.kind) {
                    check.regex.lastIndex = 0;
                    const testResult = check.regex.test(input.data);
                    if (!testResult) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "regex",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("trim" === check.kind) input.data = input.data.trim();
                else if ("includes" === check.kind) {
                    if (!input.data.includes(check.value, check.position)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: {
                                includes: check.value,
                                position: check.position
                            },
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("toLowerCase" === check.kind) input.data = input.data.toLowerCase();
                else if ("toUpperCase" === check.kind) input.data = input.data.toUpperCase();
                else if ("startsWith" === check.kind) {
                    if (!input.data.startsWith(check.value)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: {
                                startsWith: check.value
                            },
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("endsWith" === check.kind) {
                    if (!input.data.endsWith(check.value)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: {
                                endsWith: check.value
                            },
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("datetime" === check.kind) {
                    const regex = datetimeRegex(check);
                    if (!regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: "datetime",
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("date" === check.kind) {
                    const regex = dateRegex;
                    if (!regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: "date",
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("time" === check.kind) {
                    const regex = timeRegex(check);
                    if (!regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: "time",
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("duration" === check.kind) {
                    if (!durationRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "duration",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("ip" === check.kind) {
                    if (!isValidIP(input.data, check.version)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "ip",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("jwt" === check.kind) {
                    if (!isValidJWT(input.data, check.alg)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "jwt",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("cidr" === check.kind) {
                    if (!isValidCidr(input.data, check.version)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "cidr",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("base64" === check.kind) {
                    if (!base64Regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "base64",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("base64url" === check.kind) {
                    if (!base64urlRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "base64url",
                            code: ZodIssueCode.invalid_string,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else util_util.assertNever(check);
                return {
                    status: status.value,
                    value: input.data
                };
            }
            _regex(regex, validation, message) {
                return this.refinement((data)=>regex.test(data), {
                    validation,
                    code: ZodIssueCode.invalid_string,
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            _addCheck(check) {
                return new ZodString({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        check
                    ]
                });
            }
            email(message) {
                return this._addCheck({
                    kind: "email",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            url(message) {
                return this._addCheck({
                    kind: "url",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            emoji(message) {
                return this._addCheck({
                    kind: "emoji",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            uuid(message) {
                return this._addCheck({
                    kind: "uuid",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            nanoid(message) {
                return this._addCheck({
                    kind: "nanoid",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            cuid(message) {
                return this._addCheck({
                    kind: "cuid",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            cuid2(message) {
                return this._addCheck({
                    kind: "cuid2",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            ulid(message) {
                return this._addCheck({
                    kind: "ulid",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            base64(message) {
                return this._addCheck({
                    kind: "base64",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            base64url(message) {
                return this._addCheck({
                    kind: "base64url",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            jwt(options) {
                return this._addCheck({
                    kind: "jwt",
                    ...errorUtil_errorUtil.errToObj(options)
                });
            }
            ip(options) {
                return this._addCheck({
                    kind: "ip",
                    ...errorUtil_errorUtil.errToObj(options)
                });
            }
            cidr(options) {
                return this._addCheck({
                    kind: "cidr",
                    ...errorUtil_errorUtil.errToObj(options)
                });
            }
            datetime(options) {
                if ("string" == typeof options) return this._addCheck({
                    kind: "datetime",
                    precision: null,
                    offset: false,
                    local: false,
                    message: options
                });
                return this._addCheck({
                    kind: "datetime",
                    precision: void 0 === options?.precision ? null : options?.precision,
                    offset: options?.offset ?? false,
                    local: options?.local ?? false,
                    ...errorUtil_errorUtil.errToObj(options?.message)
                });
            }
            date(message) {
                return this._addCheck({
                    kind: "date",
                    message
                });
            }
            time(options) {
                if ("string" == typeof options) return this._addCheck({
                    kind: "time",
                    precision: null,
                    message: options
                });
                return this._addCheck({
                    kind: "time",
                    precision: void 0 === options?.precision ? null : options?.precision,
                    ...errorUtil_errorUtil.errToObj(options?.message)
                });
            }
            duration(message) {
                return this._addCheck({
                    kind: "duration",
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            regex(regex, message) {
                return this._addCheck({
                    kind: "regex",
                    regex: regex,
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            includes(value, options) {
                return this._addCheck({
                    kind: "includes",
                    value: value,
                    position: options?.position,
                    ...errorUtil_errorUtil.errToObj(options?.message)
                });
            }
            startsWith(value, message) {
                return this._addCheck({
                    kind: "startsWith",
                    value: value,
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            endsWith(value, message) {
                return this._addCheck({
                    kind: "endsWith",
                    value: value,
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            min(minLength, message) {
                return this._addCheck({
                    kind: "min",
                    value: minLength,
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            max(maxLength, message) {
                return this._addCheck({
                    kind: "max",
                    value: maxLength,
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            length(len, message) {
                return this._addCheck({
                    kind: "length",
                    value: len,
                    ...errorUtil_errorUtil.errToObj(message)
                });
            }
            nonempty(message) {
                return this.min(1, errorUtil_errorUtil.errToObj(message));
            }
            trim() {
                return new ZodString({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        {
                            kind: "trim"
                        }
                    ]
                });
            }
            toLowerCase() {
                return new ZodString({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        {
                            kind: "toLowerCase"
                        }
                    ]
                });
            }
            toUpperCase() {
                return new ZodString({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        {
                            kind: "toUpperCase"
                        }
                    ]
                });
            }
            get isDatetime() {
                return !!this._def.checks.find((ch)=>"datetime" === ch.kind);
            }
            get isDate() {
                return !!this._def.checks.find((ch)=>"date" === ch.kind);
            }
            get isTime() {
                return !!this._def.checks.find((ch)=>"time" === ch.kind);
            }
            get isDuration() {
                return !!this._def.checks.find((ch)=>"duration" === ch.kind);
            }
            get isEmail() {
                return !!this._def.checks.find((ch)=>"email" === ch.kind);
            }
            get isURL() {
                return !!this._def.checks.find((ch)=>"url" === ch.kind);
            }
            get isEmoji() {
                return !!this._def.checks.find((ch)=>"emoji" === ch.kind);
            }
            get isUUID() {
                return !!this._def.checks.find((ch)=>"uuid" === ch.kind);
            }
            get isNANOID() {
                return !!this._def.checks.find((ch)=>"nanoid" === ch.kind);
            }
            get isCUID() {
                return !!this._def.checks.find((ch)=>"cuid" === ch.kind);
            }
            get isCUID2() {
                return !!this._def.checks.find((ch)=>"cuid2" === ch.kind);
            }
            get isULID() {
                return !!this._def.checks.find((ch)=>"ulid" === ch.kind);
            }
            get isIP() {
                return !!this._def.checks.find((ch)=>"ip" === ch.kind);
            }
            get isCIDR() {
                return !!this._def.checks.find((ch)=>"cidr" === ch.kind);
            }
            get isBase64() {
                return !!this._def.checks.find((ch)=>"base64" === ch.kind);
            }
            get isBase64url() {
                return !!this._def.checks.find((ch)=>"base64url" === ch.kind);
            }
            get minLength() {
                let min = null;
                for (const ch of this._def.checks)if ("min" === ch.kind) {
                    if (null === min || ch.value > min) min = ch.value;
                }
                return min;
            }
            get maxLength() {
                let max = null;
                for (const ch of this._def.checks)if ("max" === ch.kind) {
                    if (null === max || ch.value < max) max = ch.value;
                }
                return max;
            }
        }
        ZodString.create = (params)=>new ZodString({
                checks: [],
                typeName: types_ZodFirstPartyTypeKind.ZodString,
                coerce: params?.coerce ?? false,
                ...processCreateParams(params)
            });
        function floatSafeRemainder(val, step) {
            const valDecCount = (val.toString().split(".")[1] || "").length;
            const stepDecCount = (step.toString().split(".")[1] || "").length;
            const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
            const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
            const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
            return valInt % stepInt / 10 ** decCount;
        }
        class ZodNumber extends ZodType {
            constructor(){
                super(...arguments);
                this.min = this.gte;
                this.max = this.lte;
                this.step = this.multipleOf;
            }
            _parse(input) {
                if (this._def.coerce) input.data = Number(input.data);
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.number) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.number,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                let ctx;
                const status = new ParseStatus();
                for (const check of this._def.checks)if ("int" === check.kind) {
                    if (!util_util.isInteger(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_type,
                            expected: "integer",
                            received: "float",
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("min" === check.kind) {
                    const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                    if (tooSmall) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "number",
                            inclusive: check.inclusive,
                            exact: false,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("max" === check.kind) {
                    const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                    if (tooBig) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "number",
                            inclusive: check.inclusive,
                            exact: false,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("multipleOf" === check.kind) {
                    if (0 !== floatSafeRemainder(input.data, check.value)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.not_multiple_of,
                            multipleOf: check.value,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("finite" === check.kind) {
                    if (!Number.isFinite(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.not_finite,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else util_util.assertNever(check);
                return {
                    status: status.value,
                    value: input.data
                };
            }
            gte(value, message) {
                return this.setLimit("min", value, true, errorUtil_errorUtil.toString(message));
            }
            gt(value, message) {
                return this.setLimit("min", value, false, errorUtil_errorUtil.toString(message));
            }
            lte(value, message) {
                return this.setLimit("max", value, true, errorUtil_errorUtil.toString(message));
            }
            lt(value, message) {
                return this.setLimit("max", value, false, errorUtil_errorUtil.toString(message));
            }
            setLimit(kind, value, inclusive, message) {
                return new ZodNumber({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        {
                            kind,
                            value,
                            inclusive,
                            message: errorUtil_errorUtil.toString(message)
                        }
                    ]
                });
            }
            _addCheck(check) {
                return new ZodNumber({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        check
                    ]
                });
            }
            int(message) {
                return this._addCheck({
                    kind: "int",
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            positive(message) {
                return this._addCheck({
                    kind: "min",
                    value: 0,
                    inclusive: false,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            negative(message) {
                return this._addCheck({
                    kind: "max",
                    value: 0,
                    inclusive: false,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            nonpositive(message) {
                return this._addCheck({
                    kind: "max",
                    value: 0,
                    inclusive: true,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            nonnegative(message) {
                return this._addCheck({
                    kind: "min",
                    value: 0,
                    inclusive: true,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            multipleOf(value, message) {
                return this._addCheck({
                    kind: "multipleOf",
                    value: value,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            finite(message) {
                return this._addCheck({
                    kind: "finite",
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            safe(message) {
                return this._addCheck({
                    kind: "min",
                    inclusive: true,
                    value: Number.MIN_SAFE_INTEGER,
                    message: errorUtil_errorUtil.toString(message)
                })._addCheck({
                    kind: "max",
                    inclusive: true,
                    value: Number.MAX_SAFE_INTEGER,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            get minValue() {
                let min = null;
                for (const ch of this._def.checks)if ("min" === ch.kind) {
                    if (null === min || ch.value > min) min = ch.value;
                }
                return min;
            }
            get maxValue() {
                let max = null;
                for (const ch of this._def.checks)if ("max" === ch.kind) {
                    if (null === max || ch.value < max) max = ch.value;
                }
                return max;
            }
            get isInt() {
                return !!this._def.checks.find((ch)=>"int" === ch.kind || "multipleOf" === ch.kind && util_util.isInteger(ch.value));
            }
            get isFinite() {
                let max = null;
                let min = null;
                for (const ch of this._def.checks)if ("finite" === ch.kind || "int" === ch.kind || "multipleOf" === ch.kind) return true;
                else if ("min" === ch.kind) {
                    if (null === min || ch.value > min) min = ch.value;
                } else if ("max" === ch.kind) {
                    if (null === max || ch.value < max) max = ch.value;
                }
                return Number.isFinite(min) && Number.isFinite(max);
            }
        }
        ZodNumber.create = (params)=>new ZodNumber({
                checks: [],
                typeName: types_ZodFirstPartyTypeKind.ZodNumber,
                coerce: params?.coerce || false,
                ...processCreateParams(params)
            });
        class ZodBigInt extends ZodType {
            constructor(){
                super(...arguments);
                this.min = this.gte;
                this.max = this.lte;
            }
            _parse(input) {
                if (this._def.coerce) try {
                    input.data = BigInt(input.data);
                } catch  {
                    return this._getInvalidInput(input);
                }
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.bigint) return this._getInvalidInput(input);
                let ctx;
                const status = new ParseStatus();
                for (const check of this._def.checks)if ("min" === check.kind) {
                    const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                    if (tooSmall) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            type: "bigint",
                            minimum: check.value,
                            inclusive: check.inclusive,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("max" === check.kind) {
                    const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                    if (tooBig) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            type: "bigint",
                            maximum: check.value,
                            inclusive: check.inclusive,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else if ("multipleOf" === check.kind) {
                    if (input.data % check.value !== BigInt(0)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.not_multiple_of,
                            multipleOf: check.value,
                            message: check.message
                        });
                        status.dirty();
                    }
                } else util_util.assertNever(check);
                return {
                    status: status.value,
                    value: input.data
                };
            }
            _getInvalidInput(input) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.bigint,
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
            gte(value, message) {
                return this.setLimit("min", value, true, errorUtil_errorUtil.toString(message));
            }
            gt(value, message) {
                return this.setLimit("min", value, false, errorUtil_errorUtil.toString(message));
            }
            lte(value, message) {
                return this.setLimit("max", value, true, errorUtil_errorUtil.toString(message));
            }
            lt(value, message) {
                return this.setLimit("max", value, false, errorUtil_errorUtil.toString(message));
            }
            setLimit(kind, value, inclusive, message) {
                return new ZodBigInt({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        {
                            kind,
                            value,
                            inclusive,
                            message: errorUtil_errorUtil.toString(message)
                        }
                    ]
                });
            }
            _addCheck(check) {
                return new ZodBigInt({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        check
                    ]
                });
            }
            positive(message) {
                return this._addCheck({
                    kind: "min",
                    value: BigInt(0),
                    inclusive: false,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            negative(message) {
                return this._addCheck({
                    kind: "max",
                    value: BigInt(0),
                    inclusive: false,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            nonpositive(message) {
                return this._addCheck({
                    kind: "max",
                    value: BigInt(0),
                    inclusive: true,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            nonnegative(message) {
                return this._addCheck({
                    kind: "min",
                    value: BigInt(0),
                    inclusive: true,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            multipleOf(value, message) {
                return this._addCheck({
                    kind: "multipleOf",
                    value,
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            get minValue() {
                let min = null;
                for (const ch of this._def.checks)if ("min" === ch.kind) {
                    if (null === min || ch.value > min) min = ch.value;
                }
                return min;
            }
            get maxValue() {
                let max = null;
                for (const ch of this._def.checks)if ("max" === ch.kind) {
                    if (null === max || ch.value < max) max = ch.value;
                }
                return max;
            }
        }
        ZodBigInt.create = (params)=>new ZodBigInt({
                checks: [],
                typeName: types_ZodFirstPartyTypeKind.ZodBigInt,
                coerce: params?.coerce ?? false,
                ...processCreateParams(params)
            });
        class ZodBoolean extends ZodType {
            _parse(input) {
                if (this._def.coerce) input.data = Boolean(input.data);
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.boolean) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.boolean,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                return OK(input.data);
            }
        }
        ZodBoolean.create = (params)=>new ZodBoolean({
                typeName: types_ZodFirstPartyTypeKind.ZodBoolean,
                coerce: params?.coerce || false,
                ...processCreateParams(params)
            });
        class ZodDate extends ZodType {
            _parse(input) {
                if (this._def.coerce) input.data = new Date(input.data);
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.date) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.date,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                if (Number.isNaN(input.data.getTime())) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_date
                    });
                    return parseUtil_INVALID;
                }
                const status = new ParseStatus();
                let ctx;
                for (const check of this._def.checks)if ("min" === check.kind) {
                    if (input.data.getTime() < check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            message: check.message,
                            inclusive: true,
                            exact: false,
                            minimum: check.value,
                            type: "date"
                        });
                        status.dirty();
                    }
                } else if ("max" === check.kind) {
                    if (input.data.getTime() > check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            message: check.message,
                            inclusive: true,
                            exact: false,
                            maximum: check.value,
                            type: "date"
                        });
                        status.dirty();
                    }
                } else util_util.assertNever(check);
                return {
                    status: status.value,
                    value: new Date(input.data.getTime())
                };
            }
            _addCheck(check) {
                return new ZodDate({
                    ...this._def,
                    checks: [
                        ...this._def.checks,
                        check
                    ]
                });
            }
            min(minDate, message) {
                return this._addCheck({
                    kind: "min",
                    value: minDate.getTime(),
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            max(maxDate, message) {
                return this._addCheck({
                    kind: "max",
                    value: maxDate.getTime(),
                    message: errorUtil_errorUtil.toString(message)
                });
            }
            get minDate() {
                let min = null;
                for (const ch of this._def.checks)if ("min" === ch.kind) {
                    if (null === min || ch.value > min) min = ch.value;
                }
                return null != min ? new Date(min) : null;
            }
            get maxDate() {
                let max = null;
                for (const ch of this._def.checks)if ("max" === ch.kind) {
                    if (null === max || ch.value < max) max = ch.value;
                }
                return null != max ? new Date(max) : null;
            }
        }
        ZodDate.create = (params)=>new ZodDate({
                checks: [],
                coerce: params?.coerce || false,
                typeName: types_ZodFirstPartyTypeKind.ZodDate,
                ...processCreateParams(params)
            });
        class ZodSymbol extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.symbol) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.symbol,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                return OK(input.data);
            }
        }
        ZodSymbol.create = (params)=>new ZodSymbol({
                typeName: types_ZodFirstPartyTypeKind.ZodSymbol,
                ...processCreateParams(params)
            });
        class ZodUndefined extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.undefined) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.undefined,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                return OK(input.data);
            }
        }
        ZodUndefined.create = (params)=>new ZodUndefined({
                typeName: types_ZodFirstPartyTypeKind.ZodUndefined,
                ...processCreateParams(params)
            });
        class ZodNull extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType["null"]) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType["null"],
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                return OK(input.data);
            }
        }
        ZodNull.create = (params)=>new ZodNull({
                typeName: types_ZodFirstPartyTypeKind.ZodNull,
                ...processCreateParams(params)
            });
        class ZodAny extends ZodType {
            constructor(){
                super(...arguments);
                this._any = true;
            }
            _parse(input) {
                return OK(input.data);
            }
        }
        ZodAny.create = (params)=>new ZodAny({
                typeName: types_ZodFirstPartyTypeKind.ZodAny,
                ...processCreateParams(params)
            });
        class ZodUnknown extends ZodType {
            constructor(){
                super(...arguments);
                this._unknown = true;
            }
            _parse(input) {
                return OK(input.data);
            }
        }
        ZodUnknown.create = (params)=>new ZodUnknown({
                typeName: types_ZodFirstPartyTypeKind.ZodUnknown,
                ...processCreateParams(params)
            });
        class ZodNever extends ZodType {
            _parse(input) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.never,
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
        }
        ZodNever.create = (params)=>new ZodNever({
                typeName: types_ZodFirstPartyTypeKind.ZodNever,
                ...processCreateParams(params)
            });
        class ZodVoid extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.undefined) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType["void"],
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                return OK(input.data);
            }
        }
        ZodVoid.create = (params)=>new ZodVoid({
                typeName: types_ZodFirstPartyTypeKind.ZodVoid,
                ...processCreateParams(params)
            });
        class ZodArray extends ZodType {
            _parse(input) {
                const { ctx, status } = this._processInputParams(input);
                const def = this._def;
                if (ctx.parsedType !== ZodParsedType.array) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.array,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                if (null !== def.exactLength) {
                    const tooBig = ctx.data.length > def.exactLength.value;
                    const tooSmall = ctx.data.length < def.exactLength.value;
                    if (tooBig || tooSmall) {
                        addIssueToContext(ctx, {
                            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                            minimum: tooSmall ? def.exactLength.value : void 0,
                            maximum: tooBig ? def.exactLength.value : void 0,
                            type: "array",
                            inclusive: true,
                            exact: true,
                            message: def.exactLength.message
                        });
                        status.dirty();
                    }
                }
                if (null !== def.minLength) {
                    if (ctx.data.length < def.minLength.value) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: def.minLength.value,
                            type: "array",
                            inclusive: true,
                            exact: false,
                            message: def.minLength.message
                        });
                        status.dirty();
                    }
                }
                if (null !== def.maxLength) {
                    if (ctx.data.length > def.maxLength.value) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: def.maxLength.value,
                            type: "array",
                            inclusive: true,
                            exact: false,
                            message: def.maxLength.message
                        });
                        status.dirty();
                    }
                }
                if (ctx.common.async) return Promise.all([
                    ...ctx.data
                ].map((item, i)=>def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i)))).then((result)=>ParseStatus.mergeArray(status, result));
                const result = [
                    ...ctx.data
                ].map((item, i)=>def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i)));
                return ParseStatus.mergeArray(status, result);
            }
            get element() {
                return this._def.type;
            }
            min(minLength, message) {
                return new ZodArray({
                    ...this._def,
                    minLength: {
                        value: minLength,
                        message: errorUtil_errorUtil.toString(message)
                    }
                });
            }
            max(maxLength, message) {
                return new ZodArray({
                    ...this._def,
                    maxLength: {
                        value: maxLength,
                        message: errorUtil_errorUtil.toString(message)
                    }
                });
            }
            length(len, message) {
                return new ZodArray({
                    ...this._def,
                    exactLength: {
                        value: len,
                        message: errorUtil_errorUtil.toString(message)
                    }
                });
            }
            nonempty(message) {
                return this.min(1, message);
            }
        }
        ZodArray.create = (schema, params)=>new ZodArray({
                type: schema,
                minLength: null,
                maxLength: null,
                exactLength: null,
                typeName: types_ZodFirstPartyTypeKind.ZodArray,
                ...processCreateParams(params)
            });
        function deepPartialify(schema) {
            if (schema instanceof ZodObject) {
                const newShape = {};
                for(const key in schema.shape){
                    const fieldSchema = schema.shape[key];
                    newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
                }
                return new ZodObject({
                    ...schema._def,
                    shape: ()=>newShape
                });
            }
            if (schema instanceof ZodArray) return new ZodArray({
                ...schema._def,
                type: deepPartialify(schema.element)
            });
            if (schema instanceof ZodOptional) return ZodOptional.create(deepPartialify(schema.unwrap()));
            if (schema instanceof ZodNullable) return ZodNullable.create(deepPartialify(schema.unwrap()));
            if (schema instanceof ZodTuple) return ZodTuple.create(schema.items.map((item)=>deepPartialify(item)));
            else return schema;
        }
        class ZodObject extends ZodType {
            constructor(){
                super(...arguments);
                this._cached = null;
                this.nonstrict = this.passthrough;
                this.augment = this.extend;
            }
            _getCached() {
                if (null !== this._cached) return this._cached;
                const shape = this._def.shape();
                const keys = util_util.objectKeys(shape);
                this._cached = {
                    shape,
                    keys
                };
                return this._cached;
            }
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.object) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.object,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                const { status, ctx } = this._processInputParams(input);
                const { shape, keys: shapeKeys } = this._getCached();
                const extraKeys = [];
                if (!(this._def.catchall instanceof ZodNever && "strip" === this._def.unknownKeys)) {
                    for(const key in ctx.data)if (!shapeKeys.includes(key)) extraKeys.push(key);
                }
                const pairs = [];
                for (const key of shapeKeys){
                    const keyValidator = shape[key];
                    const value = ctx.data[key];
                    pairs.push({
                        key: {
                            status: "valid",
                            value: key
                        },
                        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                        alwaysSet: key in ctx.data
                    });
                }
                if (this._def.catchall instanceof ZodNever) {
                    const unknownKeys = this._def.unknownKeys;
                    if ("passthrough" === unknownKeys) for (const key of extraKeys)pairs.push({
                        key: {
                            status: "valid",
                            value: key
                        },
                        value: {
                            status: "valid",
                            value: ctx.data[key]
                        }
                    });
                    else if ("strict" === unknownKeys) {
                        if (extraKeys.length > 0) {
                            addIssueToContext(ctx, {
                                code: ZodIssueCode.unrecognized_keys,
                                keys: extraKeys
                            });
                            status.dirty();
                        }
                    } else if ("strip" === unknownKeys) ;
                    else throw new Error("Internal ZodObject error: invalid unknownKeys value.");
                } else {
                    const catchall = this._def.catchall;
                    for (const key of extraKeys){
                        const value = ctx.data[key];
                        pairs.push({
                            key: {
                                status: "valid",
                                value: key
                            },
                            value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                            alwaysSet: key in ctx.data
                        });
                    }
                }
                if (ctx.common.async) return Promise.resolve().then(async ()=>{
                    const syncPairs = [];
                    for (const pair of pairs){
                        const key = await pair.key;
                        const value = await pair.value;
                        syncPairs.push({
                            key,
                            value,
                            alwaysSet: pair.alwaysSet
                        });
                    }
                    return syncPairs;
                }).then((syncPairs)=>ParseStatus.mergeObjectSync(status, syncPairs));
                return ParseStatus.mergeObjectSync(status, pairs);
            }
            get shape() {
                return this._def.shape();
            }
            strict(message) {
                errorUtil_errorUtil.errToObj;
                return new ZodObject({
                    ...this._def,
                    unknownKeys: "strict",
                    ...void 0 !== message ? {
                        errorMap: (issue, ctx)=>{
                            const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
                            if ("unrecognized_keys" === issue.code) return {
                                message: errorUtil_errorUtil.errToObj(message).message ?? defaultError
                            };
                            return {
                                message: defaultError
                            };
                        }
                    } : {}
                });
            }
            strip() {
                return new ZodObject({
                    ...this._def,
                    unknownKeys: "strip"
                });
            }
            passthrough() {
                return new ZodObject({
                    ...this._def,
                    unknownKeys: "passthrough"
                });
            }
            extend(augmentation) {
                return new ZodObject({
                    ...this._def,
                    shape: ()=>({
                            ...this._def.shape(),
                            ...augmentation
                        })
                });
            }
            merge(merging) {
                const merged = new ZodObject({
                    unknownKeys: merging._def.unknownKeys,
                    catchall: merging._def.catchall,
                    shape: ()=>({
                            ...this._def.shape(),
                            ...merging._def.shape()
                        }),
                    typeName: types_ZodFirstPartyTypeKind.ZodObject
                });
                return merged;
            }
            setKey(key, schema) {
                return this.augment({
                    [key]: schema
                });
            }
            catchall(index) {
                return new ZodObject({
                    ...this._def,
                    catchall: index
                });
            }
            pick(mask) {
                const shape = {};
                for (const key of util_util.objectKeys(mask))if (mask[key] && this.shape[key]) shape[key] = this.shape[key];
                return new ZodObject({
                    ...this._def,
                    shape: ()=>shape
                });
            }
            omit(mask) {
                const shape = {};
                for (const key of util_util.objectKeys(this.shape))if (!mask[key]) shape[key] = this.shape[key];
                return new ZodObject({
                    ...this._def,
                    shape: ()=>shape
                });
            }
            deepPartial() {
                return deepPartialify(this);
            }
            partial(mask) {
                const newShape = {};
                for (const key of util_util.objectKeys(this.shape)){
                    const fieldSchema = this.shape[key];
                    if (mask && !mask[key]) newShape[key] = fieldSchema;
                    else newShape[key] = fieldSchema.optional();
                }
                return new ZodObject({
                    ...this._def,
                    shape: ()=>newShape
                });
            }
            required(mask) {
                const newShape = {};
                for (const key of util_util.objectKeys(this.shape))if (mask && !mask[key]) newShape[key] = this.shape[key];
                else {
                    const fieldSchema = this.shape[key];
                    let newField = fieldSchema;
                    while(newField instanceof ZodOptional)newField = newField._def.innerType;
                    newShape[key] = newField;
                }
                return new ZodObject({
                    ...this._def,
                    shape: ()=>newShape
                });
            }
            keyof() {
                return createZodEnum(util_util.objectKeys(this.shape));
            }
        }
        ZodObject.create = (shape, params)=>new ZodObject({
                shape: ()=>shape,
                unknownKeys: "strip",
                catchall: ZodNever.create(),
                typeName: types_ZodFirstPartyTypeKind.ZodObject,
                ...processCreateParams(params)
            });
        ZodObject.strictCreate = (shape, params)=>new ZodObject({
                shape: ()=>shape,
                unknownKeys: "strict",
                catchall: ZodNever.create(),
                typeName: types_ZodFirstPartyTypeKind.ZodObject,
                ...processCreateParams(params)
            });
        ZodObject.lazycreate = (shape, params)=>new ZodObject({
                shape,
                unknownKeys: "strip",
                catchall: ZodNever.create(),
                typeName: types_ZodFirstPartyTypeKind.ZodObject,
                ...processCreateParams(params)
            });
        class ZodUnion extends ZodType {
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                const options = this._def.options;
                function handleResults(results) {
                    for (const result of results)if ("valid" === result.result.status) return result.result;
                    for (const result of results)if ("dirty" === result.result.status) {
                        ctx.common.issues.push(...result.ctx.common.issues);
                        return result.result;
                    }
                    const unionErrors = results.map((result)=>new ZodError(result.ctx.common.issues));
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_union,
                        unionErrors
                    });
                    return parseUtil_INVALID;
                }
                if (ctx.common.async) return Promise.all(options.map(async (option)=>{
                    const childCtx = {
                        ...ctx,
                        common: {
                            ...ctx.common,
                            issues: []
                        },
                        parent: null
                    };
                    return {
                        result: await option._parseAsync({
                            data: ctx.data,
                            path: ctx.path,
                            parent: childCtx
                        }),
                        ctx: childCtx
                    };
                })).then(handleResults);
                {
                    let dirty;
                    const issues = [];
                    for (const option of options){
                        const childCtx = {
                            ...ctx,
                            common: {
                                ...ctx.common,
                                issues: []
                            },
                            parent: null
                        };
                        const result = option._parseSync({
                            data: ctx.data,
                            path: ctx.path,
                            parent: childCtx
                        });
                        if ("valid" === result.status) return result;
                        if ("dirty" === result.status && !dirty) dirty = {
                            result,
                            ctx: childCtx
                        };
                        if (childCtx.common.issues.length) issues.push(childCtx.common.issues);
                    }
                    if (dirty) {
                        ctx.common.issues.push(...dirty.ctx.common.issues);
                        return dirty.result;
                    }
                    const unionErrors = issues.map((issues)=>new ZodError(issues));
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_union,
                        unionErrors
                    });
                    return parseUtil_INVALID;
                }
            }
            get options() {
                return this._def.options;
            }
        }
        ZodUnion.create = (types, params)=>new ZodUnion({
                options: types,
                typeName: types_ZodFirstPartyTypeKind.ZodUnion,
                ...processCreateParams(params)
            });
        const getDiscriminator = (type)=>{
            if (type instanceof ZodLazy) return getDiscriminator(type.schema);
            if (type instanceof ZodEffects) return getDiscriminator(type.innerType());
            if (type instanceof ZodLiteral) return [
                type.value
            ];
            if (type instanceof ZodEnum) return type.options;
            if (type instanceof ZodNativeEnum) return util_util.objectValues(type.enum);
            else if (type instanceof ZodDefault) return getDiscriminator(type._def.innerType);
            else if (type instanceof ZodUndefined) return [
                void 0
            ];
            else if (type instanceof ZodNull) return [
                null
            ];
            else if (type instanceof ZodOptional) return [
                void 0,
                ...getDiscriminator(type.unwrap())
            ];
            else if (type instanceof ZodNullable) return [
                null,
                ...getDiscriminator(type.unwrap())
            ];
            else if (type instanceof ZodBranded) return getDiscriminator(type.unwrap());
            else if (type instanceof ZodReadonly) return getDiscriminator(type.unwrap());
            else if (type instanceof ZodCatch) return getDiscriminator(type._def.innerType);
            else return [];
        };
        class ZodDiscriminatedUnion extends ZodType {
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType.object) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.object,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                const discriminator = this.discriminator;
                const discriminatorValue = ctx.data[discriminator];
                const option = this.optionsMap.get(discriminatorValue);
                if (!option) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_union_discriminator,
                        options: Array.from(this.optionsMap.keys()),
                        path: [
                            discriminator
                        ]
                    });
                    return parseUtil_INVALID;
                }
                if (ctx.common.async) return option._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                return option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
            }
            get discriminator() {
                return this._def.discriminator;
            }
            get options() {
                return this._def.options;
            }
            get optionsMap() {
                return this._def.optionsMap;
            }
            static create(discriminator, options, params) {
                const optionsMap = new Map();
                for (const type of options){
                    const discriminatorValues = getDiscriminator(type.shape[discriminator]);
                    if (!discriminatorValues.length) throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
                    for (const value of discriminatorValues){
                        if (optionsMap.has(value)) throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                        optionsMap.set(value, type);
                    }
                }
                return new ZodDiscriminatedUnion({
                    typeName: types_ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
                    discriminator,
                    options,
                    optionsMap,
                    ...processCreateParams(params)
                });
            }
        }
        function mergeValues(a, b) {
            const aType = getParsedType(a);
            const bType = getParsedType(b);
            if (a === b) return {
                valid: true,
                data: a
            };
            if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
                const bKeys = util_util.objectKeys(b);
                const sharedKeys = util_util.objectKeys(a).filter((key)=>-1 !== bKeys.indexOf(key));
                const newObj = {
                    ...a,
                    ...b
                };
                for (const key of sharedKeys){
                    const sharedValue = mergeValues(a[key], b[key]);
                    if (!sharedValue.valid) return {
                        valid: false
                    };
                    newObj[key] = sharedValue.data;
                }
                return {
                    valid: true,
                    data: newObj
                };
            }
            if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
                if (a.length !== b.length) return {
                    valid: false
                };
                const newArray = [];
                for(let index = 0; index < a.length; index++){
                    const itemA = a[index];
                    const itemB = b[index];
                    const sharedValue = mergeValues(itemA, itemB);
                    if (!sharedValue.valid) return {
                        valid: false
                    };
                    newArray.push(sharedValue.data);
                }
                return {
                    valid: true,
                    data: newArray
                };
            }
            if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) return {
                valid: true,
                data: a
            };
            return {
                valid: false
            };
        }
        class ZodIntersection extends ZodType {
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                const handleParsed = (parsedLeft, parsedRight)=>{
                    if (isAborted(parsedLeft) || isAborted(parsedRight)) return parseUtil_INVALID;
                    const merged = mergeValues(parsedLeft.value, parsedRight.value);
                    if (!merged.valid) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_intersection_types
                        });
                        return parseUtil_INVALID;
                    }
                    if (isDirty(parsedLeft) || isDirty(parsedRight)) status.dirty();
                    return {
                        status: status.value,
                        value: merged.data
                    };
                };
                if (ctx.common.async) return Promise.all([
                    this._def.left._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    }),
                    this._def.right._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    })
                ]).then(([left, right])=>handleParsed(left, right));
                return handleParsed(this._def.left._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }), this._def.right._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }));
            }
        }
        ZodIntersection.create = (left, right, params)=>new ZodIntersection({
                left: left,
                right: right,
                typeName: types_ZodFirstPartyTypeKind.ZodIntersection,
                ...processCreateParams(params)
            });
        class ZodTuple extends ZodType {
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType.array) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.array,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                if (ctx.data.length < this._def.items.length) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: this._def.items.length,
                        inclusive: true,
                        exact: false,
                        type: "array"
                    });
                    return parseUtil_INVALID;
                }
                const rest = this._def.rest;
                if (!rest && ctx.data.length > this._def.items.length) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: this._def.items.length,
                        inclusive: true,
                        exact: false,
                        type: "array"
                    });
                    status.dirty();
                }
                const items = [
                    ...ctx.data
                ].map((item, itemIndex)=>{
                    const schema = this._def.items[itemIndex] || this._def.rest;
                    if (!schema) return null;
                    return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
                }).filter((x)=>!!x);
                if (ctx.common.async) return Promise.all(items).then((results)=>ParseStatus.mergeArray(status, results));
                return ParseStatus.mergeArray(status, items);
            }
            get items() {
                return this._def.items;
            }
            rest(rest) {
                return new ZodTuple({
                    ...this._def,
                    rest
                });
            }
        }
        ZodTuple.create = (schemas, params)=>{
            if (!Array.isArray(schemas)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
            return new ZodTuple({
                items: schemas,
                typeName: types_ZodFirstPartyTypeKind.ZodTuple,
                rest: null,
                ...processCreateParams(params)
            });
        };
        class ZodRecord extends ZodType {
            get keySchema() {
                return this._def.keyType;
            }
            get valueSchema() {
                return this._def.valueType;
            }
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType.object) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.object,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                const pairs = [];
                const keyType = this._def.keyType;
                const valueType = this._def.valueType;
                for(const key in ctx.data)pairs.push({
                    key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                    value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
                    alwaysSet: key in ctx.data
                });
                if (ctx.common.async) return ParseStatus.mergeObjectAsync(status, pairs);
                return ParseStatus.mergeObjectSync(status, pairs);
            }
            get element() {
                return this._def.valueType;
            }
            static create(first, second, third) {
                if (second instanceof ZodType) return new ZodRecord({
                    keyType: first,
                    valueType: second,
                    typeName: types_ZodFirstPartyTypeKind.ZodRecord,
                    ...processCreateParams(third)
                });
                return new ZodRecord({
                    keyType: ZodString.create(),
                    valueType: first,
                    typeName: types_ZodFirstPartyTypeKind.ZodRecord,
                    ...processCreateParams(second)
                });
            }
        }
        class ZodMap extends ZodType {
            get keySchema() {
                return this._def.keyType;
            }
            get valueSchema() {
                return this._def.valueType;
            }
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType.map) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.map,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                const keyType = this._def.keyType;
                const valueType = this._def.valueType;
                const pairs = [
                    ...ctx.data.entries()
                ].map(([key, value], index)=>({
                        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [
                            index,
                            "key"
                        ])),
                        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [
                            index,
                            "value"
                        ]))
                    }));
                if (ctx.common.async) {
                    const finalMap = new Map();
                    return Promise.resolve().then(async ()=>{
                        for (const pair of pairs){
                            const key = await pair.key;
                            const value = await pair.value;
                            if ("aborted" === key.status || "aborted" === value.status) return parseUtil_INVALID;
                            if ("dirty" === key.status || "dirty" === value.status) status.dirty();
                            finalMap.set(key.value, value.value);
                        }
                        return {
                            status: status.value,
                            value: finalMap
                        };
                    });
                }
                {
                    const finalMap = new Map();
                    for (const pair of pairs){
                        const key = pair.key;
                        const value = pair.value;
                        if ("aborted" === key.status || "aborted" === value.status) return parseUtil_INVALID;
                        if ("dirty" === key.status || "dirty" === value.status) status.dirty();
                        finalMap.set(key.value, value.value);
                    }
                    return {
                        status: status.value,
                        value: finalMap
                    };
                }
            }
        }
        ZodMap.create = (keyType, valueType, params)=>new ZodMap({
                valueType,
                keyType,
                typeName: types_ZodFirstPartyTypeKind.ZodMap,
                ...processCreateParams(params)
            });
        class ZodSet extends ZodType {
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType.set) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.set,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                const def = this._def;
                if (null !== def.minSize) {
                    if (ctx.data.size < def.minSize.value) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: def.minSize.value,
                            type: "set",
                            inclusive: true,
                            exact: false,
                            message: def.minSize.message
                        });
                        status.dirty();
                    }
                }
                if (null !== def.maxSize) {
                    if (ctx.data.size > def.maxSize.value) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: def.maxSize.value,
                            type: "set",
                            inclusive: true,
                            exact: false,
                            message: def.maxSize.message
                        });
                        status.dirty();
                    }
                }
                const valueType = this._def.valueType;
                function finalizeSet(elements) {
                    const parsedSet = new Set();
                    for (const element of elements){
                        if ("aborted" === element.status) return parseUtil_INVALID;
                        if ("dirty" === element.status) status.dirty();
                        parsedSet.add(element.value);
                    }
                    return {
                        status: status.value,
                        value: parsedSet
                    };
                }
                const elements = [
                    ...ctx.data.values()
                ].map((item, i)=>valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
                if (ctx.common.async) return Promise.all(elements).then((elements)=>finalizeSet(elements));
                return finalizeSet(elements);
            }
            min(minSize, message) {
                return new ZodSet({
                    ...this._def,
                    minSize: {
                        value: minSize,
                        message: errorUtil_errorUtil.toString(message)
                    }
                });
            }
            max(maxSize, message) {
                return new ZodSet({
                    ...this._def,
                    maxSize: {
                        value: maxSize,
                        message: errorUtil_errorUtil.toString(message)
                    }
                });
            }
            size(size, message) {
                return this.min(size, message).max(size, message);
            }
            nonempty(message) {
                return this.min(1, message);
            }
        }
        ZodSet.create = (valueType, params)=>new ZodSet({
                valueType,
                minSize: null,
                maxSize: null,
                typeName: types_ZodFirstPartyTypeKind.ZodSet,
                ...processCreateParams(params)
            });
        class ZodFunction extends ZodType {
            constructor(){
                super(...arguments);
                this.validate = this.implement;
            }
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType["function"]) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType["function"],
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                function makeArgsIssue(args, error) {
                    return makeIssue({
                        data: args,
                        path: ctx.path,
                        errorMaps: [
                            ctx.common.contextualErrorMap,
                            ctx.schemaErrorMap,
                            getErrorMap(),
                            en
                        ].filter((x)=>!!x),
                        issueData: {
                            code: ZodIssueCode.invalid_arguments,
                            argumentsError: error
                        }
                    });
                }
                function makeReturnsIssue(returns, error) {
                    return makeIssue({
                        data: returns,
                        path: ctx.path,
                        errorMaps: [
                            ctx.common.contextualErrorMap,
                            ctx.schemaErrorMap,
                            getErrorMap(),
                            en
                        ].filter((x)=>!!x),
                        issueData: {
                            code: ZodIssueCode.invalid_return_type,
                            returnTypeError: error
                        }
                    });
                }
                const params = {
                    errorMap: ctx.common.contextualErrorMap
                };
                const fn = ctx.data;
                if (this._def.returns instanceof ZodPromise) {
                    const me = this;
                    return OK(async function(...args) {
                        const error = new ZodError([]);
                        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e)=>{
                            error.addIssue(makeArgsIssue(args, e));
                            throw error;
                        });
                        const result = await Reflect.apply(fn, this, parsedArgs);
                        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e)=>{
                            error.addIssue(makeReturnsIssue(result, e));
                            throw error;
                        });
                        return parsedReturns;
                    });
                }
                {
                    const me = this;
                    return OK(function(...args) {
                        const parsedArgs = me._def.args.safeParse(args, params);
                        if (!parsedArgs.success) throw new ZodError([
                            makeArgsIssue(args, parsedArgs.error)
                        ]);
                        const result = Reflect.apply(fn, this, parsedArgs.data);
                        const parsedReturns = me._def.returns.safeParse(result, params);
                        if (!parsedReturns.success) throw new ZodError([
                            makeReturnsIssue(result, parsedReturns.error)
                        ]);
                        return parsedReturns.data;
                    });
                }
            }
            parameters() {
                return this._def.args;
            }
            returnType() {
                return this._def.returns;
            }
            args(...items) {
                return new ZodFunction({
                    ...this._def,
                    args: ZodTuple.create(items).rest(ZodUnknown.create())
                });
            }
            returns(returnType) {
                return new ZodFunction({
                    ...this._def,
                    returns: returnType
                });
            }
            implement(func) {
                const validatedFunc = this.parse(func);
                return validatedFunc;
            }
            strictImplement(func) {
                const validatedFunc = this.parse(func);
                return validatedFunc;
            }
            static create(args, returns, params) {
                return new ZodFunction({
                    args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
                    returns: returns || ZodUnknown.create(),
                    typeName: types_ZodFirstPartyTypeKind.ZodFunction,
                    ...processCreateParams(params)
                });
            }
        }
        class ZodLazy extends ZodType {
            get schema() {
                return this._def.getter();
            }
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                const lazySchema = this._def.getter();
                return lazySchema._parse({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
            }
        }
        ZodLazy.create = (getter, params)=>new ZodLazy({
                getter: getter,
                typeName: types_ZodFirstPartyTypeKind.ZodLazy,
                ...processCreateParams(params)
            });
        class ZodLiteral extends ZodType {
            _parse(input) {
                if (input.data !== this._def.value) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        received: ctx.data,
                        code: ZodIssueCode.invalid_literal,
                        expected: this._def.value
                    });
                    return parseUtil_INVALID;
                }
                return {
                    status: "valid",
                    value: input.data
                };
            }
            get value() {
                return this._def.value;
            }
        }
        ZodLiteral.create = (value, params)=>new ZodLiteral({
                value: value,
                typeName: types_ZodFirstPartyTypeKind.ZodLiteral,
                ...processCreateParams(params)
            });
        function createZodEnum(values, params) {
            return new ZodEnum({
                values,
                typeName: types_ZodFirstPartyTypeKind.ZodEnum,
                ...processCreateParams(params)
            });
        }
        class ZodEnum extends ZodType {
            _parse(input) {
                if ("string" != typeof input.data) {
                    const ctx = this._getOrReturnCtx(input);
                    const expectedValues = this._def.values;
                    addIssueToContext(ctx, {
                        expected: util_util.joinValues(expectedValues),
                        received: ctx.parsedType,
                        code: ZodIssueCode.invalid_type
                    });
                    return parseUtil_INVALID;
                }
                if (!this._cache) this._cache = new Set(this._def.values);
                if (!this._cache.has(input.data)) {
                    const ctx = this._getOrReturnCtx(input);
                    const expectedValues = this._def.values;
                    addIssueToContext(ctx, {
                        received: ctx.data,
                        code: ZodIssueCode.invalid_enum_value,
                        options: expectedValues
                    });
                    return parseUtil_INVALID;
                }
                return OK(input.data);
            }
            get options() {
                return this._def.values;
            }
            get enum() {
                const enumValues = {};
                for (const val of this._def.values)enumValues[val] = val;
                return enumValues;
            }
            get Values() {
                const enumValues = {};
                for (const val of this._def.values)enumValues[val] = val;
                return enumValues;
            }
            get Enum() {
                const enumValues = {};
                for (const val of this._def.values)enumValues[val] = val;
                return enumValues;
            }
            extract(values, newDef = this._def) {
                return ZodEnum.create(values, {
                    ...this._def,
                    ...newDef
                });
            }
            exclude(values, newDef = this._def) {
                return ZodEnum.create(this.options.filter((opt)=>!values.includes(opt)), {
                    ...this._def,
                    ...newDef
                });
            }
        }
        ZodEnum.create = createZodEnum;
        class ZodNativeEnum extends ZodType {
            _parse(input) {
                const nativeEnumValues = util_util.getValidEnumValues(this._def.values);
                const ctx = this._getOrReturnCtx(input);
                if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
                    const expectedValues = util_util.objectValues(nativeEnumValues);
                    addIssueToContext(ctx, {
                        expected: util_util.joinValues(expectedValues),
                        received: ctx.parsedType,
                        code: ZodIssueCode.invalid_type
                    });
                    return parseUtil_INVALID;
                }
                if (!this._cache) this._cache = new Set(util_util.getValidEnumValues(this._def.values));
                if (!this._cache.has(input.data)) {
                    const expectedValues = util_util.objectValues(nativeEnumValues);
                    addIssueToContext(ctx, {
                        received: ctx.data,
                        code: ZodIssueCode.invalid_enum_value,
                        options: expectedValues
                    });
                    return parseUtil_INVALID;
                }
                return OK(input.data);
            }
            get enum() {
                return this._def.values;
            }
        }
        ZodNativeEnum.create = (values, params)=>new ZodNativeEnum({
                values: values,
                typeName: types_ZodFirstPartyTypeKind.ZodNativeEnum,
                ...processCreateParams(params)
            });
        class ZodPromise extends ZodType {
            unwrap() {
                return this._def.type;
            }
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                if (ctx.parsedType !== ZodParsedType.promise && false === ctx.common.async) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.promise,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
                return OK(promisified.then((data)=>this._def.type.parseAsync(data, {
                        path: ctx.path,
                        errorMap: ctx.common.contextualErrorMap
                    })));
            }
        }
        ZodPromise.create = (schema, params)=>new ZodPromise({
                type: schema,
                typeName: types_ZodFirstPartyTypeKind.ZodPromise,
                ...processCreateParams(params)
            });
        class ZodEffects extends ZodType {
            innerType() {
                return this._def.schema;
            }
            sourceType() {
                return this._def.schema._def.typeName === types_ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
            }
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                const effect = this._def.effect || null;
                const checkCtx = {
                    addIssue: (arg)=>{
                        addIssueToContext(ctx, arg);
                        if (arg.fatal) status.abort();
                        else status.dirty();
                    },
                    get path () {
                        return ctx.path;
                    }
                };
                checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
                if ("preprocess" === effect.type) {
                    const processed = effect.transform(ctx.data, checkCtx);
                    if (ctx.common.async) return Promise.resolve(processed).then(async (processed)=>{
                        if ("aborted" === status.value) return parseUtil_INVALID;
                        const result = await this._def.schema._parseAsync({
                            data: processed,
                            path: ctx.path,
                            parent: ctx
                        });
                        if ("aborted" === result.status) return parseUtil_INVALID;
                        if ("dirty" === result.status) return DIRTY(result.value);
                        if ("dirty" === status.value) return DIRTY(result.value);
                        return result;
                    });
                    {
                        if ("aborted" === status.value) return parseUtil_INVALID;
                        const result = this._def.schema._parseSync({
                            data: processed,
                            path: ctx.path,
                            parent: ctx
                        });
                        if ("aborted" === result.status) return parseUtil_INVALID;
                        if ("dirty" === result.status) return DIRTY(result.value);
                        if ("dirty" === status.value) return DIRTY(result.value);
                        return result;
                    }
                }
                if ("refinement" === effect.type) {
                    const executeRefinement = (acc)=>{
                        const result = effect.refinement(acc, checkCtx);
                        if (ctx.common.async) return Promise.resolve(result);
                        if (result instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                        return acc;
                    };
                    if (false !== ctx.common.async) return this._def.schema._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    }).then((inner)=>{
                        if ("aborted" === inner.status) return parseUtil_INVALID;
                        if ("dirty" === inner.status) status.dirty();
                        return executeRefinement(inner.value).then(()=>({
                                status: status.value,
                                value: inner.value
                            }));
                    });
                    {
                        const inner = this._def.schema._parseSync({
                            data: ctx.data,
                            path: ctx.path,
                            parent: ctx
                        });
                        if ("aborted" === inner.status) return parseUtil_INVALID;
                        if ("dirty" === inner.status) status.dirty();
                        executeRefinement(inner.value);
                        return {
                            status: status.value,
                            value: inner.value
                        };
                    }
                }
                if ("transform" === effect.type) if (false !== ctx.common.async) return this._def.schema._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }).then((base)=>{
                    if (!isValid(base)) return parseUtil_INVALID;
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result)=>({
                            status: status.value,
                            value: result
                        }));
                });
                else {
                    const base = this._def.schema._parseSync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    });
                    if (!isValid(base)) return parseUtil_INVALID;
                    const result = effect.transform(base.value, checkCtx);
                    if (result instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                    return {
                        status: status.value,
                        value: result
                    };
                }
                util_util.assertNever(effect);
            }
        }
        ZodEffects.create = (schema, effect, params)=>new ZodEffects({
                schema,
                typeName: types_ZodFirstPartyTypeKind.ZodEffects,
                effect,
                ...processCreateParams(params)
            });
        ZodEffects.createWithPreprocess = (preprocess, schema, params)=>new ZodEffects({
                schema,
                effect: {
                    type: "preprocess",
                    transform: preprocess
                },
                typeName: types_ZodFirstPartyTypeKind.ZodEffects,
                ...processCreateParams(params)
            });
        class ZodOptional extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType === ZodParsedType.undefined) return OK(void 0);
                return this._def.innerType._parse(input);
            }
            unwrap() {
                return this._def.innerType;
            }
        }
        ZodOptional.create = (type, params)=>new ZodOptional({
                innerType: type,
                typeName: types_ZodFirstPartyTypeKind.ZodOptional,
                ...processCreateParams(params)
            });
        class ZodNullable extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType === ZodParsedType["null"]) return OK(null);
                return this._def.innerType._parse(input);
            }
            unwrap() {
                return this._def.innerType;
            }
        }
        ZodNullable.create = (type, params)=>new ZodNullable({
                innerType: type,
                typeName: types_ZodFirstPartyTypeKind.ZodNullable,
                ...processCreateParams(params)
            });
        class ZodDefault extends ZodType {
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                let data = ctx.data;
                if (ctx.parsedType === ZodParsedType.undefined) data = this._def.defaultValue();
                return this._def.innerType._parse({
                    data,
                    path: ctx.path,
                    parent: ctx
                });
            }
            removeDefault() {
                return this._def.innerType;
            }
        }
        ZodDefault.create = (type, params)=>new ZodDefault({
                innerType: type,
                typeName: types_ZodFirstPartyTypeKind.ZodDefault,
                defaultValue: "function" == typeof params.default ? params.default : ()=>params.default,
                ...processCreateParams(params)
            });
        class ZodCatch extends ZodType {
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                const newCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: []
                    }
                };
                const result = this._def.innerType._parse({
                    data: newCtx.data,
                    path: newCtx.path,
                    parent: {
                        ...newCtx
                    }
                });
                if (isAsync(result)) return result.then((result)=>({
                        status: "valid",
                        value: "valid" === result.status ? result.value : this._def.catchValue({
                            get error () {
                                return new ZodError(newCtx.common.issues);
                            },
                            input: newCtx.data
                        })
                    }));
                return {
                    status: "valid",
                    value: "valid" === result.status ? result.value : this._def.catchValue({
                        get error () {
                            return new ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data
                    })
                };
            }
            removeCatch() {
                return this._def.innerType;
            }
        }
        ZodCatch.create = (type, params)=>new ZodCatch({
                innerType: type,
                typeName: types_ZodFirstPartyTypeKind.ZodCatch,
                catchValue: "function" == typeof params.catch ? params.catch : ()=>params.catch,
                ...processCreateParams(params)
            });
        class ZodNaN extends ZodType {
            _parse(input) {
                const parsedType = this._getType(input);
                if (parsedType !== ZodParsedType.nan) {
                    const ctx = this._getOrReturnCtx(input);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: ZodParsedType.nan,
                        received: ctx.parsedType
                    });
                    return parseUtil_INVALID;
                }
                return {
                    status: "valid",
                    value: input.data
                };
            }
        }
        ZodNaN.create = (params)=>new ZodNaN({
                typeName: types_ZodFirstPartyTypeKind.ZodNaN,
                ...processCreateParams(params)
            });
        Symbol("zod_brand");
        class ZodBranded extends ZodType {
            _parse(input) {
                const { ctx } = this._processInputParams(input);
                const data = ctx.data;
                return this._def.type._parse({
                    data,
                    path: ctx.path,
                    parent: ctx
                });
            }
            unwrap() {
                return this._def.type;
            }
        }
        class ZodPipeline extends ZodType {
            _parse(input) {
                const { status, ctx } = this._processInputParams(input);
                if (ctx.common.async) {
                    const handleAsync = async ()=>{
                        const inResult = await this._def.in._parseAsync({
                            data: ctx.data,
                            path: ctx.path,
                            parent: ctx
                        });
                        if ("aborted" === inResult.status) return parseUtil_INVALID;
                        if ("dirty" !== inResult.status) return this._def.out._parseAsync({
                            data: inResult.value,
                            path: ctx.path,
                            parent: ctx
                        });
                        status.dirty();
                        return DIRTY(inResult.value);
                    };
                    return handleAsync();
                }
                {
                    const inResult = this._def.in._parseSync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    });
                    if ("aborted" === inResult.status) return parseUtil_INVALID;
                    if ("dirty" !== inResult.status) return this._def.out._parseSync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx
                    });
                    status.dirty();
                    return {
                        status: "dirty",
                        value: inResult.value
                    };
                }
            }
            static create(a, b) {
                return new ZodPipeline({
                    in: a,
                    out: b,
                    typeName: types_ZodFirstPartyTypeKind.ZodPipeline
                });
            }
        }
        class ZodReadonly extends ZodType {
            _parse(input) {
                const result = this._def.innerType._parse(input);
                const freeze = (data)=>{
                    if (isValid(data)) data.value = Object.freeze(data.value);
                    return data;
                };
                return isAsync(result) ? result.then((data)=>freeze(data)) : freeze(result);
            }
            unwrap() {
                return this._def.innerType;
            }
        }
        ZodReadonly.create = (type, params)=>new ZodReadonly({
                innerType: type,
                typeName: types_ZodFirstPartyTypeKind.ZodReadonly,
                ...processCreateParams(params)
            });
        ZodObject.lazycreate;
        var types_ZodFirstPartyTypeKind;
        (function(ZodFirstPartyTypeKind) {
            ZodFirstPartyTypeKind["ZodString"] = "ZodString";
            ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
            ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
            ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
            ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
            ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
            ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
            ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
            ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
            ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
            ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
            ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
            ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
            ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
            ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
            ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
            ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
            ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
            ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
            ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
            ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
            ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
            ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
            ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
            ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
            ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
            ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
            ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
            ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
            ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
            ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
            ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
            ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
            ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
            ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
            ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
        })(types_ZodFirstPartyTypeKind || (types_ZodFirstPartyTypeKind = {}));
        ZodString.create;
        ZodNumber.create;
        ZodNaN.create;
        ZodBigInt.create;
        ZodBoolean.create;
        ZodDate.create;
        ZodSymbol.create;
        ZodUndefined.create;
        ZodNull.create;
        ZodAny.create;
        ZodUnknown.create;
        ZodNever.create;
        ZodVoid.create;
        ZodArray.create;
        ZodObject.create;
        ZodObject.strictCreate;
        ZodUnion.create;
        ZodDiscriminatedUnion.create;
        ZodIntersection.create;
        ZodTuple.create;
        ZodRecord.create;
        ZodMap.create;
        ZodSet.create;
        ZodFunction.create;
        ZodLazy.create;
        ZodLiteral.create;
        ZodEnum.create;
        ZodNativeEnum.create;
        ZodPromise.create;
        ZodEffects.create;
        ZodOptional.create;
        ZodNullable.create;
        ZodEffects.createWithPreprocess;
        ZodPipeline.create;
    },
    "../agent-tars-interface/dist/cli.mjs": function() {},
    "../agent-tars-interface/dist/config.mjs": function() {},
    "../agent-tars-interface/dist/core.mjs": function() {},
    "../agent-tars-interface/dist/define-config.mjs": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            Z: ()=>defineConfig
        });
        function defineConfig(config) {
            return config;
        }
    },
    "../agent-tars-interface/dist/index.mjs": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, {
            LogLevel: ()=>_mcp_agent_interface__WEBPACK_IMPORTED_MODULE_0__.i,
            defineConfig: ()=>_define_config_mjs__WEBPACK_IMPORTED_MODULE_5__.Z
        });
        var _mcp_agent_interface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../mcp-agent-interface/dist/index.mjs");
        var _config_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../agent-tars-interface/dist/config.mjs");
        var __WEBPACK_REEXPORT_OBJECT__ = {};
        for(var __WEBPACK_IMPORT_KEY__ in _config_mjs__WEBPACK_IMPORTED_MODULE_1__)if ([
            "default",
            "LogLevel"
        ].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = (function(key) {
            return _config_mjs__WEBPACK_IMPORTED_MODULE_1__[key];
        }).bind(0, __WEBPACK_IMPORT_KEY__);
        __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
        var _core_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../agent-tars-interface/dist/core.mjs");
        var __WEBPACK_REEXPORT_OBJECT__ = {};
        for(var __WEBPACK_IMPORT_KEY__ in _core_mjs__WEBPACK_IMPORTED_MODULE_2__)if ([
            "default",
            "LogLevel"
        ].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = (function(key) {
            return _core_mjs__WEBPACK_IMPORTED_MODULE_2__[key];
        }).bind(0, __WEBPACK_IMPORT_KEY__);
        __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
        var _server_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("../agent-tars-interface/dist/server.mjs");
        var __WEBPACK_REEXPORT_OBJECT__ = {};
        for(var __WEBPACK_IMPORT_KEY__ in _server_mjs__WEBPACK_IMPORTED_MODULE_3__)if ([
            "default",
            "LogLevel"
        ].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = (function(key) {
            return _server_mjs__WEBPACK_IMPORTED_MODULE_3__[key];
        }).bind(0, __WEBPACK_IMPORT_KEY__);
        __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
        var _cli_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../agent-tars-interface/dist/cli.mjs");
        var __WEBPACK_REEXPORT_OBJECT__ = {};
        for(var __WEBPACK_IMPORT_KEY__ in _cli_mjs__WEBPACK_IMPORTED_MODULE_4__)if ([
            "default",
            "LogLevel"
        ].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = (function(key) {
            return _cli_mjs__WEBPACK_IMPORTED_MODULE_4__[key];
        }).bind(0, __WEBPACK_IMPORT_KEY__);
        __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
        var _define_config_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("../agent-tars-interface/dist/define-config.mjs");
    },
    "../agent-tars-interface/dist/server.mjs": function() {},
    "./src/core/SocketHandlers.ts": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            L: ()=>SocketHandlers,
            s: ()=>setupSocketIO
        });
        var dist = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/index.js");
        const { Server, Namespace, Socket } = dist;
        var error_handler = __webpack_require__("./src/utils/error-handler.ts");
        function setupSocketIO(httpServer, server) {
            const io = new Server(httpServer, {
                cors: {
                    origin: '*',
                    methods: [
                        'GET',
                        'POST'
                    ]
                }
            });
            io.on('connection', (socket)=>{
                SocketHandlers.handleConnection(socket, server);
            });
            return io;
        }
        class SocketHandlers {
            static handleConnection(socket, server) {
                console.log('Client connected:', socket.id);
                socket.on('ping', (callback)=>{
                    if ('function' == typeof callback) callback();
                });
                socket.on('join-session', (sessionId)=>{
                    SocketHandlers.handleJoinSession(socket, server, sessionId);
                });
                socket.on('send-query', async ({ sessionId, query })=>{
                    await SocketHandlers.handleSendQuery(socket, server, sessionId, query);
                });
                socket.on('abort-query', async ({ sessionId })=>{
                    await SocketHandlers.handleAbortQuery(socket, server, sessionId);
                });
                socket.on('disconnect', ()=>{
                    console.log('Client disconnected:', socket.id);
                });
            }
            static handleJoinSession(socket, server, sessionId) {
                if (server.sessions[sessionId]) {
                    socket.join(sessionId);
                    console.log(`Client ${socket.id} joined session ${sessionId}`);
                    const eventHandler = (eventType, data)=>{
                        socket.emit('agent-event', {
                            type: eventType,
                            data
                        });
                    };
                    const initialStatus = {
                        isProcessing: server.sessions[sessionId].getProcessingStatus(),
                        state: server.sessions[sessionId].agent.status()
                    };
                    socket.emit('agent-status', initialStatus);
                    server.sessions[sessionId].eventBridge.subscribe(eventHandler);
                    socket.on('disconnect', ()=>{
                        if (server.sessions[sessionId]) server.sessions[sessionId].eventBridge.unsubscribe(eventHandler);
                    });
                } else socket.emit('error', 'Session not found');
            }
            static async handleSendQuery(socket, server, sessionId, query) {
                if (server.sessions[sessionId]) try {
                    const response = await server.sessions[sessionId].runQuery(query);
                    if (!response.success && response.error) socket.emit('error', response.error.message);
                } catch (error) {
                    const handledError = (0, error_handler.rB)(error);
                    console.error('Unexpected error in socket query:', handledError);
                    socket.emit('error', handledError.message);
                }
                else socket.emit('error', 'Session not found');
            }
            static async handleAbortQuery(socket, server, sessionId) {
                if (server.sessions[sessionId]) try {
                    const aborted = await server.sessions[sessionId].abortQuery();
                    socket.emit('abort-result', {
                        success: aborted
                    });
                } catch (error) {
                    console.error('Error aborting query:', error);
                    socket.emit('error', 'Failed to abort query');
                }
                else socket.emit('error', 'Session not found');
            }
        }
    },
    "./src/core/index.ts": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            iF: ()=>AgioProvider,
            ZT: ()=>AgentSession,
            sI: ()=>SocketHandlers.s,
            Lw: ()=>SocketHandlers.L
        });
        var external_path_ = __webpack_require__("path");
        var external_path_default = /*#__PURE__*/ __webpack_require__.n(external_path_);
        var core_ = __webpack_require__("@agent-tars/core");
        var external_fs_ = __webpack_require__("fs");
        var external_fs_default = /*#__PURE__*/ __webpack_require__.n(external_fs_);
        var dist = __webpack_require__("../agent-interface/dist/index.mjs");
        var logger_dist = __webpack_require__("../node_modules/.pnpm/@agent-infra+logger@0.0.2-beta.2/node_modules/@agent-infra/logger/dist/index.mjs");
        const logger = new logger_dist.kw('[AgentSnapshot]');
        var fast_json_stable_stringify = __webpack_require__("../node_modules/.pnpm/fast-json-stable-stringify@2.1.0/node_modules/fast-json-stable-stringify/index.js");
        var fast_json_stable_stringify_default = /*#__PURE__*/ __webpack_require__.n(fast_json_stable_stringify);
        function _define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        const DEFAULT_CONFIG = {
            fieldsToNormalize: [
                {
                    pattern: /id$/,
                    replacement: '<<ID>>'
                },
                {
                    pattern: 'timestamp',
                    replacement: '<<TIMESTAMP>>'
                },
                {
                    pattern: 'created',
                    replacement: '<<TIMESTAMP>>'
                },
                {
                    pattern: 'startTime',
                    replacement: '<<TIMESTAMP>>'
                },
                {
                    pattern: 'elapsedMs',
                    replacement: '<<elapsedMs>>'
                },
                {
                    pattern: 'image_url',
                    replacement: '<<image_url>>'
                },
                {
                    pattern: 'toolCallId',
                    replacement: '<<toolCallId>>'
                },
                {
                    pattern: 'sessionId',
                    replacement: '<<sessionId>>'
                },
                {
                    pattern: 'messageId',
                    replacement: '<<messageId>>'
                },
                {
                    pattern: /Time$/,
                    replacement: '<<TIMESTAMP>>'
                }
            ],
            fieldsToIgnore: []
        };
        class SimpleDiffer {
            diff(expected, actual, expectedLabel = 'Expected', actualLabel = 'Actual') {
                const expectedLines = expected.split('\n');
                const actualLines = actual.split('\n');
                const diffLines = [];
                diffLines.push(`--- ${expectedLabel}`);
                diffLines.push(`+++ ${actualLabel}`);
                const lcs = this.longestCommonSubsequence(expectedLines, actualLines);
                const changes = this.generateChanges(expectedLines, actualLines, lcs);
                const hunks = this.groupChangesIntoHunks(changes, expectedLines.length, actualLines.length);
                for (const hunk of hunks){
                    diffLines.push(`@@ -${hunk.oldStart},${hunk.oldCount} +${hunk.newStart},${hunk.newCount} @@`);
                    diffLines.push(...hunk.lines);
                }
                return diffLines.join('\n');
            }
            longestCommonSubsequence(a, b) {
                const m = a.length;
                const n = b.length;
                const dp = Array(m + 1).fill(null).map(()=>Array(n + 1).fill(0));
                for(let i = 1; i <= m; i++)for(let j = 1; j <= n; j++)if (a[i - 1] === b[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                return dp;
            }
            generateChanges(expected, actual, lcs) {
                const changes = [];
                let i = expected.length;
                let j = actual.length;
                while(i > 0 || j > 0)if (i > 0 && j > 0 && expected[i - 1] === actual[j - 1]) {
                    changes.unshift({
                        type: 'equal',
                        expectedIndex: i - 1,
                        actualIndex: j - 1,
                        line: expected[i - 1]
                    });
                    i--;
                    j--;
                } else if (j > 0 && (0 === i || lcs[i][j - 1] >= lcs[i - 1][j])) {
                    changes.unshift({
                        type: 'add',
                        expectedIndex: -1,
                        actualIndex: j - 1,
                        line: actual[j - 1]
                    });
                    j--;
                } else if (i > 0) {
                    changes.unshift({
                        type: 'remove',
                        expectedIndex: i - 1,
                        actualIndex: -1,
                        line: expected[i - 1]
                    });
                    i--;
                }
                return changes;
            }
            groupChangesIntoHunks(changes, expectedLength, actualLength) {
                const hunks = [];
                let currentHunk = null;
                for(let i = 0; i < changes.length; i++){
                    const change = changes[i];
                    if ('equal' !== change.type) {
                        if (!currentHunk) {
                            var _changes_contextStart, _changes_contextStart1;
                            const contextStart = Math.max(0, i - this.contextLines);
                            currentHunk = {
                                oldStart: (null == (_changes_contextStart = changes[contextStart]) ? void 0 : _changes_contextStart.expectedIndex) + 1 || 1,
                                oldCount: 0,
                                newStart: (null == (_changes_contextStart1 = changes[contextStart]) ? void 0 : _changes_contextStart1.actualIndex) + 1 || 1,
                                newCount: 0,
                                lines: []
                            };
                            for(let j = contextStart; j < i; j++)if ('equal' === changes[j].type) {
                                currentHunk.lines.push(` ${changes[j].line}`);
                                currentHunk.oldCount++;
                                currentHunk.newCount++;
                            }
                        }
                        if ('remove' === change.type) {
                            currentHunk.lines.push(`-${change.line}`);
                            currentHunk.oldCount++;
                        } else if ('add' === change.type) {
                            currentHunk.lines.push(`+${change.line}`);
                            currentHunk.newCount++;
                        }
                    } else if (currentHunk) {
                        currentHunk.lines.push(` ${change.line}`);
                        currentHunk.oldCount++;
                        currentHunk.newCount++;
                        const nextChanges = changes.slice(i + 1, i + 1 + 2 * this.contextLines);
                        const hasMoreChanges = nextChanges.some((c)=>'equal' !== c.type);
                        if (!hasMoreChanges || i === changes.length - 1) {
                            var _changes_j;
                            const contextEnd = Math.min(i + this.contextLines, changes.length - 1);
                            for(let j = i + 1; j <= contextEnd; j++)if ((null == (_changes_j = changes[j]) ? void 0 : _changes_j.type) === 'equal') {
                                currentHunk.lines.push(` ${changes[j].line}`);
                                currentHunk.oldCount++;
                                currentHunk.newCount++;
                            }
                            hunks.push(currentHunk);
                            currentHunk = null;
                        }
                    }
                }
                return hunks;
            }
            constructor(contextLines = 3){
                _define_property(this, "contextLines", void 0);
                this.contextLines = contextLines;
            }
        }
        class AgentSnapshotNormalizer {
            normalize(obj, path = '') {
                if ('' === path) this.seenObjects = new WeakMap();
                if (null == obj) return obj;
                if ('object' == typeof obj) {
                    if (this.seenObjects.has(obj)) return '[Circular Reference]';
                    this.seenObjects.set(obj, true);
                }
                if (Array.isArray(obj)) return obj.map((item, index)=>this.normalize(item, `${path}[${index}]`));
                if ('object' == typeof obj) {
                    const result = {};
                    for (const [key, value] of Object.entries(obj)){
                        const currentPath = path ? `${path}.${key}` : key;
                        if (this.shouldIgnoreField(key, currentPath)) continue;
                        const normalized = this.normalizeField(key, value, currentPath);
                        if (void 0 !== normalized) result[key] = normalized;
                        else if ('object' == typeof value && null !== value) result[key] = this.normalize(value, currentPath);
                        else result[key] = value;
                    }
                    return result;
                }
                return obj;
            }
            shouldIgnoreField(key, path) {
                var _this_config_fieldsToIgnore;
                return (null == (_this_config_fieldsToIgnore = this.config.fieldsToIgnore) ? void 0 : _this_config_fieldsToIgnore.some((pattern)=>{
                    if (pattern instanceof RegExp) return pattern.test(key) || pattern.test(path);
                    return key === pattern || path === pattern;
                })) || false;
            }
            normalizeField(key, value, path) {
                if (this.config.customNormalizers) {
                    for (const { pattern, normalizer } of this.config.customNormalizers)if (pattern instanceof RegExp && (pattern.test(key) || pattern.test(path)) || key === pattern || path === pattern) return normalizer(value, path);
                }
                if (this.config.fieldsToNormalize) {
                    for (const { pattern, replacement, deep = true } of this.config.fieldsToNormalize)if (pattern instanceof RegExp && (pattern.test(key) || pattern.test(path)) || key === pattern || path === pattern) return replacement;
                }
            }
            compare(expected, actual) {
                const normalizedExpected = this.normalize(expected);
                const normalizedActual = this.normalize(actual);
                const expectedString = fast_json_stable_stringify_default()(normalizedExpected);
                const actualString = fast_json_stable_stringify_default()(normalizedActual);
                if (expectedString === actualString) return {
                    equal: true,
                    diff: null
                };
                const diff = this.differ.diff(JSON.stringify(normalizedExpected, null, 2), JSON.stringify(normalizedActual, null, 2), 'Created Agent Snapshot', 'Runtime Agent State');
                return {
                    equal: false,
                    diff
                };
            }
            createSnapshotSerializer() {
                return {
                    test (val) {
                        return 'object' == typeof val && null !== val;
                    },
                    serialize: (val)=>JSON.stringify(this.normalize(val), null, 2)
                };
            }
            constructor(config){
                _define_property(this, "config", void 0);
                _define_property(this, "seenObjects", new WeakMap());
                _define_property(this, "differ", new SimpleDiffer(3));
                this.config = {
                    ...DEFAULT_CONFIG,
                    ...config,
                    fieldsToNormalize: [
                        ...DEFAULT_CONFIG.fieldsToNormalize || [],
                        ...(null == config ? void 0 : config.fieldsToNormalize) || []
                    ],
                    fieldsToIgnore: [
                        ...DEFAULT_CONFIG.fieldsToIgnore || [],
                        ...(null == config ? void 0 : config.fieldsToIgnore) || []
                    ],
                    customNormalizers: [
                        ...DEFAULT_CONFIG.customNormalizers || [],
                        ...(null == config ? void 0 : config.customNormalizers) || []
                    ]
                };
            }
        }
        function snapshot_manager_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class SnapshotManager {
            getSnapshotPath(caseName, loopDir, filename) {
                if ('' === loopDir) return external_path_default().join(this.fixturesRoot, caseName, filename);
                return external_path_default().join(this.fixturesRoot, caseName, loopDir, filename);
            }
            async readSnapshot(caseName, loopDir, filename) {
                const filePath = this.getSnapshotPath(caseName, loopDir, filename);
                if (!external_fs_default().existsSync(filePath)) return null;
                try {
                    const content = external_fs_default().readFileSync(filePath, 'utf-8');
                    if ('llm-response.jsonl' === filename) try {
                        return JSON.parse(content);
                    } catch (parseError) {
                        const lines = content.split('\n').filter((line)=>line.trim());
                        if (lines.length > 0) try {
                            const chunks = lines.map((line)=>JSON.parse(line));
                            return chunks;
                        } catch (lineParseError) {
                            logger.error(`Error parsing LLM response as streaming format: ${lineParseError}`);
                            throw lineParseError;
                        }
                        throw parseError;
                    }
                    return JSON.parse(content);
                } catch (error) {
                    logger.error(`Error reading snapshot from ${filePath}: ${error}`);
                    return null;
                }
            }
            async writeSnapshot(caseName, loopDir, filename, data) {
                const filePath = this.getSnapshotPath(caseName, loopDir, filename);
                const dirPath = external_path_default().dirname(filePath);
                if (!external_fs_default().existsSync(dirPath)) await external_fs_default().promises.mkdir(dirPath, {
                    recursive: true
                });
                try {
                    await external_fs_default().promises.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');
                    logger.info(`Snapshot written to ${filePath}`);
                } catch (error) {
                    logger.error(`Error writing snapshot to ${filePath}: ${error}`);
                    throw error;
                }
            }
            async writeActualData(caseName, loopDir, filename, data) {
                const actualFilename = filename.replace(/(\.[^.]+)$/, '.actual$1');
                const actualFilePath = this.getSnapshotPath(caseName, loopDir, actualFilename);
                await this.writeSnapshot(caseName, loopDir, actualFilename, data);
                logger.info(`Actual data written to ${actualFilePath}`);
                return actualFilePath;
            }
            async deleteActualDataIfExists(caseName, loopDir, filename) {
                const actualFilename = filename.replace(/(\.[^.]+)$/, '.actual$1');
                const actualFilePath = this.getSnapshotPath(caseName, loopDir, actualFilename);
                if (external_fs_default().existsSync(actualFilePath)) try {
                    await external_fs_default().promises.unlink(actualFilePath);
                    logger.info(`Deleted actual data file: ${actualFilePath}`);
                } catch (error) {
                    logger.warn(`Failed to delete actual data file ${actualFilePath}: ${error}`);
                }
            }
            async cleanupAllActualFiles(caseName) {
                const casePath = external_path_default().join(this.fixturesRoot, caseName);
                if (!external_fs_default().existsSync(casePath)) return 0;
                try {
                    const findActualFiles = (dir)=>{
                        const results = [];
                        const files = external_fs_default().readdirSync(dir);
                        for (const file of files){
                            const fullPath = external_path_default().join(dir, file);
                            if (external_fs_default().statSync(fullPath).isDirectory()) results.push(...findActualFiles(fullPath));
                            else if (file.includes('.actual.jsonl')) results.push(fullPath);
                        }
                        return results;
                    };
                    const actualFiles = findActualFiles(casePath);
                    for (const file of actualFiles)try {
                        await external_fs_default().promises.unlink(file);
                        logger.info(`Cleanup: Deleted leftover temporary file ${file}`);
                    } catch (err) {
                        logger.warn(`Failed to delete temporary file ${file}: ${err}`);
                    }
                    if (actualFiles.length > 0) logger.success(`\u{2705} Successfully cleaned up ${actualFiles.length} temporary .actual.jsonl files`);
                    return actualFiles.length;
                } catch (error) {
                    logger.warn(`Failed to perform cleanup of actual files: ${error}`);
                    return 0;
                }
            }
            async verifyEventStreamSnapshot(caseName, loopDir, actualEventStream, updateSnapshots = false) {
                const filename = 'event-stream.jsonl';
                const expectedEventStream = await this.readSnapshot(caseName, loopDir, filename);
                if (!expectedEventStream) {
                    if (updateSnapshots) {
                        await this.writeSnapshot(caseName, loopDir, filename, actualEventStream);
                        logger.success(`\u{2705} Created new event stream snapshot for ${caseName}/${loopDir}`);
                        return true;
                    }
                    throw new Error(`No event stream snapshot found for ${caseName}/${loopDir}`);
                }
                if (updateSnapshots) {
                    await this.writeSnapshot(caseName, loopDir, filename, actualEventStream);
                    logger.warn(`\u{26A0}\u{FE0F} Skipping event stream verification for ${caseName}/${loopDir}, updating snapshot directly`);
                    return true;
                }
                const result = this.normalizer.compare(expectedEventStream, actualEventStream);
                if (!result.equal) {
                    await this.writeActualData(caseName, loopDir, filename, actualEventStream);
                    logger.error(`\u{274C} Event stream comparison failed for ${caseName}/${loopDir}:\n${result.diff}`);
                    throw new Error(`Event stream doesn't match for ${caseName}/${loopDir}. Actual data saved to ${loopDir ? `${loopDir}/` : ''}event-stream.actual.jsonl`);
                }
                await this.deleteActualDataIfExists(caseName, loopDir, filename);
                logger.success(`\u{2705} Event stream comparison passed for ${caseName}/${loopDir}`);
                return true;
            }
            async verifyRequestSnapshot(caseName, loopDir, actualRequest, updateSnapshots = false) {
                actualRequest = JSON.parse(JSON.stringify(actualRequest));
                const filename = 'llm-request.jsonl';
                const expectedRequest = await this.readSnapshot(caseName, loopDir, filename);
                if (!expectedRequest) {
                    if (updateSnapshots) {
                        await this.writeSnapshot(caseName, loopDir, filename, actualRequest);
                        logger.success(`\u{2705} Created new request snapshot for ${caseName}/${loopDir}`);
                        return true;
                    }
                    throw new Error(`No request snapshot found for ${caseName}/${loopDir}`);
                }
                if (updateSnapshots) {
                    await this.writeSnapshot(caseName, loopDir, filename, actualRequest);
                    logger.warn(`\u{26A0}\u{FE0F} Skipping request verification for ${caseName}/${loopDir}, updating snapshot directly`);
                    return true;
                }
                const result = this.normalizer.compare(expectedRequest, actualRequest);
                if (!result.equal) {
                    await this.writeActualData(caseName, loopDir, filename, actualRequest);
                    logger.error(`\u{274C} Request comparison failed for ${caseName}/${loopDir}:\n${result.diff}`);
                    throw new Error(`Request doesn't match for ${caseName}/${loopDir}. Actual data saved to ${loopDir}/llm-request.actual.jsonl`);
                }
                await this.deleteActualDataIfExists(caseName, loopDir, filename);
                logger.success(`\u{2705} LLM request comparison passed for ${caseName}/${loopDir}`);
                return true;
            }
            async verifyToolCallsSnapshot(caseName, loopDir, actualToolCalls, updateSnapshots = false) {
                actualToolCalls = JSON.parse(JSON.stringify(actualToolCalls));
                const filename = 'tool-calls.jsonl';
                const expectedToolCalls = await this.readSnapshot(caseName, loopDir, filename);
                if (!expectedToolCalls) {
                    if (updateSnapshots) {
                        await this.writeSnapshot(caseName, loopDir, filename, actualToolCalls);
                        logger.success(`\u{2705} Created new tool calls snapshot for ${caseName}/${loopDir}`);
                        return true;
                    }
                    throw new Error(`No tool calls snapshot found for ${caseName}/${loopDir}`);
                }
                if (updateSnapshots) {
                    await this.writeSnapshot(caseName, loopDir, filename, actualToolCalls);
                    logger.warn(`\u{26A0}\u{FE0F} Skipping tool calls verification for ${caseName}/${loopDir}, updating snapshot directly`);
                    return true;
                }
                const result = this.normalizer.compare(expectedToolCalls, actualToolCalls);
                if (!result.equal) {
                    await this.writeActualData(caseName, loopDir, filename, actualToolCalls);
                    logger.error(`\u{274C} Tool calls comparison failed for ${caseName}/${loopDir}:\n${result.diff}`);
                    throw new Error(`Tool calls don't match for ${caseName}/${loopDir}. Actual data saved to ${loopDir}/tool-calls.actual.jsonl`);
                }
                await this.deleteActualDataIfExists(caseName, loopDir, filename);
                logger.success(`\u{2705} Tool calls comparison passed for ${caseName}/${loopDir}`);
                return true;
            }
            async createTestCaseStructure(caseName, numLoops) {
                const caseDir = external_path_default().join(this.fixturesRoot, caseName);
                if (!external_fs_default().existsSync(caseDir)) await external_fs_default().promises.mkdir(caseDir, {
                    recursive: true
                });
                for(let i = 1; i <= numLoops; i++){
                    const loopDir = external_path_default().join(caseDir, `loop-${i}`);
                    if (!external_fs_default().existsSync(loopDir)) await external_fs_default().promises.mkdir(loopDir, {
                        recursive: true
                    });
                }
                const initialDir = external_path_default().join(caseDir, 'initial');
                if (!external_fs_default().existsSync(initialDir)) await external_fs_default().promises.mkdir(initialDir, {
                    recursive: true
                });
                return caseDir;
            }
            async writeStreamingChunks(caseName, loopDir, filename, chunks, updateIfExists = false) {
                const filePath = this.getSnapshotPath(caseName, loopDir, filename);
                const dirPath = external_path_default().dirname(filePath);
                if (!external_fs_default().existsSync(dirPath)) await external_fs_default().promises.mkdir(dirPath, {
                    recursive: true
                });
                if (external_fs_default().existsSync(filePath) && !updateIfExists) return void logger.info(`Skipping write to existing file: ${filePath}`);
                try {
                    const chunksAsJsonLines = chunks.map((chunk)=>JSON.stringify(chunk)).join('\n');
                    await external_fs_default().promises.writeFile(filePath, chunksAsJsonLines, 'utf-8');
                    logger.info(`Stream chunks written to ${filePath} (${chunks.length} chunks)`);
                } catch (error) {
                    logger.error(`Error writing stream chunks to ${filePath}: ${error}`);
                    throw error;
                }
            }
            async readStreamingChunks(caseName, loopDir, filename) {
                const filePath = this.getSnapshotPath(caseName, loopDir, filename);
                if (!external_fs_default().existsSync(filePath)) return [];
                try {
                    const content = await external_fs_default().promises.readFile(filePath, 'utf-8');
                    const lines = content.split('\n').filter((line)=>line.trim());
                    if (0 === lines.length) return [];
                    try {
                        return lines.map((line)=>JSON.parse(line));
                    } catch (lineParseError) {
                        logger.error(`Error parsing streaming chunks: ${lineParseError}`);
                        throw lineParseError;
                    }
                } catch (error) {
                    logger.error(`Error reading streaming chunks from ${filePath}: ${error}`);
                    return [];
                }
            }
            updateAgentNormalizerConfig(config) {
                this.normalizer = new AgentSnapshotNormalizer(config);
            }
            constructor(fixturesRoot, normalizerConfig){
                snapshot_manager_define_property(this, "fixturesRoot", void 0);
                snapshot_manager_define_property(this, "normalizer", void 0);
                this.fixturesRoot = fixturesRoot;
                this.normalizer = new AgentSnapshotNormalizer(normalizerConfig);
            }
        }
        function agent_hook_base_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class AgentHookBase {
            setCurrentRunOptions(options) {
                this.currentRunOptions = options;
            }
            hookAgent() {
                if (this.isHooked) return false;
                this.originalRequestHook = this.agent.onLLMRequest;
                this.originalResponseHook = this.agent.onLLMResponse;
                this.originalStreamingResponseHook = this.agent.onLLMStreamingResponse;
                this.originalLoopEndHook = this.agent.onAgentLoopEnd;
                this.originalEachLoopStartHook = this.agent.onEachAgentLoopStart;
                this.originalBeforeToolCallHook = this.agent.onBeforeToolCall;
                this.originalAfterToolCallHook = this.agent.onAfterToolCall;
                this.originalToolCallErrorHook = this.agent.onToolCallError;
                this.originalProcessToolCallsHook = this.agent.onProcessToolCalls;
                this.agent.onLLMRequest = (id, payload)=>this.safeExecuteHook(()=>this.onLLMRequest(id, payload));
                this.agent.onLLMResponse = (id, payload)=>this.safeExecuteHook(()=>this.onLLMResponse(id, payload));
                this.agent.onLLMStreamingResponse = (id, payload)=>this.safeExecuteHook(()=>this.onLLMStreamingResponse(id, payload));
                this.agent.onAgentLoopEnd = (id)=>this.safeExecuteHook(()=>this.onAgentLoopEnd(id));
                this.agent.onEachAgentLoopStart = (id)=>this.safeExecuteHook(()=>this.onEachAgentLoopStart(id));
                this.agent.onBeforeToolCall = (id, toolCall, args)=>this.safeExecuteHook(()=>this.onBeforeToolCall(id, toolCall, args));
                this.agent.onAfterToolCall = (id, toolCall, result)=>this.safeExecuteHook(()=>this.onAfterToolCall(id, toolCall, result));
                this.agent.onToolCallError = (id, toolCall, error)=>this.safeExecuteHook(()=>this.onToolCallError(id, toolCall, error));
                this.agent.onProcessToolCalls = (id, toolCalls)=>this.safeExecuteHook(()=>this.onProcessToolCalls(id, toolCalls));
                this.isHooked = true;
                logger.info(`Hooked into agent: ${this.snapshotName}`);
                return true;
            }
            unhookAgent(force = false) {
                if (!this.isHooked && !force) return false;
                if (this.originalRequestHook) this.agent.onLLMRequest = this.originalRequestHook;
                if (this.originalResponseHook) this.agent.onLLMResponse = this.originalResponseHook;
                if (this.originalStreamingResponseHook) this.agent.onLLMStreamingResponse = this.originalStreamingResponseHook;
                if (this.originalLoopEndHook) this.agent.onAgentLoopEnd = this.originalLoopEndHook;
                if (this.originalEachLoopStartHook) this.agent.onEachAgentLoopStart = this.originalEachLoopStartHook;
                if (this.originalBeforeToolCallHook) this.agent.onBeforeToolCall = this.originalBeforeToolCallHook;
                if (this.originalAfterToolCallHook) this.agent.onAfterToolCall = this.originalAfterToolCallHook;
                if (this.originalToolCallErrorHook) this.agent.onToolCallError = this.originalToolCallErrorHook;
                if (this.originalProcessToolCallsHook) this.agent.onProcessToolCalls = this.originalProcessToolCallsHook;
                this.isHooked = false;
                logger.info(`Unhooked from agent: ${this.snapshotName}`);
                return true;
            }
            async safeExecuteHook(hookFn) {
                try {
                    const result = await hookFn();
                    if (result instanceof Promise) return result.catch((error)=>{
                        this.lastError = error;
                        logger.error(`Hook execution error: ${error.message}`);
                        throw error;
                    });
                    return result;
                } catch (error) {
                    this.lastError = error;
                    logger.error(`Hook execution error: ${error.message}`);
                }
            }
            hasError() {
                return null !== this.lastError;
            }
            getLastError() {
                return this.lastError;
            }
            clearError() {
                this.lastError = null;
            }
            writeStreamingChunks(filePath, chunks) {
                if (!chunks || 0 === chunks.length) return;
                try {
                    const chunksAsJsonLines = chunks.map((chunk)=>JSON.stringify(chunk)).join('\n');
                    external_fs_default().writeFileSync(filePath, chunksAsJsonLines, 'utf-8');
                    logger.debug(`${chunks.length} chunks written to ${filePath}`);
                } catch (error) {
                    logger.error(`Error writing streaming chunks: ${error}`);
                    this.lastError = error;
                    throw error;
                }
            }
            constructor(agent, options){
                agent_hook_base_define_property(this, "agent", void 0);
                agent_hook_base_define_property(this, "snapshotPath", void 0);
                agent_hook_base_define_property(this, "snapshotName", void 0);
                agent_hook_base_define_property(this, "originalRequestHook", null);
                agent_hook_base_define_property(this, "originalResponseHook", null);
                agent_hook_base_define_property(this, "originalLoopEndHook", null);
                agent_hook_base_define_property(this, "originalEachLoopStartHook", null);
                agent_hook_base_define_property(this, "originalStreamingResponseHook", null);
                agent_hook_base_define_property(this, "originalBeforeToolCallHook", null);
                agent_hook_base_define_property(this, "originalAfterToolCallHook", null);
                agent_hook_base_define_property(this, "originalToolCallErrorHook", null);
                agent_hook_base_define_property(this, "originalProcessToolCallsHook", null);
                agent_hook_base_define_property(this, "isHooked", false);
                agent_hook_base_define_property(this, "currentRunOptions", void 0);
                agent_hook_base_define_property(this, "snapshotManager", void 0);
                agent_hook_base_define_property(this, "lastError", null);
                this.agent = agent;
                this.snapshotPath = options.snapshotPath;
                this.snapshotName = options.snapshotName;
                if (!external_fs_default().existsSync(this.snapshotPath)) external_fs_default().mkdirSync(this.snapshotPath, {
                    recursive: true
                });
            }
        }
        function agent_generate_snapshot_hook_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class AgentGenerateSnapshotHook extends AgentHookBase {
            onEachAgentLoopStart(id) {
                logger.info(`Starting agent loop ${this.agent.getCurrentLoopIteration()}`);
                const currentLoop = this.agent.getCurrentLoopIteration();
                if (!this.toolCallsByLoop[currentLoop]) this.toolCallsByLoop[currentLoop] = [];
                if (this.originalEachLoopStartHook) return this.originalEachLoopStartHook.call(this.agent, id);
            }
            onLLMRequest(id, payload) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                this.llmRequests[currentLoop] = payload;
                const loopDir = external_path_default().join(this.snapshotPath, `loop-${currentLoop}`);
                if (!external_fs_default().existsSync(loopDir)) external_fs_default().mkdirSync(loopDir, {
                    recursive: true
                });
                external_fs_default().writeFileSync(external_path_default().join(loopDir, 'llm-request.jsonl'), JSON.stringify(payload, null, 2), 'utf-8');
                const events = this.agent.getEventStream().getEvents();
                external_fs_default().writeFileSync(external_path_default().join(loopDir, 'event-stream.jsonl'), JSON.stringify(events, null, 2), 'utf-8');
                if (this.originalRequestHook) return this.originalRequestHook.call(this.agent, id, payload);
            }
            onLLMResponse(id, payload) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                this.llmResponses[currentLoop] = payload;
                if (this.originalResponseHook) return this.originalResponseHook.call(this.agent, id, payload);
            }
            onLLMStreamingResponse(id, payload) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                const loopDir = `loop-${currentLoop}`;
                try {
                    const responsePath = external_path_default().join(this.snapshotPath, loopDir, 'llm-response.jsonl');
                    this.writeStreamingChunks(responsePath, payload.chunks);
                    logger.info(`Saved ${payload.chunks.length} streaming chunks for ${loopDir}`);
                } catch (error) {
                    logger.error(`Failed to save streaming chunks: ${error}`);
                }
                if (this.originalStreamingResponseHook) this.originalStreamingResponseHook.call(this.agent, id, payload);
            }
            onBeforeToolCall(id, toolCall, args) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                this.startTimeByToolCall[toolCall.toolCallId] = Date.now();
                if (!this.toolCallsByLoop[currentLoop]) this.toolCallsByLoop[currentLoop] = [];
                this.toolCallsByLoop[currentLoop].push({
                    toolCallId: toolCall.toolCallId,
                    name: toolCall.name,
                    args
                });
                logger.debug(`Tool call captured for ${toolCall.name} (${toolCall.toolCallId}) in loop ${currentLoop}`);
                if (this.originalBeforeToolCallHook) return this.originalBeforeToolCallHook.call(this.agent, id, toolCall, args);
                return args;
            }
            onAfterToolCall(id, toolCall, result) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                const executionTime = Date.now() - (this.startTimeByToolCall[toolCall.toolCallId] || Date.now());
                if (this.toolCallsByLoop[currentLoop]) {
                    const toolCallData = this.toolCallsByLoop[currentLoop].find((tc)=>tc.toolCallId === toolCall.toolCallId);
                    if (toolCallData) {
                        toolCallData.result = result;
                        toolCallData.executionTime = executionTime;
                    }
                }
                logger.debug(`Tool call result captured for ${toolCall.name} (${toolCall.toolCallId}) in loop ${currentLoop}`);
                this.saveToolCalls(currentLoop);
                if (this.originalAfterToolCallHook) return this.originalAfterToolCallHook.call(this.agent, id, toolCall, result);
                return result;
            }
            onToolCallError(id, toolCall, error) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                const executionTime = Date.now() - (this.startTimeByToolCall[toolCall.toolCallId] || Date.now());
                if (this.toolCallsByLoop[currentLoop]) {
                    const toolCallData = this.toolCallsByLoop[currentLoop].find((tc)=>tc.toolCallId === toolCall.toolCallId);
                    if (toolCallData) {
                        toolCallData.error = error;
                        toolCallData.executionTime = executionTime;
                    }
                }
                logger.debug(`Tool call error captured for ${toolCall.name} (${toolCall.toolCallId}) in loop ${currentLoop}`);
                this.saveToolCalls(currentLoop);
                if (this.originalToolCallErrorHook) return this.originalToolCallErrorHook.call(this.agent, id, toolCall, error);
                return `Error: ${error}`;
            }
            saveToolCalls(loopNumber) {
                if (!this.toolCallsByLoop[loopNumber] || 0 === this.toolCallsByLoop[loopNumber].length) return;
                try {
                    const loopDir = external_path_default().join(this.snapshotPath, `loop-${loopNumber}`);
                    if (!external_fs_default().existsSync(loopDir)) external_fs_default().mkdirSync(loopDir, {
                        recursive: true
                    });
                    external_fs_default().writeFileSync(external_path_default().join(loopDir, 'tool-calls.jsonl'), JSON.stringify(this.toolCallsByLoop[loopNumber], null, 2), 'utf-8');
                    logger.info(`Saved ${this.toolCallsByLoop[loopNumber].length} tool calls for loop ${loopNumber}`);
                } catch (error) {
                    logger.error(`Failed to save tool calls for loop ${loopNumber}: ${error}`);
                }
            }
            onAgentLoopEnd(id) {
                const finalEvents = this.agent.getEventStream().getEvents();
                external_fs_default().writeFileSync(external_path_default().join(this.snapshotPath, 'event-stream.jsonl'), JSON.stringify(finalEvents, null, 2), 'utf-8');
                logger.info(`Snapshot generation completed: ${this.snapshotPath}`);
                if (this.originalLoopEndHook) return this.originalLoopEndHook.call(this.agent, id);
            }
            onProcessToolCalls(id, toolCalls) {}
            constructor(agent, options){
                super(agent, options), agent_generate_snapshot_hook_define_property(this, "llmRequests", {}), agent_generate_snapshot_hook_define_property(this, "llmResponses", {}), agent_generate_snapshot_hook_define_property(this, "toolCallsByLoop", {}), agent_generate_snapshot_hook_define_property(this, "startTimeByToolCall", {});
            }
        }
        function agent_replay_snapshot_hook_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class AgentReplaySnapshotHook extends AgentHookBase {
            async setup(agent, casePath, totalLoops, options = {}) {
                var _options_verification, _options_verification1, _options_verification2;
                this.agent = agent;
                this.snapshotPath = casePath;
                this.snapshotName = external_path_default().basename(casePath);
                this.totalLoops = totalLoops;
                this.updateSnapshots = options.updateSnapshots || false;
                this.verifyLLMRequests = (null == (_options_verification = options.verification) ? void 0 : _options_verification.verifyLLMRequests) !== false;
                this.verifyEventStreams = (null == (_options_verification1 = options.verification) ? void 0 : _options_verification1.verifyEventStreams) !== false;
                this.verifyToolCalls = (null == (_options_verification2 = options.verification) ? void 0 : _options_verification2.verifyToolCalls) !== false;
                this.snapshotManager = new SnapshotManager(external_path_default().dirname(casePath), options.normalizerConfig);
                this.hookAgent();
                this.mockLLMClient = this.createMockLLMClient();
                logger.info(`LLM mocker set up for ${this.snapshotName} with ${totalLoops} loops`);
                logger.info(`Verification settings: LLM requests: ${this.verifyLLMRequests ? 'enabled' : 'disabled'}, Event streams: ${this.verifyEventStreams ? 'enabled' : 'disabled'}, Tool calls: ${this.verifyToolCalls ? 'enabled' : 'disabled'}`);
                if (this.verifyEventStreams) await this.verifyInitialEventStreamState();
            }
            storeFinalEventStreamState(events) {
                this.finalEventStreamState = [
                    ...events
                ];
            }
            getFinalEventStreamState() {
                return this.finalEventStreamState;
            }
            getMockLLMClient() {
                return this.mockLLMClient;
            }
            restore() {
                this.unhookAgent();
                this.mockLLMClient = void 0;
                logger.info('Restored original LLM hooks and client');
            }
            createMockLLMClient() {
                return {
                    chat: {
                        completions: {
                            create: async (request)=>{
                                var _this_agent, _this_snapshotManager;
                                const currentLoop = null == (_this_agent = this.agent) ? void 0 : _this_agent.getCurrentLoopIteration();
                                logger.info(`[Mock LLM Client] Creating chat completion for loop ${currentLoop} with args: ` + JSON.stringify(request, null, 2));
                                const loopDir = `loop-${currentLoop}`;
                                const mockResponse = await (null == (_this_snapshotManager = this.snapshotManager) ? void 0 : _this_snapshotManager.readSnapshot(external_path_default().basename(this.snapshotPath), loopDir, 'llm-response.jsonl'));
                                if (!mockResponse) {
                                    const error = new Error(`No mock response found for ${loopDir}`);
                                    this.lastError = error;
                                }
                                logger.info(`[Mock LLM Response] Loop ${currentLoop}: Type: ${Array.isArray(mockResponse) ? 'array' : 'object'}, Length: ${Array.isArray(mockResponse) ? mockResponse.length : 1}`);
                                logger.success(`\u{2705} Using mock LLM response from snapshot for ${loopDir}`);
                                if (!request.stream) return mockResponse;
                                {
                                    const streamResponse = Array.isArray(mockResponse) ? mockResponse : [
                                        mockResponse
                                    ];
                                    logger.info(`Creating streaming response with ${streamResponse.length} chunks for loop ${currentLoop}`);
                                    streamResponse.forEach((chunk, idx)=>{
                                        if (!chunk.id || !chunk.object || !chunk.choices) logger.warn(`Chunk ${idx} may have invalid structure: ${JSON.stringify(chunk)}`);
                                    });
                                    return this.createAsyncIterable(streamResponse);
                                }
                            }
                        }
                    }
                };
            }
            async verifyInitialEventStreamState() {
                if (!this.snapshotPath || !this.snapshotManager || !this.agent) throw new Error('LLMMocker not properly set up');
                logger.info(`\u{1F50D} Verifying initial event stream state before first loop`);
                const events = this.agent.getEventStream().getEvents();
                if (events.length > 0) try {
                    await this.snapshotManager.verifyEventStreamSnapshot(external_path_default().basename(this.snapshotPath), 'initial', events, this.updateSnapshots);
                    logger.success(`\u{2705} Initial event stream verification succeeded`);
                } catch (error) {
                    logger.error(`\u{274C} Initial event stream verification failed: ${error}`);
                    if (!this.updateSnapshots) throw error;
                }
            }
            createAsyncIterable(chunks) {
                logger.info(`Creating AsyncIterable with ${chunks.length} chunks`);
                return {
                    [Symbol.asyncIterator] () {
                        let index = 0;
                        let iteratorClosed = false;
                        logger.info(`AsyncIterator created for ${chunks.length} chunks`);
                        return {
                            async next () {
                                if (iteratorClosed) {
                                    logger.info("Iterator already closed, returning done");
                                    return {
                                        done: true,
                                        value: void 0
                                    };
                                }
                                if (index < chunks.length) {
                                    const chunk = chunks[index];
                                    logger.info(`Yielding chunk ${index + 1}/${chunks.length}`);
                                    index++;
                                    return {
                                        done: false,
                                        value: chunk
                                    };
                                }
                                logger.info(`Iterator completed after yielding ${index} chunks`);
                                iteratorClosed = true;
                                return {
                                    done: true,
                                    value: void 0
                                };
                            },
                            async return () {
                                logger.info(`Iterator return() called early at index ${index}/${chunks.length}`);
                                iteratorClosed = true;
                                return {
                                    done: true,
                                    value: void 0
                                };
                            },
                            async throw (error) {
                                logger.error(`Error in streaming response iterator: ${error}`);
                                iteratorClosed = true;
                                return {
                                    done: true,
                                    value: void 0
                                };
                            }
                        };
                    }
                };
            }
            onEachAgentLoopStart(id) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                if (!this.toolCallsByLoop[currentLoop]) this.toolCallsByLoop[currentLoop] = [];
                if (this.originalEachLoopStartHook) return this.originalEachLoopStartHook.call(this.agent, id);
            }
            async onLLMRequest(id, payload) {
                if (!this.snapshotPath || !this.snapshotManager) throw new Error('LLMMocker not properly set up');
                const currentLoop = this.agent.getCurrentLoopIteration();
                const loopDir = `loop-${currentLoop}`;
                logger.info(`\u{1F504} Intercepted LLM request for loop ${currentLoop}`);
                const events = this.agent.getEventStream().getEvents();
                this.eventStreamStatesByLoop.set(currentLoop, [
                    ...events
                ]);
                if (this.verifyEventStreams) try {
                    logger.info(`\u{1F50D} Verifying event stream state at the beginning of ${loopDir}`);
                    if (this.updateSnapshots) logger.warn(`\u{26A0}\u{FE0F} Update mode enabled: directly updating event stream snapshot for ${loopDir}`);
                    await this.snapshotManager.verifyEventStreamSnapshot(external_path_default().basename(this.snapshotPath), loopDir, events, this.updateSnapshots);
                } catch (error) {
                    logger.error(`\u{274C} Event stream verification failed for ${loopDir}: ${error}`);
                    if (!this.updateSnapshots) throw error;
                }
                else logger.info(`Event stream verification skipped for ${loopDir} (disabled in config)`);
                if (this.verifyLLMRequests) try {
                    if (this.updateSnapshots) logger.warn(`\u{26A0}\u{FE0F} Update mode enabled: directly updating LLM request snapshot for ${loopDir}`);
                    await this.snapshotManager.verifyRequestSnapshot(external_path_default().basename(this.snapshotPath), loopDir, payload, this.updateSnapshots);
                } catch (error) {
                    logger.error(`\u{274C} Request verification failed for ${loopDir}: ${error}`);
                    if (!this.updateSnapshots) throw error;
                }
                else logger.info(`LLM request verification skipped for ${loopDir} (disabled in config)`);
                if (this.originalRequestHook) await this.originalRequestHook.call(this.agent, id, payload);
            }
            async onLLMResponse(id, payload) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                logger.debug(`LLM response hook called for loop ${currentLoop}`);
                if (this.originalResponseHook) await this.originalResponseHook.call(this.agent, id, payload);
            }
            onLLMStreamingResponse(id, payload) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                logger.debug(`LLM onStreamingResponseHook called for loop ${currentLoop}`);
                if (this.originalStreamingResponseHook) this.originalStreamingResponseHook.call(this.agent, id, payload);
            }
            onBeforeToolCall(id, toolCall, args) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                this.startTimeByToolCall[toolCall.toolCallId] = Date.now();
                if (this.verifyToolCalls) this.loadToolCallsFromSnapshot(currentLoop).catch((error)=>{
                    logger.error(`Error loading tool calls from snapshot: ${error}`);
                    if (!this.updateSnapshots) this.lastError = error instanceof Error ? error : new Error(String(error));
                });
                if (!this.toolCallsByLoop[currentLoop]) this.toolCallsByLoop[currentLoop] = [];
                this.toolCallsByLoop[currentLoop].push({
                    toolCallId: toolCall.toolCallId,
                    name: toolCall.name,
                    args
                });
                logger.debug(`Tool call intercepted for ${toolCall.name} (${toolCall.toolCallId}) in loop ${currentLoop}`);
                if (this.originalBeforeToolCallHook) return this.originalBeforeToolCallHook.call(this.agent, id, toolCall, args);
                return args;
            }
            onAfterToolCall(id, toolCall, result) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                const executionTime = Date.now() - (this.startTimeByToolCall[toolCall.toolCallId] || Date.now());
                if (this.toolCallsByLoop[currentLoop]) {
                    const toolCallData = this.toolCallsByLoop[currentLoop].find((tc)=>tc.toolCallId === toolCall.toolCallId);
                    if (toolCallData) {
                        toolCallData.result = result;
                        toolCallData.executionTime = executionTime;
                    }
                }
                logger.debug(`Tool call result intercepted for ${toolCall.name} (${toolCall.toolCallId}) in loop ${currentLoop}`);
                if (this.verifyToolCalls) this.verifyToolCallsForLoop(currentLoop).catch((error)=>{
                    logger.error(`Error verifying tool calls: ${error}`);
                    if (!this.updateSnapshots) this.lastError = error instanceof Error ? error : new Error(String(error));
                });
                if (this.originalAfterToolCallHook) return this.originalAfterToolCallHook.call(this.agent, id, toolCall, result);
                return result;
            }
            onToolCallError(id, toolCall, error) {
                const currentLoop = this.agent.getCurrentLoopIteration();
                const executionTime = Date.now() - (this.startTimeByToolCall[toolCall.toolCallId] || Date.now());
                if (this.toolCallsByLoop[currentLoop]) {
                    const toolCallData = this.toolCallsByLoop[currentLoop].find((tc)=>tc.toolCallId === toolCall.toolCallId);
                    if (toolCallData) {
                        toolCallData.error = error;
                        toolCallData.executionTime = executionTime;
                    }
                }
                logger.debug(`Tool call error intercepted for ${toolCall.name} (${toolCall.toolCallId}) in loop ${currentLoop}`);
                if (this.verifyToolCalls) this.verifyToolCallsForLoop(currentLoop).catch((error)=>{
                    logger.error(`Error verifying tool calls: ${error}`);
                    if (!this.updateSnapshots) this.lastError = error instanceof Error ? error : new Error(String(error));
                });
                if (this.originalToolCallErrorHook) return this.originalToolCallErrorHook.call(this.agent, id, toolCall, error);
                return `Error: ${error}`;
            }
            async onProcessToolCalls(id, toolCalls) {
                if (!this.verifyToolCalls) return;
                const currentLoop = this.agent.getCurrentLoopIteration();
                const loopDir = `loop-${currentLoop}`;
                try {
                    var _this_snapshotManager;
                    const savedToolCalls = await (null == (_this_snapshotManager = this.snapshotManager) ? void 0 : _this_snapshotManager.readSnapshot(external_path_default().basename(this.snapshotPath), loopDir, 'tool-calls.jsonl'));
                    if (!savedToolCalls || 0 === savedToolCalls.length) return void logger.warn(`No saved tool calls found for ${loopDir}, executing real tools`);
                    if (savedToolCalls.length !== toolCalls.length) logger.warn(`Tool call count mismatch in ${loopDir}: expected ${toolCalls.length} but found ${savedToolCalls.length} in snapshot`);
                    const results = [];
                    for(let i = 0; i < toolCalls.length; i++){
                        const toolCall = toolCalls[i];
                        const savedToolCall = savedToolCalls.find((stc)=>stc.name === toolCall.function.name);
                        if (savedToolCall) results.push({
                            toolCallId: toolCall.id,
                            toolName: toolCall.function.name,
                            content: savedToolCall.result || savedToolCall.error || 'No result in snapshot'
                        });
                        else {
                            logger.warn(`No matching saved tool call found for ${toolCall.function.name} in ${loopDir}`);
                            results.push({
                                toolCallId: toolCall.id,
                                toolName: toolCall.function.name,
                                content: "Mock result: No saved result found for this tool in snapshot"
                            });
                        }
                    }
                    logger.info(`Replaying ${results.length} tool call results from snapshot`);
                    return results;
                } catch (error) {
                    logger.error(`Error replaying tool calls: ${error}`);
                    return;
                }
            }
            async loadToolCallsFromSnapshot(loopNumber) {
                if (!this.snapshotManager) return;
                const loopDir = `loop-${loopNumber}`;
                const toolCalls = await this.snapshotManager.readSnapshot(external_path_default().basename(this.snapshotPath), loopDir, 'tool-calls.jsonl');
                if (!toolCalls || 0 === toolCalls.length) return void logger.debug(`No tool calls found in snapshot for ${loopDir}`);
                logger.debug(`Loaded ${toolCalls.length} tool calls from snapshot for ${loopDir}`);
            }
            async verifyToolCallsForLoop(loopNumber) {
                if (!this.snapshotManager || !this.toolCallsByLoop[loopNumber]) return;
                const loopDir = `loop-${loopNumber}`;
                try {
                    await this.snapshotManager.verifyToolCallsSnapshot(external_path_default().basename(this.snapshotPath), loopDir, this.toolCallsByLoop[loopNumber], this.updateSnapshots);
                    logger.success(`\u{2705} Tool calls verification succeeded for ${loopDir}`);
                } catch (error) {
                    logger.error(`\u{274C} Tool calls verification failed for ${loopDir}: ${error}`);
                    if (!this.updateSnapshots) throw error;
                }
            }
            async onAgentLoopEnd(id) {
                if (!this.snapshotPath || !this.snapshotManager || !this.agent) throw new Error('LLMMocker not properly set up');
                logger.info(`\u{1F504} Agent loop execution completed`);
                const finalEvents = this.agent.getEventStream().getEvents();
                this.finalEventStreamState = finalEvents;
                if (this.verifyEventStreams) try {
                    logger.info(`\u{1F50D} Verifying final event stream state after agent completion`);
                    await this.snapshotManager.verifyEventStreamSnapshot(external_path_default().basename(this.snapshotPath), '', JSON.parse(JSON.stringify(finalEvents)), this.updateSnapshots);
                    logger.success(`\u{2705} Final event stream verification succeeded`);
                } catch (error) {
                    logger.error(`\u{274C} Final event stream verification failed: ${error}`);
                    if (!this.updateSnapshots) throw error;
                }
                else logger.info("Final event stream verification skipped (disabled in config)");
                if (!this.hasError() && this.snapshotManager) await this.snapshotManager.cleanupAllActualFiles(external_path_default().basename(this.snapshotPath));
                if (this.originalLoopEndHook) await this.originalLoopEndHook.call(this.agent, id);
            }
            getEventStreamStateAfterLoop(loopNumber) {
                const events = this.eventStreamStatesByLoop.get(loopNumber);
                if (!events) throw new Error(`No event stream state found for loop ${loopNumber}`);
                return events;
            }
            constructor(...args){
                super(...args), agent_replay_snapshot_hook_define_property(this, "totalLoops", 0), agent_replay_snapshot_hook_define_property(this, "updateSnapshots", false), agent_replay_snapshot_hook_define_property(this, "eventStreamStatesByLoop", new Map()), agent_replay_snapshot_hook_define_property(this, "finalEventStreamState", []), agent_replay_snapshot_hook_define_property(this, "mockLLMClient", void 0), agent_replay_snapshot_hook_define_property(this, "verifyLLMRequests", true), agent_replay_snapshot_hook_define_property(this, "verifyEventStreams", true), agent_replay_snapshot_hook_define_property(this, "verifyToolCalls", true), agent_replay_snapshot_hook_define_property(this, "toolCallsByLoop", {}), agent_replay_snapshot_hook_define_property(this, "startTimeByToolCall", {});
            }
        }
        function agent_snapshot_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class agent_snapshot_AgentSnapshot {
            async run(runOptions) {
                logger.info(`AgentSnapshot.run called with ${'string' == typeof runOptions ? 'string' : 'options object'}`);
                if (!this.generateHook) this.generateHook = new AgentGenerateSnapshotHook(this.hostedAgent, {
                    snapshotPath: this.options.snapshotPath,
                    snapshotName: this.snapshotName
                });
                this.generateHook.setCurrentRunOptions(runOptions);
                this.generateHook.hookAgent();
                try {
                    const isStreaming = 'object' == typeof runOptions && (0, dist.isAgentRunObjectOptions)(runOptions) && (0, dist.isStreamingOptions)(runOptions);
                    logger.info(`Executing agent with ${isStreaming ? 'streaming' : 'non-streaming'} mode`);
                    const response = await this.hostedAgent.run(runOptions);
                    return response;
                } catch (error) {
                    logger.error(`Error during AgentSnapshot.run: ${error}`);
                    throw error;
                } finally{
                    if (this.generateHook) this.generateHook.clearError();
                }
            }
            async generate(runOptions) {
                const snapshotName = this.snapshotName || `agent-snapshot-${Date.now()}`;
                this.generateHook = new AgentGenerateSnapshotHook(this.hostedAgent, {
                    snapshotPath: this.options.snapshotPath || external_path_default().join(process.cwd(), 'fixtures'),
                    snapshotName: snapshotName
                });
                if (this.snapshotPath) {
                    if (!external_fs_default().existsSync(this.snapshotPath)) external_fs_default().mkdirSync(this.snapshotPath, {
                        recursive: true
                    });
                }
                logger.info(`Starting snapshot generation for '${snapshotName}'`);
                const startTime = Date.now();
                this.generateHook.setCurrentRunOptions(runOptions);
                this.generateHook.hookAgent();
                try {
                    const response = await this.hostedAgent.run(runOptions);
                    if (this.generateHook.hasError()) {
                        const error = this.generateHook.getLastError();
                        logger.error(`Error occurred during snapshot generation: ${null == error ? void 0 : error.message}`);
                        throw error;
                    }
                    const events = this.hostedAgent.getEventStream().getEvents();
                    const snapshotPath = external_path_default().join(this.options.snapshotPath);
                    const loopCount = this.countLoops(snapshotPath);
                    logger.success(`Successfully generated snapshot with ${loopCount} loops`);
                    return {
                        snapshotPath,
                        loopCount,
                        response,
                        events,
                        meta: {
                            snapshotName: this.snapshotName,
                            executionTime: Date.now() - startTime
                        }
                    };
                } catch (error) {
                    logger.error(`Snapshot generation failed: ${error}`);
                    throw error;
                } finally{
                    if (this.generateHook) this.generateHook.clearError();
                }
            }
            async replay(runOptions, config) {
                var _config_verification, _this_options_verification, _config_verification1, _this_options_verification1, _config_verification2, _this_options_verification2;
                const snapshotName = this.options.snapshotName || external_path_default().basename(this.options.snapshotPath);
                const updateSnapshots = (null == config ? void 0 : config.updateSnapshots) || this.options.updateSnapshots || false;
                if (null == config ? void 0 : config.normalizerConfig) this.snapshotManager.updateAgentNormalizerConfig(config.normalizerConfig);
                const verification = {
                    verifyLLMRequests: (null == config ? void 0 : null == (_config_verification = config.verification) ? void 0 : _config_verification.verifyLLMRequests) !== void 0 ? config.verification.verifyLLMRequests : (null == (_this_options_verification = this.options.verification) ? void 0 : _this_options_verification.verifyLLMRequests) !== false,
                    verifyEventStreams: (null == config ? void 0 : null == (_config_verification1 = config.verification) ? void 0 : _config_verification1.verifyEventStreams) !== void 0 ? config.verification.verifyEventStreams : (null == (_this_options_verification1 = this.options.verification) ? void 0 : _this_options_verification1.verifyEventStreams) !== false,
                    verifyToolCalls: (null == config ? void 0 : null == (_config_verification2 = config.verification) ? void 0 : _config_verification2.verifyToolCalls) !== void 0 ? config.verification.verifyToolCalls : (null == (_this_options_verification2 = this.options.verification) ? void 0 : _this_options_verification2.verifyToolCalls) !== false
                };
                if (!external_fs_default().existsSync(this.snapshotPath)) throw new Error(`Snapshot directory not found: ${this.snapshotPath}. Generate snapshots first using .generate()`);
                logger.info(`Running test against snapshot '${snapshotName}'${updateSnapshots ? ' (update mode)' : ''}`);
                logger.info(`Verification settings: 
      LLM requests: ${verification.verifyLLMRequests ? 'enabled' : 'disabled'}, 
      Event streams: ${verification.verifyEventStreams ? 'enabled' : 'disabled'},
      Tool calls: ${verification.verifyToolCalls ? 'enabled' : 'disabled'}`);
                const loopCount = this.countLoops(this.snapshotPath);
                logger.info(`Found ${loopCount} loops in test case`);
                const startTime = Date.now();
                try {
                    await this.replayHook.setup(this.hostedAgent, this.snapshotPath, loopCount, {
                        updateSnapshots,
                        normalizerConfig: (null == config ? void 0 : config.normalizerConfig) || this.options.normalizerConfig,
                        verification
                    });
                    if (this.replayHook.hasError()) {
                        const error = this.replayHook.getLastError();
                        logger.error(`Error occurred during test setup: ${null == error ? void 0 : error.message}`);
                        throw error;
                    }
                    const mockLLMClient = this.replayHook.getMockLLMClient();
                    this.hostedAgent.setCustomLLMClient(mockLLMClient);
                    const isStreaming = 'object' == typeof runOptions && (0, dist.isStreamingOptions)(runOptions);
                    let response;
                    let events = [];
                    this.hostedAgent._setIsReplay();
                    if (isStreaming) {
                        const asyncIterable = await this.hostedAgent.run(runOptions);
                        const streamEvents = [];
                        logger.info("Processing streaming response...");
                        for await (const event of asyncIterable){
                            if (this.replayHook.hasError()) {
                                const error = this.replayHook.getLastError();
                                logger.error(`Error occurred during streaming: ${null == error ? void 0 : error.message}`);
                                throw error;
                            }
                            streamEvents.push(event);
                        }
                        response = asyncIterable;
                        events = this.hostedAgent.getEventStream().getEvents();
                        logger.success(`Streaming execution completed with ${streamEvents.length} events`);
                    } else {
                        response = await this.hostedAgent.run(runOptions);
                        if (this.replayHook.hasError()) {
                            const error = this.replayHook.getLastError();
                            logger.error(`Error occurred during execution: ${null == error ? void 0 : error.message}`);
                            throw error;
                        }
                        events = this.hostedAgent.getEventStream().getEvents();
                        logger.success("Execution completed successfully");
                    }
                    const executedLoops = this.hostedAgent.getCurrentLoopIteration();
                    logger.info(`Executed ${executedLoops} agent loops out of ${loopCount} expected loops: ${JSON.stringify(this.options)}`);
                    if (executedLoops !== loopCount) throw new Error(`Loop count mismatch: Agent executed ${executedLoops} loops, but fixture has ${loopCount} loop directories`);
                    if (this.snapshotManager) await this.snapshotManager.cleanupAllActualFiles(this.snapshotName);
                    return {
                        response,
                        events,
                        meta: {
                            snapshotName,
                            executionTime: Date.now() - startTime,
                            loopCount: executedLoops
                        }
                    };
                } catch (error) {
                    logger.error(`Test execution failed: ${error}`);
                    throw error;
                } finally{
                    this.replayHook.clearError();
                }
            }
            countLoops(casePath) {
                if (!external_fs_default().existsSync(casePath)) return 0;
                const loopDirs = external_fs_default().readdirSync(casePath).filter((dir)=>dir.startsWith('loop-') && external_fs_default().statSync(external_path_default().join(casePath, dir)).isDirectory()).sort((a, b)=>{
                    const numA = parseInt(a.split('-')[1], 10);
                    const numB = parseInt(b.split('-')[1], 10);
                    return numA - numB;
                });
                return loopDirs.length;
            }
            getAgent() {
                return this.hostedAgent;
            }
            getCurrentLoop() {
                return this.hostedAgent.getCurrentLoopIteration();
            }
            updateAgentNormalizerConfig(config) {
                this.snapshotManager.updateAgentNormalizerConfig(config);
            }
            constructor(agent, options){
                agent_snapshot_define_property(this, "hostedAgent", void 0);
                agent_snapshot_define_property(this, "options", void 0);
                agent_snapshot_define_property(this, "snapshotPath", void 0);
                agent_snapshot_define_property(this, "snapshotName", void 0);
                agent_snapshot_define_property(this, "snapshotManager", void 0);
                agent_snapshot_define_property(this, "replayHook", void 0);
                agent_snapshot_define_property(this, "generateHook", null);
                this.hostedAgent = agent;
                this.options = options;
                this.snapshotPath = options.snapshotPath || external_path_default().join(process.cwd(), 'fixtures');
                this.snapshotName = options.snapshotName ?? external_path_default().basename(options.snapshotPath);
                this.snapshotManager = new SnapshotManager(this.snapshotPath, options.normalizerConfig);
                this.replayHook = new AgentReplaySnapshotHook(agent, {
                    snapshotPath: this.options.snapshotPath || external_path_default().join(process.cwd(), 'fixtures'),
                    snapshotName: this.snapshotName
                });
                if (!external_fs_default().existsSync(this.snapshotPath)) external_fs_default().mkdirSync(this.snapshotPath, {
                    recursive: true
                });
                process.env.TEST = 'true';
                const agentSnapshotProto = Object.getPrototypeOf(this);
                const methodsToPreserve = {};
                Object.getOwnPropertyNames(agentSnapshotProto).forEach((key)=>{
                    const descriptor = Object.getOwnPropertyDescriptor(agentSnapshotProto, key);
                    if ('function' == typeof (null == descriptor ? void 0 : descriptor.value) && 'constructor' !== key) methodsToPreserve[key] = this[key].bind(this);
                });
                Object.setPrototypeOf(this, Object.getPrototypeOf(agent));
                Object.getOwnPropertyNames(agent).forEach((prop)=>{
                    if (!(prop in this)) Object.defineProperty(this, prop, {
                        get: ()=>agent[prop],
                        set: (value)=>{
                            agent[prop] = value;
                        },
                        configurable: true
                    });
                });
                Object.entries(methodsToPreserve).forEach(([key, method])=>{
                    this[key] = method;
                });
            }
        }
        function event_stream_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class EventStreamBridge {
            subscribe(handler) {
                this.subscribers.add(handler);
            }
            unsubscribe(handler) {
                this.subscribers.delete(handler);
            }
            emit(type, data) {
                for (const handler of this.subscribers)handler(type, data);
            }
            connectToAgentEventStream(agentEventStream) {
                const handleEvent = (event)=>{
                    var _event_message, _event_message1;
                    switch(event.type){
                        case 'agent_run_start':
                            this.emit('agent-status', {
                                isProcessing: true,
                                state: 'executing'
                            });
                            break;
                        case 'agent_run_end':
                            this.emit('agent-status', {
                                isProcessing: false,
                                state: event.status || 'idle'
                            });
                            break;
                        case 'user_message':
                            this.emit('agent-status', {
                                isProcessing: true,
                                state: 'processing'
                            });
                            this.emit('query', {
                                text: event.content
                            });
                            break;
                        case 'assistant_message':
                            this.emit('answer', {
                                text: event.content
                            });
                            break;
                        case 'tool_call':
                            this.emit('event', {
                                type: 'tool_call',
                                name: event.name,
                                toolCallId: event.toolCallId,
                                arguments: event.arguments
                            });
                            break;
                        case 'tool_result':
                            this.emit('event', {
                                type: 'tool_result',
                                name: event.name,
                                toolCallId: event.toolCallId,
                                content: event.content,
                                error: event.error
                            });
                            break;
                        case 'system':
                            this.emit(event.level, {
                                message: event.message
                            });
                            break;
                        default:
                            this.emit('event', event);
                    }
                    if ('system' === event.type && (null == (_event_message = event.message) ? void 0 : _event_message.includes('aborted'))) {
                        this.emit('aborted', {
                            message: event.message
                        });
                        this.emit('agent-status', {
                            isProcessing: false,
                            state: 'idle'
                        });
                    }
                    if ('system' === event.type && (null == (_event_message1 = event.message) ? void 0 : _event_message1.includes('status'))) this.emit('status', {
                        message: event.message
                    });
                };
                return agentEventStream.subscribe(handleEvent);
            }
            constructor(){
                event_stream_define_property(this, "subscribers", new Set());
            }
        }
        (function(AgioEvent) {
            function createEvent(type, sessionId, payload) {
                return {
                    type,
                    timestamp: Date.now(),
                    sessionId,
                    ...payload
                };
            }
            AgioEvent.createEvent = createEvent;
            function createEvents(sessionId, events) {
                return events.map(({ type, payload })=>createEvent(type, sessionId, payload));
            }
            AgioEvent.createEvents = createEvents;
            function isEventType(event, type) {
                return event.type === type;
            }
            AgioEvent.isEventType = isEventType;
        })(src_AgioEvent || (src_AgioEvent = {}));
        var src_AgioEvent;
        function AgioBatchProcessor_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class AgioBatchProcessor {
            addEvent(event) {
                this.eventBuffer.push(event);
                if (this.eventBuffer.length >= this.maxBatchSize) this.flush();
                else this.scheduleFlush();
            }
            async flush() {
                this.clearScheduledFlush();
                if (0 === this.eventBuffer.length) return;
                const eventsToSend = [
                    ...this.eventBuffer
                ];
                this.eventBuffer = [];
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(()=>controller.abort(), this.requestTimeout);
                    const response = await fetch(this.providerUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            events: eventsToSend
                        }),
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                } catch (error) {}
            }
            scheduleFlush() {
                if (!this.timer) this.timer = setTimeout(()=>{
                    this.flush();
                }, this.flushInterval);
            }
            clearScheduledFlush() {
                if (this.timer) {
                    clearTimeout(this.timer);
                    this.timer = null;
                }
            }
            constructor(options){
                AgioBatchProcessor_define_property(this, "providerUrl", void 0);
                AgioBatchProcessor_define_property(this, "maxBatchSize", void 0);
                AgioBatchProcessor_define_property(this, "flushInterval", void 0);
                AgioBatchProcessor_define_property(this, "requestTimeout", void 0);
                AgioBatchProcessor_define_property(this, "eventBuffer", []);
                AgioBatchProcessor_define_property(this, "timer", null);
                this.providerUrl = options.providerUrl;
                this.maxBatchSize = options.maxBatchSize ?? 20;
                this.flushInterval = options.flushInterval ?? 5000;
                this.requestTimeout = options.requestTimeout ?? 5000;
            }
        }
        function AgioProvider_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class AgioProvider {
            calculateCounts() {
                var _this_appConfig_model;
                const toolsCount = this.agent.getTools().length;
                const modelProviders = null == (_this_appConfig_model = this.appConfig.model) ? void 0 : _this_appConfig_model.providers;
                const modelProvidersCount = Array.isArray(modelProviders) ? modelProviders.length : 1;
                const mcpServersConfig = this.appConfig.mcpServers || {};
                const mcpServersCount = Object.keys(mcpServersConfig).length;
                return {
                    mcpServersCount,
                    toolsCount,
                    modelProvidersCount
                };
            }
            async sendAgentInitialized() {
                var _this_appConfig_browser, _this_appConfig_thinking, _this_appConfig_snapshot;
                if (this.hasInitialized) return;
                this.hasInitialized = true;
                const resolvedModel = this.agent.getCurrentResolvedModel();
                const counts = this.calculateCounts();
                this.modelName = null == resolvedModel ? void 0 : resolvedModel.id;
                const event = src_AgioEvent.createEvent('agent_initialized', this.sessionId, {
                    config: {
                        modelProvider: null == resolvedModel ? void 0 : resolvedModel.provider,
                        modelName: null == resolvedModel ? void 0 : resolvedModel.id,
                        toolCallEngine: this.appConfig.toolCallEngine,
                        maxTokens: this.appConfig.maxTokens,
                        temperature: this.appConfig.temperature,
                        maxIterations: this.appConfig.maxIterations,
                        browserControl: null == (_this_appConfig_browser = this.appConfig.browser) ? void 0 : _this_appConfig_browser.control,
                        plannerEnabled: 'object' == typeof this.appConfig.planner ? this.appConfig.planner.enable : Boolean(this.appConfig.planner),
                        thinkingEnabled: (null == (_this_appConfig_thinking = this.appConfig.thinking) ? void 0 : _this_appConfig_thinking.type) === 'enabled',
                        snapshotEnabled: null == (_this_appConfig_snapshot = this.appConfig.snapshot) ? void 0 : _this_appConfig_snapshot.enable,
                        researchEnabled: 'object' == typeof this.appConfig.planner ? this.appConfig.planner.enable : Boolean(this.appConfig.planner),
                        customMcpServers: Boolean(this.appConfig.mcpServers && Object.keys(this.appConfig.mcpServers).length > 0)
                    },
                    count: counts
                });
                this.agentInitializedEvent = event;
            }
            async processAgentEvent(event) {
                try {
                    switch(event.type){
                        case 'agent_run_start':
                            await this.handleRunStart(event);
                            break;
                        case 'agent_run_end':
                            await this.handleRunEnd(event);
                            break;
                        case 'assistant_streaming_message':
                            await this.handleFirstToken(event);
                            break;
                        case 'tool_call':
                            await this.handleToolCall(event);
                            break;
                        case 'tool_result':
                            await this.handleToolResult(event);
                            break;
                        case 'user_message':
                            await this.handleLoopStart();
                            break;
                        case 'assistant_message':
                            await this.handleLoopEnd(event);
                            break;
                        default:
                            break;
                    }
                } catch (error) {
                    console.error('Failed to process AGIO event:', error);
                }
            }
            isInputMultimodal(input) {
                if (!Array.isArray(input)) return false;
                return input.some((part)=>{
                    if ('object' == typeof part && null !== part) {
                        if ('image_url' === part.type || 'image' === part.type) return true;
                        if (part.type && 'text' !== part.type) return true;
                    }
                    return false;
                });
            }
            async handleRunStart(event) {
                var _event_runOptions, _event_runOptions1, _event_runOptions2;
                if (this.agentInitializedEvent) {
                    await this.queueEvent(this.agentInitializedEvent);
                    this.agentInitializedEvent = null;
                }
                this.runId = event.sessionId;
                this.runStartTime = Date.now();
                this.firstTokenTime = void 0;
                this.currentIteration = 0;
                this.loopStartTimes.clear();
                const isMultimodalInput = this.isInputMultimodal((null == (_event_runOptions = event.runOptions) ? void 0 : _event_runOptions.input) || '');
                const agioEvent = src_AgioEvent.createEvent('agent_run_start', this.sessionId, {
                    runId: this.runId,
                    input: (null == (_event_runOptions1 = event.runOptions) ? void 0 : _event_runOptions1.input) || '',
                    isMultimodalInput,
                    streaming: Boolean(null == (_event_runOptions2 = event.runOptions) ? void 0 : _event_runOptions2.stream)
                });
                await this.queueEvent(agioEvent);
            }
            async handleRunEnd(event) {
                if (!this.runStartTime || !this.runId) return;
                const executionTimeMs = Date.now() - this.runStartTime;
                const successful = event.status !== core_.AgentStatus.ERROR;
                const isError = event.status === core_.AgentStatus.ERROR;
                const agioEvent = src_AgioEvent.createEvent('agent_run_end', this.sessionId, {
                    runId: this.runId,
                    executionTimeMs,
                    loopCount: event.iterations || this.currentIteration,
                    successful,
                    error: isError ? 'AgentRunError' : ''
                });
                await this.queueEvent(agioEvent);
                await this.batchProcessor.flush();
                this.runId = void 0;
                this.runStartTime = void 0;
            }
            async handleFirstToken(event) {
                if (!this.firstTokenTime && this.runStartTime && event.content) {
                    this.firstTokenTime = Date.now();
                    const ttftMs = this.firstTokenTime - this.runStartTime;
                    const agioEvent = src_AgioEvent.createEvent('agent_ttft', this.sessionId, {
                        runId: this.runId,
                        modelName: this.modelName,
                        ttftMs
                    });
                    await this.queueEvent(agioEvent);
                }
            }
            async handleToolCall(event) {
                const sanitizedArgs = this.sanitizeArguments(event.arguments);
                const agioEvent = src_AgioEvent.createEvent('tool_call', this.sessionId, {
                    runId: this.runId,
                    toolName: event.name,
                    toolCallId: event.toolCallId,
                    arguments: sanitizedArgs,
                    argumentsSize: JSON.stringify(event.arguments).length,
                    mcpServer: this.extractMCPServer(event.name)
                });
                await this.queueEvent(agioEvent);
            }
            async handleToolResult(event) {
                const agioEvent = src_AgioEvent.createEvent('tool_result', this.sessionId, {
                    runId: this.runId,
                    toolName: event.name,
                    toolCallId: event.toolCallId,
                    executionTimeMs: event.elapsedMs || 0,
                    successful: !event.error,
                    resultSize: this.calculateResultSize(event.content),
                    contentType: this.determineContentType(event.content)
                });
                await this.queueEvent(agioEvent);
            }
            async handleLoopStart() {
                this.currentIteration++;
                this.loopStartTimes.set(this.currentIteration, Date.now());
                const agioEvent = src_AgioEvent.createEvent('agent_loop_start', this.sessionId, {
                    runId: this.runId,
                    iteration: this.currentIteration
                });
                await this.queueEvent(agioEvent);
            }
            async handleLoopEnd(event) {
                const startTime = this.loopStartTimes.get(this.currentIteration);
                if (!startTime) return;
                const durationMs = Date.now() - startTime;
                const agioEvent = src_AgioEvent.createEvent('agent_loop_end', this.sessionId, {
                    runId: this.runId,
                    iteration: this.currentIteration,
                    durationMs
                });
                await this.queueEvent(agioEvent);
                this.loopStartTimes.delete(this.currentIteration);
            }
            queueEvent(event) {
                this.batchProcessor.addEvent(event);
            }
            sanitizeArguments(args) {
                if (!args || 'object' != typeof args) return {};
                const sanitized = {};
                const sensitiveKeys = [
                    'password',
                    'token',
                    'key',
                    'secret',
                    'apikey',
                    'auth'
                ];
                for (const [key, value] of Object.entries(args)){
                    const keyLower = key.toLowerCase();
                    if (sensitiveKeys.some((sensitive)=>keyLower.includes(sensitive))) sanitized[key] = '[REDACTED]';
                    else if ('string' == typeof value && value.length > 1000) sanitized[key] = value.substring(0, 100) + '...[TRUNCATED]';
                    else sanitized[key] = value;
                }
                return sanitized;
            }
            extractMCPServer(toolName) {
                if (toolName.startsWith('browser_')) return 'browser';
                if (toolName.startsWith('filesystem_')) return 'filesystem';
                if ('web_search' === toolName) return 'search';
                if (toolName.startsWith('commands_')) return 'commands';
            }
            calculateResultSize(content) {
                if (!content) return 0;
                try {
                    return JSON.stringify(content).length;
                } catch  {
                    return String(content).length;
                }
            }
            determineContentType(content) {
                if (!content) return 'empty';
                if ('string' == typeof content) return 'text';
                if (Array.isArray(content)) return 'array';
                if ('object' == typeof content) return 'object';
                return 'unknown';
            }
            async cleanup() {
                await this.batchProcessor.flush();
            }
            constructor(providerUrl, appConfig, sessionId, agent){
                AgioProvider_define_property(this, "providerUrl", void 0);
                AgioProvider_define_property(this, "appConfig", void 0);
                AgioProvider_define_property(this, "sessionId", void 0);
                AgioProvider_define_property(this, "agent", void 0);
                AgioProvider_define_property(this, "runId", void 0);
                AgioProvider_define_property(this, "runStartTime", void 0);
                AgioProvider_define_property(this, "firstTokenTime", void 0);
                AgioProvider_define_property(this, "loopStartTimes", void 0);
                AgioProvider_define_property(this, "currentIteration", void 0);
                AgioProvider_define_property(this, "hasInitialized", void 0);
                AgioProvider_define_property(this, "modelName", void 0);
                AgioProvider_define_property(this, "batchProcessor", void 0);
                AgioProvider_define_property(this, "agentInitializedEvent", void 0);
                this.providerUrl = providerUrl;
                this.appConfig = appConfig;
                this.sessionId = sessionId;
                this.agent = agent;
                this.loopStartTimes = new Map();
                this.currentIteration = 0;
                this.hasInitialized = false;
                this.agentInitializedEvent = null;
                this.sessionId = sessionId;
                this.agent = agent;
                this.appConfig = agent.getOptions();
                this.batchProcessor = new AgioBatchProcessor({
                    providerUrl: this.providerUrl,
                    maxBatchSize: 3
                });
            }
        }
        var error_handler = __webpack_require__("./src/utils/error-handler.ts");
        function AgentSession_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class AgentSession {
            getProcessingStatus() {
                return this.agent.status() === core_.AgentStatus.EXECUTING;
            }
            async initialize() {
                await this.agent.initialize();
                if (this.agioProvider) try {
                    await this.agioProvider.sendAgentInitialized();
                } catch (error) {
                    console.error('Failed to send AGIO initialization event:', error);
                }
                const agentEventStream = this.agent.getEventStream();
                const handleEvent = async (event)=>{
                    if (this.server.storageProvider) try {
                        await this.server.storageProvider.saveEvent(this.id, event);
                    } catch (error) {
                        console.error(`Failed to save event to storage: ${error}`);
                    }
                    if (this.agioProvider) try {
                        await this.agioProvider.processAgentEvent(event);
                    } catch (error) {
                        console.error('Failed to process AGIO event:', error);
                    }
                };
                const storageUnsubscribe = agentEventStream.subscribe(handleEvent);
                this.unsubscribe = this.eventBridge.connectToAgentEventStream(agentEventStream);
                this.eventBridge.emit('ready', {
                    sessionId: this.id
                });
                return {
                    storageUnsubscribe
                };
            }
            async runQuery(query) {
                try {
                    const result = await this.agent.run({
                        input: query
                    });
                    return {
                        success: true,
                        result
                    };
                } catch (error) {
                    this.eventBridge.emit('error', {
                        message: error instanceof Error ? error.message : String(error)
                    });
                    const handledError = (0, error_handler.rB)(error, `Session ${this.id}`);
                    return {
                        success: false,
                        error: {
                            code: handledError.code,
                            message: handledError.message,
                            details: handledError.details
                        }
                    };
                }
            }
            async runQueryStreaming(query) {
                try {
                    return await this.agent.run({
                        input: query,
                        stream: true
                    });
                } catch (error) {
                    this.eventBridge.emit('error', {
                        message: error instanceof Error ? error.message : String(error)
                    });
                    const handledError = (0, error_handler.rB)(error, `Session ${this.id} (streaming)`);
                    return this.createErrorEventStream(handledError);
                }
            }
            async *createErrorEventStream(error) {
                yield this.agent.getEventStream().createEvent('system', {
                    level: 'error',
                    message: error.message,
                    details: {
                        errorCode: error.code,
                        details: error.details
                    }
                });
            }
            async abortQuery() {
                try {
                    const aborted = this.agent.abort();
                    if (aborted) this.eventBridge.emit('aborted', {
                        sessionId: this.id
                    });
                    return aborted;
                } catch (error) {
                    this.eventBridge.emit('error', {
                        message: error instanceof Error ? error.message : String(error)
                    });
                    return false;
                }
            }
            async cleanup() {
                if (this.unsubscribe) {
                    this.unsubscribe();
                    this.unsubscribe = null;
                }
                await this.agent.cleanup();
                if (this.agioProvider) {
                    var _this_agioProvider_cleanup, _this_agioProvider;
                    await (null == (_this_agioProvider_cleanup = (_this_agioProvider = this.agioProvider).cleanup) ? void 0 : _this_agioProvider_cleanup.call(_this_agioProvider));
                }
                this.eventBridge.emit('closed', {
                    sessionId: this.id
                });
            }
            constructor(server, sessionId, agioProviderImpl, workingDirectory){
                var _appConfig_snapshot, _appConfig_agio;
                AgentSession_define_property(this, "server", void 0);
                AgentSession_define_property(this, "id", void 0);
                AgentSession_define_property(this, "agent", void 0);
                AgentSession_define_property(this, "eventBridge", void 0);
                AgentSession_define_property(this, "unsubscribe", void 0);
                AgentSession_define_property(this, "agioProvider", void 0);
                this.server = server;
                this.unsubscribe = null;
                this.id = sessionId;
                this.eventBridge = new EventStreamBridge();
                const { appConfig } = server;
                const { workspace, server: appServerConfig } = appConfig;
                workspace.workingDirectory = workingDirectory;
                const agent = new core_.AgentTARS(server.appConfig);
                if (null == (_appConfig_snapshot = appConfig.snapshot) ? void 0 : _appConfig_snapshot.enable) {
                    const snapshotStoragesDirectory = appConfig.snapshot.storageDirectory ?? workspace.workingDirectory;
                    const snapshotPath = external_path_default().join(snapshotStoragesDirectory, sessionId);
                    this.agent = new agent_snapshot_AgentSnapshot(agent, {
                        snapshotPath,
                        snapshotName: sessionId
                    });
                    agent.logger.debug(`AgentSnapshot initialized with path: ${snapshotPath}`);
                } else this.agent = agent;
                if (null == (_appConfig_agio = appConfig.agio) ? void 0 : _appConfig_agio.provider) {
                    var _appConfig_agio1;
                    const impl = agioProviderImpl ?? AgioProvider;
                    this.agioProvider = new impl(null == (_appConfig_agio1 = appConfig.agio) ? void 0 : _appConfig_agio1.provider, appConfig, sessionId, agent);
                    agent.logger.debug(`AGIO collector initialized with provider: ${appConfig.agio.provider}`);
                }
                agent.logger.info('Agent Config', JSON.stringify(agent.getOptions(), null, 2));
            }
        }
        var SocketHandlers = __webpack_require__("./src/core/SocketHandlers.ts");
    },
    "./src/server.ts": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            t: ()=>AgentTARSServer,
            z: ()=>express_default()
        });
        var express = __webpack_require__("../node_modules/.pnpm/express@4.21.2/node_modules/express/index.js");
        var express_default = /*#__PURE__*/ __webpack_require__.n(express);
        var external_http_ = __webpack_require__("http");
        var external_http_default = /*#__PURE__*/ __webpack_require__.n(external_http_);
        var lib = __webpack_require__("../node_modules/.pnpm/cors@2.8.5/node_modules/cors/lib/index.js");
        var lib_default = /*#__PURE__*/ __webpack_require__.n(lib);
        const external_node_crypto_namespaceObject = require("node:crypto");
        const urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
        const POOL_SIZE_MULTIPLIER = 128;
        let pool, poolOffset;
        function fillPool(bytes) {
            if (!pool || pool.length < bytes) {
                pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
                external_node_crypto_namespaceObject.webcrypto.getRandomValues(pool);
                poolOffset = 0;
            } else if (poolOffset + bytes > pool.length) {
                external_node_crypto_namespaceObject.webcrypto.getRandomValues(pool);
                poolOffset = 0;
            }
            poolOffset += bytes;
        }
        function nanoid(size = 21) {
            fillPool(size |= 0);
            let id = '';
            for(let i = poolOffset - size; i < poolOffset; i++)id += urlAlphabet[63 & pool[i]];
            return id;
        }
        var workspace = __webpack_require__("./src/utils/workspace.ts");
        var core = __webpack_require__("./src/core/index.ts");
        var services = __webpack_require__("./src/services/index.ts");
        async function getAllSessions(req, res) {
            try {
                const server = req.app.locals.server;
                if (!server.storageProvider) {
                    const activeSessions = Object.keys(server.sessions).map((id)=>({
                            id,
                            createdAt: Date.now(),
                            updatedAt: Date.now()
                        }));
                    return res.status(200).json({
                        sessions: activeSessions
                    });
                }
                const sessions = await server.storageProvider.getAllSessions();
                res.status(200).json({
                    sessions
                });
            } catch (error) {
                console.error('Failed to get sessions:', error);
                res.status(500).json({
                    error: 'Failed to get sessions'
                });
            }
        }
        async function createSession(req, res) {
            try {
                var _server_appConfig_workspace;
                const server = req.app.locals.server;
                const sessionId = nanoid();
                await cleanupBrowserPagesForExistingSessions(server);
                const isolateSessions = (null == (_server_appConfig_workspace = server.appConfig.workspace) ? void 0 : _server_appConfig_workspace.isolateSessions) ?? false;
                const workingDirectory = (0, workspace.s)(sessionId, server.workspacePath, isolateSessions);
                const session = new core.ZT(server, sessionId, server.getCustomAgioProvider(), workingDirectory);
                server.sessions[sessionId] = session;
                const { storageUnsubscribe } = await session.initialize();
                if (storageUnsubscribe) server.storageUnsubscribes[sessionId] = storageUnsubscribe;
                if (server.storageProvider) {
                    const metadata = {
                        id: sessionId,
                        createdAt: Date.now(),
                        updatedAt: Date.now(),
                        workingDirectory
                    };
                    await server.storageProvider.createSession(metadata);
                }
                res.status(201).json({
                    sessionId
                });
            } catch (error) {
                console.error('Failed to create session:', error);
                res.status(500).json({
                    error: 'Failed to create session'
                });
            }
        }
        async function cleanupBrowserPagesForExistingSessions(server) {
            try {
                const activeSessions = Object.values(server.sessions);
                for (const session of activeSessions)if (session && session.agent) {
                    var _session_agent_getBrowserManager, _session_agent;
                    const browserManager = null == (_session_agent_getBrowserManager = (_session_agent = session.agent).getBrowserManager) ? void 0 : _session_agent_getBrowserManager.call(_session_agent);
                    if (browserManager && browserManager.isLaunchingComplete()) {
                        console.log("Closing browser pages for session before creating new session");
                        await browserManager.closeAllPages();
                    }
                }
            } catch (error) {
                console.warn(`Failed to cleanup browser pages for existing sessions: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
        async function getSessionDetails(req, res) {
            const sessionId = req.query.sessionId;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            try {
                const server = req.app.locals.server;
                if (server.storageProvider) {
                    const metadata = await server.storageProvider.getSessionMetadata(sessionId);
                    if (metadata) return res.status(200).json({
                        session: metadata
                    });
                }
                if (server.sessions[sessionId]) return res.status(200).json({
                    session: {
                        id: sessionId,
                        createdAt: Date.now(),
                        updatedAt: Date.now(),
                        workingDirectory: server.sessions[sessionId].agent.getWorkingDirectory()
                    }
                });
                return res.status(404).json({
                    error: 'Session not found'
                });
            } catch (error) {
                console.error(`Error getting session details for ${sessionId}:`, error);
                res.status(500).json({
                    error: 'Failed to get session details'
                });
            }
        }
        async function getSessionEvents(req, res) {
            const sessionId = req.query.sessionId;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            try {
                const server = req.app.locals.server;
                if (!server.storageProvider) return res.status(404).json({
                    error: 'Storage not configured, no events available'
                });
                const events = await server.storageProvider.getSessionEvents(sessionId);
                res.status(200).json({
                    events
                });
            } catch (error) {
                console.error(`Error getting events for session ${sessionId}:`, error);
                res.status(500).json({
                    error: 'Failed to get session events'
                });
            }
        }
        async function getSessionStatus(req, res) {
            var _server_appConfig_workspace;
            const sessionId = req.query.sessionId;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            const server = req.app.locals.server;
            const isolateSessions = (null == (_server_appConfig_workspace = server.appConfig.workspace) ? void 0 : _server_appConfig_workspace.isolateSessions) ?? false;
            const workingDirectory = (0, workspace.s)(sessionId, server.workspacePath, isolateSessions);
            try {
                const server = req.app.locals.server;
                let session = server.sessions[sessionId];
                if (!session && server.storageProvider) {
                    const metadata = await server.storageProvider.getSessionMetadata(sessionId);
                    if (metadata) try {
                        session = new core.ZT(server, sessionId, server.getCustomAgioProvider(), workingDirectory);
                        server.sessions[sessionId] = session;
                        const { storageUnsubscribe } = await session.initialize();
                        if (storageUnsubscribe) server.storageUnsubscribes[sessionId] = storageUnsubscribe;
                    } catch (error) {
                        console.error(`Failed to restore session ${sessionId}:`, error);
                        return res.status(200).json({
                            sessionId,
                            status: {
                                isProcessing: false,
                                state: 'stored'
                            }
                        });
                    }
                }
                if (!session) return res.status(404).json({
                    error: 'Session not found'
                });
                const isProcessing = session.getProcessingStatus();
                res.status(200).json({
                    sessionId,
                    status: {
                        isProcessing,
                        state: session.agent.status()
                    }
                });
            } catch (error) {
                console.error(`Error getting session status (${sessionId}):`, error);
                res.status(500).json({
                    error: 'Failed to get session status'
                });
            }
        }
        async function updateSession(req, res) {
            const { sessionId, name, tags } = req.body;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            try {
                const server = req.app.locals.server;
                if (!server.storageProvider) return res.status(404).json({
                    error: 'Storage not configured, cannot update session'
                });
                const metadata = await server.storageProvider.getSessionMetadata(sessionId);
                if (!metadata) return res.status(404).json({
                    error: 'Session not found'
                });
                const updatedMetadata = await server.storageProvider.updateSessionMetadata(sessionId, {
                    name,
                    tags,
                    updatedAt: Date.now()
                });
                res.status(200).json({
                    session: updatedMetadata
                });
            } catch (error) {
                console.error(`Error updating session ${sessionId}:`, error);
                res.status(500).json({
                    error: 'Failed to update session'
                });
            }
        }
        async function deleteSession(req, res) {
            const { sessionId } = req.body;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            try {
                const server = req.app.locals.server;
                if (server.sessions[sessionId]) {
                    try {
                        var _server_sessions_sessionId_agent_getBrowserManager, _server_sessions_sessionId_agent;
                        const browserManager = null == (_server_sessions_sessionId_agent_getBrowserManager = (_server_sessions_sessionId_agent = server.sessions[sessionId].agent).getBrowserManager) ? void 0 : _server_sessions_sessionId_agent_getBrowserManager.call(_server_sessions_sessionId_agent);
                        if (browserManager && browserManager.isLaunchingComplete()) {
                            console.log(`Closing browser pages for session ${sessionId} before deletion`);
                            await browserManager.closeAllPages();
                        }
                    } catch (error) {
                        console.warn(`Failed to cleanup browser pages for session ${sessionId}: ${error instanceof Error ? error.message : String(error)}`);
                    }
                    await server.sessions[sessionId].cleanup();
                    delete server.sessions[sessionId];
                    if (server.storageUnsubscribes[sessionId]) {
                        server.storageUnsubscribes[sessionId]();
                        delete server.storageUnsubscribes[sessionId];
                    }
                }
                if (server.storageProvider) {
                    const deleted = await server.storageProvider.deleteSession(sessionId);
                    if (!deleted) return res.status(404).json({
                        error: 'Session not found in storage'
                    });
                }
                res.status(200).json({
                    success: true
                });
            } catch (error) {
                console.error(`Error deleting session ${sessionId}:`, error);
                res.status(500).json({
                    error: 'Failed to delete session'
                });
            }
        }
        async function generateSummary(req, res) {
            const { sessionId, messages, model, provider } = req.body;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            if (!Array.isArray(messages) || 0 === messages.length) return res.status(400).json({
                error: 'Messages are required'
            });
            try {
                const server = req.app.locals.server;
                const session = server.sessions[sessionId];
                if (!session) return res.status(404).json({
                    error: 'Session not found'
                });
                const summaryResponse = await session.agent.generateSummary({
                    messages,
                    model,
                    provider
                });
                res.status(200).json(summaryResponse);
            } catch (error) {
                console.error(`Error generating summary for session ${sessionId}:`, error);
                res.status(500).json({
                    error: 'Failed to generate summary',
                    message: error instanceof Error ? error.message : String(error)
                });
            }
        }
        async function getBrowserControlInfo(req, res) {
            const sessionId = req.query.sessionId;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            try {
                const server = req.app.locals.server;
                const session = server.sessions[sessionId];
                if (!session) return res.status(404).json({
                    error: 'Session not found'
                });
                const browserControlInfo = await session.agent.getBrowserControlInfo();
                res.status(200).json(browserControlInfo);
            } catch (error) {
                console.error(`Error getting browser control info (${sessionId}):`, error);
                res.status(500).json({
                    error: 'Failed to get browser control info'
                });
            }
        }
        async function shareSession(req, res) {
            const { sessionId, upload } = req.body;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            try {
                var _server_sessions_sessionId;
                const server = req.app.locals.server;
                const shareService = new services.t(server.appConfig, server.storageProvider);
                const agent = null == (_server_sessions_sessionId = server.sessions[sessionId]) ? void 0 : _server_sessions_sessionId.agent;
                const result = await shareService.shareSession(sessionId, upload, agent);
                if (result.success) return res.status(200).json(result);
                return res.status(500).json({
                    error: result.error || 'Failed to share session'
                });
            } catch (error) {
                console.error(`Error sharing session ${sessionId}:`, error);
                return res.status(500).json({
                    error: 'Failed to share session'
                });
            }
        }
        async function getLatestSessionEvents(req, res) {
            try {
                const server = req.app.locals.server;
                if (!server.storageProvider) return res.status(404).json({
                    error: 'Storage not configured, cannot get latest session events'
                });
                const sessions = await server.storageProvider.getAllSessions();
                if (0 === sessions.length) return res.status(404).json({
                    error: 'No sessions found'
                });
                const latestSession = sessions.reduce((latest, current)=>current.updatedAt > latest.updatedAt ? current : latest);
                const events = await server.storageProvider.getSessionEvents(latestSession.id);
                res.status(200).json({
                    sessionId: latestSession.id,
                    sessionMetadata: latestSession,
                    events
                });
            } catch (error) {
                console.error('Error getting latest session events:', error);
                res.status(500).json({
                    error: 'Failed to get latest session events'
                });
            }
        }
        function registerSessionRoutes(app) {
            app.get('/api/v1/sessions', getAllSessions);
            app.post('/api/v1/sessions/create', createSession);
            app.get('/api/v1/sessions/details', getSessionDetails);
            app.get('/api/v1/sessions/events', getSessionEvents);
            app.get('/api/v1/sessions/events/latest', getLatestSessionEvents);
            app.get('/api/v1/sessions/status', getSessionStatus);
            app.post('/api/v1/sessions/update', updateSession);
            app.post('/api/v1/sessions/delete', deleteSession);
            app.post('/api/v1/sessions/generate-summary', generateSummary);
            app.get('/api/v1/sessions/browser-control', getBrowserControlInfo);
            app.post('/api/v1/sessions/share', shareSession);
        }
        var core_ = __webpack_require__("@agent-tars/core");
        var error_handler = __webpack_require__("./src/utils/error-handler.ts");
        const imageCompressor = new core_.ImageCompressor({
            quality: 5,
            format: 'webp'
        });
        async function compressImagesInQuery(query) {
            try {
                if ('string' == typeof query) return query;
                if (Array.isArray(query)) {
                    const compressedQuery = await Promise.all(query.map(async (part)=>{
                        var _part_image_url;
                        if ('image_url' === part.type && (null == (_part_image_url = part.image_url) ? void 0 : _part_image_url.url)) return await compressImageUrl(part);
                        return part;
                    }));
                    return compressedQuery;
                }
                return query;
            } catch (error) {
                console.error('Error compressing images in query:', error);
                return query;
            }
        }
        async function compressImageUrl(imagePart) {
            try {
                const imageUrl = imagePart.image_url.url;
                if (!imageUrl.startsWith('data:image/')) return imagePart;
                const base64Data = imageUrl.replace(/^data:image\/\w+;base64,/, '');
                const originalBuffer = Buffer.from(base64Data, 'base64');
                const originalSize = originalBuffer.length;
                const compressedBuffer = await imageCompressor.compressToBuffer(originalBuffer);
                const compressedSize = compressedBuffer.length;
                const compressedBase64 = `data:image/webp;base64,${compressedBuffer.toString('base64')}`;
                const compressionRatio = originalSize / compressedSize;
                const compressionPercentage = ((1 - compressedSize / originalSize) * 100).toFixed(2);
                console.log('Image compression stats:', {
                    original: (0, core_.formatBytes)(originalSize),
                    compressed: (0, core_.formatBytes)(compressedSize),
                    ratio: `${compressionRatio.toFixed(2)}x (${compressionPercentage}% smaller)`,
                    format: 'webp',
                    quality: 80
                });
                return {
                    ...imagePart,
                    image_url: {
                        url: compressedBase64
                    }
                };
            } catch (error) {
                console.error('Error compressing individual image:', error);
                return imagePart;
            }
        }
        async function executeQuery(req, res) {
            const { sessionId, query } = req.body;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            if (!query) return res.status(400).json({
                error: 'Query is required'
            });
            const server = req.app.locals.server;
            if (!server.sessions[sessionId]) return res.status(404).json({
                error: 'Session not found'
            });
            try {
                const compressedQuery = await compressImagesInQuery(query);
                const response = await server.sessions[sessionId].runQuery(compressedQuery);
                if (response.success) res.status(200).json({
                    result: response.result
                });
                else res.status(500).json(response);
            } catch (error) {
                console.error(`Unexpected error processing query in session ${sessionId}:`, error);
                res.status(500).json((0, error_handler.jl)(error));
            }
        }
        async function executeStreamingQuery(req, res) {
            const { sessionId, query } = req.body;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            if (!query) return res.status(400).json({
                error: 'Query is required'
            });
            const server = req.app.locals.server;
            if (!server.sessions[sessionId]) return res.status(404).json({
                error: 'Session not found'
            });
            try {
                res.setHeader('Content-Type', 'text/event-stream');
                res.setHeader('Cache-Control', 'no-cache');
                res.setHeader('Connection', 'keep-alive');
                const compressedQuery = await compressImagesInQuery(query);
                const eventStream = await server.sessions[sessionId].runQueryStreaming(compressedQuery);
                for await (const event of eventStream){
                    const isErrorEvent = 'system' === event.type && 'error' === event.level;
                    if (res.closed) break;
                    res.write(`data: ${JSON.stringify(event)}\n\n`);
                    if (isErrorEvent) break;
                }
                if (!res.closed) res.end();
            } catch (error) {
                console.error(`Critical error in streaming query for session ${sessionId}:`, error);
                if (res.headersSent) {
                    const errorObj = (0, error_handler.jl)(error);
                    res.write(`data: ${JSON.stringify({
                        type: 'system',
                        level: 'error',
                        message: errorObj.error.message,
                        timestamp: Date.now()
                    })}\n\n`);
                    res.end();
                } else res.status(500).json((0, error_handler.jl)(error));
            }
        }
        async function abortQuery(req, res) {
            const { sessionId } = req.body;
            if (!sessionId) return res.status(400).json({
                error: 'Session ID is required'
            });
            const server = req.app.locals.server;
            if (!server.sessions[sessionId]) return res.status(404).json({
                error: 'Session not found'
            });
            try {
                const aborted = await server.sessions[sessionId].abortQuery();
                res.status(200).json({
                    success: aborted
                });
            } catch (error) {
                console.error(`Error aborting query in session ${sessionId}:`, error);
                res.status(500).json({
                    error: 'Failed to abort query'
                });
            }
        }
        function registerQueryRoutes(app) {
            app.post('/api/v1/sessions/query', executeQuery);
            app.post('/api/v1/sessions/query/stream', executeStreamingQuery);
            app.post('/api/v1/sessions/abort', abortQuery);
        }
        function healthCheck(req, res) {
            res.status(200).json({
                status: 'ok'
            });
        }
        function registerSystemRoutes(app) {
            app.get('/api/v1/health', healthCheck);
        }
        function getShareConfig(req, res) {
            const server = req.app.locals.server;
            const shareService = new services.t(server.appConfig, server.storageProvider);
            res.status(200).json(shareService.getShareConfig());
        }
        function registerShareRoutes(app) {
            app.get('/api/v1/share/config', getShareConfig);
        }
        async function createAndQuery(req, res) {
            try {
                var _server_appConfig_workspace;
                const { query, sessionName, sessionTags } = req.body;
                if (!query) return res.status(400).json({
                    error: 'Query is required'
                });
                const server = req.app.locals.server;
                const sessionId = nanoid();
                const isolateSessions = (null == (_server_appConfig_workspace = server.appConfig.workspace) ? void 0 : _server_appConfig_workspace.isolateSessions) ?? false;
                const workingDirectory = (0, workspace.s)(sessionId, server.workspacePath, isolateSessions);
                const session = new core.ZT(server, sessionId, server.getCustomAgioProvider(), workingDirectory);
                server.sessions[sessionId] = session;
                const { storageUnsubscribe } = await session.initialize();
                if (storageUnsubscribe) server.storageUnsubscribes[sessionId] = storageUnsubscribe;
                if (server.storageProvider) {
                    const metadata = {
                        id: sessionId,
                        createdAt: Date.now(),
                        updatedAt: Date.now(),
                        name: sessionName,
                        workingDirectory,
                        tags: sessionTags
                    };
                    await server.storageProvider.createSession(metadata);
                }
                const response = await session.runQuery(query);
                if (response.success) res.status(200).json({
                    sessionId,
                    result: response.result
                });
                else res.status(500).json({
                    sessionId,
                    ...response
                });
            } catch (error) {
                console.error("Unexpected error in createAndQuery:", error);
                res.status(500).json((0, error_handler.jl)(error));
            }
        }
        async function createAndStreamingQuery(req, res) {
            try {
                var _server_appConfig_workspace;
                const { query, sessionName, sessionTags } = req.body;
                if (!query) return res.status(400).json({
                    error: 'Query is required'
                });
                const server = req.app.locals.server;
                const sessionId = nanoid();
                const isolateSessions = (null == (_server_appConfig_workspace = server.appConfig.workspace) ? void 0 : _server_appConfig_workspace.isolateSessions) ?? false;
                const workingDirectory = (0, workspace.s)(sessionId, server.workspacePath, isolateSessions);
                const session = new core.ZT(server, sessionId, server.getCustomAgioProvider(), workingDirectory);
                server.sessions[sessionId] = session;
                const { storageUnsubscribe } = await session.initialize();
                if (storageUnsubscribe) server.storageUnsubscribes[sessionId] = storageUnsubscribe;
                if (server.storageProvider) {
                    const metadata = {
                        id: sessionId,
                        createdAt: Date.now(),
                        updatedAt: Date.now(),
                        name: sessionName,
                        workingDirectory,
                        tags: sessionTags
                    };
                    await server.storageProvider.createSession(metadata);
                }
                res.setHeader('Content-Type', 'text/event-stream');
                res.setHeader('Cache-Control', 'no-cache');
                res.setHeader('Connection', 'keep-alive');
                res.write(`data: ${JSON.stringify({
                    type: 'session_created',
                    sessionId,
                    timestamp: Date.now()
                })}\n\n`);
                const eventStream = await session.runQueryStreaming(query);
                for await (const event of eventStream){
                    const isErrorEvent = 'system' === event.type && 'error' === event.level;
                    if (res.closed) break;
                    res.write(`data: ${JSON.stringify(event)}\n\n`);
                    if (isErrorEvent) break;
                }
                if (!res.closed) res.end();
            } catch (error) {
                console.error("Critical error in streaming query creation:", error);
                if (res.headersSent) {
                    const errorObj = (0, error_handler.jl)(error);
                    res.write(`data: ${JSON.stringify({
                        type: 'system',
                        level: 'error',
                        message: errorObj.error.message,
                        timestamp: Date.now()
                    })}\n\n`);
                    res.end();
                } else res.status(500).json((0, error_handler.jl)(error));
            }
        }
        function registerOneshotRoutes(app) {
            app.post('/api/v1/oneshot/query', createAndQuery);
            app.post('/api/v1/oneshot/query/stream', createAndStreamingQuery);
        }
        function registerAllRoutes(app) {
            registerSessionRoutes(app);
            registerQueryRoutes(app);
            registerSystemRoutes(app);
            registerShareRoutes(app);
            registerOneshotRoutes(app);
        }
        function getDefaultCorsOptions() {
            return {
                origin: '*',
                methods: [
                    'GET',
                    'POST',
                    'PUT',
                    'DELETE',
                    'OPTIONS'
                ],
                allowedHeaders: [
                    'Content-Type',
                    'Authorization'
                ]
            };
        }
        function setupAPI(app) {
            app.use(lib_default()(getDefaultCorsOptions()));
            app.use(express_default().json({
                limit: '20mb'
            }));
            registerAllRoutes(app);
        }
        var SocketHandlers = __webpack_require__("./src/core/SocketHandlers.ts");
        var storage = __webpack_require__("./src/storage/index.ts");
        function _define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class AgentTARSServer {
            getCustomAgioProvider() {
                return this.customAgioProvider;
            }
            getApp() {
                return this.app;
            }
            getHttpServer() {
                return this.server;
            }
            getSocketIOServer() {
                return this.io;
            }
            isServerRunning() {
                return this.isRunning;
            }
            getStorageInfo() {
                if (!this.storageProvider) return {
                    type: 'none'
                };
                if ('FileStorageProvider' === this.storageProvider.constructor.name) return {
                    type: 'file',
                    path: this.storageProvider.dbPath
                };
                if ('SQLiteStorageProvider' === this.storageProvider.constructor.name) return {
                    type: 'sqlite',
                    path: this.storageProvider.dbPath
                };
                return {
                    type: this.storageProvider.constructor.name.replace('StorageProvider', '').toLowerCase()
                };
            }
            async start() {
                if (this.storageProvider) try {
                    await this.storageProvider.initialize();
                } catch (error) {
                    console.error('Failed to initialize storage provider:', error);
                }
                return new Promise((resolve)=>{
                    this.server.listen(this.port, ()=>{
                        this.isRunning = true;
                        resolve(this.server);
                    });
                });
            }
            async stop() {
                const sessionCleanup = Object.values(this.sessions).map((session)=>session.cleanup());
                await Promise.all(sessionCleanup);
                Object.values(this.storageUnsubscribes).forEach((unsubscribe)=>unsubscribe());
                this.storageUnsubscribes = {};
                this.sessions = {};
                if (this.storageProvider) await this.storageProvider.close();
                if (this.isRunning) return new Promise((resolve, reject)=>{
                    this.server.close((err)=>{
                        if (err) return void reject(err);
                        this.isRunning = false;
                        resolve();
                    });
                });
                return Promise.resolve();
            }
            constructor(appConfig, injectionOptions){
                var _appConfig_workspace;
                _define_property(this, "app", void 0);
                _define_property(this, "server", void 0);
                _define_property(this, "io", void 0);
                _define_property(this, "isRunning", false);
                _define_property(this, "sessions", {});
                _define_property(this, "storageUnsubscribes", {});
                _define_property(this, "customAgioProvider", void 0);
                _define_property(this, "port", void 0);
                _define_property(this, "workspacePath", void 0);
                _define_property(this, "isDebug", void 0);
                _define_property(this, "storageProvider", null);
                _define_property(this, "appConfig", void 0);
                this.appConfig = appConfig;
                this.port = appConfig.server.port ?? 3000;
                this.workspacePath = null == (_appConfig_workspace = appConfig.workspace) ? void 0 : _appConfig_workspace.workingDirectory;
                this.isDebug = appConfig.logLevel === core_.LogLevel.DEBUG;
                this.customAgioProvider = null == injectionOptions ? void 0 : injectionOptions.agioProvider;
                this.app = express_default()();
                this.server = external_http_default().createServer(this.app);
                if (appConfig.server.storage) this.storageProvider = (0, storage.E)(appConfig.server.storage);
                setupAPI(this.app);
                this.io = (0, SocketHandlers.s)(this.server, this);
                this.app.locals.server = this;
            }
        }
    },
    "./src/services/index.ts": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            t: ()=>ShareService
        });
        var external_fs_ = __webpack_require__("fs");
        var external_fs_default = /*#__PURE__*/ __webpack_require__.n(external_fs_);
        var external_path_ = __webpack_require__("path");
        var external_path_default = /*#__PURE__*/ __webpack_require__.n(external_path_);
        var external_os_ = __webpack_require__("os");
        var external_os_default = /*#__PURE__*/ __webpack_require__.n(external_os_);
        class ShareUtils {
            static generateShareHtml(events, metadata, staticPath) {
                if (!staticPath) throw new Error('Cannot found static path.');
                const indexPath = external_path_default().join(staticPath, 'index.html');
                if (!external_fs_default().existsSync(indexPath)) throw new Error('Static web ui not found.');
                try {
                    let htmlContent = external_fs_default().readFileSync(indexPath, 'utf8');
                    const safeEventJson = this.safeJsonStringify(events);
                    const safeMetadataJson = this.safeJsonStringify(metadata);
                    const scriptTag = `<script>
        window.AGENT_TARS_REPLAY_MODE = true;
        window.AGENT_TARS_SESSION_DATA = ${safeMetadataJson};
        window.AGENT_TARS_EVENT_STREAM = ${safeEventJson};
      </script>
      <script>
        // Add a fallback mechanism for when routes don't match in shared HTML files
        window.addEventListener('DOMContentLoaded', function() {
          // Give React time to attempt normal routing
          setTimeout(function() {
            const root = document.getElementById('root');
            if (root && (!root.children || root.children.length === 0)) {
              console.log('[ReplayMode] No content rendered, applying fallback');
              // Try to force the app to re-render if no content is displayed
              window.dispatchEvent(new Event('resize'));
            }
          }, 1000);
        });
      </script>`;
                    htmlContent = htmlContent.replace('</head>', `${scriptTag}\n</head>`);
                    return htmlContent;
                } catch (error) {
                    console.error('Failed to generate share HTML:', error);
                    throw new Error(`Failed to generate share HTML: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            static safeJsonStringify(data) {
                let jsonString = JSON.stringify(data);
                jsonString = jsonString.replace(/</g, '\\u003C');
                jsonString = jsonString.replace(/>/g, '\\u003E');
                jsonString = jsonString.replace(/\//g, '\\/');
                return jsonString;
            }
            static async uploadShareHtml(html, sessionId, shareProviderUrl, options) {
                if (!shareProviderUrl) throw new Error('Share provider not configured');
                try {
                    const tempDir = external_path_default().join(external_os_default().tmpdir(), 'agent-tars-share');
                    if (!external_fs_default().existsSync(tempDir)) external_fs_default().mkdirSync(tempDir, {
                        recursive: true
                    });
                    const fileName = `agent-tars-${sessionId}-${Date.now()}.html`;
                    const filePath = external_path_default().join(tempDir, fileName);
                    external_fs_default().writeFileSync(filePath, html);
                    const formData = new FormData();
                    const file = new File([
                        html
                    ], fileName, {
                        type: 'text/html'
                    });
                    formData.append('file', file);
                    formData.append('sessionId', sessionId);
                    if (options) {
                        if (options.slug) formData.append('slug', options.slug);
                        if (options.query) formData.append('query', options.query);
                        if (options.metadata) {
                            formData.append('name', options.metadata.name || '');
                            if (options.metadata.tags && options.metadata.tags.length > 0) formData.append('tags', JSON.stringify(options.metadata.tags));
                        }
                    }
                    const response = await fetch(shareProviderUrl, {
                        method: 'POST',
                        body: formData
                    });
                    external_fs_default().unlinkSync(filePath);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const responseData = await response.json();
                    if (responseData && responseData.url) return responseData.url;
                    throw new Error('Invalid response from share provider');
                } catch (error) {
                    console.error('Failed to upload share HTML:', error);
                    throw error;
                }
            }
        }
        function _define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class SlugGenerator {
            async generateSlug(userMessage) {
                if (!userMessage.trim()) return this.getDefaultSlug();
                try {
                    const llmSlug = await this.generateWithLLM(userMessage);
                    if (llmSlug) return llmSlug;
                } catch (error) {
                    console.warn('LLM slug generation failed, using manual normalization:', error);
                }
                return this.manualNormalization(userMessage);
            }
            async generateWithLLM(userMessage) {
                var _response_choices__message, _response_choices_;
                const response = await this.agent.callLLM({
                    messages: [
                        {
                            role: 'system',
                            content: `You are a URL slug generator. Generate a semantic, URL-friendly slug from the given text.

Requirements:
- Use 3-5 words separated by hyphens
- Use only lowercase English words
- No special characters except hyphens
- Capture the main topic/intent of the text
- Handle multilingual input (Chinese, English, etc.)
- NEVER include non-ASCII characters like Chinese in the output

Return only a JSON object with a "slug" field.`
                        },
                        {
                            role: 'user',
                            content: `Generate a slug for: "${userMessage}"`
                        }
                    ],
                    response_format: {
                        type: 'json_object'
                    },
                    temperature: 0.3,
                    max_tokens: 100
                });
                const content = null == (_response_choices_ = response.choices[0]) ? void 0 : null == (_response_choices__message = _response_choices_.message) ? void 0 : _response_choices__message.content;
                if (!content) return null;
                try {
                    const parsed = JSON.parse(content);
                    return this.manualNormalization(parsed.slug);
                } catch (error) {
                    console.error('Failed to parse LLM slug response:', error);
                    return null;
                }
            }
            manualNormalization(text) {
                const normalized = text.toLowerCase().replace(/[^\x00-\x7F]+/g, '-').replace(/[^\w\s-]/g, '').replace(/\s+/g, '-').replace(/-+/g, '-').substring(0, 60).replace(/^-+|-+$/g, '');
                if (!normalized || 0 === normalized.length) return this.getDefaultSlug();
                const words = normalized.split('-').filter((word)=>word.length > 0);
                return words.slice(0, 4).join('-') || this.getDefaultSlug();
            }
            getDefaultSlug() {
                return 'untitled-session';
            }
            constructor(agent){
                _define_property(this, "agent", void 0);
                this.agent = agent;
            }
        }
        function ShareService_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class ShareService {
            async shareSession(sessionId, upload = false, agent) {
                try {
                    if (!this.storageProvider) throw new Error('Storage not configured, cannot share session');
                    const metadata = await this.storageProvider.getSessionMetadata(sessionId);
                    if (!metadata) throw new Error('Session not found');
                    const events = await this.storageProvider.getSessionEvents(sessionId);
                    const keyFrameEvents = events.filter((event)=>'assistant_streaming_message' !== event.type && 'assistant_streaming_thinking_message' !== event.type && 'final_answer_streaming' !== event.type);
                    const shareHtml = this.generateShareHtml(keyFrameEvents, metadata);
                    if (upload && this.appConfig.share.provider) {
                        const shareUrl = await this.uploadShareHtml(shareHtml, sessionId, metadata, agent);
                        return {
                            success: true,
                            url: shareUrl,
                            sessionId
                        };
                    }
                    return {
                        success: true,
                        html: shareHtml,
                        sessionId
                    };
                } catch (error) {
                    return {
                        success: false,
                        sessionId,
                        error: error instanceof Error ? error.message : String(error)
                    };
                }
            }
            generateShareHtml(events, metadata) {
                if (!this.appConfig.ui.staticPath) throw new Error('Cannot found static path.');
                return ShareUtils.generateShareHtml(events, metadata, this.appConfig.ui.staticPath);
            }
            async uploadShareHtml(html, sessionId, metadata, agent) {
                if (!this.appConfig.share.provider) throw new Error('Share provider not configured');
                let normalizedSlug = '';
                let originalQuery = '';
                if (this.storageProvider && agent) try {
                    const events = await this.storageProvider.getSessionEvents(sessionId);
                    const firstUserMessage = events.find((e)=>'user_message' === e.type);
                    if (firstUserMessage && firstUserMessage.content) {
                        var _firstUserMessage_content_find;
                        originalQuery = 'string' == typeof firstUserMessage.content ? firstUserMessage.content : (null == (_firstUserMessage_content_find = firstUserMessage.content.find((c)=>'text' === c.type)) ? void 0 : _firstUserMessage_content_find.text) || '';
                        if (originalQuery) {
                            const slugGenerator = new SlugGenerator(agent);
                            normalizedSlug = await slugGenerator.generateSlug(originalQuery);
                            normalizedSlug = normalizedSlug.replace(/[^\x00-\x7F]+/g, '').replace(/[^\w-]/g, '');
                        }
                    }
                } catch (error) {
                    console.warn('Failed to extract query for normalized slug:', error);
                }
                normalizedSlug = normalizedSlug ? `${normalizedSlug}-${sessionId}` : sessionId;
                return ShareUtils.uploadShareHtml(html, sessionId, this.appConfig.share.provider, {
                    metadata,
                    slug: normalizedSlug,
                    query: originalQuery
                });
            }
            getShareConfig() {
                var _this_appConfig_share, _this_appConfig_share1;
                return {
                    hasShareProvider: !!(null == (_this_appConfig_share = this.appConfig.share) ? void 0 : _this_appConfig_share.provider),
                    shareProvider: (null == (_this_appConfig_share1 = this.appConfig.share) ? void 0 : _this_appConfig_share1.provider) || null
                };
            }
            constructor(appConfig, storageProvider){
                ShareService_define_property(this, "appConfig", void 0);
                ShareService_define_property(this, "storageProvider", void 0);
                this.appConfig = appConfig;
                this.storageProvider = storageProvider;
            }
        }
    },
    "./src/storage/index.ts": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            E: ()=>createStorageProvider
        });
        function _define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class MemoryStorageProvider {
            async initialize() {}
            async createSession(metadata) {
                this.sessions.set(metadata.id, {
                    ...metadata,
                    createdAt: metadata.createdAt || Date.now(),
                    updatedAt: metadata.updatedAt || Date.now()
                });
                this.events.set(metadata.id, []);
                return this.sessions.get(metadata.id);
            }
            async updateSessionMetadata(sessionId, metadata) {
                const session = this.sessions.get(sessionId);
                if (!session) throw new Error(`Session not found: ${sessionId}`);
                const updatedSession = {
                    ...session,
                    ...metadata,
                    updatedAt: Date.now()
                };
                this.sessions.set(sessionId, updatedSession);
                return updatedSession;
            }
            async getSessionMetadata(sessionId) {
                return this.sessions.get(sessionId) || null;
            }
            async getAllSessions() {
                return Array.from(this.sessions.values());
            }
            async deleteSession(sessionId) {
                const deleted = this.sessions.delete(sessionId);
                this.events.delete(sessionId);
                return deleted;
            }
            async saveEvent(sessionId, event) {
                if (!this.sessions.has(sessionId)) throw new Error(`Session not found: ${sessionId}`);
                const sessionEvents = this.events.get(sessionId) || [];
                sessionEvents.push(event);
                this.events.set(sessionId, sessionEvents);
                await this.updateSessionMetadata(sessionId, {
                    updatedAt: Date.now()
                });
            }
            async getSessionEvents(sessionId) {
                if (!this.sessions.has(sessionId)) throw new Error(`Session not found: ${sessionId}`);
                return this.events.get(sessionId) || [];
            }
            async close() {}
            constructor(){
                _define_property(this, "sessions", new Map());
                _define_property(this, "events", new Map());
            }
        }
        var external_path_ = __webpack_require__("path");
        var external_path_default = /*#__PURE__*/ __webpack_require__.n(external_path_);
        var external_fs_ = __webpack_require__("fs");
        var external_fs_default = /*#__PURE__*/ __webpack_require__.n(external_fs_);
        function checkArgs(adapter, defaultData) {
            if (void 0 === adapter) throw new Error('lowdb: missing adapter');
            if (void 0 === defaultData) throw new Error('lowdb: missing default data');
        }
        class Low_Low {
            adapter;
            data;
            constructor(adapter, defaultData){
                checkArgs(adapter, defaultData);
                this.adapter = adapter;
                this.data = defaultData;
            }
            async read() {
                const data = await this.adapter.read();
                if (data) this.data = data;
            }
            async write() {
                if (this.data) await this.adapter.write(this.data);
            }
        }
        require("node:fs");
        const promises_namespaceObject = require("node:fs/promises");
        const external_node_path_namespaceObject = require("node:path");
        const external_node_url_namespaceObject = require("node:url");
        function getTempFilename(file) {
            const f = file instanceof URL ? (0, external_node_url_namespaceObject.fileURLToPath)(file) : file.toString();
            return (0, external_node_path_namespaceObject.join)((0, external_node_path_namespaceObject.dirname)(f), `.${(0, external_node_path_namespaceObject.basename)(f)}.tmp`);
        }
        class Writer {
            #filename;
            #tempFilename;
            #locked = false;
            #prev = null;
            #next = null;
            #nextPromise = null;
            #nextData = null;
            #add(data) {
                this.#nextData = data;
                this.#nextPromise ||= new Promise((resolve, reject)=>{
                    this.#next = [
                        resolve,
                        reject
                    ];
                });
                return new Promise((resolve, reject)=>{
                    this.#nextPromise?.then(resolve).catch(reject);
                });
            }
            async #write(data) {
                this.#locked = true;
                try {
                    await (0, promises_namespaceObject.writeFile)(this.#tempFilename, data, 'utf-8');
                    await (0, promises_namespaceObject.rename)(this.#tempFilename, this.#filename);
                    this.#prev?.[0]();
                } catch (err) {
                    if (err instanceof Error) this.#prev?.[1](err);
                    throw err;
                } finally{
                    this.#locked = false;
                    this.#prev = this.#next;
                    this.#next = this.#nextPromise = null;
                    if (null !== this.#nextData) {
                        const nextData = this.#nextData;
                        this.#nextData = null;
                        await this.write(nextData);
                    }
                }
            }
            constructor(filename){
                this.#filename = filename;
                this.#tempFilename = getTempFilename(filename);
            }
            async write(data) {
                return this.#locked ? this.#add(data) : this.#write(data);
            }
        }
        class TextFile {
            #filename;
            #writer;
            constructor(filename){
                this.#filename = filename;
                this.#writer = new Writer(filename);
            }
            async read() {
                let data;
                try {
                    data = await promises_namespaceObject.readFile(this.#filename, 'utf-8');
                } catch (e) {
                    if ('ENOENT' === e.code) return null;
                    throw e;
                }
                return data;
            }
            write(str) {
                return this.#writer.write(str);
            }
        }
        class JSONFile_JSONFile {
            #adapter;
            constructor(filename){
                this.#adapter = new TextFile(filename);
            }
            async read() {
                const data = await this.#adapter.read();
                if (null === data) return null;
                return JSON.parse(data);
            }
            write(obj) {
                return this.#adapter.write(JSON.stringify(obj, null, 2));
            }
        }
        function FileStorageProvider_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class FileStorageProvider {
            async initialize() {
                if (!this.initialized) try {
                    await this.db.read();
                    this.db.data = this.db.data || {
                        sessions: {},
                        events: {}
                    };
                    this.initialized = true;
                } catch (error) {
                    this.db.data = {
                        sessions: {},
                        events: {}
                    };
                    await this.db.write();
                    this.initialized = true;
                }
            }
            async createSession(metadata) {
                await this.ensureInitialized();
                const sessionData = {
                    ...metadata,
                    createdAt: metadata.createdAt || Date.now(),
                    updatedAt: metadata.updatedAt || Date.now()
                };
                this.db.data.sessions[metadata.id] = sessionData;
                this.db.data.events[metadata.id] = [];
                await this.db.write();
                return sessionData;
            }
            async updateSessionMetadata(sessionId, metadata) {
                await this.ensureInitialized();
                const session = this.db.data.sessions[sessionId];
                if (!session) throw new Error(`Session not found: ${sessionId}`);
                const updatedSession = {
                    ...session,
                    ...metadata,
                    updatedAt: Date.now()
                };
                this.db.data.sessions[sessionId] = updatedSession;
                await this.db.write();
                return updatedSession;
            }
            async getSessionMetadata(sessionId) {
                await this.ensureInitialized();
                return this.db.data.sessions[sessionId] || null;
            }
            async getAllSessions() {
                await this.ensureInitialized();
                return Object.values(this.db.data.sessions);
            }
            async deleteSession(sessionId) {
                await this.ensureInitialized();
                if (!this.db.data.sessions[sessionId]) return false;
                delete this.db.data.sessions[sessionId];
                delete this.db.data.events[sessionId];
                await this.db.write();
                return true;
            }
            async saveEvent(sessionId, event) {
                await this.ensureInitialized();
                if (!this.db.data.sessions[sessionId]) throw new Error(`Session not found: ${sessionId}`);
                if (!this.db.data.events[sessionId]) this.db.data.events[sessionId] = [];
                this.db.data.events[sessionId].push(event);
                this.db.data.sessions[sessionId].updatedAt = Date.now();
                await this.db.write();
            }
            async getSessionEvents(sessionId) {
                await this.ensureInitialized();
                if (!this.db.data.sessions[sessionId]) throw new Error(`Session not found: ${sessionId}`);
                return this.db.data.events[sessionId] || [];
            }
            async close() {
                if (this.initialized) await this.db.write();
            }
            async ensureInitialized() {
                if (!this.initialized) await this.initialize();
            }
            constructor(storagePath){
                FileStorageProvider_define_property(this, "db", void 0);
                FileStorageProvider_define_property(this, "initialized", false);
                FileStorageProvider_define_property(this, "dbPath", void 0);
                const defaultPath = process.env.HOME || process.env.USERPROFILE || '.';
                const baseDir = storagePath || external_path_default().join(defaultPath, '.agent-tars');
                if (!external_fs_default().existsSync(baseDir)) external_fs_default().mkdirSync(baseDir, {
                    recursive: true
                });
                this.dbPath = external_path_default().join(baseDir, 'storage.json');
                const adapter = new JSONFile_JSONFile(this.dbPath);
                this.db = new Low_Low(adapter, {
                    sessions: {},
                    events: {}
                });
            }
        }
        const external_node_sqlite_namespaceObject = require("node:sqlite");
        function SQLiteStorageProvider_define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class SQLiteStorageProvider {
            async initialize() {
                if (!this.initialized) try {
                    this.db.open();
                    this.db.exec('PRAGMA journal_mode = WAL');
                    this.db.exec(`
          CREATE TABLE IF NOT EXISTS sessions (
            id TEXT PRIMARY KEY,
            createdAt INTEGER NOT NULL,
            updatedAt INTEGER NOT NULL,
            name TEXT,
            workingDirectory TEXT NOT NULL,
            tags TEXT
          )
        `);
                    this.db.exec(`
          CREATE TABLE IF NOT EXISTS events (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            sessionId TEXT NOT NULL,
            timestamp INTEGER NOT NULL,
            eventData TEXT NOT NULL,
            FOREIGN KEY (sessionId) REFERENCES sessions (id) ON DELETE CASCADE
          )
        `);
                    this.db.exec(`
          CREATE INDEX IF NOT EXISTS idx_events_sessionId ON events (sessionId)
        `);
                    this.db.exec('PRAGMA foreign_keys = ON');
                    this.initialized = true;
                } catch (error) {
                    console.error('Failed to initialize SQLite database:', error);
                    throw error;
                }
            }
            async createSession(metadata) {
                await this.ensureInitialized();
                const sessionData = {
                    ...metadata,
                    createdAt: metadata.createdAt || Date.now(),
                    updatedAt: metadata.updatedAt || Date.now()
                };
                const tagsJson = sessionData.tags ? JSON.stringify(sessionData.tags) : null;
                try {
                    const stmt = this.db.prepare(`
        INSERT INTO sessions (id, createdAt, updatedAt, name, workingDirectory, tags)
        VALUES (?, ?, ?, ?, ?, ?)
      `);
                    stmt.run(sessionData.id, sessionData.createdAt, sessionData.updatedAt, sessionData.name || null, sessionData.workingDirectory, tagsJson);
                    return sessionData;
                } catch (error) {
                    console.error(`Failed to create session ${sessionData.id}:`, error);
                    throw new Error(`Failed to create session: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            async updateSessionMetadata(sessionId, metadata) {
                await this.ensureInitialized();
                const session = await this.getSessionMetadata(sessionId);
                if (!session) throw new Error(`Session not found: ${sessionId}`);
                const updatedSession = {
                    ...session,
                    ...metadata,
                    updatedAt: Date.now()
                };
                try {
                    const params = [];
                    const setClauses = [];
                    if (void 0 !== metadata.name) {
                        setClauses.push('name = ?');
                        params.push(metadata.name || null);
                    }
                    if (void 0 !== metadata.workingDirectory) {
                        setClauses.push('workingDirectory = ?');
                        params.push(metadata.workingDirectory);
                    }
                    if (void 0 !== metadata.tags) {
                        setClauses.push('tags = ?');
                        params.push(metadata.tags ? JSON.stringify(metadata.tags) : null);
                    }
                    setClauses.push('updatedAt = ?');
                    params.push(updatedSession.updatedAt);
                    params.push(sessionId);
                    if (0 === setClauses.length) return updatedSession;
                    const updateQuery = `
        UPDATE sessions
        SET ${setClauses.join(', ')}
        WHERE id = ?
      `;
                    const updateStmt = this.db.prepare(updateQuery);
                    updateStmt.run(...params);
                    return updatedSession;
                } catch (error) {
                    console.error(`Failed to update session ${sessionId}:`, error);
                    throw new Error(`Failed to update session: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            async getSessionMetadata(sessionId) {
                await this.ensureInitialized();
                try {
                    const stmt = this.db.prepare(`
        SELECT id, createdAt, updatedAt, name, workingDirectory, tags
        FROM sessions
        WHERE id = ?
      `);
                    const row = stmt.get(sessionId);
                    if (!row) return null;
                    return {
                        id: row.id,
                        createdAt: row.createdAt,
                        updatedAt: row.updatedAt,
                        name: row.name || void 0,
                        workingDirectory: row.workingDirectory,
                        tags: row.tags ? JSON.parse(row.tags) : void 0
                    };
                } catch (error) {
                    console.error(`Failed to get session ${sessionId}:`, error);
                    throw new Error(`Failed to get session: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            async getAllSessions() {
                await this.ensureInitialized();
                try {
                    const stmt = this.db.prepare(`
        SELECT id, createdAt, updatedAt, name, workingDirectory, tags
        FROM sessions
        ORDER BY updatedAt DESC
      `);
                    const rows = stmt.all();
                    return rows.map((row)=>({
                            id: row.id,
                            createdAt: row.createdAt,
                            updatedAt: row.updatedAt,
                            name: row.name || void 0,
                            workingDirectory: row.workingDirectory,
                            tags: row.tags ? JSON.parse(row.tags) : void 0
                        }));
                } catch (error) {
                    console.error('Failed to get all sessions:', error);
                    throw new Error(`Failed to get all sessions: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            async deleteSession(sessionId) {
                await this.ensureInitialized();
                try {
                    const deleteEventsStmt = this.db.prepare('DELETE FROM events WHERE sessionId = ?');
                    deleteEventsStmt.run(sessionId);
                    const deleteSessionStmt = this.db.prepare('DELETE FROM sessions WHERE id = ?');
                    const result = deleteSessionStmt.run(sessionId);
                    return result.changes > 0;
                } catch (error) {
                    console.error(`Failed to delete session ${sessionId}:`, error);
                    throw new Error(`Failed to delete session: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            async saveEvent(sessionId, event) {
                await this.ensureInitialized();
                try {
                    const sessionExistsStmt = this.db.prepare(`
        SELECT 1 as existsFlag FROM sessions WHERE id = ?
      `);
                    const sessionExists = sessionExistsStmt.get(sessionId);
                    if (!sessionExists || !sessionExists.existsFlag) throw new Error(`Session not found: ${sessionId}`);
                    const timestamp = Date.now();
                    const eventData = JSON.stringify(event);
                    const insertEventStmt = this.db.prepare(`
        INSERT INTO events (sessionId, timestamp, eventData)
        VALUES (?, ?, ?)
      `);
                    insertEventStmt.run(sessionId, timestamp, eventData);
                    const updateSessionStmt = this.db.prepare(`
        UPDATE sessions SET updatedAt = ? WHERE id = ?
      `);
                    updateSessionStmt.run(timestamp, sessionId);
                } catch (error) {
                    console.error(`Failed to save event for session ${sessionId}:`, error);
                    throw new Error(`Failed to save event: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            async getSessionEvents(sessionId) {
                await this.ensureInitialized();
                try {
                    const sessionExistsStmt = this.db.prepare(`
        SELECT 1 as existsFlag FROM sessions WHERE id = ?
      `);
                    const sessionExists = sessionExistsStmt.get(sessionId);
                    if (!sessionExists || !sessionExists.existsFlag) throw new Error(`Session not found: ${sessionId}`);
                    const stmt = this.db.prepare(`
        SELECT eventData
        FROM events
        WHERE sessionId = ?
        ORDER BY timestamp ASC, id ASC
      `);
                    const rows = stmt.all(sessionId);
                    return rows.map((row)=>{
                        try {
                            return JSON.parse(row.eventData);
                        } catch (error) {
                            console.error(`Failed to parse event data: ${row.eventData}`);
                            return {
                                type: 'system',
                                message: 'Failed to parse event data',
                                timestamp: Date.now()
                            };
                        }
                    });
                } catch (error) {
                    console.error(`Failed to get events for session ${sessionId}:`, error);
                    throw new Error(`Failed to get session events: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            async close() {
                if (this.db && this.db.isOpen) this.db.close();
            }
            async ensureInitialized() {
                if (!this.initialized) await this.initialize();
            }
            constructor(storagePath){
                SQLiteStorageProvider_define_property(this, "db", void 0);
                SQLiteStorageProvider_define_property(this, "initialized", false);
                SQLiteStorageProvider_define_property(this, "dbPath", void 0);
                const defaultPath = process.env.HOME || process.env.USERPROFILE || '.';
                const baseDir = storagePath || external_path_default().join(defaultPath, '.agent-tars');
                if (!external_fs_default().existsSync(baseDir)) external_fs_default().mkdirSync(baseDir, {
                    recursive: true
                });
                this.dbPath = external_path_default().join(baseDir, 'agent-tars.db');
                this.db = new external_node_sqlite_namespaceObject.DatabaseSync(this.dbPath, {
                    open: false
                });
            }
        }
        function createStorageProvider(options) {
            if (!options || 'memory' === options.type) return new MemoryStorageProvider();
            if ('file' === options.type) return new FileStorageProvider(options.path);
            if ('sqlite' === options.type) return new SQLiteStorageProvider(options.path);
            if ('database' === options.type) throw new Error('Database storage not implemented');
            throw new Error(`Unknown storage type: ${options.type}`);
        }
    },
    "./src/types.ts": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var _agent_tars_interface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../agent-tars-interface/dist/index.mjs");
        var __WEBPACK_REEXPORT_OBJECT__ = {};
        for(var __WEBPACK_IMPORT_KEY__ in _agent_tars_interface__WEBPACK_IMPORTED_MODULE_0__)if ("default" !== __WEBPACK_IMPORT_KEY__) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = (function(key) {
            return _agent_tars_interface__WEBPACK_IMPORTED_MODULE_0__[key];
        }).bind(0, __WEBPACK_IMPORT_KEY__);
        __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
    },
    "./src/utils/error-handler.ts": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            G8: ()=>ErrorWithCode,
            jl: ()=>createErrorResponse,
            rB: ()=>handleAgentError
        });
        function _define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class ErrorWithCode extends Error {
            constructor(message, code, details){
                super(message), _define_property(this, "code", void 0), _define_property(this, "details", void 0), this.code = code, this.details = details;
                this.name = 'AgentTARSError';
            }
        }
        function handleAgentError(error, context) {
            console.error(`Agent error${context ? ` [${context}]` : ''}:`, error);
            if (error instanceof ErrorWithCode) return error;
            if (error instanceof Error) return new ErrorWithCode(error.message, 'AGENT_EXECUTION_ERROR', {
                stack: error.stack
            });
            return new ErrorWithCode('string' == typeof error ? error : 'Unknown agent execution error', 'UNKNOWN_ERROR', {
                originalError: error
            });
        }
        function createErrorResponse(error) {
            const normalizedError = handleAgentError(error);
            return {
                success: false,
                error: {
                    code: normalizedError.code,
                    message: normalizedError.message,
                    details: normalizedError.details
                }
            };
        }
    },
    "./src/utils/index.ts": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            G8: ()=>_error_handler__WEBPACK_IMPORTED_MODULE_1__.G8,
            jl: ()=>_error_handler__WEBPACK_IMPORTED_MODULE_1__.jl,
            rB: ()=>_error_handler__WEBPACK_IMPORTED_MODULE_1__.rB,
            st: ()=>_workspace__WEBPACK_IMPORTED_MODULE_0__.s
        });
        var _workspace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/workspace.ts");
        var _error_handler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/error-handler.ts");
    },
    "./src/utils/workspace.ts": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            s: ()=>ensureWorkingDirectory
        });
        var external_fs_ = __webpack_require__("fs");
        var external_fs_default = /*#__PURE__*/ __webpack_require__.n(external_fs_);
        var external_path_ = __webpack_require__("path");
        var external_path_default = /*#__PURE__*/ __webpack_require__.n(external_path_);
        var external_os_ = __webpack_require__("os");
        var external_os_default = /*#__PURE__*/ __webpack_require__.n(external_os_);
        function _define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class WorkspacePathManager {
            static resolveWorkspacePath(baseDir, workspacePath, namespace, isolateSessions) {
                let resolvedPath;
                resolvedPath = workspacePath ? workspacePath.startsWith('~') ? workspacePath.replace(/^~/, external_os_default().homedir()) : external_path_default().isAbsolute(workspacePath) ? workspacePath : external_path_default().resolve(baseDir, workspacePath) : external_path_default().join(baseDir, this.DEFAULT_WORKSPACE_DIR);
                if (isolateSessions && namespace) resolvedPath = external_path_default().join(resolvedPath, namespace);
                return resolvedPath;
            }
            static ensureWorkspaceDirectory(workspacePath) {
                try {
                    external_fs_default().mkdirSync(workspacePath, {
                        recursive: true
                    });
                    return workspacePath;
                } catch (error) {
                    throw new Error(`Failed to create workspace directory ${workspacePath}: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
        }
        _define_property(WorkspacePathManager, "DEFAULT_WORKSPACE_DIR", 'agent-tars-workspace');
        function ensureWorkingDirectory(namespace, workspacePath, isolateSessions = false, isDebug = false) {
            try {
                const baseDir = process.cwd();
                const resolvedPath = WorkspacePathManager.resolveWorkspacePath(baseDir, workspacePath, namespace, isolateSessions);
                const workingDirectory = WorkspacePathManager.ensureWorkspaceDirectory(resolvedPath);
                if (isDebug) console.log(`Created or verified working directory: ${workingDirectory}`);
                return workingDirectory;
            } catch (error) {
                console.error("Failed to create working directory:", error);
                throw new Error(`Failed to initialize agent workspace: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    },
    "../mcp-agent-interface/dist/index.mjs": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            i: ()=>_multimodal_agent_interface__WEBPACK_IMPORTED_MODULE_0__.LogLevel
        });
        var _multimodal_agent_interface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../agent-interface/dist/index.mjs");
    },
    "@agent-tars/core": function(module) {
        "use strict";
        module.exports = require("@agent-tars/core");
    },
    async_hooks: function(module) {
        "use strict";
        module.exports = require("async_hooks");
    },
    buffer: function(module) {
        "use strict";
        module.exports = require("buffer");
    },
    crypto: function(module) {
        "use strict";
        module.exports = require("crypto");
    },
    events: function(module) {
        "use strict";
        module.exports = require("events");
    },
    fs: function(module) {
        "use strict";
        module.exports = require("fs");
    },
    http: function(module) {
        "use strict";
        module.exports = require("http");
    },
    https: function(module) {
        "use strict";
        module.exports = require("https");
    },
    net: function(module) {
        "use strict";
        module.exports = require("net");
    },
    os: function(module) {
        "use strict";
        module.exports = require("os");
    },
    path: function(module) {
        "use strict";
        module.exports = require("path");
    },
    querystring: function(module) {
        "use strict";
        module.exports = require("querystring");
    },
    stream: function(module) {
        "use strict";
        module.exports = require("stream");
    },
    string_decoder: function(module) {
        "use strict";
        module.exports = require("string_decoder");
    },
    timers: function(module) {
        "use strict";
        module.exports = require("timers");
    },
    tls: function(module) {
        "use strict";
        module.exports = require("tls");
    },
    tty: function(module) {
        "use strict";
        module.exports = require("tty");
    },
    url: function(module) {
        "use strict";
        module.exports = require("url");
    },
    util: function(module) {
        "use strict";
        module.exports = require("util");
    },
    zlib: function(module) {
        "use strict";
        module.exports = require("zlib");
    },
    "../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/commons.js": function(__unused_webpack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.ERROR_PACKET = exports1.PACKET_TYPES_REVERSE = exports1.PACKET_TYPES = void 0;
        const PACKET_TYPES = Object.create(null);
        exports1.PACKET_TYPES = PACKET_TYPES;
        PACKET_TYPES["open"] = "0";
        PACKET_TYPES["close"] = "1";
        PACKET_TYPES["ping"] = "2";
        PACKET_TYPES["pong"] = "3";
        PACKET_TYPES["message"] = "4";
        PACKET_TYPES["upgrade"] = "5";
        PACKET_TYPES["noop"] = "6";
        const PACKET_TYPES_REVERSE = Object.create(null);
        exports1.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
        Object.keys(PACKET_TYPES).forEach((key)=>{
            PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
        });
        const ERROR_PACKET = {
            type: "error",
            data: "parser error"
        };
        exports1.ERROR_PACKET = ERROR_PACKET;
    },
    "../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/decodePacket.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.decodePacket = void 0;
        const commons_js_1 = __webpack_require__("../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/commons.js");
        const decodePacket = (encodedPacket, binaryType)=>{
            if ("string" != typeof encodedPacket) return {
                type: "message",
                data: mapBinary(encodedPacket, binaryType)
            };
            const type = encodedPacket.charAt(0);
            if ("b" === type) {
                const buffer = Buffer.from(encodedPacket.substring(1), "base64");
                return {
                    type: "message",
                    data: mapBinary(buffer, binaryType)
                };
            }
            if (!commons_js_1.PACKET_TYPES_REVERSE[type]) return commons_js_1.ERROR_PACKET;
            return encodedPacket.length > 1 ? {
                type: commons_js_1.PACKET_TYPES_REVERSE[type],
                data: encodedPacket.substring(1)
            } : {
                type: commons_js_1.PACKET_TYPES_REVERSE[type]
            };
        };
        exports1.decodePacket = decodePacket;
        const mapBinary = (data, binaryType)=>{
            switch(binaryType){
                case "arraybuffer":
                    if (data instanceof ArrayBuffer) return data;
                    if (Buffer.isBuffer(data)) return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
                    return data.buffer;
                case "nodebuffer":
                default:
                    if (Buffer.isBuffer(data)) return data;
                    return Buffer.from(data);
            }
        };
    },
    "../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/encodePacket.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.encodePacket = void 0;
        exports1.encodePacketToBinary = encodePacketToBinary;
        const commons_js_1 = __webpack_require__("../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/commons.js");
        const encodePacket = ({ type, data }, supportsBinary, callback)=>{
            if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) return callback(supportsBinary ? data : "b" + toBuffer(data, true).toString("base64"));
            return callback(commons_js_1.PACKET_TYPES[type] + (data || ""));
        };
        exports1.encodePacket = encodePacket;
        const toBuffer = (data, forceBufferConversion)=>{
            if (Buffer.isBuffer(data) || data instanceof Uint8Array && !forceBufferConversion) return data;
            if (data instanceof ArrayBuffer) return Buffer.from(data);
            return Buffer.from(data.buffer, data.byteOffset, data.byteLength);
        };
        let TEXT_ENCODER;
        function encodePacketToBinary(packet, callback) {
            if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) return callback(toBuffer(packet.data, false));
            (0, exports1.encodePacket)(packet, true, (encoded)=>{
                if (!TEXT_ENCODER) TEXT_ENCODER = new TextEncoder();
                callback(TEXT_ENCODER.encode(encoded));
            });
        }
    },
    "../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.decodePayload = exports1.decodePacket = exports1.encodePayload = exports1.encodePacket = exports1.protocol = void 0;
        exports1.createPacketEncoderStream = createPacketEncoderStream;
        exports1.createPacketDecoderStream = createPacketDecoderStream;
        const encodePacket_js_1 = __webpack_require__("../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/encodePacket.js");
        Object.defineProperty(exports1, "encodePacket", {
            enumerable: true,
            get: function() {
                return encodePacket_js_1.encodePacket;
            }
        });
        const decodePacket_js_1 = __webpack_require__("../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/decodePacket.js");
        Object.defineProperty(exports1, "decodePacket", {
            enumerable: true,
            get: function() {
                return decodePacket_js_1.decodePacket;
            }
        });
        const commons_js_1 = __webpack_require__("../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/commons.js");
        const SEPARATOR = String.fromCharCode(30);
        const encodePayload = (packets, callback)=>{
            const length = packets.length;
            const encodedPackets = new Array(length);
            let count = 0;
            packets.forEach((packet, i)=>{
                (0, encodePacket_js_1.encodePacket)(packet, false, (encodedPacket)=>{
                    encodedPackets[i] = encodedPacket;
                    if (++count === length) callback(encodedPackets.join(SEPARATOR));
                });
            });
        };
        exports1.encodePayload = encodePayload;
        const decodePayload = (encodedPayload, binaryType)=>{
            const encodedPackets = encodedPayload.split(SEPARATOR);
            const packets = [];
            for(let i = 0; i < encodedPackets.length; i++){
                const decodedPacket = (0, decodePacket_js_1.decodePacket)(encodedPackets[i], binaryType);
                packets.push(decodedPacket);
                if ("error" === decodedPacket.type) break;
            }
            return packets;
        };
        exports1.decodePayload = decodePayload;
        function createPacketEncoderStream() {
            return new TransformStream({
                transform (packet, controller) {
                    (0, encodePacket_js_1.encodePacketToBinary)(packet, (encodedPacket)=>{
                        const payloadLength = encodedPacket.length;
                        let header;
                        if (payloadLength < 126) {
                            header = new Uint8Array(1);
                            new DataView(header.buffer).setUint8(0, payloadLength);
                        } else if (payloadLength < 65536) {
                            header = new Uint8Array(3);
                            const view = new DataView(header.buffer);
                            view.setUint8(0, 126);
                            view.setUint16(1, payloadLength);
                        } else {
                            header = new Uint8Array(9);
                            const view = new DataView(header.buffer);
                            view.setUint8(0, 127);
                            view.setBigUint64(1, BigInt(payloadLength));
                        }
                        if (packet.data && "string" != typeof packet.data) header[0] |= 0x80;
                        controller.enqueue(header);
                        controller.enqueue(encodedPacket);
                    });
                }
            });
        }
        let TEXT_DECODER;
        function totalLength(chunks) {
            return chunks.reduce((acc, chunk)=>acc + chunk.length, 0);
        }
        function concatChunks(chunks, size) {
            if (chunks[0].length === size) return chunks.shift();
            const buffer = new Uint8Array(size);
            let j = 0;
            for(let i = 0; i < size; i++){
                buffer[i] = chunks[0][j++];
                if (j === chunks[0].length) {
                    chunks.shift();
                    j = 0;
                }
            }
            if (chunks.length && j < chunks[0].length) chunks[0] = chunks[0].slice(j);
            return buffer;
        }
        function createPacketDecoderStream(maxPayload, binaryType) {
            if (!TEXT_DECODER) TEXT_DECODER = new TextDecoder();
            const chunks = [];
            let state = 0;
            let expectedLength = -1;
            let isBinary = false;
            return new TransformStream({
                transform (chunk, controller) {
                    chunks.push(chunk);
                    while(true){
                        if (0 === state) {
                            if (totalLength(chunks) < 1) break;
                            const header = concatChunks(chunks, 1);
                            isBinary = (0x80 & header[0]) === 0x80;
                            expectedLength = 0x7f & header[0];
                            state = expectedLength < 126 ? 3 : 126 === expectedLength ? 1 : 2;
                        } else if (1 === state) {
                            if (totalLength(chunks) < 2) break;
                            const headerArray = concatChunks(chunks, 2);
                            expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
                            state = 3;
                        } else if (2 === state) {
                            if (totalLength(chunks) < 8) break;
                            const headerArray = concatChunks(chunks, 8);
                            const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
                            const n = view.getUint32(0);
                            if (n > Math.pow(2, 21) - 1) {
                                controller.enqueue(commons_js_1.ERROR_PACKET);
                                break;
                            }
                            expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
                            state = 3;
                        } else {
                            if (totalLength(chunks) < expectedLength) break;
                            const data = concatChunks(chunks, expectedLength);
                            controller.enqueue((0, decodePacket_js_1.decodePacket)(isBinary ? data : TEXT_DECODER.decode(data), binaryType));
                            state = 0;
                        }
                        if (0 === expectedLength || expectedLength > maxPayload) {
                            controller.enqueue(commons_js_1.ERROR_PACKET);
                            break;
                        }
                    }
                }
            });
        }
        exports1.protocol = 4;
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/engine.io.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.protocol = exports1.Transport = exports1.Socket = exports1.uServer = exports1.parser = exports1.transports = exports1.Server = void 0;
        exports1.listen = listen;
        exports1.attach = attach;
        const http_1 = __webpack_require__("http");
        const server_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/server.js");
        Object.defineProperty(exports1, "Server", {
            enumerable: true,
            get: function() {
                return server_1.Server;
            }
        });
        const index_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/index.js");
        exports1.transports = index_1.default;
        const parser = __webpack_require__("../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/index.js");
        exports1.parser = parser;
        var userver_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/userver.js");
        Object.defineProperty(exports1, "uServer", {
            enumerable: true,
            get: function() {
                return userver_1.uServer;
            }
        });
        var socket_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/socket.js");
        Object.defineProperty(exports1, "Socket", {
            enumerable: true,
            get: function() {
                return socket_1.Socket;
            }
        });
        var transport_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transport.js");
        Object.defineProperty(exports1, "Transport", {
            enumerable: true,
            get: function() {
                return transport_1.Transport;
            }
        });
        exports1.protocol = parser.protocol;
        function listen(port, options, fn) {
            if ("function" == typeof options) {
                fn = options;
                options = {};
            }
            const server = (0, http_1.createServer)(function(req, res) {
                res.writeHead(501);
                res.end("Not Implemented");
            });
            const engine = attach(server, options);
            engine.httpServer = server;
            server.listen(port, fn);
            return engine;
        }
        function attach(server, options) {
            const engine = new server_1.Server(options);
            engine.attach(server, options);
            return engine;
        }
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/parser-v3/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.packets = exports1.protocol = void 0;
        exports1.encodePacket = encodePacket;
        exports1.encodeBase64Packet = encodeBase64Packet;
        exports1.decodePacket = decodePacket;
        exports1.decodeBase64Packet = decodeBase64Packet;
        exports1.encodePayload = encodePayload;
        exports1.decodePayload = decodePayload;
        exports1.encodePayloadAsBinary = encodePayloadAsBinary;
        exports1.decodePayloadAsBinary = decodePayloadAsBinary;
        var utf8 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/parser-v3/utf8.js");
        exports1.protocol = 3;
        const hasBinary = (packets)=>{
            for (const packet of packets)if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) return true;
            return false;
        };
        exports1.packets = {
            open: 0,
            close: 1,
            ping: 2,
            pong: 3,
            message: 4,
            upgrade: 5,
            noop: 6
        };
        var packetslist = Object.keys(exports1.packets);
        var err = {
            type: 'error',
            data: 'parser error'
        };
        const EMPTY_BUFFER = Buffer.concat([]);
        function encodePacket(packet, supportsBinary, utf8encode, callback) {
            if ('function' == typeof supportsBinary) {
                callback = supportsBinary;
                supportsBinary = null;
            }
            if ('function' == typeof utf8encode) {
                callback = utf8encode;
                utf8encode = null;
            }
            if (Buffer.isBuffer(packet.data)) return encodeBuffer(packet, supportsBinary, callback);
            if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) return encodeBuffer({
                type: packet.type,
                data: arrayBufferToBuffer(packet.data)
            }, supportsBinary, callback);
            var encoded = exports1.packets[packet.type];
            if (void 0 !== packet.data) encoded += utf8encode ? utf8.encode(String(packet.data), {
                strict: false
            }) : String(packet.data);
            return callback('' + encoded);
        }
        function encodeBuffer(packet, supportsBinary, callback) {
            if (!supportsBinary) return encodeBase64Packet(packet, callback);
            var data = packet.data;
            var typeBuffer = Buffer.allocUnsafe(1);
            typeBuffer[0] = exports1.packets[packet.type];
            return callback(Buffer.concat([
                typeBuffer,
                data
            ]));
        }
        function encodeBase64Packet(packet, callback) {
            var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);
            var message = 'b' + exports1.packets[packet.type];
            message += data.toString('base64');
            return callback(message);
        }
        function decodePacket(data, binaryType, utf8decode) {
            if (void 0 === data) return err;
            var type;
            if ('string' == typeof data) {
                type = data.charAt(0);
                if ('b' === type) return decodeBase64Packet(data.slice(1), binaryType);
                if (utf8decode) {
                    data = tryDecode(data);
                    if (false === data) return err;
                }
                if (Number(type) != type || !packetslist[type]) return err;
                if (data.length > 1) return {
                    type: packetslist[type],
                    data: data.slice(1)
                };
                return {
                    type: packetslist[type]
                };
            }
            if ('arraybuffer' === binaryType) {
                var intArray = new Uint8Array(data);
                type = intArray[0];
                return {
                    type: packetslist[type],
                    data: intArray.buffer.slice(1)
                };
            }
            if (data instanceof ArrayBuffer) data = arrayBufferToBuffer(data);
            type = data[0];
            return {
                type: packetslist[type],
                data: data.slice(1)
            };
        }
        function tryDecode(data) {
            try {
                data = utf8.decode(data, {
                    strict: false
                });
            } catch (e) {
                return false;
            }
            return data;
        }
        function decodeBase64Packet(msg, binaryType) {
            var type = packetslist[msg.charAt(0)];
            var data = Buffer.from(msg.slice(1), 'base64');
            if ('arraybuffer' === binaryType) {
                var abv = new Uint8Array(data.length);
                for(var i = 0; i < abv.length; i++)abv[i] = data[i];
                data = abv.buffer;
            }
            return {
                type: type,
                data: data
            };
        }
        function encodePayload(packets, supportsBinary, callback) {
            if ('function' == typeof supportsBinary) {
                callback = supportsBinary;
                supportsBinary = null;
            }
            if (supportsBinary && hasBinary(packets)) return encodePayloadAsBinary(packets, callback);
            if (!packets.length) return callback('0:');
            function encodeOne(packet, doneCallback) {
                encodePacket(packet, supportsBinary, false, function(message) {
                    doneCallback(null, setLengthHeader(message));
                });
            }
            map(packets, encodeOne, function(err, results) {
                return callback(results.join(''));
            });
        }
        function setLengthHeader(message) {
            return message.length + ':' + message;
        }
        function map(ary, each, done) {
            const results = new Array(ary.length);
            let count = 0;
            for(let i = 0; i < ary.length; i++)each(ary[i], (error, msg)=>{
                results[i] = msg;
                if (++count === ary.length) done(null, results);
            });
        }
        function decodePayload(data, binaryType, callback) {
            if ('string' != typeof data) return decodePayloadAsBinary(data, binaryType, callback);
            if ('function' == typeof binaryType) {
                callback = binaryType;
                binaryType = null;
            }
            if ('' === data) return callback(err, 0, 1);
            var length = '', n, msg, packet;
            for(var i = 0, l = data.length; i < l; i++){
                var chr = data.charAt(i);
                if (':' !== chr) {
                    length += chr;
                    continue;
                }
                if ('' === length || length != (n = Number(length))) return callback(err, 0, 1);
                msg = data.slice(i + 1, i + 1 + n);
                if (length != msg.length) return callback(err, 0, 1);
                if (msg.length) {
                    packet = decodePacket(msg, binaryType, false);
                    if (err.type === packet.type && err.data === packet.data) return callback(err, 0, 1);
                    var more = callback(packet, i + n, l);
                    if (false === more) return;
                }
                i += n;
                length = '';
            }
            if ('' !== length) return callback(err, 0, 1);
        }
        function bufferToString(buffer) {
            var str = '';
            for(var i = 0, l = buffer.length; i < l; i++)str += String.fromCharCode(buffer[i]);
            return str;
        }
        function stringToBuffer(string) {
            var buf = Buffer.allocUnsafe(string.length);
            for(var i = 0, l = string.length; i < l; i++)buf.writeUInt8(string.charCodeAt(i), i);
            return buf;
        }
        function arrayBufferToBuffer(data) {
            var length = data.byteLength || data.length;
            var offset = data.byteOffset || 0;
            return Buffer.from(data.buffer || data, offset, length);
        }
        function encodePayloadAsBinary(packets, callback) {
            if (!packets.length) return callback(EMPTY_BUFFER);
            map(packets, encodeOneBinaryPacket, function(err, results) {
                return callback(Buffer.concat(results));
            });
        }
        function encodeOneBinaryPacket(p, doneCallback) {
            function onBinaryPacketEncode(packet) {
                var encodingLength = '' + packet.length;
                var sizeBuffer;
                if ('string' == typeof packet) {
                    sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
                    sizeBuffer[0] = 0;
                    for(var i = 0; i < encodingLength.length; i++)sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
                    sizeBuffer[sizeBuffer.length - 1] = 255;
                    return doneCallback(null, Buffer.concat([
                        sizeBuffer,
                        stringToBuffer(packet)
                    ]));
                }
                sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
                sizeBuffer[0] = 1;
                for(var i = 0; i < encodingLength.length; i++)sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
                sizeBuffer[sizeBuffer.length - 1] = 255;
                doneCallback(null, Buffer.concat([
                    sizeBuffer,
                    packet
                ]));
            }
            encodePacket(p, true, true, onBinaryPacketEncode);
        }
        function decodePayloadAsBinary(data, binaryType, callback) {
            if ('function' == typeof binaryType) {
                callback = binaryType;
                binaryType = null;
            }
            var bufferTail = data;
            var buffers = [];
            var i;
            while(bufferTail.length > 0){
                var strLen = '';
                var isString = 0 === bufferTail[0];
                for(i = 1;; i++){
                    if (255 === bufferTail[i]) break;
                    if (strLen.length > 310) return callback(err, 0, 1);
                    strLen += '' + bufferTail[i];
                }
                bufferTail = bufferTail.slice(strLen.length + 1);
                var msgLength = parseInt(strLen, 10);
                var msg = bufferTail.slice(1, msgLength + 1);
                if (isString) msg = bufferToString(msg);
                buffers.push(msg);
                bufferTail = bufferTail.slice(msgLength + 1);
            }
            var total = buffers.length;
            for(i = 0; i < total; i++){
                var buffer = buffers[i];
                callback(decodePacket(buffer, binaryType, true), i, total);
            }
        }
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/parser-v3/utf8.js": function(module) {
        /*! https://mths.be/utf8js v2.1.2 by @mathias */ var stringFromCharCode = String.fromCharCode;
        function ucs2decode(string) {
            var output = [];
            var counter = 0;
            var length = string.length;
            var value;
            var extra;
            while(counter < length){
                value = string.charCodeAt(counter++);
                if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                    extra = string.charCodeAt(counter++);
                    if ((0xFC00 & extra) == 0xDC00) output.push(((0x3FF & value) << 10) + (0x3FF & extra) + 0x10000);
                    else {
                        output.push(value);
                        counter--;
                    }
                } else output.push(value);
            }
            return output;
        }
        function ucs2encode(array) {
            var length = array.length;
            var index = -1;
            var value;
            var output = '';
            while(++index < length){
                value = array[index];
                if (value > 0xFFFF) {
                    value -= 0x10000;
                    output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                    value = 0xDC00 | 0x3FF & value;
                }
                output += stringFromCharCode(value);
            }
            return output;
        }
        function checkScalarValue(codePoint, strict) {
            if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
                if (strict) throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
                return false;
            }
            return true;
        }
        function createByte(codePoint, shift) {
            return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);
        }
        function encodeCodePoint(codePoint, strict) {
            if ((0xFFFFFF80 & codePoint) == 0) return stringFromCharCode(codePoint);
            var symbol = '';
            if ((0xFFFFF800 & codePoint) == 0) symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);
            else if ((0xFFFF0000 & codePoint) == 0) {
                if (!checkScalarValue(codePoint, strict)) codePoint = 0xFFFD;
                symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);
                symbol += createByte(codePoint, 6);
            } else if ((0xFFE00000 & codePoint) == 0) {
                symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);
                symbol += createByte(codePoint, 12);
                symbol += createByte(codePoint, 6);
            }
            symbol += stringFromCharCode(0x3F & codePoint | 0x80);
            return symbol;
        }
        function utf8encode(string, opts) {
            opts = opts || {};
            var strict = false !== opts.strict;
            var codePoints = ucs2decode(string);
            var length = codePoints.length;
            var index = -1;
            var codePoint;
            var byteString = '';
            while(++index < length){
                codePoint = codePoints[index];
                byteString += encodeCodePoint(codePoint, strict);
            }
            return byteString;
        }
        function readContinuationByte() {
            if (byteIndex >= byteCount) throw Error('Invalid byte index');
            var continuationByte = 0xFF & byteArray[byteIndex];
            byteIndex++;
            if ((0xC0 & continuationByte) == 0x80) return 0x3F & continuationByte;
            throw Error('Invalid continuation byte');
        }
        function decodeSymbol(strict) {
            var byte1;
            var byte2;
            var byte3;
            var byte4;
            var codePoint;
            if (byteIndex > byteCount) throw Error('Invalid byte index');
            if (byteIndex == byteCount) return false;
            byte1 = 0xFF & byteArray[byteIndex];
            byteIndex++;
            if ((0x80 & byte1) == 0) return byte1;
            if ((0xE0 & byte1) == 0xC0) {
                byte2 = readContinuationByte();
                codePoint = (0x1F & byte1) << 6 | byte2;
                if (codePoint >= 0x80) return codePoint;
                throw Error('Invalid continuation byte');
            }
            if ((0xF0 & byte1) == 0xE0) {
                byte2 = readContinuationByte();
                byte3 = readContinuationByte();
                codePoint = (0x0F & byte1) << 12 | byte2 << 6 | byte3;
                if (codePoint >= 0x0800) return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
                throw Error('Invalid continuation byte');
            }
            if ((0xF8 & byte1) == 0xF0) {
                byte2 = readContinuationByte();
                byte3 = readContinuationByte();
                byte4 = readContinuationByte();
                codePoint = (0x07 & byte1) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;
                if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) return codePoint;
            }
            throw Error('Invalid UTF-8 detected');
        }
        var byteArray;
        var byteCount;
        var byteIndex;
        function utf8decode(byteString, opts) {
            opts = opts || {};
            var strict = false !== opts.strict;
            byteArray = ucs2decode(byteString);
            byteCount = byteArray.length;
            byteIndex = 0;
            var codePoints = [];
            var tmp;
            while(false !== (tmp = decodeSymbol(strict)))codePoints.push(tmp);
            return ucs2encode(codePoints);
        }
        module.exports = {
            version: '2.1.2',
            encode: utf8encode,
            decode: utf8decode
        };
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/server.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Server = exports1.BaseServer = void 0;
        const qs = __webpack_require__("querystring");
        const url_1 = __webpack_require__("url");
        const base64id = __webpack_require__("../node_modules/.pnpm/base64id@2.0.0/node_modules/base64id/lib/base64id.js");
        const transports_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/index.js");
        const events_1 = __webpack_require__("events");
        const socket_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/socket.js");
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const cookie_1 = __webpack_require__("../node_modules/.pnpm/cookie@0.7.2/node_modules/cookie/index.js");
        const ws_1 = __webpack_require__("../node_modules/.pnpm/ws@8.17.1/node_modules/ws/index.js");
        const webtransport_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/webtransport.js");
        const engine_io_parser_1 = __webpack_require__("../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/index.js");
        const debug = (0, debug_1.default)("engine");
        const kResponseHeaders = Symbol("responseHeaders");
        function parseSessionId(data) {
            try {
                const parsed = JSON.parse(data);
                if ("string" == typeof parsed.sid) return parsed.sid;
            } catch (e) {}
        }
        class BaseServer extends events_1.EventEmitter {
            constructor(opts = {}){
                super();
                this.middlewares = [];
                this.clients = {};
                this.clientsCount = 0;
                this.opts = Object.assign({
                    wsEngine: ws_1.Server,
                    pingTimeout: 20000,
                    pingInterval: 25000,
                    upgradeTimeout: 10000,
                    maxHttpBufferSize: 1e6,
                    transports: [
                        "polling",
                        "websocket"
                    ],
                    allowUpgrades: true,
                    httpCompression: {
                        threshold: 1024
                    },
                    cors: false,
                    allowEIO3: false
                }, opts);
                if (opts.cookie) this.opts.cookie = Object.assign({
                    name: "io",
                    path: "/",
                    httpOnly: false !== opts.cookie.path,
                    sameSite: "lax"
                }, opts.cookie);
                if (this.opts.cors) this.use(__webpack_require__("../node_modules/.pnpm/cors@2.8.5/node_modules/cors/lib/index.js")(this.opts.cors));
                if (opts.perMessageDeflate) this.opts.perMessageDeflate = Object.assign({
                    threshold: 1024
                }, opts.perMessageDeflate);
                this.init();
            }
            _computePath(options) {
                let path = (options.path || "/engine.io").replace(/\/$/, "");
                if (false !== options.addTrailingSlash) path += "/";
                return path;
            }
            upgrades(transport) {
                if (!this.opts.allowUpgrades) return [];
                return transports_1.default[transport].upgradesTo || [];
            }
            verify(req, upgrade, fn) {
                const transport = req._query.transport;
                if (!~this.opts.transports.indexOf(transport) || "webtransport" === transport) {
                    debug('unknown transport "%s"', transport);
                    return fn(Server.errors.UNKNOWN_TRANSPORT, {
                        transport
                    });
                }
                const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);
                if (isOriginInvalid) {
                    const origin = req.headers.origin;
                    req.headers.origin = null;
                    debug("origin header invalid");
                    return fn(Server.errors.BAD_REQUEST, {
                        name: "INVALID_ORIGIN",
                        origin
                    });
                }
                const sid = req._query.sid;
                if (sid) {
                    if (!this.clients.hasOwnProperty(sid)) {
                        debug('unknown sid "%s"', sid);
                        return fn(Server.errors.UNKNOWN_SID, {
                            sid
                        });
                    }
                    const previousTransport = this.clients[sid].transport.name;
                    if (!upgrade && previousTransport !== transport) {
                        debug("bad request: unexpected transport without upgrade");
                        return fn(Server.errors.BAD_REQUEST, {
                            name: "TRANSPORT_MISMATCH",
                            transport,
                            previousTransport
                        });
                    }
                } else {
                    if ("GET" !== req.method) return fn(Server.errors.BAD_HANDSHAKE_METHOD, {
                        method: req.method
                    });
                    if ("websocket" === transport && !upgrade) {
                        debug("invalid transport upgrade");
                        return fn(Server.errors.BAD_REQUEST, {
                            name: "TRANSPORT_HANDSHAKE_ERROR"
                        });
                    }
                    if (!this.opts.allowRequest) return fn();
                    return this.opts.allowRequest(req, (message, success)=>{
                        if (!success) return fn(Server.errors.FORBIDDEN, {
                            message
                        });
                        fn();
                    });
                }
                fn();
            }
            use(fn) {
                this.middlewares.push(fn);
            }
            _applyMiddlewares(req, res, callback) {
                if (0 === this.middlewares.length) {
                    debug("no middleware to apply, skipping");
                    return callback();
                }
                const apply = (i)=>{
                    debug("applying middleware n%d", i + 1);
                    this.middlewares[i](req, res, (err)=>{
                        if (err) return callback(err);
                        if (i + 1 < this.middlewares.length) apply(i + 1);
                        else callback();
                    });
                };
                apply(0);
            }
            close() {
                debug("closing all open clients");
                for(let i in this.clients)if (this.clients.hasOwnProperty(i)) this.clients[i].close(true);
                this.cleanup();
                return this;
            }
            generateId(req) {
                return base64id.generateId();
            }
            async handshake(transportName, req, closeConnection) {
                const protocol = "4" === req._query.EIO ? 4 : 3;
                if (3 === protocol && !this.opts.allowEIO3) {
                    debug("unsupported protocol version");
                    this.emit("connection_error", {
                        req,
                        code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,
                        message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],
                        context: {
                            protocol
                        }
                    });
                    closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);
                    return;
                }
                let id;
                try {
                    id = await this.generateId(req);
                } catch (e) {
                    debug("error while generating an id");
                    this.emit("connection_error", {
                        req,
                        code: Server.errors.BAD_REQUEST,
                        message: Server.errorMessages[Server.errors.BAD_REQUEST],
                        context: {
                            name: "ID_GENERATION_ERROR",
                            error: e
                        }
                    });
                    closeConnection(Server.errors.BAD_REQUEST);
                    return;
                }
                debug('handshaking client "%s"', id);
                try {
                    var transport = this.createTransport(transportName, req);
                    if ("polling" === transportName) {
                        transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;
                        transport.httpCompression = this.opts.httpCompression;
                    } else if ("websocket" === transportName) transport.perMessageDeflate = this.opts.perMessageDeflate;
                } catch (e) {
                    debug('error handshaking to transport "%s"', transportName);
                    this.emit("connection_error", {
                        req,
                        code: Server.errors.BAD_REQUEST,
                        message: Server.errorMessages[Server.errors.BAD_REQUEST],
                        context: {
                            name: "TRANSPORT_HANDSHAKE_ERROR",
                            error: e
                        }
                    });
                    closeConnection(Server.errors.BAD_REQUEST);
                    return;
                }
                const socket = new socket_1.Socket(id, this, transport, req, protocol);
                transport.on("headers", (headers, req)=>{
                    const isInitialRequest = !req._query.sid;
                    if (isInitialRequest) {
                        if (this.opts.cookie) headers["Set-Cookie"] = [
                            (0, cookie_1.serialize)(this.opts.cookie.name, id, this.opts.cookie)
                        ];
                        this.emit("initial_headers", headers, req);
                    }
                    this.emit("headers", headers, req);
                });
                transport.onRequest(req);
                this.clients[id] = socket;
                this.clientsCount++;
                socket.once("close", ()=>{
                    delete this.clients[id];
                    this.clientsCount--;
                });
                this.emit("connection", socket);
                return transport;
            }
            async onWebTransportSession(session) {
                const timeout = setTimeout(()=>{
                    debug("the client failed to establish a bidirectional stream in the given period");
                    session.close();
                }, this.opts.upgradeTimeout);
                const streamReader = session.incomingBidirectionalStreams.getReader();
                const result = await streamReader.read();
                if (result.done) return void debug("session is closed");
                const stream = result.value;
                const transformStream = (0, engine_io_parser_1.createPacketDecoderStream)(this.opts.maxHttpBufferSize, "nodebuffer");
                const reader = stream.readable.pipeThrough(transformStream).getReader();
                const { value, done } = await reader.read();
                if (done) return void debug("stream is closed");
                clearTimeout(timeout);
                if ("open" !== value.type) {
                    debug("invalid WebTransport handshake");
                    return session.close();
                }
                if (void 0 === value.data) {
                    const transport = new webtransport_1.WebTransport(session, stream, reader);
                    const id = base64id.generateId();
                    debug('handshaking client "%s" (WebTransport)', id);
                    const socket = new socket_1.Socket(id, this, transport, null, 4);
                    this.clients[id] = socket;
                    this.clientsCount++;
                    socket.once("close", ()=>{
                        delete this.clients[id];
                        this.clientsCount--;
                    });
                    this.emit("connection", socket);
                    return;
                }
                const sid = parseSessionId(value.data);
                if (!sid) {
                    debug("invalid WebTransport handshake");
                    return session.close();
                }
                const client = this.clients[sid];
                if (client) if (client.upgrading) {
                    debug("transport has already been trying to upgrade");
                    session.close();
                } else if (client.upgraded) {
                    debug("transport had already been upgraded");
                    session.close();
                } else {
                    debug("upgrading existing transport");
                    const transport = new webtransport_1.WebTransport(session, stream, reader);
                    client._maybeUpgrade(transport);
                }
                else {
                    debug("upgrade attempt for closed client");
                    session.close();
                }
            }
        }
        exports1.BaseServer = BaseServer;
        BaseServer.errors = {
            UNKNOWN_TRANSPORT: 0,
            UNKNOWN_SID: 1,
            BAD_HANDSHAKE_METHOD: 2,
            BAD_REQUEST: 3,
            FORBIDDEN: 4,
            UNSUPPORTED_PROTOCOL_VERSION: 5
        };
        BaseServer.errorMessages = {
            0: "Transport unknown",
            1: "Session ID unknown",
            2: "Bad handshake method",
            3: "Bad request",
            4: "Forbidden",
            5: "Unsupported protocol version"
        };
        class WebSocketResponse {
            constructor(req, socket){
                this.req = req;
                this.socket = socket;
                req[kResponseHeaders] = {};
            }
            setHeader(name, value) {
                this.req[kResponseHeaders][name] = value;
            }
            getHeader(name) {
                return this.req[kResponseHeaders][name];
            }
            removeHeader(name) {
                delete this.req[kResponseHeaders][name];
            }
            write() {}
            writeHead() {}
            end() {
                this.socket.destroy();
            }
        }
        class Server extends BaseServer {
            init() {
                if (!~this.opts.transports.indexOf("websocket")) return;
                if (this.ws) this.ws.close();
                this.ws = new this.opts.wsEngine({
                    noServer: true,
                    clientTracking: false,
                    perMessageDeflate: this.opts.perMessageDeflate,
                    maxPayload: this.opts.maxHttpBufferSize
                });
                if ("function" == typeof this.ws.on) this.ws.on("headers", (headersArray, req)=>{
                    const additionalHeaders = req[kResponseHeaders] || {};
                    delete req[kResponseHeaders];
                    const isInitialRequest = !req._query.sid;
                    if (isInitialRequest) this.emit("initial_headers", additionalHeaders, req);
                    this.emit("headers", additionalHeaders, req);
                    debug("writing headers: %j", additionalHeaders);
                    Object.keys(additionalHeaders).forEach((key)=>{
                        headersArray.push(`${key}: ${additionalHeaders[key]}`);
                    });
                });
            }
            cleanup() {
                if (this.ws) {
                    debug("closing webSocketServer");
                    this.ws.close();
                }
            }
            prepare(req) {
                if (!req._query) req._query = ~req.url.indexOf("?") ? qs.parse((0, url_1.parse)(req.url).query) : {};
            }
            createTransport(transportName, req) {
                return new transports_1.default[transportName](req);
            }
            handleRequest(req, res) {
                debug('handling "%s" http request "%s"', req.method, req.url);
                this.prepare(req);
                req.res = res;
                const callback = (errorCode, errorContext)=>{
                    if (void 0 !== errorCode) {
                        this.emit("connection_error", {
                            req,
                            code: errorCode,
                            message: Server.errorMessages[errorCode],
                            context: errorContext
                        });
                        abortRequest(res, errorCode, errorContext);
                        return;
                    }
                    if (req._query.sid) {
                        debug("setting new request for existing client");
                        this.clients[req._query.sid].transport.onRequest(req);
                    } else {
                        const closeConnection = (errorCode, errorContext)=>abortRequest(res, errorCode, errorContext);
                        this.handshake(req._query.transport, req, closeConnection);
                    }
                };
                this._applyMiddlewares(req, res, (err)=>{
                    if (err) callback(Server.errors.BAD_REQUEST, {
                        name: "MIDDLEWARE_FAILURE"
                    });
                    else this.verify(req, false, callback);
                });
            }
            handleUpgrade(req, socket, upgradeHead) {
                this.prepare(req);
                const res = new WebSocketResponse(req, socket);
                const callback = (errorCode, errorContext)=>{
                    if (void 0 !== errorCode) {
                        this.emit("connection_error", {
                            req,
                            code: errorCode,
                            message: Server.errorMessages[errorCode],
                            context: errorContext
                        });
                        abortUpgrade(socket, errorCode, errorContext);
                        return;
                    }
                    const head = Buffer.from(upgradeHead);
                    upgradeHead = null;
                    res.writeHead();
                    this.ws.handleUpgrade(req, socket, head, (websocket)=>{
                        this.onWebSocket(req, socket, websocket);
                    });
                };
                this._applyMiddlewares(req, res, (err)=>{
                    if (err) callback(Server.errors.BAD_REQUEST, {
                        name: "MIDDLEWARE_FAILURE"
                    });
                    else this.verify(req, true, callback);
                });
            }
            onWebSocket(req, socket, websocket) {
                websocket.on("error", onUpgradeError);
                if (void 0 !== transports_1.default[req._query.transport] && !transports_1.default[req._query.transport].prototype.handlesUpgrades) {
                    debug("transport doesnt handle upgraded requests");
                    websocket.close();
                    return;
                }
                const id = req._query.sid;
                req.websocket = websocket;
                if (id) {
                    const client = this.clients[id];
                    if (client) if (client.upgrading) {
                        debug("transport has already been trying to upgrade");
                        websocket.close();
                    } else if (client.upgraded) {
                        debug("transport had already been upgraded");
                        websocket.close();
                    } else {
                        debug("upgrading existing transport");
                        websocket.removeListener("error", onUpgradeError);
                        const transport = this.createTransport(req._query.transport, req);
                        transport.perMessageDeflate = this.opts.perMessageDeflate;
                        client._maybeUpgrade(transport);
                    }
                    else {
                        debug("upgrade attempt for closed client");
                        websocket.close();
                    }
                } else {
                    const closeConnection = (errorCode, errorContext)=>abortUpgrade(socket, errorCode, errorContext);
                    this.handshake(req._query.transport, req, closeConnection);
                }
                function onUpgradeError() {
                    debug("websocket error before upgrade");
                }
            }
            attach(server, options = {}) {
                const path = this._computePath(options);
                const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;
                function check(req) {
                    return path === req.url.slice(0, path.length);
                }
                const listeners = server.listeners("request").slice(0);
                server.removeAllListeners("request");
                server.on("close", this.close.bind(this));
                server.on("listening", this.init.bind(this));
                server.on("request", (req, res)=>{
                    if (check(req)) {
                        debug('intercepting request for path "%s"', path);
                        this.handleRequest(req, res);
                    } else {
                        let i = 0;
                        const l = listeners.length;
                        for(; i < l; i++)listeners[i].call(server, req, res);
                    }
                });
                if (~this.opts.transports.indexOf("websocket")) server.on("upgrade", (req, socket, head)=>{
                    if (check(req)) this.handleUpgrade(req, socket, head);
                    else if (false !== options.destroyUpgrade) setTimeout(function() {
                        if (socket.writable && socket.bytesWritten <= 0) {
                            socket.on("error", (e)=>{
                                debug("error while destroying upgrade: %s", e.message);
                            });
                            return socket.end();
                        }
                    }, destroyUpgradeTimeout);
                });
            }
        }
        exports1.Server = Server;
        function abortRequest(res, errorCode, errorContext) {
            const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;
            const message = errorContext && errorContext.message ? errorContext.message : Server.errorMessages[errorCode];
            res.writeHead(statusCode, {
                "Content-Type": "application/json"
            });
            res.end(JSON.stringify({
                code: errorCode,
                message
            }));
        }
        function abortUpgrade(socket, errorCode, errorContext = {}) {
            socket.on("error", ()=>{
                debug("ignoring error from closed connection");
            });
            if (socket.writable) {
                const message = errorContext.message || Server.errorMessages[errorCode];
                const length = Buffer.byteLength(message);
                socket.write("HTTP/1.1 400 Bad Request\r\nConnection: close\r\nContent-type: text/html\r\nContent-Length: " + length + "\r\n\r\n" + message);
            }
            socket.destroy();
        }
        const validHdrChars = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ];
        function checkInvalidHeaderChar(val) {
            val += "";
            if (val.length < 1) return false;
            if (!validHdrChars[val.charCodeAt(0)]) {
                debug('invalid header, index 0, char "%s"', val.charCodeAt(0));
                return true;
            }
            if (val.length < 2) return false;
            if (!validHdrChars[val.charCodeAt(1)]) {
                debug('invalid header, index 1, char "%s"', val.charCodeAt(1));
                return true;
            }
            if (val.length < 3) return false;
            if (!validHdrChars[val.charCodeAt(2)]) {
                debug('invalid header, index 2, char "%s"', val.charCodeAt(2));
                return true;
            }
            if (val.length < 4) return false;
            if (!validHdrChars[val.charCodeAt(3)]) {
                debug('invalid header, index 3, char "%s"', val.charCodeAt(3));
                return true;
            }
            for(let i = 4; i < val.length; ++i)if (!validHdrChars[val.charCodeAt(i)]) {
                debug('invalid header, index "%i", char "%s"', i, val.charCodeAt(i));
                return true;
            }
            return false;
        }
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/socket.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Socket = void 0;
        const events_1 = __webpack_require__("events");
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const timers_1 = __webpack_require__("timers");
        const debug = (0, debug_1.default)("engine:socket");
        class Socket extends events_1.EventEmitter {
            get readyState() {
                return this._readyState;
            }
            set readyState(state) {
                debug("readyState updated from %s to %s", this._readyState, state);
                this._readyState = state;
            }
            constructor(id, server, transport, req, protocol){
                super();
                this._readyState = "opening";
                this.upgrading = false;
                this.upgraded = false;
                this.writeBuffer = [];
                this.packetsFn = [];
                this.sentCallbackFn = [];
                this.cleanupFn = [];
                this.id = id;
                this.server = server;
                this.request = req;
                this.protocol = protocol;
                if (req) if (req.websocket && req.websocket._socket) this.remoteAddress = req.websocket._socket.remoteAddress;
                else this.remoteAddress = req.connection.remoteAddress;
                this.pingTimeoutTimer = null;
                this.pingIntervalTimer = null;
                this.setTransport(transport);
                this.onOpen();
            }
            onOpen() {
                this.readyState = "open";
                this.transport.sid = this.id;
                this.sendPacket("open", JSON.stringify({
                    sid: this.id,
                    upgrades: this.getAvailableUpgrades(),
                    pingInterval: this.server.opts.pingInterval,
                    pingTimeout: this.server.opts.pingTimeout,
                    maxPayload: this.server.opts.maxHttpBufferSize
                }));
                if (this.server.opts.initialPacket) this.sendPacket("message", this.server.opts.initialPacket);
                this.emit("open");
                if (3 === this.protocol) this.resetPingTimeout();
                else this.schedulePing();
            }
            onPacket(packet) {
                if ("open" !== this.readyState) return debug("packet received with closed socket");
                debug(`received packet ${packet.type}`);
                this.emit("packet", packet);
                switch(packet.type){
                    case "ping":
                        if (3 !== this.transport.protocol) return void this.onError(new Error("invalid heartbeat direction"));
                        debug("got ping");
                        this.pingTimeoutTimer.refresh();
                        this.sendPacket("pong");
                        this.emit("heartbeat");
                        break;
                    case "pong":
                        if (3 === this.transport.protocol) return void this.onError(new Error("invalid heartbeat direction"));
                        debug("got pong");
                        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
                        this.pingIntervalTimer.refresh();
                        this.emit("heartbeat");
                        break;
                    case "error":
                        this.onClose("parse error");
                        break;
                    case "message":
                        this.emit("data", packet.data);
                        this.emit("message", packet.data);
                        break;
                }
            }
            onError(err) {
                debug("transport error");
                this.onClose("transport error", err);
            }
            schedulePing() {
                this.pingIntervalTimer = (0, timers_1.setTimeout)(()=>{
                    debug("writing ping packet - expecting pong within %sms", this.server.opts.pingTimeout);
                    this.sendPacket("ping");
                    this.resetPingTimeout();
                }, this.server.opts.pingInterval);
            }
            resetPingTimeout() {
                (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
                this.pingTimeoutTimer = (0, timers_1.setTimeout)(()=>{
                    if ("closed" === this.readyState) return;
                    this.onClose("ping timeout");
                }, 3 === this.protocol ? this.server.opts.pingInterval + this.server.opts.pingTimeout : this.server.opts.pingTimeout);
            }
            setTransport(transport) {
                const onError = this.onError.bind(this);
                const onReady = ()=>this.flush();
                const onPacket = this.onPacket.bind(this);
                const onDrain = this.onDrain.bind(this);
                const onClose = this.onClose.bind(this, "transport close");
                this.transport = transport;
                this.transport.once("error", onError);
                this.transport.on("ready", onReady);
                this.transport.on("packet", onPacket);
                this.transport.on("drain", onDrain);
                this.transport.once("close", onClose);
                this.cleanupFn.push(function() {
                    transport.removeListener("error", onError);
                    transport.removeListener("ready", onReady);
                    transport.removeListener("packet", onPacket);
                    transport.removeListener("drain", onDrain);
                    transport.removeListener("close", onClose);
                });
            }
            onDrain() {
                if (this.sentCallbackFn.length > 0) {
                    debug("executing batch send callback");
                    const seqFn = this.sentCallbackFn.shift();
                    if (seqFn) for(let i = 0; i < seqFn.length; i++)seqFn[i](this.transport);
                }
            }
            _maybeUpgrade(transport) {
                debug('might upgrade socket transport from "%s" to "%s"', this.transport.name, transport.name);
                this.upgrading = true;
                const upgradeTimeoutTimer = (0, timers_1.setTimeout)(()=>{
                    debug("client did not complete upgrade - closing transport");
                    cleanup();
                    if ("open" === transport.readyState) transport.close();
                }, this.server.opts.upgradeTimeout);
                let checkIntervalTimer;
                const onPacket = (packet)=>{
                    if ("ping" === packet.type && "probe" === packet.data) {
                        debug("got probe ping packet, sending pong");
                        transport.send([
                            {
                                type: "pong",
                                data: "probe"
                            }
                        ]);
                        this.emit("upgrading", transport);
                        clearInterval(checkIntervalTimer);
                        checkIntervalTimer = setInterval(check, 100);
                    } else if ("upgrade" === packet.type && "closed" !== this.readyState) {
                        debug("got upgrade packet - upgrading");
                        cleanup();
                        this.transport.discard();
                        this.upgraded = true;
                        this.clearTransport();
                        this.setTransport(transport);
                        this.emit("upgrade", transport);
                        this.flush();
                        if ("closing" === this.readyState) transport.close(()=>{
                            this.onClose("forced close");
                        });
                    } else {
                        cleanup();
                        transport.close();
                    }
                };
                const check = ()=>{
                    if ("polling" === this.transport.name && this.transport.writable) {
                        debug("writing a noop packet to polling for fast upgrade");
                        this.transport.send([
                            {
                                type: "noop"
                            }
                        ]);
                    }
                };
                const cleanup = ()=>{
                    this.upgrading = false;
                    clearInterval(checkIntervalTimer);
                    (0, timers_1.clearTimeout)(upgradeTimeoutTimer);
                    transport.removeListener("packet", onPacket);
                    transport.removeListener("close", onTransportClose);
                    transport.removeListener("error", onError);
                    this.removeListener("close", onClose);
                };
                const onError = (err)=>{
                    debug("client did not complete upgrade - %s", err);
                    cleanup();
                    transport.close();
                    transport = null;
                };
                const onTransportClose = ()=>{
                    onError("transport closed");
                };
                const onClose = ()=>{
                    onError("socket closed");
                };
                transport.on("packet", onPacket);
                transport.once("close", onTransportClose);
                transport.once("error", onError);
                this.once("close", onClose);
            }
            clearTransport() {
                let cleanup;
                const toCleanUp = this.cleanupFn.length;
                for(let i = 0; i < toCleanUp; i++){
                    cleanup = this.cleanupFn.shift();
                    cleanup();
                }
                this.transport.on("error", function() {
                    debug("error triggered by discarded transport");
                });
                this.transport.close();
                (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
            }
            onClose(reason, description) {
                if ("closed" !== this.readyState) {
                    this.readyState = "closed";
                    (0, timers_1.clearTimeout)(this.pingIntervalTimer);
                    (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
                    process.nextTick(()=>{
                        this.writeBuffer = [];
                    });
                    this.packetsFn = [];
                    this.sentCallbackFn = [];
                    this.clearTransport();
                    this.emit("close", reason, description);
                }
            }
            send(data, options, callback) {
                this.sendPacket("message", data, options, callback);
                return this;
            }
            write(data, options, callback) {
                this.sendPacket("message", data, options, callback);
                return this;
            }
            sendPacket(type, data, options = {}, callback) {
                if ("function" == typeof options) {
                    callback = options;
                    options = {};
                }
                if ("closing" !== this.readyState && "closed" !== this.readyState) {
                    debug('sending packet "%s" (%s)', type, data);
                    options.compress = false !== options.compress;
                    const packet = {
                        type,
                        options: options
                    };
                    if (data) packet.data = data;
                    this.emit("packetCreate", packet);
                    this.writeBuffer.push(packet);
                    if ("function" == typeof callback) this.packetsFn.push(callback);
                    this.flush();
                }
            }
            flush() {
                if ("closed" !== this.readyState && this.transport.writable && this.writeBuffer.length) {
                    debug("flushing buffer to transport");
                    this.emit("flush", this.writeBuffer);
                    this.server.emit("flush", this, this.writeBuffer);
                    const wbuf = this.writeBuffer;
                    this.writeBuffer = [];
                    if (this.packetsFn.length) {
                        this.sentCallbackFn.push(this.packetsFn);
                        this.packetsFn = [];
                    } else this.sentCallbackFn.push(null);
                    this.transport.send(wbuf);
                    this.emit("drain");
                    this.server.emit("drain", this);
                }
            }
            getAvailableUpgrades() {
                const availableUpgrades = [];
                const allUpgrades = this.server.upgrades(this.transport.name);
                for(let i = 0; i < allUpgrades.length; ++i){
                    const upg = allUpgrades[i];
                    if (-1 !== this.server.opts.transports.indexOf(upg)) availableUpgrades.push(upg);
                }
                return availableUpgrades;
            }
            close(discard) {
                if (discard && ("open" === this.readyState || "closing" === this.readyState)) return this.closeTransport(discard);
                if ("open" !== this.readyState) return;
                this.readyState = "closing";
                if (this.writeBuffer.length) {
                    debug("there are %d remaining packets in the buffer, waiting for the 'drain' event", this.writeBuffer.length);
                    this.once("drain", ()=>{
                        debug("all packets have been sent, closing the transport");
                        this.closeTransport(discard);
                    });
                    return;
                }
                debug("the buffer is empty, closing the transport right away");
                this.closeTransport(discard);
            }
            closeTransport(discard) {
                debug("closing the transport (discard? %s)", !!discard);
                if (discard) this.transport.discard();
                this.transport.close(this.onClose.bind(this, "forced close"));
            }
        }
        exports1.Socket = Socket;
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transport.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Transport = void 0;
        const events_1 = __webpack_require__("events");
        const parser_v4 = __webpack_require__("../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/index.js");
        const parser_v3 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/parser-v3/index.js");
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const debug = (0, debug_1.default)("engine:transport");
        function noop() {}
        class Transport extends events_1.EventEmitter {
            get readyState() {
                return this._readyState;
            }
            set readyState(state) {
                debug("readyState updated from %s to %s (%s)", this._readyState, state, this.name);
                this._readyState = state;
            }
            constructor(req){
                super();
                this.writable = false;
                this._readyState = "open";
                this.discarded = false;
                this.protocol = "4" === req._query.EIO ? 4 : 3;
                this.parser = 4 === this.protocol ? parser_v4 : parser_v3;
                this.supportsBinary = !(req._query && req._query.b64);
            }
            discard() {
                this.discarded = true;
            }
            onRequest(req) {}
            close(fn) {
                if ("closed" === this.readyState || "closing" === this.readyState) return;
                this.readyState = "closing";
                this.doClose(fn || noop);
            }
            onError(msg, desc) {
                if (this.listeners("error").length) {
                    const err = new Error(msg);
                    err.type = "TransportError";
                    err.description = desc;
                    this.emit("error", err);
                } else debug("ignored transport error %s (%s)", msg, desc);
            }
            onPacket(packet) {
                this.emit("packet", packet);
            }
            onData(data) {
                this.onPacket(this.parser.decodePacket(data));
            }
            onClose() {
                this.readyState = "closed";
                this.emit("close");
            }
        }
        exports1.Transport = Transport;
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports-uws/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const polling_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports-uws/polling.js");
        const websocket_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports-uws/websocket.js");
        exports1["default"] = {
            polling: polling_1.Polling,
            websocket: websocket_1.WebSocket
        };
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports-uws/polling.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Polling = void 0;
        const transport_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transport.js");
        const zlib_1 = __webpack_require__("zlib");
        const accepts = __webpack_require__("../node_modules/.pnpm/accepts@1.3.8/node_modules/accepts/index.js");
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const debug = (0, debug_1.default)("engine:polling");
        const compressionMethods = {
            gzip: zlib_1.createGzip,
            deflate: zlib_1.createDeflate
        };
        class Polling extends transport_1.Transport {
            constructor(req){
                super(req);
                this.closeTimeout = 30000;
            }
            get name() {
                return "polling";
            }
            onRequest(req) {
                const res = req.res;
                req.res = null;
                if ("get" === req.getMethod()) this.onPollRequest(req, res);
                else if ("post" === req.getMethod()) this.onDataRequest(req, res);
                else {
                    res.writeStatus("500 Internal Server Error");
                    res.end();
                }
            }
            onPollRequest(req, res) {
                if (this.req) {
                    debug("request overlap");
                    this.onError("overlap from client");
                    res.writeStatus("500 Internal Server Error");
                    res.end();
                    return;
                }
                debug("setting request");
                this.req = req;
                this.res = res;
                const onClose = ()=>{
                    this.writable = false;
                    this.onError("poll connection closed prematurely");
                };
                const cleanup = ()=>{
                    this.req = this.res = null;
                };
                req.cleanup = cleanup;
                res.onAborted(onClose);
                this.writable = true;
                this.emit("ready");
                if (this.writable && this.shouldClose) {
                    debug("triggering empty send to append close packet");
                    this.send([
                        {
                            type: "noop"
                        }
                    ]);
                }
            }
            onDataRequest(req, res) {
                if (this.dataReq) {
                    this.onError("data request overlap from client");
                    res.writeStatus("500 Internal Server Error");
                    res.end();
                    return;
                }
                const expectedContentLength = Number(req.headers["content-length"]);
                if (!expectedContentLength) {
                    this.onError("content-length header required");
                    res.writeStatus("411 Length Required").end();
                    return;
                }
                if (expectedContentLength > this.maxHttpBufferSize) {
                    this.onError("payload too large");
                    res.writeStatus("413 Payload Too Large").end();
                    return;
                }
                const isBinary = "application/octet-stream" === req.headers["content-type"];
                if (isBinary && 4 === this.protocol) return this.onError("invalid content");
                this.dataReq = req;
                this.dataRes = res;
                let buffer;
                let offset = 0;
                const headers = {
                    "Content-Type": "text/html"
                };
                this.headers(req, headers);
                for(let key in headers)res.writeHeader(key, String(headers[key]));
                const onEnd = (buffer)=>{
                    this.onData(buffer.toString());
                    this.onDataRequestCleanup();
                    res.cork(()=>{
                        res.end("ok");
                    });
                };
                res.onAborted(()=>{
                    this.onDataRequestCleanup();
                    this.onError("data request connection closed prematurely");
                });
                res.onData((arrayBuffer, isLast)=>{
                    const totalLength = offset + arrayBuffer.byteLength;
                    if (totalLength > expectedContentLength) {
                        this.onError("content-length mismatch");
                        res.close();
                        return;
                    }
                    if (!buffer) {
                        if (isLast) return void onEnd(Buffer.from(arrayBuffer));
                        buffer = Buffer.allocUnsafe(expectedContentLength);
                    }
                    Buffer.from(arrayBuffer).copy(buffer, offset);
                    if (isLast) {
                        if (totalLength != expectedContentLength) {
                            this.onError("content-length mismatch");
                            res.writeStatus("400 Content-Length Mismatch").end();
                            this.onDataRequestCleanup();
                            return;
                        }
                        onEnd(buffer);
                        return;
                    }
                    offset = totalLength;
                });
            }
            onDataRequestCleanup() {
                this.dataReq = this.dataRes = null;
            }
            onData(data) {
                debug('received "%s"', data);
                const callback = (packet)=>{
                    if ("close" === packet.type) {
                        debug("got xhr close packet");
                        this.onClose();
                        return false;
                    }
                    this.onPacket(packet);
                };
                if (3 === this.protocol) this.parser.decodePayload(data, callback);
                else this.parser.decodePayload(data).forEach(callback);
            }
            onClose() {
                if (this.writable) this.send([
                    {
                        type: "noop"
                    }
                ]);
                super.onClose();
            }
            send(packets) {
                this.writable = false;
                if (this.shouldClose) {
                    debug("appending close packet to payload");
                    packets.push({
                        type: "close"
                    });
                    this.shouldClose();
                    this.shouldClose = null;
                }
                const doWrite = (data)=>{
                    const compress = packets.some((packet)=>packet.options && packet.options.compress);
                    this.write(data, {
                        compress
                    });
                };
                if (3 === this.protocol) this.parser.encodePayload(packets, this.supportsBinary, doWrite);
                else this.parser.encodePayload(packets, doWrite);
            }
            write(data, options) {
                debug('writing "%s"', data);
                this.doWrite(data, options, ()=>{
                    this.req.cleanup();
                    this.emit("drain");
                });
            }
            doWrite(data, options, callback) {
                const isString = "string" == typeof data;
                const contentType = isString ? "text/plain; charset=UTF-8" : "application/octet-stream";
                const headers = {
                    "Content-Type": contentType
                };
                const respond = (data)=>{
                    this.headers(this.req, headers);
                    this.res.cork(()=>{
                        Object.keys(headers).forEach((key)=>{
                            this.res.writeHeader(key, String(headers[key]));
                        });
                        this.res.end(data);
                    });
                    callback();
                };
                if (!this.httpCompression || !options.compress) return void respond(data);
                const len = isString ? Buffer.byteLength(data) : data.length;
                if (len < this.httpCompression.threshold) return void respond(data);
                const encoding = accepts(this.req).encodings([
                    "gzip",
                    "deflate"
                ]);
                if (!encoding) return void respond(data);
                this.compress(data, encoding, (err, data)=>{
                    if (err) {
                        this.res.writeStatus("500 Internal Server Error");
                        this.res.end();
                        callback(err);
                        return;
                    }
                    headers["Content-Encoding"] = encoding;
                    respond(data);
                });
            }
            compress(data, encoding, callback) {
                debug("compressing");
                const buffers = [];
                let nread = 0;
                compressionMethods[encoding](this.httpCompression).on("error", callback).on("data", function(chunk) {
                    buffers.push(chunk);
                    nread += chunk.length;
                }).on("end", function() {
                    callback(null, Buffer.concat(buffers, nread));
                }).end(data);
            }
            doClose(fn) {
                debug("closing");
                let closeTimeoutTimer;
                const onClose = ()=>{
                    clearTimeout(closeTimeoutTimer);
                    fn();
                    this.onClose();
                };
                if (this.writable) {
                    debug("transport writable - closing right away");
                    this.send([
                        {
                            type: "close"
                        }
                    ]);
                    onClose();
                } else if (this.discarded) {
                    debug("transport discarded - closing right away");
                    onClose();
                } else {
                    debug("transport not writable - buffering orderly close");
                    this.shouldClose = onClose;
                    closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
                }
            }
            headers(req, headers) {
                headers = headers || {};
                const ua = req.headers["user-agent"];
                if (ua && (~ua.indexOf(";MSIE") || ~ua.indexOf("Trident/"))) headers["X-XSS-Protection"] = "0";
                headers["cache-control"] = "no-store";
                this.emit("headers", headers, req);
                return headers;
            }
        }
        exports1.Polling = Polling;
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports-uws/websocket.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.WebSocket = void 0;
        const transport_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transport.js");
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const debug = (0, debug_1.default)("engine:ws");
        class WebSocket extends transport_1.Transport {
            constructor(req){
                super(req);
                this.writable = false;
                this.perMessageDeflate = null;
            }
            get name() {
                return "websocket";
            }
            get handlesUpgrades() {
                return true;
            }
            send(packets) {
                this.writable = false;
                for(let i = 0; i < packets.length; i++){
                    const packet = packets[i];
                    const isLast = i + 1 === packets.length;
                    const send = (data)=>{
                        const isBinary = "string" != typeof data;
                        const compress = this.perMessageDeflate && Buffer.byteLength(data) > this.perMessageDeflate.threshold;
                        debug('writing "%s"', data);
                        this.socket.send(data, isBinary, compress);
                        if (isLast) {
                            this.emit("drain");
                            this.writable = true;
                            this.emit("ready");
                        }
                    };
                    if (packet.options && "string" == typeof packet.options.wsPreEncoded) send(packet.options.wsPreEncoded);
                    else this.parser.encodePacket(packet, this.supportsBinary, send);
                }
            }
            doClose(fn) {
                debug("closing");
                fn && fn();
                this.socket.end();
            }
        }
        exports1.WebSocket = WebSocket;
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const polling_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/polling.js");
        const polling_jsonp_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/polling-jsonp.js");
        const websocket_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/websocket.js");
        const webtransport_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/webtransport.js");
        exports1["default"] = {
            polling: polling,
            websocket: websocket_1.WebSocket,
            webtransport: webtransport_1.WebTransport
        };
        function polling(req) {
            if ("string" == typeof req._query.j) return new polling_jsonp_1.JSONP(req);
            return new polling_1.Polling(req);
        }
        polling.upgradesTo = [
            "websocket",
            "webtransport"
        ];
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/polling-jsonp.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.JSONP = void 0;
        const polling_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/polling.js");
        const qs = __webpack_require__("querystring");
        const rDoubleSlashes = /\\\\n/g;
        const rSlashes = /(\\)?\\n/g;
        class JSONP extends polling_1.Polling {
            constructor(req){
                super(req);
                this.head = "___eio[" + (req._query.j || "").replace(/[^0-9]/g, "") + "](";
                this.foot = ");";
            }
            onData(data) {
                data = qs.parse(data).d;
                if ("string" == typeof data) {
                    data = data.replace(rSlashes, function(match, slashes) {
                        return slashes ? match : "\n";
                    });
                    super.onData(data.replace(rDoubleSlashes, "\\n"));
                }
            }
            doWrite(data, options, callback) {
                const js = JSON.stringify(data).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
                data = this.head + js + this.foot;
                super.doWrite(data, options, callback);
            }
        }
        exports1.JSONP = JSONP;
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/polling.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Polling = void 0;
        const transport_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transport.js");
        const zlib_1 = __webpack_require__("zlib");
        const accepts = __webpack_require__("../node_modules/.pnpm/accepts@1.3.8/node_modules/accepts/index.js");
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const debug = (0, debug_1.default)("engine:polling");
        const compressionMethods = {
            gzip: zlib_1.createGzip,
            deflate: zlib_1.createDeflate
        };
        class Polling extends transport_1.Transport {
            constructor(req){
                super(req);
                this.closeTimeout = 30000;
            }
            get name() {
                return "polling";
            }
            onRequest(req) {
                const res = req.res;
                req.res = null;
                if ("GET" === req.method) this.onPollRequest(req, res);
                else if ("POST" === req.method) this.onDataRequest(req, res);
                else {
                    res.writeHead(500);
                    res.end();
                }
            }
            onPollRequest(req, res) {
                if (this.req) {
                    debug("request overlap");
                    this.onError("overlap from client");
                    res.writeHead(400);
                    res.end();
                    return;
                }
                debug("setting request");
                this.req = req;
                this.res = res;
                const onClose = ()=>{
                    this.onError("poll connection closed prematurely");
                };
                const cleanup = ()=>{
                    req.removeListener("close", onClose);
                    this.req = this.res = null;
                };
                req.cleanup = cleanup;
                req.on("close", onClose);
                this.writable = true;
                this.emit("ready");
                if (this.writable && this.shouldClose) {
                    debug("triggering empty send to append close packet");
                    this.send([
                        {
                            type: "noop"
                        }
                    ]);
                }
            }
            onDataRequest(req, res) {
                if (this.dataReq) {
                    this.onError("data request overlap from client");
                    res.writeHead(400);
                    res.end();
                    return;
                }
                const isBinary = "application/octet-stream" === req.headers["content-type"];
                if (isBinary && 4 === this.protocol) return this.onError("invalid content");
                this.dataReq = req;
                this.dataRes = res;
                let chunks = isBinary ? Buffer.concat([]) : "";
                const cleanup = ()=>{
                    req.removeListener("data", onData);
                    req.removeListener("end", onEnd);
                    req.removeListener("close", onClose);
                    this.dataReq = this.dataRes = chunks = null;
                };
                const onClose = ()=>{
                    cleanup();
                    this.onError("data request connection closed prematurely");
                };
                const onData = (data)=>{
                    let contentLength;
                    if (isBinary) {
                        chunks = Buffer.concat([
                            chunks,
                            data
                        ]);
                        contentLength = chunks.length;
                    } else {
                        chunks += data;
                        contentLength = Buffer.byteLength(chunks);
                    }
                    if (contentLength > this.maxHttpBufferSize) {
                        res.writeHead(413).end();
                        cleanup();
                    }
                };
                const onEnd = ()=>{
                    this.onData(chunks);
                    const headers = {
                        "Content-Type": "text/html",
                        "Content-Length": "2"
                    };
                    res.writeHead(200, this.headers(req, headers));
                    res.end("ok");
                    cleanup();
                };
                req.on("close", onClose);
                if (!isBinary) req.setEncoding("utf8");
                req.on("data", onData);
                req.on("end", onEnd);
            }
            onData(data) {
                debug('received "%s"', data);
                const callback = (packet)=>{
                    if ("close" === packet.type) {
                        debug("got xhr close packet");
                        this.onClose();
                        return false;
                    }
                    this.onPacket(packet);
                };
                if (3 === this.protocol) this.parser.decodePayload(data, callback);
                else this.parser.decodePayload(data).forEach(callback);
            }
            onClose() {
                if (this.writable) this.send([
                    {
                        type: "noop"
                    }
                ]);
                super.onClose();
            }
            send(packets) {
                this.writable = false;
                if (this.shouldClose) {
                    debug("appending close packet to payload");
                    packets.push({
                        type: "close"
                    });
                    this.shouldClose();
                    this.shouldClose = null;
                }
                const doWrite = (data)=>{
                    const compress = packets.some((packet)=>packet.options && packet.options.compress);
                    this.write(data, {
                        compress
                    });
                };
                if (3 === this.protocol) this.parser.encodePayload(packets, this.supportsBinary, doWrite);
                else this.parser.encodePayload(packets, doWrite);
            }
            write(data, options) {
                debug('writing "%s"', data);
                this.doWrite(data, options, ()=>{
                    this.req.cleanup();
                    this.emit("drain");
                });
            }
            doWrite(data, options, callback) {
                const isString = "string" == typeof data;
                const contentType = isString ? "text/plain; charset=UTF-8" : "application/octet-stream";
                const headers = {
                    "Content-Type": contentType
                };
                const respond = (data)=>{
                    headers["Content-Length"] = "string" == typeof data ? Buffer.byteLength(data) : data.length;
                    this.res.writeHead(200, this.headers(this.req, headers));
                    this.res.end(data);
                    callback();
                };
                if (!this.httpCompression || !options.compress) return void respond(data);
                const len = isString ? Buffer.byteLength(data) : data.length;
                if (len < this.httpCompression.threshold) return void respond(data);
                const encoding = accepts(this.req).encodings([
                    "gzip",
                    "deflate"
                ]);
                if (!encoding) return void respond(data);
                this.compress(data, encoding, (err, data)=>{
                    if (err) {
                        this.res.writeHead(500);
                        this.res.end();
                        callback(err);
                        return;
                    }
                    headers["Content-Encoding"] = encoding;
                    respond(data);
                });
            }
            compress(data, encoding, callback) {
                debug("compressing");
                const buffers = [];
                let nread = 0;
                compressionMethods[encoding](this.httpCompression).on("error", callback).on("data", function(chunk) {
                    buffers.push(chunk);
                    nread += chunk.length;
                }).on("end", function() {
                    callback(null, Buffer.concat(buffers, nread));
                }).end(data);
            }
            doClose(fn) {
                debug("closing");
                let closeTimeoutTimer;
                if (this.dataReq) {
                    debug("aborting ongoing data request");
                    this.dataReq.destroy();
                }
                const onClose = ()=>{
                    clearTimeout(closeTimeoutTimer);
                    fn();
                    this.onClose();
                };
                if (this.writable) {
                    debug("transport writable - closing right away");
                    this.send([
                        {
                            type: "close"
                        }
                    ]);
                    onClose();
                } else if (this.discarded) {
                    debug("transport discarded - closing right away");
                    onClose();
                } else {
                    debug("transport not writable - buffering orderly close");
                    this.shouldClose = onClose;
                    closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
                }
            }
            headers(req, headers = {}) {
                const ua = req.headers["user-agent"];
                if (ua && (~ua.indexOf(";MSIE") || ~ua.indexOf("Trident/"))) headers["X-XSS-Protection"] = "0";
                headers["cache-control"] = "no-store";
                this.emit("headers", headers, req);
                return headers;
            }
        }
        exports1.Polling = Polling;
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/websocket.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.WebSocket = void 0;
        const transport_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transport.js");
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const debug = (0, debug_1.default)("engine:ws");
        class WebSocket extends transport_1.Transport {
            constructor(req){
                super(req);
                this._doSend = (data)=>{
                    this.socket.send(data, this._onSent);
                };
                this._doSendLast = (data)=>{
                    this.socket.send(data, this._onSentLast);
                };
                this._onSent = (err)=>{
                    if (err) this.onError("write error", err.stack);
                };
                this._onSentLast = (err)=>{
                    if (err) this.onError("write error", err.stack);
                    else {
                        this.emit("drain");
                        this.writable = true;
                        this.emit("ready");
                    }
                };
                this.socket = req.websocket;
                this.socket.on("message", (data, isBinary)=>{
                    const message = isBinary ? data : data.toString();
                    debug('received "%s"', message);
                    super.onData(message);
                });
                this.socket.once("close", this.onClose.bind(this));
                this.socket.on("error", this.onError.bind(this));
                this.writable = true;
                this.perMessageDeflate = null;
            }
            get name() {
                return "websocket";
            }
            get handlesUpgrades() {
                return true;
            }
            send(packets) {
                this.writable = false;
                for(let i = 0; i < packets.length; i++){
                    const packet = packets[i];
                    const isLast = i + 1 === packets.length;
                    if (this._canSendPreEncodedFrame(packet)) this.socket._sender.sendFrame(packet.options.wsPreEncodedFrame, isLast ? this._onSentLast : this._onSent);
                    else this.parser.encodePacket(packet, this.supportsBinary, isLast ? this._doSendLast : this._doSend);
                }
            }
            _canSendPreEncodedFrame(packet) {
                var _a, _b, _c;
                return !this.perMessageDeflate && "function" == typeof (null == (_b = null == (_a = this.socket) ? void 0 : _a._sender) ? void 0 : _b.sendFrame) && (null == (_c = packet.options) ? void 0 : _c.wsPreEncodedFrame) !== void 0;
            }
            doClose(fn) {
                debug("closing");
                this.socket.close();
                fn && fn();
            }
        }
        exports1.WebSocket = WebSocket;
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports/webtransport.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.WebTransport = void 0;
        const transport_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transport.js");
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const engine_io_parser_1 = __webpack_require__("../node_modules/.pnpm/engine.io-parser@5.2.3/node_modules/engine.io-parser/build/cjs/index.js");
        const debug = (0, debug_1.default)("engine:webtransport");
        class WebTransport extends transport_1.Transport {
            constructor(session, stream, reader){
                super({
                    _query: {
                        EIO: "4"
                    }
                });
                this.session = session;
                const transformStream = (0, engine_io_parser_1.createPacketEncoderStream)();
                transformStream.readable.pipeTo(stream.writable).catch(()=>{
                    debug("the stream was closed");
                });
                this.writer = transformStream.writable.getWriter();
                (async ()=>{
                    try {
                        while(true){
                            const { value, done } = await reader.read();
                            if (done) {
                                debug("session is closed");
                                break;
                            }
                            debug("received chunk: %o", value);
                            this.onPacket(value);
                        }
                    } catch (e) {
                        debug("error while reading: %s", e.message);
                    }
                })();
                session.closed.then(()=>this.onClose());
                this.writable = true;
            }
            get name() {
                return "webtransport";
            }
            async send(packets) {
                this.writable = false;
                try {
                    for(let i = 0; i < packets.length; i++){
                        const packet = packets[i];
                        await this.writer.write(packet);
                    }
                } catch (e) {
                    debug("error while writing: %s", e.message);
                }
                this.emit("drain");
                this.writable = true;
                this.emit("ready");
            }
            doClose(fn) {
                debug("closing WebTransport session");
                this.session.close();
                fn && fn();
            }
        }
        exports1.WebTransport = WebTransport;
    },
    "../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/userver.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.uServer = void 0;
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const server_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/server.js");
        const transports_uws_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/transports-uws/index.js");
        const debug = (0, debug_1.default)("engine:uws");
        class uServer extends server_1.BaseServer {
            init() {}
            cleanup() {}
            prepare(req, res) {
                req.method = req.getMethod().toUpperCase();
                req.url = req.getUrl();
                const params = new URLSearchParams(req.getQuery());
                req._query = Object.fromEntries(params.entries());
                req.headers = {};
                req.forEach((key, value)=>{
                    req.headers[key] = value;
                });
                req.connection = {
                    remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString()
                };
                res.onAborted(()=>{
                    debug("response has been aborted");
                });
            }
            createTransport(transportName, req) {
                return new transports_uws_1.default[transportName](req);
            }
            attach(app, options = {}) {
                const path = this._computePath(options);
                app.any(path, this.handleRequest.bind(this)).ws(path, {
                    compression: options.compression,
                    idleTimeout: options.idleTimeout,
                    maxBackpressure: options.maxBackpressure,
                    maxPayloadLength: this.opts.maxHttpBufferSize,
                    upgrade: this.handleUpgrade.bind(this),
                    open: (ws)=>{
                        const transport = ws.getUserData().transport;
                        transport.socket = ws;
                        transport.writable = true;
                        transport.emit("ready");
                    },
                    message: (ws, message, isBinary)=>{
                        ws.getUserData().transport.onData(isBinary ? message : Buffer.from(message).toString());
                    },
                    close: (ws, code, message)=>{
                        ws.getUserData().transport.onClose(code, message);
                    }
                });
            }
            _applyMiddlewares(req, res, callback) {
                if (0 === this.middlewares.length) return callback();
                req.res = new ResponseWrapper(res);
                super._applyMiddlewares(req, req.res, (err)=>{
                    req.res.writeHead();
                    callback(err);
                });
            }
            handleRequest(res, req) {
                debug('handling "%s" http request "%s"', req.getMethod(), req.getUrl());
                this.prepare(req, res);
                req.res = res;
                const callback = (errorCode, errorContext)=>{
                    if (void 0 !== errorCode) {
                        this.emit("connection_error", {
                            req,
                            code: errorCode,
                            message: server_1.Server.errorMessages[errorCode],
                            context: errorContext
                        });
                        this.abortRequest(req.res, errorCode, errorContext);
                        return;
                    }
                    if (req._query.sid) {
                        debug("setting new request for existing client");
                        this.clients[req._query.sid].transport.onRequest(req);
                    } else {
                        const closeConnection = (errorCode, errorContext)=>this.abortRequest(res, errorCode, errorContext);
                        this.handshake(req._query.transport, req, closeConnection);
                    }
                };
                this._applyMiddlewares(req, res, (err)=>{
                    if (err) callback(server_1.Server.errors.BAD_REQUEST, {
                        name: "MIDDLEWARE_FAILURE"
                    });
                    else this.verify(req, false, callback);
                });
            }
            handleUpgrade(res, req, context) {
                debug("on upgrade");
                this.prepare(req, res);
                req.res = res;
                const callback = async (errorCode, errorContext)=>{
                    if (void 0 !== errorCode) {
                        this.emit("connection_error", {
                            req,
                            code: errorCode,
                            message: server_1.Server.errorMessages[errorCode],
                            context: errorContext
                        });
                        this.abortRequest(res, errorCode, errorContext);
                        return;
                    }
                    const id = req._query.sid;
                    let transport;
                    if (id) {
                        const client = this.clients[id];
                        if (client) if (client.upgrading) {
                            debug("transport has already been trying to upgrade");
                            return res.close();
                        } else if (client.upgraded) {
                            debug("transport had already been upgraded");
                            return res.close();
                        } else {
                            debug("upgrading existing transport");
                            transport = this.createTransport(req._query.transport, req);
                            client._maybeUpgrade(transport);
                        }
                        else {
                            debug("upgrade attempt for closed client");
                            return res.close();
                        }
                    } else {
                        transport = await this.handshake(req._query.transport, req, (errorCode, errorContext)=>this.abortRequest(res, errorCode, errorContext));
                        if (!transport) return;
                    }
                    req.res.writeStatus("101 Switching Protocols");
                    res.upgrade({
                        transport
                    }, req.getHeader("sec-websocket-key"), req.getHeader("sec-websocket-protocol"), req.getHeader("sec-websocket-extensions"), context);
                };
                this._applyMiddlewares(req, res, (err)=>{
                    if (err) callback(server_1.Server.errors.BAD_REQUEST, {
                        name: "MIDDLEWARE_FAILURE"
                    });
                    else this.verify(req, true, callback);
                });
            }
            abortRequest(res, errorCode, errorContext) {
                const statusCode = errorCode === server_1.Server.errors.FORBIDDEN ? "403 Forbidden" : "400 Bad Request";
                const message = errorContext && errorContext.message ? errorContext.message : server_1.Server.errorMessages[errorCode];
                res.writeStatus(statusCode);
                res.writeHeader("Content-Type", "application/json");
                res.end(JSON.stringify({
                    code: errorCode,
                    message
                }));
            }
        }
        exports1.uServer = uServer;
        class ResponseWrapper {
            constructor(res){
                this.res = res;
                this.statusWritten = false;
                this.headers = [];
                this.isAborted = false;
            }
            set statusCode(status) {
                if (!status) return;
                this.writeStatus(200 === status ? "200 OK" : "204 No Content");
            }
            writeHead(status) {
                this.statusCode = status;
            }
            setHeader(key, value) {
                if (Array.isArray(value)) value.forEach((val)=>{
                    this.writeHeader(key, val);
                });
                else this.writeHeader(key, value);
            }
            removeHeader() {}
            getHeader() {}
            writeStatus(status) {
                if (this.isAborted) return;
                this.res.writeStatus(status);
                this.statusWritten = true;
                this.writeBufferedHeaders();
                return this;
            }
            writeHeader(key, value) {
                if (this.isAborted) return;
                if ("Content-Length" === key) return;
                if (this.statusWritten) this.res.writeHeader(key, value);
                else this.headers.push([
                    key,
                    value
                ]);
            }
            writeBufferedHeaders() {
                this.headers.forEach(([key, value])=>{
                    this.res.writeHeader(key, value);
                });
            }
            end(data) {
                if (this.isAborted) return;
                this.res.cork(()=>{
                    if (!this.statusWritten) this.writeBufferedHeaders();
                    this.res.end(data);
                });
            }
            onData(fn) {
                if (this.isAborted) return;
                this.res.onData(fn);
            }
            onAborted(fn) {
                if (this.isAborted) return;
                this.res.onAborted(()=>{
                    this.isAborted = true;
                    fn();
                });
            }
            cork(fn) {
                if (this.isAborted) return;
                this.res.cork(fn);
            }
        }
    },
    "../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/cjs/binary.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.reconstructPacket = exports1.deconstructPacket = void 0;
        const is_binary_js_1 = __webpack_require__("../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/cjs/is-binary.js");
        function deconstructPacket(packet) {
            const buffers = [];
            const packetData = packet.data;
            const pack = packet;
            pack.data = _deconstructPacket(packetData, buffers);
            pack.attachments = buffers.length;
            return {
                packet: pack,
                buffers: buffers
            };
        }
        exports1.deconstructPacket = deconstructPacket;
        function _deconstructPacket(data, buffers) {
            if (!data) return data;
            if ((0, is_binary_js_1.isBinary)(data)) {
                const placeholder = {
                    _placeholder: true,
                    num: buffers.length
                };
                buffers.push(data);
                return placeholder;
            }
            if (Array.isArray(data)) {
                const newData = new Array(data.length);
                for(let i = 0; i < data.length; i++)newData[i] = _deconstructPacket(data[i], buffers);
                return newData;
            }
            if ("object" == typeof data && !(data instanceof Date)) {
                const newData = {};
                for(const key in data)if (Object.prototype.hasOwnProperty.call(data, key)) newData[key] = _deconstructPacket(data[key], buffers);
                return newData;
            }
            return data;
        }
        function reconstructPacket(packet, buffers) {
            packet.data = _reconstructPacket(packet.data, buffers);
            delete packet.attachments;
            return packet;
        }
        exports1.reconstructPacket = reconstructPacket;
        function _reconstructPacket(data, buffers) {
            if (!data) return data;
            if (data && true === data._placeholder) {
                const isIndexValid = "number" == typeof data.num && data.num >= 0 && data.num < buffers.length;
                if (isIndexValid) return buffers[data.num];
                throw new Error("illegal attachments");
            }
            if (Array.isArray(data)) for(let i = 0; i < data.length; i++)data[i] = _reconstructPacket(data[i], buffers);
            else if ("object" == typeof data) {
                for(const key in data)if (Object.prototype.hasOwnProperty.call(data, key)) data[key] = _reconstructPacket(data[key], buffers);
            }
            return data;
        }
    },
    "../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/cjs/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Decoder = exports1.Encoder = exports1.PacketType = exports1.protocol = void 0;
        const component_emitter_1 = __webpack_require__("../node_modules/.pnpm/@socket.io+component-emitter@3.1.2/node_modules/@socket.io/component-emitter/lib/esm/index.js");
        const binary_js_1 = __webpack_require__("../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/cjs/binary.js");
        const is_binary_js_1 = __webpack_require__("../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/cjs/is-binary.js");
        const debug_1 = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const debug = (0, debug_1.default)("socket.io-parser");
        const RESERVED_EVENTS = [
            "connect",
            "connect_error",
            "disconnect",
            "disconnecting",
            "newListener",
            "removeListener"
        ];
        exports1.protocol = 5;
        var PacketType;
        (function(PacketType) {
            PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
            PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
            PacketType[PacketType["EVENT"] = 2] = "EVENT";
            PacketType[PacketType["ACK"] = 3] = "ACK";
            PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
            PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
            PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
        })(PacketType = exports1.PacketType || (exports1.PacketType = {}));
        class Encoder {
            constructor(replacer){
                this.replacer = replacer;
            }
            encode(obj) {
                debug("encoding packet %j", obj);
                if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
                    if ((0, is_binary_js_1.hasBinary)(obj)) return this.encodeAsBinary({
                        type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
                        nsp: obj.nsp,
                        data: obj.data,
                        id: obj.id
                    });
                }
                return [
                    this.encodeAsString(obj)
                ];
            }
            encodeAsString(obj) {
                let str = "" + obj.type;
                if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) str += obj.attachments + "-";
                if (obj.nsp && "/" !== obj.nsp) str += obj.nsp + ",";
                if (null != obj.id) str += obj.id;
                if (null != obj.data) str += JSON.stringify(obj.data, this.replacer);
                debug("encoded %j as %s", obj, str);
                return str;
            }
            encodeAsBinary(obj) {
                const deconstruction = (0, binary_js_1.deconstructPacket)(obj);
                const pack = this.encodeAsString(deconstruction.packet);
                const buffers = deconstruction.buffers;
                buffers.unshift(pack);
                return buffers;
            }
        }
        exports1.Encoder = Encoder;
        function isObject(value) {
            return "[object Object]" === Object.prototype.toString.call(value);
        }
        class Decoder extends component_emitter_1.Emitter {
            constructor(reviver){
                super();
                this.reviver = reviver;
            }
            add(obj) {
                let packet;
                if ("string" == typeof obj) {
                    if (this.reconstructor) throw new Error("got plaintext data when reconstructing a packet");
                    packet = this.decodeString(obj);
                    const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
                    if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
                        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
                        this.reconstructor = new BinaryReconstructor(packet);
                        if (0 === packet.attachments) super.emitReserved("decoded", packet);
                    } else super.emitReserved("decoded", packet);
                } else if ((0, is_binary_js_1.isBinary)(obj) || obj.base64) if (this.reconstructor) {
                    packet = this.reconstructor.takeBinaryData(obj);
                    if (packet) {
                        this.reconstructor = null;
                        super.emitReserved("decoded", packet);
                    }
                } else throw new Error("got binary data when not reconstructing a packet");
                else throw new Error("Unknown type: " + obj);
            }
            decodeString(str) {
                let i = 0;
                const p = {
                    type: Number(str.charAt(0))
                };
                if (void 0 === PacketType[p.type]) throw new Error("unknown packet type " + p.type);
                if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
                    const start = i + 1;
                    while("-" !== str.charAt(++i) && i != str.length);
                    const buf = str.substring(start, i);
                    if (buf != Number(buf) || "-" !== str.charAt(i)) throw new Error("Illegal attachments");
                    p.attachments = Number(buf);
                }
                if ("/" === str.charAt(i + 1)) {
                    const start = i + 1;
                    while(++i){
                        const c = str.charAt(i);
                        if ("," === c) break;
                        if (i === str.length) break;
                    }
                    p.nsp = str.substring(start, i);
                } else p.nsp = "/";
                const next = str.charAt(i + 1);
                if ("" !== next && Number(next) == next) {
                    const start = i + 1;
                    while(++i){
                        const c = str.charAt(i);
                        if (null == c || Number(c) != c) {
                            --i;
                            break;
                        }
                        if (i === str.length) break;
                    }
                    p.id = Number(str.substring(start, i + 1));
                }
                if (str.charAt(++i)) {
                    const payload = this.tryParse(str.substr(i));
                    if (Decoder.isPayloadValid(p.type, payload)) p.data = payload;
                    else throw new Error("invalid payload");
                }
                debug("decoded %s as %j", str, p);
                return p;
            }
            tryParse(str) {
                try {
                    return JSON.parse(str, this.reviver);
                } catch (e) {
                    return false;
                }
            }
            static isPayloadValid(type, payload) {
                switch(type){
                    case PacketType.CONNECT:
                        return isObject(payload);
                    case PacketType.DISCONNECT:
                        return void 0 === payload;
                    case PacketType.CONNECT_ERROR:
                        return "string" == typeof payload || isObject(payload);
                    case PacketType.EVENT:
                    case PacketType.BINARY_EVENT:
                        return Array.isArray(payload) && ("number" == typeof payload[0] || "string" == typeof payload[0] && -1 === RESERVED_EVENTS.indexOf(payload[0]));
                    case PacketType.ACK:
                    case PacketType.BINARY_ACK:
                        return Array.isArray(payload);
                }
            }
            destroy() {
                if (this.reconstructor) {
                    this.reconstructor.finishedReconstruction();
                    this.reconstructor = null;
                }
            }
        }
        exports1.Decoder = Decoder;
        class BinaryReconstructor {
            constructor(packet){
                this.packet = packet;
                this.buffers = [];
                this.reconPack = packet;
            }
            takeBinaryData(binData) {
                this.buffers.push(binData);
                if (this.buffers.length === this.reconPack.attachments) {
                    const packet = (0, binary_js_1.reconstructPacket)(this.reconPack, this.buffers);
                    this.finishedReconstruction();
                    return packet;
                }
                return null;
            }
            finishedReconstruction() {
                this.reconPack = null;
                this.buffers = [];
            }
        }
    },
    "../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/cjs/is-binary.js": function(__unused_webpack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.hasBinary = exports1.isBinary = void 0;
        const withNativeArrayBuffer = "function" == typeof ArrayBuffer;
        const isView = (obj)=>"function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
        const toString = Object.prototype.toString;
        const withNativeBlob = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === toString.call(Blob);
        const withNativeFile = "function" == typeof File || "undefined" != typeof File && "[object FileConstructor]" === toString.call(File);
        function isBinary(obj) {
            return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
        }
        exports1.isBinary = isBinary;
        function hasBinary(obj, toJSON) {
            if (!obj || "object" != typeof obj) return false;
            if (Array.isArray(obj)) {
                for(let i = 0, l = obj.length; i < l; i++)if (hasBinary(obj[i])) return true;
                return false;
            }
            if (isBinary(obj)) return true;
            if (obj.toJSON && "function" == typeof obj.toJSON && 1 === arguments.length) return hasBinary(obj.toJSON(), true);
            for(const key in obj)if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) return true;
            return false;
        }
        exports1.hasBinary = hasBinary;
    },
    "../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/broadcast-operator.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.RemoteSocket = exports1.BroadcastOperator = void 0;
        const socket_types_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/socket-types.js");
        const socket_io_parser_1 = __webpack_require__("../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/cjs/index.js");
        class BroadcastOperator {
            constructor(adapter, rooms = new Set(), exceptRooms = new Set(), flags = {}){
                this.adapter = adapter;
                this.rooms = rooms;
                this.exceptRooms = exceptRooms;
                this.flags = flags;
            }
            to(room) {
                const rooms = new Set(this.rooms);
                if (Array.isArray(room)) room.forEach((r)=>rooms.add(r));
                else rooms.add(room);
                return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);
            }
            in(room) {
                return this.to(room);
            }
            except(room) {
                const exceptRooms = new Set(this.exceptRooms);
                if (Array.isArray(room)) room.forEach((r)=>exceptRooms.add(r));
                else exceptRooms.add(room);
                return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);
            }
            compress(compress) {
                const flags = Object.assign({}, this.flags, {
                    compress
                });
                return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
            }
            get volatile() {
                const flags = Object.assign({}, this.flags, {
                    volatile: true
                });
                return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
            }
            get local() {
                const flags = Object.assign({}, this.flags, {
                    local: true
                });
                return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
            }
            timeout(timeout) {
                const flags = Object.assign({}, this.flags, {
                    timeout
                });
                return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
            }
            emit(ev, ...args) {
                if (socket_types_1.RESERVED_EVENTS.has(ev)) throw new Error(`"${String(ev)}" is a reserved event name`);
                const data = [
                    ev,
                    ...args
                ];
                const packet = {
                    type: socket_io_parser_1.PacketType.EVENT,
                    data: data
                };
                const withAck = "function" == typeof data[data.length - 1];
                if (!withAck) {
                    this.adapter.broadcast(packet, {
                        rooms: this.rooms,
                        except: this.exceptRooms,
                        flags: this.flags
                    });
                    return true;
                }
                const ack = data.pop();
                let timedOut = false;
                let responses = [];
                const timer = setTimeout(()=>{
                    timedOut = true;
                    ack.apply(this, [
                        new Error("operation has timed out"),
                        this.flags.expectSingleResponse ? null : responses
                    ]);
                }, this.flags.timeout);
                let expectedServerCount = -1;
                let actualServerCount = 0;
                let expectedClientCount = 0;
                const checkCompleteness = ()=>{
                    if (!timedOut && expectedServerCount === actualServerCount && responses.length === expectedClientCount) {
                        clearTimeout(timer);
                        ack.apply(this, [
                            null,
                            this.flags.expectSingleResponse ? responses[0] : responses
                        ]);
                    }
                };
                this.adapter.broadcastWithAck(packet, {
                    rooms: this.rooms,
                    except: this.exceptRooms,
                    flags: this.flags
                }, (clientCount)=>{
                    expectedClientCount += clientCount;
                    actualServerCount++;
                    checkCompleteness();
                }, (clientResponse)=>{
                    responses.push(clientResponse);
                    checkCompleteness();
                });
                this.adapter.serverCount().then((serverCount)=>{
                    expectedServerCount = serverCount;
                    checkCompleteness();
                });
                return true;
            }
            emitWithAck(ev, ...args) {
                return new Promise((resolve, reject)=>{
                    args.push((err, responses)=>{
                        if (!err) return resolve(responses);
                        err.responses = responses;
                        return reject(err);
                    });
                    this.emit(ev, ...args);
                });
            }
            allSockets() {
                if (!this.adapter) throw new Error("No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?");
                return this.adapter.sockets(this.rooms);
            }
            fetchSockets() {
                return this.adapter.fetchSockets({
                    rooms: this.rooms,
                    except: this.exceptRooms,
                    flags: this.flags
                }).then((sockets)=>sockets.map((socket)=>{
                        if (socket.server) return socket;
                        return new RemoteSocket(this.adapter, socket);
                    }));
            }
            socketsJoin(room) {
                this.adapter.addSockets({
                    rooms: this.rooms,
                    except: this.exceptRooms,
                    flags: this.flags
                }, Array.isArray(room) ? room : [
                    room
                ]);
            }
            socketsLeave(room) {
                this.adapter.delSockets({
                    rooms: this.rooms,
                    except: this.exceptRooms,
                    flags: this.flags
                }, Array.isArray(room) ? room : [
                    room
                ]);
            }
            disconnectSockets(close = false) {
                this.adapter.disconnectSockets({
                    rooms: this.rooms,
                    except: this.exceptRooms,
                    flags: this.flags
                }, close);
            }
        }
        exports1.BroadcastOperator = BroadcastOperator;
        class RemoteSocket {
            constructor(adapter, details){
                this.id = details.id;
                this.handshake = details.handshake;
                this.rooms = new Set(details.rooms);
                this.data = details.data;
                this.operator = new BroadcastOperator(adapter, new Set([
                    this.id
                ]), new Set(), {
                    expectSingleResponse: true
                });
            }
            timeout(timeout) {
                return this.operator.timeout(timeout);
            }
            emit(ev, ...args) {
                return this.operator.emit(ev, ...args);
            }
            join(room) {
                return this.operator.socketsJoin(room);
            }
            leave(room) {
                return this.operator.socketsLeave(room);
            }
            disconnect(close = false) {
                this.operator.disconnectSockets(close);
                return this;
            }
        }
        exports1.RemoteSocket = RemoteSocket;
    },
    "../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/client.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Client = void 0;
        const socket_io_parser_1 = __webpack_require__("../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/cjs/index.js");
        const debugModule = __webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js");
        const url = __webpack_require__("url");
        const debug = debugModule("socket.io:client");
        class Client {
            constructor(server, conn){
                this.sockets = new Map();
                this.nsps = new Map();
                this.server = server;
                this.conn = conn;
                this.encoder = server.encoder;
                this.decoder = new server._parser.Decoder();
                this.id = conn.id;
                this.setup();
            }
            get request() {
                return this.conn.request;
            }
            setup() {
                this.onclose = this.onclose.bind(this);
                this.ondata = this.ondata.bind(this);
                this.onerror = this.onerror.bind(this);
                this.ondecoded = this.ondecoded.bind(this);
                this.decoder.on("decoded", this.ondecoded);
                this.conn.on("data", this.ondata);
                this.conn.on("error", this.onerror);
                this.conn.on("close", this.onclose);
                this.connectTimeout = setTimeout(()=>{
                    if (0 === this.nsps.size) {
                        debug("no namespace joined yet, close the client");
                        this.close();
                    } else debug("the client has already joined a namespace, nothing to do");
                }, this.server._connectTimeout);
            }
            connect(name, auth = {}) {
                if (this.server._nsps.has(name)) {
                    debug("connecting to namespace %s", name);
                    return this.doConnect(name, auth);
                }
                this.server._checkNamespace(name, auth, (dynamicNspName)=>{
                    if (dynamicNspName) this.doConnect(name, auth);
                    else {
                        debug("creation of namespace %s was denied", name);
                        this._packet({
                            type: socket_io_parser_1.PacketType.CONNECT_ERROR,
                            nsp: name,
                            data: {
                                message: "Invalid namespace"
                            }
                        });
                    }
                });
            }
            doConnect(name, auth) {
                const nsp = this.server.of(name);
                nsp._add(this, auth, (socket)=>{
                    this.sockets.set(socket.id, socket);
                    this.nsps.set(nsp.name, socket);
                    if (this.connectTimeout) {
                        clearTimeout(this.connectTimeout);
                        this.connectTimeout = void 0;
                    }
                });
            }
            _disconnect() {
                for (const socket of this.sockets.values())socket.disconnect();
                this.sockets.clear();
                this.close();
            }
            _remove(socket) {
                if (this.sockets.has(socket.id)) {
                    const nsp = this.sockets.get(socket.id).nsp.name;
                    this.sockets.delete(socket.id);
                    this.nsps.delete(nsp);
                } else debug("ignoring remove for %s", socket.id);
            }
            close() {
                if ("open" === this.conn.readyState) {
                    debug("forcing transport close");
                    this.conn.close();
                    this.onclose("forced server close");
                }
            }
            _packet(packet, opts = {}) {
                if ("open" !== this.conn.readyState) return void debug("ignoring packet write %j", packet);
                const encodedPackets = opts.preEncoded ? packet : this.encoder.encode(packet);
                this.writeToEngine(encodedPackets, opts);
            }
            writeToEngine(encodedPackets, opts) {
                if (opts.volatile && !this.conn.transport.writable) return void debug("volatile packet is discarded since the transport is not currently writable");
                const packets = Array.isArray(encodedPackets) ? encodedPackets : [
                    encodedPackets
                ];
                for (const encodedPacket of packets)this.conn.write(encodedPacket, opts);
            }
            ondata(data) {
                try {
                    this.decoder.add(data);
                } catch (e) {
                    debug("invalid packet format");
                    this.onerror(e);
                }
            }
            ondecoded(packet) {
                let namespace;
                let authPayload;
                if (3 === this.conn.protocol) {
                    const parsed = url.parse(packet.nsp, true);
                    namespace = parsed.pathname;
                    authPayload = parsed.query;
                } else {
                    namespace = packet.nsp;
                    authPayload = packet.data;
                }
                const socket = this.nsps.get(namespace);
                if (socket || packet.type !== socket_io_parser_1.PacketType.CONNECT) if (socket && packet.type !== socket_io_parser_1.PacketType.CONNECT && packet.type !== socket_io_parser_1.PacketType.CONNECT_ERROR) process.nextTick(function() {
                    socket._onpacket(packet);
                });
                else {
                    debug("invalid state (packet type: %s)", packet.type);
                    this.close();
                }
                else this.connect(namespace, authPayload);
            }
            onerror(err) {
                for (const socket of this.sockets.values())socket._onerror(err);
                this.conn.close();
            }
            onclose(reason, description) {
                debug("client close with reason %s", reason);
                this.destroy();
                for (const socket of this.sockets.values())socket._onclose(reason, description);
                this.sockets.clear();
                this.decoder.destroy();
            }
            destroy() {
                this.conn.removeListener("data", this.ondata);
                this.conn.removeListener("error", this.onerror);
                this.conn.removeListener("close", this.onclose);
                this.decoder.removeListener("decoded", this.ondecoded);
                if (this.connectTimeout) {
                    clearTimeout(this.connectTimeout);
                    this.connectTimeout = void 0;
                }
            }
        }
        exports1.Client = Client;
    },
    "../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/index.js": function(module, exports1, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
            Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
            if (void 0 === k2) k2 = k;
            o[k2] = m[k];
        });
        var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
            Object.defineProperty(o, "default", {
                enumerable: true,
                value: v
            });
        } : function(o, v) {
            o["default"] = v;
        });
        var __importStar = this && this.__importStar || function(mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (null != mod) {
                for(var k in mod)if ("default" !== k && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }
            __setModuleDefault(result, mod);
            return result;
        };
        var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
                default: mod
            };
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Namespace = exports1.Socket = exports1.Server = void 0;
        const http = __webpack_require__("http");
        const fs_1 = __webpack_require__("fs");
        const zlib_1 = __webpack_require__("zlib");
        const accepts = __webpack_require__("../node_modules/.pnpm/accepts@1.3.8/node_modules/accepts/index.js");
        const stream_1 = __webpack_require__("stream");
        const path = __webpack_require__("path");
        const engine_io_1 = __webpack_require__("../node_modules/.pnpm/engine.io@6.6.4/node_modules/engine.io/build/engine.io.js");
        const client_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/client.js");
        const events_1 = __webpack_require__("events");
        const namespace_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/namespace.js");
        Object.defineProperty(exports1, "Namespace", {
            enumerable: true,
            get: function() {
                return namespace_1.Namespace;
            }
        });
        const parent_namespace_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/parent-namespace.js");
        const socket_io_adapter_1 = __webpack_require__("../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/index.js");
        const parser = __importStar(__webpack_require__("../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/cjs/index.js"));
        const debug_1 = __importDefault(__webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js"));
        const socket_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/socket.js");
        Object.defineProperty(exports1, "Socket", {
            enumerable: true,
            get: function() {
                return socket_1.Socket;
            }
        });
        const typed_events_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/typed-events.js");
        const uws_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/uws.js");
        const cors_1 = __importDefault(__webpack_require__("../node_modules/.pnpm/cors@2.8.5/node_modules/cors/lib/index.js"));
        const debug = (0, debug_1.default)("socket.io:server");
        const clientVersion = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/package.json").i8;
        const dotMapRegex = /\.map/;
        class Server extends typed_events_1.StrictEventEmitter {
            constructor(srv, opts = {}){
                super();
                this._nsps = new Map();
                this.parentNsps = new Map();
                this.parentNamespacesFromRegExp = new Map();
                if ("object" == typeof srv && srv instanceof Object && !srv.listen) {
                    opts = srv;
                    srv = void 0;
                }
                this.path(opts.path || "/socket.io");
                this.connectTimeout(opts.connectTimeout || 45000);
                this.serveClient(false !== opts.serveClient);
                this._parser = opts.parser || parser;
                this.encoder = new this._parser.Encoder();
                this.opts = opts;
                if (opts.connectionStateRecovery) {
                    opts.connectionStateRecovery = Object.assign({
                        maxDisconnectionDuration: 120000,
                        skipMiddlewares: true
                    }, opts.connectionStateRecovery);
                    this.adapter(opts.adapter || socket_io_adapter_1.SessionAwareAdapter);
                } else this.adapter(opts.adapter || socket_io_adapter_1.Adapter);
                opts.cleanupEmptyChildNamespaces = !!opts.cleanupEmptyChildNamespaces;
                this.sockets = this.of("/");
                if (srv || "number" == typeof srv) this.attach(srv);
                if (this.opts.cors) this._corsMiddleware = (0, cors_1.default)(this.opts.cors);
            }
            get _opts() {
                return this.opts;
            }
            serveClient(v) {
                if (!arguments.length) return this._serveClient;
                this._serveClient = v;
                return this;
            }
            _checkNamespace(name, auth, fn) {
                if (0 === this.parentNsps.size) return fn(false);
                const keysIterator = this.parentNsps.keys();
                const run = ()=>{
                    const nextFn = keysIterator.next();
                    if (nextFn.done) return fn(false);
                    nextFn.value(name, auth, (err, allow)=>{
                        if (err || !allow) return run();
                        if (this._nsps.has(name)) {
                            debug("dynamic namespace %s already exists", name);
                            return fn(this._nsps.get(name));
                        }
                        const namespace = this.parentNsps.get(nextFn.value).createChild(name);
                        debug("dynamic namespace %s was created", name);
                        fn(namespace);
                    });
                };
                run();
            }
            path(v) {
                if (!arguments.length) return this._path;
                this._path = v.replace(/\/$/, "");
                const escapedPath = this._path.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
                this.clientPathRegex = new RegExp("^" + escapedPath + "/socket\\.io(\\.msgpack|\\.esm)?(\\.min)?\\.js(\\.map)?(?:\\?|$)");
                return this;
            }
            connectTimeout(v) {
                if (void 0 === v) return this._connectTimeout;
                this._connectTimeout = v;
                return this;
            }
            adapter(v) {
                if (!arguments.length) return this._adapter;
                this._adapter = v;
                for (const nsp of this._nsps.values())nsp._initAdapter();
                return this;
            }
            listen(srv, opts = {}) {
                return this.attach(srv, opts);
            }
            attach(srv, opts = {}) {
                if ("function" == typeof srv) {
                    const msg = "You are trying to attach socket.io to an express request handler function. Please pass a http.Server instance.";
                    throw new Error(msg);
                }
                if (Number(srv) == srv) srv = Number(srv);
                if ("number" == typeof srv) {
                    debug("creating http server and binding to %d", srv);
                    const port = srv;
                    srv = http.createServer((req, res)=>{
                        res.writeHead(404);
                        res.end();
                    });
                    srv.listen(port);
                }
                Object.assign(opts, this.opts);
                opts.path = opts.path || this._path;
                this.initEngine(srv, opts);
                return this;
            }
            attachApp(app, opts = {}) {
                Object.assign(opts, this.opts);
                opts.path = opts.path || this._path;
                debug("creating uWebSockets.js-based engine with opts %j", opts);
                const engine = new engine_io_1.uServer(opts);
                engine.attach(app, opts);
                this.bind(engine);
                if (this._serveClient) app.get(`${this._path}/*`, (res, req)=>{
                    if (!this.clientPathRegex.test(req.getUrl())) return void req.setYield(true);
                    const filename = req.getUrl().replace(this._path, "").replace(/\?.*$/, "").replace(/^\//, "");
                    const isMap = dotMapRegex.test(filename);
                    const type = isMap ? "map" : "source";
                    const expectedEtag = '"' + clientVersion + '"';
                    const weakEtag = "W/" + expectedEtag;
                    const etag = req.getHeader("if-none-match");
                    if (etag) {
                        if (expectedEtag === etag || weakEtag === etag) {
                            debug("serve client %s 304", type);
                            res.writeStatus("304 Not Modified");
                            res.end();
                            return;
                        }
                    }
                    debug("serve client %s", type);
                    res.writeHeader("cache-control", "public, max-age=0");
                    res.writeHeader("content-type", "application/" + (isMap ? "json" : "javascript") + "; charset=utf-8");
                    res.writeHeader("etag", expectedEtag);
                    const filepath = path.join(__dirname, "../client-dist/", filename);
                    (0, uws_1.serveFile)(res, filepath);
                });
                (0, uws_1.patchAdapter)(app);
            }
            initEngine(srv, opts) {
                debug("creating engine.io instance with opts %j", opts);
                this.eio = (0, engine_io_1.attach)(srv, opts);
                if (this._serveClient) this.attachServe(srv);
                this.httpServer = srv;
                this.bind(this.eio);
            }
            attachServe(srv) {
                debug("attaching client serving req handler");
                const evs = srv.listeners("request").slice(0);
                srv.removeAllListeners("request");
                srv.on("request", (req, res)=>{
                    if (this.clientPathRegex.test(req.url)) if (this._corsMiddleware) this._corsMiddleware(req, res, ()=>{
                        this.serve(req, res);
                    });
                    else this.serve(req, res);
                    else for(let i = 0; i < evs.length; i++)evs[i].call(srv, req, res);
                });
            }
            serve(req, res) {
                const filename = req.url.replace(this._path, "").replace(/\?.*$/, "");
                const isMap = dotMapRegex.test(filename);
                const type = isMap ? "map" : "source";
                const expectedEtag = '"' + clientVersion + '"';
                const weakEtag = "W/" + expectedEtag;
                const etag = req.headers["if-none-match"];
                if (etag) {
                    if (expectedEtag === etag || weakEtag === etag) {
                        debug("serve client %s 304", type);
                        res.writeHead(304);
                        res.end();
                        return;
                    }
                }
                debug("serve client %s", type);
                res.setHeader("Cache-Control", "public, max-age=0");
                res.setHeader("Content-Type", "application/" + (isMap ? "json" : "javascript") + "; charset=utf-8");
                res.setHeader("ETag", expectedEtag);
                Server.sendFile(filename, req, res);
            }
            static sendFile(filename, req, res) {
                const readStream = (0, fs_1.createReadStream)(path.join(__dirname, "../client-dist/", filename));
                const encoding = accepts(req).encodings([
                    "br",
                    "gzip",
                    "deflate"
                ]);
                const onError = (err)=>{
                    if (err) res.end();
                };
                switch(encoding){
                    case "br":
                        res.writeHead(200, {
                            "content-encoding": "br"
                        });
                        (0, stream_1.pipeline)(readStream, (0, zlib_1.createBrotliCompress)(), res, onError);
                        break;
                    case "gzip":
                        res.writeHead(200, {
                            "content-encoding": "gzip"
                        });
                        (0, stream_1.pipeline)(readStream, (0, zlib_1.createGzip)(), res, onError);
                        break;
                    case "deflate":
                        res.writeHead(200, {
                            "content-encoding": "deflate"
                        });
                        (0, stream_1.pipeline)(readStream, (0, zlib_1.createDeflate)(), res, onError);
                        break;
                    default:
                        res.writeHead(200);
                        (0, stream_1.pipeline)(readStream, res, onError);
                }
            }
            bind(engine) {
                this.engine = engine;
                this.engine.on("connection", this.onconnection.bind(this));
                return this;
            }
            onconnection(conn) {
                debug("incoming connection with id %s", conn.id);
                const client = new client_1.Client(this, conn);
                if (3 === conn.protocol) client.connect("/");
                return this;
            }
            of(name, fn) {
                if ("function" == typeof name || name instanceof RegExp) {
                    const parentNsp = new parent_namespace_1.ParentNamespace(this);
                    debug("initializing parent namespace %s", parentNsp.name);
                    if ("function" == typeof name) this.parentNsps.set(name, parentNsp);
                    else {
                        this.parentNsps.set((nsp, conn, next)=>next(null, name.test(nsp)), parentNsp);
                        this.parentNamespacesFromRegExp.set(name, parentNsp);
                    }
                    if (fn) parentNsp.on("connect", fn);
                    return parentNsp;
                }
                if ("/" !== String(name)[0]) name = "/" + name;
                let nsp = this._nsps.get(name);
                if (!nsp) {
                    for (const [regex, parentNamespace] of this.parentNamespacesFromRegExp)if (regex.test(name)) {
                        debug("attaching namespace %s to parent namespace %s", name, regex);
                        return parentNamespace.createChild(name);
                    }
                    debug("initializing namespace %s", name);
                    nsp = new namespace_1.Namespace(this, name);
                    this._nsps.set(name, nsp);
                    if ("/" !== name) this.sockets.emitReserved("new_namespace", nsp);
                }
                if (fn) nsp.on("connect", fn);
                return nsp;
            }
            async close(fn) {
                await Promise.allSettled([
                    ...this._nsps.values()
                ].map(async (nsp)=>{
                    nsp.sockets.forEach((socket)=>{
                        socket._onclose("server shutting down");
                    });
                    await nsp.adapter.close();
                }));
                this.engine.close();
                (0, uws_1.restoreAdapter)();
                if (this.httpServer) this.httpServer.close(fn);
                else fn && fn();
            }
            use(fn) {
                this.sockets.use(fn);
                return this;
            }
            to(room) {
                return this.sockets.to(room);
            }
            in(room) {
                return this.sockets.in(room);
            }
            except(room) {
                return this.sockets.except(room);
            }
            send(...args) {
                this.sockets.emit("message", ...args);
                return this;
            }
            write(...args) {
                this.sockets.emit("message", ...args);
                return this;
            }
            serverSideEmit(ev, ...args) {
                return this.sockets.serverSideEmit(ev, ...args);
            }
            serverSideEmitWithAck(ev, ...args) {
                return this.sockets.serverSideEmitWithAck(ev, ...args);
            }
            allSockets() {
                return this.sockets.allSockets();
            }
            compress(compress) {
                return this.sockets.compress(compress);
            }
            get volatile() {
                return this.sockets.volatile;
            }
            get local() {
                return this.sockets.local;
            }
            timeout(timeout) {
                return this.sockets.timeout(timeout);
            }
            fetchSockets() {
                return this.sockets.fetchSockets();
            }
            socketsJoin(room) {
                return this.sockets.socketsJoin(room);
            }
            socketsLeave(room) {
                return this.sockets.socketsLeave(room);
            }
            disconnectSockets(close = false) {
                return this.sockets.disconnectSockets(close);
            }
        }
        exports1.Server = Server;
        const emitterMethods = Object.keys(events_1.EventEmitter.prototype).filter(function(key) {
            return "function" == typeof events_1.EventEmitter.prototype[key];
        });
        emitterMethods.forEach(function(fn) {
            Server.prototype[fn] = function() {
                return this.sockets[fn].apply(this.sockets, arguments);
            };
        });
        module.exports = (srv, opts)=>new Server(srv, opts);
        module.exports.Server = Server;
        module.exports.Namespace = namespace_1.Namespace;
        module.exports.Socket = socket_1.Socket;
    },
    "../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/namespace.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
                default: mod
            };
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Namespace = exports1.RESERVED_EVENTS = void 0;
        const socket_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/socket.js");
        const typed_events_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/typed-events.js");
        const debug_1 = __importDefault(__webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js"));
        const broadcast_operator_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/broadcast-operator.js");
        const debug = (0, debug_1.default)("socket.io:namespace");
        exports1.RESERVED_EVENTS = new Set([
            "connect",
            "connection",
            "new_namespace"
        ]);
        class Namespace extends typed_events_1.StrictEventEmitter {
            constructor(server, name){
                super();
                this.sockets = new Map();
                this._preConnectSockets = new Map();
                this._fns = [];
                this._ids = 0;
                this.server = server;
                this.name = name;
                this._initAdapter();
            }
            _initAdapter() {
                this.adapter = new (this.server.adapter())(this);
            }
            use(fn) {
                this._fns.push(fn);
                return this;
            }
            run(socket, fn) {
                if (!this._fns.length) return fn();
                const fns = this._fns.slice(0);
                function run(i) {
                    fns[i](socket, (err)=>{
                        if (err) return fn(err);
                        if (!fns[i + 1]) return fn();
                        run(i + 1);
                    });
                }
                run(0);
            }
            to(room) {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).to(room);
            }
            in(room) {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).in(room);
            }
            except(room) {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).except(room);
            }
            async _add(client, auth, fn) {
                var _a;
                debug("adding socket to nsp %s", this.name);
                const socket = await this._createSocket(client, auth);
                this._preConnectSockets.set(socket.id, socket);
                if ((null == (_a = this.server.opts.connectionStateRecovery) ? void 0 : _a.skipMiddlewares) && socket.recovered && "open" === client.conn.readyState) return this._doConnect(socket, fn);
                this.run(socket, (err)=>{
                    process.nextTick(()=>{
                        if ("open" !== client.conn.readyState) {
                            debug("next called after client was closed - ignoring socket");
                            socket._cleanup();
                            return;
                        }
                        if (err) {
                            debug("middleware error, sending CONNECT_ERROR packet to the client");
                            socket._cleanup();
                            if (3 === client.conn.protocol) return socket._error(err.data || err.message);
                            return socket._error({
                                message: err.message,
                                data: err.data
                            });
                        }
                        this._doConnect(socket, fn);
                    });
                });
            }
            async _createSocket(client, auth) {
                const sessionId = auth.pid;
                const offset = auth.offset;
                if (this.server.opts.connectionStateRecovery && "string" == typeof sessionId && "string" == typeof offset) {
                    let session;
                    try {
                        session = await this.adapter.restoreSession(sessionId, offset);
                    } catch (e) {
                        debug("error while restoring session: %s", e);
                    }
                    if (session) {
                        debug("connection state recovered for sid %s", session.sid);
                        return new socket_1.Socket(this, client, auth, session);
                    }
                }
                return new socket_1.Socket(this, client, auth);
            }
            _doConnect(socket, fn) {
                this._preConnectSockets.delete(socket.id);
                this.sockets.set(socket.id, socket);
                socket._onconnect();
                if (fn) fn(socket);
                this.emitReserved("connect", socket);
                this.emitReserved("connection", socket);
            }
            _remove(socket) {
                this.sockets.delete(socket.id) || this._preConnectSockets.delete(socket.id);
            }
            emit(ev, ...args) {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).emit(ev, ...args);
            }
            send(...args) {
                this.emit("message", ...args);
                return this;
            }
            write(...args) {
                this.emit("message", ...args);
                return this;
            }
            serverSideEmit(ev, ...args) {
                if (exports1.RESERVED_EVENTS.has(ev)) throw new Error(`"${String(ev)}" is a reserved event name`);
                args.unshift(ev);
                this.adapter.serverSideEmit(args);
                return true;
            }
            serverSideEmitWithAck(ev, ...args) {
                return new Promise((resolve, reject)=>{
                    args.push((err, responses)=>{
                        if (!err) return resolve(responses);
                        err.responses = responses;
                        return reject(err);
                    });
                    this.serverSideEmit(ev, ...args);
                });
            }
            _onServerSideEmit(args) {
                super.emitUntyped.apply(this, args);
            }
            allSockets() {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).allSockets();
            }
            compress(compress) {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).compress(compress);
            }
            get volatile() {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).volatile;
            }
            get local() {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).local;
            }
            timeout(timeout) {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).timeout(timeout);
            }
            fetchSockets() {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).fetchSockets();
            }
            socketsJoin(room) {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsJoin(room);
            }
            socketsLeave(room) {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsLeave(room);
            }
            disconnectSockets(close = false) {
                return new broadcast_operator_1.BroadcastOperator(this.adapter).disconnectSockets(close);
            }
        }
        exports1.Namespace = Namespace;
    },
    "../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/parent-namespace.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
                default: mod
            };
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.ParentNamespace = void 0;
        const namespace_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/namespace.js");
        const socket_io_adapter_1 = __webpack_require__("../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/index.js");
        const debug_1 = __importDefault(__webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js"));
        const debug = (0, debug_1.default)("socket.io:parent-namespace");
        class ParentNamespace extends namespace_1.Namespace {
            constructor(server){
                super(server, "/_" + ParentNamespace.count++);
                this.children = new Set();
            }
            _initAdapter() {
                this.adapter = new ParentBroadcastAdapter(this);
            }
            emit(ev, ...args) {
                this.children.forEach((nsp)=>{
                    nsp.emit(ev, ...args);
                });
                return true;
            }
            createChild(name) {
                debug("creating child namespace %s", name);
                const namespace = new namespace_1.Namespace(this.server, name);
                this["_fns"].forEach((fn)=>namespace.use(fn));
                this.listeners("connect").forEach((listener)=>namespace.on("connect", listener));
                this.listeners("connection").forEach((listener)=>namespace.on("connection", listener));
                this.children.add(namespace);
                if (this.server._opts.cleanupEmptyChildNamespaces) {
                    const remove = namespace._remove;
                    namespace._remove = (socket)=>{
                        remove.call(namespace, socket);
                        if (0 === namespace.sockets.size) {
                            debug("closing child namespace %s", name);
                            namespace.adapter.close();
                            this.server._nsps.delete(namespace.name);
                            this.children.delete(namespace);
                        }
                    };
                }
                this.server._nsps.set(name, namespace);
                this.server.sockets.emitReserved("new_namespace", namespace);
                return namespace;
            }
            fetchSockets() {
                throw new Error("fetchSockets() is not supported on parent namespaces");
            }
        }
        exports1.ParentNamespace = ParentNamespace;
        ParentNamespace.count = 0;
        class ParentBroadcastAdapter extends socket_io_adapter_1.Adapter {
            broadcast(packet, opts) {
                this.nsp.children.forEach((nsp)=>{
                    nsp.adapter.broadcast(packet, opts);
                });
            }
        }
    },
    "../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/socket-types.js": function(__unused_webpack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.RESERVED_EVENTS = void 0;
        exports1.RESERVED_EVENTS = new Set([
            "connect",
            "connect_error",
            "disconnect",
            "disconnecting",
            "newListener",
            "removeListener"
        ]);
    },
    "../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/socket.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
                default: mod
            };
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.Socket = void 0;
        const socket_io_parser_1 = __webpack_require__("../node_modules/.pnpm/socket.io-parser@4.2.4/node_modules/socket.io-parser/build/cjs/index.js");
        const debug_1 = __importDefault(__webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js"));
        const typed_events_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/typed-events.js");
        const base64id_1 = __importDefault(__webpack_require__("../node_modules/.pnpm/base64id@2.0.0/node_modules/base64id/lib/base64id.js"));
        const broadcast_operator_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/broadcast-operator.js");
        const socket_types_1 = __webpack_require__("../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/socket-types.js");
        const debug = (0, debug_1.default)("socket.io:socket");
        const RECOVERABLE_DISCONNECT_REASONS = new Set([
            "transport error",
            "transport close",
            "forced close",
            "ping timeout",
            "server shutting down",
            "forced server close"
        ]);
        function noop() {}
        class Socket extends typed_events_1.StrictEventEmitter {
            constructor(nsp, client, auth, previousSession){
                super();
                this.nsp = nsp;
                this.client = client;
                this.recovered = false;
                this.data = {};
                this.connected = false;
                this.acks = new Map();
                this.fns = [];
                this.flags = {};
                this.server = nsp.server;
                this.adapter = this.nsp.adapter;
                if (previousSession) {
                    this.id = previousSession.sid;
                    this.pid = previousSession.pid;
                    previousSession.rooms.forEach((room)=>this.join(room));
                    this.data = previousSession.data;
                    previousSession.missedPackets.forEach((packet)=>{
                        this.packet({
                            type: socket_io_parser_1.PacketType.EVENT,
                            data: packet
                        });
                    });
                    this.recovered = true;
                } else {
                    if (3 === client.conn.protocol) this.id = "/" !== nsp.name ? nsp.name + "#" + client.id : client.id;
                    else this.id = base64id_1.default.generateId();
                    if (this.server._opts.connectionStateRecovery) this.pid = base64id_1.default.generateId();
                }
                this.handshake = this.buildHandshake(auth);
                this.on("error", noop);
            }
            buildHandshake(auth) {
                var _a, _b, _c, _d;
                return {
                    headers: (null == (_a = this.request) ? void 0 : _a.headers) || {},
                    time: new Date() + "",
                    address: this.conn.remoteAddress,
                    xdomain: !!(null == (_b = this.request) ? void 0 : _b.headers.origin),
                    secure: !this.request || !!this.request.connection.encrypted,
                    issued: +new Date(),
                    url: null == (_c = this.request) ? void 0 : _c.url,
                    query: (null == (_d = this.request) ? void 0 : _d._query) || {},
                    auth
                };
            }
            emit(ev, ...args) {
                if (socket_types_1.RESERVED_EVENTS.has(ev)) throw new Error(`"${String(ev)}" is a reserved event name`);
                const data = [
                    ev,
                    ...args
                ];
                const packet = {
                    type: socket_io_parser_1.PacketType.EVENT,
                    data: data
                };
                if ("function" == typeof data[data.length - 1]) {
                    const id = this.nsp._ids++;
                    debug("emitting packet with ack id %d", id);
                    this.registerAckCallback(id, data.pop());
                    packet.id = id;
                }
                const flags = Object.assign({}, this.flags);
                this.flags = {};
                if (this.nsp.server.opts.connectionStateRecovery) this.adapter.broadcast(packet, {
                    rooms: new Set([
                        this.id
                    ]),
                    except: new Set(),
                    flags
                });
                else {
                    this.notifyOutgoingListeners(packet);
                    this.packet(packet, flags);
                }
                return true;
            }
            emitWithAck(ev, ...args) {
                const withErr = void 0 !== this.flags.timeout;
                return new Promise((resolve, reject)=>{
                    args.push((arg1, arg2)=>{
                        if (withErr) return arg1 ? reject(arg1) : resolve(arg2);
                        return resolve(arg1);
                    });
                    this.emit(ev, ...args);
                });
            }
            registerAckCallback(id, ack) {
                const timeout = this.flags.timeout;
                if (void 0 === timeout) return void this.acks.set(id, ack);
                const timer = setTimeout(()=>{
                    debug("event with ack id %d has timed out after %d ms", id, timeout);
                    this.acks.delete(id);
                    ack.call(this, new Error("operation has timed out"));
                }, timeout);
                this.acks.set(id, (...args)=>{
                    clearTimeout(timer);
                    ack.apply(this, [
                        null,
                        ...args
                    ]);
                });
            }
            to(room) {
                return this.newBroadcastOperator().to(room);
            }
            in(room) {
                return this.newBroadcastOperator().in(room);
            }
            except(room) {
                return this.newBroadcastOperator().except(room);
            }
            send(...args) {
                this.emit("message", ...args);
                return this;
            }
            write(...args) {
                this.emit("message", ...args);
                return this;
            }
            packet(packet, opts = {}) {
                packet.nsp = this.nsp.name;
                opts.compress = false !== opts.compress;
                this.client._packet(packet, opts);
            }
            join(rooms) {
                debug("join room %s", rooms);
                return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [
                    rooms
                ]));
            }
            leave(room) {
                debug("leave room %s", room);
                return this.adapter.del(this.id, room);
            }
            leaveAll() {
                this.adapter.delAll(this.id);
            }
            _onconnect() {
                debug("socket connected - writing packet");
                this.connected = true;
                this.join(this.id);
                if (3 === this.conn.protocol) this.packet({
                    type: socket_io_parser_1.PacketType.CONNECT
                });
                else this.packet({
                    type: socket_io_parser_1.PacketType.CONNECT,
                    data: {
                        sid: this.id,
                        pid: this.pid
                    }
                });
            }
            _onpacket(packet) {
                debug("got packet %j", packet);
                switch(packet.type){
                    case socket_io_parser_1.PacketType.EVENT:
                        this.onevent(packet);
                        break;
                    case socket_io_parser_1.PacketType.BINARY_EVENT:
                        this.onevent(packet);
                        break;
                    case socket_io_parser_1.PacketType.ACK:
                        this.onack(packet);
                        break;
                    case socket_io_parser_1.PacketType.BINARY_ACK:
                        this.onack(packet);
                        break;
                    case socket_io_parser_1.PacketType.DISCONNECT:
                        this.ondisconnect();
                        break;
                }
            }
            onevent(packet) {
                const args = packet.data || [];
                debug("emitting event %j", args);
                if (null != packet.id) {
                    debug("attaching ack callback to event");
                    args.push(this.ack(packet.id));
                }
                if (this._anyListeners && this._anyListeners.length) {
                    const listeners = this._anyListeners.slice();
                    for (const listener of listeners)listener.apply(this, args);
                }
                this.dispatch(args);
            }
            ack(id) {
                const self = this;
                let sent = false;
                return function() {
                    if (sent) return;
                    const args = Array.prototype.slice.call(arguments);
                    debug("sending ack %j", args);
                    self.packet({
                        id: id,
                        type: socket_io_parser_1.PacketType.ACK,
                        data: args
                    });
                    sent = true;
                };
            }
            onack(packet) {
                const ack = this.acks.get(packet.id);
                if ("function" == typeof ack) {
                    debug("calling ack %s with %j", packet.id, packet.data);
                    ack.apply(this, packet.data);
                    this.acks.delete(packet.id);
                } else debug("bad ack %s", packet.id);
            }
            ondisconnect() {
                debug("got disconnect packet");
                this._onclose("client namespace disconnect");
            }
            _onerror(err) {
                this.emitReserved("error", err);
            }
            _onclose(reason, description) {
                if (!this.connected) return this;
                debug("closing socket - reason %s", reason);
                this.emitReserved("disconnecting", reason, description);
                if (this.server._opts.connectionStateRecovery && RECOVERABLE_DISCONNECT_REASONS.has(reason)) {
                    debug("connection state recovery is enabled for sid %s", this.id);
                    this.adapter.persistSession({
                        sid: this.id,
                        pid: this.pid,
                        rooms: [
                            ...this.rooms
                        ],
                        data: this.data
                    });
                }
                this._cleanup();
                this.client._remove(this);
                this.connected = false;
                this.emitReserved("disconnect", reason, description);
            }
            _cleanup() {
                this.leaveAll();
                this.nsp._remove(this);
                this.join = noop;
            }
            _error(err) {
                this.packet({
                    type: socket_io_parser_1.PacketType.CONNECT_ERROR,
                    data: err
                });
            }
            disconnect(close = false) {
                if (!this.connected) return this;
                if (close) this.client._disconnect();
                else {
                    this.packet({
                        type: socket_io_parser_1.PacketType.DISCONNECT
                    });
                    this._onclose("server namespace disconnect");
                }
                return this;
            }
            compress(compress) {
                this.flags.compress = compress;
                return this;
            }
            get volatile() {
                this.flags.volatile = true;
                return this;
            }
            get broadcast() {
                return this.newBroadcastOperator();
            }
            get local() {
                return this.newBroadcastOperator().local;
            }
            timeout(timeout) {
                this.flags.timeout = timeout;
                return this;
            }
            dispatch(event) {
                debug("dispatching an event %j", event);
                this.run(event, (err)=>{
                    process.nextTick(()=>{
                        if (err) return this._onerror(err);
                        if (this.connected) super.emitUntyped.apply(this, event);
                        else debug("ignore packet received after disconnection");
                    });
                });
            }
            use(fn) {
                this.fns.push(fn);
                return this;
            }
            run(event, fn) {
                if (!this.fns.length) return fn();
                const fns = this.fns.slice(0);
                function run(i) {
                    fns[i](event, (err)=>{
                        if (err) return fn(err);
                        if (!fns[i + 1]) return fn();
                        run(i + 1);
                    });
                }
                run(0);
            }
            get disconnected() {
                return !this.connected;
            }
            get request() {
                return this.client.request;
            }
            get conn() {
                return this.client.conn;
            }
            get rooms() {
                return this.adapter.socketRooms(this.id) || new Set();
            }
            onAny(listener) {
                this._anyListeners = this._anyListeners || [];
                this._anyListeners.push(listener);
                return this;
            }
            prependAny(listener) {
                this._anyListeners = this._anyListeners || [];
                this._anyListeners.unshift(listener);
                return this;
            }
            offAny(listener) {
                if (!this._anyListeners) return this;
                if (listener) {
                    const listeners = this._anyListeners;
                    for(let i = 0; i < listeners.length; i++)if (listener === listeners[i]) {
                        listeners.splice(i, 1);
                        break;
                    }
                } else this._anyListeners = [];
                return this;
            }
            listenersAny() {
                return this._anyListeners || [];
            }
            onAnyOutgoing(listener) {
                this._anyOutgoingListeners = this._anyOutgoingListeners || [];
                this._anyOutgoingListeners.push(listener);
                return this;
            }
            prependAnyOutgoing(listener) {
                this._anyOutgoingListeners = this._anyOutgoingListeners || [];
                this._anyOutgoingListeners.unshift(listener);
                return this;
            }
            offAnyOutgoing(listener) {
                if (!this._anyOutgoingListeners) return this;
                if (listener) {
                    const listeners = this._anyOutgoingListeners;
                    for(let i = 0; i < listeners.length; i++)if (listener === listeners[i]) {
                        listeners.splice(i, 1);
                        break;
                    }
                } else this._anyOutgoingListeners = [];
                return this;
            }
            listenersAnyOutgoing() {
                return this._anyOutgoingListeners || [];
            }
            notifyOutgoingListeners(packet) {
                if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
                    const listeners = this._anyOutgoingListeners.slice();
                    for (const listener of listeners)listener.apply(this, packet.data);
                }
            }
            newBroadcastOperator() {
                const flags = Object.assign({}, this.flags);
                this.flags = {};
                return new broadcast_operator_1.BroadcastOperator(this.adapter, new Set(), new Set([
                    this.id
                ]), flags);
            }
        }
        exports1.Socket = Socket;
    },
    "../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/typed-events.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.StrictEventEmitter = void 0;
        const events_1 = __webpack_require__("events");
        class StrictEventEmitter extends events_1.EventEmitter {
            on(ev, listener) {
                return super.on(ev, listener);
            }
            once(ev, listener) {
                return super.once(ev, listener);
            }
            emit(ev, ...args) {
                return super.emit(ev, ...args);
            }
            emitReserved(ev, ...args) {
                return super.emit(ev, ...args);
            }
            emitUntyped(ev, ...args) {
                return super.emit(ev, ...args);
            }
            listeners(event) {
                return super.listeners(event);
            }
        }
        exports1.StrictEventEmitter = StrictEventEmitter;
    },
    "../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/dist/uws.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
                default: mod
            };
        };
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.patchAdapter = patchAdapter;
        exports1.restoreAdapter = restoreAdapter;
        exports1.serveFile = serveFile;
        const socket_io_adapter_1 = __webpack_require__("../node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/index.js");
        const fs_1 = __webpack_require__("fs");
        const debug_1 = __importDefault(__webpack_require__("../node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js"));
        const debug = (0, debug_1.default)("socket.io:adapter-uws");
        const SEPARATOR = "\x1f";
        const { addAll, del, broadcast } = socket_io_adapter_1.Adapter.prototype;
        function patchAdapter(app) {
            socket_io_adapter_1.Adapter.prototype.addAll = function(id, rooms) {
                const isNew = !this.sids.has(id);
                addAll.call(this, id, rooms);
                const socket = this.nsp.sockets.get(id) || this.nsp._preConnectSockets.get(id);
                if (!socket) return;
                if ("websocket" === socket.conn.transport.name) return void subscribe(this.nsp.name, socket, isNew, rooms);
                if (isNew) socket.conn.on("upgrade", ()=>{
                    const rooms = this.sids.get(id);
                    if (rooms) subscribe(this.nsp.name, socket, isNew, rooms);
                });
            };
            socket_io_adapter_1.Adapter.prototype.del = function(id, room) {
                del.call(this, id, room);
                const socket = this.nsp.sockets.get(id) || this.nsp._preConnectSockets.get(id);
                if (socket && "websocket" === socket.conn.transport.name) {
                    const sessionId = socket.conn.id;
                    const websocket = socket.conn.transport.socket;
                    const topic = `${this.nsp.name}${SEPARATOR}${room}`;
                    debug("unsubscribe connection %s from topic %s", sessionId, topic);
                    websocket.unsubscribe(topic);
                }
            };
            socket_io_adapter_1.Adapter.prototype.broadcast = function(packet, opts) {
                const useFastPublish = opts.rooms.size <= 1 && 0 === opts.except.size;
                if (!useFastPublish) return void broadcast.call(this, packet, opts);
                const flags = opts.flags || {};
                const basePacketOpts = {
                    preEncoded: true,
                    volatile: flags.volatile,
                    compress: flags.compress
                };
                packet.nsp = this.nsp.name;
                const encodedPackets = this.encoder.encode(packet);
                const topic = 0 === opts.rooms.size ? this.nsp.name : `${this.nsp.name}${SEPARATOR}${opts.rooms.keys().next().value}`;
                debug("fast publish to %s", topic);
                encodedPackets.forEach((encodedPacket)=>{
                    const isBinary = "string" != typeof encodedPacket;
                    app.publish(topic, isBinary ? encodedPacket : "4" + encodedPacket, isBinary);
                });
                this.apply(opts, (socket)=>{
                    if ("websocket" !== socket.conn.transport.name) socket.client.writeToEngine(encodedPackets, basePacketOpts);
                });
            };
        }
        function subscribe(namespaceName, socket, isNew, rooms) {
            const sessionId = socket.conn.id;
            const websocket = socket.conn.transport.socket;
            if (isNew) {
                debug("subscribe connection %s to topic %s", sessionId, namespaceName);
                websocket.subscribe(namespaceName);
            }
            rooms.forEach((room)=>{
                const topic = `${namespaceName}${SEPARATOR}${room}`;
                debug("subscribe connection %s to topic %s", sessionId, topic);
                websocket.subscribe(topic);
            });
        }
        function restoreAdapter() {
            socket_io_adapter_1.Adapter.prototype.addAll = addAll;
            socket_io_adapter_1.Adapter.prototype.del = del;
            socket_io_adapter_1.Adapter.prototype.broadcast = broadcast;
        }
        const toArrayBuffer = (buffer)=>{
            const { buffer: arrayBuffer, byteOffset, byteLength } = buffer;
            return arrayBuffer.slice(byteOffset, byteOffset + byteLength);
        };
        function serveFile(res, filepath) {
            const { size } = (0, fs_1.statSync)(filepath);
            const readStream = (0, fs_1.createReadStream)(filepath);
            const destroyReadStream = ()=>!readStream.destroyed && readStream.destroy();
            const onError = (error)=>{
                destroyReadStream();
                throw error;
            };
            const onDataChunk = (chunk)=>{
                const arrayBufferChunk = toArrayBuffer(chunk);
                res.cork(()=>{
                    const lastOffset = res.getWriteOffset();
                    const [ok, done] = res.tryEnd(arrayBufferChunk, size);
                    if (!done && !ok) {
                        readStream.pause();
                        res.onWritable((offset)=>{
                            const [ok, done] = res.tryEnd(arrayBufferChunk.slice(offset - lastOffset), size);
                            if (!done && ok) readStream.resume();
                            return ok;
                        });
                    }
                });
            };
            res.onAborted(destroyReadStream);
            readStream.on("data", onDataChunk).on("error", onError).on("end", destroyReadStream);
        }
    },
    "../node_modules/.pnpm/@agent-infra+logger@0.0.2-beta.2/node_modules/@agent-infra/logger/dist/index.mjs": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            in: ()=>types_LogLevel,
            kw: ()=>ConsoleLogger
        });
        var types_LogLevel = /*#__PURE__*/ function(LogLevel) {
            LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
            LogLevel[LogLevel["INFO"] = 1] = "INFO";
            LogLevel[LogLevel["SUCCESS"] = 2] = "SUCCESS";
            LogLevel[LogLevel["WARN"] = 3] = "WARN";
            LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
            LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
            return LogLevel;
        }({});
        class BaseLogger {
            log(...args) {}
            info(...args) {}
            warn(...args) {}
            error(...args) {}
            debug(...args) {}
            success(message) {}
            infoWithData(message, data, transformer) {}
            spawn(subPrefix) {
                return new BaseLogger();
            }
            setLevel(level) {}
            getLevel() {
                return 1;
            }
        }
        new BaseLogger();
        var _process_stdout;
        const colorize_isBrowser = 'undefined' != typeof window && void 0 !== window.document;
        const supportsColor = !colorize_isBrowser && !('NO_COLOR' in process.env || '0' === process.env.FORCE_COLOR) && (void 0 !== process.env.FORCE_COLOR || (null == (_process_stdout = process.stdout) ? void 0 : _process_stdout.isTTY));
        const ANSI_COLORS = {
            black: '\x1b[30m',
            red: '\x1b[31m',
            green: '\x1b[32m',
            yellow: '\x1b[33m',
            blue: '\x1b[34m',
            magenta: '\x1b[35m',
            cyan: '\x1b[36m',
            white: '\x1b[37m',
            gray: '\x1b[90m',
            reset: '\x1b[0m'
        };
        const ANSI_STYLES = {
            bold: '\x1b[1m',
            normal: ''
        };
        const CSS_COLOR_VALUES = {
            black: '#1E1E2E',
            red: '#F87171',
            green: '#10B981',
            yellow: '#FBBF24',
            blue: '#3B82F6',
            magenta: '#A78BFA',
            cyan: '#06B6D4',
            white: '#F3F4F6',
            gray: '#9CA3AF',
            reset: 'inherit'
        };
        const CSS_COLORS = {};
        Object.entries(CSS_COLOR_VALUES).forEach(([key, value])=>{
            CSS_COLORS[key] = `color: ${value}`;
        });
        function colorize(text, color, style = 'normal') {
            if (!text) return text;
            if (colorize_isBrowser) return text;
            if (supportsColor) {
                let result = text;
                if ('normal' !== style) result = `${ANSI_STYLES[style]}${result}`;
                result = `${ANSI_COLORS[color]}${result}`;
                return `${result}${ANSI_COLORS.reset}`;
            }
            return text;
        }
        function _define_property(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            else obj[key] = value;
            return obj;
        }
        class ConsoleLogger extends BaseLogger {
            colorPrefix(prefix, type) {
                if (!prefix) return '';
                let color = 'gray';
                switch(type){
                    case 'info':
                        color = 'blue';
                        break;
                    case 'warn':
                        color = 'yellow';
                        break;
                    case 'error':
                        color = 'red';
                        break;
                    case 'debug':
                        color = 'gray';
                        break;
                    case 'success':
                        color = 'green';
                        break;
                }
                const isBrowser = 'undefined' != typeof window && void 0 !== window.document;
                if (isBrowser) {
                    this.lastPrefixColor = color;
                    return prefix;
                }
                return colorize(prefix, color, 'bold');
            }
            log(...args) {
                if (this.level <= types_LogLevel.DEBUG) console.log(this.colorPrefix(this.prefix), ...args);
            }
            info(...args) {
                if (this.level <= types_LogLevel.INFO) {
                    const prefix = this.colorPrefix(this.prefix, 'info');
                    if ('undefined' != typeof window && this.lastPrefixColor) {
                        console.log(`%c${prefix}%c`, `color: ${CSS_COLOR_VALUES[this.lastPrefixColor]}; font-weight: bold`, 'color: inherit', ...args);
                        this.lastPrefixColor = null;
                    } else console.log(`${prefix}`, ...args);
                }
            }
            warn(...args) {
                if (this.level <= types_LogLevel.WARN) {
                    const prefix = this.colorPrefix(this.prefix, 'warn');
                    if ('undefined' != typeof window && this.lastPrefixColor) {
                        console.warn(`%c${prefix}%c`, `color: ${CSS_COLOR_VALUES[this.lastPrefixColor]}; font-weight: bold`, 'color: inherit', ...args);
                        this.lastPrefixColor = null;
                    } else console.warn(`${prefix}`, ...args);
                }
            }
            error(...args) {
                if (this.level <= types_LogLevel.ERROR) {
                    const prefix = this.colorPrefix(this.prefix, 'error');
                    if ('undefined' != typeof window && this.lastPrefixColor) {
                        console.error(`%c${prefix}%c`, `color: ${CSS_COLOR_VALUES[this.lastPrefixColor]}; font-weight: bold`, 'color: inherit', ...args);
                        this.lastPrefixColor = null;
                    } else console.error(`${prefix}`, ...args);
                }
            }
            success(message) {
                if (this.level <= types_LogLevel.SUCCESS) {
                    const prefix = this.colorPrefix(this.prefix, 'success');
                    if ('undefined' != typeof window && this.lastPrefixColor) {
                        console.log(`%c${prefix}%c ${message}`, `color: ${CSS_COLOR_VALUES[this.lastPrefixColor]}; font-weight: bold`, 'color: inherit');
                        this.lastPrefixColor = null;
                    } else console.log(`${prefix} ${message}`);
                }
            }
            debug(...args) {
                if (this.level <= types_LogLevel.DEBUG) {
                    const prefix = this.colorPrefix(this.prefix, 'debug');
                    if ('undefined' != typeof window && this.lastPrefixColor) {
                        console.debug(`%c${prefix}%c`, `color: ${CSS_COLOR_VALUES[this.lastPrefixColor]}; font-weight: bold`, 'color: inherit', ...args);
                        this.lastPrefixColor = null;
                    } else console.debug(`${prefix}`, ...args);
                }
            }
            infoWithData(message, data, transformer) {
                if (this.level <= types_LogLevel.INFO) {
                    this.info(message);
                    if (data) console.log(transformer ? transformer(data) : data);
                }
            }
            spawn(prefix) {
                const newPrefix = this.prefix ? `${this.prefix}:${prefix}` : prefix;
                return new ConsoleLogger(newPrefix, this.level);
            }
            setLevel(level) {
                this.level = level;
            }
            getLevel() {
                return this.level;
            }
            constructor(prefix = '', level = types_LogLevel.INFO){
                super(), _define_property(this, "prefix", void 0), _define_property(this, "lastPrefixColor", null), _define_property(this, "level", types_LogLevel.INFO);
                this.prefix = prefix;
                this.level = level;
            }
        }
    },
    "../node_modules/.pnpm/@socket.io+component-emitter@3.1.2/node_modules/@socket.io/component-emitter/lib/esm/index.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, {
            Emitter: ()=>Emitter
        });
        function Emitter(obj) {
            if (obj) return mixin(obj);
        }
        function mixin(obj) {
            for(var key in Emitter.prototype)obj[key] = Emitter.prototype[key];
            return obj;
        }
        Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
            this._callbacks = this._callbacks || {};
            (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
            return this;
        };
        Emitter.prototype.once = function(event, fn) {
            function on() {
                this.off(event, on);
                fn.apply(this, arguments);
            }
            on.fn = fn;
            this.on(event, on);
            return this;
        };
        Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
            this._callbacks = this._callbacks || {};
            if (0 == arguments.length) {
                this._callbacks = {};
                return this;
            }
            var callbacks = this._callbacks['$' + event];
            if (!callbacks) return this;
            if (1 == arguments.length) {
                delete this._callbacks['$' + event];
                return this;
            }
            var cb;
            for(var i = 0; i < callbacks.length; i++){
                cb = callbacks[i];
                if (cb === fn || cb.fn === fn) {
                    callbacks.splice(i, 1);
                    break;
                }
            }
            if (0 === callbacks.length) delete this._callbacks['$' + event];
            return this;
        };
        Emitter.prototype.emit = function(event) {
            this._callbacks = this._callbacks || {};
            var args = new Array(arguments.length - 1), callbacks = this._callbacks['$' + event];
            for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
            if (callbacks) {
                callbacks = callbacks.slice(0);
                for(var i = 0, len = callbacks.length; i < len; ++i)callbacks[i].apply(this, args);
            }
            return this;
        };
        Emitter.prototype.emitReserved = Emitter.prototype.emit;
        Emitter.prototype.listeners = function(event) {
            this._callbacks = this._callbacks || {};
            return this._callbacks['$' + event] || [];
        };
        Emitter.prototype.hasListeners = function(event) {
            return !!this.listeners(event).length;
        };
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/big5-added.json": function(module) {
        "use strict";
        module.exports = JSON.parse('[["8740",""],["8767",""],["87a1",""],["8840","",4,""],["88a1",""],["8940",""],["8943",""],["8946",""],["894c",""],["89a1",""],["89ab",""],["89b0",""],["89b5",""],["89c1",""],["89c5",""],["8a40",""],["8a43",""],["8a64",""],["8a76",""],["8aa1",""],["8aac",""],["8ab2",""],["8abb",""],["8ac9",""],["8ace",""],["8adf",""],["8af6",""],["8b40",""],["8b55",""],["8ba1",""],["8bde",""],["8c40",""],["8ca1",""],["8ca7",""],["8cc9",""],["8cce",""],["8ce6",""],["8d40",""],["8d42",""],["8da1",""],["8e40",""],["8ea1",""],["8f40",""],["8fa1",""],["9040",""],["90a1",""],["9140",""],["91a1",""],["9240",""],["92a1",""],["9340",""],["93a1",""],["9440",""],["94a1",""],["9540",""],["95a1",""],["9640",""],["96a1",""],["9740",""],["97a1",""],["9840",""],["98a1",""],["9940",""],["99a1",""],["9a40",""],["9aa1",""],["9b40",""],["9b62",""],["9ba1",""],["9c40",""],["9ca1",""],["9d40",""],["9da1",""],["9e40",""],["9ea1",""],["9ead",""],["9ec5",""],["9ef5",""],["9f40",""],["9f4f",""],["9fa1",""],["9fae",""],["9fb2",""],["9fc1",""],["9fc9",""],["9fdb",""],["9fe7",""],["9feb",""],["9ff0",""],["a040",""],["a055",""],["a058",""],["a05b",""],["a063",""],["a073",""],["a0a1",""],["a0a6",""],["a0ae",""],["a0b0",""],["a0d4",""],["a0e2",""],["a3c0","",31,""],["c6a1","",9,"",9,"",9,"",23],["c740","",58,""],["c7a1","",81,"",5,"",4],["c840","",26,"",25,""],["c8a1",""],["c8cd",""],["c8f5",""],["f9fe",""],["fa40",""],["faa1",""],["fb40",""],["fba1",""],["fc40",""],["fca1",""],["fd40",""],["fda1",""],["fe40",""],["fea1",""]]');
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp936.json": function(module) {
        "use strict";
        module.exports = JSON.parse('[["0","\\u0000",127,""],["8140","",5,"",9,"",6,""],["8180","",6,"",4,"",4,"",5,""],["8240","",4,"",8,"",4,"",11],["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],["8340","",17,"",5,"",10,"",4,"",9,""],["8380","",5,"",13,"",28,"",4,"",4,"",5],["8440","",5,"",5,""],["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],["8540","",9,""],["8580","",4,"",6,"",4,"",4,"",7,""],["8640","",4,"",5,"",4,"",5,""],["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],["8740","",7,"",11,"",4,"",4],["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],["8840","",9,"",4,"",4,""],["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],["8940","",5,"",6,"",4,"",5,"",4,"",16,""],["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],["8a40","",4,"",12,""],["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],["8b40","",8,"",17,"",6,"",13,""],["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],["8c40","",7,""],["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],["8d40","",5,"",5,"",5,"",6,"",9,"",4],["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],["8e40","",21,"",12,"",6,"",12,""],["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],["8f40","",5,"",11,"",8,""],["8f80","",6,"",14,"",5,"",5,"",4,""],["9040","",4,"",4,"",6,""],["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],["9140","",6,"",6,"",18,"",4,""],["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],["9240","",6,"",5,""],["9280","",5,"",7,"",6,""],["9340","",6,"",4,"",4,"",5,""],["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],["9440","",24,"",7,"",7,"",4,"",8],["9480","",4,"",4,"",14,"",7,"",7,""],["9540","",4,"",4,"",6,""],["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],["9640","",5,"",4,""],["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],["9740","",7,"",8,"",7,"",9,""],["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],["9840","",4,"",5,"",9,""],["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],["9980","",114,"",6],["9a40","",11,"",7,"",13,""],["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],["9b40","",4,""],["9b80","",5,"",4,"",4,"",5,""],["9c40","",7,""],["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],["9d40","",7,"",4,"",9,"",6,""],["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],["9e40","",7,"",32,"",7,"",6,"",6],["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],["9f40","",6,"",10,"",4,"",10,"",7,""],["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],["a040","",9,"",5,"",9,"",11,"",19],["a080","",9,"",6,"",4,"",11,"",11,"",6,""],["a1a1","",7,""],["a2a1","",9],["a2b1","",19,"",19,"",9],["a2e5","",9],["a2f1","",11],["a3a1","",88,""],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a6e0",""],["a6ee",""],["a6f4",""],["a7a1","",5,"",25],["a7d1","",5,"",25],["a840","",35,"",6],["a880","",7,""],["a8a1",""],["a8bd",""],["a8c0",""],["a8c5","",36],["a940","",8,""],["a959",""],["a95c",""],["a960","",9,"",8],["a980","",4,""],["a996",""],["a9a4","",75],["aa40","",5,"",5,"",8],["aa80","",7,"",10,""],["ab40","",11,"",4,"",5,"",4],["ab80","",6,"",4],["ac40","",10,"",8,"",5,"",4,"",11],["ac80","",6,"",12,"",4,""],["ad40","",10,"",7,"",15,"",12],["ad80","",9,"",8,"",6,""],["ae40","",6,"",7,"",4,""],["ae80","",7,"",6,"",4,""],["af40","",4,""],["af80",""],["b040","",6,"",5,"",4,"",6,"",7,""],["b080","",7,"",8,"",9,""],["b140","",4,"",7,"",10,""],["b180","",4,"",7,"",7,""],["b240","",11,"",5,"",11,"",4],["b280","",12,"",8,"",4,""],["b340","",5,""],["b380","",11,"",7,"",6,""],["b440","",7,"",9],["b480","",4,"",5,"",6,""],["b540","",5,"",9,"",4,"",14,"",4,"",8,""],["b580","",6,"",4,""],["b640","",6,"",11,"",10,"",4,"",5,""],["b680","",6,"",4,""],["b740","",14,"",5,"",9,"",4,"",16],["b780","",6,""],["b840","",4,"",10,"",10,"",9,"",5,""],["b880","",4,""],["b940","",5,"",10,"",6,""],["b980","",7,""],["ba40","",4,"",4,"",7,"",5,""],["ba80","",4,"",5,"",12,"",5,""],["bb40","",9,"",36,"",5,"",9],["bb80","",6,"",4,""],["bc40","",6,"",6,"",5,"",7,"",13,"",5],["bc80","",14,"",6,""],["bd40","",54,"",7],["bd80","",32,""],["be40","",12,"",6,"",42],["be80","",32,""],["bf40","",62],["bf80","",4,"",4,"",21,""],["c040","",35,"",23,""],["c080","",6,"",9,""],["c140","",4,"",7,"",4,"",4,"",6,""],["c180","",4,"",4,"",5,""],["c240","",6,"",5,""],["c280","",13,"",5,"",11,""],["c340","",5,"",4,"",6,""],["c380","",12,"",4,""],["c440","",5,"",4,"",4,"",5,"",4,""],["c480","",7,"",5,"",6,""],["c540","",14,"",4,"",5,"",4,"",5,""],["c580","",7,"",7,""],["c640",""],["c680","",4,"",9,""],["c740","",4,"",4,"",6,"",6,"",6,""],["c780",""],["c840","",4,"",5,"",5,"",7,"",5,"",7,""],["c880","",6,"",4,"",4,""],["c940","",4,"",7,"",12,""],["c980","",4,"",4,"",10,""],["ca40","",8,"",8,"",9,"",4,"",10],["ca80","",4,"",8,""],["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],["cb80","",5,"",6,"",14,""],["cc40","",4,"",10,"",15,"",13,""],["cc80","",11,"",4,"",7,""],["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],["cd80",""],["ce40","",6,"",5,"",7,""],["ce80","",4,"",6,"",4,""],["cf40","",4,"",4,"",6,"",9],["cf80","",5,"",7,"",4,""],["d040","",13,"",5,"",5,"",5,"",6,""],["d080","",4,"",4,"",5,""],["d140","",4,"",4,"",6,"",5],["d180","",4,"",4,"",4,""],["d240","",8,"",24,"",5,"",19,""],["d280","",26,""],["d340","",30,"",6],["d380","",4,"",5,"",21,""],["d440","",31,"",8,"",21],["d480","",25,"",6,""],["d540","",7,"",7,"",46],["d580","",32,""],["d640","",34,"",27],["d680","",30,""],["d740","",31,"",4,"",25],["d780","",24,""],["d840","",8,"",7,"",5,"",6,"",6,"",6,""],["d880","",6,"",20,""],["d940","",62],["d980","",32,""],["da40","",14,"",8,"",4,"",9,""],["da80","",12,""],["db40","",6,"",7,"",4,""],["db80","",4,"",5,"",11,""],["dc40","",4,"",6,"",6,"",11,"",6,"",7],["dc80","",10,"",21,""],["dd40","",62],["dd80","",32,""],["de40","",32,""],["de80","",4,""],["df40","",5,"",4,"",4,"",5,"",4,"",6,""],["df80","",4,""],["e040","",19,""],["e080","",10,"",6,"",8,""],["e140","",4,"",6,"",5,"",5,""],["e180","",10,"",9,"",8,""],["e240","",62],["e280","",32,"",5,""],["e340","",45,"",16],["e380","",7,"",24,""],["e440","",5,"",24,"",31],["e480","",32,""],["e540","",51,"",10],["e580","",31,""],["e640","",34,"",27],["e680","",29,""],["e740","",7,"",54],["e780","",32,"",6,"",4,""],["e840","",14,"",43,""],["e880","",20,""],["e940","",7,"",42],["e980","",32,""],["ea40","",27,"",6,""],["ea80","",4,"",12,""],["eb40","",9,"",7,"",9,"",6,""],["eb80","",4,""],["ec40","",8,"",4,"",18,"",7],["ec80","",4,"",7,"",4,"",4,""],["ed40","",6,"",46],["ed80","",4,"",23,""],["ee40","",62],["ee80","",32,"",4,"",6,""],["ef40","",5,"",37,"",4],["ef80","",30,"",4,"",8,""],["f040","",4,"",28,"",26],["f080","",9,"",12,"",4,"",6,""],["f140","",10,"",47],["f180","",32,""],["f240","",62],["f280","",32,""],["f340","",17,"",6,"",4,""],["f380","",8,"",6,""],["f440","",5,"",10,"",10,"",7,"",5],["f480","",32,""],["f540","",62],["f580","",32,""],["f640","",62],["f680","",32,"",5,"",5,"",4,"",7,""],["f740","",62],["f780","",4,"",4,""],["f840","",62],["f880","",32],["f940","",62],["f980","",32],["fa40","",62],["fa80","",32],["fb40","",27,"",9,""],["fb80","",5,"",8,"",5,""],["fc40","",8,"",4,"",8,"",6],["fc80","",4,"",5,"",8,""],["fd40","",4,"",4,"",10,"",38],["fd80","",5,"",11,"",4,""],["fe40",""]]');
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp949.json": function(module) {
        "use strict";
        module.exports = JSON.parse('[["0","\\u0000",127],["8141","",4,"",6,""],["8161","",9,"",5,""],["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],["8241","",7,"",5],["8261","",6,"",5,""],["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],["8341","",5,"",5,"",7],["8361","",18,""],["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],["8441","",5,"",8],["8461","",18],["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],["8541","",5,"",4,"",6,"",4],["8561","",5,"",5,"",6,""],["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],["8641","",6,"",5,""],["8661","",6,"",10],["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],["8741","",9,"",15],["8761","",18,""],["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],["8841","",4,"",5,"",6,"",4],["8861","",4,""],["8881","",15,"",4,"",6,"",5,"",54,""],["8941","",6,"",5,""],["8961","",10,"",5,""],["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],["8a41","",10,"",6,""],["8a61","",4,"",18,""],["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],["8b41","",5,"",4,"",6,""],["8b61","",6,"",8],["8b81","",52,"",4,"",6,"",5,"",18,"",18],["8c41","",15,"",4],["8c61","",6,"",5,"",6,"",5],["8c81","",12,"",26,"",50,"",5,"",16],["8d41","",16,"",8],["8d61","",17,""],["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],["8e41","",6,"",5,"",8],["8e61","",4,"",19],["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],["8f41","",7,"",17],["8f61","",7,"",6,"",4],["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],["9041","",6,"",5,""],["9061","",5,"",15],["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],["9141","",6,"",5],["9161","",9,"",5],["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],["9241","",7,"",4,""],["9261","",7,"",7,"",4],["9281","",21,"",18,"",6,"",7,"",6,"",35,""],["9341","",4,""],["9361","",6,"",8],["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],["9441","",5,"",5,"",8],["9461","",5,"",6,"",12],["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],["9541","",11,"",5,""],["9561","",6,"",5,""],["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],["9641","",23,""],["9661","",6,"",5,"",8],["9681","",10,"",5,"",13,"",33,"",6,"",44],["9741","",16,"",8],["9761","",17,"",7],["9781","",11,"",5,"",6,"",89,""],["9841","",16,"",5,""],["9861","",6,"",15],["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],["9941","",6,"",5,""],["9961","",6,"",5,""],["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],["9a41","",16],["9a61","",6,"",6,""],["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],["9b41","",6,"",8],["9b61","",17,"",7],["9b81","",25,"",4,"",5,"",50,"",22,""],["9c41","",4,"",5,"",5],["9c61","",8,"",6,"",9],["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],["9d41","",13,"",8],["9d61","",25],["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],["9e41","",7,"",9,""],["9e61","",4,"",6,""],["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],["9f41","",5,"",4,"",5,""],["9f61","",6,"",5,""],["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],["a041","",5,"",6,""],["a061","",5,"",13],["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],["a141","",18,""],["a161","",6,"",5,""],["a181","",14,"",5,"",4,"",9,""],["a241","",5,"",18],["a261","",6,"",18],["a281","",7,"",6,"",7,""],["a341","",6,"",10,""],["a361","",6,"",16],["a381","",16,"",4,"",58,"",32,""],["a441","",5,""],["a461","",5,"",12],["a481","",28,"",93],["a541","",4,"",6,"",5,""],["a561","",17,"",5,""],["a581","",16,"",14,"",9],["a5b0","",9],["a5c1","",16,"",6],["a5e1","",16,"",6],["a641","",19,""],["a661","",5,"",5,"",6],["a681","",6,"",18,"",7],["a741","",4,"",6,"",7],["a761","",22,""],["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],["a841","",10,"",14],["a861","",18,"",6],["a881","",19,"",11,""],["a8a6",""],["a8a8",""],["a8b1","",27,"",25,"",14,""],["a941","",14,"",10],["a961","",18],["a981","",14,"",6,"",27,"",25,"",14,""],["aa41","",6,"",4,""],["aa61","",4,"",5,"",6,""],["aa81","",29,"",82],["ab41","",6,"",5,""],["ab61","",6,"",5,"",5],["ab81","",8,"",6,"",12,"",85],["ac41","",5,"",6,""],["ac61","",11,"",4],["ac81","",28,"",5,"",25],["acd1","",5,"",25],["ad41","",6,"",5,"",7],["ad61","",6,"",10,""],["ad81","",5,"",18,""],["ae41","",5,"",16],["ae61","",5,"",6,"",4],["ae81","",6,"",5,""],["af41","",19],["af61","",13,"",5,""],["af81","",5,"",6,"",5,""],["b041","",5,"",5,"",12],["b061","",5,"",19],["b081","",13,"",6,"",5,"",7,"",4,""],["b141","",6,"",5,""],["b161","",6,"",5,"",11],["b181","",14,"",6,""],["b241","",6,"",5,""],["b261","",18,"",5,""],["b281","",5,"",18,"",6,""],["b341","",19,""],["b361","",5,"",5,"",5],["b381","",5,"",5,"",19,"",4,""],["b441","",5,"",6,"",5],["b461","",6,"",10,""],["b481","",6,"",18,"",4,"",4,""],["b541","",14,"",5],["b561","",5,"",5,"",4],["b581","",6,"",5,"",11,""],["b641","",7,"",17],["b661","",15,""],["b681","",5,"",6,"",5,""],["b741","",13,"",6,""],["b761","",20,""],["b781","",6,"",14,""],["b841","",7,"",17],["b861","",8,"",13],["b881","",5,"",24,"",4,""],["b941","",6,"",5,""],["b961","",14,"",6,""],["b981","",22,"",4,"",4,""],["ba41","",5,"",6,""],["ba61","",5,"",4,"",5],["ba81","",6,"",9,""],["bb41","",4,"",5,"",4,""],["bb61","",6,"",5,""],["bb81","",31,""],["bc41","",17,""],["bc61","",5,"",6,""],["bc81","",4,"",6,"",5,"",5,"",4,""],["bd41","",7,"",7,""],["bd61","",5,"",13],["bd81","",5,"",25,""],["be41","",7,"",14],["be61","",7,"",7,""],["be81","",4,"",4,"",5,"",8,"",6,""],["bf41","",10,"",14],["bf61","",18,""],["bf81","",5,"",7,"",6,"",5,""],["c041","",5,"",6,"",5],["c061","",25],["c081","",6,"",5,"",7,""],["c141","",5,"",6,""],["c161","",19,""],["c181","",31,""],["c241","",4,"",5,""],["c261","",4,"",5,"",6,""],["c281","",5,"",7,"",9,""],["c341","",4],["c361","",4,"",5,"",11],["c381","",5,"",7,"",5,""],["c441","",7,"",7,""],["c461","",5,"",4],["c481","",5,"",11,""],["c541","",6,"",5,""],["c561","",6,"",5,"",4],["c581","",6,"",5,""],["c641","",6,"",5],["c6a1",""],["c7a1",""],["c8a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1","",5,"",4,""],["d2a1","",4,"",5,"",10,"",7,"",5,""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f5a1",""],["f6a1",""],["f7a1",""],["f8a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fda1",""]]');
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/cp950.json": function(module) {
        "use strict";
        module.exports = JSON.parse('[["0","\\u0000",127],["a140",""],["a1a1","",4,""],["a240","",7,""],["a2a1","",9,"",9,"",8,"",25,"",21],["a340","",16,"",6,"",16,"",6,"",10],["a3a1","",25,""],["a3e1",""],["a440",""],["a4a1",""],["a540",""],["a5a1",""],["a640",""],["a6a1",""],["a740",""],["a7a1",""],["a840",""],["a8a1",""],["a940",""],["a9a1",""],["aa40",""],["aaa1",""],["ab40",""],["aba1",""],["ac40",""],["aca1",""],["ad40",""],["ada1",""],["ae40",""],["aea1",""],["af40",""],["afa1",""],["b040",""],["b0a1",""],["b140",""],["b1a1",""],["b240",""],["b2a1",""],["b340",""],["b3a1",""],["b440",""],["b4a1",""],["b540",""],["b5a1",""],["b640",""],["b6a1",""],["b740",""],["b7a1",""],["b840",""],["b8a1",""],["b940",""],["b9a1",""],["ba40",""],["baa1",""],["bb40",""],["bba1",""],["bc40",""],["bca1",""],["bd40",""],["bda1",""],["be40",""],["bea1",""],["bf40",""],["bfa1",""],["c040",""],["c0a1",""],["c140",""],["c1a1",""],["c240",""],["c2a1",""],["c340",""],["c3a1",""],["c440",""],["c4a1",""],["c540",""],["c5a1",""],["c640",""],["c940",""],["c9a1",""],["ca40",""],["caa1",""],["cb40",""],["cba1",""],["cc40",""],["cca1",""],["cd40",""],["cda1",""],["ce40",""],["cea1",""],["cf40",""],["cfa1",""],["d040",""],["d0a1",""],["d140",""],["d1a1",""],["d240",""],["d2a1",""],["d340",""],["d3a1",""],["d440",""],["d4a1",""],["d540",""],["d5a1",""],["d640",""],["d6a1",""],["d740",""],["d7a1",""],["d840",""],["d8a1",""],["d940",""],["d9a1",""],["da40",""],["daa1",""],["db40",""],["dba1",""],["dc40",""],["dca1",""],["dd40",""],["dda1",""],["de40",""],["dea1",""],["df40",""],["dfa1",""],["e040",""],["e0a1",""],["e140",""],["e1a1",""],["e240",""],["e2a1",""],["e340",""],["e3a1",""],["e440",""],["e4a1",""],["e540",""],["e5a1",""],["e640",""],["e6a1",""],["e740",""],["e7a1",""],["e840",""],["e8a1",""],["e940",""],["e9a1",""],["ea40",""],["eaa1",""],["eb40",""],["eba1",""],["ec40",""],["eca1",""],["ed40",""],["eda1",""],["ee40",""],["eea1",""],["ef40",""],["efa1",""],["f040",""],["f0a1",""],["f140",""],["f1a1",""],["f240",""],["f2a1",""],["f340",""],["f3a1",""],["f440",""],["f4a1",""],["f540",""],["f5a1",""],["f640",""],["f6a1",""],["f740",""],["f7a1",""],["f840",""],["f8a1",""],["f940",""],["f9a1",""]]');
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/eucjp.json": function(module) {
        "use strict";
        module.exports = JSON.parse('[["0","\\u0000",127],["8ea1","",62],["a1a1","",9,""],["a2a1",""],["a2ba",""],["a2ca",""],["a2dc",""],["a2f2",""],["a2fe",""],["a3b0","",9],["a3c1","",25],["a3e1","",25],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a7a1","",5,"",25],["a7d1","",5,"",25],["a8a1",""],["ada1","",19,"",9],["adc0",""],["addf","",4,""],["b0a1",""],["b1a1",""],["b2a1",""],["b3a1",""],["b4a1",""],["b5a1",""],["b6a1",""],["b7a1",""],["b8a1",""],["b9a1",""],["baa1",""],["bba1",""],["bca1",""],["bda1",""],["bea1",""],["bfa1",""],["c0a1",""],["c1a1",""],["c2a1",""],["c3a1",""],["c4a1",""],["c5a1",""],["c6a1",""],["c7a1",""],["c8a1",""],["c9a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1",""],["d2a1",""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fcf1","",9,""],["8fa2af",""],["8fa2c2",""],["8fa2eb",""],["8fa6e1",""],["8fa6e7",""],["8fa6e9",""],["8fa6ec",""],["8fa6f1",""],["8fa7c2","",10,""],["8fa7f2","",10,""],["8fa9a1",""],["8fa9a4",""],["8fa9a6",""],["8fa9a8",""],["8fa9ab",""],["8fa9af",""],["8fa9c1",""],["8faaa1",""],["8faaba",""],["8faba1",""],["8fabbd",""],["8fabc5",""],["8fb0a1",""],["8fb1a1",""],["8fb2a1","",4,""],["8fb3a1",""],["8fb4a1",""],["8fb5a1",""],["8fb6a1","",5,"",4,""],["8fb7a1","",4,""],["8fb8a1",""],["8fb9a1",""],["8fbaa1","",4,""],["8fbba1",""],["8fbca1","",4,""],["8fbda1","",4,""],["8fbea1","",4,""],["8fbfa1",""],["8fc0a1",""],["8fc1a1",""],["8fc2a1",""],["8fc3a1","",4,""],["8fc4a1",""],["8fc5a1",""],["8fc6a1",""],["8fc7a1",""],["8fc8a1",""],["8fc9a1","",4,"",4,""],["8fcaa1",""],["8fcba1",""],["8fcca1","",9,""],["8fcda1","",5,""],["8fcea1","",6,""],["8fcfa1",""],["8fd0a1",""],["8fd1a1",""],["8fd2a1","",5],["8fd3a1",""],["8fd4a1","",4,""],["8fd5a1",""],["8fd6a1",""],["8fd7a1",""],["8fd8a1",""],["8fd9a1","",4,"",6,""],["8fdaa1","",4,""],["8fdba1","",6,""],["8fdca1","",4,""],["8fdda1","",4,""],["8fdea1","",4,""],["8fdfa1",""],["8fe0a1",""],["8fe1a1","",4,""],["8fe2a1",""],["8fe3a1","",5,"",4,""],["8fe4a1","",4,""],["8fe5a1","",4,""],["8fe6a1",""],["8fe7a1",""],["8fe8a1","",4,""],["8fe9a1","",4],["8feaa1","",4,""],["8feba1","",4,""],["8feca1",""],["8feda1","",4,"",4,""]]');
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json": function(module) {
        "use strict";
        module.exports = JSON.parse('{"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}');
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/gbk-added.json": function(module) {
        "use strict";
        module.exports = JSON.parse('[["a140","",62],["a180","",32],["a240","",62],["a280","",32],["a2ab","",5],["a2e3",""],["a2ef",""],["a2fd",""],["a340","",62],["a380","",31,""],["a440","",62],["a480","",32],["a4f4","",10],["a540","",62],["a580","",32],["a5f7","",7],["a640","",62],["a680","",32],["a6b9","",7],["a6d9","",6],["a6ec",""],["a6f3",""],["a6f6","",8],["a740","",62],["a780","",32],["a7c2","",14],["a7f2","",12],["a896","",10],["a8bc",""],["a8bf",""],["a8c1",""],["a8ea","",20],["a958",""],["a95b",""],["a95d",""],["a989","",11],["a997","",12],["a9f0","",14],["aaa1","",93],["aba1","",93],["aca1","",93],["ada1","",93],["aea1","",93],["afa1","",93],["d7fa","",4],["f8a1","",93],["f9a1","",93],["faa1","",93],["fba1","",93],["fca1","",93],["fda1","",93],["fe50",""],["fe80","",6,"",93]]');
    },
    "../node_modules/.pnpm/iconv-lite@0.4.24/node_modules/iconv-lite/encodings/tables/shiftjis.json": function(module) {
        "use strict";
        module.exports = JSON.parse('[["0","\\u0000",128],["a1","",62],["8140","",9,""],["8180",""],["81b8",""],["81c8",""],["81da",""],["81f0",""],["81fc",""],["824f","",9],["8260","",25],["8281","",25],["829f","",82],["8340","",62],["8380","",22],["839f","",16,"",6],["83bf","",16,"",6],["8440","",5,"",25],["8470","",5,"",7],["8480","",17],["849f",""],["8740","",19,"",9],["875f",""],["877e",""],["8780","",4,""],["889f",""],["8940",""],["8980",""],["8a40",""],["8a80",""],["8b40",""],["8b80",""],["8c40",""],["8c80",""],["8d40",""],["8d80",""],["8e40",""],["8e80",""],["8f40",""],["8f80",""],["9040",""],["9080",""],["9140",""],["9180",""],["9240",""],["9280",""],["9340",""],["9380",""],["9440",""],["9480",""],["9540",""],["9580",""],["9640",""],["9680",""],["9740",""],["9780",""],["9840",""],["989f",""],["9940",""],["9980",""],["9a40",""],["9a80",""],["9b40",""],["9b80",""],["9c40",""],["9c80",""],["9d40",""],["9d80",""],["9e40",""],["9e80",""],["9f40",""],["9f80",""],["e040",""],["e080",""],["e140",""],["e180",""],["e240",""],["e280",""],["e340",""],["e380",""],["e440",""],["e480",""],["e540",""],["e580",""],["e640",""],["e680",""],["e740",""],["e780",""],["e840",""],["e880",""],["e940",""],["e980",""],["ea40",""],["ea80",""],["ed40",""],["ed80",""],["ee40",""],["ee80",""],["eeef","",9,""],["f040","",62],["f080","",124],["f140","",62],["f180","",124],["f240","",62],["f280","",124],["f340","",62],["f380","",124],["f440","",62],["f480","",124],["f540","",62],["f580","",124],["f640","",62],["f680","",124],["f740","",62],["f780","",124],["f840","",62],["f880","",124],["f940",""],["fa40","",9,"",9,""],["fa80",""],["fb40",""],["fb80",""],["fc40",""]]');
    },
    "../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json": function(module) {
        "use strict";
        module.exports = JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');
    },
    "../node_modules/.pnpm/mime@1.6.0/node_modules/mime/types.json": function(module) {
        "use strict";
        module.exports = JSON.parse('{"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomsvc+xml":["atomsvc"],"application/bdoc":["bdoc"],"application/ccxml+xml":["ccxml"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["ecma"],"application/emma+xml":["emma"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/font-tdpfr":["pfr"],"application/font-woff":[],"application/font-woff2":[],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/patch-ops-error+xml":["xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/prs.cww":["cww"],"application/pskc+xml":["pskcxml"],"application/raml+yaml":["raml"],"application/rdf+xml":["rdf"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/vnd.3gpp.pic-bw-large":["plb"],"application/vnd.3gpp.pic-bw-small":["psb"],"application/vnd.3gpp.pic-bw-var":["pvb"],"application/vnd.3gpp2.tcap":["tcap"],"application/vnd.3m.post-it-notes":["pwn"],"application/vnd.accpac.simply.aso":["aso"],"application/vnd.accpac.simply.imp":["imp"],"application/vnd.acucobol":["acu"],"application/vnd.acucorp":["atc","acutc"],"application/vnd.adobe.air-application-installer-package+zip":["air"],"application/vnd.adobe.formscentral.fcdt":["fcdt"],"application/vnd.adobe.fxp":["fxp","fxpl"],"application/vnd.adobe.xdp+xml":["xdp"],"application/vnd.adobe.xfdf":["xfdf"],"application/vnd.ahead.space":["ahead"],"application/vnd.airzip.filesecure.azf":["azf"],"application/vnd.airzip.filesecure.azs":["azs"],"application/vnd.amazon.ebook":["azw"],"application/vnd.americandynamics.acc":["acc"],"application/vnd.amiga.ami":["ami"],"application/vnd.android.package-archive":["apk"],"application/vnd.anser-web-certificate-issue-initiation":["cii"],"application/vnd.anser-web-funds-transfer-initiation":["fti"],"application/vnd.antix.game-component":["atx"],"application/vnd.apple.installer+xml":["mpkg"],"application/vnd.apple.mpegurl":["m3u8"],"application/vnd.apple.pkpass":["pkpass"],"application/vnd.aristanetworks.swi":["swi"],"application/vnd.astraea-software.iota":["iota"],"application/vnd.audiograph":["aep"],"application/vnd.blueice.multipass":["mpm"],"application/vnd.bmi":["bmi"],"application/vnd.businessobjects":["rep"],"application/vnd.chemdraw+xml":["cdxml"],"application/vnd.chipnuts.karaoke-mmd":["mmd"],"application/vnd.cinderella":["cdy"],"application/vnd.claymore":["cla"],"application/vnd.cloanto.rp9":["rp9"],"application/vnd.clonk.c4group":["c4g","c4d","c4f","c4p","c4u"],"application/vnd.cluetrust.cartomobile-config":["c11amc"],"application/vnd.cluetrust.cartomobile-config-pkg":["c11amz"],"application/vnd.commonspace":["csp"],"application/vnd.contact.cmsg":["cdbcmsg"],"application/vnd.cosmocaller":["cmc"],"application/vnd.crick.clicker":["clkx"],"application/vnd.crick.clicker.keyboard":["clkk"],"application/vnd.crick.clicker.palette":["clkp"],"application/vnd.crick.clicker.template":["clkt"],"application/vnd.crick.clicker.wordbank":["clkw"],"application/vnd.criticaltools.wbs+xml":["wbs"],"application/vnd.ctc-posml":["pml"],"application/vnd.cups-ppd":["ppd"],"application/vnd.curl.car":["car"],"application/vnd.curl.pcurl":["pcurl"],"application/vnd.dart":["dart"],"application/vnd.data-vision.rdz":["rdz"],"application/vnd.dece.data":["uvf","uvvf","uvd","uvvd"],"application/vnd.dece.ttml+xml":["uvt","uvvt"],"application/vnd.dece.unspecified":["uvx","uvvx"],"application/vnd.dece.zip":["uvz","uvvz"],"application/vnd.denovo.fcselayout-link":["fe_launch"],"application/vnd.dna":["dna"],"application/vnd.dolby.mlp":["mlp"],"application/vnd.dpgraph":["dpg"],"application/vnd.dreamfactory":["dfac"],"application/vnd.ds-keypoint":["kpxx"],"application/vnd.dvb.ait":["ait"],"application/vnd.dvb.service":["svc"],"application/vnd.dynageo":["geo"],"application/vnd.ecowin.chart":["mag"],"application/vnd.enliven":["nml"],"application/vnd.epson.esf":["esf"],"application/vnd.epson.msf":["msf"],"application/vnd.epson.quickanime":["qam"],"application/vnd.epson.salt":["slt"],"application/vnd.epson.ssf":["ssf"],"application/vnd.eszigno3+xml":["es3","et3"],"application/vnd.ezpix-album":["ez2"],"application/vnd.ezpix-package":["ez3"],"application/vnd.fdf":["fdf"],"application/vnd.fdsn.mseed":["mseed"],"application/vnd.fdsn.seed":["seed","dataless"],"application/vnd.flographit":["gph"],"application/vnd.fluxtime.clip":["ftc"],"application/vnd.framemaker":["fm","frame","maker","book"],"application/vnd.frogans.fnc":["fnc"],"application/vnd.frogans.ltf":["ltf"],"application/vnd.fsc.weblaunch":["fsc"],"application/vnd.fujitsu.oasys":["oas"],"application/vnd.fujitsu.oasys2":["oa2"],"application/vnd.fujitsu.oasys3":["oa3"],"application/vnd.fujitsu.oasysgp":["fg5"],"application/vnd.fujitsu.oasysprs":["bh2"],"application/vnd.fujixerox.ddd":["ddd"],"application/vnd.fujixerox.docuworks":["xdw"],"application/vnd.fujixerox.docuworks.binder":["xbd"],"application/vnd.fuzzysheet":["fzs"],"application/vnd.genomatix.tuxedo":["txd"],"application/vnd.geogebra.file":["ggb"],"application/vnd.geogebra.tool":["ggt"],"application/vnd.geometry-explorer":["gex","gre"],"application/vnd.geonext":["gxt"],"application/vnd.geoplan":["g2w"],"application/vnd.geospace":["g3w"],"application/vnd.gmx":["gmx"],"application/vnd.google-apps.document":["gdoc"],"application/vnd.google-apps.presentation":["gslides"],"application/vnd.google-apps.spreadsheet":["gsheet"],"application/vnd.google-earth.kml+xml":["kml"],"application/vnd.google-earth.kmz":["kmz"],"application/vnd.grafeq":["gqf","gqs"],"application/vnd.groove-account":["gac"],"application/vnd.groove-help":["ghf"],"application/vnd.groove-identity-message":["gim"],"application/vnd.groove-injector":["grv"],"application/vnd.groove-tool-message":["gtm"],"application/vnd.groove-tool-template":["tpl"],"application/vnd.groove-vcard":["vcg"],"application/vnd.hal+xml":["hal"],"application/vnd.handheld-entertainment+xml":["zmm"],"application/vnd.hbci":["hbci"],"application/vnd.hhe.lesson-player":["les"],"application/vnd.hp-hpgl":["hpgl"],"application/vnd.hp-hpid":["hpid"],"application/vnd.hp-hps":["hps"],"application/vnd.hp-jlyt":["jlt"],"application/vnd.hp-pcl":["pcl"],"application/vnd.hp-pclxl":["pclxl"],"application/vnd.hydrostatix.sof-data":["sfd-hdstx"],"application/vnd.ibm.minipay":["mpy"],"application/vnd.ibm.modcap":["afp","listafp","list3820"],"application/vnd.ibm.rights-management":["irm"],"application/vnd.ibm.secure-container":["sc"],"application/vnd.iccprofile":["icc","icm"],"application/vnd.igloader":["igl"],"application/vnd.immervision-ivp":["ivp"],"application/vnd.immervision-ivu":["ivu"],"application/vnd.insors.igm":["igm"],"application/vnd.intercon.formnet":["xpw","xpx"],"application/vnd.intergeo":["i2g"],"application/vnd.intu.qbo":["qbo"],"application/vnd.intu.qfx":["qfx"],"application/vnd.ipunplugged.rcprofile":["rcprofile"],"application/vnd.irepository.package+xml":["irp"],"application/vnd.is-xpr":["xpr"],"application/vnd.isac.fcs":["fcs"],"application/vnd.jam":["jam"],"application/vnd.jcp.javame.midlet-rms":["rms"],"application/vnd.jisp":["jisp"],"application/vnd.joost.joda-archive":["joda"],"application/vnd.kahootz":["ktz","ktr"],"application/vnd.kde.karbon":["karbon"],"application/vnd.kde.kchart":["chrt"],"application/vnd.kde.kformula":["kfo"],"application/vnd.kde.kivio":["flw"],"application/vnd.kde.kontour":["kon"],"application/vnd.kde.kpresenter":["kpr","kpt"],"application/vnd.kde.kspread":["ksp"],"application/vnd.kde.kword":["kwd","kwt"],"application/vnd.kenameaapp":["htke"],"application/vnd.kidspiration":["kia"],"application/vnd.kinar":["kne","knp"],"application/vnd.koan":["skp","skd","skt","skm"],"application/vnd.kodak-descriptor":["sse"],"application/vnd.las.las+xml":["lasxml"],"application/vnd.llamagraphics.life-balance.desktop":["lbd"],"application/vnd.llamagraphics.life-balance.exchange+xml":["lbe"],"application/vnd.lotus-1-2-3":["123"],"application/vnd.lotus-approach":["apr"],"application/vnd.lotus-freelance":["pre"],"application/vnd.lotus-notes":["nsf"],"application/vnd.lotus-organizer":["org"],"application/vnd.lotus-screencam":["scm"],"application/vnd.lotus-wordpro":["lwp"],"application/vnd.macports.portpkg":["portpkg"],"application/vnd.mcd":["mcd"],"application/vnd.medcalcdata":["mc1"],"application/vnd.mediastation.cdkey":["cdkey"],"application/vnd.mfer":["mwf"],"application/vnd.mfmp":["mfm"],"application/vnd.micrografx.flo":["flo"],"application/vnd.micrografx.igx":["igx"],"application/vnd.mif":["mif"],"application/vnd.mobius.daf":["daf"],"application/vnd.mobius.dis":["dis"],"application/vnd.mobius.mbk":["mbk"],"application/vnd.mobius.mqy":["mqy"],"application/vnd.mobius.msl":["msl"],"application/vnd.mobius.plc":["plc"],"application/vnd.mobius.txf":["txf"],"application/vnd.mophun.application":["mpn"],"application/vnd.mophun.certificate":["mpc"],"application/vnd.mozilla.xul+xml":["xul"],"application/vnd.ms-artgalry":["cil"],"application/vnd.ms-cab-compressed":["cab"],"application/vnd.ms-excel":["xls","xlm","xla","xlc","xlt","xlw"],"application/vnd.ms-excel.addin.macroenabled.12":["xlam"],"application/vnd.ms-excel.sheet.binary.macroenabled.12":["xlsb"],"application/vnd.ms-excel.sheet.macroenabled.12":["xlsm"],"application/vnd.ms-excel.template.macroenabled.12":["xltm"],"application/vnd.ms-fontobject":["eot"],"application/vnd.ms-htmlhelp":["chm"],"application/vnd.ms-ims":["ims"],"application/vnd.ms-lrm":["lrm"],"application/vnd.ms-officetheme":["thmx"],"application/vnd.ms-outlook":["msg"],"application/vnd.ms-pki.seccat":["cat"],"application/vnd.ms-pki.stl":["stl"],"application/vnd.ms-powerpoint":["ppt","pps","pot"],"application/vnd.ms-powerpoint.addin.macroenabled.12":["ppam"],"application/vnd.ms-powerpoint.presentation.macroenabled.12":["pptm"],"application/vnd.ms-powerpoint.slide.macroenabled.12":["sldm"],"application/vnd.ms-powerpoint.slideshow.macroenabled.12":["ppsm"],"application/vnd.ms-powerpoint.template.macroenabled.12":["potm"],"application/vnd.ms-project":["mpp","mpt"],"application/vnd.ms-word.document.macroenabled.12":["docm"],"application/vnd.ms-word.template.macroenabled.12":["dotm"],"application/vnd.ms-works":["wps","wks","wcm","wdb"],"application/vnd.ms-wpl":["wpl"],"application/vnd.ms-xpsdocument":["xps"],"application/vnd.mseq":["mseq"],"application/vnd.musician":["mus"],"application/vnd.muvee.style":["msty"],"application/vnd.mynfc":["taglet"],"application/vnd.neurolanguage.nlu":["nlu"],"application/vnd.nitf":["ntf","nitf"],"application/vnd.noblenet-directory":["nnd"],"application/vnd.noblenet-sealer":["nns"],"application/vnd.noblenet-web":["nnw"],"application/vnd.nokia.n-gage.data":["ngdat"],"application/vnd.nokia.n-gage.symbian.install":["n-gage"],"application/vnd.nokia.radio-preset":["rpst"],"application/vnd.nokia.radio-presets":["rpss"],"application/vnd.novadigm.edm":["edm"],"application/vnd.novadigm.edx":["edx"],"application/vnd.novadigm.ext":["ext"],"application/vnd.oasis.opendocument.chart":["odc"],"application/vnd.oasis.opendocument.chart-template":["otc"],"application/vnd.oasis.opendocument.database":["odb"],"application/vnd.oasis.opendocument.formula":["odf"],"application/vnd.oasis.opendocument.formula-template":["odft"],"application/vnd.oasis.opendocument.graphics":["odg"],"application/vnd.oasis.opendocument.graphics-template":["otg"],"application/vnd.oasis.opendocument.image":["odi"],"application/vnd.oasis.opendocument.image-template":["oti"],"application/vnd.oasis.opendocument.presentation":["odp"],"application/vnd.oasis.opendocument.presentation-template":["otp"],"application/vnd.oasis.opendocument.spreadsheet":["ods"],"application/vnd.oasis.opendocument.spreadsheet-template":["ots"],"application/vnd.oasis.opendocument.text":["odt"],"application/vnd.oasis.opendocument.text-master":["odm"],"application/vnd.oasis.opendocument.text-template":["ott"],"application/vnd.oasis.opendocument.text-web":["oth"],"application/vnd.olpc-sugar":["xo"],"application/vnd.oma.dd2+xml":["dd2"],"application/vnd.openofficeorg.extension":["oxt"],"application/vnd.openxmlformats-officedocument.presentationml.presentation":["pptx"],"application/vnd.openxmlformats-officedocument.presentationml.slide":["sldx"],"application/vnd.openxmlformats-officedocument.presentationml.slideshow":["ppsx"],"application/vnd.openxmlformats-officedocument.presentationml.template":["potx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":["xlsx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.template":["xltx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.document":["docx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.template":["dotx"],"application/vnd.osgeo.mapguide.package":["mgp"],"application/vnd.osgi.dp":["dp"],"application/vnd.osgi.subsystem":["esa"],"application/vnd.palm":["pdb","pqa","oprc"],"application/vnd.pawaafile":["paw"],"application/vnd.pg.format":["str"],"application/vnd.pg.osasli":["ei6"],"application/vnd.picsel":["efif"],"application/vnd.pmi.widget":["wg"],"application/vnd.pocketlearn":["plf"],"application/vnd.powerbuilder6":["pbd"],"application/vnd.previewsystems.box":["box"],"application/vnd.proteus.magazine":["mgz"],"application/vnd.publishare-delta-tree":["qps"],"application/vnd.pvi.ptid1":["ptid"],"application/vnd.quark.quarkxpress":["qxd","qxt","qwd","qwt","qxl","qxb"],"application/vnd.realvnc.bed":["bed"],"application/vnd.recordare.musicxml":["mxl"],"application/vnd.recordare.musicxml+xml":["musicxml"],"application/vnd.rig.cryptonote":["cryptonote"],"application/vnd.rim.cod":["cod"],"application/vnd.rn-realmedia":["rm"],"application/vnd.rn-realmedia-vbr":["rmvb"],"application/vnd.route66.link66+xml":["link66"],"application/vnd.sailingtracker.track":["st"],"application/vnd.seemail":["see"],"application/vnd.sema":["sema"],"application/vnd.semd":["semd"],"application/vnd.semf":["semf"],"application/vnd.shana.informed.formdata":["ifm"],"application/vnd.shana.informed.formtemplate":["itp"],"application/vnd.shana.informed.interchange":["iif"],"application/vnd.shana.informed.package":["ipk"],"application/vnd.simtech-mindmapper":["twd","twds"],"application/vnd.smaf":["mmf"],"application/vnd.smart.teacher":["teacher"],"application/vnd.solent.sdkm+xml":["sdkm","sdkd"],"application/vnd.spotfire.dxp":["dxp"],"application/vnd.spotfire.sfs":["sfs"],"application/vnd.stardivision.calc":["sdc"],"application/vnd.stardivision.draw":["sda"],"application/vnd.stardivision.impress":["sdd"],"application/vnd.stardivision.math":["smf"],"application/vnd.stardivision.writer":["sdw","vor"],"application/vnd.stardivision.writer-global":["sgl"],"application/vnd.stepmania.package":["smzip"],"application/vnd.stepmania.stepchart":["sm"],"application/vnd.sun.wadl+xml":["wadl"],"application/vnd.sun.xml.calc":["sxc"],"application/vnd.sun.xml.calc.template":["stc"],"application/vnd.sun.xml.draw":["sxd"],"application/vnd.sun.xml.draw.template":["std"],"application/vnd.sun.xml.impress":["sxi"],"application/vnd.sun.xml.impress.template":["sti"],"application/vnd.sun.xml.math":["sxm"],"application/vnd.sun.xml.writer":["sxw"],"application/vnd.sun.xml.writer.global":["sxg"],"application/vnd.sun.xml.writer.template":["stw"],"application/vnd.sus-calendar":["sus","susp"],"application/vnd.svd":["svd"],"application/vnd.symbian.install":["sis","sisx"],"application/vnd.syncml+xml":["xsm"],"application/vnd.syncml.dm+wbxml":["bdm"],"application/vnd.syncml.dm+xml":["xdm"],"application/vnd.tao.intent-module-archive":["tao"],"application/vnd.tcpdump.pcap":["pcap","cap","dmp"],"application/vnd.tmobile-livetv":["tmo"],"application/vnd.trid.tpt":["tpt"],"application/vnd.triscape.mxs":["mxs"],"application/vnd.trueapp":["tra"],"application/vnd.ufdl":["ufd","ufdl"],"application/vnd.uiq.theme":["utz"],"application/vnd.umajin":["umj"],"application/vnd.unity":["unityweb"],"application/vnd.uoml+xml":["uoml"],"application/vnd.vcx":["vcx"],"application/vnd.visio":["vsd","vst","vss","vsw"],"application/vnd.visionary":["vis"],"application/vnd.vsf":["vsf"],"application/vnd.wap.wbxml":["wbxml"],"application/vnd.wap.wmlc":["wmlc"],"application/vnd.wap.wmlscriptc":["wmlsc"],"application/vnd.webturbo":["wtb"],"application/vnd.wolfram.player":["nbp"],"application/vnd.wordperfect":["wpd"],"application/vnd.wqd":["wqd"],"application/vnd.wt.stf":["stf"],"application/vnd.xara":["xar"],"application/vnd.xfdl":["xfdl"],"application/vnd.yamaha.hv-dic":["hvd"],"application/vnd.yamaha.hv-script":["hvs"],"application/vnd.yamaha.hv-voice":["hvp"],"application/vnd.yamaha.openscoreformat":["osf"],"application/vnd.yamaha.openscoreformat.osfpvg+xml":["osfpvg"],"application/vnd.yamaha.smaf-audio":["saf"],"application/vnd.yamaha.smaf-phrase":["spf"],"application/vnd.yellowriver-custom-menu":["cmp"],"application/vnd.zul":["zir","zirz"],"application/vnd.zzazz.deck+xml":["zaz"],"application/voicexml+xml":["vxml"],"application/wasm":["wasm"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/x-7z-compressed":["7z"],"application/x-abiword":["abw"],"application/x-ace-compressed":["ace"],"application/x-apple-diskimage":[],"application/x-arj":["arj"],"application/x-authorware-bin":["aab","x32","u32","vox"],"application/x-authorware-map":["aam"],"application/x-authorware-seg":["aas"],"application/x-bcpio":["bcpio"],"application/x-bdoc":[],"application/x-bittorrent":["torrent"],"application/x-blorb":["blb","blorb"],"application/x-bzip":["bz"],"application/x-bzip2":["bz2","boz"],"application/x-cbr":["cbr","cba","cbt","cbz","cb7"],"application/x-cdlink":["vcd"],"application/x-cfs-compressed":["cfs"],"application/x-chat":["chat"],"application/x-chess-pgn":["pgn"],"application/x-chrome-extension":["crx"],"application/x-cocoa":["cco"],"application/x-conference":["nsc"],"application/x-cpio":["cpio"],"application/x-csh":["csh"],"application/x-debian-package":["udeb"],"application/x-dgc-compressed":["dgc"],"application/x-director":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"],"application/x-doom":["wad"],"application/x-dtbncx+xml":["ncx"],"application/x-dtbook+xml":["dtb"],"application/x-dtbresource+xml":["res"],"application/x-dvi":["dvi"],"application/x-envoy":["evy"],"application/x-eva":["eva"],"application/x-font-bdf":["bdf"],"application/x-font-ghostscript":["gsf"],"application/x-font-linux-psf":["psf"],"application/x-font-pcf":["pcf"],"application/x-font-snf":["snf"],"application/x-font-type1":["pfa","pfb","pfm","afm"],"application/x-freearc":["arc"],"application/x-futuresplash":["spl"],"application/x-gca-compressed":["gca"],"application/x-glulx":["ulx"],"application/x-gnumeric":["gnumeric"],"application/x-gramps-xml":["gramps"],"application/x-gtar":["gtar"],"application/x-hdf":["hdf"],"application/x-httpd-php":["php"],"application/x-install-instructions":["install"],"application/x-iso9660-image":[],"application/x-java-archive-diff":["jardiff"],"application/x-java-jnlp-file":["jnlp"],"application/x-latex":["latex"],"application/x-lua-bytecode":["luac"],"application/x-lzh-compressed":["lzh","lha"],"application/x-makeself":["run"],"application/x-mie":["mie"],"application/x-mobipocket-ebook":["prc","mobi"],"application/x-ms-application":["application"],"application/x-ms-shortcut":["lnk"],"application/x-ms-wmd":["wmd"],"application/x-ms-wmz":["wmz"],"application/x-ms-xbap":["xbap"],"application/x-msaccess":["mdb"],"application/x-msbinder":["obd"],"application/x-mscardfile":["crd"],"application/x-msclip":["clp"],"application/x-msdos-program":[],"application/x-msdownload":["com","bat"],"application/x-msmediaview":["mvb","m13","m14"],"application/x-msmetafile":["wmf","emf","emz"],"application/x-msmoney":["mny"],"application/x-mspublisher":["pub"],"application/x-msschedule":["scd"],"application/x-msterminal":["trm"],"application/x-mswrite":["wri"],"application/x-netcdf":["nc","cdf"],"application/x-ns-proxy-autoconfig":["pac"],"application/x-nzb":["nzb"],"application/x-perl":["pl","pm"],"application/x-pilot":[],"application/x-pkcs12":["p12","pfx"],"application/x-pkcs7-certificates":["p7b","spc"],"application/x-pkcs7-certreqresp":["p7r"],"application/x-rar-compressed":["rar"],"application/x-redhat-package-manager":["rpm"],"application/x-research-info-systems":["ris"],"application/x-sea":["sea"],"application/x-sh":["sh"],"application/x-shar":["shar"],"application/x-shockwave-flash":["swf"],"application/x-silverlight-app":["xap"],"application/x-sql":["sql"],"application/x-stuffit":["sit"],"application/x-stuffitx":["sitx"],"application/x-subrip":["srt"],"application/x-sv4cpio":["sv4cpio"],"application/x-sv4crc":["sv4crc"],"application/x-t3vm-image":["t3"],"application/x-tads":["gam"],"application/x-tar":["tar"],"application/x-tcl":["tcl","tk"],"application/x-tex":["tex"],"application/x-tex-tfm":["tfm"],"application/x-texinfo":["texinfo","texi"],"application/x-tgif":["obj"],"application/x-ustar":["ustar"],"application/x-virtualbox-hdd":["hdd"],"application/x-virtualbox-ova":["ova"],"application/x-virtualbox-ovf":["ovf"],"application/x-virtualbox-vbox":["vbox"],"application/x-virtualbox-vbox-extpack":["vbox-extpack"],"application/x-virtualbox-vdi":["vdi"],"application/x-virtualbox-vhd":["vhd"],"application/x-virtualbox-vmdk":["vmdk"],"application/x-wais-source":["src"],"application/x-web-app-manifest+json":["webapp"],"application/x-x509-ca-cert":["der","crt","pem"],"application/x-xfig":["fig"],"application/x-xliff+xml":["xlf"],"application/x-xpinstall":["xpi"],"application/x-xz":["xz"],"application/x-zmachine":["z1","z2","z3","z4","z5","z6","z7","z8"],"application/xaml+xml":["xaml"],"application/xcap-diff+xml":["xdf"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":[],"audio/adpcm":["adp"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mp3":[],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/vnd.dece.audio":["uva","uvva"],"audio/vnd.digital-winds":["eol"],"audio/vnd.dra":["dra"],"audio/vnd.dts":["dts"],"audio/vnd.dts.hd":["dtshd"],"audio/vnd.lucent.voice":["lvp"],"audio/vnd.ms-playready.media.pya":["pya"],"audio/vnd.nuera.ecelp4800":["ecelp4800"],"audio/vnd.nuera.ecelp7470":["ecelp7470"],"audio/vnd.nuera.ecelp9600":["ecelp9600"],"audio/vnd.rip":["rip"],"audio/wav":["wav"],"audio/wave":[],"audio/webm":["weba"],"audio/x-aac":["aac"],"audio/x-aiff":["aif","aiff","aifc"],"audio/x-caf":["caf"],"audio/x-flac":["flac"],"audio/x-m4a":[],"audio/x-matroska":["mka"],"audio/x-mpegurl":["m3u"],"audio/x-ms-wax":["wax"],"audio/x-ms-wma":["wma"],"audio/x-pn-realaudio":["ram","ra"],"audio/x-pn-realaudio-plugin":["rmp"],"audio/x-realaudio":[],"audio/x-wav":[],"audio/xm":["xm"],"chemical/x-cdx":["cdx"],"chemical/x-cif":["cif"],"chemical/x-cmdf":["cmdf"],"chemical/x-cml":["cml"],"chemical/x-csml":["csml"],"chemical/x-xyz":["xyz"],"font/collection":["ttc"],"font/otf":["otf"],"font/ttf":["ttf"],"font/woff":["woff"],"font/woff2":["woff2"],"image/apng":["apng"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/g3fax":["g3"],"image/gif":["gif"],"image/ief":["ief"],"image/jp2":["jp2","jpg2"],"image/jpeg":["jpeg","jpg","jpe"],"image/jpm":["jpm"],"image/jpx":["jpx","jpf"],"image/ktx":["ktx"],"image/png":["png"],"image/prs.btif":["btif"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/tiff":["tiff","tif"],"image/vnd.adobe.photoshop":["psd"],"image/vnd.dece.graphic":["uvi","uvvi","uvg","uvvg"],"image/vnd.djvu":["djvu","djv"],"image/vnd.dvb.subtitle":[],"image/vnd.dwg":["dwg"],"image/vnd.dxf":["dxf"],"image/vnd.fastbidsheet":["fbs"],"image/vnd.fpx":["fpx"],"image/vnd.fst":["fst"],"image/vnd.fujixerox.edmics-mmr":["mmr"],"image/vnd.fujixerox.edmics-rlc":["rlc"],"image/vnd.ms-modi":["mdi"],"image/vnd.ms-photo":["wdp"],"image/vnd.net-fpx":["npx"],"image/vnd.wap.wbmp":["wbmp"],"image/vnd.xiff":["xif"],"image/webp":["webp"],"image/x-3ds":["3ds"],"image/x-cmu-raster":["ras"],"image/x-cmx":["cmx"],"image/x-freehand":["fh","fhc","fh4","fh5","fh7"],"image/x-icon":["ico"],"image/x-jng":["jng"],"image/x-mrsid-image":["sid"],"image/x-ms-bmp":[],"image/x-pcx":["pcx"],"image/x-pict":["pic","pct"],"image/x-portable-anymap":["pnm"],"image/x-portable-bitmap":["pbm"],"image/x-portable-graymap":["pgm"],"image/x-portable-pixmap":["ppm"],"image/x-rgb":["rgb"],"image/x-tga":["tga"],"image/x-xbitmap":["xbm"],"image/x-xpixmap":["xpm"],"image/x-xwindowdump":["xwd"],"message/rfc822":["eml","mime"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/vnd.collada+xml":["dae"],"model/vnd.dwf":["dwf"],"model/vnd.gdl":["gdl"],"model/vnd.gtw":["gtw"],"model/vnd.mts":["mts"],"model/vnd.vtu":["vtu"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["x3db","x3dbz"],"model/x3d+vrml":["x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/hjson":["hjson"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/prs.lines.tag":["dsc"],"text/richtext":["rtx"],"text/rtf":[],"text/sgml":["sgml","sgm"],"text/slim":["slim","slm"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vnd.curl":["curl"],"text/vnd.curl.dcurl":["dcurl"],"text/vnd.curl.mcurl":["mcurl"],"text/vnd.curl.scurl":["scurl"],"text/vnd.dvb.subtitle":["sub"],"text/vnd.fly":["fly"],"text/vnd.fmi.flexstor":["flx"],"text/vnd.graphviz":["gv"],"text/vnd.in3d.3dml":["3dml"],"text/vnd.in3d.spot":["spot"],"text/vnd.sun.j2me.app-descriptor":["jad"],"text/vnd.wap.wml":["wml"],"text/vnd.wap.wmlscript":["wmls"],"text/vtt":["vtt"],"text/x-asm":["s","asm"],"text/x-c":["c","cc","cxx","cpp","h","hh","dic"],"text/x-component":["htc"],"text/x-fortran":["f","for","f77","f90"],"text/x-handlebars-template":["hbs"],"text/x-java-source":["java"],"text/x-lua":["lua"],"text/x-markdown":["mkd"],"text/x-nfo":["nfo"],"text/x-opml":["opml"],"text/x-org":[],"text/x-pascal":["p","pas"],"text/x-processing":["pde"],"text/x-sass":["sass"],"text/x-scss":["scss"],"text/x-setext":["etx"],"text/x-sfv":["sfv"],"text/x-suse-ymp":["ymp"],"text/x-uuencode":["uu"],"text/x-vcalendar":["vcs"],"text/x-vcard":["vcf"],"text/xml":[],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/jpeg":["jpgv"],"video/jpm":["jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/vnd.dece.hd":["uvh","uvvh"],"video/vnd.dece.mobile":["uvm","uvvm"],"video/vnd.dece.pd":["uvp","uvvp"],"video/vnd.dece.sd":["uvs","uvvs"],"video/vnd.dece.video":["uvv","uvvv"],"video/vnd.dvb.file":["dvb"],"video/vnd.fvt":["fvt"],"video/vnd.mpegurl":["mxu","m4u"],"video/vnd.ms-playready.media.pyv":["pyv"],"video/vnd.uvvu.mp4":["uvu","uvvu"],"video/vnd.vivo":["viv"],"video/webm":["webm"],"video/x-f4v":["f4v"],"video/x-fli":["fli"],"video/x-flv":["flv"],"video/x-m4v":["m4v"],"video/x-matroska":["mkv","mk3d","mks"],"video/x-mng":["mng"],"video/x-ms-asf":["asf","asx"],"video/x-ms-vob":["vob"],"video/x-ms-wm":["wm"],"video/x-ms-wmv":["wmv"],"video/x-ms-wmx":["wmx"],"video/x-ms-wvx":["wvx"],"video/x-msvideo":["avi"],"video/x-sgi-movie":["movie"],"video/x-smv":["smv"],"x-conference/x-cooltalk":["ice"]}');
    },
    "../node_modules/.pnpm/socket.io@4.8.1/node_modules/socket.io/package.json": function(module) {
        "use strict";
        module.exports = {
            i8: "4.8.1"
        };
    },
    "../node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/codes.json": function(module) {
        "use strict";
        module.exports = JSON.parse('{"100":"Continue","101":"Switching Protocols","102":"Processing","103":"Early Hints","200":"OK","201":"Created","202":"Accepted","203":"Non-Authoritative Information","204":"No Content","205":"Reset Content","206":"Partial Content","207":"Multi-Status","208":"Already Reported","226":"IM Used","300":"Multiple Choices","301":"Moved Permanently","302":"Found","303":"See Other","304":"Not Modified","305":"Use Proxy","307":"Temporary Redirect","308":"Permanent Redirect","400":"Bad Request","401":"Unauthorized","402":"Payment Required","403":"Forbidden","404":"Not Found","405":"Method Not Allowed","406":"Not Acceptable","407":"Proxy Authentication Required","408":"Request Timeout","409":"Conflict","410":"Gone","411":"Length Required","412":"Precondition Failed","413":"Payload Too Large","414":"URI Too Long","415":"Unsupported Media Type","416":"Range Not Satisfiable","417":"Expectation Failed","418":"I\'m a Teapot","421":"Misdirected Request","422":"Unprocessable Entity","423":"Locked","424":"Failed Dependency","425":"Too Early","426":"Upgrade Required","428":"Precondition Required","429":"Too Many Requests","431":"Request Header Fields Too Large","451":"Unavailable For Legal Reasons","500":"Internal Server Error","501":"Not Implemented","502":"Bad Gateway","503":"Service Unavailable","504":"Gateway Timeout","505":"HTTP Version Not Supported","506":"Variant Also Negotiates","507":"Insufficient Storage","508":"Loop Detected","509":"Bandwidth Limit Exceeded","510":"Not Extended","511":"Network Authentication Required"}');
    }
};
var __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
        id: moduleId,
        loaded: false,
        exports: {}
    };
    __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    module.loaded = true;
    return module.exports;
}
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
(()=>{
    __webpack_require__.nmd = (module)=>{
        module.paths = [];
        if (!module.children) module.children = [];
        return module;
    };
})();
var __webpack_exports__ = {};
(()=>{
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
        AgentSession: ()=>_core__WEBPACK_IMPORTED_MODULE_0__.ZT,
        AgentTARSServer: ()=>_server__WEBPACK_IMPORTED_MODULE_1__.t,
        AgioProvider: ()=>_core__WEBPACK_IMPORTED_MODULE_0__.iF,
        ErrorWithCode: ()=>_utils__WEBPACK_IMPORTED_MODULE_2__.G8,
        ShareService: ()=>_services__WEBPACK_IMPORTED_MODULE_5__.t,
        SocketHandlers: ()=>_core__WEBPACK_IMPORTED_MODULE_0__.Lw,
        createErrorResponse: ()=>_utils__WEBPACK_IMPORTED_MODULE_2__.jl,
        createStorageProvider: ()=>_storage__WEBPACK_IMPORTED_MODULE_3__.E,
        ensureWorkingDirectory: ()=>_utils__WEBPACK_IMPORTED_MODULE_2__.st,
        express: ()=>_server__WEBPACK_IMPORTED_MODULE_1__.z,
        handleAgentError: ()=>_utils__WEBPACK_IMPORTED_MODULE_2__.rB,
        setupSocketIO: ()=>_core__WEBPACK_IMPORTED_MODULE_0__.sI
    });
    var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/core/index.ts");
    var _server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/server.ts");
    var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/index.ts");
    var _storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/storage/index.ts");
    var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/types.ts");
    var __WEBPACK_REEXPORT_OBJECT__ = {};
    for(var __WEBPACK_IMPORT_KEY__ in _types__WEBPACK_IMPORTED_MODULE_4__)if ([
        "default",
        "AgioProvider",
        "ErrorWithCode",
        "setupSocketIO",
        "AgentTARSServer",
        "express",
        "SocketHandlers",
        "createErrorResponse",
        "ensureWorkingDirectory",
        "handleAgentError",
        "createStorageProvider",
        "AgentSession"
    ].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = (function(key) {
        return _types__WEBPACK_IMPORTED_MODULE_4__[key];
    }).bind(0, __WEBPACK_IMPORT_KEY__);
    __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
    var _services__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/services/index.ts");
})();
exports.AgentSession = __webpack_exports__.AgentSession;
exports.AgentTARSServer = __webpack_exports__.AgentTARSServer;
exports.AgioProvider = __webpack_exports__.AgioProvider;
exports.ErrorWithCode = __webpack_exports__.ErrorWithCode;
exports.ShareService = __webpack_exports__.ShareService;
exports.SocketHandlers = __webpack_exports__.SocketHandlers;
exports.createErrorResponse = __webpack_exports__.createErrorResponse;
exports.createStorageProvider = __webpack_exports__.createStorageProvider;
exports.ensureWorkingDirectory = __webpack_exports__.ensureWorkingDirectory;
exports.express = __webpack_exports__.express;
exports.handleAgentError = __webpack_exports__.handleAgentError;
exports.setupSocketIO = __webpack_exports__.setupSocketIO;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "AgentSession",
    "AgentTARSServer",
    "AgioProvider",
    "ErrorWithCode",
    "ShareService",
    "SocketHandlers",
    "createErrorResponse",
    "createStorageProvider",
    "ensureWorkingDirectory",
    "express",
    "handleAgentError",
    "setupSocketIO"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});

//# sourceMappingURL=index.js.map