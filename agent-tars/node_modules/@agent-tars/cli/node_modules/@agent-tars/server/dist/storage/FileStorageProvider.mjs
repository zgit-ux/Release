/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
import external_path_default from "path";
import external_fs_default from "fs";
import { Low } from "lowdb";
import { JSONFile } from "lowdb/node";
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
class FileStorageProvider {
    async initialize() {
        if (!this.initialized) try {
            await this.db.read();
            this.db.data = this.db.data || {
                sessions: {},
                events: {}
            };
            this.initialized = true;
        } catch (error) {
            this.db.data = {
                sessions: {},
                events: {}
            };
            await this.db.write();
            this.initialized = true;
        }
    }
    async createSession(metadata) {
        await this.ensureInitialized();
        const sessionData = {
            ...metadata,
            createdAt: metadata.createdAt || Date.now(),
            updatedAt: metadata.updatedAt || Date.now()
        };
        this.db.data.sessions[metadata.id] = sessionData;
        this.db.data.events[metadata.id] = [];
        await this.db.write();
        return sessionData;
    }
    async updateSessionMetadata(sessionId, metadata) {
        await this.ensureInitialized();
        const session = this.db.data.sessions[sessionId];
        if (!session) throw new Error(`Session not found: ${sessionId}`);
        const updatedSession = {
            ...session,
            ...metadata,
            updatedAt: Date.now()
        };
        this.db.data.sessions[sessionId] = updatedSession;
        await this.db.write();
        return updatedSession;
    }
    async getSessionMetadata(sessionId) {
        await this.ensureInitialized();
        return this.db.data.sessions[sessionId] || null;
    }
    async getAllSessions() {
        await this.ensureInitialized();
        return Object.values(this.db.data.sessions);
    }
    async deleteSession(sessionId) {
        await this.ensureInitialized();
        if (!this.db.data.sessions[sessionId]) return false;
        delete this.db.data.sessions[sessionId];
        delete this.db.data.events[sessionId];
        await this.db.write();
        return true;
    }
    async saveEvent(sessionId, event) {
        await this.ensureInitialized();
        if (!this.db.data.sessions[sessionId]) throw new Error(`Session not found: ${sessionId}`);
        if (!this.db.data.events[sessionId]) this.db.data.events[sessionId] = [];
        this.db.data.events[sessionId].push(event);
        this.db.data.sessions[sessionId].updatedAt = Date.now();
        await this.db.write();
    }
    async getSessionEvents(sessionId) {
        await this.ensureInitialized();
        if (!this.db.data.sessions[sessionId]) throw new Error(`Session not found: ${sessionId}`);
        return this.db.data.events[sessionId] || [];
    }
    async close() {
        if (this.initialized) await this.db.write();
    }
    async ensureInitialized() {
        if (!this.initialized) await this.initialize();
    }
    constructor(storagePath){
        _define_property(this, "db", void 0);
        _define_property(this, "initialized", false);
        _define_property(this, "dbPath", void 0);
        const defaultPath = process.env.HOME || process.env.USERPROFILE || '.';
        const baseDir = storagePath || external_path_default.join(defaultPath, '.agent-tars');
        if (!external_fs_default.existsSync(baseDir)) external_fs_default.mkdirSync(baseDir, {
            recursive: true
        });
        this.dbPath = external_path_default.join(baseDir, 'storage.json');
        const adapter = new JSONFile(this.dbPath);
        this.db = new Low(adapter, {
            sessions: {},
            events: {}
        });
    }
}
export { FileStorageProvider };

//# sourceMappingURL=FileStorageProvider.mjs.map