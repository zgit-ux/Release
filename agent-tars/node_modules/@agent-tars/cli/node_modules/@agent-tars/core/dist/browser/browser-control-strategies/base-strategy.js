/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    AbstractBrowserControlStrategy: ()=>AbstractBrowserControlStrategy
});
const core_namespaceObject = require("@mcp-agent/core");
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
class AbstractBrowserControlStrategy {
    setBrowserClient(client) {
        this.browserClient = client;
    }
    setBrowserGUIAgent(browserGUIAgent) {
        this.browserGUIAgent = browserGUIAgent;
    }
    getStrategyName() {
        return this.constructor.name;
    }
    async registerMCPBrowserTools(registerToolFn, toolNames) {
        if (!this.browserClient) return;
        try {
            const tools = await this.browserClient.listTools();
            if (!tools || !Array.isArray(tools.tools)) return void this.logger.warn('No tools returned from browser client');
            for (const tool of tools.tools)if (toolNames.includes(tool.name)) {
                const toolDefinition = new core_namespaceObject.Tool({
                    id: tool.name,
                    description: `[browser] ${tool.description}`,
                    parameters: tool.inputSchema || {
                        type: 'object',
                        properties: {}
                    },
                    function: async (args)=>{
                        try {
                            const result = await this.browserClient.callTool({
                                name: tool.name,
                                arguments: args
                            });
                            return result.content;
                        } catch (error) {
                            this.logger.error(`Error executing tool '${tool.name}':`, error);
                            throw error;
                        }
                    }
                });
                registerToolFn(toolDefinition);
                this.registeredTools.add(tool.name);
                this.logger.debug(`Registered browser tool: ${tool.name}`);
            }
            this.logger.info(`Registered ${this.registeredTools.size} MCP browser tools`);
        } catch (error) {
            this.logger.error("Failed to register MCP browser tools:", error);
            throw error;
        }
    }
    constructor(logger){
        _define_property(this, "browserClient", void 0);
        _define_property(this, "browserGUIAgent", void 0);
        _define_property(this, "logger", void 0);
        _define_property(this, "registeredTools", new Set());
        this.logger = logger.spawn(this.constructor.name);
    }
}
exports.AbstractBrowserControlStrategy = __webpack_exports__.AbstractBrowserControlStrategy;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "AbstractBrowserControlStrategy"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});

//# sourceMappingURL=base-strategy.js.map