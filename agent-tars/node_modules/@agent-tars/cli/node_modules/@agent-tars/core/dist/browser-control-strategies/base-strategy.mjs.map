{"version":3,"file":"browser-control-strategies/base-strategy.mjs","sources":["webpack://@agent-tars/core/./src/browser-control-strategies/base-strategy.ts"],"sourcesContent":["/*\n * Copyright (c) 2025 Bytedance, Inc. and its affiliates.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ConsoleLogger, JSONSchema7, ToolDefinition } from '@multimodal/mcp-agent';\nimport { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport { GUIAgent } from '../gui-agent';\n\n/**\n * BrowserControlStrategy - Interface for browser control strategies\n *\n * Defines the contract that all browser control strategies must implement\n */\nexport interface BrowserControlStrategy {\n  /**\n   * Set the MCP Browser client for DOM-based operations\n   * @param client MCP client for browser operations\n   */\n  setBrowserClient(client: Client): void;\n\n  /**\n   * Set the GUI Agent for vision-based operations\n   * @param guiAgent GUI Agent instance\n   */\n  setGUIAgent(guiAgent: GUIAgent): void;\n\n  /**\n   * Register browser control tools based on the strategy\n   * @param registerToolFn Function to register a tool with the agent\n   * @returns Array of registered tool names\n   */\n  registerTools(registerToolFn: (tool: ToolDefinition) => void): Promise<string[]>;\n\n  /**\n   * Get the name of the strategy for logging purposes\n   */\n  getStrategyName(): string;\n}\n\n/**\n * AbstractBrowserControlStrategy - Base implementation for browser control strategies\n *\n * Provides common functionality and state management for all strategies\n */\nexport abstract class AbstractBrowserControlStrategy implements BrowserControlStrategy {\n  protected browserClient?: Client;\n  protected guiAgent?: GUIAgent;\n  protected logger: ConsoleLogger;\n  protected registeredTools: Set<string> = new Set();\n\n  constructor(logger: ConsoleLogger) {\n    this.logger = logger.spawn(this.constructor.name);\n  }\n\n  /**\n   * Set the MCP Browser client\n   */\n  setBrowserClient(client: Client): void {\n    this.browserClient = client;\n  }\n\n  /**\n   * Set the GUI Agent\n   */\n  setGUIAgent(guiAgent: GUIAgent): void {\n    this.guiAgent = guiAgent;\n  }\n\n  /**\n   * Register browser control tools\n   * Each strategy must implement this method\n   */\n  abstract registerTools(registerToolFn: (tool: ToolDefinition) => void): Promise<string[]>;\n\n  /**\n   * Get the name of the strategy for logging purposes\n   */\n  getStrategyName(): string {\n    return this.constructor.name;\n  }\n\n  /**\n   * Register selected MCP Browser tools\n   * Helper method for strategies that use MCP Browser\n   */\n  protected async registerMCPBrowserTools(\n    registerToolFn: (tool: ToolDefinition) => void,\n    toolNames: string[],\n  ): Promise<void> {\n    if (!this.browserClient) return;\n\n    try {\n      // Get all available tools from browser client\n      const tools = await this.browserClient.listTools();\n\n      if (!tools || !Array.isArray(tools.tools)) {\n        this.logger.warn('No tools returned from browser client');\n        return;\n      }\n\n      // Filter tools by name and register them\n      for (const tool of tools.tools) {\n        if (toolNames.includes(tool.name)) {\n          const toolDefinition: ToolDefinition = {\n            name: tool.name,\n            description: `[browser] ${tool.description}`,\n            schema: (tool.inputSchema || { type: 'object', properties: {} }) as JSONSchema7,\n            function: async (args: Record<string, unknown>) => {\n              try {\n                const result = await this.browserClient!.callTool({\n                  name: tool.name,\n                  arguments: args,\n                });\n                return result.content;\n              } catch (error) {\n                this.logger.error(`Error executing tool '${tool.name}':`, error);\n                throw error;\n              }\n            },\n          };\n\n          registerToolFn(toolDefinition);\n          this.registeredTools.add(tool.name);\n          this.logger.debug(`Registered browser tool: ${tool.name}`);\n        }\n      }\n\n      this.logger.info(`Registered ${this.registeredTools.size} MCP browser tools`);\n    } catch (error) {\n      this.logger.error(`Failed to register MCP browser tools:`, error);\n      throw error;\n    }\n  }\n}\n"],"names":["AbstractBrowserControlStrategy","client","guiAgent","registerToolFn","toolNames","tools","Array","tool","toolDefinition","args","result","error","logger","Set"],"mappings":";;;;AAGC;;;;;;;;;;AA0CM,MAAeA;IAapB,iBAAiBC,MAAc,EAAQ;QACrC,IAAI,CAAC,aAAa,GAAGA;IACvB;IAKA,YAAYC,QAAkB,EAAQ;QACpC,IAAI,CAAC,QAAQ,GAAGA;IAClB;IAWA,kBAA0B;QACxB,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI;IAC9B;IAMA,MAAgB,wBACdC,cAA8C,EAC9CC,SAAmB,EACJ;QACf,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;QAEzB,IAAI;YAEF,MAAMC,QAAQ,MAAM,IAAI,CAAC,aAAa,CAAC,SAAS;YAEhD,IAAI,CAACA,SAAS,CAACC,MAAM,OAAO,CAACD,MAAM,KAAK,GAAG;gBACzC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;gBACjB;YACF;YAGA,KAAK,MAAME,QAAQF,MAAM,KAAK,CAC5B,IAAID,UAAU,QAAQ,CAACG,KAAK,IAAI,GAAG;gBACjC,MAAMC,iBAAiC;oBACrC,MAAMD,KAAK,IAAI;oBACf,aAAa,CAAC,UAAU,EAAEA,KAAK,WAAW,EAAE;oBAC5C,QAASA,KAAK,WAAW,IAAI;wBAAE,MAAM;wBAAU,YAAY,CAAC;oBAAE;oBAC9D,UAAU,OAAOE;wBACf,IAAI;4BACF,MAAMC,SAAS,MAAM,IAAI,CAAC,aAAa,CAAE,QAAQ,CAAC;gCAChD,MAAMH,KAAK,IAAI;gCACf,WAAWE;4BACb;4BACA,OAAOC,OAAO,OAAO;wBACvB,EAAE,OAAOC,OAAO;4BACd,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,sBAAsB,EAAEJ,KAAK,IAAI,CAAC,EAAE,CAAC,EAAEI;4BAC1D,MAAMA;wBACR;oBACF;gBACF;gBAEAR,eAAeK;gBACf,IAAI,CAAC,eAAe,CAAC,GAAG,CAACD,KAAK,IAAI;gBAClC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,yBAAyB,EAAEA,KAAK,IAAI,EAAE;YAC3D;YAGF,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,WAAW,EAAE,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,kBAAkB,CAAC;QAC9E,EAAE,OAAOI,OAAO;YACd,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,yCAAyCA;YAC3D,MAAMA;QACR;IACF;IAlFA,YAAYC,MAAqB,CAAE;QALnC,uBAAU,iBAAV;QACA,uBAAU,YAAV;QACA,uBAAU,UAAV;QACA,uBAAU,mBAA+B,IAAIC;QAG3C,IAAI,CAAC,MAAM,GAAGD,OAAO,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI;IAClD;AAiFF"}