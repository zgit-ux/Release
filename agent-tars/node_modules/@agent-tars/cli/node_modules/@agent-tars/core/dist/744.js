/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
/*! For license information please see 744.js.LICENSE.txt */
"use strict";
exports.ids = [
    "744"
];
exports.modules = {
    "../node_modules/.pnpm/yargs-parser@21.1.1/node_modules/yargs-parser/build/lib/index.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            Z: ()=>lib
        });
        var external_util_ = __webpack_require__("util");
        var external_path_ = __webpack_require__("path");
        /**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */ function camelCase(str) {
            const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
            if (!isCamelCase) str = str.toLowerCase();
            if (-1 === str.indexOf('-') && -1 === str.indexOf('_')) return str;
            {
                let camelcase = '';
                let nextChrUpper = false;
                const leadingHyphens = str.match(/^-+/);
                for(let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++){
                    let chr = str.charAt(i);
                    if (nextChrUpper) {
                        nextChrUpper = false;
                        chr = chr.toUpperCase();
                    }
                    if (0 !== i && ('-' === chr || '_' === chr)) nextChrUpper = true;
                    else if ('-' !== chr && '_' !== chr) camelcase += chr;
                }
                return camelcase;
            }
        }
        function decamelize(str, joinString) {
            const lowercase = str.toLowerCase();
            joinString = joinString || '-';
            let notCamelcase = '';
            for(let i = 0; i < str.length; i++){
                const chrLower = lowercase.charAt(i);
                const chrString = str.charAt(i);
                if (chrLower !== chrString && i > 0) notCamelcase += `${joinString}${lowercase.charAt(i)}`;
                else notCamelcase += chrString;
            }
            return notCamelcase;
        }
        function looksLikeNumber(x) {
            if (null == x) return false;
            if ('number' == typeof x) return true;
            if (/^0x[0-9a-f]+$/i.test(x)) return true;
            if (/^0[^.]/.test(x)) return false;
            return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
        }
        /**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */ function tokenizeArgString(argString) {
            if (Array.isArray(argString)) return argString.map((e)=>'string' != typeof e ? e + '' : e);
            argString = argString.trim();
            let i = 0;
            let prevC = null;
            let c = null;
            let opening = null;
            const args = [];
            for(let ii = 0; ii < argString.length; ii++){
                prevC = c;
                c = argString.charAt(ii);
                if (' ' === c && !opening) {
                    if (' ' !== prevC) i++;
                    continue;
                }
                if (c === opening) opening = null;
                else if (("'" === c || '"' === c) && !opening) opening = c;
                if (!args[i]) args[i] = '';
                args[i] += c;
            }
            return args;
        }
        /**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */ var yargs_parser_types_DefaultValuesForTypeKey;
        (function(DefaultValuesForTypeKey) {
            DefaultValuesForTypeKey["BOOLEAN"] = "boolean";
            DefaultValuesForTypeKey["STRING"] = "string";
            DefaultValuesForTypeKey["NUMBER"] = "number";
            DefaultValuesForTypeKey["ARRAY"] = "array";
        })(yargs_parser_types_DefaultValuesForTypeKey || (yargs_parser_types_DefaultValuesForTypeKey = {}));
        /**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */ let mixin;
        class YargsParser {
            constructor(_mixin){
                mixin = _mixin;
            }
            parse(argsInput, options) {
                const opts = Object.assign({
                    alias: void 0,
                    array: void 0,
                    boolean: void 0,
                    config: void 0,
                    configObjects: void 0,
                    configuration: void 0,
                    coerce: void 0,
                    count: void 0,
                    default: void 0,
                    envPrefix: void 0,
                    narg: void 0,
                    normalize: void 0,
                    string: void 0,
                    number: void 0,
                    __: void 0,
                    key: void 0
                }, options);
                const args = tokenizeArgString(argsInput);
                const inputIsString = 'string' == typeof argsInput;
                const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
                const configuration = Object.assign({
                    'boolean-negation': true,
                    'camel-case-expansion': true,
                    'combine-arrays': false,
                    'dot-notation': true,
                    'duplicate-arguments-array': true,
                    'flatten-duplicate-arrays': true,
                    'greedy-arrays': true,
                    'halt-at-non-option': false,
                    'nargs-eats-options': false,
                    'negation-prefix': 'no-',
                    'parse-numbers': true,
                    'parse-positional-numbers': true,
                    'populate--': false,
                    'set-placeholder-key': false,
                    'short-option-groups': true,
                    'strip-aliased': false,
                    'strip-dashed': false,
                    'unknown-options-as-args': false
                }, opts.configuration);
                const defaults = Object.assign(Object.create(null), opts.default);
                const configObjects = opts.configObjects || [];
                const envPrefix = opts.envPrefix;
                const notFlagsOption = configuration['populate--'];
                const notFlagsArgv = notFlagsOption ? '--' : '_';
                const newAliases = Object.create(null);
                const defaulted = Object.create(null);
                const __ = opts.__ || mixin.format;
                const flags = {
                    aliases: Object.create(null),
                    arrays: Object.create(null),
                    bools: Object.create(null),
                    strings: Object.create(null),
                    numbers: Object.create(null),
                    counts: Object.create(null),
                    normalize: Object.create(null),
                    configs: Object.create(null),
                    nargs: Object.create(null),
                    coercions: Object.create(null),
                    keys: []
                };
                const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
                const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');
                [].concat(opts.array || []).filter(Boolean).forEach(function(opt) {
                    const key = 'object' == typeof opt ? opt.key : opt;
                    const assignment = Object.keys(opt).map(function(key) {
                        const arrayFlagKeys = {
                            boolean: 'bools',
                            string: 'strings',
                            number: 'numbers'
                        };
                        return arrayFlagKeys[key];
                    }).filter(Boolean).pop();
                    if (assignment) flags[assignment][key] = true;
                    flags.arrays[key] = true;
                    flags.keys.push(key);
                });
                [].concat(opts.boolean || []).filter(Boolean).forEach(function(key) {
                    flags.bools[key] = true;
                    flags.keys.push(key);
                });
                [].concat(opts.string || []).filter(Boolean).forEach(function(key) {
                    flags.strings[key] = true;
                    flags.keys.push(key);
                });
                [].concat(opts.number || []).filter(Boolean).forEach(function(key) {
                    flags.numbers[key] = true;
                    flags.keys.push(key);
                });
                [].concat(opts.count || []).filter(Boolean).forEach(function(key) {
                    flags.counts[key] = true;
                    flags.keys.push(key);
                });
                [].concat(opts.normalize || []).filter(Boolean).forEach(function(key) {
                    flags.normalize[key] = true;
                    flags.keys.push(key);
                });
                if ('object' == typeof opts.narg) Object.entries(opts.narg).forEach(([key, value])=>{
                    if ('number' == typeof value) {
                        flags.nargs[key] = value;
                        flags.keys.push(key);
                    }
                });
                if ('object' == typeof opts.coerce) Object.entries(opts.coerce).forEach(([key, value])=>{
                    if ('function' == typeof value) {
                        flags.coercions[key] = value;
                        flags.keys.push(key);
                    }
                });
                if (void 0 !== opts.config) {
                    if (Array.isArray(opts.config) || 'string' == typeof opts.config) [].concat(opts.config).filter(Boolean).forEach(function(key) {
                        flags.configs[key] = true;
                    });
                    else if ('object' == typeof opts.config) Object.entries(opts.config).forEach(([key, value])=>{
                        if ('boolean' == typeof value || 'function' == typeof value) flags.configs[key] = value;
                    });
                }
                extendAliases(opts.key, aliases, opts.default, flags.arrays);
                Object.keys(defaults).forEach(function(key) {
                    (flags.aliases[key] || []).forEach(function(alias) {
                        defaults[alias] = defaults[key];
                    });
                });
                let error = null;
                checkConfiguration();
                let notFlags = [];
                const argv = Object.assign(Object.create(null), {
                    _: []
                });
                const argvReturn = {};
                for(let i = 0; i < args.length; i++){
                    const arg = args[i];
                    const truncatedArg = arg.replace(/^-{3,}/, '---');
                    let broken;
                    let key;
                    let letters;
                    let m;
                    let next;
                    let value;
                    if ('--' !== arg && /^-/.test(arg) && isUnknownOptionAsArg(arg)) pushPositional(arg);
                    else if (truncatedArg.match(/^---+(=|$)/)) {
                        pushPositional(arg);
                        continue;
                    } else if (arg.match(/^--.+=/) || !configuration['short-option-groups'] && arg.match(/^-.+=/)) {
                        m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
                        if (null !== m && Array.isArray(m) && m.length >= 3) if (checkAllAliases(m[1], flags.arrays)) i = eatArray(i, m[1], args, m[2]);
                        else if (false !== checkAllAliases(m[1], flags.nargs)) i = eatNargs(i, m[1], args, m[2]);
                        else setArg(m[1], m[2], true);
                    } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {
                        m = arg.match(negatedBoolean);
                        if (null !== m && Array.isArray(m) && m.length >= 2) {
                            key = m[1];
                            setArg(key, checkAllAliases(key, flags.arrays) ? [
                                false
                            ] : false);
                        }
                    } else if (arg.match(/^--.+/) || !configuration['short-option-groups'] && arg.match(/^-[^-]+/)) {
                        m = arg.match(/^--?(.+)/);
                        if (null !== m && Array.isArray(m) && m.length >= 2) {
                            key = m[1];
                            if (checkAllAliases(key, flags.arrays)) i = eatArray(i, key, args);
                            else if (false !== checkAllAliases(key, flags.nargs)) i = eatNargs(i, key, args);
                            else {
                                next = args[i + 1];
                                if (void 0 !== next && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                                    setArg(key, next);
                                    i++;
                                } else if (/^(true|false)$/.test(next)) {
                                    setArg(key, next);
                                    i++;
                                } else setArg(key, defaultValue(key));
                            }
                        }
                    } else if (arg.match(/^-.\..+=/)) {
                        m = arg.match(/^-([^=]+)=([\s\S]*)$/);
                        if (null !== m && Array.isArray(m) && m.length >= 3) setArg(m[1], m[2]);
                    } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
                        next = args[i + 1];
                        m = arg.match(/^-(.\..+)/);
                        if (null !== m && Array.isArray(m) && m.length >= 2) {
                            key = m[1];
                            if (void 0 === next || next.match(/^-/) || checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) setArg(key, defaultValue(key));
                            else {
                                setArg(key, next);
                                i++;
                            }
                        }
                    } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
                        letters = arg.slice(1, -1).split('');
                        broken = false;
                        for(let j = 0; j < letters.length; j++){
                            next = arg.slice(j + 2);
                            if (letters[j + 1] && '=' === letters[j + 1]) {
                                value = arg.slice(j + 3);
                                key = letters[j];
                                if (checkAllAliases(key, flags.arrays)) i = eatArray(i, key, args, value);
                                else if (false !== checkAllAliases(key, flags.nargs)) i = eatNargs(i, key, args, value);
                                else setArg(key, value);
                                broken = true;
                                break;
                            }
                            if ('-' === next) {
                                setArg(letters[j], next);
                                continue;
                            }
                            if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && false === checkAllAliases(next, flags.bools)) {
                                setArg(letters[j], next);
                                broken = true;
                                break;
                            }
                            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                                setArg(letters[j], next);
                                broken = true;
                                break;
                            }
                            setArg(letters[j], defaultValue(letters[j]));
                        }
                        key = arg.slice(-1)[0];
                        if (!broken && '-' !== key) if (checkAllAliases(key, flags.arrays)) i = eatArray(i, key, args);
                        else if (false !== checkAllAliases(key, flags.nargs)) i = eatNargs(i, key, args);
                        else {
                            next = args[i + 1];
                            if (void 0 !== next && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                                setArg(key, next);
                                i++;
                            } else if (/^(true|false)$/.test(next)) {
                                setArg(key, next);
                                i++;
                            } else setArg(key, defaultValue(key));
                        }
                    } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
                        key = arg.slice(1);
                        setArg(key, defaultValue(key));
                    } else if ('--' === arg) {
                        notFlags = args.slice(i + 1);
                        break;
                    } else if (configuration['halt-at-non-option']) {
                        notFlags = args.slice(i);
                        break;
                    } else pushPositional(arg);
                }
                applyEnvVars(argv, true);
                applyEnvVars(argv, false);
                setConfig(argv);
                setConfigObjects();
                applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
                applyCoercions(argv);
                if (configuration['set-placeholder-key']) setPlaceholderKeys(argv);
                Object.keys(flags.counts).forEach(function(key) {
                    if (!hasKey(argv, key.split('.'))) setArg(key, 0);
                });
                if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = [];
                notFlags.forEach(function(key) {
                    argv[notFlagsArgv].push(key);
                });
                if (configuration['camel-case-expansion'] && configuration['strip-dashed']) Object.keys(argv).filter((key)=>'--' !== key && key.includes('-')).forEach((key)=>{
                    delete argv[key];
                });
                if (configuration['strip-aliased']) [].concat(...Object.keys(aliases).map((k)=>aliases[k])).forEach((alias)=>{
                    if (configuration['camel-case-expansion'] && alias.includes('-')) delete argv[alias.split('.').map((prop)=>camelCase(prop)).join('.')];
                    delete argv[alias];
                });
                function pushPositional(arg) {
                    const maybeCoercedNumber = maybeCoerceNumber('_', arg);
                    if ('string' == typeof maybeCoercedNumber || 'number' == typeof maybeCoercedNumber) argv._.push(maybeCoercedNumber);
                }
                function eatNargs(i, key, args, argAfterEqualSign) {
                    let ii;
                    let toEat = checkAllAliases(key, flags.nargs);
                    toEat = 'number' != typeof toEat || isNaN(toEat) ? 1 : toEat;
                    if (0 === toEat) {
                        if (!isUndefined(argAfterEqualSign)) error = Error(__('Argument unexpected for: %s', key));
                        setArg(key, defaultValue(key));
                        return i;
                    }
                    let available = isUndefined(argAfterEqualSign) ? 0 : 1;
                    if (configuration['nargs-eats-options']) {
                        if (args.length - (i + 1) + available < toEat) error = Error(__('Not enough arguments following: %s', key));
                        available = toEat;
                    } else {
                        for(ii = i + 1; ii < args.length; ii++)if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii])) available++;
                        else break;
                        if (available < toEat) error = Error(__('Not enough arguments following: %s', key));
                    }
                    let consumed = Math.min(available, toEat);
                    if (!isUndefined(argAfterEqualSign) && consumed > 0) {
                        setArg(key, argAfterEqualSign);
                        consumed--;
                    }
                    for(ii = i + 1; ii < consumed + i + 1; ii++)setArg(key, args[ii]);
                    return i + consumed;
                }
                function eatArray(i, key, args, argAfterEqualSign) {
                    let argsToSet = [];
                    let next = argAfterEqualSign || args[i + 1];
                    const nargsCount = checkAllAliases(key, flags.nargs);
                    if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) argsToSet.push(true);
                    else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
                        if (void 0 !== defaults[key]) {
                            const defVal = defaults[key];
                            argsToSet = Array.isArray(defVal) ? defVal : [
                                defVal
                            ];
                        }
                    } else {
                        if (!isUndefined(argAfterEqualSign)) argsToSet.push(processValue(key, argAfterEqualSign, true));
                        for(let ii = i + 1; ii < args.length; ii++){
                            if (!configuration['greedy-arrays'] && argsToSet.length > 0 || nargsCount && 'number' == typeof nargsCount && argsToSet.length >= nargsCount) break;
                            next = args[ii];
                            if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break;
                            i = ii;
                            argsToSet.push(processValue(key, next, inputIsString));
                        }
                    }
                    if ('number' == typeof nargsCount && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && 0 === argsToSet.length)) error = Error(__('Not enough arguments following: %s', key));
                    setArg(key, argsToSet);
                    return i;
                }
                function setArg(key, val, shouldStripQuotes = inputIsString) {
                    if (/-/.test(key) && configuration['camel-case-expansion']) {
                        const alias = key.split('.').map(function(prop) {
                            return camelCase(prop);
                        }).join('.');
                        addNewAlias(key, alias);
                    }
                    const value = processValue(key, val, shouldStripQuotes);
                    const splitKey = key.split('.');
                    setKey(argv, splitKey, value);
                    if (flags.aliases[key]) flags.aliases[key].forEach(function(x) {
                        const keyProperties = x.split('.');
                        setKey(argv, keyProperties, value);
                    });
                    if (splitKey.length > 1 && configuration['dot-notation']) (flags.aliases[splitKey[0]] || []).forEach(function(x) {
                        let keyProperties = x.split('.');
                        const a = [].concat(splitKey);
                        a.shift();
                        keyProperties = keyProperties.concat(a);
                        if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) setKey(argv, keyProperties, value);
                    });
                    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
                        const keys = [
                            key
                        ].concat(flags.aliases[key] || []);
                        keys.forEach(function(key) {
                            Object.defineProperty(argvReturn, key, {
                                enumerable: true,
                                get () {
                                    return val;
                                },
                                set (value) {
                                    val = 'string' == typeof value ? mixin.normalize(value) : value;
                                }
                            });
                        });
                    }
                }
                function addNewAlias(key, alias) {
                    if (!(flags.aliases[key] && flags.aliases[key].length)) {
                        flags.aliases[key] = [
                            alias
                        ];
                        newAliases[alias] = true;
                    }
                    if (!(flags.aliases[alias] && flags.aliases[alias].length)) addNewAlias(alias, key);
                }
                function processValue(key, val, shouldStripQuotes) {
                    if (shouldStripQuotes) val = stripQuotes(val);
                    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
                        if ('string' == typeof val) val = 'true' === val;
                    }
                    let value = Array.isArray(val) ? val.map(function(v) {
                        return maybeCoerceNumber(key, v);
                    }) : maybeCoerceNumber(key, val);
                    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || 'boolean' == typeof value)) value = increment();
                    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) value = Array.isArray(val) ? val.map((val)=>mixin.normalize(val)) : mixin.normalize(val);
                    return value;
                }
                function maybeCoerceNumber(key, value) {
                    if (!configuration['parse-positional-numbers'] && '_' === key) return value;
                    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
                        const shouldCoerceNumber = looksLikeNumber(value) && configuration['parse-numbers'] && Number.isSafeInteger(Math.floor(parseFloat(`${value}`)));
                        if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) value = Number(value);
                    }
                    return value;
                }
                function setConfig(argv) {
                    const configLookup = Object.create(null);
                    applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
                    Object.keys(flags.configs).forEach(function(configKey) {
                        const configPath = argv[configKey] || configLookup[configKey];
                        if (configPath) try {
                            let config = null;
                            const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);
                            const resolveConfig = flags.configs[configKey];
                            if ('function' == typeof resolveConfig) {
                                try {
                                    config = resolveConfig(resolvedConfigPath);
                                } catch (e) {
                                    config = e;
                                }
                                if (config instanceof Error) {
                                    error = config;
                                    return;
                                }
                            } else config = mixin.require(resolvedConfigPath);
                            setConfigObject(config);
                        } catch (ex) {
                            if ('PermissionDenied' === ex.name) error = ex;
                            else if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath));
                        }
                    });
                }
                function setConfigObject(config, prev) {
                    Object.keys(config).forEach(function(key) {
                        const value = config[key];
                        const fullKey = prev ? prev + '.' + key : key;
                        if ('object' == typeof value && null !== value && !Array.isArray(value) && configuration['dot-notation']) setConfigObject(value, fullKey);
                        else if (!hasKey(argv, fullKey.split('.')) || checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays']) setArg(fullKey, value);
                    });
                }
                function setConfigObjects() {
                    if (void 0 !== configObjects) configObjects.forEach(function(configObject) {
                        setConfigObject(configObject);
                    });
                }
                function applyEnvVars(argv, configOnly) {
                    if (void 0 === envPrefix) return;
                    const prefix = 'string' == typeof envPrefix ? envPrefix : '';
                    const env = mixin.env();
                    Object.keys(env).forEach(function(envVar) {
                        if ('' === prefix || 0 === envVar.lastIndexOf(prefix, 0)) {
                            const keys = envVar.split('__').map(function(key, i) {
                                if (0 === i) key = key.substring(prefix.length);
                                return camelCase(key);
                            });
                            if ((configOnly && flags.configs[keys.join('.')] || !configOnly) && !hasKey(argv, keys)) setArg(keys.join('.'), env[envVar]);
                        }
                    });
                }
                function applyCoercions(argv) {
                    let coerce;
                    const applied = new Set();
                    Object.keys(argv).forEach(function(key) {
                        if (!applied.has(key)) {
                            coerce = checkAllAliases(key, flags.coercions);
                            if ('function' == typeof coerce) try {
                                const value = maybeCoerceNumber(key, coerce(argv[key]));
                                [].concat(flags.aliases[key] || [], key).forEach((ali)=>{
                                    applied.add(ali);
                                    argv[ali] = value;
                                });
                            } catch (err) {
                                error = err;
                            }
                        }
                    });
                }
                function setPlaceholderKeys(argv) {
                    flags.keys.forEach((key)=>{
                        if (~key.indexOf('.')) return;
                        if (void 0 === argv[key]) argv[key] = void 0;
                    });
                    return argv;
                }
                function applyDefaultsAndAliases(obj, aliases, defaults, canLog = false) {
                    Object.keys(defaults).forEach(function(key) {
                        if (!hasKey(obj, key.split('.'))) {
                            setKey(obj, key.split('.'), defaults[key]);
                            if (canLog) defaulted[key] = true;
                            (aliases[key] || []).forEach(function(x) {
                                if (hasKey(obj, x.split('.'))) return;
                                setKey(obj, x.split('.'), defaults[key]);
                            });
                        }
                    });
                }
                function hasKey(obj, keys) {
                    let o = obj;
                    if (!configuration['dot-notation']) keys = [
                        keys.join('.')
                    ];
                    keys.slice(0, -1).forEach(function(key) {
                        o = o[key] || {};
                    });
                    const key = keys[keys.length - 1];
                    if ('object' != typeof o) return false;
                    return key in o;
                }
                function setKey(obj, keys, value) {
                    let o = obj;
                    if (!configuration['dot-notation']) keys = [
                        keys.join('.')
                    ];
                    keys.slice(0, -1).forEach(function(key) {
                        key = sanitizeKey(key);
                        if ('object' == typeof o && void 0 === o[key]) o[key] = {};
                        if ('object' != typeof o[key] || Array.isArray(o[key])) {
                            if (Array.isArray(o[key])) o[key].push({});
                            else o[key] = [
                                o[key],
                                {}
                            ];
                            o = o[key][o[key].length - 1];
                        } else o = o[key];
                    });
                    const key = sanitizeKey(keys[keys.length - 1]);
                    const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);
                    const isValueArray = Array.isArray(value);
                    let duplicate = configuration['duplicate-arguments-array'];
                    if (!duplicate && checkAllAliases(key, flags.nargs)) {
                        duplicate = true;
                        if (!isUndefined(o[key]) && 1 === flags.nargs[key] || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) o[key] = void 0;
                    }
                    if (value === increment()) o[key] = increment(o[key]);
                    else if (Array.isArray(o[key])) if (duplicate && isTypeArray && isValueArray) o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [
                        o[key]
                    ]).concat([
                        value
                    ]);
                    else if (duplicate || Boolean(isTypeArray) !== Boolean(isValueArray)) o[key] = o[key].concat([
                        value
                    ]);
                    else o[key] = value;
                    else if (void 0 === o[key] && isTypeArray) o[key] = isValueArray ? value : [
                        value
                    ];
                    else if (duplicate && !(void 0 === o[key] || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) o[key] = [
                        o[key],
                        value
                    ];
                    else o[key] = value;
                }
                function extendAliases(...args) {
                    args.forEach(function(obj) {
                        Object.keys(obj || {}).forEach(function(key) {
                            if (flags.aliases[key]) return;
                            flags.aliases[key] = [].concat(aliases[key] || []);
                            flags.aliases[key].concat(key).forEach(function(x) {
                                if (/-/.test(x) && configuration['camel-case-expansion']) {
                                    const c = camelCase(x);
                                    if (c !== key && -1 === flags.aliases[key].indexOf(c)) {
                                        flags.aliases[key].push(c);
                                        newAliases[c] = true;
                                    }
                                }
                            });
                            flags.aliases[key].concat(key).forEach(function(x) {
                                if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {
                                    const c = decamelize(x, '-');
                                    if (c !== key && -1 === flags.aliases[key].indexOf(c)) {
                                        flags.aliases[key].push(c);
                                        newAliases[c] = true;
                                    }
                                }
                            });
                            flags.aliases[key].forEach(function(x) {
                                flags.aliases[x] = [
                                    key
                                ].concat(flags.aliases[key].filter(function(y) {
                                    return x !== y;
                                }));
                            });
                        });
                    });
                }
                function checkAllAliases(key, flag) {
                    const toCheck = [].concat(flags.aliases[key] || [], key);
                    const keys = Object.keys(flag);
                    const setAlias = toCheck.find((key)=>keys.includes(key));
                    return setAlias ? flag[setAlias] : false;
                }
                function hasAnyFlag(key) {
                    const flagsKeys = Object.keys(flags);
                    const toCheck = [].concat(flagsKeys.map((k)=>flags[k]));
                    return toCheck.some(function(flag) {
                        return Array.isArray(flag) ? flag.includes(key) : flag[key];
                    });
                }
                function hasFlagsMatching(arg, ...patterns) {
                    const toCheck = [].concat(...patterns);
                    return toCheck.some(function(pattern) {
                        const match = arg.match(pattern);
                        return match && hasAnyFlag(match[1]);
                    });
                }
                function hasAllShortFlags(arg) {
                    if (arg.match(negative) || !arg.match(/^-[^-]+/)) return false;
                    let hasAllFlags = true;
                    let next;
                    const letters = arg.slice(1).split('');
                    for(let j = 0; j < letters.length; j++){
                        next = arg.slice(j + 2);
                        if (!hasAnyFlag(letters[j])) {
                            hasAllFlags = false;
                            break;
                        }
                        if (letters[j + 1] && '=' === letters[j + 1] || '-' === next || /[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\W/)) break;
                    }
                    return hasAllFlags;
                }
                function isUnknownOptionAsArg(arg) {
                    return configuration['unknown-options-as-args'] && isUnknownOption(arg);
                }
                function isUnknownOption(arg) {
                    arg = arg.replace(/^-{3,}/, '--');
                    if (arg.match(negative)) return false;
                    if (hasAllShortFlags(arg)) return false;
                    const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
                    const normalFlag = /^-+([^=]+?)$/;
                    const flagEndingInHyphen = /^-+([^=]+?)-$/;
                    const flagEndingInDigits = /^-+([^=]+?\d+)$/;
                    const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
                    return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
                }
                function defaultValue(key) {
                    if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) return defaults[key];
                    return defaultForType(guessType(key));
                }
                function defaultForType(type) {
                    const def = {
                        [yargs_parser_types_DefaultValuesForTypeKey.BOOLEAN]: true,
                        [yargs_parser_types_DefaultValuesForTypeKey.STRING]: '',
                        [yargs_parser_types_DefaultValuesForTypeKey.NUMBER]: void 0,
                        [yargs_parser_types_DefaultValuesForTypeKey.ARRAY]: []
                    };
                    return def[type];
                }
                function guessType(key) {
                    let type = yargs_parser_types_DefaultValuesForTypeKey.BOOLEAN;
                    if (checkAllAliases(key, flags.strings)) type = yargs_parser_types_DefaultValuesForTypeKey.STRING;
                    else if (checkAllAliases(key, flags.numbers)) type = yargs_parser_types_DefaultValuesForTypeKey.NUMBER;
                    else if (checkAllAliases(key, flags.bools)) type = yargs_parser_types_DefaultValuesForTypeKey.BOOLEAN;
                    else if (checkAllAliases(key, flags.arrays)) type = yargs_parser_types_DefaultValuesForTypeKey.ARRAY;
                    return type;
                }
                function isUndefined(num) {
                    return void 0 === num;
                }
                function checkConfiguration() {
                    Object.keys(flags.counts).find((key)=>{
                        if (checkAllAliases(key, flags.arrays)) {
                            error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));
                            return true;
                        }
                        if (checkAllAliases(key, flags.nargs)) {
                            error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));
                            return true;
                        }
                        return false;
                    });
                }
                return {
                    aliases: Object.assign({}, flags.aliases),
                    argv: Object.assign(argvReturn, argv),
                    configuration: configuration,
                    defaulted: Object.assign({}, defaulted),
                    error: error,
                    newAliases: Object.assign({}, newAliases)
                };
            }
        }
        function combineAliases(aliases) {
            const aliasArrays = [];
            const combined = Object.create(null);
            let change = true;
            Object.keys(aliases).forEach(function(key) {
                aliasArrays.push([].concat(aliases[key], key));
            });
            while(change){
                change = false;
                for(let i = 0; i < aliasArrays.length; i++)for(let ii = i + 1; ii < aliasArrays.length; ii++){
                    const intersect = aliasArrays[i].filter(function(v) {
                        return -1 !== aliasArrays[ii].indexOf(v);
                    });
                    if (intersect.length) {
                        aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
                        aliasArrays.splice(ii, 1);
                        change = true;
                        break;
                    }
                }
            }
            aliasArrays.forEach(function(aliasArray) {
                aliasArray = aliasArray.filter(function(v, i, self) {
                    return self.indexOf(v) === i;
                });
                const lastAlias = aliasArray.pop();
                if (void 0 !== lastAlias && 'string' == typeof lastAlias) combined[lastAlias] = aliasArray;
            });
            return combined;
        }
        function increment(orig) {
            return void 0 !== orig ? orig + 1 : 1;
        }
        function sanitizeKey(key) {
            if ('__proto__' === key) return '___proto___';
            return key;
        }
        function stripQuotes(val) {
            return 'string' == typeof val && ("'" === val[0] || '"' === val[0]) && val[val.length - 1] === val[0] ? val.substring(1, val.length - 1) : val;
        }
        var external_fs_ = __webpack_require__("fs?fa32");
        /**
 * @fileoverview Main entrypoint for libraries using yargs-parser in Node.js
 * CJS and ESM environments.
 *
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */ var _a, _b, _c;
        const minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;
        const nodeVersion = null != (_b = null == (_a = null == process ? void 0 : process.versions) ? void 0 : _a.node) ? _b : null == (_c = null == process ? void 0 : process.version) ? void 0 : _c.slice(1);
        if (nodeVersion) {
            const major = Number(nodeVersion.match(/^([^.]+)/)[1]);
            if (major < minNodeVersion) throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
        }
        const lib_env = process ? process.env : {};
        const parser = new YargsParser({
            cwd: process.cwd,
            env: ()=>lib_env,
            format: external_util_.format,
            normalize: external_path_.normalize,
            resolve: external_path_.resolve,
            require: (path)=>{
                if ('undefined' != typeof require) return require(path);
                if (path.match(/\.json$/)) return JSON.parse((0, external_fs_.readFileSync)(path, 'utf8'));
                throw Error('only .json config files are supported in ESM');
            }
        });
        const yargsParser = function(args, opts) {
            const result = parser.parse(args.slice(), opts);
            return result.argv;
        };
        yargsParser.detailed = function(args, opts) {
            return parser.parse(args.slice(), opts);
        };
        yargsParser.camelCase = camelCase;
        yargsParser.decamelize = decamelize;
        yargsParser.looksLikeNumber = looksLikeNumber;
        const lib = yargsParser;
    },
    "../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/utils/apply-extends.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            J: ()=>applyExtends
        });
        var _yerror_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/yerror.js");
        let previouslyVisitedConfigs = [];
        let shim;
        function applyExtends(config, cwd, mergeExtends, _shim) {
            shim = _shim;
            let defaultConfig = {};
            if (Object.prototype.hasOwnProperty.call(config, 'extends')) {
                if ('string' != typeof config.extends) return defaultConfig;
                const isPath = /\.json|\..*rc$/.test(config.extends);
                let pathToDefault = null;
                if (isPath) pathToDefault = getPathToDefaultConfig(cwd, config.extends);
                else try {
                    pathToDefault = require.resolve(config.extends);
                } catch (_err) {
                    return config;
                }
                checkForCircularExtends(pathToDefault);
                previouslyVisitedConfigs.push(pathToDefault);
                defaultConfig = isPath ? JSON.parse(shim.readFileSync(pathToDefault, 'utf8')) : require(config.extends);
                delete config.extends;
                defaultConfig = applyExtends(defaultConfig, shim.path.dirname(pathToDefault), mergeExtends, shim);
            }
            previouslyVisitedConfigs = [];
            return mergeExtends ? mergeDeep(defaultConfig, config) : Object.assign({}, defaultConfig, config);
        }
        function checkForCircularExtends(cfgPath) {
            if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) throw new _yerror_js__WEBPACK_IMPORTED_MODULE_0__.s(`Circular extended configurations: '${cfgPath}'.`);
        }
        function getPathToDefaultConfig(cwd, pathToExtend) {
            return shim.path.resolve(cwd, pathToExtend);
        }
        function mergeDeep(config1, config2) {
            const target = {};
            function isObject(obj) {
                return obj && 'object' == typeof obj && !Array.isArray(obj);
            }
            Object.assign(target, config1);
            for (const key of Object.keys(config2))if (isObject(config2[key]) && isObject(target[key])) target[key] = mergeDeep(config1[key], config2[key]);
            else target[key] = config2[key];
            return target;
        }
    },
    "../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/utils/process-argv.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            E: ()=>getProcessArgvBin,
            b: ()=>hideBin
        });
        function getProcessArgvBinIndex() {
            if (isBundledElectronApp()) return 0;
            return 1;
        }
        function isBundledElectronApp() {
            return isElectronApp() && !process.defaultApp;
        }
        function isElectronApp() {
            return !!process.versions.electron;
        }
        function hideBin(argv) {
            return argv.slice(getProcessArgvBinIndex() + 1);
        }
        function getProcessArgvBin() {
            return process.argv[getProcessArgvBinIndex()];
        }
    },
    "../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/yerror.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            s: ()=>YError
        });
        class YError extends Error {
            constructor(msg){
                super(msg || 'yargs error');
                this.name = 'YError';
                if (Error.captureStackTrace) Error.captureStackTrace(this, YError);
            }
        }
    },
    "../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/lib/platform-shims/esm.mjs": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            Z: ()=>esm
        });
        var external_assert_ = __webpack_require__("assert");
        const align = {
            right: alignRight,
            center: alignCenter
        };
        const lib_top = 0;
        const right = 1;
        const bottom = 2;
        const left = 3;
        class UI {
            constructor(opts){
                var _a;
                this.width = opts.width;
                this.wrap = null != (_a = opts.wrap) ? _a : true;
                this.rows = [];
            }
            span(...args) {
                const cols = this.div(...args);
                cols.span = true;
            }
            resetOutput() {
                this.rows = [];
            }
            div(...args) {
                if (0 === args.length) this.div('');
                if (this.wrap && this.shouldApplyLayoutDSL(...args) && 'string' == typeof args[0]) return this.applyLayoutDSL(args[0]);
                const cols = args.map((arg)=>{
                    if ('string' == typeof arg) return this.colFromString(arg);
                    return arg;
                });
                this.rows.push(cols);
                return cols;
            }
            shouldApplyLayoutDSL(...args) {
                return 1 === args.length && 'string' == typeof args[0] && /[\t\n]/.test(args[0]);
            }
            applyLayoutDSL(str) {
                const rows = str.split('\n').map((row)=>row.split('\t'));
                let leftColumnWidth = 0;
                rows.forEach((columns)=>{
                    if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) leftColumnWidth = Math.min(Math.floor(0.5 * this.width), mixin.stringWidth(columns[0]));
                });
                rows.forEach((columns)=>{
                    this.div(...columns.map((r, i)=>({
                            text: r.trim(),
                            padding: this.measurePadding(r),
                            width: 0 === i && columns.length > 1 ? leftColumnWidth : void 0
                        })));
                });
                return this.rows[this.rows.length - 1];
            }
            colFromString(text) {
                return {
                    text,
                    padding: this.measurePadding(text)
                };
            }
            measurePadding(str) {
                const noAnsi = mixin.stripAnsi(str);
                return [
                    0,
                    noAnsi.match(/\s*$/)[0].length,
                    0,
                    noAnsi.match(/^\s*/)[0].length
                ];
            }
            toString() {
                const lines = [];
                this.rows.forEach((row)=>{
                    this.rowToString(row, lines);
                });
                return lines.filter((line)=>!line.hidden).map((line)=>line.text).join('\n');
            }
            rowToString(row, lines) {
                this.rasterize(row).forEach((rrow, r)=>{
                    let str = '';
                    rrow.forEach((col, c)=>{
                        const { width } = row[c];
                        const wrapWidth = this.negatePadding(row[c]);
                        let ts = col;
                        if (wrapWidth > mixin.stringWidth(col)) ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));
                        if (row[c].align && 'left' !== row[c].align && this.wrap) {
                            const fn = align[row[c].align];
                            ts = fn(ts, wrapWidth);
                            if (mixin.stringWidth(ts) < wrapWidth) ts += ' '.repeat((width || 0) - mixin.stringWidth(ts) - 1);
                        }
                        const padding = row[c].padding || [
                            0,
                            0,
                            0,
                            0
                        ];
                        if (padding[left]) str += ' '.repeat(padding[left]);
                        str += addBorder(row[c], ts, '| ');
                        str += ts;
                        str += addBorder(row[c], ts, ' |');
                        if (padding[right]) str += ' '.repeat(padding[right]);
                        if (0 === r && lines.length > 0) str = this.renderInline(str, lines[lines.length - 1]);
                    });
                    lines.push({
                        text: str.replace(/ +$/, ''),
                        span: row.span
                    });
                });
                return lines;
            }
            renderInline(source, previousLine) {
                const match = source.match(/^ */);
                const leadingWhitespace = match ? match[0].length : 0;
                const target = previousLine.text;
                const targetTextWidth = mixin.stringWidth(target.trimRight());
                if (!previousLine.span) return source;
                if (!this.wrap) {
                    previousLine.hidden = true;
                    return target + source;
                }
                if (leadingWhitespace < targetTextWidth) return source;
                previousLine.hidden = true;
                return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
            }
            rasterize(row) {
                const rrows = [];
                const widths = this.columnWidths(row);
                let wrapped;
                row.forEach((col, c)=>{
                    col.width = widths[c];
                    wrapped = this.wrap ? mixin.wrap(col.text, this.negatePadding(col), {
                        hard: true
                    }).split('\n') : col.text.split('\n');
                    if (col.border) {
                        wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');
                        wrapped.push("'" + '-'.repeat(this.negatePadding(col) + 2) + "'");
                    }
                    if (col.padding) {
                        wrapped.unshift(...new Array(col.padding[lib_top] || 0).fill(''));
                        wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));
                    }
                    wrapped.forEach((str, r)=>{
                        if (!rrows[r]) rrows.push([]);
                        const rrow = rrows[r];
                        for(let i = 0; i < c; i++)if (void 0 === rrow[i]) rrow.push('');
                        rrow.push(str);
                    });
                });
                return rrows;
            }
            negatePadding(col) {
                let wrapWidth = col.width || 0;
                if (col.padding) wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
                if (col.border) wrapWidth -= 4;
                return wrapWidth;
            }
            columnWidths(row) {
                if (!this.wrap) return row.map((col)=>col.width || mixin.stringWidth(col.text));
                let unset = row.length;
                let remainingWidth = this.width;
                const widths = row.map((col)=>{
                    if (col.width) {
                        unset--;
                        remainingWidth -= col.width;
                        return col.width;
                    }
                });
                const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
                return widths.map((w, i)=>{
                    if (void 0 === w) return Math.max(unsetWidth, _minWidth(row[i]));
                    return w;
                });
            }
        }
        function addBorder(col, ts, style) {
            if (col.border) {
                if (/[.']-+[.']/.test(ts)) return '';
                if (0 !== ts.trim().length) return style;
                return '  ';
            }
            return '';
        }
        function _minWidth(col) {
            const padding = col.padding || [];
            const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
            if (col.border) return minWidth + 4;
            return minWidth;
        }
        function getWindowWidth() {
            if ('object' == typeof process && process.stdout && process.stdout.columns) return process.stdout.columns;
            return 80;
        }
        function alignRight(str, width) {
            str = str.trim();
            const strWidth = mixin.stringWidth(str);
            if (strWidth < width) return ' '.repeat(width - strWidth) + str;
            return str;
        }
        function alignCenter(str, width) {
            str = str.trim();
            const strWidth = mixin.stringWidth(str);
            if (strWidth >= width) return str;
            return ' '.repeat(width - strWidth >> 1) + str;
        }
        let mixin;
        function cliui(opts, _mixin) {
            mixin = _mixin;
            return new UI({
                width: (null == opts ? void 0 : opts.width) || getWindowWidth(),
                wrap: null == opts ? void 0 : opts.wrap
            });
        }
        const ansi = new RegExp("\x1b(?:\\[(?:\\d+[ABCDEFGJKSTm]|\\d+;\\d+[Hfm]|\\d+;\\d+;\\d+m|6n|s|u|\\?25[lh])|\\w)", 'g');
        function stripAnsi(str) {
            return str.replace(ansi, '');
        }
        function wrap(str, width) {
            const [start, end] = str.match(ansi) || [
                '',
                ''
            ];
            str = stripAnsi(str);
            let wrapped = '';
            for(let i = 0; i < str.length; i++){
                if (0 !== i && i % width === 0) wrapped += '\n';
                wrapped += str.charAt(i);
            }
            if (start && end) wrapped = `${start}${wrapped}${end}`;
            return wrapped;
        }
        function ui(opts) {
            return cliui(opts, {
                stringWidth: (str)=>[
                        ...str
                    ].length,
                stripAnsi: stripAnsi,
                wrap: wrap
            });
        }
        var external_path_ = __webpack_require__("path");
        var external_fs_ = __webpack_require__("fs?fa32");
        function sync(start, callback) {
            let dir = (0, external_path_.resolve)('.', start);
            let tmp, stats = (0, external_fs_.statSync)(dir);
            if (!stats.isDirectory()) dir = (0, external_path_.dirname)(dir);
            while(true){
                tmp = callback(dir, (0, external_fs_.readdirSync)(dir));
                if (tmp) return (0, external_path_.resolve)(dir, tmp);
                dir = (0, external_path_.dirname)(tmp = dir);
                if (tmp === dir) break;
            }
        }
        var external_util_ = __webpack_require__("util");
        var external_url_ = __webpack_require__("url");
        var lib = __webpack_require__("../node_modules/.pnpm/yargs-parser@21.1.1/node_modules/yargs-parser/build/lib/index.js");
        var process_argv = __webpack_require__("../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/utils/process-argv.js");
        var yerror = __webpack_require__("../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/yerror.js");
        const node = {
            fs: {
                readFileSync: external_fs_.readFileSync,
                writeFile: external_fs_.writeFile
            },
            format: external_util_.format,
            resolve: external_path_.resolve,
            exists: (file)=>{
                try {
                    return (0, external_fs_.statSync)(file).isFile();
                } catch (err) {
                    return false;
                }
            }
        };
        let shim;
        class Y18N {
            constructor(opts){
                opts = opts || {};
                this.directory = opts.directory || './locales';
                this.updateFiles = 'boolean' == typeof opts.updateFiles ? opts.updateFiles : true;
                this.locale = opts.locale || 'en';
                this.fallbackToLanguage = 'boolean' == typeof opts.fallbackToLanguage ? opts.fallbackToLanguage : true;
                this.cache = Object.create(null);
                this.writeQueue = [];
            }
            __(...args) {
                if ('string' != typeof arguments[0]) return this._taggedLiteral(arguments[0], ...arguments);
                const str = args.shift();
                let cb = function() {};
                if ('function' == typeof args[args.length - 1]) cb = args.pop();
                cb = cb || function() {};
                if (!this.cache[this.locale]) this._readLocaleFile();
                if (!this.cache[this.locale][str] && this.updateFiles) {
                    this.cache[this.locale][str] = str;
                    this._enqueueWrite({
                        directory: this.directory,
                        locale: this.locale,
                        cb
                    });
                } else cb();
                return shim.format.apply(shim.format, [
                    this.cache[this.locale][str] || str
                ].concat(args));
            }
            __n() {
                const args = Array.prototype.slice.call(arguments);
                const singular = args.shift();
                const plural = args.shift();
                const quantity = args.shift();
                let cb = function() {};
                if ('function' == typeof args[args.length - 1]) cb = args.pop();
                if (!this.cache[this.locale]) this._readLocaleFile();
                let str = 1 === quantity ? singular : plural;
                if (this.cache[this.locale][singular]) {
                    const entry = this.cache[this.locale][singular];
                    str = entry[1 === quantity ? 'one' : 'other'];
                }
                if (!this.cache[this.locale][singular] && this.updateFiles) {
                    this.cache[this.locale][singular] = {
                        one: singular,
                        other: plural
                    };
                    this._enqueueWrite({
                        directory: this.directory,
                        locale: this.locale,
                        cb
                    });
                } else cb();
                const values = [
                    str
                ];
                if (~str.indexOf('%d')) values.push(quantity);
                return shim.format.apply(shim.format, values.concat(args));
            }
            setLocale(locale) {
                this.locale = locale;
            }
            getLocale() {
                return this.locale;
            }
            updateLocale(obj) {
                if (!this.cache[this.locale]) this._readLocaleFile();
                for(const key in obj)if (Object.prototype.hasOwnProperty.call(obj, key)) this.cache[this.locale][key] = obj[key];
            }
            _taggedLiteral(parts, ...args) {
                let str = '';
                parts.forEach(function(part, i) {
                    const arg = args[i + 1];
                    str += part;
                    if (void 0 !== arg) str += '%s';
                });
                return this.__.apply(this, [
                    str
                ].concat([].slice.call(args, 1)));
            }
            _enqueueWrite(work) {
                this.writeQueue.push(work);
                if (1 === this.writeQueue.length) this._processWriteQueue();
            }
            _processWriteQueue() {
                const _this = this;
                const work = this.writeQueue[0];
                const directory = work.directory;
                const locale = work.locale;
                const cb = work.cb;
                const languageFile = this._resolveLocaleFile(directory, locale);
                const serializedLocale = JSON.stringify(this.cache[locale], null, 2);
                shim.fs.writeFile(languageFile, serializedLocale, 'utf-8', function(err) {
                    _this.writeQueue.shift();
                    if (_this.writeQueue.length > 0) _this._processWriteQueue();
                    cb(err);
                });
            }
            _readLocaleFile() {
                let localeLookup = {};
                const languageFile = this._resolveLocaleFile(this.directory, this.locale);
                try {
                    if (shim.fs.readFileSync) localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, 'utf-8'));
                } catch (err) {
                    if (err instanceof SyntaxError) err.message = 'syntax error in ' + languageFile;
                    if ('ENOENT' === err.code) localeLookup = {};
                    else throw err;
                }
                this.cache[this.locale] = localeLookup;
            }
            _resolveLocaleFile(directory, locale) {
                let file = shim.resolve(directory, './', locale + '.json');
                if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {
                    const languageFile = shim.resolve(directory, './', locale.split('_')[0] + '.json');
                    if (this._fileExistsSync(languageFile)) file = languageFile;
                }
                return file;
            }
            _fileExistsSync(file) {
                return shim.exists(file);
            }
        }
        function lib_y18n(opts, _shim) {
            shim = _shim;
            const y18n = new Y18N(opts);
            return {
                __: y18n.__.bind(y18n),
                __n: y18n.__n.bind(y18n),
                setLocale: y18n.setLocale.bind(y18n),
                getLocale: y18n.getLocale.bind(y18n),
                updateLocale: y18n.updateLocale.bind(y18n),
                locale: y18n.locale
            };
        }
        const y18n_y18n = (opts)=>lib_y18n(opts, node);
        const node_modules_y18n = y18n_y18n;
        const REQUIRE_ERROR = 'require is not supported by ESM';
        const REQUIRE_DIRECTORY_ERROR = 'loading a directory of commands is not supported yet for ESM';
        let esm_dirname;
        try {
            esm_dirname = (0, external_url_.fileURLToPath)(__rslib_import_meta_url__);
        } catch (e) {
            esm_dirname = process.cwd();
        }
        const mainFilename = esm_dirname.substring(0, esm_dirname.lastIndexOf('node_modules'));
        const esm = {
            assert: {
                notStrictEqual: external_assert_.notStrictEqual,
                strictEqual: external_assert_.strictEqual
            },
            cliui: ui,
            findUp: sync,
            getEnv: (key)=>process.env[key],
            inspect: external_util_.inspect,
            getCallerFile: ()=>{
                throw new yerror.s(REQUIRE_DIRECTORY_ERROR);
            },
            getProcessArgvBin: process_argv.E,
            mainFilename: mainFilename || process.cwd(),
            Parser: lib.Z,
            path: {
                basename: external_path_.basename,
                dirname: external_path_.dirname,
                extname: external_path_.extname,
                relative: external_path_.relative,
                resolve: external_path_.resolve
            },
            process: {
                argv: ()=>process.argv,
                cwd: process.cwd,
                emitWarning: (warning, type)=>process.emitWarning(warning, type),
                execPath: ()=>process.execPath,
                exit: process.exit,
                nextTick: process.nextTick,
                stdColumns: void 0 !== process.stdout.columns ? process.stdout.columns : null
            },
            readFileSync: external_fs_.readFileSync,
            require: ()=>{
                throw new yerror.s(REQUIRE_ERROR);
            },
            requireDirectory: ()=>{
                throw new yerror.s(REQUIRE_DIRECTORY_ERROR);
            },
            stringWidth: (str)=>[
                    ...str
                ].length,
            y18n: node_modules_y18n({
                directory: (0, external_path_.resolve)(esm_dirname, '../../../locales'),
                updateFiles: false
            })
        };
    }
};

//# sourceMappingURL=744.js.map