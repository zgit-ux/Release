{"version":3,"file":"945.js","sources":["webpack://@agent-tars/core/../node_modules/.pnpm/buffer-crc32@0.2.13/node_modules/buffer-crc32/index.js","webpack://@agent-tars/core/../node_modules/.pnpm/extract-zip@2.0.1/node_modules/extract-zip/index.js","webpack://@agent-tars/core/../node_modules/.pnpm/fd-slicer@1.1.0/node_modules/fd-slicer/index.js","webpack://@agent-tars/core/../node_modules/.pnpm/pend@1.2.0/node_modules/pend/index.js","webpack://@agent-tars/core/../node_modules/.pnpm/yauzl@2.10.0/node_modules/yauzl/index.js"],"sourcesContent":["var Buffer = require('buffer').Buffer;\n\nvar CRC_TABLE = [\n  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,\n  0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,\n  0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,\n  0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,\n  0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,\n  0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,\n  0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n  0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,\n  0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,\n  0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,\n  0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,\n  0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,\n  0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,\n  0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n  0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,\n  0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,\n  0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,\n  0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,\n  0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,\n  0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,\n  0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,\n  0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,\n  0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,\n  0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,\n  0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,\n  0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,\n  0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n  0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,\n  0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,\n  0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,\n  0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,\n  0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,\n  0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,\n  0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n  0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,\n  0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,\n  0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,\n  0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,\n  0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,\n  0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,\n  0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,\n  0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,\n  0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,\n  0x2d02ef8d\n];\n\nif (typeof Int32Array !== 'undefined') {\n  CRC_TABLE = new Int32Array(CRC_TABLE);\n}\n\nfunction ensureBuffer(input) {\n  if (Buffer.isBuffer(input)) {\n    return input;\n  }\n\n  var hasNewBufferAPI =\n      typeof Buffer.alloc === \"function\" &&\n      typeof Buffer.from === \"function\";\n\n  if (typeof input === \"number\") {\n    return hasNewBufferAPI ? Buffer.alloc(input) : new Buffer(input);\n  }\n  else if (typeof input === \"string\") {\n    return hasNewBufferAPI ? Buffer.from(input) : new Buffer(input);\n  }\n  else {\n    throw new Error(\"input must be buffer, number, or string, received \" +\n                    typeof input);\n  }\n}\n\nfunction bufferizeInt(num) {\n  var tmp = ensureBuffer(4);\n  tmp.writeInt32BE(num, 0);\n  return tmp;\n}\n\nfunction _crc32(buf, previous) {\n  buf = ensureBuffer(buf);\n  if (Buffer.isBuffer(previous)) {\n    previous = previous.readUInt32BE(0);\n  }\n  var crc = ~~previous ^ -1;\n  for (var n = 0; n < buf.length; n++) {\n    crc = CRC_TABLE[(crc ^ buf[n]) & 0xff] ^ (crc >>> 8);\n  }\n  return (crc ^ -1);\n}\n\nfunction crc32() {\n  return bufferizeInt(_crc32.apply(null, arguments));\n}\ncrc32.signed = function () {\n  return _crc32.apply(null, arguments);\n};\ncrc32.unsigned = function () {\n  return _crc32.apply(null, arguments) >>> 0;\n};\n\nmodule.exports = crc32;\n","const debug = require('debug')('extract-zip')\n// eslint-disable-next-line node/no-unsupported-features/node-builtins\nconst { createWriteStream, promises: fs } = require('fs')\nconst getStream = require('get-stream')\nconst path = require('path')\nconst { promisify } = require('util')\nconst stream = require('stream')\nconst yauzl = require('yauzl')\n\nconst openZip = promisify(yauzl.open)\nconst pipeline = promisify(stream.pipeline)\n\nclass Extractor {\n  constructor (zipPath, opts) {\n    this.zipPath = zipPath\n    this.opts = opts\n  }\n\n  async extract () {\n    debug('opening', this.zipPath, 'with opts', this.opts)\n\n    this.zipfile = await openZip(this.zipPath, { lazyEntries: true })\n    this.canceled = false\n\n    return new Promise((resolve, reject) => {\n      this.zipfile.on('error', err => {\n        this.canceled = true\n        reject(err)\n      })\n      this.zipfile.readEntry()\n\n      this.zipfile.on('close', () => {\n        if (!this.canceled) {\n          debug('zip extraction complete')\n          resolve()\n        }\n      })\n\n      this.zipfile.on('entry', async entry => {\n        /* istanbul ignore if */\n        if (this.canceled) {\n          debug('skipping entry', entry.fileName, { cancelled: this.canceled })\n          return\n        }\n\n        debug('zipfile entry', entry.fileName)\n\n        if (entry.fileName.startsWith('__MACOSX/')) {\n          this.zipfile.readEntry()\n          return\n        }\n\n        const destDir = path.dirname(path.join(this.opts.dir, entry.fileName))\n\n        try {\n          await fs.mkdir(destDir, { recursive: true })\n\n          const canonicalDestDir = await fs.realpath(destDir)\n          const relativeDestDir = path.relative(this.opts.dir, canonicalDestDir)\n\n          if (relativeDestDir.split(path.sep).includes('..')) {\n            throw new Error(`Out of bound path \"${canonicalDestDir}\" found while processing file ${entry.fileName}`)\n          }\n\n          await this.extractEntry(entry)\n          debug('finished processing', entry.fileName)\n          this.zipfile.readEntry()\n        } catch (err) {\n          this.canceled = true\n          this.zipfile.close()\n          reject(err)\n        }\n      })\n    })\n  }\n\n  async extractEntry (entry) {\n    /* istanbul ignore if */\n    if (this.canceled) {\n      debug('skipping entry extraction', entry.fileName, { cancelled: this.canceled })\n      return\n    }\n\n    if (this.opts.onEntry) {\n      this.opts.onEntry(entry, this.zipfile)\n    }\n\n    const dest = path.join(this.opts.dir, entry.fileName)\n\n    // convert external file attr int into a fs stat mode int\n    const mode = (entry.externalFileAttributes >> 16) & 0xFFFF\n    // check if it's a symlink or dir (using stat mode constants)\n    const IFMT = 61440\n    const IFDIR = 16384\n    const IFLNK = 40960\n    const symlink = (mode & IFMT) === IFLNK\n    let isDir = (mode & IFMT) === IFDIR\n\n    // Failsafe, borrowed from jsZip\n    if (!isDir && entry.fileName.endsWith('/')) {\n      isDir = true\n    }\n\n    // check for windows weird way of specifying a directory\n    // https://github.com/maxogden/extract-zip/issues/13#issuecomment-154494566\n    const madeBy = entry.versionMadeBy >> 8\n    if (!isDir) isDir = (madeBy === 0 && entry.externalFileAttributes === 16)\n\n    debug('extracting entry', { filename: entry.fileName, isDir: isDir, isSymlink: symlink })\n\n    const procMode = this.getExtractedMode(mode, isDir) & 0o777\n\n    // always ensure folders are created\n    const destDir = isDir ? dest : path.dirname(dest)\n\n    const mkdirOptions = { recursive: true }\n    if (isDir) {\n      mkdirOptions.mode = procMode\n    }\n    debug('mkdir', { dir: destDir, ...mkdirOptions })\n    await fs.mkdir(destDir, mkdirOptions)\n    if (isDir) return\n\n    debug('opening read stream', dest)\n    const readStream = await promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry)\n\n    if (symlink) {\n      const link = await getStream(readStream)\n      debug('creating symlink', link, dest)\n      await fs.symlink(link, dest)\n    } else {\n      await pipeline(readStream, createWriteStream(dest, { mode: procMode }))\n    }\n  }\n\n  getExtractedMode (entryMode, isDir) {\n    let mode = entryMode\n    // Set defaults, if necessary\n    if (mode === 0) {\n      if (isDir) {\n        if (this.opts.defaultDirMode) {\n          mode = parseInt(this.opts.defaultDirMode, 10)\n        }\n\n        if (!mode) {\n          mode = 0o755\n        }\n      } else {\n        if (this.opts.defaultFileMode) {\n          mode = parseInt(this.opts.defaultFileMode, 10)\n        }\n\n        if (!mode) {\n          mode = 0o644\n        }\n      }\n    }\n\n    return mode\n  }\n}\n\nmodule.exports = async function (zipPath, opts) {\n  debug('creating target directory', opts.dir)\n\n  if (!path.isAbsolute(opts.dir)) {\n    throw new Error('Target directory is expected to be absolute')\n  }\n\n  await fs.mkdir(opts.dir, { recursive: true })\n  opts.dir = await fs.realpath(opts.dir)\n  return new Extractor(zipPath, opts).extract()\n}\n","var fs = require('fs');\nvar util = require('util');\nvar stream = require('stream');\nvar Readable = stream.Readable;\nvar Writable = stream.Writable;\nvar PassThrough = stream.PassThrough;\nvar Pend = require('pend');\nvar EventEmitter = require('events').EventEmitter;\n\nexports.createFromBuffer = createFromBuffer;\nexports.createFromFd = createFromFd;\nexports.BufferSlicer = BufferSlicer;\nexports.FdSlicer = FdSlicer;\n\nutil.inherits(FdSlicer, EventEmitter);\nfunction FdSlicer(fd, options) {\n  options = options || {};\n  EventEmitter.call(this);\n\n  this.fd = fd;\n  this.pend = new Pend();\n  this.pend.max = 1;\n  this.refCount = 0;\n  this.autoClose = !!options.autoClose;\n}\n\nFdSlicer.prototype.read = function(buffer, offset, length, position, callback) {\n  var self = this;\n  self.pend.go(function(cb) {\n    fs.read(self.fd, buffer, offset, length, position, function(err, bytesRead, buffer) {\n      cb();\n      callback(err, bytesRead, buffer);\n    });\n  });\n};\n\nFdSlicer.prototype.write = function(buffer, offset, length, position, callback) {\n  var self = this;\n  self.pend.go(function(cb) {\n    fs.write(self.fd, buffer, offset, length, position, function(err, written, buffer) {\n      cb();\n      callback(err, written, buffer);\n    });\n  });\n};\n\nFdSlicer.prototype.createReadStream = function(options) {\n  return new ReadStream(this, options);\n};\n\nFdSlicer.prototype.createWriteStream = function(options) {\n  return new WriteStream(this, options);\n};\n\nFdSlicer.prototype.ref = function() {\n  this.refCount += 1;\n};\n\nFdSlicer.prototype.unref = function() {\n  var self = this;\n  self.refCount -= 1;\n\n  if (self.refCount > 0) return;\n  if (self.refCount < 0) throw new Error(\"invalid unref\");\n\n  if (self.autoClose) {\n    fs.close(self.fd, onCloseDone);\n  }\n\n  function onCloseDone(err) {\n    if (err) {\n      self.emit('error', err);\n    } else {\n      self.emit('close');\n    }\n  }\n};\n\nutil.inherits(ReadStream, Readable);\nfunction ReadStream(context, options) {\n  options = options || {};\n  Readable.call(this, options);\n\n  this.context = context;\n  this.context.ref();\n\n  this.start = options.start || 0;\n  this.endOffset = options.end;\n  this.pos = this.start;\n  this.destroyed = false;\n}\n\nReadStream.prototype._read = function(n) {\n  var self = this;\n  if (self.destroyed) return;\n\n  var toRead = Math.min(self._readableState.highWaterMark, n);\n  if (self.endOffset != null) {\n    toRead = Math.min(toRead, self.endOffset - self.pos);\n  }\n  if (toRead <= 0) {\n    self.destroyed = true;\n    self.push(null);\n    self.context.unref();\n    return;\n  }\n  self.context.pend.go(function(cb) {\n    if (self.destroyed) return cb();\n    var buffer = new Buffer(toRead);\n    fs.read(self.context.fd, buffer, 0, toRead, self.pos, function(err, bytesRead) {\n      if (err) {\n        self.destroy(err);\n      } else if (bytesRead === 0) {\n        self.destroyed = true;\n        self.push(null);\n        self.context.unref();\n      } else {\n        self.pos += bytesRead;\n        self.push(buffer.slice(0, bytesRead));\n      }\n      cb();\n    });\n  });\n};\n\nReadStream.prototype.destroy = function(err) {\n  if (this.destroyed) return;\n  err = err || new Error(\"stream destroyed\");\n  this.destroyed = true;\n  this.emit('error', err);\n  this.context.unref();\n};\n\nutil.inherits(WriteStream, Writable);\nfunction WriteStream(context, options) {\n  options = options || {};\n  Writable.call(this, options);\n\n  this.context = context;\n  this.context.ref();\n\n  this.start = options.start || 0;\n  this.endOffset = (options.end == null) ? Infinity : +options.end;\n  this.bytesWritten = 0;\n  this.pos = this.start;\n  this.destroyed = false;\n\n  this.on('finish', this.destroy.bind(this));\n}\n\nWriteStream.prototype._write = function(buffer, encoding, callback) {\n  var self = this;\n  if (self.destroyed) return;\n\n  if (self.pos + buffer.length > self.endOffset) {\n    var err = new Error(\"maximum file length exceeded\");\n    err.code = 'ETOOBIG';\n    self.destroy();\n    callback(err);\n    return;\n  }\n  self.context.pend.go(function(cb) {\n    if (self.destroyed) return cb();\n    fs.write(self.context.fd, buffer, 0, buffer.length, self.pos, function(err, bytes) {\n      if (err) {\n        self.destroy();\n        cb();\n        callback(err);\n      } else {\n        self.bytesWritten += bytes;\n        self.pos += bytes;\n        self.emit('progress');\n        cb();\n        callback();\n      }\n    });\n  });\n};\n\nWriteStream.prototype.destroy = function() {\n  if (this.destroyed) return;\n  this.destroyed = true;\n  this.context.unref();\n};\n\nutil.inherits(BufferSlicer, EventEmitter);\nfunction BufferSlicer(buffer, options) {\n  EventEmitter.call(this);\n\n  options = options || {};\n  this.refCount = 0;\n  this.buffer = buffer;\n  this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;\n}\n\nBufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {\n  var end = position + length;\n  var delta = end - this.buffer.length;\n  var written = (delta > 0) ? delta : length;\n  this.buffer.copy(buffer, offset, position, end);\n  setImmediate(function() {\n    callback(null, written);\n  });\n};\n\nBufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {\n  buffer.copy(this.buffer, position, offset, offset + length);\n  setImmediate(function() {\n    callback(null, length, buffer);\n  });\n};\n\nBufferSlicer.prototype.createReadStream = function(options) {\n  options = options || {};\n  var readStream = new PassThrough(options);\n  readStream.destroyed = false;\n  readStream.start = options.start || 0;\n  readStream.endOffset = options.end;\n  // by the time this function returns, we'll be done.\n  readStream.pos = readStream.endOffset || this.buffer.length;\n\n  // respect the maxChunkSize option to slice up the chunk into smaller pieces.\n  var entireSlice = this.buffer.slice(readStream.start, readStream.pos);\n  var offset = 0;\n  while (true) {\n    var nextOffset = offset + this.maxChunkSize;\n    if (nextOffset >= entireSlice.length) {\n      // last chunk\n      if (offset < entireSlice.length) {\n        readStream.write(entireSlice.slice(offset, entireSlice.length));\n      }\n      break;\n    }\n    readStream.write(entireSlice.slice(offset, nextOffset));\n    offset = nextOffset;\n  }\n\n  readStream.end();\n  readStream.destroy = function() {\n    readStream.destroyed = true;\n  };\n  return readStream;\n};\n\nBufferSlicer.prototype.createWriteStream = function(options) {\n  var bufferSlicer = this;\n  options = options || {};\n  var writeStream = new Writable(options);\n  writeStream.start = options.start || 0;\n  writeStream.endOffset = (options.end == null) ? this.buffer.length : +options.end;\n  writeStream.bytesWritten = 0;\n  writeStream.pos = writeStream.start;\n  writeStream.destroyed = false;\n  writeStream._write = function(buffer, encoding, callback) {\n    if (writeStream.destroyed) return;\n\n    var end = writeStream.pos + buffer.length;\n    if (end > writeStream.endOffset) {\n      var err = new Error(\"maximum file length exceeded\");\n      err.code = 'ETOOBIG';\n      writeStream.destroyed = true;\n      callback(err);\n      return;\n    }\n    buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);\n\n    writeStream.bytesWritten += buffer.length;\n    writeStream.pos = end;\n    writeStream.emit('progress');\n    callback();\n  };\n  writeStream.destroy = function() {\n    writeStream.destroyed = true;\n  };\n  return writeStream;\n};\n\nBufferSlicer.prototype.ref = function() {\n  this.refCount += 1;\n};\n\nBufferSlicer.prototype.unref = function() {\n  this.refCount -= 1;\n\n  if (this.refCount < 0) {\n    throw new Error(\"invalid unref\");\n  }\n};\n\nfunction createFromBuffer(buffer, options) {\n  return new BufferSlicer(buffer, options);\n}\n\nfunction createFromFd(fd, options) {\n  return new FdSlicer(fd, options);\n}\n","module.exports = Pend;\n\nfunction Pend() {\n  this.pending = 0;\n  this.max = Infinity;\n  this.listeners = [];\n  this.waiting = [];\n  this.error = null;\n}\n\nPend.prototype.go = function(fn) {\n  if (this.pending < this.max) {\n    pendGo(this, fn);\n  } else {\n    this.waiting.push(fn);\n  }\n};\n\nPend.prototype.wait = function(cb) {\n  if (this.pending === 0) {\n    cb(this.error);\n  } else {\n    this.listeners.push(cb);\n  }\n};\n\nPend.prototype.hold = function() {\n  return pendHold(this);\n};\n\nfunction pendHold(self) {\n  self.pending += 1;\n  var called = false;\n  return onCb;\n  function onCb(err) {\n    if (called) throw new Error(\"callback called twice\");\n    called = true;\n    self.error = self.error || err;\n    self.pending -= 1;\n    if (self.waiting.length > 0 && self.pending < self.max) {\n      pendGo(self, self.waiting.shift());\n    } else if (self.pending === 0) {\n      var listeners = self.listeners;\n      self.listeners = [];\n      listeners.forEach(cbListener);\n    }\n  }\n  function cbListener(listener) {\n    listener(self.error);\n  }\n}\n\nfunction pendGo(self, fn) {\n  fn(pendHold(self));\n}\n","var fs = require(\"fs\");\nvar zlib = require(\"zlib\");\nvar fd_slicer = require(\"fd-slicer\");\nvar crc32 = require(\"buffer-crc32\");\nvar util = require(\"util\");\nvar EventEmitter = require(\"events\").EventEmitter;\nvar Transform = require(\"stream\").Transform;\nvar PassThrough = require(\"stream\").PassThrough;\nvar Writable = require(\"stream\").Writable;\n\nexports.open = open;\nexports.fromFd = fromFd;\nexports.fromBuffer = fromBuffer;\nexports.fromRandomAccessReader = fromRandomAccessReader;\nexports.dosDateTimeToDate = dosDateTimeToDate;\nexports.validateFileName = validateFileName;\nexports.ZipFile = ZipFile;\nexports.Entry = Entry;\nexports.RandomAccessReader = RandomAccessReader;\n\nfunction open(path, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = true;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  fs.open(path, \"r\", function(err, fd) {\n    if (err) return callback(err);\n    fromFd(fd, options, function(err, zipfile) {\n      if (err) fs.close(fd, defaultCallback);\n      callback(err, zipfile);\n    });\n  });\n}\n\nfunction fromFd(fd, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = false;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  fs.fstat(fd, function(err, stats) {\n    if (err) return callback(err);\n    var reader = fd_slicer.createFromFd(fd, {autoClose: true});\n    fromRandomAccessReader(reader, stats.size, options, callback);\n  });\n}\n\nfunction fromBuffer(buffer, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  options.autoClose = false;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  // limit the max chunk size. see https://github.com/thejoshwolfe/yauzl/issues/87\n  var reader = fd_slicer.createFromBuffer(buffer, {maxChunkSize: 0x10000});\n  fromRandomAccessReader(reader, buffer.length, options, callback);\n}\n\nfunction fromRandomAccessReader(reader, totalSize, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = true;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  var decodeStrings = !!options.decodeStrings;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  if (typeof totalSize !== \"number\") throw new Error(\"expected totalSize parameter to be a number\");\n  if (totalSize > Number.MAX_SAFE_INTEGER) {\n    throw new Error(\"zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.\");\n  }\n\n  // the matching unref() call is in zipfile.close()\n  reader.ref();\n\n  // eocdr means End of Central Directory Record.\n  // search backwards for the eocdr signature.\n  // the last field of the eocdr is a variable-length comment.\n  // the comment size is encoded in a 2-byte field in the eocdr, which we can't find without trudging backwards through the comment to find it.\n  // as a consequence of this design decision, it's possible to have ambiguous zip file metadata if a coherent eocdr was in the comment.\n  // we search backwards for a eocdr signature, and hope that whoever made the zip file was smart enough to forbid the eocdr signature in the comment.\n  var eocdrWithoutCommentSize = 22;\n  var maxCommentSize = 0xffff; // 2-byte size\n  var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);\n  var buffer = newBuffer(bufferSize);\n  var bufferReadStart = totalSize - buffer.length;\n  readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {\n    if (err) return callback(err);\n    for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {\n      if (buffer.readUInt32LE(i) !== 0x06054b50) continue;\n      // found eocdr\n      var eocdrBuffer = buffer.slice(i);\n\n      // 0 - End of central directory signature = 0x06054b50\n      // 4 - Number of this disk\n      var diskNumber = eocdrBuffer.readUInt16LE(4);\n      if (diskNumber !== 0) {\n        return callback(new Error(\"multi-disk zip files are not supported: found disk number: \" + diskNumber));\n      }\n      // 6 - Disk where central directory starts\n      // 8 - Number of central directory records on this disk\n      // 10 - Total number of central directory records\n      var entryCount = eocdrBuffer.readUInt16LE(10);\n      // 12 - Size of central directory (bytes)\n      // 16 - Offset of start of central directory, relative to start of archive\n      var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);\n      // 20 - Comment length\n      var commentLength = eocdrBuffer.readUInt16LE(20);\n      var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;\n      if (commentLength !== expectedCommentLength) {\n        return callback(new Error(\"invalid comment length. expected: \" + expectedCommentLength + \". found: \" + commentLength));\n      }\n      // 22 - Comment\n      // the encoding is always cp437.\n      var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false)\n                                  : eocdrBuffer.slice(22);\n\n      if (!(entryCount === 0xffff || centralDirectoryOffset === 0xffffffff)) {\n        return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));\n      }\n\n      // ZIP64 format\n\n      // ZIP64 Zip64 end of central directory locator\n      var zip64EocdlBuffer = newBuffer(20);\n      var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;\n      readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err) {\n        if (err) return callback(err);\n\n        // 0 - zip64 end of central dir locator signature = 0x07064b50\n        if (zip64EocdlBuffer.readUInt32LE(0) !== 0x07064b50) {\n          return callback(new Error(\"invalid zip64 end of central directory locator signature\"));\n        }\n        // 4 - number of the disk with the start of the zip64 end of central directory\n        // 8 - relative offset of the zip64 end of central directory record\n        var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);\n        // 16 - total number of disks\n\n        // ZIP64 end of central directory record\n        var zip64EocdrBuffer = newBuffer(56);\n        readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err) {\n          if (err) return callback(err);\n\n          // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)\n          if (zip64EocdrBuffer.readUInt32LE(0) !== 0x06064b50) {\n            return callback(new Error(\"invalid zip64 end of central directory record signature\"));\n          }\n          // 4 - size of zip64 end of central directory record                8 bytes\n          // 12 - version made by                                             2 bytes\n          // 14 - version needed to extract                                   2 bytes\n          // 16 - number of this disk                                         4 bytes\n          // 20 - number of the disk with the start of the central directory  4 bytes\n          // 24 - total number of entries in the central directory on this disk         8 bytes\n          // 32 - total number of entries in the central directory            8 bytes\n          entryCount = readUInt64LE(zip64EocdrBuffer, 32);\n          // 40 - size of the central directory                               8 bytes\n          // 48 - offset of start of central directory with respect to the starting disk number     8 bytes\n          centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);\n          // 56 - zip64 extensible data sector                                (variable size)\n          return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));\n        });\n      });\n      return;\n    }\n    callback(new Error(\"end of central directory record signature not found\"));\n  });\n}\n\nutil.inherits(ZipFile, EventEmitter);\nfunction ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {\n  var self = this;\n  EventEmitter.call(self);\n  self.reader = reader;\n  // forward close events\n  self.reader.on(\"error\", function(err) {\n    // error closing the fd\n    emitError(self, err);\n  });\n  self.reader.once(\"close\", function() {\n    self.emit(\"close\");\n  });\n  self.readEntryCursor = centralDirectoryOffset;\n  self.fileSize = fileSize;\n  self.entryCount = entryCount;\n  self.comment = comment;\n  self.entriesRead = 0;\n  self.autoClose = !!autoClose;\n  self.lazyEntries = !!lazyEntries;\n  self.decodeStrings = !!decodeStrings;\n  self.validateEntrySizes = !!validateEntrySizes;\n  self.strictFileNames = !!strictFileNames;\n  self.isOpen = true;\n  self.emittedError = false;\n\n  if (!self.lazyEntries) self._readEntry();\n}\nZipFile.prototype.close = function() {\n  if (!this.isOpen) return;\n  this.isOpen = false;\n  this.reader.unref();\n};\n\nfunction emitErrorAndAutoClose(self, err) {\n  if (self.autoClose) self.close();\n  emitError(self, err);\n}\nfunction emitError(self, err) {\n  if (self.emittedError) return;\n  self.emittedError = true;\n  self.emit(\"error\", err);\n}\n\nZipFile.prototype.readEntry = function() {\n  if (!this.lazyEntries) throw new Error(\"readEntry() called without lazyEntries:true\");\n  this._readEntry();\n};\nZipFile.prototype._readEntry = function() {\n  var self = this;\n  if (self.entryCount === self.entriesRead) {\n    // done with metadata\n    setImmediate(function() {\n      if (self.autoClose) self.close();\n      if (self.emittedError) return;\n      self.emit(\"end\");\n    });\n    return;\n  }\n  if (self.emittedError) return;\n  var buffer = newBuffer(46);\n  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {\n    if (err) return emitErrorAndAutoClose(self, err);\n    if (self.emittedError) return;\n    var entry = new Entry();\n    // 0 - Central directory file header signature\n    var signature = buffer.readUInt32LE(0);\n    if (signature !== 0x02014b50) return emitErrorAndAutoClose(self, new Error(\"invalid central directory file header signature: 0x\" + signature.toString(16)));\n    // 4 - Version made by\n    entry.versionMadeBy = buffer.readUInt16LE(4);\n    // 6 - Version needed to extract (minimum)\n    entry.versionNeededToExtract = buffer.readUInt16LE(6);\n    // 8 - General purpose bit flag\n    entry.generalPurposeBitFlag = buffer.readUInt16LE(8);\n    // 10 - Compression method\n    entry.compressionMethod = buffer.readUInt16LE(10);\n    // 12 - File last modification time\n    entry.lastModFileTime = buffer.readUInt16LE(12);\n    // 14 - File last modification date\n    entry.lastModFileDate = buffer.readUInt16LE(14);\n    // 16 - CRC-32\n    entry.crc32 = buffer.readUInt32LE(16);\n    // 20 - Compressed size\n    entry.compressedSize = buffer.readUInt32LE(20);\n    // 24 - Uncompressed size\n    entry.uncompressedSize = buffer.readUInt32LE(24);\n    // 28 - File name length (n)\n    entry.fileNameLength = buffer.readUInt16LE(28);\n    // 30 - Extra field length (m)\n    entry.extraFieldLength = buffer.readUInt16LE(30);\n    // 32 - File comment length (k)\n    entry.fileCommentLength = buffer.readUInt16LE(32);\n    // 34 - Disk number where file starts\n    // 36 - Internal file attributes\n    entry.internalFileAttributes = buffer.readUInt16LE(36);\n    // 38 - External file attributes\n    entry.externalFileAttributes = buffer.readUInt32LE(38);\n    // 42 - Relative offset of local file header\n    entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);\n\n    if (entry.generalPurposeBitFlag & 0x40) return emitErrorAndAutoClose(self, new Error(\"strong encryption is not supported\"));\n\n    self.readEntryCursor += 46;\n\n    buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);\n    readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {\n      if (err) return emitErrorAndAutoClose(self, err);\n      if (self.emittedError) return;\n      // 46 - File name\n      var isUtf8 = (entry.generalPurposeBitFlag & 0x800) !== 0;\n      entry.fileName = self.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8)\n                                          : buffer.slice(0, entry.fileNameLength);\n\n      // 46+n - Extra field\n      var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;\n      var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);\n      entry.extraFields = [];\n      var i = 0;\n      while (i < extraFieldBuffer.length - 3) {\n        var headerId = extraFieldBuffer.readUInt16LE(i + 0);\n        var dataSize = extraFieldBuffer.readUInt16LE(i + 2);\n        var dataStart = i + 4;\n        var dataEnd = dataStart + dataSize;\n        if (dataEnd > extraFieldBuffer.length) return emitErrorAndAutoClose(self, new Error(\"extra field length exceeds extra field buffer size\"));\n        var dataBuffer = newBuffer(dataSize);\n        extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);\n        entry.extraFields.push({\n          id: headerId,\n          data: dataBuffer,\n        });\n        i = dataEnd;\n      }\n\n      // 46+n+m - File comment\n      entry.fileComment = self.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8)\n                                             : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);\n      // compatibility hack for https://github.com/thejoshwolfe/yauzl/issues/47\n      entry.comment = entry.fileComment;\n\n      self.readEntryCursor += buffer.length;\n      self.entriesRead += 1;\n\n      if (entry.uncompressedSize            === 0xffffffff ||\n          entry.compressedSize              === 0xffffffff ||\n          entry.relativeOffsetOfLocalHeader === 0xffffffff) {\n        // ZIP64 format\n        // find the Zip64 Extended Information Extra Field\n        var zip64EiefBuffer = null;\n        for (var i = 0; i < entry.extraFields.length; i++) {\n          var extraField = entry.extraFields[i];\n          if (extraField.id === 0x0001) {\n            zip64EiefBuffer = extraField.data;\n            break;\n          }\n        }\n        if (zip64EiefBuffer == null) {\n          return emitErrorAndAutoClose(self, new Error(\"expected zip64 extended information extra field\"));\n        }\n        var index = 0;\n        // 0 - Original Size          8 bytes\n        if (entry.uncompressedSize === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include uncompressed size\"));\n          }\n          entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        }\n        // 8 - Compressed Size        8 bytes\n        if (entry.compressedSize === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include compressed size\"));\n          }\n          entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        }\n        // 16 - Relative Header Offset 8 bytes\n        if (entry.relativeOffsetOfLocalHeader === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include relative header offset\"));\n          }\n          entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        }\n        // 24 - Disk Start Number      4 bytes\n      }\n\n      // check for Info-ZIP Unicode Path Extra Field (0x7075)\n      // see https://github.com/thejoshwolfe/yauzl/issues/33\n      if (self.decodeStrings) {\n        for (var i = 0; i < entry.extraFields.length; i++) {\n          var extraField = entry.extraFields[i];\n          if (extraField.id === 0x7075) {\n            if (extraField.data.length < 6) {\n              // too short to be meaningful\n              continue;\n            }\n            // Version       1 byte      version of this extra field, currently 1\n            if (extraField.data.readUInt8(0) !== 1) {\n              // > Changes may not be backward compatible so this extra\n              // > field should not be used if the version is not recognized.\n              continue;\n            }\n            // NameCRC32     4 bytes     File Name Field CRC32 Checksum\n            var oldNameCrc32 = extraField.data.readUInt32LE(1);\n            if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {\n              // > If the CRC check fails, this UTF-8 Path Extra Field should be\n              // > ignored and the File Name field in the header should be used instead.\n              continue;\n            }\n            // UnicodeName   Variable    UTF-8 version of the entry File Name\n            entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);\n            break;\n          }\n        }\n      }\n\n      // validate file size\n      if (self.validateEntrySizes && entry.compressionMethod === 0) {\n        var expectedCompressedSize = entry.uncompressedSize;\n        if (entry.isEncrypted()) {\n          // traditional encryption prefixes the file data with a header\n          expectedCompressedSize += 12;\n        }\n        if (entry.compressedSize !== expectedCompressedSize) {\n          var msg = \"compressed/uncompressed size mismatch for stored file: \" + entry.compressedSize + \" != \" + entry.uncompressedSize;\n          return emitErrorAndAutoClose(self, new Error(msg));\n        }\n      }\n\n      if (self.decodeStrings) {\n        if (!self.strictFileNames) {\n          // allow backslash\n          entry.fileName = entry.fileName.replace(/\\\\/g, \"/\");\n        }\n        var errorMessage = validateFileName(entry.fileName, self.validateFileNameOptions);\n        if (errorMessage != null) return emitErrorAndAutoClose(self, new Error(errorMessage));\n      }\n      self.emit(\"entry\", entry);\n\n      if (!self.lazyEntries) self._readEntry();\n    });\n  });\n};\n\nZipFile.prototype.openReadStream = function(entry, options, callback) {\n  var self = this;\n  // parameter validation\n  var relativeStart = 0;\n  var relativeEnd = entry.compressedSize;\n  if (callback == null) {\n    callback = options;\n    options = {};\n  } else {\n    // validate options that the caller has no excuse to get wrong\n    if (options.decrypt != null) {\n      if (!entry.isEncrypted()) {\n        throw new Error(\"options.decrypt can only be specified for encrypted entries\");\n      }\n      if (options.decrypt !== false) throw new Error(\"invalid options.decrypt value: \" + options.decrypt);\n      if (entry.isCompressed()) {\n        if (options.decompress !== false) throw new Error(\"entry is encrypted and compressed, and options.decompress !== false\");\n      }\n    }\n    if (options.decompress != null) {\n      if (!entry.isCompressed()) {\n        throw new Error(\"options.decompress can only be specified for compressed entries\");\n      }\n      if (!(options.decompress === false || options.decompress === true)) {\n        throw new Error(\"invalid options.decompress value: \" + options.decompress);\n      }\n    }\n    if (options.start != null || options.end != null) {\n      if (entry.isCompressed() && options.decompress !== false) {\n        throw new Error(\"start/end range not allowed for compressed entry without options.decompress === false\");\n      }\n      if (entry.isEncrypted() && options.decrypt !== false) {\n        throw new Error(\"start/end range not allowed for encrypted entry without options.decrypt === false\");\n      }\n    }\n    if (options.start != null) {\n      relativeStart = options.start;\n      if (relativeStart < 0) throw new Error(\"options.start < 0\");\n      if (relativeStart > entry.compressedSize) throw new Error(\"options.start > entry.compressedSize\");\n    }\n    if (options.end != null) {\n      relativeEnd = options.end;\n      if (relativeEnd < 0) throw new Error(\"options.end < 0\");\n      if (relativeEnd > entry.compressedSize) throw new Error(\"options.end > entry.compressedSize\");\n      if (relativeEnd < relativeStart) throw new Error(\"options.end < options.start\");\n    }\n  }\n  // any further errors can either be caused by the zipfile,\n  // or were introduced in a minor version of yauzl,\n  // so should be passed to the client rather than thrown.\n  if (!self.isOpen) return callback(new Error(\"closed\"));\n  if (entry.isEncrypted()) {\n    if (options.decrypt !== false) return callback(new Error(\"entry is encrypted, and options.decrypt !== false\"));\n  }\n  // make sure we don't lose the fd before we open the actual read stream\n  self.reader.ref();\n  var buffer = newBuffer(30);\n  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {\n    try {\n      if (err) return callback(err);\n      // 0 - Local file header signature = 0x04034b50\n      var signature = buffer.readUInt32LE(0);\n      if (signature !== 0x04034b50) {\n        return callback(new Error(\"invalid local file header signature: 0x\" + signature.toString(16)));\n      }\n      // all this should be redundant\n      // 4 - Version needed to extract (minimum)\n      // 6 - General purpose bit flag\n      // 8 - Compression method\n      // 10 - File last modification time\n      // 12 - File last modification date\n      // 14 - CRC-32\n      // 18 - Compressed size\n      // 22 - Uncompressed size\n      // 26 - File name length (n)\n      var fileNameLength = buffer.readUInt16LE(26);\n      // 28 - Extra field length (m)\n      var extraFieldLength = buffer.readUInt16LE(28);\n      // 30 - File name\n      // 30+n - Extra field\n      var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;\n      var decompress;\n      if (entry.compressionMethod === 0) {\n        // 0 - The file is stored (no compression)\n        decompress = false;\n      } else if (entry.compressionMethod === 8) {\n        // 8 - The file is Deflated\n        decompress = options.decompress != null ? options.decompress : true;\n      } else {\n        return callback(new Error(\"unsupported compression method: \" + entry.compressionMethod));\n      }\n      var fileDataStart = localFileHeaderEnd;\n      var fileDataEnd = fileDataStart + entry.compressedSize;\n      if (entry.compressedSize !== 0) {\n        // bounds check now, because the read streams will probably not complain loud enough.\n        // since we're dealing with an unsigned offset plus an unsigned size,\n        // we only have 1 thing to check for.\n        if (fileDataEnd > self.fileSize) {\n          return callback(new Error(\"file data overflows file bounds: \" +\n              fileDataStart + \" + \" + entry.compressedSize + \" > \" + self.fileSize));\n        }\n      }\n      var readStream = self.reader.createReadStream({\n        start: fileDataStart + relativeStart,\n        end: fileDataStart + relativeEnd,\n      });\n      var endpointStream = readStream;\n      if (decompress) {\n        var destroyed = false;\n        var inflateFilter = zlib.createInflateRaw();\n        readStream.on(\"error\", function(err) {\n          // setImmediate here because errors can be emitted during the first call to pipe()\n          setImmediate(function() {\n            if (!destroyed) inflateFilter.emit(\"error\", err);\n          });\n        });\n        readStream.pipe(inflateFilter);\n\n        if (self.validateEntrySizes) {\n          endpointStream = new AssertByteCountStream(entry.uncompressedSize);\n          inflateFilter.on(\"error\", function(err) {\n            // forward zlib errors to the client-visible stream\n            setImmediate(function() {\n              if (!destroyed) endpointStream.emit(\"error\", err);\n            });\n          });\n          inflateFilter.pipe(endpointStream);\n        } else {\n          // the zlib filter is the client-visible stream\n          endpointStream = inflateFilter;\n        }\n        // this is part of yauzl's API, so implement this function on the client-visible stream\n        endpointStream.destroy = function() {\n          destroyed = true;\n          if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);\n          readStream.unpipe(inflateFilter);\n          // TODO: the inflateFilter may cause a memory leak. see Issue #27.\n          readStream.destroy();\n        };\n      }\n      callback(null, endpointStream);\n    } finally {\n      self.reader.unref();\n    }\n  });\n};\n\nfunction Entry() {\n}\nEntry.prototype.getLastModDate = function() {\n  return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);\n};\nEntry.prototype.isEncrypted = function() {\n  return (this.generalPurposeBitFlag & 0x1) !== 0;\n};\nEntry.prototype.isCompressed = function() {\n  return this.compressionMethod === 8;\n};\n\nfunction dosDateTimeToDate(date, time) {\n  var day = date & 0x1f; // 1-31\n  var month = (date >> 5 & 0xf) - 1; // 1-12, 0-11\n  var year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108\n\n  var millisecond = 0;\n  var second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)\n  var minute = time >> 5 & 0x3f; // 0-59\n  var hour = time >> 11 & 0x1f; // 0-23\n\n  return new Date(year, month, day, hour, minute, second, millisecond);\n}\n\nfunction validateFileName(fileName) {\n  if (fileName.indexOf(\"\\\\\") !== -1) {\n    return \"invalid characters in fileName: \" + fileName;\n  }\n  if (/^[a-zA-Z]:/.test(fileName) || /^\\//.test(fileName)) {\n    return \"absolute path: \" + fileName;\n  }\n  if (fileName.split(\"/\").indexOf(\"..\") !== -1) {\n    return \"invalid relative path: \" + fileName;\n  }\n  // all good\n  return null;\n}\n\nfunction readAndAssertNoEof(reader, buffer, offset, length, position, callback) {\n  if (length === 0) {\n    // fs.read will throw an out-of-bounds error if you try to read 0 bytes from a 0 byte file\n    return setImmediate(function() { callback(null, newBuffer(0)); });\n  }\n  reader.read(buffer, offset, length, position, function(err, bytesRead) {\n    if (err) return callback(err);\n    if (bytesRead < length) {\n      return callback(new Error(\"unexpected EOF\"));\n    }\n    callback();\n  });\n}\n\nutil.inherits(AssertByteCountStream, Transform);\nfunction AssertByteCountStream(byteCount) {\n  Transform.call(this);\n  this.actualByteCount = 0;\n  this.expectedByteCount = byteCount;\n}\nAssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {\n  this.actualByteCount += chunk.length;\n  if (this.actualByteCount > this.expectedByteCount) {\n    var msg = \"too many bytes in the stream. expected \" + this.expectedByteCount + \". got at least \" + this.actualByteCount;\n    return cb(new Error(msg));\n  }\n  cb(null, chunk);\n};\nAssertByteCountStream.prototype._flush = function(cb) {\n  if (this.actualByteCount < this.expectedByteCount) {\n    var msg = \"not enough bytes in the stream. expected \" + this.expectedByteCount + \". got only \" + this.actualByteCount;\n    return cb(new Error(msg));\n  }\n  cb();\n};\n\nutil.inherits(RandomAccessReader, EventEmitter);\nfunction RandomAccessReader() {\n  EventEmitter.call(this);\n  this.refCount = 0;\n}\nRandomAccessReader.prototype.ref = function() {\n  this.refCount += 1;\n};\nRandomAccessReader.prototype.unref = function() {\n  var self = this;\n  self.refCount -= 1;\n\n  if (self.refCount > 0) return;\n  if (self.refCount < 0) throw new Error(\"invalid unref\");\n\n  self.close(onCloseDone);\n\n  function onCloseDone(err) {\n    if (err) return self.emit('error', err);\n    self.emit('close');\n  }\n};\nRandomAccessReader.prototype.createReadStream = function(options) {\n  var start = options.start;\n  var end = options.end;\n  if (start === end) {\n    var emptyStream = new PassThrough();\n    setImmediate(function() {\n      emptyStream.end();\n    });\n    return emptyStream;\n  }\n  var stream = this._readStreamForRange(start, end);\n\n  var destroyed = false;\n  var refUnrefFilter = new RefUnrefFilter(this);\n  stream.on(\"error\", function(err) {\n    setImmediate(function() {\n      if (!destroyed) refUnrefFilter.emit(\"error\", err);\n    });\n  });\n  refUnrefFilter.destroy = function() {\n    stream.unpipe(refUnrefFilter);\n    refUnrefFilter.unref();\n    stream.destroy();\n  };\n\n  var byteCounter = new AssertByteCountStream(end - start);\n  refUnrefFilter.on(\"error\", function(err) {\n    setImmediate(function() {\n      if (!destroyed) byteCounter.emit(\"error\", err);\n    });\n  });\n  byteCounter.destroy = function() {\n    destroyed = true;\n    refUnrefFilter.unpipe(byteCounter);\n    refUnrefFilter.destroy();\n  };\n\n  return stream.pipe(refUnrefFilter).pipe(byteCounter);\n};\nRandomAccessReader.prototype._readStreamForRange = function(start, end) {\n  throw new Error(\"not implemented\");\n};\nRandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {\n  var readStream = this.createReadStream({start: position, end: position + length});\n  var writeStream = new Writable();\n  var written = 0;\n  writeStream._write = function(chunk, encoding, cb) {\n    chunk.copy(buffer, offset + written, 0, chunk.length);\n    written += chunk.length;\n    cb();\n  };\n  writeStream.on(\"finish\", callback);\n  readStream.on(\"error\", function(error) {\n    callback(error);\n  });\n  readStream.pipe(writeStream);\n};\nRandomAccessReader.prototype.close = function(callback) {\n  setImmediate(callback);\n};\n\nutil.inherits(RefUnrefFilter, PassThrough);\nfunction RefUnrefFilter(context) {\n  PassThrough.call(this);\n  this.context = context;\n  this.context.ref();\n  this.unreffedYet = false;\n}\nRefUnrefFilter.prototype._flush = function(cb) {\n  this.unref();\n  cb();\n};\nRefUnrefFilter.prototype.unref = function(cb) {\n  if (this.unreffedYet) return;\n  this.unreffedYet = true;\n  this.context.unref();\n};\n\nvar cp437 = '\\u0000 !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';\nfunction decodeBuffer(buffer, start, end, isUtf8) {\n  if (isUtf8) {\n    return buffer.toString(\"utf8\", start, end);\n  } else {\n    var result = \"\";\n    for (var i = start; i < end; i++) {\n      result += cp437[buffer[i]];\n    }\n    return result;\n  }\n}\n\nfunction readUInt64LE(buffer, offset) {\n  // there is no native function for this, because we can't actually store 64-bit integers precisely.\n  // after 53 bits, JavaScript's Number type (IEEE 754 double) can't store individual integers anymore.\n  // but since 53 bits is a whole lot more than 32 bits, we do our best anyway.\n  var lower32 = buffer.readUInt32LE(offset);\n  var upper32 = buffer.readUInt32LE(offset + 4);\n  // we can't use bitshifting here, because JavaScript bitshifting only works on 32-bit integers.\n  return upper32 * 0x100000000 + lower32;\n  // as long as we're bounds checking the result of this function against the total file size,\n  // we'll catch any overflow errors, because we already made sure the total file size was within reason.\n}\n\n// Node 10 deprecated new Buffer().\nvar newBuffer;\nif (typeof Buffer.allocUnsafe === \"function\") {\n  newBuffer = function(len) {\n    return Buffer.allocUnsafe(len);\n  };\n} else {\n  newBuffer = function(len) {\n    return new Buffer(len);\n  };\n}\n\nfunction defaultCallback(err) {\n  if (err) throw err;\n}\n"],"names":["CRC_TABLE","Int32Array","ensureBuffer","input","hasNewBufferAPI","Error","bufferizeInt","num","tmp","_crc32","buf","previous","crc","n","crc32","arguments","module","debug","createWriteStream","fs","getStream","path","promisify","stream","yauzl","openZip","pipeline","Extractor","zipPath","opts","Promise","resolve","reject","err","entry","destDir","canonicalDestDir","relativeDestDir","dest","mode","IFMT","IFDIR","IFLNK","symlink","isDir","madeBy","procMode","mkdirOptions","readStream","link","entryMode","parseInt","util","Readable","Writable","PassThrough","Pend","EventEmitter","createFromBuffer","createFromFd","BufferSlicer","FdSlicer","fd","options","buffer","offset","length","position","callback","self","cb","bytesRead","written","ReadStream","WriteStream","onCloseDone","context","toRead","Math","Buffer","encoding","bytes","Number","end","delta","setImmediate","entireSlice","nextOffset","bufferSlicer","writeStream","fn","pendGo","pendHold","called","onCb","listeners","cbListener","listener","zlib","fd_slicer","Transform","open","fromFd","fromBuffer","fromRandomAccessReader","dosDateTimeToDate","validateFileName","ZipFile","Entry","RandomAccessReader","defaultCallback","zipfile","stats","reader","totalSize","decodeStrings","eocdrWithoutCommentSize","maxCommentSize","bufferSize","newBuffer","bufferReadStart","readAndAssertNoEof","i","eocdrBuffer","diskNumber","entryCount","centralDirectoryOffset","commentLength","expectedCommentLength","comment","decodeBuffer","zip64EocdlBuffer","zip64EocdlOffset","zip64EocdrOffset","readUInt64LE","zip64EocdrBuffer","fileSize","autoClose","lazyEntries","validateEntrySizes","strictFileNames","emitError","emitErrorAndAutoClose","signature","isUtf8","fileCommentStart","extraFieldBuffer","headerId","dataSize","dataStart","dataEnd","dataBuffer","zip64EiefBuffer","extraField","index","oldNameCrc32","expectedCompressedSize","msg","errorMessage","relativeStart","relativeEnd","fileNameLength","extraFieldLength","localFileHeaderEnd","decompress","fileDataStart","fileDataEnd","endpointStream","destroyed","inflateFilter","AssertByteCountStream","date","time","day","month","year","millisecond","second","minute","hour","Date","fileName","byteCount","chunk","start","emptyStream","refUnrefFilter","RefUnrefFilter","byteCounter","error","cp437","result","lower32","upper32","len"],"mappings":";;;;;;;;;QAAA,IAAI,UAAS;QAEb,IAAIA,YAAY;YACd;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;YAAY;YAAY;YAChD;YAAY;YAAY;Y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"}