/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
import external_fs_default from "fs";
import external_path_default from "path";
import { Client, InMemoryTransport, MCPAgent, Tool } from "@mcp-agent/core";
import { DEFAULT_SYSTEM_PROMPT, generateBrowserRulesPrompt } from "./prompt.mjs";
import { BrowserGUIAgent, BrowserManager, BrowserToolsManager } from "./browser/index.mjs";
import { DEFAULT_PLANNING_PROMPT, PlanManager } from "./planner/plan-manager.mjs";
import { SearchToolProvider } from "./search/index.mjs";
import * as __WEBPACK_EXTERNAL_MODULE__agent_infra_mcp_server_browser_dist_server_cjs_bbf55cff__ from "@agent-infra/mcp-server-browser/dist/server.cjs";
import * as __WEBPACK_EXTERNAL_MODULE__agent_infra_mcp_server_filesystem_c88fdec0__ from "@agent-infra/mcp-server-filesystem";
import * as __WEBPACK_EXTERNAL_MODULE__agent_infra_mcp_server_commands_628a56c5__ from "@agent-infra/mcp-server-commands";
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
class AgentTARS extends MCPAgent {
    async initialize() {
        this.logger.info('Initializing AgentTARS ...');
        try {
            var _this_tarsOptions_browser;
            const control = (null == (_this_tarsOptions_browser = this.tarsOptions.browser) ? void 0 : _this_tarsOptions_browser.control) || 'mixed';
            this.browserToolsManager = new BrowserToolsManager(this.logger, control);
            if ('browser-use-only' !== control) await this.initializeGUIAgent();
            await this.initializeSearchTools();
            if ('in-memory' === this.tarsOptions.mcpImpl) await this.initializeInMemoryMCPForBuiltInMCPServers();
            if (this.planManager) {
                const plannerTools = this.planManager.getTools();
                plannerTools.forEach((tool)=>this.registerTool(tool));
                this.logger.info(`Registered ${plannerTools.length} planner tools`);
            }
            this.logger.info("\u2705 AgentTARS initialization complete");
            this.logRegisteredTools();
        } catch (error) {
            this.logger.error("\u274C Failed to initialize AgentTARS:", error);
            await this.cleanup();
            throw error;
        }
    }
    async initializeSearchTools() {
        try {
            var _this_tarsOptions_search;
            this.logger.info("\uD83D\uDD0D Initializing search tools with direct integration");
            (null == (_this_tarsOptions_search = this.tarsOptions.search) ? void 0 : _this_tarsOptions_search.provider) === 'browser_search' && this.browserManager.getBrowser();
            this.searchToolProvider = new SearchToolProvider(this.logger, {
                provider: this.tarsOptions.search.provider,
                count: this.tarsOptions.search.count,
                browserSearch: this.tarsOptions.search.browserSearch,
                apiKey: this.tarsOptions.search.apiKey,
                baseUrl: this.tarsOptions.search.baseUrl
            });
            const searchTool = this.searchToolProvider.createSearchTool();
            this.registerTool(searchTool);
            this.logger.info("\u2705 Search tools initialized successfully");
        } catch (error) {
            this.logger.error("\u274C Failed to initialize search tools:", error);
            throw error;
        }
    }
    logRegisteredTools() {
        try {
            const tools = this.getTools();
            if (!tools || 0 === tools.length) return void this.logger.info("\uD83E\uDDF0 No tools registered");
            const toolCount = tools.length;
            const header = `\u{1F9F0} ${toolCount} Tools Registered \u{1F9F0}`;
            const separator = "\u2550".repeat(header.length);
            this.logger.info('\n');
            this.logger.info(separator);
            this.logger.info(header);
            this.logger.info(separator);
            const toolsByCategory = {};
            tools.forEach((tool)=>{
                var _tool_description;
                const categoryMatch = null == (_tool_description = tool.description) ? void 0 : _tool_description.match(/^\[(.*?)\]/);
                const category = categoryMatch ? categoryMatch[1] : 'general';
                if (!toolsByCategory[category]) toolsByCategory[category] = [];
                toolsByCategory[category].push(tool.name);
            });
            Object.entries(toolsByCategory).forEach(([category, toolNames])=>{
                this.logger.info(`
\u{1F4E6} ${category} (${toolNames.length}):`);
                toolNames.sort().forEach((name)=>{
                    this.logger.info(`  \u{2022} ${name}`);
                });
            });
            this.logger.info('\n' + separator);
            this.logger.info(`\u{2728} Total: ${toolCount} tools ready to use`);
            this.logger.info(separator + '\n');
        } catch (error) {
            this.logger.error("\u274C Failed to log registered tools:", error);
        }
    }
    async initializeGUIAgent() {
        try {
            var _this_tarsOptions_browser;
            this.logger.info("\uD83D\uDDA5\uFE0F Initializing GUI Agent for visual browser control");
            this.browserGUIAgent = new BrowserGUIAgent({
                logger: this.logger,
                headless: null == (_this_tarsOptions_browser = this.tarsOptions.browser) ? void 0 : _this_tarsOptions_browser.headless,
                browser: this.browserManager.getBrowser(),
                eventStream: this.eventStream
            });
            if (this.browserToolsManager) this.browserToolsManager.setBrowserGUIAgent(this.browserGUIAgent);
            this.logger.info("\u2705 GUI Agent initialized successfully");
        } catch (error) {
            this.logger.error(`\u{274C} Failed to initialize GUI Agent: ${error}`);
            throw error;
        }
    }
    async initializeInMemoryMCPForBuiltInMCPServers() {
        try {
            var _this_tarsOptions_browser;
            const sharedBrowser = this.browserManager.getBrowser();
            this.logger.info('Using shared browser instance for MCP servers');
            const mcpModules = {
                browser: __WEBPACK_EXTERNAL_MODULE__agent_infra_mcp_server_browser_dist_server_cjs_bbf55cff__,
                filesystem: __WEBPACK_EXTERNAL_MODULE__agent_infra_mcp_server_filesystem_c88fdec0__,
                commands: __WEBPACK_EXTERNAL_MODULE__agent_infra_mcp_server_commands_628a56c5__
            };
            this.mcpServers = {
                browser: mcpModules.browser.createServer({
                    externalBrowser: sharedBrowser,
                    enableAdBlocker: false,
                    launchOptions: {
                        headless: null == (_this_tarsOptions_browser = this.tarsOptions.browser) ? void 0 : _this_tarsOptions_browser.headless
                    }
                }),
                filesystem: mcpModules.filesystem.createServer({
                    allowedDirectories: [
                        this.workingDirectory
                    ]
                }),
                commands: mcpModules.commands.createServer()
            };
            await Promise.all(Object.entries(this.mcpServers).filter(([_, server])=>null !== server).map(async ([name, server])=>{
                const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();
                const client = new Client({
                    name: `${name}-client`,
                    version: '1.0'
                }, {
                    capabilities: {
                        roots: {
                            listChanged: true
                        }
                    }
                });
                await Promise.all([
                    client.connect(clientTransport),
                    server.connect(serverTransport)
                ]);
                this.inMemoryMCPClients[name] = client;
                this.logger.info(`\u{2705} Connected to ${name} MCP server`);
            }));
            if (this.browserToolsManager && this.inMemoryMCPClients.browser) this.browserToolsManager.setBrowserClient(this.inMemoryMCPClients.browser);
            if (this.browserToolsManager) {
                var _this_tarsOptions_browser1;
                const registeredTools = await this.browserToolsManager.registerTools((tool)=>this.registerTool(tool));
                this.logger.info(`\u{2705} Registered ${registeredTools.length} browser tools using '${(null == (_this_tarsOptions_browser1 = this.tarsOptions.browser) ? void 0 : _this_tarsOptions_browser1.control) || 'default'}' strategy`);
            }
            await Promise.all(Object.entries(this.inMemoryMCPClients).map(async ([name, client])=>{
                if ('browser' !== name || !this.browserToolsManager) await this.registerToolsFromClient(name, client);
            }));
            this.logger.info("\u2705 In-memory MCP initialization complete");
        } catch (error) {
            this.logger.error("\u274C Failed to initialize in-memory MCP:", error);
            throw new Error(`Failed to initialize in-memory MCP: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async registerToolsFromClient(moduleName, client) {
        try {
            const tools = await client.listTools();
            if (!tools || !Array.isArray(tools.tools)) return void this.logger.warn(`\u{26A0}\u{FE0F} No tools returned from '${moduleName}' module`);
            for (const tool of tools.tools){
                const toolDefinition = new Tool({
                    id: tool.name,
                    description: `[${moduleName}] ${tool.description}`,
                    parameters: tool.inputSchema || {
                        type: 'object',
                        properties: {}
                    },
                    function: async (args)=>{
                        try {
                            const result = await client.callTool({
                                name: tool.name,
                                arguments: args
                            });
                            return result.content;
                        } catch (error) {
                            this.logger.error(`\u{274C} Error executing tool '${tool.name}':`, error);
                            throw error;
                        }
                    }
                });
                this.registerTool(toolDefinition);
                this.logger.info(`Registered tool: ${toolDefinition.name}`);
            }
            this.logger.info(`Registered ${tools.tools.length} MCP tools from '${moduleName}'`);
        } catch (error) {
            this.logger.error(`\u{274C} Failed to register tools from '${moduleName}' module:`, error);
            throw error;
        }
    }
    async onBeforeToolCall(id, toolCall, args) {
        if (toolCall.name.startsWith('browser') && !this.browserManager.isLaunchingComplete() || !await this.browserManager.isBrowserAlive()) if (this.isReplaySnapshot) ;
        else {
            var _this_tarsOptions_browser;
            await this.browserManager.launchBrowser({
                headless: null == (_this_tarsOptions_browser = this.tarsOptions.browser) ? void 0 : _this_tarsOptions_browser.headless
            });
        }
        return args;
    }
    async onEachAgentLoopStart(sessionId) {
        var _this_tarsOptions_browser;
        this.currentIteration++;
        if ((null == (_this_tarsOptions_browser = this.tarsOptions.browser) ? void 0 : _this_tarsOptions_browser.control) !== 'browser-use-only' && this.browserGUIAgent && this.browserManager.isLaunchingComplete()) {
            var _this_browserGUIAgent;
            if (this.browserGUIAgent.setEventStream) this.browserGUIAgent.setEventStream(this.eventStream);
            await (null == (_this_browserGUIAgent = this.browserGUIAgent) ? void 0 : _this_browserGUIAgent.onEachAgentLoopStart(this.eventStream, this.isReplaySnapshot));
        }
        if (this.planManager && !this.isReplaySnapshot) {
            const llmClient = this.getLLMClient();
            const resolvedModel = this.getCurrentResolvedModel();
            if (llmClient && resolvedModel) {
                const messages = this.getMessagesForPlanning();
                if (1 === this.currentIteration) await this.planManager.generateInitialPlan(llmClient, resolvedModel, messages, sessionId);
                else await this.planManager.updatePlan(llmClient, resolvedModel, messages, sessionId);
            }
        }
        await super.onEachAgentLoopStart(sessionId);
    }
    async onBeforeLoopTermination(id, finalEvent) {
        return {
            finished: true
        };
    }
    async onAgentLoopEnd(id) {
        if (this.planManager) {
            this.planManager.resetFinalAnswerStatus();
            this.currentIteration = 0;
        }
        await super.onAgentLoopEnd(id);
    }
    getMessagesForPlanning() {
        const events = this.eventStream.getEventsByType([
            'user_message',
            'assistant_message'
        ]);
        return events.map((event)=>{
            if ('assistant_message' === event.type) return {
                role: 'assistant',
                content: event.content
            };
            return {
                role: 'user',
                content: 'string' == typeof (null == event ? void 0 : event.content) ? event.content : JSON.stringify(event.content)
            };
        });
    }
    getBrowserControlInfo() {
        var _this_tarsOptions_browser;
        if (this.browserToolsManager) return {
            mode: this.browserToolsManager.getMode(),
            tools: this.browserToolsManager.getRegisteredTools()
        };
        return {
            mode: (null == (_this_tarsOptions_browser = this.tarsOptions.browser) ? void 0 : _this_tarsOptions_browser.control) || 'default',
            tools: []
        };
    }
    async cleanup() {
        this.logger.info('Cleaning up resources...');
        const cleanupPromises = [];
        for (const [name, client] of Object.entries(this.inMemoryMCPClients))cleanupPromises.push(client.close().catch((error)=>{
            this.logger.warn(`\u{26A0}\u{FE0F} Error while closing ${name} client: ${error}`);
        }));
        for (const [name, server] of Object.entries(this.mcpServers))if (null == server ? void 0 : server.close) cleanupPromises.push(server.close().catch((error)=>{
            this.logger.warn(`\u{26A0}\u{FE0F} Error while closing ${name} server: ${error}`);
        }));
        cleanupPromises.push(this.browserManager.closeBrowser().catch((error)=>{
            this.logger.warn(`\u{26A0}\u{FE0F} Error while closing shared browser: ${error}`);
        }));
        await Promise.allSettled(cleanupPromises);
        this.inMemoryMCPClients = {};
        this.mcpServers = {};
        this.browserGUIAgent = void 0;
        this.logger.info("\u2705 Cleanup complete");
    }
    getWorkingDirectory() {
        return this.workingDirectory;
    }
    getLogger() {
        return this.logger;
    }
    onLLMRequest(id, payload) {
        var _this_tarsOptions_experimental;
        if (null == (_this_tarsOptions_experimental = this.tarsOptions.experimental) ? void 0 : _this_tarsOptions_experimental.dumpMessageHistory) {
            this.traces.push({
                type: 'request',
                timestamp: Date.now(),
                id,
                data: JSON.parse(JSON.stringify(payload))
            });
            this.dumpMessageHistory(id);
        }
    }
    onLLMResponse(id, payload) {
        var _this_tarsOptions_experimental;
        if (null == (_this_tarsOptions_experimental = this.tarsOptions.experimental) ? void 0 : _this_tarsOptions_experimental.dumpMessageHistory) {
            this.traces.push({
                type: 'response',
                timestamp: Date.now(),
                id,
                data: JSON.parse(JSON.stringify(payload))
            });
            this.dumpMessageHistory(id);
        }
    }
    getAbortSignal() {
        return this.executionController.getAbortSignal();
    }
    getBrowserManager() {
        return this.browserManager;
    }
    dumpMessageHistory(sessionId) {
        try {
            var _this_tarsOptions_experimental;
            if (!(null == (_this_tarsOptions_experimental = this.tarsOptions.experimental) ? void 0 : _this_tarsOptions_experimental.dumpMessageHistory)) return;
            const filename = `session_${sessionId}.json`;
            const filePath = external_path_default.join(this.workingDirectory, filename);
            const output = {
                agent: {
                    id: this.id,
                    name: this.name
                },
                sessionId,
                timestamp: Date.now(),
                history: this.traces
            };
            external_fs_default.writeFileSync(filePath, JSON.stringify(output, null, 2), 'utf8');
            this.logger.debug(`\u{1F4DD} Message history updated in: ${filePath}`);
        } catch (error) {
            this.logger.error('Failed to dump message history:', error);
        }
    }
    constructor(options){
        var _options_search, _tarsOptions_browser, _options_experimental;
        const tarsOptions = {
            search: {
                provider: 'browser_search',
                count: 10,
                browserSearch: {
                    engine: 'google',
                    needVisitedUrls: false,
                    ...(null == (_options_search = options.search) ? void 0 : _options_search.browserSearch) || {}
                },
                ...options.search ?? {}
            },
            browser: {
                type: 'local',
                headless: false,
                control: 'mixed',
                ...options.browser ?? {}
            },
            mcpImpl: 'in-memory',
            toolCallEngine: 'structured_outputs',
            mcpServers: {},
            maxIterations: 100,
            maxTokens: 10000,
            ...options
        };
        const { workingDirectory = process.cwd() } = tarsOptions.workspace;
        const mcpServers = {
            ...'stdio' === options.mcpImpl ? {
                browser: {
                    command: 'npx',
                    args: [
                        '-y',
                        '@agent-infra/mcp-server-browser'
                    ]
                },
                filesystem: {
                    command: 'npx',
                    args: [
                        '-y',
                        '@agent-infra/mcp-server-filesystem',
                        workingDirectory
                    ]
                },
                commands: {
                    command: 'npx',
                    args: [
                        '-y',
                        '@agent-infra/mcp-server-commands'
                    ]
                }
            } : {},
            ...options.mcpServers || {}
        };
        const plannerOptions = 'boolean' == typeof tarsOptions.planner ? tarsOptions.planner ? {
            enabled: true
        } : void 0 : tarsOptions.planner;
        let plannerPrompt = '';
        if (null == plannerOptions ? void 0 : plannerOptions.enabled) plannerPrompt = `${DEFAULT_PLANNING_PROMPT} \n\n ${plannerOptions.planningPrompt ?? ''}`;
        const browserRules = generateBrowserRulesPrompt(null == (_tarsOptions_browser = tarsOptions.browser) ? void 0 : _tarsOptions_browser.control);
        const systemPrompt = `${DEFAULT_SYSTEM_PROMPT}
${plannerPrompt ? `\n${plannerPrompt}` : ''}
${browserRules}

<envirnoment>
Current Working Directory: ${workingDirectory}
</envirnoment>

    `;
        const instructions = options.instructions ? `${systemPrompt}\n\n${options.instructions}` : systemPrompt;
        super({
            ...tarsOptions,
            name: options.name ?? 'AgentTARS',
            instructions,
            mcpServers,
            maxTokens: tarsOptions.maxTokens
        }), _define_property(this, "workingDirectory", void 0), _define_property(this, "tarsOptions", void 0), _define_property(this, "mcpServers", {}), _define_property(this, "inMemoryMCPClients", {}), _define_property(this, "browserGUIAgent", void 0), _define_property(this, "browserManager", void 0), _define_property(this, "planManager", void 0), _define_property(this, "currentIteration", 0), _define_property(this, "browserToolsManager", void 0), _define_property(this, "searchToolProvider", void 0), _define_property(this, "traces", []);
        this.logger = this.logger.spawn('AgentTARS');
        this.tarsOptions = tarsOptions;
        this.workingDirectory = workingDirectory;
        this.logger.info(`\u{1F916} AgentTARS initialized | Working directory: ${workingDirectory}`);
        this.browserManager = BrowserManager.getInstance(this.logger);
        if (null == plannerOptions ? void 0 : plannerOptions.enabled) this.planManager = new PlanManager(this.logger, this.eventStream, this, plannerOptions);
        if (null == (_options_experimental = options.experimental) ? void 0 : _options_experimental.dumpMessageHistory) this.logger.info("\uD83D\uDCDD Message history dump enabled");
    }
}
export { AgentTARS };

//# sourceMappingURL=agent-tars.mjs.map