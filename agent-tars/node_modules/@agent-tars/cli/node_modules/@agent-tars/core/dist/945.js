/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
exports.ids = [
    "945"
];
exports.modules = {
    "../node_modules/.pnpm/buffer-crc32@0.2.13/node_modules/buffer-crc32/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        var Buffer1 = __webpack_require__("buffer").Buffer;
        var CRC_TABLE = [
            0x00000000,
            0x77073096,
            0xee0e612c,
            0x990951ba,
            0x076dc419,
            0x706af48f,
            0xe963a535,
            0x9e6495a3,
            0x0edb8832,
            0x79dcb8a4,
            0xe0d5e91e,
            0x97d2d988,
            0x09b64c2b,
            0x7eb17cbd,
            0xe7b82d07,
            0x90bf1d91,
            0x1db71064,
            0x6ab020f2,
            0xf3b97148,
            0x84be41de,
            0x1adad47d,
            0x6ddde4eb,
            0xf4d4b551,
            0x83d385c7,
            0x136c9856,
            0x646ba8c0,
            0xfd62f97a,
            0x8a65c9ec,
            0x14015c4f,
            0x63066cd9,
            0xfa0f3d63,
            0x8d080df5,
            0x3b6e20c8,
            0x4c69105e,
            0xd56041e4,
            0xa2677172,
            0x3c03e4d1,
            0x4b04d447,
            0xd20d85fd,
            0xa50ab56b,
            0x35b5a8fa,
            0x42b2986c,
            0xdbbbc9d6,
            0xacbcf940,
            0x32d86ce3,
            0x45df5c75,
            0xdcd60dcf,
            0xabd13d59,
            0x26d930ac,
            0x51de003a,
            0xc8d75180,
            0xbfd06116,
            0x21b4f4b5,
            0x56b3c423,
            0xcfba9599,
            0xb8bda50f,
            0x2802b89e,
            0x5f058808,
            0xc60cd9b2,
            0xb10be924,
            0x2f6f7c87,
            0x58684c11,
            0xc1611dab,
            0xb6662d3d,
            0x76dc4190,
            0x01db7106,
            0x98d220bc,
            0xefd5102a,
            0x71b18589,
            0x06b6b51f,
            0x9fbfe4a5,
            0xe8b8d433,
            0x7807c9a2,
            0x0f00f934,
            0x9609a88e,
            0xe10e9818,
            0x7f6a0dbb,
            0x086d3d2d,
            0x91646c97,
            0xe6635c01,
            0x6b6b51f4,
            0x1c6c6162,
            0x856530d8,
            0xf262004e,
            0x6c0695ed,
            0x1b01a57b,
            0x8208f4c1,
            0xf50fc457,
            0x65b0d9c6,
            0x12b7e950,
            0x8bbeb8ea,
            0xfcb9887c,
            0x62dd1ddf,
            0x15da2d49,
            0x8cd37cf3,
            0xfbd44c65,
            0x4db26158,
            0x3ab551ce,
            0xa3bc0074,
            0xd4bb30e2,
            0x4adfa541,
            0x3dd895d7,
            0xa4d1c46d,
            0xd3d6f4fb,
            0x4369e96a,
            0x346ed9fc,
            0xad678846,
            0xda60b8d0,
            0x44042d73,
            0x33031de5,
            0xaa0a4c5f,
            0xdd0d7cc9,
            0x5005713c,
            0x270241aa,
            0xbe0b1010,
            0xc90c2086,
            0x5768b525,
            0x206f85b3,
            0xb966d409,
            0xce61e49f,
            0x5edef90e,
            0x29d9c998,
            0xb0d09822,
            0xc7d7a8b4,
            0x59b33d17,
            0x2eb40d81,
            0xb7bd5c3b,
            0xc0ba6cad,
            0xedb88320,
            0x9abfb3b6,
            0x03b6e20c,
            0x74b1d29a,
            0xead54739,
            0x9dd277af,
            0x04db2615,
            0x73dc1683,
            0xe3630b12,
            0x94643b84,
            0x0d6d6a3e,
            0x7a6a5aa8,
            0xe40ecf0b,
            0x9309ff9d,
            0x0a00ae27,
            0x7d079eb1,
            0xf00f9344,
            0x8708a3d2,
            0x1e01f268,
            0x6906c2fe,
            0xf762575d,
            0x806567cb,
            0x196c3671,
            0x6e6b06e7,
            0xfed41b76,
            0x89d32be0,
            0x10da7a5a,
            0x67dd4acc,
            0xf9b9df6f,
            0x8ebeeff9,
            0x17b7be43,
            0x60b08ed5,
            0xd6d6a3e8,
            0xa1d1937e,
            0x38d8c2c4,
            0x4fdff252,
            0xd1bb67f1,
            0xa6bc5767,
            0x3fb506dd,
            0x48b2364b,
            0xd80d2bda,
            0xaf0a1b4c,
            0x36034af6,
            0x41047a60,
            0xdf60efc3,
            0xa867df55,
            0x316e8eef,
            0x4669be79,
            0xcb61b38c,
            0xbc66831a,
            0x256fd2a0,
            0x5268e236,
            0xcc0c7795,
            0xbb0b4703,
            0x220216b9,
            0x5505262f,
            0xc5ba3bbe,
            0xb2bd0b28,
            0x2bb45a92,
            0x5cb36a04,
            0xc2d7ffa7,
            0xb5d0cf31,
            0x2cd99e8b,
            0x5bdeae1d,
            0x9b64c2b0,
            0xec63f226,
            0x756aa39c,
            0x026d930a,
            0x9c0906a9,
            0xeb0e363f,
            0x72076785,
            0x05005713,
            0x95bf4a82,
            0xe2b87a14,
            0x7bb12bae,
            0x0cb61b38,
            0x92d28e9b,
            0xe5d5be0d,
            0x7cdcefb7,
            0x0bdbdf21,
            0x86d3d2d4,
            0xf1d4e242,
            0x68ddb3f8,
            0x1fda836e,
            0x81be16cd,
            0xf6b9265b,
            0x6fb077e1,
            0x18b74777,
            0x88085ae6,
            0xff0f6a70,
            0x66063bca,
            0x11010b5c,
            0x8f659eff,
            0xf862ae69,
            0x616bffd3,
            0x166ccf45,
            0xa00ae278,
            0xd70dd2ee,
            0x4e048354,
            0x3903b3c2,
            0xa7672661,
            0xd06016f7,
            0x4969474d,
            0x3e6e77db,
            0xaed16a4a,
            0xd9d65adc,
            0x40df0b66,
            0x37d83bf0,
            0xa9bcae53,
            0xdebb9ec5,
            0x47b2cf7f,
            0x30b5ffe9,
            0xbdbdf21c,
            0xcabac28a,
            0x53b39330,
            0x24b4a3a6,
            0xbad03605,
            0xcdd70693,
            0x54de5729,
            0x23d967bf,
            0xb3667a2e,
            0xc4614ab8,
            0x5d681b02,
            0x2a6f2b94,
            0xb40bbe37,
            0xc30c8ea1,
            0x5a05df1b,
            0x2d02ef8d
        ];
        if ('undefined' != typeof Int32Array) CRC_TABLE = new Int32Array(CRC_TABLE);
        function ensureBuffer(input) {
            if (Buffer1.isBuffer(input)) return input;
            var hasNewBufferAPI = "function" == typeof Buffer1.alloc && "function" == typeof Buffer1.from;
            if ("number" == typeof input) return hasNewBufferAPI ? Buffer1.alloc(input) : new Buffer1(input);
            if ("string" == typeof input) return hasNewBufferAPI ? Buffer1.from(input) : new Buffer1(input);
            throw new Error("input must be buffer, number, or string, received " + typeof input);
        }
        function bufferizeInt(num) {
            var tmp = ensureBuffer(4);
            tmp.writeInt32BE(num, 0);
            return tmp;
        }
        function _crc32(buf, previous) {
            buf = ensureBuffer(buf);
            if (Buffer1.isBuffer(previous)) previous = previous.readUInt32BE(0);
            var crc = -1 ^ ~~previous;
            for(var n = 0; n < buf.length; n++)crc = CRC_TABLE[(crc ^ buf[n]) & 0xff] ^ crc >>> 8;
            return -1 ^ crc;
        }
        function crc32() {
            return bufferizeInt(_crc32.apply(null, arguments));
        }
        crc32.signed = function() {
            return _crc32.apply(null, arguments);
        };
        crc32.unsigned = function() {
            return _crc32.apply(null, arguments) >>> 0;
        };
        module.exports = crc32;
    },
    "../node_modules/.pnpm/extract-zip@2.0.1/node_modules/extract-zip/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const debug = __webpack_require__("../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/index.js")('extract-zip');
        const { createWriteStream, promises: fs } = __webpack_require__("fs?fa32");
        const getStream = __webpack_require__("../node_modules/.pnpm/get-stream@5.2.0/node_modules/get-stream/index.js");
        const path = __webpack_require__("path");
        const { promisify } = __webpack_require__("util");
        const stream = __webpack_require__("stream");
        const yauzl = __webpack_require__("../node_modules/.pnpm/yauzl@2.10.0/node_modules/yauzl/index.js");
        const openZip = promisify(yauzl.open);
        const pipeline = promisify(stream.pipeline);
        class Extractor {
            constructor(zipPath, opts){
                this.zipPath = zipPath;
                this.opts = opts;
            }
            async extract() {
                debug('opening', this.zipPath, 'with opts', this.opts);
                this.zipfile = await openZip(this.zipPath, {
                    lazyEntries: true
                });
                this.canceled = false;
                return new Promise((resolve, reject)=>{
                    this.zipfile.on('error', (err)=>{
                        this.canceled = true;
                        reject(err);
                    });
                    this.zipfile.readEntry();
                    this.zipfile.on('close', ()=>{
                        if (!this.canceled) {
                            debug('zip extraction complete');
                            resolve();
                        }
                    });
                    this.zipfile.on('entry', async (entry)=>{
                        if (this.canceled) return void debug('skipping entry', entry.fileName, {
                            cancelled: this.canceled
                        });
                        debug('zipfile entry', entry.fileName);
                        if (entry.fileName.startsWith('__MACOSX/')) return void this.zipfile.readEntry();
                        const destDir = path.dirname(path.join(this.opts.dir, entry.fileName));
                        try {
                            await fs.mkdir(destDir, {
                                recursive: true
                            });
                            const canonicalDestDir = await fs.realpath(destDir);
                            const relativeDestDir = path.relative(this.opts.dir, canonicalDestDir);
                            if (relativeDestDir.split(path.sep).includes('..')) throw new Error(`Out of bound path "${canonicalDestDir}" found while processing file ${entry.fileName}`);
                            await this.extractEntry(entry);
                            debug('finished processing', entry.fileName);
                            this.zipfile.readEntry();
                        } catch (err) {
                            this.canceled = true;
                            this.zipfile.close();
                            reject(err);
                        }
                    });
                });
            }
            async extractEntry(entry) {
                if (this.canceled) return void debug('skipping entry extraction', entry.fileName, {
                    cancelled: this.canceled
                });
                if (this.opts.onEntry) this.opts.onEntry(entry, this.zipfile);
                const dest = path.join(this.opts.dir, entry.fileName);
                const mode = entry.externalFileAttributes >> 16 & 0xFFFF;
                const IFMT = 61440;
                const IFDIR = 16384;
                const IFLNK = 40960;
                const symlink = (mode & IFMT) === IFLNK;
                let isDir = (mode & IFMT) === IFDIR;
                if (!isDir && entry.fileName.endsWith('/')) isDir = true;
                const madeBy = entry.versionMadeBy >> 8;
                if (!isDir) isDir = 0 === madeBy && 16 === entry.externalFileAttributes;
                debug('extracting entry', {
                    filename: entry.fileName,
                    isDir: isDir,
                    isSymlink: symlink
                });
                const procMode = 511 & this.getExtractedMode(mode, isDir);
                const destDir = isDir ? dest : path.dirname(dest);
                const mkdirOptions = {
                    recursive: true
                };
                if (isDir) mkdirOptions.mode = procMode;
                debug('mkdir', {
                    dir: destDir,
                    ...mkdirOptions
                });
                await fs.mkdir(destDir, mkdirOptions);
                if (isDir) return;
                debug('opening read stream', dest);
                const readStream = await promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry);
                if (symlink) {
                    const link = await getStream(readStream);
                    debug('creating symlink', link, dest);
                    await fs.symlink(link, dest);
                } else await pipeline(readStream, createWriteStream(dest, {
                    mode: procMode
                }));
            }
            getExtractedMode(entryMode, isDir) {
                let mode = entryMode;
                if (0 === mode) if (isDir) {
                    if (this.opts.defaultDirMode) mode = parseInt(this.opts.defaultDirMode, 10);
                    if (!mode) mode = 493;
                } else {
                    if (this.opts.defaultFileMode) mode = parseInt(this.opts.defaultFileMode, 10);
                    if (!mode) mode = 420;
                }
                return mode;
            }
        }
        module.exports = async function(zipPath, opts) {
            debug('creating target directory', opts.dir);
            if (!path.isAbsolute(opts.dir)) throw new Error('Target directory is expected to be absolute');
            await fs.mkdir(opts.dir, {
                recursive: true
            });
            opts.dir = await fs.realpath(opts.dir);
            return new Extractor(zipPath, opts).extract();
        };
    },
    "../node_modules/.pnpm/fd-slicer@1.1.0/node_modules/fd-slicer/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        var fs = __webpack_require__("fs?fa32");
        var util = __webpack_require__("util");
        var stream = __webpack_require__("stream");
        var Readable = stream.Readable;
        var Writable = stream.Writable;
        var PassThrough = stream.PassThrough;
        var Pend = __webpack_require__("../node_modules/.pnpm/pend@1.2.0/node_modules/pend/index.js");
        var EventEmitter = __webpack_require__("events").EventEmitter;
        exports1.createFromBuffer = createFromBuffer;
        exports1.createFromFd = createFromFd;
        exports1.BufferSlicer = BufferSlicer;
        exports1.FdSlicer = FdSlicer;
        util.inherits(FdSlicer, EventEmitter);
        function FdSlicer(fd, options) {
            options = options || {};
            EventEmitter.call(this);
            this.fd = fd;
            this.pend = new Pend();
            this.pend.max = 1;
            this.refCount = 0;
            this.autoClose = !!options.autoClose;
        }
        FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
            var self = this;
            self.pend.go(function(cb) {
                fs.read(self.fd, buffer, offset, length, position, function(err, bytesRead, buffer) {
                    cb();
                    callback(err, bytesRead, buffer);
                });
            });
        };
        FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
            var self = this;
            self.pend.go(function(cb) {
                fs.write(self.fd, buffer, offset, length, position, function(err, written, buffer) {
                    cb();
                    callback(err, written, buffer);
                });
            });
        };
        FdSlicer.prototype.createReadStream = function(options) {
            return new ReadStream(this, options);
        };
        FdSlicer.prototype.createWriteStream = function(options) {
            return new WriteStream(this, options);
        };
        FdSlicer.prototype.ref = function() {
            this.refCount += 1;
        };
        FdSlicer.prototype.unref = function() {
            var self = this;
            self.refCount -= 1;
            if (self.refCount > 0) return;
            if (self.refCount < 0) throw new Error("invalid unref");
            if (self.autoClose) fs.close(self.fd, onCloseDone);
            function onCloseDone(err) {
                if (err) self.emit('error', err);
                else self.emit('close');
            }
        };
        util.inherits(ReadStream, Readable);
        function ReadStream(context, options) {
            options = options || {};
            Readable.call(this, options);
            this.context = context;
            this.context.ref();
            this.start = options.start || 0;
            this.endOffset = options.end;
            this.pos = this.start;
            this.destroyed = false;
        }
        ReadStream.prototype._read = function(n) {
            var self = this;
            if (self.destroyed) return;
            var toRead = Math.min(self._readableState.highWaterMark, n);
            if (null != self.endOffset) toRead = Math.min(toRead, self.endOffset - self.pos);
            if (toRead <= 0) {
                self.destroyed = true;
                self.push(null);
                self.context.unref();
                return;
            }
            self.context.pend.go(function(cb) {
                if (self.destroyed) return cb();
                var buffer = new Buffer(toRead);
                fs.read(self.context.fd, buffer, 0, toRead, self.pos, function(err, bytesRead) {
                    if (err) self.destroy(err);
                    else if (0 === bytesRead) {
                        self.destroyed = true;
                        self.push(null);
                        self.context.unref();
                    } else {
                        self.pos += bytesRead;
                        self.push(buffer.slice(0, bytesRead));
                    }
                    cb();
                });
            });
        };
        ReadStream.prototype.destroy = function(err) {
            if (this.destroyed) return;
            err = err || new Error("stream destroyed");
            this.destroyed = true;
            this.emit('error', err);
            this.context.unref();
        };
        util.inherits(WriteStream, Writable);
        function WriteStream(context, options) {
            options = options || {};
            Writable.call(this, options);
            this.context = context;
            this.context.ref();
            this.start = options.start || 0;
            this.endOffset = null == options.end ? 1 / 0 : +options.end;
            this.bytesWritten = 0;
            this.pos = this.start;
            this.destroyed = false;
            this.on('finish', this.destroy.bind(this));
        }
        WriteStream.prototype._write = function(buffer, encoding, callback) {
            var self = this;
            if (self.destroyed) return;
            if (self.pos + buffer.length > self.endOffset) {
                var err = new Error("maximum file length exceeded");
                err.code = 'ETOOBIG';
                self.destroy();
                callback(err);
                return;
            }
            self.context.pend.go(function(cb) {
                if (self.destroyed) return cb();
                fs.write(self.context.fd, buffer, 0, buffer.length, self.pos, function(err, bytes) {
                    if (err) {
                        self.destroy();
                        cb();
                        callback(err);
                    } else {
                        self.bytesWritten += bytes;
                        self.pos += bytes;
                        self.emit('progress');
                        cb();
                        callback();
                    }
                });
            });
        };
        WriteStream.prototype.destroy = function() {
            if (this.destroyed) return;
            this.destroyed = true;
            this.context.unref();
        };
        util.inherits(BufferSlicer, EventEmitter);
        function BufferSlicer(buffer, options) {
            EventEmitter.call(this);
            options = options || {};
            this.refCount = 0;
            this.buffer = buffer;
            this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
        }
        BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
            var end = position + length;
            var delta = end - this.buffer.length;
            var written = delta > 0 ? delta : length;
            this.buffer.copy(buffer, offset, position, end);
            setImmediate(function() {
                callback(null, written);
            });
        };
        BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
            buffer.copy(this.buffer, position, offset, offset + length);
            setImmediate(function() {
                callback(null, length, buffer);
            });
        };
        BufferSlicer.prototype.createReadStream = function(options) {
            options = options || {};
            var readStream = new PassThrough(options);
            readStream.destroyed = false;
            readStream.start = options.start || 0;
            readStream.endOffset = options.end;
            readStream.pos = readStream.endOffset || this.buffer.length;
            var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
            var offset = 0;
            while(true){
                var nextOffset = offset + this.maxChunkSize;
                if (nextOffset >= entireSlice.length) {
                    if (offset < entireSlice.length) readStream.write(entireSlice.slice(offset, entireSlice.length));
                    break;
                }
                readStream.write(entireSlice.slice(offset, nextOffset));
                offset = nextOffset;
            }
            readStream.end();
            readStream.destroy = function() {
                readStream.destroyed = true;
            };
            return readStream;
        };
        BufferSlicer.prototype.createWriteStream = function(options) {
            var bufferSlicer = this;
            options = options || {};
            var writeStream = new Writable(options);
            writeStream.start = options.start || 0;
            writeStream.endOffset = null == options.end ? this.buffer.length : +options.end;
            writeStream.bytesWritten = 0;
            writeStream.pos = writeStream.start;
            writeStream.destroyed = false;
            writeStream._write = function(buffer, encoding, callback) {
                if (writeStream.destroyed) return;
                var end = writeStream.pos + buffer.length;
                if (end > writeStream.endOffset) {
                    var err = new Error("maximum file length exceeded");
                    err.code = 'ETOOBIG';
                    writeStream.destroyed = true;
                    callback(err);
                    return;
                }
                buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
                writeStream.bytesWritten += buffer.length;
                writeStream.pos = end;
                writeStream.emit('progress');
                callback();
            };
            writeStream.destroy = function() {
                writeStream.destroyed = true;
            };
            return writeStream;
        };
        BufferSlicer.prototype.ref = function() {
            this.refCount += 1;
        };
        BufferSlicer.prototype.unref = function() {
            this.refCount -= 1;
            if (this.refCount < 0) throw new Error("invalid unref");
        };
        function createFromBuffer(buffer, options) {
            return new BufferSlicer(buffer, options);
        }
        function createFromFd(fd, options) {
            return new FdSlicer(fd, options);
        }
    },
    "../node_modules/.pnpm/pend@1.2.0/node_modules/pend/index.js": function(module) {
        module.exports = Pend;
        function Pend() {
            this.pending = 0;
            this.max = 1 / 0;
            this.listeners = [];
            this.waiting = [];
            this.error = null;
        }
        Pend.prototype.go = function(fn) {
            if (this.pending < this.max) pendGo(this, fn);
            else this.waiting.push(fn);
        };
        Pend.prototype.wait = function(cb) {
            if (0 === this.pending) cb(this.error);
            else this.listeners.push(cb);
        };
        Pend.prototype.hold = function() {
            return pendHold(this);
        };
        function pendHold(self) {
            self.pending += 1;
            var called = false;
            return onCb;
            function onCb(err) {
                if (called) throw new Error("callback called twice");
                called = true;
                self.error = self.error || err;
                self.pending -= 1;
                if (self.waiting.length > 0 && self.pending < self.max) pendGo(self, self.waiting.shift());
                else if (0 === self.pending) {
                    var listeners = self.listeners;
                    self.listeners = [];
                    listeners.forEach(cbListener);
                }
            }
            function cbListener(listener) {
                listener(self.error);
            }
        }
        function pendGo(self, fn) {
            fn(pendHold(self));
        }
    },
    "../node_modules/.pnpm/yauzl@2.10.0/node_modules/yauzl/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        var fs = __webpack_require__("fs?fa32");
        var zlib = __webpack_require__("zlib");
        var fd_slicer = __webpack_require__("../node_modules/.pnpm/fd-slicer@1.1.0/node_modules/fd-slicer/index.js");
        var crc32 = __webpack_require__("../node_modules/.pnpm/buffer-crc32@0.2.13/node_modules/buffer-crc32/index.js");
        var util = __webpack_require__("util");
        var EventEmitter = __webpack_require__("events").EventEmitter;
        var Transform = __webpack_require__("stream").Transform;
        var PassThrough = __webpack_require__("stream").PassThrough;
        var Writable = __webpack_require__("stream").Writable;
        exports1.open = open;
        exports1.fromFd = fromFd;
        exports1.fromBuffer = fromBuffer;
        exports1.fromRandomAccessReader = fromRandomAccessReader;
        exports1.dosDateTimeToDate = dosDateTimeToDate;
        exports1.validateFileName = validateFileName;
        exports1.ZipFile = ZipFile;
        exports1.Entry = Entry;
        exports1.RandomAccessReader = RandomAccessReader;
        function open(path, options, callback) {
            if ("function" == typeof options) {
                callback = options;
                options = null;
            }
            if (null == options) options = {};
            if (null == options.autoClose) options.autoClose = true;
            if (null == options.lazyEntries) options.lazyEntries = false;
            if (null == options.decodeStrings) options.decodeStrings = true;
            if (null == options.validateEntrySizes) options.validateEntrySizes = true;
            if (null == options.strictFileNames) options.strictFileNames = false;
            if (null == callback) callback = defaultCallback;
            fs.open(path, "r", function(err, fd) {
                if (err) return callback(err);
                fromFd(fd, options, function(err, zipfile) {
                    if (err) fs.close(fd, defaultCallback);
                    callback(err, zipfile);
                });
            });
        }
        function fromFd(fd, options, callback) {
            if ("function" == typeof options) {
                callback = options;
                options = null;
            }
            if (null == options) options = {};
            if (null == options.autoClose) options.autoClose = false;
            if (null == options.lazyEntries) options.lazyEntries = false;
            if (null == options.decodeStrings) options.decodeStrings = true;
            if (null == options.validateEntrySizes) options.validateEntrySizes = true;
            if (null == options.strictFileNames) options.strictFileNames = false;
            if (null == callback) callback = defaultCallback;
            fs.fstat(fd, function(err, stats) {
                if (err) return callback(err);
                var reader = fd_slicer.createFromFd(fd, {
                    autoClose: true
                });
                fromRandomAccessReader(reader, stats.size, options, callback);
            });
        }
        function fromBuffer(buffer, options, callback) {
            if ("function" == typeof options) {
                callback = options;
                options = null;
            }
            if (null == options) options = {};
            options.autoClose = false;
            if (null == options.lazyEntries) options.lazyEntries = false;
            if (null == options.decodeStrings) options.decodeStrings = true;
            if (null == options.validateEntrySizes) options.validateEntrySizes = true;
            if (null == options.strictFileNames) options.strictFileNames = false;
            var reader = fd_slicer.createFromBuffer(buffer, {
                maxChunkSize: 0x10000
            });
            fromRandomAccessReader(reader, buffer.length, options, callback);
        }
        function fromRandomAccessReader(reader, totalSize, options, callback) {
            if ("function" == typeof options) {
                callback = options;
                options = null;
            }
            if (null == options) options = {};
            if (null == options.autoClose) options.autoClose = true;
            if (null == options.lazyEntries) options.lazyEntries = false;
            if (null == options.decodeStrings) options.decodeStrings = true;
            var decodeStrings = !!options.decodeStrings;
            if (null == options.validateEntrySizes) options.validateEntrySizes = true;
            if (null == options.strictFileNames) options.strictFileNames = false;
            if (null == callback) callback = defaultCallback;
            if ("number" != typeof totalSize) throw new Error("expected totalSize parameter to be a number");
            if (totalSize > Number.MAX_SAFE_INTEGER) throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
            reader.ref();
            var eocdrWithoutCommentSize = 22;
            var maxCommentSize = 0xffff;
            var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
            var buffer = newBuffer(bufferSize);
            var bufferReadStart = totalSize - buffer.length;
            readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
                if (err) return callback(err);
                for(var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1)if (0x06054b50 === buffer.readUInt32LE(i)) {
                    var eocdrBuffer = buffer.slice(i);
                    var diskNumber = eocdrBuffer.readUInt16LE(4);
                    if (0 !== diskNumber) return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
                    var entryCount = eocdrBuffer.readUInt16LE(10);
                    var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
                    var commentLength = eocdrBuffer.readUInt16LE(20);
                    var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
                    if (commentLength !== expectedCommentLength) return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
                    var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
                    if (!(0xffff === entryCount || 0xffffffff === centralDirectoryOffset)) return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
                    var zip64EocdlBuffer = newBuffer(20);
                    var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
                    readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err) {
                        if (err) return callback(err);
                        if (0x07064b50 !== zip64EocdlBuffer.readUInt32LE(0)) return callback(new Error("invalid zip64 end of central directory locator signature"));
                        var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
                        var zip64EocdrBuffer = newBuffer(56);
                        readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err) {
                            if (err) return callback(err);
                            if (0x06064b50 !== zip64EocdrBuffer.readUInt32LE(0)) return callback(new Error("invalid zip64 end of central directory record signature"));
                            entryCount = readUInt64LE(zip64EocdrBuffer, 32);
                            centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
                            return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
                        });
                    });
                    return;
                }
                callback(new Error("end of central directory record signature not found"));
            });
        }
        util.inherits(ZipFile, EventEmitter);
        function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
            var self = this;
            EventEmitter.call(self);
            self.reader = reader;
            self.reader.on("error", function(err) {
                emitError(self, err);
            });
            self.reader.once("close", function() {
                self.emit("close");
            });
            self.readEntryCursor = centralDirectoryOffset;
            self.fileSize = fileSize;
            self.entryCount = entryCount;
            self.comment = comment;
            self.entriesRead = 0;
            self.autoClose = !!autoClose;
            self.lazyEntries = !!lazyEntries;
            self.decodeStrings = !!decodeStrings;
            self.validateEntrySizes = !!validateEntrySizes;
            self.strictFileNames = !!strictFileNames;
            self.isOpen = true;
            self.emittedError = false;
            if (!self.lazyEntries) self._readEntry();
        }
        ZipFile.prototype.close = function() {
            if (!this.isOpen) return;
            this.isOpen = false;
            this.reader.unref();
        };
        function emitErrorAndAutoClose(self, err) {
            if (self.autoClose) self.close();
            emitError(self, err);
        }
        function emitError(self, err) {
            if (self.emittedError) return;
            self.emittedError = true;
            self.emit("error", err);
        }
        ZipFile.prototype.readEntry = function() {
            if (!this.lazyEntries) throw new Error("readEntry() called without lazyEntries:true");
            this._readEntry();
        };
        ZipFile.prototype._readEntry = function() {
            var self = this;
            if (self.entryCount === self.entriesRead) return void setImmediate(function() {
                if (self.autoClose) self.close();
                if (self.emittedError) return;
                self.emit("end");
            });
            if (self.emittedError) return;
            var buffer = newBuffer(46);
            readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {
                if (err) return emitErrorAndAutoClose(self, err);
                if (self.emittedError) return;
                var entry = new Entry();
                var signature = buffer.readUInt32LE(0);
                if (0x02014b50 !== signature) return emitErrorAndAutoClose(self, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
                entry.versionMadeBy = buffer.readUInt16LE(4);
                entry.versionNeededToExtract = buffer.readUInt16LE(6);
                entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
                entry.compressionMethod = buffer.readUInt16LE(10);
                entry.lastModFileTime = buffer.readUInt16LE(12);
                entry.lastModFileDate = buffer.readUInt16LE(14);
                entry.crc32 = buffer.readUInt32LE(16);
                entry.compressedSize = buffer.readUInt32LE(20);
                entry.uncompressedSize = buffer.readUInt32LE(24);
                entry.fileNameLength = buffer.readUInt16LE(28);
                entry.extraFieldLength = buffer.readUInt16LE(30);
                entry.fileCommentLength = buffer.readUInt16LE(32);
                entry.internalFileAttributes = buffer.readUInt16LE(36);
                entry.externalFileAttributes = buffer.readUInt32LE(38);
                entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
                if (0x40 & entry.generalPurposeBitFlag) return emitErrorAndAutoClose(self, new Error("strong encryption is not supported"));
                self.readEntryCursor += 46;
                buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
                readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {
                    if (err) return emitErrorAndAutoClose(self, err);
                    if (self.emittedError) return;
                    var isUtf8 = (0x800 & entry.generalPurposeBitFlag) !== 0;
                    entry.fileName = self.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength);
                    var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
                    var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
                    entry.extraFields = [];
                    var i = 0;
                    while(i < extraFieldBuffer.length - 3){
                        var headerId = extraFieldBuffer.readUInt16LE(i + 0);
                        var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
                        var dataStart = i + 4;
                        var dataEnd = dataStart + dataSize;
                        if (dataEnd > extraFieldBuffer.length) return emitErrorAndAutoClose(self, new Error("extra field length exceeds extra field buffer size"));
                        var dataBuffer = newBuffer(dataSize);
                        extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
                        entry.extraFields.push({
                            id: headerId,
                            data: dataBuffer
                        });
                        i = dataEnd;
                    }
                    entry.fileComment = self.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
                    entry.comment = entry.fileComment;
                    self.readEntryCursor += buffer.length;
                    self.entriesRead += 1;
                    if (0xffffffff === entry.uncompressedSize || 0xffffffff === entry.compressedSize || 0xffffffff === entry.relativeOffsetOfLocalHeader) {
                        var zip64EiefBuffer = null;
                        for(var i = 0; i < entry.extraFields.length; i++){
                            var extraField = entry.extraFields[i];
                            if (0x0001 === extraField.id) {
                                zip64EiefBuffer = extraField.data;
                                break;
                            }
                        }
                        if (null == zip64EiefBuffer) return emitErrorAndAutoClose(self, new Error("expected zip64 extended information extra field"));
                        var index = 0;
                        if (0xffffffff === entry.uncompressedSize) {
                            if (index + 8 > zip64EiefBuffer.length) return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include uncompressed size"));
                            entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
                            index += 8;
                        }
                        if (0xffffffff === entry.compressedSize) {
                            if (index + 8 > zip64EiefBuffer.length) return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include compressed size"));
                            entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
                            index += 8;
                        }
                        if (0xffffffff === entry.relativeOffsetOfLocalHeader) {
                            if (index + 8 > zip64EiefBuffer.length) return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include relative header offset"));
                            entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
                            index += 8;
                        }
                    }
                    if (self.decodeStrings) for(var i = 0; i < entry.extraFields.length; i++){
                        var extraField = entry.extraFields[i];
                        if (0x7075 === extraField.id) {
                            if (extraField.data.length < 6) continue;
                            if (1 !== extraField.data.readUInt8(0)) continue;
                            var oldNameCrc32 = extraField.data.readUInt32LE(1);
                            if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) continue;
                            entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
                            break;
                        }
                    }
                    if (self.validateEntrySizes && 0 === entry.compressionMethod) {
                        var expectedCompressedSize = entry.uncompressedSize;
                        if (entry.isEncrypted()) expectedCompressedSize += 12;
                        if (entry.compressedSize !== expectedCompressedSize) {
                            var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
                            return emitErrorAndAutoClose(self, new Error(msg));
                        }
                    }
                    if (self.decodeStrings) {
                        if (!self.strictFileNames) entry.fileName = entry.fileName.replace(/\\/g, "/");
                        var errorMessage = validateFileName(entry.fileName, self.validateFileNameOptions);
                        if (null != errorMessage) return emitErrorAndAutoClose(self, new Error(errorMessage));
                    }
                    self.emit("entry", entry);
                    if (!self.lazyEntries) self._readEntry();
                });
            });
        };
        ZipFile.prototype.openReadStream = function(entry, options, callback) {
            var self = this;
            var relativeStart = 0;
            var relativeEnd = entry.compressedSize;
            if (null == callback) {
                callback = options;
                options = {};
            } else {
                if (null != options.decrypt) {
                    if (!entry.isEncrypted()) throw new Error("options.decrypt can only be specified for encrypted entries");
                    if (false !== options.decrypt) throw new Error("invalid options.decrypt value: " + options.decrypt);
                    if (entry.isCompressed()) {
                        if (false !== options.decompress) throw new Error("entry is encrypted and compressed, and options.decompress !== false");
                    }
                }
                if (null != options.decompress) {
                    if (!entry.isCompressed()) throw new Error("options.decompress can only be specified for compressed entries");
                    if (!(false === options.decompress || true === options.decompress)) throw new Error("invalid options.decompress value: " + options.decompress);
                }
                if (null != options.start || null != options.end) {
                    if (entry.isCompressed() && false !== options.decompress) throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
                    if (entry.isEncrypted() && false !== options.decrypt) throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
                }
                if (null != options.start) {
                    relativeStart = options.start;
                    if (relativeStart < 0) throw new Error("options.start < 0");
                    if (relativeStart > entry.compressedSize) throw new Error("options.start > entry.compressedSize");
                }
                if (null != options.end) {
                    relativeEnd = options.end;
                    if (relativeEnd < 0) throw new Error("options.end < 0");
                    if (relativeEnd > entry.compressedSize) throw new Error("options.end > entry.compressedSize");
                    if (relativeEnd < relativeStart) throw new Error("options.end < options.start");
                }
            }
            if (!self.isOpen) return callback(new Error("closed"));
            if (entry.isEncrypted()) {
                if (false !== options.decrypt) return callback(new Error("entry is encrypted, and options.decrypt !== false"));
            }
            self.reader.ref();
            var buffer = newBuffer(30);
            readAndAssertNoEof(self.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
                try {
                    if (err) return callback(err);
                    var signature = buffer.readUInt32LE(0);
                    if (0x04034b50 !== signature) return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
                    var fileNameLength = buffer.readUInt16LE(26);
                    var extraFieldLength = buffer.readUInt16LE(28);
                    var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
                    var decompress;
                    if (0 === entry.compressionMethod) decompress = false;
                    else {
                        if (8 !== entry.compressionMethod) return callback(new Error("unsupported compression method: " + entry.compressionMethod));
                        decompress = null != options.decompress ? options.decompress : true;
                    }
                    var fileDataStart = localFileHeaderEnd;
                    var fileDataEnd = fileDataStart + entry.compressedSize;
                    if (0 !== entry.compressedSize) {
                        if (fileDataEnd > self.fileSize) return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self.fileSize));
                    }
                    var readStream = self.reader.createReadStream({
                        start: fileDataStart + relativeStart,
                        end: fileDataStart + relativeEnd
                    });
                    var endpointStream = readStream;
                    if (decompress) {
                        var destroyed = false;
                        var inflateFilter = zlib.createInflateRaw();
                        readStream.on("error", function(err) {
                            setImmediate(function() {
                                if (!destroyed) inflateFilter.emit("error", err);
                            });
                        });
                        readStream.pipe(inflateFilter);
                        if (self.validateEntrySizes) {
                            endpointStream = new AssertByteCountStream(entry.uncompressedSize);
                            inflateFilter.on("error", function(err) {
                                setImmediate(function() {
                                    if (!destroyed) endpointStream.emit("error", err);
                                });
                            });
                            inflateFilter.pipe(endpointStream);
                        } else endpointStream = inflateFilter;
                        endpointStream.destroy = function() {
                            destroyed = true;
                            if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);
                            readStream.unpipe(inflateFilter);
                            readStream.destroy();
                        };
                    }
                    callback(null, endpointStream);
                } finally{
                    self.reader.unref();
                }
            });
        };
        function Entry() {}
        Entry.prototype.getLastModDate = function() {
            return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
        };
        Entry.prototype.isEncrypted = function() {
            return (0x1 & this.generalPurposeBitFlag) !== 0;
        };
        Entry.prototype.isCompressed = function() {
            return 8 === this.compressionMethod;
        };
        function dosDateTimeToDate(date, time) {
            var day = 0x1f & date;
            var month = (date >> 5 & 0xf) - 1;
            var year = (date >> 9 & 0x7f) + 1980;
            var millisecond = 0;
            var second = (0x1f & time) * 2;
            var minute = time >> 5 & 0x3f;
            var hour = time >> 11 & 0x1f;
            return new Date(year, month, day, hour, minute, second, millisecond);
        }
        function validateFileName(fileName) {
            if (-1 !== fileName.indexOf("\\")) return "invalid characters in fileName: " + fileName;
            if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) return "absolute path: " + fileName;
            if (-1 !== fileName.split("/").indexOf("..")) return "invalid relative path: " + fileName;
            return null;
        }
        function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
            if (0 === length) return setImmediate(function() {
                callback(null, newBuffer(0));
            });
            reader.read(buffer, offset, length, position, function(err, bytesRead) {
                if (err) return callback(err);
                if (bytesRead < length) return callback(new Error("unexpected EOF"));
                callback();
            });
        }
        util.inherits(AssertByteCountStream, Transform);
        function AssertByteCountStream(byteCount) {
            Transform.call(this);
            this.actualByteCount = 0;
            this.expectedByteCount = byteCount;
        }
        AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
            this.actualByteCount += chunk.length;
            if (this.actualByteCount > this.expectedByteCount) {
                var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
                return cb(new Error(msg));
            }
            cb(null, chunk);
        };
        AssertByteCountStream.prototype._flush = function(cb) {
            if (this.actualByteCount < this.expectedByteCount) {
                var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
                return cb(new Error(msg));
            }
            cb();
        };
        util.inherits(RandomAccessReader, EventEmitter);
        function RandomAccessReader() {
            EventEmitter.call(this);
            this.refCount = 0;
        }
        RandomAccessReader.prototype.ref = function() {
            this.refCount += 1;
        };
        RandomAccessReader.prototype.unref = function() {
            var self = this;
            self.refCount -= 1;
            if (self.refCount > 0) return;
            if (self.refCount < 0) throw new Error("invalid unref");
            self.close(onCloseDone);
            function onCloseDone(err) {
                if (err) return self.emit('error', err);
                self.emit('close');
            }
        };
        RandomAccessReader.prototype.createReadStream = function(options) {
            var start = options.start;
            var end = options.end;
            if (start === end) {
                var emptyStream = new PassThrough();
                setImmediate(function() {
                    emptyStream.end();
                });
                return emptyStream;
            }
            var stream = this._readStreamForRange(start, end);
            var destroyed = false;
            var refUnrefFilter = new RefUnrefFilter(this);
            stream.on("error", function(err) {
                setImmediate(function() {
                    if (!destroyed) refUnrefFilter.emit("error", err);
                });
            });
            refUnrefFilter.destroy = function() {
                stream.unpipe(refUnrefFilter);
                refUnrefFilter.unref();
                stream.destroy();
            };
            var byteCounter = new AssertByteCountStream(end - start);
            refUnrefFilter.on("error", function(err) {
                setImmediate(function() {
                    if (!destroyed) byteCounter.emit("error", err);
                });
            });
            byteCounter.destroy = function() {
                destroyed = true;
                refUnrefFilter.unpipe(byteCounter);
                refUnrefFilter.destroy();
            };
            return stream.pipe(refUnrefFilter).pipe(byteCounter);
        };
        RandomAccessReader.prototype._readStreamForRange = function(start, end) {
            throw new Error("not implemented");
        };
        RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
            var readStream = this.createReadStream({
                start: position,
                end: position + length
            });
            var writeStream = new Writable();
            var written = 0;
            writeStream._write = function(chunk, encoding, cb) {
                chunk.copy(buffer, offset + written, 0, chunk.length);
                written += chunk.length;
                cb();
            };
            writeStream.on("finish", callback);
            readStream.on("error", function(error) {
                callback(error);
            });
            readStream.pipe(writeStream);
        };
        RandomAccessReader.prototype.close = function(callback) {
            setImmediate(callback);
        };
        util.inherits(RefUnrefFilter, PassThrough);
        function RefUnrefFilter(context) {
            PassThrough.call(this);
            this.context = context;
            this.context.ref();
            this.unreffedYet = false;
        }
        RefUnrefFilter.prototype._flush = function(cb) {
            this.unref();
            cb();
        };
        RefUnrefFilter.prototype.unref = function(cb) {
            if (this.unreffedYet) return;
            this.unreffedYet = true;
            this.context.unref();
        };
        var cp437 = '\u0000☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ';
        function decodeBuffer(buffer, start, end, isUtf8) {
            if (isUtf8) return buffer.toString("utf8", start, end);
            var result = "";
            for(var i = start; i < end; i++)result += cp437[buffer[i]];
            return result;
        }
        function readUInt64LE(buffer, offset) {
            var lower32 = buffer.readUInt32LE(offset);
            var upper32 = buffer.readUInt32LE(offset + 4);
            return 0x100000000 * upper32 + lower32;
        }
        var newBuffer;
        newBuffer = "function" == typeof Buffer.allocUnsafe ? function(len) {
            return Buffer.allocUnsafe(len);
        } : function(len) {
            return new Buffer(len);
        };
        function defaultCallback(err) {
            if (err) throw err;
        }
    }
};

//# sourceMappingURL=945.js.map