/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    SearchToolProvider: ()=>SearchToolProvider
});
const core_namespaceObject = require("@mcp-agent/core");
const search_namespaceObject = require("@agent-infra/search");
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
class SearchToolProvider {
    mapProviderString(provider) {
        const providerMap = {
            browser_search: search_namespaceObject.SearchProvider.BrowserSearch,
            bing: search_namespaceObject.SearchProvider.BingSearch,
            tavily: search_namespaceObject.SearchProvider.Tavily,
            searxng: search_namespaceObject.SearchProvider.SearXNG,
            duckduckgo: search_namespaceObject.SearchProvider.DuckduckgoSearch
        };
        const resolvedProvider = providerMap[provider] || search_namespaceObject.SearchProvider.BrowserSearch;
        this.logger.debug(`Mapped provider ${provider} to ${resolvedProvider}`);
        return resolvedProvider;
    }
    createSearchTool() {
        const MAX_WORDS = 7;
        return new core_namespaceObject.Tool({
            id: 'web_search',
            description: `\u{26A0}\u{FE0F} SEARCH QUERY LENGTH LIMIT: ${MAX_WORDS} WORDS MAXIMUM \u{26A0}\u{FE0F}

Search the web for information. For best results:\n1) Use CONCISE queries (3-5 words ideal)\n2) Include only ESSENTIAL keywords, not full questions\n3) For complex topics, use multiple simple searches instead of one long query\n4) Focus on specific terms that will appear on relevant pages`,
            parameters: core_namespaceObject.z.object({
                query: core_namespaceObject.z.string().describe(`Search query - MUST BE CONCISE (maximum ${MAX_WORDS} words)`),
                count: core_namespaceObject.z.number().optional().describe(`Number of results to return (default: ${this.config.count || 10})`)
            }),
            function: async ({ query, count })=>{
                if (!query || '' === query.trim()) return {
                    error: 'Search query is required'
                };
                try {
                    this.logger.info(`Performing search: "${query}" (count: ${count || this.config.count})`);
                    const results = await this.searchClient.search({
                        query,
                        count: count || this.config.count
                    });
                    return results.pages;
                } catch (error) {
                    this.logger.error(`Search error: ${error}`);
                    return {
                        error: `Search failed: ${error instanceof Error ? error.message : String(error)}`
                    };
                }
            }
        });
    }
    constructor(logger, config){
        var _config_browserSearch, _config_browserSearch1;
        _define_property(this, "logger", void 0);
        _define_property(this, "searchClient", void 0);
        _define_property(this, "config", void 0);
        this.logger = logger.spawn('SearchToolProvider');
        this.config = config;
        const provider = this.mapProviderString(config.provider);
        const searchConfig = {
            provider,
            providerConfig: {
                engine: (null == (_config_browserSearch = config.browserSearch) ? void 0 : _config_browserSearch.engine) || 'google',
                needVisitedUrls: (null == (_config_browserSearch1 = config.browserSearch) ? void 0 : _config_browserSearch1.needVisitedUrls) || false,
                apiKey: config.apiKey,
                baseUrl: config.baseUrl
            },
            logger: this.logger
        };
        this.searchClient = new search_namespaceObject.SearchClient(searchConfig);
        this.logger.info(`Search tool provider initialized with ${config.provider}`);
    }
}
exports.SearchToolProvider = __webpack_exports__.SearchToolProvider;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "SearchToolProvider"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});

//# sourceMappingURL=search-tool.js.map