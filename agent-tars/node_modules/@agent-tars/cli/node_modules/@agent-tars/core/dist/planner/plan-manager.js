/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    PlanManager: ()=>PlanManager,
    DEFAULT_PLANNING_PROMPT: ()=>DEFAULT_PLANNING_PROMPT
});
const core_namespaceObject = require("@mcp-agent/core");
const external_deep_research_js_namespaceObject = require("./deep-research.js");
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const DEFAULT_PLANNING_PROMPT = `
<planning_approach>
You are a methodical agent that follows a plan-and-solve approach for complex tasks. When handling tasks:

1. Analyze if the task requires a multi-step plan:
   - For complex research, analysis, or multi-part tasks \u{2192} Create a plan
   - For simple questions or tasks \u{2192} Skip planning and answer directly

2. If a plan is needed:
   - Create a clear, step-by-step plan with specific goals
   - Execute each step in order, using appropriate tools
   - Update the plan as you learn new information
   - Mark steps as completed when done
   - Once ALL steps are complete, call the "final_answer" tool

3. During execution:
   - Adapt your plan as needed based on new findings
   - Be willing to simplify the plan if the task turns out simpler than expected
   - Always complete your plan before providing final answers
</planning_approach>

<planning_constraints>
IMPORTANT CONSTRAINTS:
- Create AT MOST 3 key steps in your plan
- Focus on information gathering and research steps
- Call the "final_answer" tool once ALL plan steps are complete
- For simple questions, you can skip planning entirely
</planning_constraints>
`;
class PlanManager {
    hasPlanGenerated() {
        return this.hasPlan;
    }
    getPlanningPrompt() {
        return this.planningPrompt;
    }
    getTools() {
        return [
            new core_namespaceObject.Tool({
                id: 'final_answer',
                description: 'Generate a focused report or answer after completing research or information gathering',
                parameters: core_namespaceObject.z.object({
                    isDeepResearch: core_namespaceObject.z.boolean().optional().describe('Whether to generate a structured report (true) or simple answer (false)'),
                    title: core_namespaceObject.z.string().optional().describe('Title for the report or answer'),
                    format: core_namespaceObject.z["enum"]([
                        'detailed',
                        'concise'
                    ]).optional().describe('Report format: detailed or concise')
                }),
                function: async ({ isDeepResearch = false, title, format = 'concise' })=>{
                    this.logger.info(`Final answer tool called with isDeepResearch=${isDeepResearch}, title=${title || 'untitled'}`);
                    this.finalAnswerCalled = true;
                    const llmClient = this.agent.getLLMClient();
                    const resolvedModel = this.agent.getCurrentResolvedModel();
                    const abortSignal = this.agent.getAbortSignal();
                    try {
                        if (isDeepResearch) await this.deepResearchGenerator.generateReport(llmClient, resolvedModel, this.eventStream, {
                            title: title || 'Information Report',
                            format
                        }, abortSignal);
                        else {
                            const messageId = `final-answer-${Date.now()}`;
                            const finalAnswerEvent = this.eventStream.createEvent('final_answer', {
                                content: "I've completed the task. Here's a summary of what I found:",
                                isDeepResearch: false,
                                title: title || 'Answer',
                                messageId
                            });
                            this.eventStream.sendEvent(finalAnswerEvent);
                        }
                    } catch (error) {
                        if (null == abortSignal ? void 0 : abortSignal.aborted) {
                            this.logger.info('Final answer generation aborted');
                            return {
                                success: false,
                                error: 'Final answer generation aborted'
                            };
                        }
                        this.logger.error(`Error generating final answer: ${error}`);
                        return {
                            success: false,
                            error: `Failed to generate final answer: ${error}`
                        };
                    }
                    this.agent.requestLoopTermination();
                    return {
                        success: true,
                        message: 'Final answer generated'
                    };
                }
            })
        ];
    }
    isFinalAnswerCalled() {
        return this.finalAnswerCalled;
    }
    resetFinalAnswerStatus() {
        this.finalAnswerCalled = false;
    }
    isTaskCompleted() {
        return this.taskCompleted;
    }
    getCurrentPlan() {
        return [
            ...this.currentPlan
        ];
    }
    async generateInitialPlan(llmClient, resolvedModel, messages, sessionId) {
        const startEvent = this.eventStream.createEvent('plan_start', {
            sessionId
        });
        this.eventStream.sendEvent(startEvent);
        try {
            var _response_choices__message, _response_choices_;
            const response = await llmClient.chat.completions.create({
                model: resolvedModel.id,
                response_format: {
                    type: 'json_object'
                },
                messages: [
                    ...messages,
                    {
                        role: 'user',
                        content: `Analyze the user's request and determine if it requires a multi-step plan. For complex research, analysis, or multi-part tasks, create a step-by-step plan. For simple questions or tasks that can be answered directly, return an empty plan. Return a JSON object with an array of steps. Each step should have a "content" field describing what needs to be done and a "done" field set to false.\n\nIMPORTANT CONSIDERATIONS:\n1. Only create steps for tasks that truly require planning and multiple tools\n2. For simple questions or factual queries, return an empty steps array\n3. For browsing tasks, only use a plan if multiple sites or complex research is needed\n4. Create AT MOST ${this.maxSteps} key steps in your plan\n5. Focus ONLY on information gathering and research steps\n6. DO NOT include report creation as a step (the finalAnswer tool will handle this)`
                    }
                ]
            });
            const content = (null == (_response_choices_ = response.choices[0]) ? void 0 : null == (_response_choices__message = _response_choices_.message) ? void 0 : _response_choices__message.content) || '{"steps":[]}';
            let planData;
            try {
                planData = JSON.parse(content);
            } catch (e) {
                this.logger.error(`Failed to parse plan JSON: ${e}`);
                planData = {
                    steps: []
                };
            }
            this.currentPlan = Array.isArray(planData.steps) ? planData.steps.map((step)=>({
                    content: step.content || 'Unknown step',
                    done: false
                })) : [];
            this.hasPlan = this.currentPlan.length > 0;
            if (this.hasPlan) {
                const updateEvent = this.eventStream.createEvent('plan_update', {
                    sessionId,
                    steps: this.currentPlan
                });
                this.eventStream.sendEvent(updateEvent);
                this.logger.info(`Initial plan created with ${this.currentPlan.length} steps`);
            } else {
                this.logger.info("No plan needed for this task - proceeding with direct execution");
                this.taskCompleted = true;
            }
        } catch (error) {
            this.logger.error(`Error generating initial plan: ${error}`);
            this.currentPlan = [];
            this.taskCompleted = true;
        }
    }
    async updatePlan(llmClient, resolvedModel, messages, sessionId) {
        try {
            var _response_choices__message, _response_choices_;
            const response = await llmClient.chat.completions.create({
                model: resolvedModel.id,
                response_format: {
                    type: 'json_object'
                },
                messages: [
                    ...messages,
                    {
                        role: 'system',
                        content: `Evaluate the current progress and update the plan. Return a JSON object with an array of steps, marking completed steps as "done": true. Add new steps or update current steps if needed based on new information. If user's task is simple and doesn't require a multi-step plan, return an empty steps array. If all steps are complete, include a "completed": true field and a "summary" field with a final summary.\n\nIMPORTANT CONSIDERATIONS:\n1. Be willing to adapt the plan as you learn more about the task\n2. If the user's request turns out to be simpler than initially thought, simplify the plan\n3. If some steps are no longer necessary, mark them as done or remove them\n4. For simple questions that can be answered directly, return an empty plan\n5. Create AT MOST ${this.maxSteps} key steps in your plan\n6. Focus ONLY on information gathering and research steps\n7. DO NOT include report creation as a step (another tool will handle this)`
                    },
                    {
                        role: 'system',
                        content: `Current plan: ${JSON.stringify({
                            steps: this.currentPlan
                        })}`
                    }
                ]
            });
            const content = (null == (_response_choices_ = response.choices[0]) ? void 0 : null == (_response_choices__message = _response_choices_.message) ? void 0 : _response_choices__message.content) || '{"steps":[]}';
            let planData;
            try {
                planData = JSON.parse(content);
            } catch (e) {
                this.logger.error(`Failed to parse plan update JSON: ${e}`);
                planData = {
                    steps: this.currentPlan
                };
            }
            if (Array.isArray(planData.steps)) this.currentPlan = planData.steps.map((step)=>({
                    content: step.content || 'Unknown step',
                    done: Boolean(step.done)
                }));
            this.hasPlan = this.currentPlan.length > 0;
            const updateEvent = this.eventStream.createEvent('plan_update', {
                sessionId,
                steps: this.currentPlan
            });
            this.eventStream.sendEvent(updateEvent);
            const allStepsDone = this.currentPlan.every((step)=>step.done) || 0 === this.currentPlan.length;
            this.taskCompleted = allStepsDone || Boolean(planData.completed);
            if (this.taskCompleted) {
                const finishEvent = this.eventStream.createEvent('plan_finish', {
                    sessionId,
                    summary: planData.summary || 'Task completed successfully'
                });
                this.eventStream.sendEvent(finishEvent);
            }
        } catch (error) {
            this.logger.error(`Error updating plan: ${error}`);
        }
    }
    reset() {
        this.currentPlan = [];
        this.taskCompleted = false;
        this.finalAnswerCalled = false;
        this.hasPlan = false;
        this.logger.info('Plan state reset');
    }
    constructor(logger, eventStream, agent, options = {}){
        _define_property(this, "logger", void 0);
        _define_property(this, "eventStream", void 0);
        _define_property(this, "agent", void 0);
        _define_property(this, "currentPlan", void 0);
        _define_property(this, "taskCompleted", void 0);
        _define_property(this, "finalAnswerCalled", void 0);
        _define_property(this, "maxSteps", void 0);
        _define_property(this, "planningPrompt", void 0);
        _define_property(this, "hasPlan", void 0);
        _define_property(this, "deepResearchGenerator", void 0);
        this.logger = logger;
        this.eventStream = eventStream;
        this.agent = agent;
        this.currentPlan = [];
        this.taskCompleted = false;
        this.finalAnswerCalled = false;
        this.hasPlan = false;
        this.maxSteps = options.maxSteps ?? 3;
        this.planningPrompt = options.planningPrompt ? `${DEFAULT_PLANNING_PROMPT}\n\n${options.planningPrompt}` : DEFAULT_PLANNING_PROMPT;
        this.logger = logger.spawn('PlanManager');
        this.logger.info(`PlanManager initialized with max steps: ${this.maxSteps}`);
        this.deepResearchGenerator = new external_deep_research_js_namespaceObject.DeepResearchGenerator(this.logger, this.eventStream);
    }
}
exports.DEFAULT_PLANNING_PROMPT = __webpack_exports__.DEFAULT_PLANNING_PROMPT;
exports.PlanManager = __webpack_exports__.PlanManager;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "DEFAULT_PLANNING_PROMPT",
    "PlanManager"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});

//# sourceMappingURL=plan-manager.js.map