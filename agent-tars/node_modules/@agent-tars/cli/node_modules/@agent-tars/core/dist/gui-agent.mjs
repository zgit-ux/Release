/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
import * as __WEBPACK_EXTERNAL_MODULE__ui_tars_operator_browser_50329fa2__ from "@ui-tars/operator-browser";
import * as __WEBPACK_EXTERNAL_MODULE__multimodal_mcp_agent_4b976ab5__ from "@multimodal/mcp-agent";
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function sleep(time) {
    return new Promise(function(resolve) {
        setTimeout(resolve, time);
    });
}
class GUIAgent {
    async capturePageContentAsEnvironmentInfo() {
        if (!this.eventStream) return;
        try {
            const page = await this.getPage();
            const markdown = await page.evaluate(()=>{
                const extractMarkdown = ()=>{
                    const title = document.title || 'Untitled Page';
                    const getVisibleText = (node)=>{
                        if (node.nodeType === Node.TEXT_NODE) return node.textContent || '';
                        const style = window.getComputedStyle(node);
                        if ('none' === style.display || 'hidden' === style.visibility || '0' === style.opacity) return '';
                        let text = '';
                        for (const child of Array.from(node.childNodes))if (child.nodeType === Node.ELEMENT_NODE) text += getVisibleText(child);
                        else if (child.nodeType === Node.TEXT_NODE) text += child.textContent || '';
                        return text.trim();
                    };
                    const mainContent = document.querySelector('article, main, #content, .content') || document.body;
                    const content = getVisibleText(mainContent);
                    return `# ${title}\n\n${content}`;
                };
                return extractMarkdown();
            });
            if (markdown && markdown.trim()) {
                const event = this.eventStream.createEvent(__WEBPACK_EXTERNAL_MODULE__multimodal_mcp_agent_4b976ab5__.EventType.ENVIRONMENT_INPUT, {
                    content: markdown,
                    description: 'Page Content After Browser Action'
                });
                this.eventStream.sendEvent(event);
                this.logger.debug('Added page content to event stream as environment info');
            }
        } catch (error) {
            this.logger.warn(`Failed to capture page content: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    setEventStream(eventStream) {
        this.eventStream = eventStream;
    }
    getToolDefinition() {
        return this.guiAgentTool;
    }
    async onEachAgentLoopStart(eventStream, isReplaySnapshot = false) {
        console.log('Agent Loop Start');
        this.eventStream = eventStream;
        const startTime = performance.now();
        if (isReplaySnapshot) {
            const event = eventStream.createEvent(__WEBPACK_EXTERNAL_MODULE__multimodal_mcp_agent_4b976ab5__.EventType.ENVIRONMENT_INPUT, {
                content: [
                    {
                        type: 'image_url',
                        image_url: {
                            url: 'data:image/jpeg;base64,/9j/4AAQSk'
                        }
                    }
                ],
                description: 'Browser Screenshot'
            });
            return eventStream.sendEvent(event);
        }
        try {
            const output = await this.browserOperator.screenshot();
            const endTime = performance.now();
            const screenshotTime = (endTime - startTime).toFixed(2);
            this.extractImageDimensionsFromBase64(output.base64);
            const base64Data = output.base64.replace(/^data:image\/\w+;base64,/, '');
            const sizeInBytes = Math.ceil(3 * base64Data.length / 4);
            const sizeInKB = (sizeInBytes / 1024).toFixed(2);
            console.log('Screenshot info:', {
                width: this.screenWidth,
                height: this.screenHeight,
                size: `${sizeInKB} KB`,
                time: `${screenshotTime} ms`
            });
            const event = eventStream.createEvent(__WEBPACK_EXTERNAL_MODULE__multimodal_mcp_agent_4b976ab5__.EventType.ENVIRONMENT_INPUT, {
                content: [
                    {
                        type: 'image_url',
                        image_url: {
                            url: this.addBase64ImagePrefix(output.base64)
                        }
                    }
                ],
                description: 'Browser Screenshot'
            });
            eventStream.sendEvent(event);
        } catch (error) {
            this.logger.error(`Failed to take screenshot: ${error}`);
            throw error;
        }
    }
    addBase64ImagePrefix(base64) {
        if (!base64) return '';
        return base64.startsWith('data:') ? base64 : `data:image/jpeg;base64,${base64}`;
    }
    parseAction(actionString) {
        const actionTypeMatch = actionString.match(/^(\w+)\(/);
        const action_type = actionTypeMatch ? actionTypeMatch[1] : '';
        const action_inputs = {};
        const pointMatch = actionString.match(/point='<point>([\d\s]+)<\/point>'/);
        if (pointMatch) {
            const [x, y] = pointMatch[1].split(' ').map(Number);
            action_inputs.start_box = `[${x / this.factors[0]},${y / this.factors[1]}]`;
        }
        const startPointMatch = actionString.match(/start_point='<point>([\d\s]+)<\/point>'/);
        if (startPointMatch) {
            const [x, y] = startPointMatch[1].split(' ').map(Number);
            action_inputs.start_box = `[${x / this.factors[0]},${y / this.factors[1]}]`;
        }
        const endPointMatch = actionString.match(/end_point='<point>([\d\s]+)<\/point>'/);
        if (endPointMatch) {
            const [x, y] = endPointMatch[1].split(' ').map(Number);
            action_inputs.end_box = `[${x / this.factors[0]},${y / this.factors[1]}]`;
        }
        const contentMatch = actionString.match(/content='([^']*(?:\\.[^']*)*)'/);
        if (contentMatch) action_inputs.content = contentMatch[1].replace(/\\n/g, '\n').replace(/\\'/g, "'").replace(/\\"/g, '"');
        const keyMatch = actionString.match(/key='([^']*)'/);
        if (keyMatch) action_inputs.key = keyMatch[1];
        const directionMatch = actionString.match(/direction='([^']*)'/);
        if (directionMatch) action_inputs.direction = directionMatch[1];
        return {
            action_type,
            action_inputs
        };
    }
    extractImageDimensionsFromBase64(base64String) {
        const base64Data = base64String.replace(/^data:image\/\w+;base64,/, '');
        const buffer = Buffer.from(base64Data, 'base64');
        if (0x89 === buffer[0] && 0x50 === buffer[1] && 0x4e === buffer[2] && 0x47 === buffer[3]) {
            this.screenWidth = buffer.readUInt32BE(16);
            this.screenHeight = buffer.readUInt32BE(20);
        } else if (0xff === buffer[0] && 0xd8 === buffer[1]) {
            let offset = 2;
            while(offset < buffer.length){
                if (0xff !== buffer[offset]) break;
                const marker = buffer[offset + 1];
                const segmentLength = buffer.readUInt16BE(offset + 2);
                if (marker >= 0xc0 && marker <= 0xc3 || marker >= 0xc5 && marker <= 0xc7) {
                    this.screenHeight = buffer.readUInt16BE(offset + 5);
                    this.screenWidth = buffer.readUInt16BE(offset + 7);
                    break;
                }
                offset += 2 + segmentLength;
            }
        }
        if (!this.screenWidth || !this.screenHeight) this.logger.warn('Unable to extract dimension information from image data');
    }
    async getPage() {
        if (!this.browser) throw new Error('Browser not initialized');
        try {
            return await this.browser.getActivePage();
        } catch (error) {
            this.logger.warn('Failed to get active page, creating new page:', error);
            return await this.browser.createPage();
        }
    }
    constructor(options){
        _define_property(this, "options", void 0);
        _define_property(this, "browser", void 0);
        _define_property(this, "browserOperator", void 0);
        _define_property(this, "screenWidth", void 0);
        _define_property(this, "screenHeight", void 0);
        _define_property(this, "guiAgentTool", void 0);
        _define_property(this, "logger", void 0);
        _define_property(this, "factors", void 0);
        _define_property(this, "eventStream", void 0);
        this.options = options;
        this.logger = options.logger;
        this.factors = options.factors || [
            1000,
            1000
        ];
        this.eventStream = options.eventStream;
        this.browser = this.options.browser;
        this.browserOperator = new __WEBPACK_EXTERNAL_MODULE__ui_tars_operator_browser_50329fa2__.BrowserOperator({
            browser: this.browser,
            browserType: 'chrome',
            logger: this.logger,
            highlightClickableElements: false,
            showActionInfo: false,
            showWaterFlow: false
        });
        this.guiAgentTool = new __WEBPACK_EXTERNAL_MODULE__multimodal_mcp_agent_4b976ab5__.Tool({
            id: 'browser_vision_control',
            description: `A browser operation tool based on visual understanding, perform the next action to complete the task.

## Action Space

click(point='<point>x1 y1</point>')            - Click at the specified coordinates
left_double(point='<point>x1 y1</point>')      - Double-click at the specified coordinates
right_single(point='<point>x1 y1</point>')     - Right-click at the specified coordinates
drag(start_point='<point>x1 y1</point>', end_point='<point>x2 y2</point>') - Drag from start to end point
hotkey(key='ctrl c')                           - Press keyboard shortcut (use space to separate keys, lowercase)
type(content='xxx')                            - Type text content (use \\', \\", and \\n for special characters)
scroll(point='<point>x1 y1</point>', direction='down or up or right or left') - Scroll in specified direction
wait()                                         - Wait 5 seconds and take a screenshot to check for changes

## Note
- Folow user lanuage in in \`thought\` part.
- Describe your thought in \`step\` part.
- Describe your action in \`Step\` part.
- Extract the data your see in \`pageData\` part.
- This tool is for operational tasks, not for collect information.
`,
            parameters: __WEBPACK_EXTERNAL_MODULE__multimodal_mcp_agent_4b976ab5__.z.object({
                thought: __WEBPACK_EXTERNAL_MODULE__multimodal_mcp_agent_4b976ab5__.z.string().describe('Your observation and small plan in one sentence, DO NOT include " characters to avoid failure to render in JSON'),
                step: __WEBPACK_EXTERNAL_MODULE__multimodal_mcp_agent_4b976ab5__.z.string().describe('Finally summarize the next action (with its target element) in one sentence'),
                action: __WEBPACK_EXTERNAL_MODULE__multimodal_mcp_agent_4b976ab5__.z.string().describe('Some action in action space like click or press')
            }),
            function: async ({ thought, step, action, pageData })=>{
                try {
                    const parsed = this.parseAction(action);
                    parsed.thought = thought;
                    this.logger.debug({
                        thought,
                        step,
                        action,
                        parsedAction: JSON.stringify(parsed, null, 2),
                        screenDimensions: {
                            width: this.screenWidth,
                            height: this.screenHeight
                        }
                    });
                    const result = await this.browserOperator.execute({
                        parsedPrediction: parsed,
                        screenWidth: this.screenWidth || 1920,
                        screenHeight: this.screenHeight || 1080
                    });
                    await sleep(500);
                    return {
                        action,
                        status: 'success',
                        result,
                        pageData
                    };
                } catch (error) {
                    this.logger.error(`Browser action failed: ${error instanceof Error ? error.message : String(error)}`);
                    return {
                        action,
                        status: 'fail',
                        error: error instanceof Error ? error.message : String(error)
                    };
                }
            }
        });
    }
}
export { GUIAgent };

//# sourceMappingURL=gui-agent.mjs.map