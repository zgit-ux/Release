/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    BrowserGUIAgent: ()=>BrowserGUIAgent
});
const operator_browser_namespaceObject = require("@ui-tars/operator-browser");
const core_namespaceObject = require("@mcp-agent/core");
const utils_js_namespaceObject = require("../shared/utils.js");
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function sleep(time) {
    return new Promise(function(resolve) {
        setTimeout(resolve, time);
    });
}
class BrowserGUIAgent {
    async capturePageContentAsEnvironmentInfo() {
        if (!this.eventStream) return;
        try {
            const page = await this.getPage();
            const markdown = await page.evaluate(()=>{
                const extractMarkdown = ()=>{
                    const title = document.title || 'Untitled Page';
                    const getVisibleText = (node)=>{
                        if (node.nodeType === Node.TEXT_NODE) return node.textContent || '';
                        const style = window.getComputedStyle(node);
                        if ('none' === style.display || 'hidden' === style.visibility || '0' === style.opacity) return '';
                        let text = '';
                        for (const child of Array.from(node.childNodes))if (child.nodeType === Node.ELEMENT_NODE) text += getVisibleText(child);
                        else if (child.nodeType === Node.TEXT_NODE) text += child.textContent || '';
                        return text.trim();
                    };
                    const mainContent = document.querySelector('article, main, #content, .content') || document.body;
                    const content = getVisibleText(mainContent);
                    return `# ${title}\n\n${content}`;
                };
                return extractMarkdown();
            });
            if (markdown && markdown.trim()) {
                const event = this.eventStream.createEvent('environment_input', {
                    content: markdown,
                    description: 'Page Content After Browser Action'
                });
                this.eventStream.sendEvent(event);
                this.logger.debug('Added page content to event stream as environment info');
            }
        } catch (error) {
            this.logger.warn(`Failed to capture page content: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    setEventStream(eventStream) {
        this.eventStream = eventStream;
    }
    getTool() {
        return this.browserGUIAgentTool;
    }
    async onEachAgentLoopStart(eventStream, isReplaySnapshot = false) {
        console.log('Agent Loop Start');
        this.eventStream = eventStream;
        if (isReplaySnapshot) {
            const event = eventStream.createEvent('environment_input', {
                content: [
                    {
                        type: 'image_url',
                        image_url: {
                            url: 'data:image/jpeg;base64,/9j/4AAQSk'
                        }
                    }
                ],
                description: 'Browser Screenshot'
            });
            return eventStream.sendEvent(event);
        }
        try {
            if (!await this.browser.isBrowserAlive()) return void this.logger.info('Browser not launched yet, skipping screenshot');
            const startTime = performance.now();
            const output = await this.browserOperator.screenshot();
            const endTime = performance.now();
            const screenshotTime = (endTime - startTime).toFixed(2);
            this.extractImageDimensionsFromBase64(output.base64);
            const originalBase64Data = output.base64.replace(/^data:image\/\w+;base64,/, '');
            const originalBuffer = Buffer.from(originalBase64Data, 'base64');
            const originalSize = originalBuffer.length;
            const imageCompressor = new utils_js_namespaceObject.ImageCompressor({
                quality: 80,
                format: 'webp'
            });
            const compressedBuffer = await imageCompressor.compressToBuffer(originalBuffer);
            const compressedSize = compressedBuffer.length;
            const compressedBase64 = `data:image/webp;base64,${compressedBuffer.toString('base64')}`;
            const compressionRatio = originalSize / compressedSize;
            const compressionPercentage = ((1 - compressedSize / originalSize) * 100).toFixed(2);
            this.logger.info('Screenshot compression stats:', {
                original: (0, utils_js_namespaceObject.formatBytes)(originalSize),
                compressed: (0, utils_js_namespaceObject.formatBytes)(compressedSize),
                ratio: `${compressionRatio.toFixed(2)}x (${compressionPercentage}% smaller)`,
                dimensions: `${this.screenWidth}x${this.screenHeight}`,
                format: 'webp',
                quality: 20,
                time: `${screenshotTime} ms`
            });
            const sizeInKB = (compressedSize / 1024).toFixed(2);
            console.log('Screenshot info:', {
                width: this.screenWidth,
                height: this.screenHeight,
                size: `${sizeInKB} KB`,
                time: `${screenshotTime} ms`,
                compression: `${originalSize / 1024 > 1024 ? (originalSize / 1024 / 1024).toFixed(2) + ' MB' : (originalSize / 1024).toFixed(2) + ' KB'} \u{2192} ${(0, utils_js_namespaceObject.formatBytes)(compressedSize)} (${compressionPercentage}% reduction)`
            });
            const event = eventStream.createEvent('environment_input', {
                content: [
                    {
                        type: 'image_url',
                        image_url: {
                            url: compressedBase64
                        }
                    }
                ],
                description: 'Browser Screenshot'
            });
            eventStream.sendEvent(event);
        } catch (error) {
            this.logger.error(`Failed to take screenshot: ${error}`);
        }
    }
    addBase64ImagePrefix(base64) {
        if (!base64) return '';
        return base64.startsWith('data:') ? base64 : `data:image/jpeg;base64,${base64}`;
    }
    parseAction(actionString) {
        const actionTypeMatch = actionString.match(/^(\w+)\(/);
        const action_type = actionTypeMatch ? actionTypeMatch[1] : '';
        const action_inputs = {};
        const pointMatch = actionString.match(/point='<point>([\d\s]+)<\/point>'/);
        if (pointMatch) {
            const [x, y] = pointMatch[1].split(' ').map(Number);
            action_inputs.start_box = `[${x / this.factors[0]},${y / this.factors[1]}]`;
        }
        const startPointMatch = actionString.match(/start_point='<point>([\d\s]+)<\/point>'/);
        if (startPointMatch) {
            const [x, y] = startPointMatch[1].split(' ').map(Number);
            action_inputs.start_box = `[${x / this.factors[0]},${y / this.factors[1]}]`;
        }
        const endPointMatch = actionString.match(/end_point='<point>([\d\s]+)<\/point>'/);
        if (endPointMatch) {
            const [x, y] = endPointMatch[1].split(' ').map(Number);
            action_inputs.end_box = `[${x / this.factors[0]},${y / this.factors[1]}]`;
        }
        const contentMatch = actionString.match(/content='([^']*(?:\\.[^']*)*)'/);
        if (contentMatch) action_inputs.content = contentMatch[1].replace(/\\n/g, '\n').replace(/\\'/g, "'").replace(/\\"/g, '"');
        const keyMatch = actionString.match(/key='([^']*)'/);
        if (keyMatch) action_inputs.key = keyMatch[1];
        const directionMatch = actionString.match(/direction='([^']*)'/);
        if (directionMatch) action_inputs.direction = directionMatch[1];
        return {
            action_type,
            action_inputs
        };
    }
    extractImageDimensionsFromBase64(base64String) {
        const base64Data = base64String.replace(/^data:image\/\w+;base64,/, '');
        const buffer = Buffer.from(base64Data, 'base64');
        if (0x89 === buffer[0] && 0x50 === buffer[1] && 0x4e === buffer[2] && 0x47 === buffer[3]) {
            this.screenWidth = buffer.readUInt32BE(16);
            this.screenHeight = buffer.readUInt32BE(20);
        } else if (0xff === buffer[0] && 0xd8 === buffer[1]) {
            let offset = 2;
            while(offset < buffer.length){
                if (0xff !== buffer[offset]) break;
                const marker = buffer[offset + 1];
                const segmentLength = buffer.readUInt16BE(offset + 2);
                if (marker >= 0xc0 && marker <= 0xc3 || marker >= 0xc5 && marker <= 0xc7) {
                    this.screenHeight = buffer.readUInt16BE(offset + 5);
                    this.screenWidth = buffer.readUInt16BE(offset + 7);
                    break;
                }
                offset += 2 + segmentLength;
            }
        }
        if (!this.screenWidth || !this.screenHeight) this.logger.warn('Unable to extract dimension information from image data');
    }
    async getPage() {
        if (!this.browser) throw new Error('Browser not initialized');
        try {
            return await this.browser.getActivePage();
        } catch (error) {
            this.logger.warn('Failed to get active page, creating new page:', error);
            return await this.browser.createPage();
        }
    }
    constructor(options){
        _define_property(this, "options", void 0);
        _define_property(this, "browser", void 0);
        _define_property(this, "browserOperator", void 0);
        _define_property(this, "screenWidth", void 0);
        _define_property(this, "screenHeight", void 0);
        _define_property(this, "browserGUIAgentTool", void 0);
        _define_property(this, "logger", void 0);
        _define_property(this, "factors", void 0);
        _define_property(this, "eventStream", void 0);
        this.options = options;
        this.logger = options.logger;
        this.factors = options.factors || [
            1000,
            1000
        ];
        this.eventStream = options.eventStream;
        this.browser = this.options.browser;
        this.browserOperator = new operator_browser_namespaceObject.BrowserOperator({
            browser: this.browser,
            browserType: 'chrome',
            logger: this.logger,
            highlightClickableElements: false,
            showActionInfo: false,
            showWaterFlow: false
        });
        this.browserGUIAgentTool = new core_namespaceObject.Tool({
            id: 'browser_vision_control',
            description: `A browser operation tool based on visual understanding, perform the next action to complete the task.

## Action Space

click(point='<point>x1 y1</point>')            - Click at the specified coordinates
left_double(point='<point>x1 y1</point>')      - Double-click at the specified coordinates
right_single(point='<point>x1 y1</point>')     - Right-click at the specified coordinates
drag(start_point='<point>x1 y1</point>', end_point='<point>x2 y2</point>') - Drag from start to end point
hotkey(key='ctrl c')                           - Press keyboard shortcut (use space to separate keys, lowercase)
type(content='xxx')                            - Type text content (use \\', \\", and \\n for special characters)
scroll(point='<point>x1 y1</point>', direction='down or up or right or left') - Scroll in specified direction
wait()                                         - Wait 5 seconds and take a screenshot to check for changes

## Note
- Folow user lanuage in in \`thought\` part.
- Describe your thought in \`step\` part.
- Describe your action in \`Step\` part.
- Extract the data your see in \`pageData\` part.
- This tool is for operational tasks, not for collect information.
`,
            parameters: core_namespaceObject.z.object({
                thought: core_namespaceObject.z.string().describe('Your observation and small plan in one sentence, DO NOT include " characters to avoid failure to render in JSON'),
                step: core_namespaceObject.z.string().describe('Finally summarize the next action (with its target element) in one sentence'),
                action: core_namespaceObject.z.string().describe('Some action in action space like click or press')
            }),
            function: async ({ thought, step, action, pageData })=>{
                try {
                    const parsed = this.parseAction(action);
                    parsed.thought = thought;
                    this.logger.debug({
                        thought,
                        step,
                        action,
                        parsedAction: JSON.stringify(parsed, null, 2),
                        screenDimensions: {
                            width: this.screenWidth,
                            height: this.screenHeight
                        }
                    });
                    const result = await this.browserOperator.execute({
                        parsedPrediction: parsed,
                        screenWidth: this.screenWidth || 1920,
                        screenHeight: this.screenHeight || 1080
                    });
                    await sleep(500);
                    return {
                        action,
                        status: 'success',
                        result,
                        pageData
                    };
                } catch (error) {
                    this.logger.error(`Browser action failed: ${error instanceof Error ? error.message : String(error)}`);
                    return {
                        action,
                        status: 'fail',
                        error: error instanceof Error ? error.message : String(error)
                    };
                }
            }
        });
    }
}
exports.BrowserGUIAgent = __webpack_exports__.BrowserGUIAgent;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "BrowserGUIAgent"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});

//# sourceMappingURL=browser-gui-agent.js.map