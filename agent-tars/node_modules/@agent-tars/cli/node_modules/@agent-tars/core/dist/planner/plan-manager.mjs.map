{"version":3,"file":"planner/plan-manager.mjs","sources":["webpack://@agent-tars/core/./src/planner/plan-manager.ts"],"sourcesContent":["/*\n * Copyright (c) 2025 Bytedance, Inc. and its affiliates.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  ResolvedModel,\n  ChatCompletionMessageParam,\n  ConsoleLogger,\n  AgentEventStream,\n  Tool,\n  z,\n  OpenAI,\n} from '@mcp-agent/core';\nimport { AgentTARSPlannerOptions } from '../types';\nimport type { AgentTARS } from '../agent-tars';\nimport { DeepResearchGenerator } from './deep-research';\n\n/**\n * Default planning system prompt extension that guides the agent to create and follow plans\n */\nexport const DEFAULT_PLANNING_PROMPT = `\n<planning_approach>\nYou are a methodical agent that follows a plan-and-solve approach for complex tasks. When handling tasks:\n\n1. Analyze if the task requires a multi-step plan:\n   - For complex research, analysis, or multi-part tasks → Create a plan\n   - For simple questions or tasks → Skip planning and answer directly\n\n2. If a plan is needed:\n   - Create a clear, step-by-step plan with specific goals\n   - Execute each step in order, using appropriate tools\n   - Update the plan as you learn new information\n   - Mark steps as completed when done\n   - Once ALL steps are complete, call the \"final_answer\" tool\n\n3. During execution:\n   - Adapt your plan as needed based on new findings\n   - Be willing to simplify the plan if the task turns out simpler than expected\n   - Always complete your plan before providing final answers\n</planning_approach>\n\n<planning_constraints>\nIMPORTANT CONSTRAINTS:\n- Create AT MOST 3 key steps in your plan\n- Focus on information gathering and research steps\n- Call the \"final_answer\" tool once ALL plan steps are complete\n- For simple questions, you can skip planning entirely\n</planning_constraints>\n`;\n\n/**\n * PlanManager - Manages planning functionality for the agent\n *\n * This class handles the creation, updating, and tracking of plans,\n * as well as registering necessary tools for plan management.\n */\nexport class PlanManager {\n  private currentPlan: AgentEventStream.PlanStep[] = [];\n  private taskCompleted = false;\n  private finalAnswerCalled = false;\n  private maxSteps: number;\n  private planningPrompt: string;\n  private hasPlan = false;\n  private deepResearchGenerator: DeepResearchGenerator;\n\n  /**\n   * Creates a new PlanManager instance\n   *\n   * @param logger - Logger instance for logging plan-related events\n   * @param eventStream - EventStream for tracking plan events\n   * @param options - Configuration options for the planning system\n   */\n  constructor(\n    private logger: ConsoleLogger,\n    private eventStream: AgentEventStream.Processor,\n    private agent: AgentTARS,\n    options: AgentTARSPlannerOptions = {},\n  ) {\n    this.maxSteps = options.maxSteps ?? 3;\n    this.planningPrompt = options.planningPrompt\n      ? `${DEFAULT_PLANNING_PROMPT}\\n\\n${options.planningPrompt}`\n      : DEFAULT_PLANNING_PROMPT;\n\n    this.logger = logger.spawn('PlanManager');\n    this.logger.info(`PlanManager initialized with max steps: ${this.maxSteps}`);\n\n    // Initialize deep research generator\n    this.deepResearchGenerator = new DeepResearchGenerator(this.logger, this.eventStream);\n  }\n\n  /**\n   * Checks if a plan has been generated for the current task\n   */\n  hasPlanGenerated(): boolean {\n    return this.hasPlan;\n  }\n\n  /**\n   * Gets the planning system prompt extension\n   */\n  getPlanningPrompt(): string {\n    return this.planningPrompt;\n  }\n\n  /**\n   * Registers planning-related tools with the agent\n   *\n   * @returns Array of tool definitions to register\n   */\n  getTools(): Tool[] {\n    return [\n      new Tool({\n        id: 'final_answer',\n        description:\n          'Generate a focused report or answer after completing research or information gathering',\n        parameters: z.object({\n          isDeepResearch: z\n            .boolean()\n            .optional()\n            .describe('Whether to generate a structured report (true) or simple answer (false)'),\n          title: z.string().optional().describe('Title for the report or answer'),\n          format: z\n            .enum(['detailed', 'concise'])\n            .optional()\n            .describe('Report format: detailed or concise'),\n        }),\n        function: async ({ isDeepResearch = false, title, format = 'concise' }) => {\n          this.logger.info(\n            `Final answer tool called with isDeepResearch=${isDeepResearch}, title=${title || 'untitled'}`,\n          );\n          this.finalAnswerCalled = true;\n\n          const llmClient = this.agent.getLLMClient()!;\n          const resolvedModel = this.agent.getCurrentResolvedModel()!;\n\n          // Get the abort signal from the agent's execution controller\n          const abortSignal = this.agent.getAbortSignal();\n\n          try {\n            if (isDeepResearch) {\n              // Generate a focused research report\n              await this.deepResearchGenerator.generateReport(\n                llmClient,\n                resolvedModel,\n                this.eventStream,\n                {\n                  title: title || 'Information Report',\n                  format,\n                },\n                abortSignal, // Pass the abort signal\n              );\n            } else {\n              // Generate a simple answer - sent directly as assistant message\n              const messageId = `final-answer-${Date.now()}`;\n\n              // Create the final answer event\n              const finalAnswerEvent = this.eventStream.createEvent('final_answer', {\n                content: \"I've completed the task. Here's a summary of what I found:\",\n                isDeepResearch: false,\n                title: title || 'Answer',\n                messageId,\n              });\n\n              // Send the event\n              this.eventStream.sendEvent(finalAnswerEvent);\n            }\n          } catch (error) {\n            // 处理中断错误\n            if (abortSignal?.aborted) {\n              this.logger.info('Final answer generation aborted');\n              return {\n                success: false,\n                error: 'Final answer generation aborted',\n              };\n            }\n\n            this.logger.error(`Error generating final answer: ${error}`);\n            return {\n              success: false,\n              error: `Failed to generate final answer: ${error}`,\n            };\n          }\n\n          // Request loop termination\n          this.agent.requestLoopTermination();\n\n          return {\n            success: true,\n            message: 'Final answer generated',\n          };\n        },\n      }),\n    ];\n  }\n\n  /**\n   * Checks if the final report has been called\n   */\n  isFinalAnswerCalled(): boolean {\n    return this.finalAnswerCalled;\n  }\n\n  /**\n   * Resets the final report status\n   */\n  resetFinalAnswerStatus(): void {\n    this.finalAnswerCalled = false;\n  }\n\n  /**\n   * Checks if all plan steps are complete\n   */\n  isTaskCompleted(): boolean {\n    return this.taskCompleted;\n  }\n\n  /**\n   * Gets the current plan steps\n   */\n  getCurrentPlan(): AgentEventStream.PlanStep[] {\n    return [...this.currentPlan];\n  }\n\n  /**\n   * Generates the initial plan for a task\n   *\n   * @param llmClient - The LLM client to use for plan generation\n   * @param resolvedModel - The resolved model configuration\n   * @param messages - The current conversation messages\n   * @param sessionId - The session identifier\n   */\n  async generateInitialPlan(\n    llmClient: OpenAI,\n    resolvedModel: ResolvedModel,\n    messages: ChatCompletionMessageParam[],\n    sessionId: string,\n  ): Promise<void> {\n    // Create plan start event\n    const startEvent = this.eventStream.createEvent('plan_start', {\n      sessionId,\n    });\n    this.eventStream.sendEvent(startEvent);\n\n    try {\n      // Request the LLM to create an initial plan with steps\n      const response = await llmClient.chat.completions.create({\n        model: resolvedModel.id,\n        response_format: { type: 'json_object' },\n        messages: [\n          ...messages,\n          {\n            role: 'user',\n            content:\n              \"Analyze the user's request and determine if it requires a multi-step plan. \" +\n              'For complex research, analysis, or multi-part tasks, create a step-by-step plan. ' +\n              'For simple questions or tasks that can be answered directly, return an empty plan. ' +\n              'Return a JSON object with an array of steps. Each step should have a \"content\" field ' +\n              'describing what needs to be done and a \"done\" field set to false.\\n\\n' +\n              'IMPORTANT CONSIDERATIONS:\\n' +\n              '1. Only create steps for tasks that truly require planning and multiple tools\\n' +\n              '2. For simple questions or factual queries, return an empty steps array\\n' +\n              '3. For browsing tasks, only use a plan if multiple sites or complex research is needed\\n' +\n              `4. Create AT MOST ${this.maxSteps} key steps in your plan\\n` +\n              '5. Focus ONLY on information gathering and research steps\\n' +\n              '6. DO NOT include report creation as a step (the finalAnswer tool will handle this)',\n          },\n        ],\n      });\n\n      // Parse the response\n      const content = response.choices[0]?.message?.content || '{\"steps\":[]}';\n      let planData: {\n        steps: AgentEventStream.PlanStep[];\n        summary?: string;\n        completed?: boolean;\n      };\n      try {\n        planData = JSON.parse(content);\n      } catch (e) {\n        this.logger.error(`Failed to parse plan JSON: ${e}`);\n        planData = { steps: [] };\n      }\n\n      // Store the plan\n      this.currentPlan = Array.isArray(planData.steps)\n        ? planData.steps.map((step) => ({\n            content: step.content || 'Unknown step',\n            done: false,\n          }))\n        : [];\n\n      // Set hasPlan flag based on whether we have any plan steps\n      this.hasPlan = this.currentPlan.length > 0;\n\n      // Only send plan update event if there are steps\n      if (this.hasPlan) {\n        // Send plan update event\n        const updateEvent = this.eventStream.createEvent('plan_update', {\n          sessionId,\n          steps: this.currentPlan,\n        });\n        this.eventStream.sendEvent(updateEvent);\n\n        this.logger.info(`Initial plan created with ${this.currentPlan.length} steps`);\n      } else {\n        // Log that no plan was needed for this task\n        this.logger.info(`No plan needed for this task - proceeding with direct execution`);\n\n        // Mark task as completed if no steps are needed\n        this.taskCompleted = true;\n      }\n    } catch (error) {\n      this.logger.error(`Error generating initial plan: ${error}`);\n\n      // Create a minimal default plan if generation fails\n      this.currentPlan = [];\n      this.taskCompleted = true;\n    }\n  }\n\n  /**\n   * Updates the plan based on current progress\n   *\n   * @param llmClient - The LLM client to use for plan updates\n   * @param resolvedModel - The resolved model configuration\n   * @param messages - The current conversation messages\n   * @param sessionId - The session identifier\n   */\n  async updatePlan(\n    llmClient: OpenAI,\n    resolvedModel: ResolvedModel,\n    messages: ChatCompletionMessageParam[],\n    sessionId: string,\n  ): Promise<void> {\n    try {\n      // Request the LLM to evaluate and update the plan\n      const response = await llmClient.chat.completions.create({\n        model: resolvedModel.id,\n        response_format: { type: 'json_object' },\n        messages: [\n          ...messages,\n          {\n            role: 'system',\n            content:\n              'Evaluate the current progress and update the plan. ' +\n              'Return a JSON object with an array of steps, marking completed steps as \"done\": true. ' +\n              'Add new steps or update current steps if needed based on new information. ' +\n              \"If user's task is simple and doesn't require a multi-step plan, return an empty steps array. \" +\n              'If all steps are complete, include a \"completed\": true field ' +\n              'and a \"summary\" field with a final summary.\\n\\n' +\n              'IMPORTANT CONSIDERATIONS:\\n' +\n              '1. Be willing to adapt the plan as you learn more about the task\\n' +\n              \"2. If the user's request turns out to be simpler than initially thought, simplify the plan\\n\" +\n              '3. If some steps are no longer necessary, mark them as done or remove them\\n' +\n              '4. For simple questions that can be answered directly, return an empty plan\\n' +\n              `5. Create AT MOST ${this.maxSteps} key steps in your plan\\n` +\n              '6. Focus ONLY on information gathering and research steps\\n' +\n              '7. DO NOT include report creation as a step (another tool will handle this)',\n          },\n          {\n            role: 'system',\n            content: `Current plan: ${JSON.stringify({ steps: this.currentPlan })}`,\n          },\n        ],\n      });\n\n      // Parse the response\n      const content = response.choices[0]?.message?.content || '{\"steps\":[]}';\n      let planData;\n      try {\n        planData = JSON.parse(content) as {\n          steps: AgentEventStream.PlanStep[];\n          summary?: string;\n          completed?: boolean;\n        };\n      } catch (e) {\n        this.logger.error(`Failed to parse plan update JSON: ${e}`);\n        planData = { steps: this.currentPlan };\n      }\n\n      // Update the plan\n      if (Array.isArray(planData.steps)) {\n        this.currentPlan = planData.steps.map((step) => ({\n          content: step.content || 'Unknown step',\n          done: Boolean(step.done),\n        }));\n      }\n\n      // Update hasPlan flag based on whether we have any plan steps\n      this.hasPlan = this.currentPlan.length > 0;\n\n      // Send plan update event\n      const updateEvent = this.eventStream.createEvent('plan_update', {\n        sessionId,\n        steps: this.currentPlan,\n      });\n      this.eventStream.sendEvent(updateEvent);\n\n      // Check if the plan is completed\n      const allStepsDone =\n        this.currentPlan.every((step) => step.done) || this.currentPlan.length === 0;\n      this.taskCompleted = allStepsDone || Boolean(planData.completed);\n\n      if (this.taskCompleted) {\n        // Send plan finish event\n        const finishEvent = this.eventStream.createEvent('plan_finish', {\n          sessionId,\n          summary: planData.summary || 'Task completed successfully',\n        });\n        this.eventStream.sendEvent(finishEvent);\n      }\n    } catch (error) {\n      this.logger.error(`Error updating plan: ${error}`);\n    }\n  }\n\n  /**\n   * Resets the planner state for a new session\n   */\n  reset(): void {\n    this.currentPlan = [];\n    this.taskCompleted = false;\n    this.finalAnswerCalled = false;\n    this.hasPlan = false;\n    this.logger.info('Plan state reset');\n  }\n}\n"],"names":["DEFAULT_PLANNING_PROMPT","PlanManager","Tool","z","isDeepResearch","title","format","llmClient","resolvedModel","abortSignal","messageId","Date","finalAnswerEvent","error","messages","sessionId","startEvent","_response_choices__message","response","content","planData","JSON","e","Array","step","updateEvent","Boolean","allStepsDone","finishEvent","logger","eventStream","agent","options","DeepResearchGenerator"],"mappings":";;;;;;AAGC;;;;;;;;;;AAkBM,MAAMA,0BAA0B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BxC,CAAC;AAQM,MAAMC;IAqCX,mBAA4B;QAC1B,OAAO,IAAI,CAAC,OAAO;IACrB;IAKA,oBAA4B;QAC1B,OAAO,IAAI,CAAC,cAAc;IAC5B;IAOA,WAAmB;QACjB,OAAO;YACL,IAAIC,KAAK;gBACP,IAAI;gBACJ,aACE;gBACF,YAAYC,EAAE,MAAM,CAAC;oBACnB,gBAAgBA,EAAAA,OACN,GACP,QAAQ,GACR,QAAQ,CAAC;oBACZ,OAAOA,EAAE,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;oBACtC,QAAQA,CAAC,CAADA,OACD,CAAC;wBAAC;wBAAY;qBAAU,EAC5B,QAAQ,GACR,QAAQ,CAAC;gBACd;gBACA,UAAU,OAAO,EAAEC,iBAAiB,KAAK,EAAEC,KAAK,EAAEC,SAAS,SAAS,EAAE;oBACpE,IAAI,CAAC,MAAM,CAAC,IAAI,CACd,CAAC,6CAA6C,EAAEF,eAAe,QAAQ,EAAEC,SAAS,YAAY;oBAEhG,IAAI,CAAC,iBAAiB,GAAG;oBAEzB,MAAME,YAAY,IAAI,CAAC,KAAK,CAAC,YAAY;oBACzC,MAAMC,gBAAgB,IAAI,CAAC,KAAK,CAAC,uBAAuB;oBAGxD,MAAMC,cAAc,IAAI,CAAC,KAAK,CAAC,cAAc;oBAE7C,IAAI;wBACF,IAAIL,gBAEF,MAAM,IAAI,CAAC,qBAAqB,CAAC,cAAc,CAC7CG,WACAC,eACA,IAAI,CAAC,WAAW,EAChB;4BACE,OAAOH,SAAS;4BAChBC;wBACF,GACAG;6BAEG;4BAEL,MAAMC,YAAY,CAAC,aAAa,EAAEC,KAAK,GAAG,IAAI;4BAG9C,MAAMC,mBAAmB,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,gBAAgB;gCACpE,SAAS;gCACT,gBAAgB;gCAChB,OAAOP,SAAS;gCAChBK;4BACF;4BAGA,IAAI,CAAC,WAAW,CAAC,SAAS,CAACE;wBAC7B;oBACF,EAAE,OAAOC,OAAO;wBAEd,IAAIJ,QAAAA,cAAAA,KAAAA,IAAAA,YAAa,OAAO,EAAE;4BACxB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;4BACjB,OAAO;gCACL,SAAS;gCACT,OAAO;4BACT;wBACF;wBAEA,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,+BAA+B,EAAEI,OAAO;wBAC3D,OAAO;4BACL,SAAS;4BACT,OAAO,CAAC,iCAAiC,EAAEA,OAAO;wBACpD;oBACF;oBAGA,IAAI,CAAC,KAAK,CAAC,sBAAsB;oBAEjC,OAAO;wBACL,SAAS;wBACT,SAAS;oBACX;gBACF;YACF;SACD;IACH;IAKA,sBAA+B;QAC7B,OAAO,IAAI,CAAC,iBAAiB;IAC/B;IAKA,yBAA+B;QAC7B,IAAI,CAAC,iBAAiB,GAAG;IAC3B;IAKA,kBAA2B;QACzB,OAAO,IAAI,CAAC,aAAa;IAC3B;IAKA,iBAA8C;QAC5C,OAAO;eAAI,IAAI,CAAC,WAAW;SAAC;IAC9B;IAUA,MAAM,oBACJN,SAAiB,EACjBC,aAA4B,EAC5BM,QAAsC,EACtCC,SAAiB,EACF;QAEf,MAAMC,aAAa,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,cAAc;YAC5DD;QACF;QACA,IAAI,CAAC,WAAW,CAAC,SAAS,CAACC;QAE3B,IAAI;gBA2BcC,4BAAAA;YAzBhB,MAAMC,WAAW,MAAMX,UAAU,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;gBACvD,OAAOC,cAAc,EAAE;gBACvB,iBAAiB;oBAAE,MAAM;gBAAc;gBACvC,UAAU;uBACLM;oBACH;wBACE,MAAM;wBACN,SAUE,CAAC,sqBAAkB,EAAE,IAAI,CAAC,QAAQ,CAAC,uKAAyB,CAAC;oBAGjE;iBACD;YACH;YAGA,MAAMK,UAAUF,AAAAA,SAAAA,CAAAA,qBAAAA,SAAS,OAAO,CAAC,EAAE,AAAD,IAAlBA,KAAAA,IAAAA,QAAAA,CAAAA,6BAAAA,mBAAqB,OAAO,AAAD,IAA3BA,KAAAA,IAAAA,2BAA8B,OAAO,AAAD,KAAK;YACzD,IAAIG;YAKJ,IAAI;gBACFA,WAAWC,KAAK,KAAK,CAACF;YACxB,EAAE,OAAOG,GAAG;gBACV,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,2BAA2B,EAAEA,GAAG;gBACnDF,WAAW;oBAAE,OAAO,EAAE;gBAAC;YACzB;YAGA,IAAI,CAAC,WAAW,GAAGG,MAAM,OAAO,CAACH,SAAS,KAAK,IAC3CA,SAAS,KAAK,CAAC,GAAG,CAAC,CAACI,OAAU;oBAC5B,SAASA,KAAK,OAAO,IAAI;oBACzB,MAAM;gBACR,MACA,EAAE;YAGN,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,GAAG;YAGzC,IAAI,IAAI,CAAC,OAAO,EAAE;gBAEhB,MAAMC,cAAc,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,eAAe;oBAC9DV;oBACA,OAAO,IAAI,CAAC,WAAW;gBACzB;gBACA,IAAI,CAAC,WAAW,CAAC,SAAS,CAACU;gBAE3B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,0BAA0B,EAAE,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC;YAC/E,OAAO;gBAEL,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;gBAGjB,IAAI,CAAC,aAAa,GAAG;YACvB;QACF,EAAE,OAAOZ,OAAO;YACd,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,+BAA+B,EAAEA,OAAO;YAG3D,IAAI,CAAC,WAAW,GAAG,EAAE;YACrB,IAAI,CAAC,aAAa,GAAG;QACvB;IACF;IAUA,MAAM,WACJN,SAAiB,EACjBC,aAA4B,EAC5BM,QAAsC,EACtCC,SAAiB,EACF;QACf,IAAI;gBAiCcE,4BAAAA;YA/BhB,MAAMC,WAAW,MAAMX,UAAU,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;gBACvD,OAAOC,cAAc,EAAE;gBACvB,iBAAiB;oBAAE,MAAM;gBAAc;gBACvC,UAAU;uBACLM;oBACH;wBACE,MAAM;wBACN,SAYE,CAAC,gwBAAkB,EAAE,IAAI,CAAC,QAAQ,CAAC,+JAAyB,CAAC;oBAGjE;oBACA;wBACE,MAAM;wBACN,SAAS,CAAC,cAAc,EAAEO,KAAK,SAAS,CAAC;4BAAE,OAAO,IAAI,CAAC,WAAW;wBAAC,IAAI;oBACzE;iBACD;YACH;YAGA,MAAMF,UAAUF,AAAAA,SAAAA,CAAAA,qBAAAA,SAAS,OAAO,CAAC,EAAE,AAAD,IAAlBA,KAAAA,IAAAA,QAAAA,CAAAA,6BAAAA,mBAAqB,OAAO,AAAD,IAA3BA,KAAAA,IAAAA,2BAA8B,OAAO,AAAD,KAAK;YACzD,IAAIG;YACJ,IAAI;gBACFA,WAAWC,KAAK,KAAK,CAACF;YAKxB,EAAE,OAAOG,GAAG;gBACV,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,kCAAkC,EAAEA,GAAG;gBAC1DF,WAAW;oBAAE,OAAO,IAAI,CAAC,WAAW;gBAAC;YACvC;YAGA,IAAIG,MAAM,OAAO,CAACH,SAAS,KAAK,GAC9B,IAAI,CAAC,WAAW,GAAGA,SAAS,KAAK,CAAC,GAAG,CAAC,CAACI,OAAU;oBAC/C,SAASA,KAAK,OAAO,IAAI;oBACzB,MAAME,QAAQF,KAAK,IAAI;gBACzB;YAIF,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,GAAG;YAGzC,MAAMC,cAAc,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,eAAe;gBAC9DV;gBACA,OAAO,IAAI,CAAC,WAAW;YACzB;YACA,IAAI,CAAC,WAAW,CAAC,SAAS,CAACU;YAG3B,MAAME,eACJ,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAACH,OAASA,KAAK,IAAI,KAAK,AAA4B,MAA5B,IAAI,CAAC,WAAW,CAAC,MAAM;YACxE,IAAI,CAAC,aAAa,GAAGG,gBAAgBD,QAAQN,SAAS,SAAS;YAE/D,IAAI,IAAI,CAAC,aAAa,EAAE;gBAEtB,MAAMQ,cAAc,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,eAAe;oBAC9Db;oBACA,SAASK,SAAS,OAAO,IAAI;gBAC/B;gBACA,IAAI,CAAC,WAAW,CAAC,SAAS,CAACQ;YAC7B;QACF,EAAE,OAAOf,OAAO;YACd,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,qBAAqB,EAAEA,OAAO;QACnD;IACF;IAKA,QAAc;QACZ,IAAI,CAAC,WAAW,GAAG,EAAE;QACrB,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,iBAAiB,GAAG;QACzB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;IACnB;IAjWA,YACUgB,MAAqB,EACrBC,WAAuC,EACvCC,KAAgB,EACxBC,UAAmC,CAAC,CAAC,CACrC;;;;QApBF,uBAAQ,eAAR;QACA,uBAAQ,iBAAR;QACA,uBAAQ,qBAAR;QACA,uBAAQ,YAAR;QACA,uBAAQ,kBAAR;QACA,uBAAQ,WAAR;QACA,uBAAQ,yBAAR;aAUUH,MAAM,GAANA;aACAC,WAAW,GAAXA;aACAC,KAAK,GAALA;aAlBF,WAAW,GAAgC,EAAE;aAC7C,aAAa,GAAG;aAChB,iBAAiB,GAAG;aAGpB,OAAO,GAAG;QAgBhB,IAAI,CAAC,QAAQ,GAAGC,QAAQ,QAAQ,IAAI;QACpC,IAAI,CAAC,cAAc,GAAGA,QAAQ,cAAc,GACxC,GAAGhC,wBAAwB,IAAI,EAAEgC,QAAQ,cAAc,EAAE,GACzDhC;QAEJ,IAAI,CAAC,MAAM,GAAG6B,OAAO,KAAK,CAAC;QAC3B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,wCAAwC,EAAE,IAAI,CAAC,QAAQ,EAAE;QAG3E,IAAI,CAAC,qBAAqB,GAAG,IAAII,sBAAsB,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,WAAW;IACtF;AAkVF"}