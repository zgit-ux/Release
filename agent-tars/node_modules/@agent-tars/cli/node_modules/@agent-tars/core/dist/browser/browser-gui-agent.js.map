{"version":3,"file":"browser/browser-gui-agent.js","sources":["webpack://@agent-tars/core/webpack/runtime/define_property_getters","webpack://@agent-tars/core/webpack/runtime/has_own_property","webpack://@agent-tars/core/webpack/runtime/make_namespace_object","webpack://@agent-tars/core/./src/browser/browser-gui-agent.ts"],"sourcesContent":["__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n        }\n    }\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/* eslint-disable @typescript-eslint/no-explicit-any */\n/*\n * Copyright (c) 2025 Bytedance, Inc. and its affiliates.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { LocalBrowser, Page } from '@agent-infra/browser';\nimport { BrowserOperator } from '@ui-tars/operator-browser';\nimport { ConsoleLogger, AgentEventStream, Tool, z } from '@mcp-agent/core';\nimport { ImageCompressor, formatBytes } from '../shared/utils';\n\n/**\n * Coordinate type definition\n */\nexport type Coords = [number, number] | [];\n\n/**\n * Action input parameters for browser actions\n */\nexport interface ActionInputs {\n  content?: string;\n  start_box?: string;\n  end_box?: string;\n  key?: string;\n  hotkey?: string;\n  direction?: string;\n  start_coords?: Coords;\n  end_coords?: Coords;\n}\n\nfunction sleep(time: number) {\n  return new Promise(function (resolve) {\n    setTimeout(resolve, time);\n  });\n}\n\n/**\n * Parsed prediction from GUI agent\n */\nexport interface PredictionParsed {\n  /** Action inputs parsed from action_type(action_inputs) */\n  action_inputs: ActionInputs;\n  /** Action type parsed from action_type(action_inputs) */\n  action_type: string;\n  /** Thinking content */\n  thought?: string;\n}\n\n/**\n * Browser initialization options\n */\nexport interface GUIAgentOptions {\n  /** browser instance to use */\n  browser: LocalBrowser;\n  /** The logger instance to use */\n  logger: ConsoleLogger;\n  /** Whether to run browser in headless mode */\n  headless?: boolean;\n  /** Scaling factors for coordinates */\n  factors?: [number, number];\n  /** Event stream instance for injecting environment info */\n  eventStream?: AgentEventStream.Processor;\n}\n\n/**\n * Browser GUI Agent for visual browser automation\n */\nexport class BrowserGUIAgent {\n  private browser: LocalBrowser;\n  private browserOperator: BrowserOperator;\n  private screenWidth?: number;\n  private screenHeight?: number;\n  private browserGUIAgentTool: Tool;\n  private logger: ConsoleLogger;\n  private factors: [number, number];\n  private eventStream?: AgentEventStream.Processor;\n\n  /**\n   * Creates a new GUI Agent\n   * @param options - Configuration options\n   */\n  constructor(private options: GUIAgentOptions) {\n    this.logger = options.logger;\n    this.factors = options.factors || [1000, 1000];\n    this.eventStream = options.eventStream;\n\n    // Use provided browser instance\n    this.browser = this.options.browser;\n\n    // Initialize browser operator\n    this.browserOperator = new BrowserOperator({\n      browser: this.browser,\n      browserType: 'chrome',\n      logger: this.logger,\n      highlightClickableElements: false,\n      showActionInfo: false,\n      showWaterFlow: false,\n    });\n\n    // Create the tool definition\n    this.browserGUIAgentTool = new Tool({\n      id: 'browser_vision_control',\n      description: `A browser operation tool based on visual understanding, perform the next action to complete the task.\n\n## Action Space\n\nclick(point='<point>x1 y1</point>')            - Click at the specified coordinates\nleft_double(point='<point>x1 y1</point>')      - Double-click at the specified coordinates\nright_single(point='<point>x1 y1</point>')     - Right-click at the specified coordinates\ndrag(start_point='<point>x1 y1</point>', end_point='<point>x2 y2</point>') - Drag from start to end point\nhotkey(key='ctrl c')                           - Press keyboard shortcut (use space to separate keys, lowercase)\ntype(content='xxx')                            - Type text content (use \\\\', \\\\\", and \\\\n for special characters)\nscroll(point='<point>x1 y1</point>', direction='down or up or right or left') - Scroll in specified direction\nwait()                                         - Wait 5 seconds and take a screenshot to check for changes\n\n## Note\n- Folow user lanuage in in \\`thought\\` part.\n- Describe your thought in \\`step\\` part.\n- Describe your action in \\`Step\\` part.\n- Extract the data your see in \\`pageData\\` part.\n- This tool is for operational tasks, not for collect information.\n`,\n      parameters: z.object({\n        thought: z\n          .string()\n          .describe(\n            'Your observation and small plan in one sentence, DO NOT include \" characters to avoid failure to render in JSON',\n          ),\n        step: z\n          .string()\n          .describe('Finally summarize the next action (with its target element) in one sentence'),\n        action: z.string().describe('Some action in action space like click or press'),\n        // pageData: z\n        //   .array(z.object({}))\n        //   .describe(\"The information you see and extract from the page based on the user's query\")\n        //   .optional(),\n      }),\n      function: async ({ thought, step, action, pageData }) => {\n        try {\n          const parsed = this.parseAction(action);\n          parsed.thought = thought;\n\n          this.logger.debug({\n            thought,\n            step,\n            action,\n            parsedAction: JSON.stringify(parsed, null, 2),\n            screenDimensions: {\n              width: this.screenWidth,\n              height: this.screenHeight,\n            },\n          });\n\n          const result = await this.browserOperator.execute({\n            parsedPrediction: parsed,\n            screenWidth: this.screenWidth || 1920,\n            screenHeight: this.screenHeight || 1080,\n          });\n\n          await sleep(500);\n\n          // Automatically get page content after browser interaction\n          // await this.capturePageContentAsEnvironmentInfo();\n\n          return { action, status: 'success', result, pageData };\n        } catch (error) {\n          this.logger.error(\n            `Browser action failed: ${error instanceof Error ? error.message : String(error)}`,\n          );\n          return {\n            action,\n            status: 'fail',\n            error: error instanceof Error ? error.message : String(error),\n          };\n        }\n      },\n    });\n  }\n\n  /**\n   * Capture page content and add it to event stream as environment info\n   * This is called automatically after each browser_vision_control action\n   */\n  private async capturePageContentAsEnvironmentInfo(): Promise<void> {\n    // Only proceed if eventStream is provided\n    if (!this.eventStream) return;\n\n    try {\n      const page = await this.getPage();\n\n      // Get page content as markdown\n      const markdown = await page.evaluate(() => {\n        // Simple function to extract page content as markdown\n        const extractMarkdown = () => {\n          // Get page title\n          const title = document.title || 'Untitled Page';\n\n          // @ts-expect-error\n          // Get visible text content\n          const getVisibleText = (node) => {\n            if (node.nodeType === Node.TEXT_NODE) {\n              return node.textContent || '';\n            }\n\n            const style = window.getComputedStyle(node);\n            if (\n              style.display === 'none' ||\n              style.visibility === 'hidden' ||\n              style.opacity === '0'\n            ) {\n              return '';\n            }\n\n            let text = '';\n            for (const child of Array.from(node.childNodes)) {\n              // @ts-expect-error\n              if (child.nodeType === Node.ELEMENT_NODE) {\n                text += getVisibleText(child);\n                // @ts-expect-error\n              } else if (child.nodeType === Node.TEXT_NODE) {\n                // @ts-expect-error\n                text += child.textContent || '';\n              }\n            }\n\n            return text.trim();\n          };\n\n          // Get main content, prefer article or main elements\n          const mainContent =\n            document.querySelector('article, main, #content, .content') || document.body;\n          const content = getVisibleText(mainContent);\n\n          // Format as markdown\n          return `# ${title}\\n\\n${content}`;\n        };\n\n        return extractMarkdown();\n      });\n\n      // If content is available, add it to event stream\n      if (markdown && markdown.trim()) {\n        // Create an environment input event with the markdown content\n        const event = this.eventStream.createEvent('environment_input', {\n          content: markdown,\n          description: 'Page Content After Browser Action',\n        });\n\n        // Send the event\n        this.eventStream.sendEvent(event);\n        this.logger.debug('Added page content to event stream as environment info');\n      }\n    } catch (error) {\n      // Log error but don't fail the main operation\n      this.logger.warn(\n        `Failed to capture page content: ${error instanceof Error ? error.message : String(error)}`,\n      );\n    }\n  }\n\n  /**\n   * Set the event stream instance\n   * @param eventStream - The event stream instance\n   */\n  public setEventStream(eventStream: AgentEventStream.Processor): void {\n    this.eventStream = eventStream;\n  }\n\n  /**\n   * Get the tool definition for GUI Agent browser control\n   */\n  getTool(): Tool {\n    return this.browserGUIAgentTool;\n  }\n\n  /**\n   * Hook for starting each agent loop\n   * - Takes a screenshot\n   * - Extracts image dimensions\n   * - Sends the screenshot to the event stream\n   */\n  async onEachAgentLoopStart(\n    eventStream: AgentEventStream.Processor,\n    isReplaySnapshot = false,\n  ): Promise<void> {\n    console.log('Agent Loop Start');\n\n    // Store the event stream for later use\n    this.eventStream = eventStream;\n\n    // Early return for replay snapshots\n    if (isReplaySnapshot) {\n      // Send screenshot to event stream as environment input\n      const event = eventStream.createEvent('environment_input', {\n        content: [\n          {\n            type: 'image_url',\n            image_url: {\n              url: 'data:image/jpeg;base64,/9j/4AAQSk',\n            },\n          },\n        ],\n        description: 'Browser Screenshot',\n      });\n\n      return eventStream.sendEvent(event);\n    }\n\n    try {\n      // Check if browser is launched before attempting screenshot\n      if (!(await this.browser.isBrowserAlive())) {\n        this.logger.info('Browser not launched yet, skipping screenshot');\n        return;\n      }\n\n      // Record screenshot start time\n      const startTime = performance.now();\n\n      const output = await this.browserOperator.screenshot();\n\n      // Calculate screenshot time\n      const endTime = performance.now();\n      const screenshotTime = (endTime - startTime).toFixed(2);\n\n      // Extract image dimensions from screenshot\n      this.extractImageDimensionsFromBase64(output.base64);\n\n      // Calculate original image size\n      const originalBase64Data = output.base64.replace(/^data:image\\/\\w+;base64,/, '');\n      const originalBuffer = Buffer.from(originalBase64Data, 'base64');\n      const originalSize = originalBuffer.length;\n\n      // Compress the image\n      const imageCompressor = new ImageCompressor({\n        quality: 80,\n        format: 'webp',\n      });\n\n      const compressedBuffer = await imageCompressor.compressToBuffer(originalBuffer);\n      const compressedSize = compressedBuffer.length;\n\n      // Convert compressed buffer to base64\n      const compressedBase64 = `data:image/webp;base64,${compressedBuffer.toString('base64')}`;\n\n      // Calculate compression ratio and percentage\n      const compressionRatio = originalSize / compressedSize;\n      const compressionPercentage = ((1 - compressedSize / originalSize) * 100).toFixed(2);\n\n      // Log compression stats\n      this.logger.info('Screenshot compression stats:', {\n        original: formatBytes(originalSize),\n        compressed: formatBytes(compressedSize),\n        ratio: `${compressionRatio.toFixed(2)}x (${compressionPercentage}% smaller)`,\n        dimensions: `${this.screenWidth}x${this.screenHeight}`,\n        format: 'webp',\n        quality: 20,\n        time: `${screenshotTime} ms`,\n      });\n\n      // Calculate image size\n      const sizeInKB = (compressedSize / 1024).toFixed(2);\n\n      // FIXME: using logger\n      console.log('Screenshot info:', {\n        width: this.screenWidth,\n        height: this.screenHeight,\n        size: `${sizeInKB} KB`,\n        time: `${screenshotTime} ms`,\n        compression: `${\n          originalSize / 1024 > 1024\n            ? (originalSize / 1024 / 1024).toFixed(2) + ' MB'\n            : (originalSize / 1024).toFixed(2) + ' KB'\n        } â†’ ${formatBytes(compressedSize)} (${compressionPercentage}% reduction)`,\n      });\n\n      // Send screenshot to event stream as environment input\n      const event = eventStream.createEvent('environment_input', {\n        content: [\n          {\n            type: 'image_url',\n            image_url: {\n              url: compressedBase64,\n            },\n          },\n        ],\n        description: 'Browser Screenshot',\n      });\n\n      eventStream.sendEvent(event);\n\n      // Also capture page content on loop start\n      // await this.capturePageContentAsEnvironmentInfo();\n    } catch (error) {\n      this.logger.error(`Failed to take screenshot: ${error}`);\n\n      // Don't throw the error to prevent loop interruption\n    }\n  }\n\n  /**\n   * Add data URI prefix to base64 image if not present\n   */\n  private addBase64ImagePrefix(base64: string): string {\n    if (!base64) return '';\n    return base64.startsWith('data:') ? base64 : `data:image/jpeg;base64,${base64}`;\n  }\n\n  /**\n   * Parse operation string into a structured operation object\n   */\n  private parseAction(actionString: string): PredictionParsed {\n    // Extract operation type and parameter string\n    const actionTypeMatch = actionString.match(/^(\\w+)\\(/);\n    const action_type = actionTypeMatch ? actionTypeMatch[1] : '';\n\n    const action_inputs: ActionInputs = {};\n\n    // Handle coordinate points\n    const pointMatch = actionString.match(/point='<point>([\\d\\s]+)<\\/point>'/);\n    if (pointMatch) {\n      const [x, y] = pointMatch[1].split(' ').map(Number);\n      action_inputs.start_box = `[${x / this.factors[0]},${y / this.factors[1]}]`;\n    }\n\n    // Handle start and end coordinates (for drag operations)\n    const startPointMatch = actionString.match(/start_point='<point>([\\d\\s]+)<\\/point>'/);\n    if (startPointMatch) {\n      const [x, y] = startPointMatch[1].split(' ').map(Number);\n      action_inputs.start_box = `[${x / this.factors[0]},${y / this.factors[1]}]`;\n    }\n\n    const endPointMatch = actionString.match(/end_point='<point>([\\d\\s]+)<\\/point>'/);\n    if (endPointMatch) {\n      const [x, y] = endPointMatch[1].split(' ').map(Number);\n      action_inputs.end_box = `[${x / this.factors[0]},${y / this.factors[1]}]`;\n    }\n\n    // Handle content parameter (for type and finished operations)\n    const contentMatch = actionString.match(/content='([^']*(?:\\\\.[^']*)*)'/);\n    if (contentMatch) {\n      // Process escape characters\n      action_inputs.content = contentMatch[1]\n        .replace(/\\\\n/g, '\\n')\n        .replace(/\\\\'/g, \"'\")\n        .replace(/\\\\\"/g, '\"');\n    }\n\n    // Handle keys and hotkeys\n    const keyMatch = actionString.match(/key='([^']*)'/);\n    if (keyMatch) {\n      action_inputs.key = keyMatch[1];\n    }\n\n    // Handle scroll direction\n    const directionMatch = actionString.match(/direction='([^']*)'/);\n    if (directionMatch) {\n      action_inputs.direction = directionMatch[1];\n    }\n\n    return {\n      action_type,\n      action_inputs,\n    };\n  }\n\n  /**\n   * Extract width and height information from base64 encoded image\n   */\n  private extractImageDimensionsFromBase64(base64String: string): void {\n    // Remove base64 prefix (if any)\n    const base64Data = base64String.replace(/^data:image\\/\\w+;base64,/, '');\n\n    // Decode base64 to binary data\n    const buffer = Buffer.from(base64Data, 'base64');\n\n    // Check image type and extract dimensions\n    if (buffer[0] === 0x89 && buffer[1] === 0x50 && buffer[2] === 0x4e && buffer[3] === 0x47) {\n      // PNG format: width in bytes 16-19, height in bytes 20-23\n      this.screenWidth = buffer.readUInt32BE(16);\n      this.screenHeight = buffer.readUInt32BE(20);\n    } else if (buffer[0] === 0xff && buffer[1] === 0xd8) {\n      // JPEG format: need to parse SOF0 marker (0xFFC0)\n      let offset = 2;\n      while (offset < buffer.length) {\n        if (buffer[offset] !== 0xff) break;\n\n        const marker = buffer[offset + 1];\n        const segmentLength = buffer.readUInt16BE(offset + 2);\n\n        // SOF0, SOF2 markers contain dimension information\n        if ((marker >= 0xc0 && marker <= 0xc3) || (marker >= 0xc5 && marker <= 0xc7)) {\n          this.screenHeight = buffer.readUInt16BE(offset + 5);\n          this.screenWidth = buffer.readUInt16BE(offset + 7);\n          break;\n        }\n\n        offset += 2 + segmentLength;\n      }\n    }\n\n    // Ensure dimensions were extracted\n    if (!this.screenWidth || !this.screenHeight) {\n      this.logger.warn('Unable to extract dimension information from image data');\n    }\n  }\n\n  /**\n   * Get access to the underlying Puppeteer page\n   * This allows custom browser tools to be implemented\n   * without relying on the MCP Browser server\n   */\n  async getPage(): Promise<Page> {\n    if (!this.browser) {\n      throw new Error('Browser not initialized');\n    }\n\n    // Get active page or create a new one\n    try {\n      return await this.browser.getActivePage();\n    } catch (error) {\n      this.logger.warn('Failed to get active page, creating new page:', error);\n      return await this.browser.createPage();\n    }\n  }\n}\n"],"names":["__webpack_require__","definition","key","Object","obj","prop","Symbol","sleep","time","Promise","resolve","setTimeout","BrowserGUIAgent","page","markdown","extractMarkdown","title","document","getVisibleText","node","Node","style","window","text","child","Array","mainContent","content","event","error","Error","String","eventStream","isReplaySnapshot","console","startTime","performance","output","endTime","screenshotTime","originalBase64Data","originalBuffer","Buffer","originalSize","imageCompressor","ImageCompressor","compressedBuffer","compressedSize","compressedBase64","compressionRatio","compressionPercentage","formatBytes","sizeInKB","base64","actionString","actionTypeMatch","action_type","action_inputs","pointMatch","x","y","Number","startPointMatch","endPointMatch","contentMatch","keyMatch","directionMatch","base64String","base64Data","buffer","offset","marker","segmentLength","options","BrowserOperator","Tool","z","thought","step","action","pageData","parsed","JSON","result"],"mappings":"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"}