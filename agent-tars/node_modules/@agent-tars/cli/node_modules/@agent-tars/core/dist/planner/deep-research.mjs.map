{"version":3,"file":"planner/deep-research.mjs","sources":["webpack://@agent-tars/core/./src/planner/deep-research.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/*\n * Copyright (c) 2025 Bytedance, Inc. and its affiliates.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  ConsoleLogger,\n  AgentEventStream,\n  ChatCompletionContentPart,\n  ResolvedModel,\n  OpenAI,\n  uuidv4,\n} from '@mcp-agent/core';\nimport fs from 'fs';\n\n/**\n * Options for generating a research report\n */\ninterface ReportGenerationOptions {\n  title: string;\n  format?: 'detailed' | 'concise';\n}\n\n/**\n * DeepResearchGenerator - Handles the generation of detailed research reports\n *\n * This class implements a streamlined workflow for creating comprehensive\n * research reports from event stream data, using a multi-stage approach:\n * 1. Analyze and extract relevant information from the event stream\n * 2. Organize content into logical sections\n * 3. Generate detailed section content with streaming support\n * 4. Assemble and stream the final report in real-time\n */\nexport class DeepResearchGenerator {\n  constructor(\n    private logger: ConsoleLogger,\n    private eventStream: AgentEventStream.Processor,\n  ) {\n    this.logger = logger.spawn('DeepResearchGenerator');\n  }\n\n  /**\n   * Generate a comprehensive research report\n   *\n   * @param llmClient - The LLM client to use for report generation\n   * @param resolvedModel - The resolved model configuration\n   * @param eventStream - The event stream to extract data from and send events to\n   * @param options - Report generation options\n   * @param abortSignal - Optional signal to abort LLM requests\n   * @returns Success message\n   */\n  async generateReport(\n    llmClient: OpenAI,\n    resolvedModel: ResolvedModel,\n    eventStream: AgentEventStream.Processor,\n    options: ReportGenerationOptions,\n    abortSignal?: AbortSignal,\n  ): Promise<any> {\n    try {\n      this.logger.info(`Generating research report: ${options.title}`);\n\n      // Check if already aborted\n      if (abortSignal?.aborted) {\n        this.logger.info('Report generation aborted before starting');\n        throw new Error('Report generation aborted');\n      }\n\n      // Create a unique message ID for tracking streaming events\n      const messageId = `research-report-${uuidv4()}`;\n\n      // Step 1: Extract relevant information from the event stream\n      const relevantData = this.extractRelevantData(eventStream);\n\n      // Check if there's enough information to generate a report\n      if (!this.hasEnoughInformationForReport(relevantData)) {\n        this.logger.warn('Insufficient information to generate a detailed report');\n\n        // Create a simple answer instead of a full report\n        const simpleAnswerEvent = eventStream.createEvent('final_answer', {\n          content:\n            \"I don't have enough information to generate a detailed report on this topic. Please provide more context or try a different query.\",\n          isDeepResearch: false,\n          title: options.title,\n          messageId,\n        });\n\n        eventStream.sendEvent(simpleAnswerEvent);\n\n        return {\n          success: false,\n          message: 'Insufficient information for report generation',\n        };\n      }\n\n      // Step 2: Generate report structure\n      const reportStructure = await this.generateReportStructure(\n        llmClient,\n        resolvedModel,\n        relevantData,\n        options,\n        abortSignal,\n      );\n      console.log('reportStructure', reportStructure);\n\n      // Step 3: Generate and stream the report\n      await this.generateAndStreamReport(\n        llmClient,\n        resolvedModel,\n        relevantData,\n        reportStructure,\n        messageId,\n        options,\n        abortSignal,\n      );\n\n      // Step 4: Send final complete event\n      const finalEvent = eventStream.createEvent('final_answer', {\n        content: reportStructure.fullContent || 'Research report generated successfully.',\n        isDeepResearch: true,\n        title: options.title,\n        format: options.format,\n        messageId,\n      });\n\n      eventStream.sendEvent(finalEvent);\n\n      return {\n        success: true,\n        message: 'Research report generated successfully',\n      };\n    } catch (error) {\n      this.logger.error(`Failed to generate research report: ${error}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Check if there's enough information to generate a meaningful report\n   */\n  private hasEnoughInformationForReport(relevantData: any): boolean {\n    // Check for substantial content\n    const hasSubstantialContent =\n      (relevantData.browserContent && relevantData.browserContent.length > 0) ||\n      (relevantData.searchResults && relevantData.searchResults.length > 0) ||\n      (relevantData.environmentImages && relevantData.environmentImages.length > 0) ||\n      (relevantData.environmentTexts &&\n        relevantData.environmentTexts.some((text: string) => text && text.length > 200));\n\n    this.logger.debug(\n      `Information check: ${hasSubstantialContent ? 'Sufficient' : 'Insufficient'} data for report`,\n    );\n\n    return hasSubstantialContent;\n  }\n\n  /**\n   * Extract relevant data from the event stream\n   * Enhanced to handle multimodal content including images and text from environment inputs\n   */\n  private extractRelevantData(eventStream: AgentEventStream.Processor): any {\n    // Extract user messages, tool results, and other relevant information\n    const events = eventStream.getEvents();\n\n    // Process and extract information from each event type\n    const userMessages = events.filter((e) => e.type === 'user_message');\n    const toolResults = events.filter((e) => e.type === 'tool_result');\n    const assistantMessages = events.filter((e) => e.type === 'assistant_message');\n    const environmentInputs = events.filter((e) => e.type === 'environment_input');\n\n    // Get original user query (first user message) for consistent reference\n    const originalQuery = userMessages.length > 0 ? userMessages[0].content : '';\n\n    // Group tool results by tool name for better organization\n    const toolResultsByName: Record<string, any[]> = {};\n    toolResults.forEach((result) => {\n      const toolName = result.name || 'unknown';\n      if (!toolResultsByName[toolName]) {\n        toolResultsByName[toolName] = [];\n      }\n      toolResultsByName[toolName].push(result);\n    });\n\n    // Extract browser content specifically (often contains the most relevant information)\n    const browserContent = toolResults\n      .filter((result) => result.name?.includes('browser_get_markdown'))\n      .map((result) => result.content)\n      .filter(Boolean);\n\n    // Extract search results specifically\n    const searchResults = toolResults\n      .filter((result) => result.name?.includes('search'))\n      .map((result) => result.content)\n      .filter(Boolean);\n\n    // Extract environment inputs (images and text)\n    const environmentImages: any[] = [];\n    const environmentTexts: string[] = [];\n\n    environmentInputs.forEach((input) => {\n      if (Array.isArray(input.content)) {\n        // Handle multimodal content arrays\n        input.content.forEach((contentPart: any) => {\n          if (contentPart.type === 'image_url' && contentPart.image_url?.url) {\n            environmentImages.push(contentPart);\n          } else if (contentPart.type === 'text' && contentPart.text) {\n            environmentTexts.push(contentPart.text);\n          }\n        });\n      } else if (typeof input.content === 'string') {\n        // Handle pure text content\n        environmentTexts.push(input.content);\n      }\n    });\n\n    this.logger.info(\n      `Extracted ${environmentImages.length} images and ${environmentTexts.length} text blocks from environment inputs`,\n    );\n\n    return {\n      userMessages,\n      toolResults,\n      assistantMessages,\n      environmentInputs,\n      environmentImages,\n      environmentTexts,\n      originalQuery,\n      toolResultsByName,\n      browserContent,\n      searchResults,\n      allEvents: events,\n    };\n  }\n\n  /**\n   * Generate the structure for the research report\n   * Updated to support multimodal content\n   */\n  private async generateReportStructure(\n    llmClient: OpenAI,\n    resolvedModel: ResolvedModel,\n    relevantData: any,\n    options: ReportGenerationOptions,\n    abortSignal?: AbortSignal,\n  ): Promise<any> {\n    try {\n      this.logger.info('Generating report structure');\n\n      // Check if already aborted\n      if (abortSignal?.aborted) {\n        this.logger.info('Report structure generation aborted');\n        throw new Error('Report structure generation aborted');\n      }\n\n      // Create multimodal prompt content with relevant data\n      const structurePromptContent = this.createStructurePromptContent(relevantData, options);\n\n      // Request structure from LLM using multimodal format\n      const response = await llmClient.chat.completions.create(\n        {\n          model: resolvedModel.id,\n          response_format: { type: 'json_object' },\n          messages: [\n            {\n              role: 'system',\n              content:\n                \"You are an expert research report organizer. Based on the information provided, create a logical structure for a comprehensive research report. Follow EXACTLY what the user is asking for - do not invent topics that aren't covered in the data provided.\",\n            },\n            {\n              role: 'user',\n              content: structurePromptContent,\n            },\n          ],\n        },\n        { signal: abortSignal },\n      );\n\n      // Parse the response\n      const structureContent = response.choices[0]?.message?.content || '{}';\n      const reportStructure = JSON.parse(structureContent);\n\n      this.logger.info(\n        `Generated report structure with ${reportStructure.sections?.length || 0} sections`,\n      );\n\n      return reportStructure;\n    } catch (error) {\n      this.logger.error(`Error generating report structure: ${error}`);\n      // Return a default structure\n      return {\n        title: options.title,\n        sections: ['Introduction', 'Key Findings', 'Conclusion'],\n        fullContent: '',\n      };\n    }\n  }\n\n  /**\n   * Create multimodal content array for report structure prompt\n   */\n  private createStructurePromptContent(\n    relevantData: any,\n    options: ReportGenerationOptions,\n  ): ChatCompletionContentPart[] {\n    const promptContent: ChatCompletionContentPart[] = [];\n\n    // Add text instructions\n    promptContent.push({\n      type: 'text',\n      text: this.createStructurePromptText(relevantData, options),\n    });\n\n    // Add a limited number of images if available (to avoid token limits)\n    if (relevantData.environmentImages && relevantData.environmentImages.length > 0) {\n      // Add up to 3 images for context\n      const imagesToInclude = relevantData.environmentImages.slice(0, 3);\n\n      this.logger.debug(`Including ${imagesToInclude.length} images in structure prompt`);\n\n      for (const image of imagesToInclude) {\n        promptContent.push({\n          type: 'image_url',\n          image_url: {\n            url: image.image_url.url,\n          },\n        });\n      }\n    }\n\n    return promptContent;\n  }\n\n  /**\n   * Create text portion of the structure prompt\n   */\n  private createStructurePromptText(relevantData: any, options: ReportGenerationOptions): string {\n    // Extract key information from relevant data\n    const userQuery = relevantData.originalQuery || 'Research request';\n\n    // Count tool results by type\n    const toolCounts: Record<string, number> = {};\n    relevantData.toolResults.forEach((result: any) => {\n      const toolName = result.name || 'unknown';\n      toolCounts[toolName] = (toolCounts[toolName] || 0) + 1;\n    });\n\n    // Format tool usage summary\n    const toolSummary = Object.entries(toolCounts)\n      .map(([tool, count]) => `${tool}: ${count} times`)\n      .join('\\n');\n\n    // Add sample data from key sources to help with structure\n    let dataPreview = '';\n\n    // Add browser content samples\n    if (relevantData.browserContent && relevantData.browserContent.length > 0) {\n      const samples = relevantData.browserContent.slice(0, 3).map((content: any) => {\n        if (typeof content === 'string') {\n          return content.substring(0, 300) + (content.length > 300 ? '...' : '');\n        } else {\n          return JSON.stringify(content).substring(0, 300) + '...';\n        }\n      });\n      dataPreview += `\\nWebpage content samples:\\n${samples.join('\\n\\n')}\\n`;\n    }\n\n    // Add search result samples\n    if (relevantData.searchResults && relevantData.searchResults.length > 0) {\n      dataPreview += `\\nSearch result samples:\\n`;\n      let searchSample = '';\n      try {\n        const firstSearchResult = relevantData.searchResults[0];\n        if (Array.isArray(firstSearchResult)) {\n          searchSample = firstSearchResult\n            .slice(0, 3)\n            .map(\n              (item: any) =>\n                `- ${item.title || 'Untitled'}: ${(item.snippet || '').substring(0, 100)}...`,\n            )\n            .join('\\n');\n        } else if (typeof firstSearchResult === 'object') {\n          searchSample = JSON.stringify(firstSearchResult).substring(0, 300) + '...';\n        } else {\n          searchSample = String(firstSearchResult).substring(0, 300) + '...';\n        }\n      } catch (e) {\n        searchSample = 'Error parsing search results';\n      }\n      dataPreview += searchSample + '\\n';\n    }\n\n    // Add environment text content\n    if (relevantData.environmentTexts && relevantData.environmentTexts.length > 0) {\n      dataPreview += `\\nEnvironment content samples:\\n`;\n      const textSamples = relevantData.environmentTexts\n        .slice(0, 3)\n        .map((text: string) => text.substring(0, 300) + (text.length > 300 ? '...' : ''))\n        .join('\\n\\n');\n      dataPreview += textSamples + '\\n';\n    }\n\n    // Add reference to images if present\n    if (relevantData.environmentImages && relevantData.environmentImages.length > 0) {\n      dataPreview += `\\nAdditional context: ${relevantData.environmentImages.length} screenshot images have been included for visual reference.\\n`;\n    }\n\n    return `\n    I need to create a factual research report with the title: \"${options.title}\" that STRICTLY answers the original request.\n    \n    The original research request was:\n    \"${userQuery}\"\n    \n    During my research, I used these tools:\n    ${toolSummary}\n    \n    Here are samples of the data I've collected:\n    ${dataPreview}\n    \n    Please create a structured outline for a ${options.format || 'detailed'} research report that:\n    1. DIRECTLY addresses the original request\n    2. ONLY includes sections that can be supported by the collected data\n    3. Does NOT include sections for which we lack sufficient information\n    4. Follows a logical flow from introduction to conclusion\n    5. Considers both textual content AND any screenshots/images provided\n    \n    Return a JSON object with:\n    1. \"title\": The report title (based on the original request)\n    2. \"sections\": An array of section names that would create a comprehensive research report\n    \n    IMPORTANT: The sections should ONLY cover topics for which we have actual data. DO NOT include sections that would require inventing information.\n    `;\n  }\n\n  /**\n   * Generate and stream the research report section by section\n   * Modified to support real-time streaming of content\n   */\n  private async generateAndStreamReport(\n    llmClient: OpenAI,\n    resolvedModel: ResolvedModel,\n    relevantData: any,\n    reportStructure: any,\n    messageId: string,\n    options: ReportGenerationOptions,\n    abortSignal?: AbortSignal,\n  ): Promise<void> {\n    this.logger.info('Generating and streaming report');\n\n    // Check if already aborted\n    if (abortSignal?.aborted) {\n      this.logger.info('Report streaming aborted before starting');\n      throw new Error('Report streaming aborted');\n    }\n\n    let fullReport = `# ${reportStructure.title || options.title}\\n\\n`;\n\n    // Add original user query as a reference point\n    if (relevantData.originalQuery) {\n      const querySection = `> Original question: ${relevantData.originalQuery}\\n\\n`;\n      fullReport += querySection;\n      this.streamReportChunk(querySection, messageId, false);\n    }\n\n    // Generate table of contents\n    const toc = this.generateTableOfContents(reportStructure.sections);\n    fullReport += toc;\n    this.streamReportChunk(toc, messageId, false);\n\n    // Generate each section with streaming\n    for (const section of reportStructure.sections) {\n      const sectionTitle = `\\n\\n## ${section}\\n\\n`;\n      fullReport += sectionTitle;\n      this.streamReportChunk(sectionTitle, messageId, false);\n\n      // Stream generate section content\n      const sectionContent = await this.streamSectionContent(\n        llmClient,\n        resolvedModel,\n        section,\n        relevantData,\n        options,\n        messageId,\n        fullReport,\n        abortSignal,\n      );\n\n      // 将章节内容添加到完整报告中\n      fullReport += sectionContent;\n\n      // Add section separator\n      const separator = '\\n\\n';\n      fullReport += separator;\n      this.streamReportChunk(separator, messageId, false);\n    }\n\n    // Store the full content in the report structure\n    reportStructure.fullContent = fullReport;\n  }\n\n  /**\n   * Stream section content using LLM streaming capabilities\n   * Enhanced to support multimodal content\n   */\n  private async streamSectionContent(\n    llmClient: OpenAI,\n    resolvedModel: ResolvedModel,\n    sectionTitle: string,\n    relevantData: any,\n    options: ReportGenerationOptions,\n    messageId: string,\n    fullReport: string,\n    abortSignal?: AbortSignal,\n  ): Promise<string | undefined> {\n    try {\n      this.logger.info(`Streaming section content: ${sectionTitle}`);\n\n      // Prepare section-specific multimodal prompt\n      const sectionPromptContent = this.createSectionPromptContent(\n        sectionTitle,\n        relevantData,\n        options,\n      );\n\n      fs.writeFileSync(\n        `${sectionPromptContent}-${Date.now()}.json`,\n        JSON.stringify(sectionPromptContent, null, 2),\n        'utf-8',\n      );\n\n      // Create streaming request\n      const stream = await llmClient.chat.completions.create(\n        {\n          model: resolvedModel.id,\n          stream: true, // Enable streaming\n          messages: [\n            {\n              role: 'system',\n              content: `You are an expert research analyst. Generate detailed content for the \"${sectionTitle}\" section of a research report. IMPORTANT: Only include information that is directly supported by the provided data - do NOT invent facts, statistics, or examples. If there is insufficient data for a comprehensive section, acknowledge the limitations and focus on what is available.`,\n            },\n            {\n              role: 'user',\n              content: sectionPromptContent,\n            },\n          ],\n        },\n        { signal: abortSignal },\n      );\n\n      // 创建一个变量来收集完整的章节内容\n      let sectionContent = '';\n\n      // Process the stream chunks in real-time\n      for await (const chunk of stream) {\n        const content = chunk.choices[0]?.delta?.content || '';\n        if (content) {\n          // 累加到章节内容\n          sectionContent += content;\n          // 发送每个块到客户端\n          this.streamReportChunk(content, messageId, false);\n        }\n      }\n\n      return sectionContent;\n    } catch (error) {\n      this.logger.error(`Error streaming section ${sectionTitle}: ${error}`);\n      // Send error message as fallback\n      const errorMessage = `\\n\\n*Error generating content for ${sectionTitle}: ${error}*\\n\\n`;\n      this.streamReportChunk(errorMessage, messageId, false);\n    }\n  }\n\n  /**\n   * Create multimodal content array for section-specific prompts\n   * Includes relevant images and text content for the specific section\n   */\n  private createSectionPromptContent(\n    sectionTitle: string,\n    relevantData: any,\n    options: ReportGenerationOptions,\n  ): ChatCompletionContentPart[] {\n    const promptContent: ChatCompletionContentPart[] = [];\n\n    // Add primary text instructions\n    promptContent.push({\n      type: 'text',\n      text: this.createSectionPromptText(sectionTitle, relevantData, options),\n    });\n\n    // Include images if available\n    if (relevantData.environmentImages && relevantData.environmentImages.length > 0) {\n      // Add up to 2 images for context (to avoid token limits)\n      const imagesToInclude = relevantData.environmentImages.slice(0, 2);\n\n      for (const image of imagesToInclude) {\n        promptContent.push({\n          type: 'image_url',\n          image_url: {\n            url: image.image_url.url,\n          },\n        });\n      }\n\n      this.logger.debug(\n        `Including ${imagesToInclude.length} images in \"${sectionTitle}\" section prompt`,\n      );\n    }\n\n    return promptContent;\n  }\n\n  /**\n   * Stream a chunk of the report to the event stream\n   */\n  private streamReportChunk(content: string, messageId: string, isComplete: boolean): void {\n    const streamingEvent = this.eventStream.createEvent('final_answer_streaming', {\n      content,\n      isDeepResearch: true,\n      isComplete,\n      messageId,\n    });\n\n    this.eventStream.sendEvent(streamingEvent);\n  }\n\n  /**\n   * Generate the table of contents for the report\n   */\n  private generateTableOfContents(sections: string[]): string {\n    let toc = '## Table of Contents\\n\\n';\n\n    sections.forEach((section, index) => {\n      toc += `${index + 1}. [${section}](#${section.toLowerCase().replace(/\\s+/g, '-')})\\n`;\n    });\n\n    toc += '\\n\\n';\n    return toc;\n  }\n\n  /**\n   * Create text for section-specific prompts\n   */\n  private createSectionPromptText(\n    sectionTitle: string,\n    relevantData: any,\n    options: ReportGenerationOptions,\n  ): string {\n    // Get the original user query to maintain focus\n    const originalQuery = relevantData.originalQuery || 'Research request';\n\n    // Extract relevant tool results without section-specific keyword matching\n    const relevantTools = relevantData.toolResults;\n\n    // Format tool results as context\n    const toolContext = relevantTools\n      .map((tool: any) => {\n        let content = '';\n        try {\n          content = typeof tool.content === 'string' ? tool.content : JSON.stringify(tool.content);\n        } catch (e) {\n          content = 'Error formatting content';\n        }\n\n        return `Tool: ${tool.name || 'unknown'}\\nContent: ${content.substring(0, 800)}${\n          content.length > 800 ? '...' : ''\n        }`;\n      })\n      .join('\\n\\n');\n\n    // Include environment text content\n    let environmentContext = '';\n    if (relevantData.environmentTexts && relevantData.environmentTexts.length > 0) {\n      const textSamples = relevantData.environmentTexts\n        .slice(0, 2)\n        .map((text: string) => text.substring(0, 800) + (text.length > 800 ? '...' : ''))\n        .join('\\n\\n');\n      environmentContext = `\\nEnvironment Content:\\n${textSamples}\\n`;\n    }\n\n    // Add image reference if images are included\n    const imageReference =\n      relevantData.environmentImages && relevantData.environmentImages.length > 0\n        ? \"\\n\\nNOTE: Screenshots have been provided. Analyze any visual information that's relevant to this section.\"\n        : '';\n\n    return `\n    I'm writing a research report titled \"${options.title}\" based on the original request: \"${originalQuery}\"\n    \n    I need to generate content for the \"${sectionTitle}\" section of the report.\n    \n    Here is the relevant information from my research that specifically relates to this section:\n    ${toolContext || 'Limited data available for this section.'}\n    ${environmentContext}\n    ${imageReference}\n    \n    STRICT GUIDELINES:\n    1. ONLY use information from the provided data - DO NOT invent facts, statistics, examples, or quotes\n    2. If the data is insufficient, acknowledge the limitations and focus only on what is available\n    3. Make sure all content directly addresses the original request\n    4. Use proper Markdown formatting with headings, paragraphs, and lists as appropriate\n    5. Write in a professional, analytical tone\n    6. If there is insufficient data for this section, keep it brief and acknowledge the limitations\n    7. Reference visual information from screenshots when relevant to this section\n    \n    Write the content for the \"${sectionTitle}\" section now, ensuring EVERYTHING is supported by the provided data.\n    `;\n  }\n}\n"],"names":["DeepResearchGenerator","llmClient","resolvedModel","eventStream","options","abortSignal","Error","messageId","uuidv4","relevantData","simpleAnswerEvent","reportStructure","console","finalEvent","error","hasSubstantialContent","text","events","userMessages","e","toolResults","assistantMessages","environmentInputs","originalQuery","toolResultsByName","result","toolName","browserContent","_result_name","Boolean","searchResults","environmentImages","environmentTexts","input","Array","contentPart","_contentPart_image_url","_response_choices__message","_reportStructure_sections","structurePromptContent","response","structureContent","JSON","promptContent","imagesToInclude","image","userQuery","toolCounts","toolSummary","Object","tool","count","dataPreview","samples","content","searchSample","firstSearchResult","item","String","textSamples","fullReport","querySection","toc","section","sectionTitle","sectionContent","separator","sectionPromptContent","fs","Date","stream","chunk","_chunk_choices__delta","errorMessage","isComplete","streamingEvent","sections","index","relevantTools","toolContext","environmentContext","imageReference","logger"],"mappings":"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"}