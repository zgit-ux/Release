import { AgentEventStream, MCPAgent, LLMRequestHookPayload, LLMResponseHookPayload, ConsoleLogger, LoopTerminationCheckResult } from '@mcp-agent/core';
import { AgentTARSOptions } from './types';
import { BrowserManager } from './browser';
/**
 * A Agent TARS that uses in-memory MCP tool call
 * for built-in MCP Servers.
 */
export declare class AgentTARS<T extends AgentTARSOptions = AgentTARSOptions> extends MCPAgent<T> {
    private workingDirectory;
    private tarsOptions;
    private mcpServers;
    private inMemoryMCPClients;
    private browserGUIAgent?;
    private browserManager;
    private planManager?;
    private currentIteration;
    private browserToolsManager?;
    private searchToolProvider?;
    private browserState;
    private traces;
    constructor(options: T);
    /**
     * Initialize in-memory MCP modules and register tools
     */
    initialize(): Promise<void>;
    /**
     * Initialize search tools using direct integration with agent-infra/search
     */
    private initializeSearchTools;
    /**
     * Log all registered tools in a beautiful format
     */
    private logRegisteredTools;
    /**
     * Initialize GUI Agent for visual browser control
     */
    private initializeGUIAgent;
    /**
     * Initialize in-memory mcp for built-in mcp servers using the new architecture
     * with direct server creation and configuration
     */
    private initializeInMemoryMCPForBuiltInMCPServers;
    /**
     * Register tools from a specific MCP client
     */
    private registerToolsFromClient;
    /**
     * Lazy browser initialization using on-demand pattern
     *
     * This hook intercepts tool calls and lazily initializes the browser only when
     * it's first needed by a browser-related tool.
     */
    onBeforeToolCall(id: string, toolCall: {
        toolCallId: string;
        name: string;
    }, args: any): Promise<any>;
    /**
     * Override the onEachAgentLoopStart method to handle GUI Agent initialization
     * and planner lifecycle
     * This is called at the start of each agent iteration
     */
    onEachAgentLoopStart(sessionId: string): Promise<void>;
    /**
     * Override onBeforeLoopTermination to ensure "final_answer" is called if planner is enabled
     */
    onBeforeLoopTermination(id: string, finalEvent: AgentEventStream.AssistantMessageEvent): Promise<LoopTerminationCheckResult>;
    /**
     * Override onAgentLoopEnd to reset planner state
     */
    onAgentLoopEnd(id: string): Promise<void>;
    /**
     * Get messages from event stream formatted for planning purposes
     *
     * FIXME: better memory control
     */
    private getMessagesForPlanning;
    /**
     * Get information about the current browser control setup
     * @returns Object containing mode and registered tools
     */
    getBrowserControlInfo(): {
        mode: string;
        tools: string[];
    };
    /**
     * Clean up resources when done
     */
    cleanup(): Promise<void>;
    /**
     * Get the current working directory for filesystem operations
     */
    getWorkingDirectory(): string;
    /**
     * Get the logger instance used by this agent
     */
    getLogger(): ConsoleLogger;
    /**
     * Override onLLMRequest hook to capture requests for message history dump
     */
    onLLMRequest(id: string, payload: LLMRequestHookPayload): void;
    /**
     * Override onLLMResponse hook to capture responses for message history dump
     */
    onLLMResponse(id: string, payload: LLMResponseHookPayload): void;
    /**
     * Get the current abort signal if available
     * This allows other components to hook into the abort mechanism
     */
    getAbortSignal(): AbortSignal | undefined;
    /**
     * Get the browser manager instance
     * This allows external components to access browser functionality
     */
    getBrowserManager(): BrowserManager | undefined;
    /**
     * Save message history to file
     * This is an experimental feature that dumps all LLM requests and responses
     * to a JSON file in the working directory.
     *
     * The file will be named using the session ID to ensure all communications
     * within the same session are stored in a single file.
     *
     * @param sessionId The session ID to use for the filename
     */
    private dumpMessageHistory;
    /**
     * Override onAfterToolCall to update browser state after tool calls
     * This ensures we have the latest URL and screenshot after each browser operation
     */
    onAfterToolCall(id: string, toolCall: {
        toolCallId: string;
        name: string;
    }, result: any): Promise<any>;
}
//# sourceMappingURL=agent-tars.d.ts.map