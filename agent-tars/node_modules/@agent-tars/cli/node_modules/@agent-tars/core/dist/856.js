/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
"use strict";
exports.ids = [
    "856"
];
exports.modules = {
    "../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/index.mjs": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            default: ()=>node_modules_yargs
        });
        var esm = __webpack_require__("../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/lib/platform-shims/esm.mjs");
        function assertNotStrictEqual(actual, expected, shim, message) {
            shim.assert.notStrictEqual(actual, expected, message);
        }
        function assertSingleKey(actual, shim) {
            shim.assert.strictEqual(typeof actual, 'string');
        }
        function objectKeys(object) {
            return Object.keys(object);
        }
        function isPromise(maybePromise) {
            return !!maybePromise && !!maybePromise.then && 'function' == typeof maybePromise.then;
        }
        var yerror = __webpack_require__("../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/yerror.js");
        function parseCommand(cmd) {
            const extraSpacesStrippedCommand = cmd.replace(/\s{2,}/g, ' ');
            const splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/);
            const bregex = /\.*[\][<>]/g;
            const firstCommand = splitCommand.shift();
            if (!firstCommand) throw new Error(`No command found in: ${cmd}`);
            const parsedCommand = {
                cmd: firstCommand.replace(bregex, ''),
                demanded: [],
                optional: []
            };
            splitCommand.forEach((cmd, i)=>{
                let variadic = false;
                cmd = cmd.replace(/\s/g, '');
                if (/\.+[\]>]/.test(cmd) && i === splitCommand.length - 1) variadic = true;
                if (/^\[/.test(cmd)) parsedCommand.optional.push({
                    cmd: cmd.replace(bregex, '').split('|'),
                    variadic
                });
                else parsedCommand.demanded.push({
                    cmd: cmd.replace(bregex, '').split('|'),
                    variadic
                });
            });
            return parsedCommand;
        }
        const positionName = [
            'first',
            'second',
            'third',
            'fourth',
            'fifth',
            'sixth'
        ];
        function argsert(arg1, arg2, arg3) {
            function parseArgs() {
                return 'object' == typeof arg1 ? [
                    {
                        demanded: [],
                        optional: []
                    },
                    arg1,
                    arg2
                ] : [
                    parseCommand(`cmd ${arg1}`),
                    arg2,
                    arg3
                ];
            }
            try {
                let position = 0;
                const [parsed, callerArguments, _length] = parseArgs();
                const args = [].slice.call(callerArguments);
                while(args.length && void 0 === args[args.length - 1])args.pop();
                const length = _length || args.length;
                if (length < parsed.demanded.length) throw new yerror.s(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);
                const totalCommands = parsed.demanded.length + parsed.optional.length;
                if (length > totalCommands) throw new yerror.s(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);
                parsed.demanded.forEach((demanded)=>{
                    const arg = args.shift();
                    const observedType = guessType(arg);
                    const matchingTypes = demanded.cmd.filter((type)=>type === observedType || '*' === type);
                    if (0 === matchingTypes.length) argumentTypeError(observedType, demanded.cmd, position);
                    position += 1;
                });
                parsed.optional.forEach((optional)=>{
                    if (0 === args.length) return;
                    const arg = args.shift();
                    const observedType = guessType(arg);
                    const matchingTypes = optional.cmd.filter((type)=>type === observedType || '*' === type);
                    if (0 === matchingTypes.length) argumentTypeError(observedType, optional.cmd, position);
                    position += 1;
                });
            } catch (err) {
                console.warn(err.stack);
            }
        }
        function guessType(arg) {
            if (Array.isArray(arg)) return 'array';
            if (null === arg) return 'null';
            return typeof arg;
        }
        function argumentTypeError(observedType, allowedTypes, position) {
            throw new yerror.s(`Invalid ${positionName[position] || 'manyith'} argument. Expected ${allowedTypes.join(' or ')} but received ${observedType}.`);
        }
        class GlobalMiddleware {
            constructor(yargs){
                this.globalMiddleware = [];
                this.frozens = [];
                this.yargs = yargs;
            }
            addMiddleware(callback, applyBeforeValidation, global = true, mutates = false) {
                argsert('<array|function> [boolean] [boolean] [boolean]', [
                    callback,
                    applyBeforeValidation,
                    global
                ], arguments.length);
                if (Array.isArray(callback)) {
                    for(let i = 0; i < callback.length; i++){
                        if ('function' != typeof callback[i]) throw Error('middleware must be a function');
                        const m = callback[i];
                        m.applyBeforeValidation = applyBeforeValidation;
                        m.global = global;
                    }
                    Array.prototype.push.apply(this.globalMiddleware, callback);
                } else if ('function' == typeof callback) {
                    const m = callback;
                    m.applyBeforeValidation = applyBeforeValidation;
                    m.global = global;
                    m.mutates = mutates;
                    this.globalMiddleware.push(callback);
                }
                return this.yargs;
            }
            addCoerceMiddleware(callback, option) {
                const aliases = this.yargs.getAliases();
                this.globalMiddleware = this.globalMiddleware.filter((m)=>{
                    const toCheck = [
                        ...aliases[option] || [],
                        option
                    ];
                    if (!m.option) return true;
                    return !toCheck.includes(m.option);
                });
                callback.option = option;
                return this.addMiddleware(callback, true, true, true);
            }
            getMiddleware() {
                return this.globalMiddleware;
            }
            freeze() {
                this.frozens.push([
                    ...this.globalMiddleware
                ]);
            }
            unfreeze() {
                const frozen = this.frozens.pop();
                if (void 0 !== frozen) this.globalMiddleware = frozen;
            }
            reset() {
                this.globalMiddleware = this.globalMiddleware.filter((m)=>m.global);
            }
        }
        function commandMiddlewareFactory(commandMiddleware) {
            if (!commandMiddleware) return [];
            return commandMiddleware.map((middleware)=>{
                middleware.applyBeforeValidation = false;
                return middleware;
            });
        }
        function applyMiddleware(argv, yargs, middlewares, beforeValidation) {
            return middlewares.reduce((acc, middleware)=>{
                if (middleware.applyBeforeValidation !== beforeValidation) return acc;
                if (middleware.mutates) {
                    if (middleware.applied) return acc;
                    middleware.applied = true;
                }
                if (isPromise(acc)) return acc.then((initialObj)=>Promise.all([
                        initialObj,
                        middleware(initialObj, yargs)
                    ])).then(([initialObj, middlewareObj])=>Object.assign(initialObj, middlewareObj));
                {
                    const result = middleware(acc, yargs);
                    return isPromise(result) ? result.then((middlewareObj)=>Object.assign(acc, middlewareObj)) : Object.assign(acc, result);
                }
            }, argv);
        }
        function maybeAsyncResult(getResult, resultHandler, errorHandler = (err)=>{
            throw err;
        }) {
            try {
                const result = isFunction(getResult) ? getResult() : getResult;
                return isPromise(result) ? result.then((result)=>resultHandler(result)) : resultHandler(result);
            } catch (err) {
                return errorHandler(err);
            }
        }
        function isFunction(arg) {
            return 'function' == typeof arg;
        }
        function whichModule(exported) {
            if ('undefined' == typeof require) return null;
            for(let i = 0, files = Object.keys(__webpack_require__.c), mod; i < files.length; i++){
                mod = __webpack_require__.c[files[i]];
                if (mod.exports === exported) return mod;
            }
            return null;
        }
        const DEFAULT_MARKER = /(^\*)|(^\$0)/;
        class CommandInstance {
            constructor(usage, validation, globalMiddleware, shim){
                this.requireCache = new Set();
                this.handlers = {};
                this.aliasMap = {};
                this.frozens = [];
                this.shim = shim;
                this.usage = usage;
                this.globalMiddleware = globalMiddleware;
                this.validation = validation;
            }
            addDirectory(dir, req, callerFile, opts) {
                opts = opts || {};
                if ('boolean' != typeof opts.recurse) opts.recurse = false;
                if (!Array.isArray(opts.extensions)) opts.extensions = [
                    'js'
                ];
                const parentVisit = 'function' == typeof opts.visit ? opts.visit : (o)=>o;
                opts.visit = (obj, joined, filename)=>{
                    const visited = parentVisit(obj, joined, filename);
                    if (visited) {
                        if (this.requireCache.has(joined)) return visited;
                        this.requireCache.add(joined);
                        this.addHandler(visited);
                    }
                    return visited;
                };
                this.shim.requireDirectory({
                    require: req,
                    filename: callerFile
                }, dir, opts);
            }
            addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {
                let aliases = [];
                const middlewares = commandMiddlewareFactory(commandMiddleware);
                handler = handler || (()=>{});
                if (Array.isArray(cmd)) if (isCommandAndAliases(cmd)) [cmd, ...aliases] = cmd;
                else for (const command of cmd)this.addHandler(command);
                else if (isCommandHandlerDefinition(cmd)) {
                    let command = Array.isArray(cmd.command) || 'string' == typeof cmd.command ? cmd.command : this.moduleName(cmd);
                    if (cmd.aliases) command = [].concat(command).concat(cmd.aliases);
                    this.addHandler(command, this.extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);
                    return;
                } else if (isCommandBuilderDefinition(builder)) return void this.addHandler([
                    cmd
                ].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);
                if ('string' == typeof cmd) {
                    const parsedCommand = parseCommand(cmd);
                    aliases = aliases.map((alias)=>parseCommand(alias).cmd);
                    let isDefault = false;
                    const parsedAliases = [
                        parsedCommand.cmd
                    ].concat(aliases).filter((c)=>{
                        if (DEFAULT_MARKER.test(c)) {
                            isDefault = true;
                            return false;
                        }
                        return true;
                    });
                    if (0 === parsedAliases.length && isDefault) parsedAliases.push('$0');
                    if (isDefault) {
                        parsedCommand.cmd = parsedAliases[0];
                        aliases = parsedAliases.slice(1);
                        cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);
                    }
                    aliases.forEach((alias)=>{
                        this.aliasMap[alias] = parsedCommand.cmd;
                    });
                    if (false !== description) this.usage.command(cmd, description, isDefault, aliases, deprecated);
                    this.handlers[parsedCommand.cmd] = {
                        original: cmd,
                        description,
                        handler,
                        builder: builder || {},
                        middlewares,
                        deprecated,
                        demanded: parsedCommand.demanded,
                        optional: parsedCommand.optional
                    };
                    if (isDefault) this.defaultCommand = this.handlers[parsedCommand.cmd];
                }
            }
            getCommandHandlers() {
                return this.handlers;
            }
            getCommands() {
                return Object.keys(this.handlers).concat(Object.keys(this.aliasMap));
            }
            hasDefaultCommand() {
                return !!this.defaultCommand;
            }
            runCommand(command, yargs, parsed, commandIndex, helpOnly, helpOrVersionSet) {
                const commandHandler = this.handlers[command] || this.handlers[this.aliasMap[command]] || this.defaultCommand;
                const currentContext = yargs.getInternalMethods().getContext();
                const parentCommands = currentContext.commands.slice();
                const isDefaultCommand = !command;
                if (command) {
                    currentContext.commands.push(command);
                    currentContext.fullCommands.push(commandHandler.original);
                }
                const builderResult = this.applyBuilderUpdateUsageAndParse(isDefaultCommand, commandHandler, yargs, parsed.aliases, parentCommands, commandIndex, helpOnly, helpOrVersionSet);
                return isPromise(builderResult) ? builderResult.then((result)=>this.applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, result.innerArgv, currentContext, helpOnly, result.aliases, yargs)) : this.applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, builderResult.innerArgv, currentContext, helpOnly, builderResult.aliases, yargs);
            }
            applyBuilderUpdateUsageAndParse(isDefaultCommand, commandHandler, yargs, aliases, parentCommands, commandIndex, helpOnly, helpOrVersionSet) {
                const builder = commandHandler.builder;
                let innerYargs = yargs;
                if (isCommandBuilderCallback(builder)) {
                    yargs.getInternalMethods().getUsageInstance().freeze();
                    const builderOutput = builder(yargs.getInternalMethods().reset(aliases), helpOrVersionSet);
                    if (isPromise(builderOutput)) return builderOutput.then((output)=>{
                        innerYargs = isYargsInstance(output) ? output : yargs;
                        return this.parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly);
                    });
                } else if (isCommandBuilderOptionDefinitions(builder)) {
                    yargs.getInternalMethods().getUsageInstance().freeze();
                    innerYargs = yargs.getInternalMethods().reset(aliases);
                    Object.keys(commandHandler.builder).forEach((key)=>{
                        innerYargs.option(key, builder[key]);
                    });
                }
                return this.parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly);
            }
            parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly) {
                if (isDefaultCommand) innerYargs.getInternalMethods().getUsageInstance().unfreeze(true);
                if (this.shouldUpdateUsage(innerYargs)) innerYargs.getInternalMethods().getUsageInstance().usage(this.usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
                const innerArgv = innerYargs.getInternalMethods().runYargsParserAndExecuteCommands(null, void 0, true, commandIndex, helpOnly);
                return isPromise(innerArgv) ? innerArgv.then((argv)=>({
                        aliases: innerYargs.parsed.aliases,
                        innerArgv: argv
                    })) : {
                    aliases: innerYargs.parsed.aliases,
                    innerArgv: innerArgv
                };
            }
            shouldUpdateUsage(yargs) {
                return !yargs.getInternalMethods().getUsageInstance().getUsageDisabled() && 0 === yargs.getInternalMethods().getUsageInstance().getUsage().length;
            }
            usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {
                const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original;
                const pc = parentCommands.filter((c)=>!DEFAULT_MARKER.test(c));
                pc.push(c);
                return `$0 ${pc.join(' ')}`;
            }
            handleValidationAndGetResult(isDefaultCommand, commandHandler, innerArgv, currentContext, aliases, yargs, middlewares, positionalMap) {
                if (!yargs.getInternalMethods().getHasOutput()) {
                    const validation = yargs.getInternalMethods().runValidation(aliases, positionalMap, yargs.parsed.error, isDefaultCommand);
                    innerArgv = maybeAsyncResult(innerArgv, (result)=>{
                        validation(result);
                        return result;
                    });
                }
                if (commandHandler.handler && !yargs.getInternalMethods().getHasOutput()) {
                    yargs.getInternalMethods().setHasOutput();
                    const populateDoubleDash = !!yargs.getOptions().configuration['populate--'];
                    yargs.getInternalMethods().postProcess(innerArgv, populateDoubleDash, false, false);
                    innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);
                    innerArgv = maybeAsyncResult(innerArgv, (result)=>{
                        const handlerResult = commandHandler.handler(result);
                        return isPromise(handlerResult) ? handlerResult.then(()=>result) : result;
                    });
                    if (!isDefaultCommand) yargs.getInternalMethods().getUsageInstance().cacheHelpMessage();
                    if (isPromise(innerArgv) && !yargs.getInternalMethods().hasParseCallback()) innerArgv.catch((error)=>{
                        try {
                            yargs.getInternalMethods().getUsageInstance().fail(null, error);
                        } catch (_err) {}
                    });
                }
                if (!isDefaultCommand) {
                    currentContext.commands.pop();
                    currentContext.fullCommands.pop();
                }
                return innerArgv;
            }
            applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, innerArgv, currentContext, helpOnly, aliases, yargs) {
                let positionalMap = {};
                if (helpOnly) return innerArgv;
                if (!yargs.getInternalMethods().getHasOutput()) positionalMap = this.populatePositionals(commandHandler, innerArgv, currentContext, yargs);
                const middlewares = this.globalMiddleware.getMiddleware().slice(0).concat(commandHandler.middlewares);
                const maybePromiseArgv = applyMiddleware(innerArgv, yargs, middlewares, true);
                return isPromise(maybePromiseArgv) ? maybePromiseArgv.then((resolvedInnerArgv)=>this.handleValidationAndGetResult(isDefaultCommand, commandHandler, resolvedInnerArgv, currentContext, aliases, yargs, middlewares, positionalMap)) : this.handleValidationAndGetResult(isDefaultCommand, commandHandler, maybePromiseArgv, currentContext, aliases, yargs, middlewares, positionalMap);
            }
            populatePositionals(commandHandler, argv, context, yargs) {
                argv._ = argv._.slice(context.commands.length);
                const demanded = commandHandler.demanded.slice(0);
                const optional = commandHandler.optional.slice(0);
                const positionalMap = {};
                this.validation.positionalCount(demanded.length, argv._.length);
                while(demanded.length){
                    const demand = demanded.shift();
                    this.populatePositional(demand, argv, positionalMap);
                }
                while(optional.length){
                    const maybe = optional.shift();
                    this.populatePositional(maybe, argv, positionalMap);
                }
                argv._ = context.commands.concat(argv._.map((a)=>'' + a));
                this.postProcessPositionals(argv, positionalMap, this.cmdToParseOptions(commandHandler.original), yargs);
                return positionalMap;
            }
            populatePositional(positional, argv, positionalMap) {
                const cmd = positional.cmd[0];
                if (positional.variadic) positionalMap[cmd] = argv._.splice(0).map(String);
                else if (argv._.length) positionalMap[cmd] = [
                    String(argv._.shift())
                ];
            }
            cmdToParseOptions(cmdString) {
                const parseOptions = {
                    array: [],
                    default: {},
                    alias: {},
                    demand: {}
                };
                const parsed = parseCommand(cmdString);
                parsed.demanded.forEach((d)=>{
                    const [cmd, ...aliases] = d.cmd;
                    if (d.variadic) {
                        parseOptions.array.push(cmd);
                        parseOptions.default[cmd] = [];
                    }
                    parseOptions.alias[cmd] = aliases;
                    parseOptions.demand[cmd] = true;
                });
                parsed.optional.forEach((o)=>{
                    const [cmd, ...aliases] = o.cmd;
                    if (o.variadic) {
                        parseOptions.array.push(cmd);
                        parseOptions.default[cmd] = [];
                    }
                    parseOptions.alias[cmd] = aliases;
                });
                return parseOptions;
            }
            postProcessPositionals(argv, positionalMap, parseOptions, yargs) {
                const options = Object.assign({}, yargs.getOptions());
                options.default = Object.assign(parseOptions.default, options.default);
                for (const key of Object.keys(parseOptions.alias))options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);
                options.array = options.array.concat(parseOptions.array);
                options.config = {};
                const unparsed = [];
                Object.keys(positionalMap).forEach((key)=>{
                    positionalMap[key].map((value)=>{
                        if (options.configuration['unknown-options-as-args']) options.key[key] = true;
                        unparsed.push(`--${key}`);
                        unparsed.push(value);
                    });
                });
                if (!unparsed.length) return;
                const config = Object.assign({}, options.configuration, {
                    'populate--': false
                });
                const parsed = this.shim.Parser.detailed(unparsed, Object.assign({}, options, {
                    configuration: config
                }));
                if (parsed.error) yargs.getInternalMethods().getUsageInstance().fail(parsed.error.message, parsed.error);
                else {
                    const positionalKeys = Object.keys(positionalMap);
                    Object.keys(positionalMap).forEach((key)=>{
                        positionalKeys.push(...parsed.aliases[key]);
                    });
                    Object.keys(parsed.argv).forEach((key)=>{
                        if (positionalKeys.includes(key)) {
                            if (!positionalMap[key]) positionalMap[key] = parsed.argv[key];
                            if (!this.isInConfigs(yargs, key) && !this.isDefaulted(yargs, key) && Object.prototype.hasOwnProperty.call(argv, key) && Object.prototype.hasOwnProperty.call(parsed.argv, key) && (Array.isArray(argv[key]) || Array.isArray(parsed.argv[key]))) argv[key] = [].concat(argv[key], parsed.argv[key]);
                            else argv[key] = parsed.argv[key];
                        }
                    });
                }
            }
            isDefaulted(yargs, key) {
                const { default: defaults } = yargs.getOptions();
                return Object.prototype.hasOwnProperty.call(defaults, key) || Object.prototype.hasOwnProperty.call(defaults, this.shim.Parser.camelCase(key));
            }
            isInConfigs(yargs, key) {
                const { configObjects } = yargs.getOptions();
                return configObjects.some((c)=>Object.prototype.hasOwnProperty.call(c, key)) || configObjects.some((c)=>Object.prototype.hasOwnProperty.call(c, this.shim.Parser.camelCase(key)));
            }
            runDefaultBuilderOn(yargs) {
                if (!this.defaultCommand) return;
                if (this.shouldUpdateUsage(yargs)) {
                    const commandString = DEFAULT_MARKER.test(this.defaultCommand.original) ? this.defaultCommand.original : this.defaultCommand.original.replace(/^[^[\]<>]*/, '$0 ');
                    yargs.getInternalMethods().getUsageInstance().usage(commandString, this.defaultCommand.description);
                }
                const builder = this.defaultCommand.builder;
                if (isCommandBuilderCallback(builder)) return builder(yargs, true);
                if (!isCommandBuilderDefinition(builder)) Object.keys(builder).forEach((key)=>{
                    yargs.option(key, builder[key]);
                });
            }
            moduleName(obj) {
                const mod = whichModule(obj);
                if (!mod) throw new Error(`No command name given for module: ${this.shim.inspect(obj)}`);
                return this.commandFromFilename(mod.filename);
            }
            commandFromFilename(filename) {
                return this.shim.path.basename(filename, this.shim.path.extname(filename));
            }
            extractDesc({ describe, description, desc }) {
                for (const test of [
                    describe,
                    description,
                    desc
                ]){
                    if ('string' == typeof test || false === test) return test;
                    assertNotStrictEqual(test, true, this.shim);
                }
                return false;
            }
            freeze() {
                this.frozens.push({
                    handlers: this.handlers,
                    aliasMap: this.aliasMap,
                    defaultCommand: this.defaultCommand
                });
            }
            unfreeze() {
                const frozen = this.frozens.pop();
                assertNotStrictEqual(frozen, void 0, this.shim);
                ({ handlers: this.handlers, aliasMap: this.aliasMap, defaultCommand: this.defaultCommand } = frozen);
            }
            reset() {
                this.handlers = {};
                this.aliasMap = {};
                this.defaultCommand = void 0;
                this.requireCache = new Set();
                return this;
            }
        }
        function command_command(usage, validation, globalMiddleware, shim) {
            return new CommandInstance(usage, validation, globalMiddleware, shim);
        }
        function isCommandBuilderDefinition(builder) {
            return 'object' == typeof builder && !!builder.builder && 'function' == typeof builder.handler;
        }
        function isCommandAndAliases(cmd) {
            return cmd.every((c)=>'string' == typeof c);
        }
        function isCommandBuilderCallback(builder) {
            return 'function' == typeof builder;
        }
        function isCommandBuilderOptionDefinitions(builder) {
            return 'object' == typeof builder;
        }
        function isCommandHandlerDefinition(cmd) {
            return 'object' == typeof cmd && !Array.isArray(cmd);
        }
        function objFilter(original = {}, filter = ()=>true) {
            const obj = {};
            objectKeys(original).forEach((key)=>{
                if (filter(key, original[key])) obj[key] = original[key];
            });
            return obj;
        }
        function setBlocking(blocking) {
            if ('undefined' == typeof process) return;
            [
                process.stdout,
                process.stderr
            ].forEach((_stream)=>{
                const stream = _stream;
                if (stream._handle && stream.isTTY && 'function' == typeof stream._handle.setBlocking) stream._handle.setBlocking(blocking);
            });
        }
        function isBoolean(fail) {
            return 'boolean' == typeof fail;
        }
        function usage_usage(yargs, shim) {
            const __ = shim.y18n.__;
            const self = {};
            const fails = [];
            self.failFn = function(f) {
                fails.push(f);
            };
            let failMessage = null;
            let globalFailMessage = null;
            let showHelpOnFail = true;
            self.showHelpOnFail = function(arg1 = true, arg2) {
                const [enabled, message] = 'string' == typeof arg1 ? [
                    true,
                    arg1
                ] : [
                    arg1,
                    arg2
                ];
                if (yargs.getInternalMethods().isGlobalContext()) globalFailMessage = message;
                failMessage = message;
                showHelpOnFail = enabled;
                return self;
            };
            let failureOutput = false;
            self.fail = function(msg, err) {
                const logger = yargs.getInternalMethods().getLoggerInstance();
                if (fails.length) for(let i = fails.length - 1; i >= 0; --i){
                    const fail = fails[i];
                    if (isBoolean(fail)) {
                        if (err) throw err;
                        else if (msg) throw Error(msg);
                    } else fail(msg, err, self);
                }
                else {
                    if (yargs.getExitProcess()) setBlocking(true);
                    if (!failureOutput) {
                        failureOutput = true;
                        if (showHelpOnFail) {
                            yargs.showHelp('error');
                            logger.error();
                        }
                        if (msg || err) logger.error(msg || err);
                        const globalOrCommandFailMessage = failMessage || globalFailMessage;
                        if (globalOrCommandFailMessage) {
                            if (msg || err) logger.error('');
                            logger.error(globalOrCommandFailMessage);
                        }
                    }
                    err = err || new yerror.s(msg);
                    if (yargs.getExitProcess()) return yargs.exit(1);
                    if (yargs.getInternalMethods().hasParseCallback()) return yargs.exit(1, err);
                    throw err;
                }
            };
            let usages = [];
            let usageDisabled = false;
            self.usage = (msg, description)=>{
                if (null === msg) {
                    usageDisabled = true;
                    usages = [];
                    return self;
                }
                usageDisabled = false;
                usages.push([
                    msg,
                    description || ''
                ]);
                return self;
            };
            self.getUsage = ()=>usages;
            self.getUsageDisabled = ()=>usageDisabled;
            self.getPositionalGroupName = ()=>__('Positionals:');
            let examples = [];
            self.example = (cmd, description)=>{
                examples.push([
                    cmd,
                    description || ''
                ]);
            };
            let commands = [];
            self.command = function(cmd, description, isDefault, aliases, deprecated = false) {
                if (isDefault) commands = commands.map((cmdArray)=>{
                    cmdArray[2] = false;
                    return cmdArray;
                });
                commands.push([
                    cmd,
                    description || '',
                    isDefault,
                    aliases,
                    deprecated
                ]);
            };
            self.getCommands = ()=>commands;
            let descriptions = {};
            self.describe = function(keyOrKeys, desc) {
                if (Array.isArray(keyOrKeys)) keyOrKeys.forEach((k)=>{
                    self.describe(k, desc);
                });
                else if ('object' == typeof keyOrKeys) Object.keys(keyOrKeys).forEach((k)=>{
                    self.describe(k, keyOrKeys[k]);
                });
                else descriptions[keyOrKeys] = desc;
            };
            self.getDescriptions = ()=>descriptions;
            let epilogs = [];
            self.epilog = (msg)=>{
                epilogs.push(msg);
            };
            let wrapSet = false;
            let wrap;
            self.wrap = (cols)=>{
                wrapSet = true;
                wrap = cols;
            };
            self.getWrap = ()=>{
                if (shim.getEnv('YARGS_DISABLE_WRAP')) return null;
                if (!wrapSet) {
                    wrap = windowWidth();
                    wrapSet = true;
                }
                return wrap;
            };
            const deferY18nLookupPrefix = '__yargsString__:';
            self.deferY18nLookup = (str)=>deferY18nLookupPrefix + str;
            self.help = function() {
                if (cachedHelpMessage) return cachedHelpMessage;
                normalizeAliases();
                const base$0 = yargs.customScriptName ? yargs.$0 : shim.path.basename(yargs.$0);
                const demandedOptions = yargs.getDemandedOptions();
                const demandedCommands = yargs.getDemandedCommands();
                const deprecatedOptions = yargs.getDeprecatedOptions();
                const groups = yargs.getGroups();
                const options = yargs.getOptions();
                let keys = [];
                keys = keys.concat(Object.keys(descriptions));
                keys = keys.concat(Object.keys(demandedOptions));
                keys = keys.concat(Object.keys(demandedCommands));
                keys = keys.concat(Object.keys(options.default));
                keys = keys.filter(filterHiddenOptions);
                keys = Object.keys(keys.reduce((acc, key)=>{
                    if ('_' !== key) acc[key] = true;
                    return acc;
                }, {}));
                const theWrap = self.getWrap();
                const ui = shim.cliui({
                    width: theWrap,
                    wrap: !!theWrap
                });
                if (!usageDisabled) {
                    if (usages.length) {
                        usages.forEach((usage)=>{
                            ui.div({
                                text: `${usage[0].replace(/\$0/g, base$0)}`
                            });
                            if (usage[1]) ui.div({
                                text: `${usage[1]}`,
                                padding: [
                                    1,
                                    0,
                                    0,
                                    0
                                ]
                            });
                        });
                        ui.div();
                    } else if (commands.length) {
                        let u = null;
                        u = demandedCommands._ ? `${base$0} <${__('command')}>\n` : `${base$0} [${__('command')}]\n`;
                        ui.div(`${u}`);
                    }
                }
                if (commands.length > 1 || 1 === commands.length && !commands[0][2]) {
                    ui.div(__('Commands:'));
                    const context = yargs.getInternalMethods().getContext();
                    const parentCommands = context.commands.length ? `${context.commands.join(' ')} ` : '';
                    if (true === yargs.getInternalMethods().getParserConfiguration()['sort-commands']) commands = commands.sort((a, b)=>a[0].localeCompare(b[0]));
                    const prefix = base$0 ? `${base$0} ` : '';
                    commands.forEach((command)=>{
                        const commandString = `${prefix}${parentCommands}${command[0].replace(/^\$0 ?/, '')}`;
                        ui.span({
                            text: commandString,
                            padding: [
                                0,
                                2,
                                0,
                                2
                            ],
                            width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4
                        }, {
                            text: command[1]
                        });
                        const hints = [];
                        if (command[2]) hints.push(`[${__('default')}]`);
                        if (command[3] && command[3].length) hints.push(`[${__('aliases:')} ${command[3].join(', ')}]`);
                        if (command[4]) if ('string' == typeof command[4]) hints.push(`[${__('deprecated: %s', command[4])}]`);
                        else hints.push(`[${__('deprecated')}]`);
                        if (hints.length) ui.div({
                            text: hints.join(' '),
                            padding: [
                                0,
                                0,
                                0,
                                2
                            ],
                            align: 'right'
                        });
                        else ui.div();
                    });
                    ui.div();
                }
                const aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);
                keys = keys.filter((key)=>!yargs.parsed.newAliases[key] && aliasKeys.every((alias)=>-1 === (options.alias[alias] || []).indexOf(key)));
                const defaultGroup = __('Options:');
                if (!groups[defaultGroup]) groups[defaultGroup] = [];
                addUngroupedKeys(keys, options.alias, groups, defaultGroup);
                const isLongSwitch = (sw)=>/^--/.test(getText(sw));
                const displayedGroups = Object.keys(groups).filter((groupName)=>groups[groupName].length > 0).map((groupName)=>{
                    const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map((key)=>{
                        if (aliasKeys.includes(key)) return key;
                        for(let i = 0, aliasKey; void 0 !== (aliasKey = aliasKeys[i]); i++)if ((options.alias[aliasKey] || []).includes(key)) return aliasKey;
                        return key;
                    });
                    return {
                        groupName,
                        normalizedKeys
                    };
                }).filter(({ normalizedKeys })=>normalizedKeys.length > 0).map(({ groupName, normalizedKeys })=>{
                    const switches = normalizedKeys.reduce((acc, key)=>{
                        acc[key] = [
                            key
                        ].concat(options.alias[key] || []).map((sw)=>{
                            if (groupName === self.getPositionalGroupName()) return sw;
                            return (/^[0-9]$/.test(sw) ? options.boolean.includes(key) ? '-' : '--' : sw.length > 1 ? '--' : '-') + sw;
                        }).sort((sw1, sw2)=>isLongSwitch(sw1) === isLongSwitch(sw2) ? 0 : isLongSwitch(sw1) ? 1 : -1).join(', ');
                        return acc;
                    }, {});
                    return {
                        groupName,
                        normalizedKeys,
                        switches
                    };
                });
                const shortSwitchesUsed = displayedGroups.filter(({ groupName })=>groupName !== self.getPositionalGroupName()).some(({ normalizedKeys, switches })=>!normalizedKeys.every((key)=>isLongSwitch(switches[key])));
                if (shortSwitchesUsed) displayedGroups.filter(({ groupName })=>groupName !== self.getPositionalGroupName()).forEach(({ normalizedKeys, switches })=>{
                    normalizedKeys.forEach((key)=>{
                        if (isLongSwitch(switches[key])) switches[key] = addIndentation(switches[key], 4);
                    });
                });
                displayedGroups.forEach(({ groupName, normalizedKeys, switches })=>{
                    ui.div(groupName);
                    normalizedKeys.forEach((key)=>{
                        const kswitch = switches[key];
                        let desc = descriptions[key] || '';
                        let type = null;
                        if (desc.includes(deferY18nLookupPrefix)) desc = __(desc.substring(deferY18nLookupPrefix.length));
                        if (options.boolean.includes(key)) type = `[${__('boolean')}]`;
                        if (options.count.includes(key)) type = `[${__('count')}]`;
                        if (options.string.includes(key)) type = `[${__('string')}]`;
                        if (options.normalize.includes(key)) type = `[${__('string')}]`;
                        if (options.array.includes(key)) type = `[${__('array')}]`;
                        if (options.number.includes(key)) type = `[${__('number')}]`;
                        const deprecatedExtra = (deprecated)=>'string' == typeof deprecated ? `[${__('deprecated: %s', deprecated)}]` : `[${__('deprecated')}]`;
                        const extra = [
                            key in deprecatedOptions ? deprecatedExtra(deprecatedOptions[key]) : null,
                            type,
                            key in demandedOptions ? `[${__('required')}]` : null,
                            options.choices && options.choices[key] ? `[${__('choices:')} ${self.stringifiedValues(options.choices[key])}]` : null,
                            defaultString(options.default[key], options.defaultDescription[key])
                        ].filter(Boolean).join(' ');
                        ui.span({
                            text: getText(kswitch),
                            padding: [
                                0,
                                2,
                                0,
                                2 + getIndentation(kswitch)
                            ],
                            width: maxWidth(switches, theWrap) + 4
                        }, desc);
                        const shouldHideOptionExtras = true === yargs.getInternalMethods().getUsageConfiguration()['hide-types'];
                        if (extra && !shouldHideOptionExtras) ui.div({
                            text: extra,
                            padding: [
                                0,
                                0,
                                0,
                                2
                            ],
                            align: 'right'
                        });
                        else ui.div();
                    });
                    ui.div();
                });
                if (examples.length) {
                    ui.div(__('Examples:'));
                    examples.forEach((example)=>{
                        example[0] = example[0].replace(/\$0/g, base$0);
                    });
                    examples.forEach((example)=>{
                        if ('' === example[1]) ui.div({
                            text: example[0],
                            padding: [
                                0,
                                2,
                                0,
                                2
                            ]
                        });
                        else ui.div({
                            text: example[0],
                            padding: [
                                0,
                                2,
                                0,
                                2
                            ],
                            width: maxWidth(examples, theWrap) + 4
                        }, {
                            text: example[1]
                        });
                    });
                    ui.div();
                }
                if (epilogs.length > 0) {
                    const e = epilogs.map((epilog)=>epilog.replace(/\$0/g, base$0)).join('\n');
                    ui.div(`${e}\n`);
                }
                return ui.toString().replace(/\s*$/, '');
            };
            function maxWidth(table, theWrap, modifier) {
                let width = 0;
                if (!Array.isArray(table)) table = Object.values(table).map((v)=>[
                        v
                    ]);
                table.forEach((v)=>{
                    width = Math.max(shim.stringWidth(modifier ? `${modifier} ${getText(v[0])}` : getText(v[0])) + getIndentation(v[0]), width);
                });
                if (theWrap) width = Math.min(width, parseInt((0.5 * theWrap).toString(), 10));
                return width;
            }
            function normalizeAliases() {
                const demandedOptions = yargs.getDemandedOptions();
                const options = yargs.getOptions();
                (Object.keys(options.alias) || []).forEach((key)=>{
                    options.alias[key].forEach((alias)=>{
                        if (descriptions[alias]) self.describe(key, descriptions[alias]);
                        if (alias in demandedOptions) yargs.demandOption(key, demandedOptions[alias]);
                        if (options.boolean.includes(alias)) yargs.boolean(key);
                        if (options.count.includes(alias)) yargs.count(key);
                        if (options.string.includes(alias)) yargs.string(key);
                        if (options.normalize.includes(alias)) yargs.normalize(key);
                        if (options.array.includes(alias)) yargs.array(key);
                        if (options.number.includes(alias)) yargs.number(key);
                    });
                });
            }
            let cachedHelpMessage;
            self.cacheHelpMessage = function() {
                cachedHelpMessage = this.help();
            };
            self.clearCachedHelpMessage = function() {
                cachedHelpMessage = void 0;
            };
            self.hasCachedHelpMessage = function() {
                return !!cachedHelpMessage;
            };
            function addUngroupedKeys(keys, aliases, groups, defaultGroup) {
                let groupedKeys = [];
                let toCheck = null;
                Object.keys(groups).forEach((group)=>{
                    groupedKeys = groupedKeys.concat(groups[group]);
                });
                keys.forEach((key)=>{
                    toCheck = [
                        key
                    ].concat(aliases[key]);
                    if (!toCheck.some((k)=>-1 !== groupedKeys.indexOf(k))) groups[defaultGroup].push(key);
                });
                return groupedKeys;
            }
            function filterHiddenOptions(key) {
                return yargs.getOptions().hiddenOptions.indexOf(key) < 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt];
            }
            self.showHelp = (level)=>{
                const logger = yargs.getInternalMethods().getLoggerInstance();
                if (!level) level = 'error';
                const emit = 'function' == typeof level ? level : logger[level];
                emit(self.help());
            };
            self.functionDescription = (fn)=>{
                const description = fn.name ? shim.Parser.decamelize(fn.name, '-') : __('generated-value');
                return [
                    '(',
                    description,
                    ')'
                ].join('');
            };
            self.stringifiedValues = function(values, separator) {
                let string = '';
                const sep = separator || ', ';
                const array = [].concat(values);
                if (!values || !array.length) return string;
                array.forEach((value)=>{
                    if (string.length) string += sep;
                    string += JSON.stringify(value);
                });
                return string;
            };
            function defaultString(value, defaultDescription) {
                let string = `[${__('default:')} `;
                if (void 0 === value && !defaultDescription) return null;
                if (defaultDescription) string += defaultDescription;
                else switch(typeof value){
                    case 'string':
                        string += `"${value}"`;
                        break;
                    case 'object':
                        string += JSON.stringify(value);
                        break;
                    default:
                        string += value;
                }
                return `${string}]`;
            }
            function windowWidth() {
                const maxWidth = 80;
                if (shim.process.stdColumns) return Math.min(maxWidth, shim.process.stdColumns);
                return maxWidth;
            }
            let version = null;
            self.version = (ver)=>{
                version = ver;
            };
            self.showVersion = (level)=>{
                const logger = yargs.getInternalMethods().getLoggerInstance();
                if (!level) level = 'error';
                const emit = 'function' == typeof level ? level : logger[level];
                emit(version);
            };
            self.reset = function(localLookup) {
                failMessage = null;
                failureOutput = false;
                usages = [];
                usageDisabled = false;
                epilogs = [];
                examples = [];
                commands = [];
                descriptions = objFilter(descriptions, (k)=>!localLookup[k]);
                return self;
            };
            const frozens = [];
            self.freeze = function() {
                frozens.push({
                    failMessage,
                    failureOutput,
                    usages,
                    usageDisabled,
                    epilogs,
                    examples,
                    commands,
                    descriptions
                });
            };
            self.unfreeze = function(defaultCommand = false) {
                const frozen = frozens.pop();
                if (!frozen) return;
                if (defaultCommand) {
                    descriptions = {
                        ...frozen.descriptions,
                        ...descriptions
                    };
                    commands = [
                        ...frozen.commands,
                        ...commands
                    ];
                    usages = [
                        ...frozen.usages,
                        ...usages
                    ];
                    examples = [
                        ...frozen.examples,
                        ...examples
                    ];
                    epilogs = [
                        ...frozen.epilogs,
                        ...epilogs
                    ];
                } else ({ failMessage, failureOutput, usages, usageDisabled, epilogs, examples, commands, descriptions } = frozen);
            };
            return self;
        }
        function isIndentedText(text) {
            return 'object' == typeof text;
        }
        function addIndentation(text, indent) {
            return isIndentedText(text) ? {
                text: text.text,
                indentation: text.indentation + indent
            } : {
                text,
                indentation: indent
            };
        }
        function getIndentation(text) {
            return isIndentedText(text) ? text.indentation : 0;
        }
        function getText(text) {
            return isIndentedText(text) ? text.text : text;
        }
        const completionShTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc
#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
    local cur_word args type_list

    cur_word="\${COMP_WORDS[COMP_CWORD]}"
    args=("\${COMP_WORDS[@]}")

    # ask yargs to generate completions.
    type_list=$({{app_path}} --get-yargs-completions "\${args[@]}")

    COMPREPLY=( $(compgen -W "\${type_list}" -- \${cur_word}) )

    # if no match was found, fall back to filename completion
    if [ \${#COMPREPLY[@]} -eq 0 ]; then
      COMPREPLY=()
    fi

    return 0
}
complete -o bashdefault -o default -F _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
        const completionZshTemplate = `#compdef {{app_name}}
###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zprofile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'\n' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
        class Completion {
            constructor(yargs, usage, command, shim){
                var _a, _b, _c;
                this.yargs = yargs;
                this.usage = usage;
                this.command = command;
                this.shim = shim;
                this.completionKey = 'get-yargs-completions';
                this.aliases = null;
                this.customCompletionFunction = null;
                this.indexAfterLastReset = 0;
                this.zshShell = null != (_c = (null == (_a = this.shim.getEnv('SHELL')) ? void 0 : _a.includes('zsh')) || (null == (_b = this.shim.getEnv('ZSH_NAME')) ? void 0 : _b.includes('zsh'))) ? _c : false;
            }
            defaultCompletion(args, argv, current, done) {
                const handlers = this.command.getCommandHandlers();
                for(let i = 0, ii = args.length; i < ii; ++i)if (handlers[args[i]] && handlers[args[i]].builder) {
                    const builder = handlers[args[i]].builder;
                    if (isCommandBuilderCallback(builder)) {
                        this.indexAfterLastReset = i + 1;
                        const y = this.yargs.getInternalMethods().reset();
                        builder(y, true);
                        return y.argv;
                    }
                }
                const completions = [];
                this.commandCompletions(completions, args, current);
                this.optionCompletions(completions, args, argv, current);
                this.choicesFromOptionsCompletions(completions, args, argv, current);
                this.choicesFromPositionalsCompletions(completions, args, argv, current);
                done(null, completions);
            }
            commandCompletions(completions, args, current) {
                const parentCommands = this.yargs.getInternalMethods().getContext().commands;
                if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current && !this.previousArgHasChoices(args)) this.usage.getCommands().forEach((usageCommand)=>{
                    const commandName = parseCommand(usageCommand[0]).cmd;
                    if (-1 === args.indexOf(commandName)) if (this.zshShell) {
                        const desc = usageCommand[1] || '';
                        completions.push(commandName.replace(/:/g, '\\:') + ':' + desc);
                    } else completions.push(commandName);
                });
            }
            optionCompletions(completions, args, argv, current) {
                if ((current.match(/^-/) || '' === current && 0 === completions.length) && !this.previousArgHasChoices(args)) {
                    const options = this.yargs.getOptions();
                    const positionalKeys = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
                    Object.keys(options.key).forEach((key)=>{
                        const negable = !!options.configuration['boolean-negation'] && options.boolean.includes(key);
                        const isPositionalKey = positionalKeys.includes(key);
                        if (!isPositionalKey && !options.hiddenOptions.includes(key) && !this.argsContainKey(args, key, negable)) this.completeOptionKey(key, completions, current, negable && !!options.default[key]);
                    });
                }
            }
            choicesFromOptionsCompletions(completions, args, argv, current) {
                if (this.previousArgHasChoices(args)) {
                    const choices = this.getPreviousArgChoices(args);
                    if (choices && choices.length > 0) completions.push(...choices.map((c)=>c.replace(/:/g, '\\:')));
                }
            }
            choicesFromPositionalsCompletions(completions, args, argv, current) {
                if ('' === current && completions.length > 0 && this.previousArgHasChoices(args)) return;
                const positionalKeys = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
                const offset = Math.max(this.indexAfterLastReset, this.yargs.getInternalMethods().getContext().commands.length + 1);
                const positionalKey = positionalKeys[argv._.length - offset - 1];
                if (!positionalKey) return;
                const choices = this.yargs.getOptions().choices[positionalKey] || [];
                for (const choice of choices)if (choice.startsWith(current)) completions.push(choice.replace(/:/g, '\\:'));
            }
            getPreviousArgChoices(args) {
                if (args.length < 1) return;
                let previousArg = args[args.length - 1];
                let filter = '';
                if (!previousArg.startsWith('-') && args.length > 1) {
                    filter = previousArg;
                    previousArg = args[args.length - 2];
                }
                if (!previousArg.startsWith('-')) return;
                const previousArgKey = previousArg.replace(/^-+/, '');
                const options = this.yargs.getOptions();
                const possibleAliases = [
                    previousArgKey,
                    ...this.yargs.getAliases()[previousArgKey] || []
                ];
                let choices;
                for (const possibleAlias of possibleAliases)if (Object.prototype.hasOwnProperty.call(options.key, possibleAlias) && Array.isArray(options.choices[possibleAlias])) {
                    choices = options.choices[possibleAlias];
                    break;
                }
                if (choices) return choices.filter((choice)=>!filter || choice.startsWith(filter));
            }
            previousArgHasChoices(args) {
                const choices = this.getPreviousArgChoices(args);
                return void 0 !== choices && choices.length > 0;
            }
            argsContainKey(args, key, negable) {
                const argsContains = (s)=>-1 !== args.indexOf((/^[^0-9]$/.test(s) ? '-' : '--') + s);
                if (argsContains(key)) return true;
                if (negable && argsContains(`no-${key}`)) return true;
                if (this.aliases) {
                    for (const alias of this.aliases[key])if (argsContains(alias)) return true;
                }
                return false;
            }
            completeOptionKey(key, completions, current, negable) {
                var _a, _b, _c, _d;
                let keyWithDesc = key;
                if (this.zshShell) {
                    const descs = this.usage.getDescriptions();
                    const aliasKey = null == (_b = null == (_a = this === null || void 0 === this ? void 0 : this.aliases) ? void 0 : _a[key]) ? void 0 : _b.find((alias)=>{
                        const desc = descs[alias];
                        return 'string' == typeof desc && desc.length > 0;
                    });
                    const descFromAlias = aliasKey ? descs[aliasKey] : void 0;
                    const desc = null != (_d = null != (_c = descs[key]) ? _c : descFromAlias) ? _d : '';
                    keyWithDesc = `${key.replace(/:/g, '\\:')}:${desc.replace('__yargsString__:', '').replace(/(\r\n|\n|\r)/gm, ' ')}`;
                }
                const startsByTwoDashes = (s)=>/^--/.test(s);
                const isShortOption = (s)=>/^[^0-9]$/.test(s);
                const dashes = !startsByTwoDashes(current) && isShortOption(key) ? '-' : '--';
                completions.push(dashes + keyWithDesc);
                if (negable) completions.push(dashes + 'no-' + keyWithDesc);
            }
            customCompletion(args, argv, current, done) {
                assertNotStrictEqual(this.customCompletionFunction, null, this.shim);
                if (isSyncCompletionFunction(this.customCompletionFunction)) {
                    const result = this.customCompletionFunction(current, argv);
                    if (isPromise(result)) return result.then((list)=>{
                        this.shim.process.nextTick(()=>{
                            done(null, list);
                        });
                    }).catch((err)=>{
                        this.shim.process.nextTick(()=>{
                            done(err, void 0);
                        });
                    });
                    return done(null, result);
                }
                if (isFallbackCompletionFunction(this.customCompletionFunction)) return this.customCompletionFunction(current, argv, (onCompleted = done)=>this.defaultCompletion(args, argv, current, onCompleted), (completions)=>{
                    done(null, completions);
                });
                return this.customCompletionFunction(current, argv, (completions)=>{
                    done(null, completions);
                });
            }
            getCompletion(args, done) {
                const current = args.length ? args[args.length - 1] : '';
                const argv = this.yargs.parse(args, true);
                const completionFunction = this.customCompletionFunction ? (argv)=>this.customCompletion(args, argv, current, done) : (argv)=>this.defaultCompletion(args, argv, current, done);
                return isPromise(argv) ? argv.then(completionFunction) : completionFunction(argv);
            }
            generateCompletionScript($0, cmd) {
                let script = this.zshShell ? completionZshTemplate : completionShTemplate;
                const name = this.shim.path.basename($0);
                if ($0.match(/\.js$/)) $0 = `./${$0}`;
                script = script.replace(/{{app_name}}/g, name);
                script = script.replace(/{{completion_command}}/g, cmd);
                return script.replace(/{{app_path}}/g, $0);
            }
            registerFunction(fn) {
                this.customCompletionFunction = fn;
            }
            setParsed(parsed) {
                this.aliases = parsed.aliases;
            }
        }
        function completion_completion(yargs, usage, command, shim) {
            return new Completion(yargs, usage, command, shim);
        }
        function isSyncCompletionFunction(completionFunction) {
            return completionFunction.length < 3;
        }
        function isFallbackCompletionFunction(completionFunction) {
            return completionFunction.length > 3;
        }
        function levenshtein(a, b) {
            if (0 === a.length) return b.length;
            if (0 === b.length) return a.length;
            const matrix = [];
            let i;
            for(i = 0; i <= b.length; i++)matrix[i] = [
                i
            ];
            let j;
            for(j = 0; j <= a.length; j++)matrix[0][j] = j;
            for(i = 1; i <= b.length; i++)for(j = 1; j <= a.length; j++)if (b.charAt(i - 1) === a.charAt(j - 1)) matrix[i][j] = matrix[i - 1][j - 1];
            else if (i > 1 && j > 1 && b.charAt(i - 2) === a.charAt(j - 1) && b.charAt(i - 1) === a.charAt(j - 2)) matrix[i][j] = matrix[i - 2][j - 2] + 1;
            else matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
            return matrix[b.length][a.length];
        }
        const specialKeys = [
            '$0',
            '--',
            '_'
        ];
        function validation_validation(yargs, usage, shim) {
            const __ = shim.y18n.__;
            const __n = shim.y18n.__n;
            const self = {};
            self.nonOptionCount = function(argv) {
                const demandedCommands = yargs.getDemandedCommands();
                const positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);
                const _s = positionalCount - yargs.getInternalMethods().getContext().commands.length;
                if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {
                    if (_s < demandedCommands._.min) if (void 0 !== demandedCommands._.minMsg) usage.fail(demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.min.toString()) : null);
                    else usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));
                    else if (_s > demandedCommands._.max) if (void 0 !== demandedCommands._.maxMsg) usage.fail(demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.max.toString()) : null);
                    else usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));
                }
            };
            self.positionalCount = function(required, observed) {
                if (observed < required) usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));
            };
            self.requiredArguments = function(argv, demandedOptions) {
                let missing = null;
                for (const key of Object.keys(demandedOptions))if (!Object.prototype.hasOwnProperty.call(argv, key) || void 0 === argv[key]) {
                    missing = missing || {};
                    missing[key] = demandedOptions[key];
                }
                if (missing) {
                    const customMsgs = [];
                    for (const key of Object.keys(missing)){
                        const msg = missing[key];
                        if (msg && customMsgs.indexOf(msg) < 0) customMsgs.push(msg);
                    }
                    const customMsg = customMsgs.length ? `\n${customMsgs.join('\n')}` : '';
                    usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));
                }
            };
            self.unknownArguments = function(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {
                var _a;
                const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();
                const unknown = [];
                const currentContext = yargs.getInternalMethods().getContext();
                Object.keys(argv).forEach((key)=>{
                    if (!specialKeys.includes(key) && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs.getInternalMethods().getParseContext(), key) && !self.isValidAndSomeAliasIsNotNew(key, aliases)) unknown.push(key);
                });
                if (checkPositionals && (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand)) argv._.slice(currentContext.commands.length).forEach((key)=>{
                    if (!commandKeys.includes('' + key)) unknown.push('' + key);
                });
                if (checkPositionals) {
                    const demandedCommands = yargs.getDemandedCommands();
                    const maxNonOptDemanded = (null == (_a = demandedCommands._) ? void 0 : _a.max) || 0;
                    const expected = currentContext.commands.length + maxNonOptDemanded;
                    if (expected < argv._.length) argv._.slice(expected).forEach((key)=>{
                        key = String(key);
                        if (!currentContext.commands.includes(key) && !unknown.includes(key)) unknown.push(key);
                    });
                }
                if (unknown.length) usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.map((s)=>s.trim() ? s : `"${s}"`).join(', ')));
            };
            self.unknownCommands = function(argv) {
                const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();
                const unknown = [];
                const currentContext = yargs.getInternalMethods().getContext();
                if (currentContext.commands.length > 0 || commandKeys.length > 0) argv._.slice(currentContext.commands.length).forEach((key)=>{
                    if (!commandKeys.includes('' + key)) unknown.push('' + key);
                });
                if (!(unknown.length > 0)) return false;
                usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));
                return true;
            };
            self.isValidAndSomeAliasIsNotNew = function(key, aliases) {
                if (!Object.prototype.hasOwnProperty.call(aliases, key)) return false;
                const newAliases = yargs.parsed.newAliases;
                return [
                    key,
                    ...aliases[key]
                ].some((a)=>!Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]);
            };
            self.limitedChoices = function(argv) {
                const options = yargs.getOptions();
                const invalid = {};
                if (!Object.keys(options.choices).length) return;
                Object.keys(argv).forEach((key)=>{
                    if (-1 === specialKeys.indexOf(key) && Object.prototype.hasOwnProperty.call(options.choices, key)) [].concat(argv[key]).forEach((value)=>{
                        if (-1 === options.choices[key].indexOf(value) && void 0 !== value) invalid[key] = (invalid[key] || []).concat(value);
                    });
                });
                const invalidKeys = Object.keys(invalid);
                if (!invalidKeys.length) return;
                let msg = __('Invalid values:');
                invalidKeys.forEach((key)=>{
                    msg += `\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;
                });
                usage.fail(msg);
            };
            let implied = {};
            self.implies = function(key, value) {
                argsert('<string|object> [array|number|string]', [
                    key,
                    value
                ], arguments.length);
                if ('object' == typeof key) Object.keys(key).forEach((k)=>{
                    self.implies(k, key[k]);
                });
                else {
                    yargs.global(key);
                    if (!implied[key]) implied[key] = [];
                    if (Array.isArray(value)) value.forEach((i)=>self.implies(key, i));
                    else {
                        assertNotStrictEqual(value, void 0, shim);
                        implied[key].push(value);
                    }
                }
            };
            self.getImplied = function() {
                return implied;
            };
            function keyExists(argv, val) {
                const num = Number(val);
                val = isNaN(num) ? val : num;
                if ('number' == typeof val) val = argv._.length >= val;
                else if (val.match(/^--no-.+/)) {
                    val = val.match(/^--no-(.+)/)[1];
                    val = !Object.prototype.hasOwnProperty.call(argv, val);
                } else val = Object.prototype.hasOwnProperty.call(argv, val);
                return val;
            }
            self.implications = function(argv) {
                const implyFail = [];
                Object.keys(implied).forEach((key)=>{
                    const origKey = key;
                    (implied[key] || []).forEach((value)=>{
                        let key = origKey;
                        const origValue = value;
                        key = keyExists(argv, key);
                        value = keyExists(argv, value);
                        if (key && !value) implyFail.push(` ${origKey} -> ${origValue}`);
                    });
                });
                if (implyFail.length) {
                    let msg = `${__('Implications failed:')}\n`;
                    implyFail.forEach((value)=>{
                        msg += value;
                    });
                    usage.fail(msg);
                }
            };
            let conflicting = {};
            self.conflicts = function(key, value) {
                argsert('<string|object> [array|string]', [
                    key,
                    value
                ], arguments.length);
                if ('object' == typeof key) Object.keys(key).forEach((k)=>{
                    self.conflicts(k, key[k]);
                });
                else {
                    yargs.global(key);
                    if (!conflicting[key]) conflicting[key] = [];
                    if (Array.isArray(value)) value.forEach((i)=>self.conflicts(key, i));
                    else conflicting[key].push(value);
                }
            };
            self.getConflicting = ()=>conflicting;
            self.conflicting = function(argv) {
                Object.keys(argv).forEach((key)=>{
                    if (conflicting[key]) conflicting[key].forEach((value)=>{
                        if (value && void 0 !== argv[key] && void 0 !== argv[value]) usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));
                    });
                });
                if (yargs.getInternalMethods().getParserConfiguration()['strip-dashed']) Object.keys(conflicting).forEach((key)=>{
                    conflicting[key].forEach((value)=>{
                        if (value && void 0 !== argv[shim.Parser.camelCase(key)] && void 0 !== argv[shim.Parser.camelCase(value)]) usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));
                    });
                });
            };
            self.recommendCommands = function(cmd, potentialCommands) {
                const threshold = 3;
                potentialCommands = potentialCommands.sort((a, b)=>b.length - a.length);
                let recommended = null;
                let bestDistance = 1 / 0;
                for(let i = 0, candidate; void 0 !== (candidate = potentialCommands[i]); i++){
                    const d = levenshtein(cmd, candidate);
                    if (d <= threshold && d < bestDistance) {
                        bestDistance = d;
                        recommended = candidate;
                    }
                }
                if (recommended) usage.fail(__('Did you mean %s?', recommended));
            };
            self.reset = function(localLookup) {
                implied = objFilter(implied, (k)=>!localLookup[k]);
                conflicting = objFilter(conflicting, (k)=>!localLookup[k]);
                return self;
            };
            const frozens = [];
            self.freeze = function() {
                frozens.push({
                    implied,
                    conflicting
                });
            };
            self.unfreeze = function() {
                const frozen = frozens.pop();
                assertNotStrictEqual(frozen, void 0, shim);
                ({ implied, conflicting } = frozen);
            };
            return self;
        }
        var apply_extends = __webpack_require__("../node_modules/.pnpm/yargs@17.7.2/node_modules/yargs/build/lib/utils/apply-extends.js");
        var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
            if ("m" === kind) throw new TypeError("Private method is not writable");
            if ("a" === kind && !f) throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof state ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === kind ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        };
        var __classPrivateFieldGet = function(receiver, state, kind, f) {
            if ("a" === kind && !f) throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof state ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === kind ? f : "a" === kind ? f.call(receiver) : f ? f.value : state.get(receiver);
        };
        var _YargsInstance_command, _YargsInstance_cwd, _YargsInstance_context, _YargsInstance_completion, _YargsInstance_completionCommand, _YargsInstance_defaultShowHiddenOpt, _YargsInstance_exitError, _YargsInstance_detectLocale, _YargsInstance_emittedWarnings, _YargsInstance_exitProcess, _YargsInstance_frozens, _YargsInstance_globalMiddleware, _YargsInstance_groups, _YargsInstance_hasOutput, _YargsInstance_helpOpt, _YargsInstance_isGlobalContext, _YargsInstance_logger, _YargsInstance_output, _YargsInstance_options, _YargsInstance_parentRequire, _YargsInstance_parserConfig, _YargsInstance_parseFn, _YargsInstance_parseContext, _YargsInstance_pkgs, _YargsInstance_preservedGroups, _YargsInstance_processArgs, _YargsInstance_recommendCommands, _YargsInstance_shim, _YargsInstance_strict, _YargsInstance_strictCommands, _YargsInstance_strictOptions, _YargsInstance_usage, _YargsInstance_usageConfig, _YargsInstance_versionOpt, _YargsInstance_validation;
        function YargsFactory(_shim) {
            return (processArgs = [], cwd = _shim.process.cwd(), parentRequire)=>{
                const yargs = new YargsInstance(processArgs, cwd, parentRequire, _shim);
                Object.defineProperty(yargs, 'argv', {
                    get: ()=>yargs.parse(),
                    enumerable: true
                });
                yargs.help();
                yargs.version();
                return yargs;
            };
        }
        const kCopyDoubleDash = Symbol('copyDoubleDash');
        const kCreateLogger = Symbol('copyDoubleDash');
        const kDeleteFromParserHintObject = Symbol('deleteFromParserHintObject');
        const kEmitWarning = Symbol('emitWarning');
        const kFreeze = Symbol('freeze');
        const kGetDollarZero = Symbol('getDollarZero');
        const kGetParserConfiguration = Symbol('getParserConfiguration');
        const kGetUsageConfiguration = Symbol('getUsageConfiguration');
        const kGuessLocale = Symbol('guessLocale');
        const kGuessVersion = Symbol('guessVersion');
        const kParsePositionalNumbers = Symbol('parsePositionalNumbers');
        const kPkgUp = Symbol('pkgUp');
        const kPopulateParserHintArray = Symbol('populateParserHintArray');
        const kPopulateParserHintSingleValueDictionary = Symbol('populateParserHintSingleValueDictionary');
        const kPopulateParserHintArrayDictionary = Symbol('populateParserHintArrayDictionary');
        const kPopulateParserHintDictionary = Symbol('populateParserHintDictionary');
        const kSanitizeKey = Symbol('sanitizeKey');
        const kSetKey = Symbol('setKey');
        const kUnfreeze = Symbol('unfreeze');
        const kValidateAsync = Symbol('validateAsync');
        const kGetCommandInstance = Symbol('getCommandInstance');
        const kGetContext = Symbol('getContext');
        const kGetHasOutput = Symbol('getHasOutput');
        const kGetLoggerInstance = Symbol('getLoggerInstance');
        const kGetParseContext = Symbol('getParseContext');
        const kGetUsageInstance = Symbol('getUsageInstance');
        const kGetValidationInstance = Symbol('getValidationInstance');
        const kHasParseCallback = Symbol('hasParseCallback');
        const kIsGlobalContext = Symbol('isGlobalContext');
        const kPostProcess = Symbol('postProcess');
        const kRebase = Symbol('rebase');
        const kReset = Symbol('reset');
        const kRunYargsParserAndExecuteCommands = Symbol('runYargsParserAndExecuteCommands');
        const kRunValidation = Symbol('runValidation');
        const kSetHasOutput = Symbol('setHasOutput');
        const kTrackManuallySetKeys = Symbol('kTrackManuallySetKeys');
        class YargsInstance {
            constructor(processArgs = [], cwd, parentRequire, shim){
                this.customScriptName = false;
                this.parsed = false;
                _YargsInstance_command.set(this, void 0);
                _YargsInstance_cwd.set(this, void 0);
                _YargsInstance_context.set(this, {
                    commands: [],
                    fullCommands: []
                });
                _YargsInstance_completion.set(this, null);
                _YargsInstance_completionCommand.set(this, null);
                _YargsInstance_defaultShowHiddenOpt.set(this, 'show-hidden');
                _YargsInstance_exitError.set(this, null);
                _YargsInstance_detectLocale.set(this, true);
                _YargsInstance_emittedWarnings.set(this, {});
                _YargsInstance_exitProcess.set(this, true);
                _YargsInstance_frozens.set(this, []);
                _YargsInstance_globalMiddleware.set(this, void 0);
                _YargsInstance_groups.set(this, {});
                _YargsInstance_hasOutput.set(this, false);
                _YargsInstance_helpOpt.set(this, null);
                _YargsInstance_isGlobalContext.set(this, true);
                _YargsInstance_logger.set(this, void 0);
                _YargsInstance_output.set(this, '');
                _YargsInstance_options.set(this, void 0);
                _YargsInstance_parentRequire.set(this, void 0);
                _YargsInstance_parserConfig.set(this, {});
                _YargsInstance_parseFn.set(this, null);
                _YargsInstance_parseContext.set(this, null);
                _YargsInstance_pkgs.set(this, {});
                _YargsInstance_preservedGroups.set(this, {});
                _YargsInstance_processArgs.set(this, void 0);
                _YargsInstance_recommendCommands.set(this, false);
                _YargsInstance_shim.set(this, void 0);
                _YargsInstance_strict.set(this, false);
                _YargsInstance_strictCommands.set(this, false);
                _YargsInstance_strictOptions.set(this, false);
                _YargsInstance_usage.set(this, void 0);
                _YargsInstance_usageConfig.set(this, {});
                _YargsInstance_versionOpt.set(this, null);
                _YargsInstance_validation.set(this, void 0);
                __classPrivateFieldSet(this, _YargsInstance_shim, shim, "f");
                __classPrivateFieldSet(this, _YargsInstance_processArgs, processArgs, "f");
                __classPrivateFieldSet(this, _YargsInstance_cwd, cwd, "f");
                __classPrivateFieldSet(this, _YargsInstance_parentRequire, parentRequire, "f");
                __classPrivateFieldSet(this, _YargsInstance_globalMiddleware, new GlobalMiddleware(this), "f");
                this.$0 = this[kGetDollarZero]();
                this[kReset]();
                __classPrivateFieldSet(this, _YargsInstance_command, __classPrivateFieldGet(this, _YargsInstance_command, "f"), "f");
                __classPrivateFieldSet(this, _YargsInstance_usage, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), "f");
                __classPrivateFieldSet(this, _YargsInstance_validation, __classPrivateFieldGet(this, _YargsInstance_validation, "f"), "f");
                __classPrivateFieldSet(this, _YargsInstance_options, __classPrivateFieldGet(this, _YargsInstance_options, "f"), "f");
                __classPrivateFieldGet(this, _YargsInstance_options, "f").showHiddenOpt = __classPrivateFieldGet(this, _YargsInstance_defaultShowHiddenOpt, "f");
                __classPrivateFieldSet(this, _YargsInstance_logger, this[kCreateLogger](), "f");
            }
            addHelpOpt(opt, msg) {
                const defaultHelpOpt = 'help';
                argsert('[string|boolean] [string]', [
                    opt,
                    msg
                ], arguments.length);
                if (__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")) {
                    this[kDeleteFromParserHintObject](__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"));
                    __classPrivateFieldSet(this, _YargsInstance_helpOpt, null, "f");
                }
                if (false === opt && void 0 === msg) return this;
                __classPrivateFieldSet(this, _YargsInstance_helpOpt, 'string' == typeof opt ? opt : defaultHelpOpt, "f");
                this.boolean(__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"));
                this.describe(__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"), msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup('Show help'));
                return this;
            }
            help(opt, msg) {
                return this.addHelpOpt(opt, msg);
            }
            addShowHiddenOpt(opt, msg) {
                argsert('[string|boolean] [string]', [
                    opt,
                    msg
                ], arguments.length);
                if (false === opt && void 0 === msg) return this;
                const showHiddenOpt = 'string' == typeof opt ? opt : __classPrivateFieldGet(this, _YargsInstance_defaultShowHiddenOpt, "f");
                this.boolean(showHiddenOpt);
                this.describe(showHiddenOpt, msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup('Show hidden options'));
                __classPrivateFieldGet(this, _YargsInstance_options, "f").showHiddenOpt = showHiddenOpt;
                return this;
            }
            showHidden(opt, msg) {
                return this.addShowHiddenOpt(opt, msg);
            }
            alias(key, value) {
                argsert('<object|string|array> [string|array]', [
                    key,
                    value
                ], arguments.length);
                this[kPopulateParserHintArrayDictionary](this.alias.bind(this), 'alias', key, value);
                return this;
            }
            array(keys) {
                argsert('<array|string>', [
                    keys
                ], arguments.length);
                this[kPopulateParserHintArray]('array', keys);
                this[kTrackManuallySetKeys](keys);
                return this;
            }
            boolean(keys) {
                argsert('<array|string>', [
                    keys
                ], arguments.length);
                this[kPopulateParserHintArray]('boolean', keys);
                this[kTrackManuallySetKeys](keys);
                return this;
            }
            check(f, global) {
                argsert('<function> [boolean]', [
                    f,
                    global
                ], arguments.length);
                this.middleware((argv, _yargs)=>maybeAsyncResult(()=>f(argv, _yargs.getOptions()), (result)=>{
                        if (result) {
                            if ('string' == typeof result || result instanceof Error) __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(result.toString(), result);
                        } else __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(__classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.__('Argument check failed: %s', f.toString()));
                        return argv;
                    }, (err)=>{
                        __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(err.message ? err.message : err.toString(), err);
                        return argv;
                    }), false, global);
                return this;
            }
            choices(key, value) {
                argsert('<object|string|array> [string|array]', [
                    key,
                    value
                ], arguments.length);
                this[kPopulateParserHintArrayDictionary](this.choices.bind(this), 'choices', key, value);
                return this;
            }
            coerce(keys, value) {
                argsert('<object|string|array> [function]', [
                    keys,
                    value
                ], arguments.length);
                if (Array.isArray(keys)) {
                    if (!value) throw new yerror.s('coerce callback must be provided');
                    for (const key of keys)this.coerce(key, value);
                    return this;
                }
                if ('object' == typeof keys) {
                    for (const key of Object.keys(keys))this.coerce(key, keys[key]);
                    return this;
                }
                if (!value) throw new yerror.s('coerce callback must be provided');
                __classPrivateFieldGet(this, _YargsInstance_options, "f").key[keys] = true;
                __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").addCoerceMiddleware((argv, yargs)=>{
                    let aliases;
                    const shouldCoerce = Object.prototype.hasOwnProperty.call(argv, keys);
                    if (!shouldCoerce) return argv;
                    return maybeAsyncResult(()=>{
                        aliases = yargs.getAliases();
                        return value(argv[keys]);
                    }, (result)=>{
                        argv[keys] = result;
                        const stripAliased = yargs.getInternalMethods().getParserConfiguration()['strip-aliased'];
                        if (aliases[keys] && true !== stripAliased) for (const alias of aliases[keys])argv[alias] = result;
                        return argv;
                    }, (err)=>{
                        throw new yerror.s(err.message);
                    });
                }, keys);
                return this;
            }
            conflicts(key1, key2) {
                argsert('<string|object> [string|array]', [
                    key1,
                    key2
                ], arguments.length);
                __classPrivateFieldGet(this, _YargsInstance_validation, "f").conflicts(key1, key2);
                return this;
            }
            config(key = 'config', msg, parseFn) {
                argsert('[object|string] [string|function] [function]', [
                    key,
                    msg,
                    parseFn
                ], arguments.length);
                if ('object' == typeof key && !Array.isArray(key)) {
                    key = (0, apply_extends.J)(key, __classPrivateFieldGet(this, _YargsInstance_cwd, "f"), this[kGetParserConfiguration]()['deep-merge-config'] || false, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
                    __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = (__classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || []).concat(key);
                    return this;
                }
                if ('function' == typeof msg) {
                    parseFn = msg;
                    msg = void 0;
                }
                this.describe(key, msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup('Path to JSON config file'));
                (Array.isArray(key) ? key : [
                    key
                ]).forEach((k)=>{
                    __classPrivateFieldGet(this, _YargsInstance_options, "f").config[k] = parseFn || true;
                });
                return this;
            }
            completion(cmd, desc, fn) {
                argsert('[string] [string|boolean|function] [function]', [
                    cmd,
                    desc,
                    fn
                ], arguments.length);
                if ('function' == typeof desc) {
                    fn = desc;
                    desc = void 0;
                }
                __classPrivateFieldSet(this, _YargsInstance_completionCommand, cmd || __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") || 'completion', "f");
                if (!desc && false !== desc) desc = "generate completion script";
                this.command(__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f"), desc);
                if (fn) __classPrivateFieldGet(this, _YargsInstance_completion, "f").registerFunction(fn);
                return this;
            }
            command(cmd, description, builder, handler, middlewares, deprecated) {
                argsert('<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]', [
                    cmd,
                    description,
                    builder,
                    handler,
                    middlewares,
                    deprecated
                ], arguments.length);
                __classPrivateFieldGet(this, _YargsInstance_command, "f").addHandler(cmd, description, builder, handler, middlewares, deprecated);
                return this;
            }
            commands(cmd, description, builder, handler, middlewares, deprecated) {
                return this.command(cmd, description, builder, handler, middlewares, deprecated);
            }
            commandDir(dir, opts) {
                argsert('<string> [object]', [
                    dir,
                    opts
                ], arguments.length);
                const req = __classPrivateFieldGet(this, _YargsInstance_parentRequire, "f") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").require;
                __classPrivateFieldGet(this, _YargsInstance_command, "f").addDirectory(dir, req, __classPrivateFieldGet(this, _YargsInstance_shim, "f").getCallerFile(), opts);
                return this;
            }
            count(keys) {
                argsert('<array|string>', [
                    keys
                ], arguments.length);
                this[kPopulateParserHintArray]('count', keys);
                this[kTrackManuallySetKeys](keys);
                return this;
            }
            default(key, value, defaultDescription) {
                argsert('<object|string|array> [*] [string]', [
                    key,
                    value,
                    defaultDescription
                ], arguments.length);
                if (defaultDescription) {
                    assertSingleKey(key, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
                    __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = defaultDescription;
                }
                if ('function' == typeof value) {
                    assertSingleKey(key, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
                    if (!__classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key]) __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = __classPrivateFieldGet(this, _YargsInstance_usage, "f").functionDescription(value);
                    value = value.call();
                }
                this[kPopulateParserHintSingleValueDictionary](this.default.bind(this), 'default', key, value);
                return this;
            }
            defaults(key, value, defaultDescription) {
                return this.default(key, value, defaultDescription);
            }
            demandCommand(min = 1, max, minMsg, maxMsg) {
                argsert('[number] [number|string] [string|null|undefined] [string|null|undefined]', [
                    min,
                    max,
                    minMsg,
                    maxMsg
                ], arguments.length);
                if ('number' != typeof max) {
                    minMsg = max;
                    max = 1 / 0;
                }
                this.global('_', false);
                __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedCommands._ = {
                    min,
                    max,
                    minMsg,
                    maxMsg
                };
                return this;
            }
            demand(keys, max, msg) {
                if (Array.isArray(max)) {
                    max.forEach((key)=>{
                        assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
                        this.demandOption(key, msg);
                    });
                    max = 1 / 0;
                } else if ('number' != typeof max) {
                    msg = max;
                    max = 1 / 0;
                }
                if ('number' == typeof keys) {
                    assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
                    this.demandCommand(keys, max, msg, msg);
                } else if (Array.isArray(keys)) keys.forEach((key)=>{
                    assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
                    this.demandOption(key, msg);
                });
                else if ('string' == typeof msg) this.demandOption(keys, msg);
                else if (true === msg || void 0 === msg) this.demandOption(keys);
                return this;
            }
            demandOption(keys, msg) {
                argsert('<object|string|array> [string]', [
                    keys,
                    msg
                ], arguments.length);
                this[kPopulateParserHintSingleValueDictionary](this.demandOption.bind(this), 'demandedOptions', keys, msg);
                return this;
            }
            deprecateOption(option, message) {
                argsert('<string> [string|boolean]', [
                    option,
                    message
                ], arguments.length);
                __classPrivateFieldGet(this, _YargsInstance_options, "f").deprecatedOptions[option] = message;
                return this;
            }
            describe(keys, description) {
                argsert('<object|string|array> [string]', [
                    keys,
                    description
                ], arguments.length);
                this[kSetKey](keys, true);
                __classPrivateFieldGet(this, _YargsInstance_usage, "f").describe(keys, description);
                return this;
            }
            detectLocale(detect) {
                argsert('<boolean>', [
                    detect
                ], arguments.length);
                __classPrivateFieldSet(this, _YargsInstance_detectLocale, detect, "f");
                return this;
            }
            env(prefix) {
                argsert('[string|boolean]', [
                    prefix
                ], arguments.length);
                if (false === prefix) delete __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix;
                else __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix = prefix || '';
                return this;
            }
            epilogue(msg) {
                argsert('<string>', [
                    msg
                ], arguments.length);
                __classPrivateFieldGet(this, _YargsInstance_usage, "f").epilog(msg);
                return this;
            }
            epilog(msg) {
                return this.epilogue(msg);
            }
            example(cmd, description) {
                argsert('<string|array> [string]', [
                    cmd,
                    description
                ], arguments.length);
                if (Array.isArray(cmd)) cmd.forEach((exampleParams)=>this.example(...exampleParams));
                else __classPrivateFieldGet(this, _YargsInstance_usage, "f").example(cmd, description);
                return this;
            }
            exit(code, err) {
                __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
                __classPrivateFieldSet(this, _YargsInstance_exitError, err, "f");
                if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f")) __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.exit(code);
            }
            exitProcess(enabled = true) {
                argsert('[boolean]', [
                    enabled
                ], arguments.length);
                __classPrivateFieldSet(this, _YargsInstance_exitProcess, enabled, "f");
                return this;
            }
            fail(f) {
                argsert('<function|boolean>', [
                    f
                ], arguments.length);
                if ('boolean' == typeof f && false !== f) throw new yerror.s("Invalid first argument. Expected function or boolean 'false'");
                __classPrivateFieldGet(this, _YargsInstance_usage, "f").failFn(f);
                return this;
            }
            getAliases() {
                return this.parsed ? this.parsed.aliases : {};
            }
            async getCompletion(args, done) {
                argsert('<array> [function]', [
                    args,
                    done
                ], arguments.length);
                if (!done) return new Promise((resolve, reject)=>{
                    __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(args, (err, completions)=>{
                        if (err) reject(err);
                        else resolve(completions);
                    });
                });
                return __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(args, done);
            }
            getDemandedOptions() {
                argsert([], 0);
                return __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedOptions;
            }
            getDemandedCommands() {
                argsert([], 0);
                return __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedCommands;
            }
            getDeprecatedOptions() {
                argsert([], 0);
                return __classPrivateFieldGet(this, _YargsInstance_options, "f").deprecatedOptions;
            }
            getDetectLocale() {
                return __classPrivateFieldGet(this, _YargsInstance_detectLocale, "f");
            }
            getExitProcess() {
                return __classPrivateFieldGet(this, _YargsInstance_exitProcess, "f");
            }
            getGroups() {
                return Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_groups, "f"), __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f"));
            }
            getHelp() {
                __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
                if (!__classPrivateFieldGet(this, _YargsInstance_usage, "f").hasCachedHelpMessage()) {
                    if (!this.parsed) {
                        const parse = this[kRunYargsParserAndExecuteCommands](__classPrivateFieldGet(this, _YargsInstance_processArgs, "f"), void 0, void 0, 0, true);
                        if (isPromise(parse)) return parse.then(()=>__classPrivateFieldGet(this, _YargsInstance_usage, "f").help());
                    }
                    const builderResponse = __classPrivateFieldGet(this, _YargsInstance_command, "f").runDefaultBuilderOn(this);
                    if (isPromise(builderResponse)) return builderResponse.then(()=>__classPrivateFieldGet(this, _YargsInstance_usage, "f").help());
                }
                return Promise.resolve(__classPrivateFieldGet(this, _YargsInstance_usage, "f").help());
            }
            getOptions() {
                return __classPrivateFieldGet(this, _YargsInstance_options, "f");
            }
            getStrict() {
                return __classPrivateFieldGet(this, _YargsInstance_strict, "f");
            }
            getStrictCommands() {
                return __classPrivateFieldGet(this, _YargsInstance_strictCommands, "f");
            }
            getStrictOptions() {
                return __classPrivateFieldGet(this, _YargsInstance_strictOptions, "f");
            }
            global(globals, global) {
                argsert('<string|array> [boolean]', [
                    globals,
                    global
                ], arguments.length);
                globals = [].concat(globals);
                if (false !== global) __classPrivateFieldGet(this, _YargsInstance_options, "f").local = __classPrivateFieldGet(this, _YargsInstance_options, "f").local.filter((l)=>-1 === globals.indexOf(l));
                else globals.forEach((g)=>{
                    if (!__classPrivateFieldGet(this, _YargsInstance_options, "f").local.includes(g)) __classPrivateFieldGet(this, _YargsInstance_options, "f").local.push(g);
                });
                return this;
            }
            group(opts, groupName) {
                argsert('<string|array> <string>', [
                    opts,
                    groupName
                ], arguments.length);
                const existing = __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName] || __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName];
                if (__classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName]) delete __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName];
                const seen = {};
                __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName] = (existing || []).concat(opts).filter((key)=>{
                    if (seen[key]) return false;
                    return seen[key] = true;
                });
                return this;
            }
            hide(key) {
                argsert('<string>', [
                    key
                ], arguments.length);
                __classPrivateFieldGet(this, _YargsInstance_options, "f").hiddenOptions.push(key);
                return this;
            }
            implies(key, value) {
                argsert('<string|object> [number|string|array]', [
                    key,
                    value
                ], arguments.length);
                __classPrivateFieldGet(this, _YargsInstance_validation, "f").implies(key, value);
                return this;
            }
            locale(locale) {
                argsert('[string]', [
                    locale
                ], arguments.length);
                if (void 0 === locale) {
                    this[kGuessLocale]();
                    return __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.getLocale();
                }
                __classPrivateFieldSet(this, _YargsInstance_detectLocale, false, "f");
                __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.setLocale(locale);
                return this;
            }
            middleware(callback, applyBeforeValidation, global) {
                return __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").addMiddleware(callback, !!applyBeforeValidation, global);
            }
            nargs(key, value) {
                argsert('<string|object|array> [number]', [
                    key,
                    value
                ], arguments.length);
                this[kPopulateParserHintSingleValueDictionary](this.nargs.bind(this), 'narg', key, value);
                return this;
            }
            normalize(keys) {
                argsert('<array|string>', [
                    keys
                ], arguments.length);
                this[kPopulateParserHintArray]('normalize', keys);
                return this;
            }
            number(keys) {
                argsert('<array|string>', [
                    keys
                ], arguments.length);
                this[kPopulateParserHintArray]('number', keys);
                this[kTrackManuallySetKeys](keys);
                return this;
            }
            option(key, opt) {
                argsert('<string|object> [object]', [
                    key,
                    opt
                ], arguments.length);
                if ('object' == typeof key) Object.keys(key).forEach((k)=>{
                    this.options(k, key[k]);
                });
                else {
                    if ('object' != typeof opt) opt = {};
                    this[kTrackManuallySetKeys](key);
                    if (__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f") && ('version' === key || (null == opt ? void 0 : opt.alias) === 'version')) this[kEmitWarning]('"version" is a reserved word.\nPlease do one of the following:\n- Disable version with `yargs.version(false)` if using "version" as an option\n- Use the built-in `yargs.version` method instead (if applicable)\n- Use a different option key\nhttps://yargs.js.org/docs/#api-reference-version', void 0, 'versionWarning');
                    __classPrivateFieldGet(this, _YargsInstance_options, "f").key[key] = true;
                    if (opt.alias) this.alias(key, opt.alias);
                    const deprecate = opt.deprecate || opt.deprecated;
                    if (deprecate) this.deprecateOption(key, deprecate);
                    const demand = opt.demand || opt.required || opt.require;
                    if (demand) this.demand(key, demand);
                    if (opt.demandOption) this.demandOption(key, 'string' == typeof opt.demandOption ? opt.demandOption : void 0);
                    if (opt.conflicts) this.conflicts(key, opt.conflicts);
                    if ('default' in opt) this.default(key, opt.default);
                    if (void 0 !== opt.implies) this.implies(key, opt.implies);
                    if (void 0 !== opt.nargs) this.nargs(key, opt.nargs);
                    if (opt.config) this.config(key, opt.configParser);
                    if (opt.normalize) this.normalize(key);
                    if (opt.choices) this.choices(key, opt.choices);
                    if (opt.coerce) this.coerce(key, opt.coerce);
                    if (opt.group) this.group(key, opt.group);
                    if (opt.boolean || 'boolean' === opt.type) {
                        this.boolean(key);
                        if (opt.alias) this.boolean(opt.alias);
                    }
                    if (opt.array || 'array' === opt.type) {
                        this.array(key);
                        if (opt.alias) this.array(opt.alias);
                    }
                    if (opt.number || 'number' === opt.type) {
                        this.number(key);
                        if (opt.alias) this.number(opt.alias);
                    }
                    if (opt.string || 'string' === opt.type) {
                        this.string(key);
                        if (opt.alias) this.string(opt.alias);
                    }
                    if (opt.count || 'count' === opt.type) this.count(key);
                    if ('boolean' == typeof opt.global) this.global(key, opt.global);
                    if (opt.defaultDescription) __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = opt.defaultDescription;
                    if (opt.skipValidation) this.skipValidation(key);
                    const desc = opt.describe || opt.description || opt.desc;
                    const descriptions = __classPrivateFieldGet(this, _YargsInstance_usage, "f").getDescriptions();
                    if (!Object.prototype.hasOwnProperty.call(descriptions, key) || 'string' == typeof desc) this.describe(key, desc);
                    if (opt.hidden) this.hide(key);
                    if (opt.requiresArg) this.requiresArg(key);
                }
                return this;
            }
            options(key, opt) {
                return this.option(key, opt);
            }
            parse(args, shortCircuit, _parseFn) {
                argsert('[string|array] [function|boolean|object] [function]', [
                    args,
                    shortCircuit,
                    _parseFn
                ], arguments.length);
                this[kFreeze]();
                if (void 0 === args) args = __classPrivateFieldGet(this, _YargsInstance_processArgs, "f");
                if ('object' == typeof shortCircuit) {
                    __classPrivateFieldSet(this, _YargsInstance_parseContext, shortCircuit, "f");
                    shortCircuit = _parseFn;
                }
                if ('function' == typeof shortCircuit) {
                    __classPrivateFieldSet(this, _YargsInstance_parseFn, shortCircuit, "f");
                    shortCircuit = false;
                }
                if (!shortCircuit) __classPrivateFieldSet(this, _YargsInstance_processArgs, args, "f");
                if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f")) __classPrivateFieldSet(this, _YargsInstance_exitProcess, false, "f");
                const parsed = this[kRunYargsParserAndExecuteCommands](args, !!shortCircuit);
                const tmpParsed = this.parsed;
                __classPrivateFieldGet(this, _YargsInstance_completion, "f").setParsed(this.parsed);
                if (isPromise(parsed)) return parsed.then((argv)=>{
                    if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f")) __classPrivateFieldGet(this, _YargsInstance_parseFn, "f").call(this, __classPrivateFieldGet(this, _YargsInstance_exitError, "f"), argv, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
                    return argv;
                }).catch((err)=>{
                    if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f")) __classPrivateFieldGet(this, _YargsInstance_parseFn, "f")(err, this.parsed.argv, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
                    throw err;
                }).finally(()=>{
                    this[kUnfreeze]();
                    this.parsed = tmpParsed;
                });
                if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f")) __classPrivateFieldGet(this, _YargsInstance_parseFn, "f").call(this, __classPrivateFieldGet(this, _YargsInstance_exitError, "f"), parsed, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
                this[kUnfreeze]();
                this.parsed = tmpParsed;
                return parsed;
            }
            parseAsync(args, shortCircuit, _parseFn) {
                const maybePromise = this.parse(args, shortCircuit, _parseFn);
                return isPromise(maybePromise) ? maybePromise : Promise.resolve(maybePromise);
            }
            parseSync(args, shortCircuit, _parseFn) {
                const maybePromise = this.parse(args, shortCircuit, _parseFn);
                if (isPromise(maybePromise)) throw new yerror.s('.parseSync() must not be used with asynchronous builders, handlers, or middleware');
                return maybePromise;
            }
            parserConfiguration(config) {
                argsert('<object>', [
                    config
                ], arguments.length);
                __classPrivateFieldSet(this, _YargsInstance_parserConfig, config, "f");
                return this;
            }
            pkgConf(key, rootPath) {
                argsert('<string> [string]', [
                    key,
                    rootPath
                ], arguments.length);
                let conf = null;
                const obj = this[kPkgUp](rootPath || __classPrivateFieldGet(this, _YargsInstance_cwd, "f"));
                if (obj[key] && 'object' == typeof obj[key]) {
                    conf = (0, apply_extends.J)(obj[key], rootPath || __classPrivateFieldGet(this, _YargsInstance_cwd, "f"), this[kGetParserConfiguration]()['deep-merge-config'] || false, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
                    __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = (__classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || []).concat(conf);
                }
                return this;
            }
            positional(key, opts) {
                argsert('<string> <object>', [
                    key,
                    opts
                ], arguments.length);
                const supportedOpts = [
                    'default',
                    "defaultDescription",
                    'implies',
                    'normalize',
                    'choices',
                    'conflicts',
                    'coerce',
                    'type',
                    'describe',
                    'desc',
                    "description",
                    'alias'
                ];
                opts = objFilter(opts, (k, v)=>{
                    if ('type' === k && ![
                        'string',
                        'number',
                        'boolean'
                    ].includes(v)) return false;
                    return supportedOpts.includes(k);
                });
                const fullCommand = __classPrivateFieldGet(this, _YargsInstance_context, "f").fullCommands[__classPrivateFieldGet(this, _YargsInstance_context, "f").fullCommands.length - 1];
                const parseOptions = fullCommand ? __classPrivateFieldGet(this, _YargsInstance_command, "f").cmdToParseOptions(fullCommand) : {
                    array: [],
                    alias: {},
                    default: {},
                    demand: {}
                };
                objectKeys(parseOptions).forEach((pk)=>{
                    const parseOption = parseOptions[pk];
                    if (Array.isArray(parseOption)) {
                        if (-1 !== parseOption.indexOf(key)) opts[pk] = true;
                    } else if (parseOption[key] && !(pk in opts)) opts[pk] = parseOption[key];
                });
                this.group(key, __classPrivateFieldGet(this, _YargsInstance_usage, "f").getPositionalGroupName());
                return this.option(key, opts);
            }
            recommendCommands(recommend = true) {
                argsert('[boolean]', [
                    recommend
                ], arguments.length);
                __classPrivateFieldSet(this, _YargsInstance_recommendCommands, recommend, "f");
                return this;
            }
            required(keys, max, msg) {
                return this.demand(keys, max, msg);
            }
            require(keys, max, msg) {
                return this.demand(keys, max, msg);
            }
            requiresArg(keys) {
                argsert('<array|string|object> [number]', [
                    keys
                ], arguments.length);
                'string' == typeof keys && __classPrivateFieldGet(this, _YargsInstance_options, "f").narg[keys] || this[kPopulateParserHintSingleValueDictionary](this.requiresArg.bind(this), 'narg', keys, NaN);
                return this;
            }
            showCompletionScript($0, cmd) {
                argsert('[string] [string]', [
                    $0,
                    cmd
                ], arguments.length);
                $0 = $0 || this.$0;
                __classPrivateFieldGet(this, _YargsInstance_logger, "f").log(__classPrivateFieldGet(this, _YargsInstance_completion, "f").generateCompletionScript($0, cmd || __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") || 'completion'));
                return this;
            }
            showHelp(level) {
                argsert('[string|function]', [
                    level
                ], arguments.length);
                __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
                if (!__classPrivateFieldGet(this, _YargsInstance_usage, "f").hasCachedHelpMessage()) {
                    if (!this.parsed) {
                        const parse = this[kRunYargsParserAndExecuteCommands](__classPrivateFieldGet(this, _YargsInstance_processArgs, "f"), void 0, void 0, 0, true);
                        if (isPromise(parse)) {
                            parse.then(()=>{
                                __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
                            });
                            return this;
                        }
                    }
                    const builderResponse = __classPrivateFieldGet(this, _YargsInstance_command, "f").runDefaultBuilderOn(this);
                    if (isPromise(builderResponse)) {
                        builderResponse.then(()=>{
                            __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
                        });
                        return this;
                    }
                }
                __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
                return this;
            }
            scriptName(scriptName) {
                this.customScriptName = true;
                this.$0 = scriptName;
                return this;
            }
            showHelpOnFail(enabled, message) {
                argsert('[boolean|string] [string]', [
                    enabled,
                    message
                ], arguments.length);
                __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelpOnFail(enabled, message);
                return this;
            }
            showVersion(level) {
                argsert('[string|function]', [
                    level
                ], arguments.length);
                __classPrivateFieldGet(this, _YargsInstance_usage, "f").showVersion(level);
                return this;
            }
            skipValidation(keys) {
                argsert('<array|string>', [
                    keys
                ], arguments.length);
                this[kPopulateParserHintArray]('skipValidation', keys);
                return this;
            }
            strict(enabled) {
                argsert('[boolean]', [
                    enabled
                ], arguments.length);
                __classPrivateFieldSet(this, _YargsInstance_strict, false !== enabled, "f");
                return this;
            }
            strictCommands(enabled) {
                argsert('[boolean]', [
                    enabled
                ], arguments.length);
                __classPrivateFieldSet(this, _YargsInstance_strictCommands, false !== enabled, "f");
                return this;
            }
            strictOptions(enabled) {
                argsert('[boolean]', [
                    enabled
                ], arguments.length);
                __classPrivateFieldSet(this, _YargsInstance_strictOptions, false !== enabled, "f");
                return this;
            }
            string(keys) {
                argsert('<array|string>', [
                    keys
                ], arguments.length);
                this[kPopulateParserHintArray]('string', keys);
                this[kTrackManuallySetKeys](keys);
                return this;
            }
            terminalWidth() {
                argsert([], 0);
                return __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.stdColumns;
            }
            updateLocale(obj) {
                return this.updateStrings(obj);
            }
            updateStrings(obj) {
                argsert('<object>', [
                    obj
                ], arguments.length);
                __classPrivateFieldSet(this, _YargsInstance_detectLocale, false, "f");
                __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.updateLocale(obj);
                return this;
            }
            usage(msg, description, builder, handler) {
                argsert('<string|null|undefined> [string|boolean] [function|object] [function]', [
                    msg,
                    description,
                    builder,
                    handler
                ], arguments.length);
                if (void 0 !== description) {
                    assertNotStrictEqual(msg, null, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
                    if ((msg || '').match(/^\$0( |$)/)) return this.command(msg, description, builder, handler);
                    throw new yerror.s(".usage() description must start with $0 if being used as alias for .command()");
                }
                __classPrivateFieldGet(this, _YargsInstance_usage, "f").usage(msg);
                return this;
            }
            usageConfiguration(config) {
                argsert('<object>', [
                    config
                ], arguments.length);
                __classPrivateFieldSet(this, _YargsInstance_usageConfig, config, "f");
                return this;
            }
            version(opt, msg, ver) {
                const defaultVersionOpt = 'version';
                argsert('[boolean|string] [string] [string]', [
                    opt,
                    msg,
                    ver
                ], arguments.length);
                if (__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f")) {
                    this[kDeleteFromParserHintObject](__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"));
                    __classPrivateFieldGet(this, _YargsInstance_usage, "f").version(void 0);
                    __classPrivateFieldSet(this, _YargsInstance_versionOpt, null, "f");
                }
                if (0 === arguments.length) {
                    ver = this[kGuessVersion]();
                    opt = defaultVersionOpt;
                } else if (1 === arguments.length) {
                    if (false === opt) return this;
                    ver = opt;
                    opt = defaultVersionOpt;
                } else if (2 === arguments.length) {
                    ver = msg;
                    msg = void 0;
                }
                __classPrivateFieldSet(this, _YargsInstance_versionOpt, 'string' == typeof opt ? opt : defaultVersionOpt, "f");
                msg = msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup('Show version number');
                __classPrivateFieldGet(this, _YargsInstance_usage, "f").version(ver || void 0);
                this.boolean(__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"));
                this.describe(__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"), msg);
                return this;
            }
            wrap(cols) {
                argsert('<number|null|undefined>', [
                    cols
                ], arguments.length);
                __classPrivateFieldGet(this, _YargsInstance_usage, "f").wrap(cols);
                return this;
            }
            [(_YargsInstance_command = new WeakMap(), _YargsInstance_cwd = new WeakMap(), _YargsInstance_context = new WeakMap(), _YargsInstance_completion = new WeakMap(), _YargsInstance_completionCommand = new WeakMap(), _YargsInstance_defaultShowHiddenOpt = new WeakMap(), _YargsInstance_exitError = new WeakMap(), _YargsInstance_detectLocale = new WeakMap(), _YargsInstance_emittedWarnings = new WeakMap(), _YargsInstance_exitProcess = new WeakMap(), _YargsInstance_frozens = new WeakMap(), _YargsInstance_globalMiddleware = new WeakMap(), _YargsInstance_groups = new WeakMap(), _YargsInstance_hasOutput = new WeakMap(), _YargsInstance_helpOpt = new WeakMap(), _YargsInstance_isGlobalContext = new WeakMap(), _YargsInstance_logger = new WeakMap(), _YargsInstance_output = new WeakMap(), _YargsInstance_options = new WeakMap(), _YargsInstance_parentRequire = new WeakMap(), _YargsInstance_parserConfig = new WeakMap(), _YargsInstance_parseFn = new WeakMap(), _YargsInstance_parseContext = new WeakMap(), _YargsInstance_pkgs = new WeakMap(), _YargsInstance_preservedGroups = new WeakMap(), _YargsInstance_processArgs = new WeakMap(), _YargsInstance_recommendCommands = new WeakMap(), _YargsInstance_shim = new WeakMap(), _YargsInstance_strict = new WeakMap(), _YargsInstance_strictCommands = new WeakMap(), _YargsInstance_strictOptions = new WeakMap(), _YargsInstance_usage = new WeakMap(), _YargsInstance_usageConfig = new WeakMap(), _YargsInstance_versionOpt = new WeakMap(), _YargsInstance_validation = new WeakMap(), kCopyDoubleDash)](argv) {
                if (!argv._ || !argv['--']) return argv;
                argv._.push.apply(argv._, argv['--']);
                try {
                    delete argv['--'];
                } catch (_err) {}
                return argv;
            }
            [kCreateLogger]() {
                return {
                    log: (...args)=>{
                        if (!this[kHasParseCallback]()) console.log(...args);
                        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
                        if (__classPrivateFieldGet(this, _YargsInstance_output, "f").length) __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + '\n', "f");
                        __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + args.join(' '), "f");
                    },
                    error: (...args)=>{
                        if (!this[kHasParseCallback]()) console.error(...args);
                        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
                        if (__classPrivateFieldGet(this, _YargsInstance_output, "f").length) __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + '\n', "f");
                        __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + args.join(' '), "f");
                    }
                };
            }
            [kDeleteFromParserHintObject](optionKey) {
                objectKeys(__classPrivateFieldGet(this, _YargsInstance_options, "f")).forEach((hintKey)=>{
                    if (((key)=>'configObjects' === key)(hintKey)) return;
                    const hint = __classPrivateFieldGet(this, _YargsInstance_options, "f")[hintKey];
                    if (Array.isArray(hint)) {
                        if (hint.includes(optionKey)) hint.splice(hint.indexOf(optionKey), 1);
                    } else if ('object' == typeof hint) delete hint[optionKey];
                });
                delete __classPrivateFieldGet(this, _YargsInstance_usage, "f").getDescriptions()[optionKey];
            }
            [kEmitWarning](warning, type, deduplicationId) {
                if (!__classPrivateFieldGet(this, _YargsInstance_emittedWarnings, "f")[deduplicationId]) {
                    __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.emitWarning(warning, type);
                    __classPrivateFieldGet(this, _YargsInstance_emittedWarnings, "f")[deduplicationId] = true;
                }
            }
            [kFreeze]() {
                __classPrivateFieldGet(this, _YargsInstance_frozens, "f").push({
                    options: __classPrivateFieldGet(this, _YargsInstance_options, "f"),
                    configObjects: __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects.slice(0),
                    exitProcess: __classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"),
                    groups: __classPrivateFieldGet(this, _YargsInstance_groups, "f"),
                    strict: __classPrivateFieldGet(this, _YargsInstance_strict, "f"),
                    strictCommands: __classPrivateFieldGet(this, _YargsInstance_strictCommands, "f"),
                    strictOptions: __classPrivateFieldGet(this, _YargsInstance_strictOptions, "f"),
                    completionCommand: __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f"),
                    output: __classPrivateFieldGet(this, _YargsInstance_output, "f"),
                    exitError: __classPrivateFieldGet(this, _YargsInstance_exitError, "f"),
                    hasOutput: __classPrivateFieldGet(this, _YargsInstance_hasOutput, "f"),
                    parsed: this.parsed,
                    parseFn: __classPrivateFieldGet(this, _YargsInstance_parseFn, "f"),
                    parseContext: __classPrivateFieldGet(this, _YargsInstance_parseContext, "f")
                });
                __classPrivateFieldGet(this, _YargsInstance_usage, "f").freeze();
                __classPrivateFieldGet(this, _YargsInstance_validation, "f").freeze();
                __classPrivateFieldGet(this, _YargsInstance_command, "f").freeze();
                __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").freeze();
            }
            [kGetDollarZero]() {
                let $0 = '';
                let default$0;
                default$0 = /\b(node|iojs|electron)(\.exe)?$/.test(__classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv()[0]) ? __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv().slice(1, 2) : __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv().slice(0, 1);
                $0 = default$0.map((x)=>{
                    const b = this[kRebase](__classPrivateFieldGet(this, _YargsInstance_cwd, "f"), x);
                    return x.match(/^(\/|([a-zA-Z]:)?\\)/) && b.length < x.length ? b : x;
                }).join(' ').trim();
                if (__classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('_') && __classPrivateFieldGet(this, _YargsInstance_shim, "f").getProcessArgvBin() === __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('_')) $0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('_').replace(`${__classPrivateFieldGet(this, _YargsInstance_shim, "f").path.dirname(__classPrivateFieldGet(this, _YargsInstance_shim, "f").process.execPath())}/`, '');
                return $0;
            }
            [kGetParserConfiguration]() {
                return __classPrivateFieldGet(this, _YargsInstance_parserConfig, "f");
            }
            [kGetUsageConfiguration]() {
                return __classPrivateFieldGet(this, _YargsInstance_usageConfig, "f");
            }
            [kGuessLocale]() {
                if (!__classPrivateFieldGet(this, _YargsInstance_detectLocale, "f")) return;
                const locale = __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('LC_ALL') || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('LC_MESSAGES') || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('LANG') || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv('LANGUAGE') || 'en_US';
                this.locale(locale.replace(/[.:].*/, ''));
            }
            [kGuessVersion]() {
                const obj = this[kPkgUp]();
                return obj.version || 'unknown';
            }
            [kParsePositionalNumbers](argv) {
                const args = argv['--'] ? argv['--'] : argv._;
                for(let i = 0, arg; void 0 !== (arg = args[i]); i++)if (__classPrivateFieldGet(this, _YargsInstance_shim, "f").Parser.looksLikeNumber(arg) && Number.isSafeInteger(Math.floor(parseFloat(`${arg}`)))) args[i] = Number(arg);
                return argv;
            }
            [kPkgUp](rootPath) {
                const npath = rootPath || '*';
                if (__classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath]) return __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath];
                let obj = {};
                try {
                    let startDir = rootPath || __classPrivateFieldGet(this, _YargsInstance_shim, "f").mainFilename;
                    if (!rootPath && __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.extname(startDir)) startDir = __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.dirname(startDir);
                    const pkgJsonPath = __classPrivateFieldGet(this, _YargsInstance_shim, "f").findUp(startDir, (dir, names)=>{
                        if (names.includes('package.json')) return 'package.json';
                    });
                    assertNotStrictEqual(pkgJsonPath, void 0, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
                    obj = JSON.parse(__classPrivateFieldGet(this, _YargsInstance_shim, "f").readFileSync(pkgJsonPath, 'utf8'));
                } catch (_noop) {}
                __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath] = obj || {};
                return __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath];
            }
            [kPopulateParserHintArray](type, keys) {
                keys = [].concat(keys);
                keys.forEach((key)=>{
                    key = this[kSanitizeKey](key);
                    __classPrivateFieldGet(this, _YargsInstance_options, "f")[type].push(key);
                });
            }
            [kPopulateParserHintSingleValueDictionary](builder, type, key, value) {
                this[kPopulateParserHintDictionary](builder, type, key, value, (type, key, value)=>{
                    __classPrivateFieldGet(this, _YargsInstance_options, "f")[type][key] = value;
                });
            }
            [kPopulateParserHintArrayDictionary](builder, type, key, value) {
                this[kPopulateParserHintDictionary](builder, type, key, value, (type, key, value)=>{
                    __classPrivateFieldGet(this, _YargsInstance_options, "f")[type][key] = (__classPrivateFieldGet(this, _YargsInstance_options, "f")[type][key] || []).concat(value);
                });
            }
            [kPopulateParserHintDictionary](builder, type, key, value, singleKeyHandler) {
                if (Array.isArray(key)) key.forEach((k)=>{
                    builder(k, value);
                });
                else if (((key)=>'object' == typeof key)(key)) for (const k of objectKeys(key))builder(k, key[k]);
                else singleKeyHandler(type, this[kSanitizeKey](key), value);
            }
            [kSanitizeKey](key) {
                if ('__proto__' === key) return '___proto___';
                return key;
            }
            [kSetKey](key, set) {
                this[kPopulateParserHintSingleValueDictionary](this[kSetKey].bind(this), 'key', key, set);
                return this;
            }
            [kUnfreeze]() {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
                const frozen = __classPrivateFieldGet(this, _YargsInstance_frozens, "f").pop();
                assertNotStrictEqual(frozen, void 0, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
                let configObjects;
                _a = this, _b = this, _c = this, _d = this, _e = this, _f = this, _g = this, _h = this, _j = this, _k = this, _l = this, _m = this, { options: ({
                    set value (_o){
                        __classPrivateFieldSet(_a, _YargsInstance_options, _o, "f");
                    }
                }).value, configObjects, exitProcess: ({
                    set value (_o){
                        __classPrivateFieldSet(_b, _YargsInstance_exitProcess, _o, "f");
                    }
                }).value, groups: ({
                    set value (_o){
                        __classPrivateFieldSet(_c, _YargsInstance_groups, _o, "f");
                    }
                }).value, output: ({
                    set value (_o){
                        __classPrivateFieldSet(_d, _YargsInstance_output, _o, "f");
                    }
                }).value, exitError: ({
                    set value (_o){
                        __classPrivateFieldSet(_e, _YargsInstance_exitError, _o, "f");
                    }
                }).value, hasOutput: ({
                    set value (_o){
                        __classPrivateFieldSet(_f, _YargsInstance_hasOutput, _o, "f");
                    }
                }).value, parsed: this.parsed, strict: ({
                    set value (_o){
                        __classPrivateFieldSet(_g, _YargsInstance_strict, _o, "f");
                    }
                }).value, strictCommands: ({
                    set value (_o){
                        __classPrivateFieldSet(_h, _YargsInstance_strictCommands, _o, "f");
                    }
                }).value, strictOptions: ({
                    set value (_o){
                        __classPrivateFieldSet(_j, _YargsInstance_strictOptions, _o, "f");
                    }
                }).value, completionCommand: ({
                    set value (_o){
                        __classPrivateFieldSet(_k, _YargsInstance_completionCommand, _o, "f");
                    }
                }).value, parseFn: ({
                    set value (_o){
                        __classPrivateFieldSet(_l, _YargsInstance_parseFn, _o, "f");
                    }
                }).value, parseContext: ({
                    set value (_o){
                        __classPrivateFieldSet(_m, _YargsInstance_parseContext, _o, "f");
                    }
                }).value } = frozen;
                __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = configObjects;
                __classPrivateFieldGet(this, _YargsInstance_usage, "f").unfreeze();
                __classPrivateFieldGet(this, _YargsInstance_validation, "f").unfreeze();
                __classPrivateFieldGet(this, _YargsInstance_command, "f").unfreeze();
                __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").unfreeze();
            }
            [kValidateAsync](validation, argv) {
                return maybeAsyncResult(argv, (result)=>{
                    validation(result);
                    return result;
                });
            }
            getInternalMethods() {
                return {
                    getCommandInstance: this[kGetCommandInstance].bind(this),
                    getContext: this[kGetContext].bind(this),
                    getHasOutput: this[kGetHasOutput].bind(this),
                    getLoggerInstance: this[kGetLoggerInstance].bind(this),
                    getParseContext: this[kGetParseContext].bind(this),
                    getParserConfiguration: this[kGetParserConfiguration].bind(this),
                    getUsageConfiguration: this[kGetUsageConfiguration].bind(this),
                    getUsageInstance: this[kGetUsageInstance].bind(this),
                    getValidationInstance: this[kGetValidationInstance].bind(this),
                    hasParseCallback: this[kHasParseCallback].bind(this),
                    isGlobalContext: this[kIsGlobalContext].bind(this),
                    postProcess: this[kPostProcess].bind(this),
                    reset: this[kReset].bind(this),
                    runValidation: this[kRunValidation].bind(this),
                    runYargsParserAndExecuteCommands: this[kRunYargsParserAndExecuteCommands].bind(this),
                    setHasOutput: this[kSetHasOutput].bind(this)
                };
            }
            [kGetCommandInstance]() {
                return __classPrivateFieldGet(this, _YargsInstance_command, "f");
            }
            [kGetContext]() {
                return __classPrivateFieldGet(this, _YargsInstance_context, "f");
            }
            [kGetHasOutput]() {
                return __classPrivateFieldGet(this, _YargsInstance_hasOutput, "f");
            }
            [kGetLoggerInstance]() {
                return __classPrivateFieldGet(this, _YargsInstance_logger, "f");
            }
            [kGetParseContext]() {
                return __classPrivateFieldGet(this, _YargsInstance_parseContext, "f") || {};
            }
            [kGetUsageInstance]() {
                return __classPrivateFieldGet(this, _YargsInstance_usage, "f");
            }
            [kGetValidationInstance]() {
                return __classPrivateFieldGet(this, _YargsInstance_validation, "f");
            }
            [kHasParseCallback]() {
                return !!__classPrivateFieldGet(this, _YargsInstance_parseFn, "f");
            }
            [kIsGlobalContext]() {
                return __classPrivateFieldGet(this, _YargsInstance_isGlobalContext, "f");
            }
            [kPostProcess](argv, populateDoubleDash, calledFromCommand, runGlobalMiddleware) {
                if (calledFromCommand) return argv;
                if (isPromise(argv)) return argv;
                if (!populateDoubleDash) argv = this[kCopyDoubleDash](argv);
                const parsePositionalNumbers = this[kGetParserConfiguration]()['parse-positional-numbers'] || void 0 === this[kGetParserConfiguration]()['parse-positional-numbers'];
                if (parsePositionalNumbers) argv = this[kParsePositionalNumbers](argv);
                if (runGlobalMiddleware) argv = applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), false);
                return argv;
            }
            [kReset](aliases = {}) {
                __classPrivateFieldSet(this, _YargsInstance_options, __classPrivateFieldGet(this, _YargsInstance_options, "f") || {}, "f");
                const tmpOptions = {};
                tmpOptions.local = __classPrivateFieldGet(this, _YargsInstance_options, "f").local || [];
                tmpOptions.configObjects = __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || [];
                const localLookup = {};
                tmpOptions.local.forEach((l)=>{
                    localLookup[l] = true;
                    (aliases[l] || []).forEach((a)=>{
                        localLookup[a] = true;
                    });
                });
                Object.assign(__classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f"), Object.keys(__classPrivateFieldGet(this, _YargsInstance_groups, "f")).reduce((acc, groupName)=>{
                    const keys = __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName].filter((key)=>!(key in localLookup));
                    if (keys.length > 0) acc[groupName] = keys;
                    return acc;
                }, {}));
                __classPrivateFieldSet(this, _YargsInstance_groups, {}, "f");
                const arrayOptions = [
                    'array',
                    'boolean',
                    'string',
                    'skipValidation',
                    'count',
                    'normalize',
                    'number',
                    'hiddenOptions'
                ];
                const objectOptions = [
                    'narg',
                    'key',
                    'alias',
                    'default',
                    "defaultDescription",
                    'config',
                    'choices',
                    'demandedOptions',
                    'demandedCommands',
                    'deprecatedOptions'
                ];
                arrayOptions.forEach((k)=>{
                    tmpOptions[k] = (__classPrivateFieldGet(this, _YargsInstance_options, "f")[k] || []).filter((k)=>!localLookup[k]);
                });
                objectOptions.forEach((k)=>{
                    tmpOptions[k] = objFilter(__classPrivateFieldGet(this, _YargsInstance_options, "f")[k], (k)=>!localLookup[k]);
                });
                tmpOptions.envPrefix = __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix;
                __classPrivateFieldSet(this, _YargsInstance_options, tmpOptions, "f");
                __classPrivateFieldSet(this, _YargsInstance_usage, __classPrivateFieldGet(this, _YargsInstance_usage, "f") ? __classPrivateFieldGet(this, _YargsInstance_usage, "f").reset(localLookup) : usage_usage(this, __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
                __classPrivateFieldSet(this, _YargsInstance_validation, __classPrivateFieldGet(this, _YargsInstance_validation, "f") ? __classPrivateFieldGet(this, _YargsInstance_validation, "f").reset(localLookup) : validation_validation(this, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
                __classPrivateFieldSet(this, _YargsInstance_command, __classPrivateFieldGet(this, _YargsInstance_command, "f") ? __classPrivateFieldGet(this, _YargsInstance_command, "f").reset() : command_command(__classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_validation, "f"), __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
                if (!__classPrivateFieldGet(this, _YargsInstance_completion, "f")) __classPrivateFieldSet(this, _YargsInstance_completion, completion_completion(this, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_command, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
                __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").reset();
                __classPrivateFieldSet(this, _YargsInstance_completionCommand, null, "f");
                __classPrivateFieldSet(this, _YargsInstance_output, '', "f");
                __classPrivateFieldSet(this, _YargsInstance_exitError, null, "f");
                __classPrivateFieldSet(this, _YargsInstance_hasOutput, false, "f");
                this.parsed = false;
                return this;
            }
            [kRebase](base, dir) {
                return __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.relative(base, dir);
            }
            [kRunYargsParserAndExecuteCommands](args, shortCircuit, calledFromCommand, commandIndex = 0, helpOnly = false) {
                let skipValidation = !!calledFromCommand || helpOnly;
                args = args || __classPrivateFieldGet(this, _YargsInstance_processArgs, "f");
                __classPrivateFieldGet(this, _YargsInstance_options, "f").__ = __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.__;
                __classPrivateFieldGet(this, _YargsInstance_options, "f").configuration = this[kGetParserConfiguration]();
                const populateDoubleDash = !!__classPrivateFieldGet(this, _YargsInstance_options, "f").configuration['populate--'];
                const config = Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_options, "f").configuration, {
                    'populate--': true
                });
                const parsed = __classPrivateFieldGet(this, _YargsInstance_shim, "f").Parser.detailed(args, Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_options, "f"), {
                    configuration: {
                        'parse-positional-numbers': false,
                        ...config
                    }
                }));
                const argv = Object.assign(parsed.argv, __classPrivateFieldGet(this, _YargsInstance_parseContext, "f"));
                let argvPromise;
                const aliases = parsed.aliases;
                let helpOptSet = false;
                let versionOptSet = false;
                Object.keys(argv).forEach((key)=>{
                    if (key === __classPrivateFieldGet(this, _YargsInstance_helpOpt, "f") && argv[key]) helpOptSet = true;
                    else if (key === __classPrivateFieldGet(this, _YargsInstance_versionOpt, "f") && argv[key]) versionOptSet = true;
                });
                argv.$0 = this.$0;
                this.parsed = parsed;
                if (0 === commandIndex) __classPrivateFieldGet(this, _YargsInstance_usage, "f").clearCachedHelpMessage();
                try {
                    this[kGuessLocale]();
                    if (shortCircuit) return this[kPostProcess](argv, populateDoubleDash, !!calledFromCommand, false);
                    if (__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")) {
                        const helpCmds = [
                            __classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")
                        ].concat(aliases[__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")] || []).filter((k)=>k.length > 1);
                        if (helpCmds.includes('' + argv._[argv._.length - 1])) {
                            argv._.pop();
                            helpOptSet = true;
                        }
                    }
                    __classPrivateFieldSet(this, _YargsInstance_isGlobalContext, false, "f");
                    const handlerKeys = __classPrivateFieldGet(this, _YargsInstance_command, "f").getCommands();
                    const requestCompletions = __classPrivateFieldGet(this, _YargsInstance_completion, "f").completionKey in argv;
                    const skipRecommendation = helpOptSet || requestCompletions || helpOnly;
                    if (argv._.length) {
                        if (handlerKeys.length) {
                            let firstUnknownCommand;
                            for(let i = commandIndex || 0, cmd; void 0 !== argv._[i]; i++){
                                cmd = String(argv._[i]);
                                if (handlerKeys.includes(cmd) && cmd !== __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) {
                                    const innerArgv = __classPrivateFieldGet(this, _YargsInstance_command, "f").runCommand(cmd, this, parsed, i + 1, helpOnly, helpOptSet || versionOptSet || helpOnly);
                                    return this[kPostProcess](innerArgv, populateDoubleDash, !!calledFromCommand, false);
                                }
                                if (!firstUnknownCommand && cmd !== __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) {
                                    firstUnknownCommand = cmd;
                                    break;
                                }
                            }
                            if (!__classPrivateFieldGet(this, _YargsInstance_command, "f").hasDefaultCommand() && __classPrivateFieldGet(this, _YargsInstance_recommendCommands, "f") && firstUnknownCommand && !skipRecommendation) __classPrivateFieldGet(this, _YargsInstance_validation, "f").recommendCommands(firstUnknownCommand, handlerKeys);
                        }
                        if (__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") && argv._.includes(__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) && !requestCompletions) {
                            if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f")) setBlocking(true);
                            this.showCompletionScript();
                            this.exit(0);
                        }
                    }
                    if (__classPrivateFieldGet(this, _YargsInstance_command, "f").hasDefaultCommand() && !skipRecommendation) {
                        const innerArgv = __classPrivateFieldGet(this, _YargsInstance_command, "f").runCommand(null, this, parsed, 0, helpOnly, helpOptSet || versionOptSet || helpOnly);
                        return this[kPostProcess](innerArgv, populateDoubleDash, !!calledFromCommand, false);
                    }
                    if (requestCompletions) {
                        if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f")) setBlocking(true);
                        args = [].concat(args);
                        const completionArgs = args.slice(args.indexOf(`--${__classPrivateFieldGet(this, _YargsInstance_completion, "f").completionKey}`) + 1);
                        __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(completionArgs, (err, completions)=>{
                            if (err) throw new yerror.s(err.message);
                            (completions || []).forEach((completion)=>{
                                __classPrivateFieldGet(this, _YargsInstance_logger, "f").log(completion);
                            });
                            this.exit(0);
                        });
                        return this[kPostProcess](argv, !populateDoubleDash, !!calledFromCommand, false);
                    }
                    if (!__classPrivateFieldGet(this, _YargsInstance_hasOutput, "f")) {
                        if (helpOptSet) {
                            if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f")) setBlocking(true);
                            skipValidation = true;
                            this.showHelp('log');
                            this.exit(0);
                        } else if (versionOptSet) {
                            if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f")) setBlocking(true);
                            skipValidation = true;
                            __classPrivateFieldGet(this, _YargsInstance_usage, "f").showVersion('log');
                            this.exit(0);
                        }
                    }
                    if (!skipValidation && __classPrivateFieldGet(this, _YargsInstance_options, "f").skipValidation.length > 0) skipValidation = Object.keys(argv).some((key)=>__classPrivateFieldGet(this, _YargsInstance_options, "f").skipValidation.indexOf(key) >= 0 && true === argv[key]);
                    if (!skipValidation) {
                        if (parsed.error) throw new yerror.s(parsed.error.message);
                        if (!requestCompletions) {
                            const validation = this[kRunValidation](aliases, {}, parsed.error);
                            if (!calledFromCommand) argvPromise = applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), true);
                            argvPromise = this[kValidateAsync](validation, null != argvPromise ? argvPromise : argv);
                            if (isPromise(argvPromise) && !calledFromCommand) argvPromise = argvPromise.then(()=>applyMiddleware(argv, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), false));
                        }
                    }
                } catch (err) {
                    if (err instanceof yerror.s) __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(err.message, err);
                    else throw err;
                }
                return this[kPostProcess](null != argvPromise ? argvPromise : argv, populateDoubleDash, !!calledFromCommand, true);
            }
            [kRunValidation](aliases, positionalMap, parseErrors, isDefaultCommand) {
                const demandedOptions = {
                    ...this.getDemandedOptions()
                };
                return (argv)=>{
                    if (parseErrors) throw new yerror.s(parseErrors.message);
                    __classPrivateFieldGet(this, _YargsInstance_validation, "f").nonOptionCount(argv);
                    __classPrivateFieldGet(this, _YargsInstance_validation, "f").requiredArguments(argv, demandedOptions);
                    let failedStrictCommands = false;
                    if (__classPrivateFieldGet(this, _YargsInstance_strictCommands, "f")) failedStrictCommands = __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownCommands(argv);
                    if (__classPrivateFieldGet(this, _YargsInstance_strict, "f") && !failedStrictCommands) __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownArguments(argv, aliases, positionalMap, !!isDefaultCommand);
                    else if (__classPrivateFieldGet(this, _YargsInstance_strictOptions, "f")) __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownArguments(argv, aliases, {}, false, false);
                    __classPrivateFieldGet(this, _YargsInstance_validation, "f").limitedChoices(argv);
                    __classPrivateFieldGet(this, _YargsInstance_validation, "f").implications(argv);
                    __classPrivateFieldGet(this, _YargsInstance_validation, "f").conflicting(argv);
                };
            }
            [kSetHasOutput]() {
                __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
            }
            [kTrackManuallySetKeys](keys) {
                if ('string' == typeof keys) __classPrivateFieldGet(this, _YargsInstance_options, "f").key[keys] = true;
                else for (const k of keys)__classPrivateFieldGet(this, _YargsInstance_options, "f").key[k] = true;
            }
        }
        function isYargsInstance(y) {
            return !!y && 'function' == typeof y.getInternalMethods;
        }
        const Yargs = YargsFactory(esm.Z);
        const node_modules_yargs = Yargs;
    }
};

//# sourceMappingURL=856.js.map