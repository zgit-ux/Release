"use strict";
self["webpackHotUpdate_agent_tars_web_ui"]("index", {
"./src/entry.css": (function (module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
// extracted by css-extract-rspack-plugin

    if(true) {
      (function() {
        var localsJsonString = undefined;
        // 1749586876774
        var cssReload = (__webpack_require__("../node_modules/.pnpm/@rspack+core@1.3.9_@swc+helpers@0.5.17/node_modules/@rspack/core/dist/cssExtractHmr.js")/* .cssReload */.cssReload)(module.id, {});
        // only invalidate when locals change
        if (
          module.hot.data &&
          module.hot.data.value &&
          module.hot.data.value !== localsJsonString
        ) {
          module.hot.invalidate();
        } else {
          module.hot.accept();
        }
        module.hot.dispose(function(data) {
          data.value = localsJsonString;
          cssReload();
        });
      })();
    }
  

}),
"./src/v2/state/actions/sessionActions.ts": (function (module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  abortQueryAction: () => (abortQueryAction),
  checkSessionStatusAction: () => (checkSessionStatusAction),
  createSessionAction: () => (createSessionAction),
  deleteSessionAction: () => (deleteSessionAction),
  loadSessionsAction: () => (loadSessionsAction),
  sendMessageAction: () => (sendMessageAction),
  setActiveSessionAction: () => (setActiveSessionAction),
  updateSessionAction: () => (updateSessionAction)
});
/* ESM import */var jotai__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("../node_modules/.pnpm/jotai@2.12.5_@types+react@18.3.23_react@18.3.1/node_modules/jotai/esm/vanilla.mjs");
/* ESM import */var uuid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/v4.js");
/* ESM import */var _services_apiService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/v2/services/apiService.ts");
/* ESM import */var _atoms_session__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/v2/state/atoms/session.ts");
/* ESM import */var _atoms_message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/v2/state/atoms/message.ts");
/* ESM import */var _atoms_tool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/v2/state/atoms/tool.ts");
/* ESM import */var _atoms_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/v2/state/atoms/ui.ts");
/* ESM import */var _eventProcessor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/v2/state/actions/eventProcessor.ts");
/* ESM import */var _atoms_replay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/v2/state/atoms/replay.ts");
/* provided dependency */ var $ReactRefreshRuntime$ = __webpack_require__("../node_modules/.pnpm/@rspack+plugin-react-refresh@1.0.3_react-refresh@0.16.0/node_modules/@rspack/plugin-react-refresh/client/reactRefresh.js");








 // 假设 connectionStatusAtom 已经存在
 // 添加引入回放状态atom
/**
 * Load all available sessions
 */ const loadSessionsAction = (0,jotai__WEBPACK_IMPORTED_MODULE_7__.atom)(null, async (get, set)=>{
    try {
        const loadedSessions = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.getSessions();
        set(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.sessionsAtom, loadedSessions);
    } catch (error) {
        console.error('Failed to load sessions:', error);
        throw error;
    }
});
/**
 * Create a new session
 */ const createSessionAction = (0,jotai__WEBPACK_IMPORTED_MODULE_7__.atom)(null, async (get, set)=>{
    try {
        const newSession = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.createSession();
        // Add to sessions list
        set(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.sessionsAtom, (prev)=>[
                newSession,
                ...prev
            ]);
        // Initialize session data
        set(_atoms_message__WEBPACK_IMPORTED_MODULE_2__.messagesAtom, (prev)=>({
                ...prev,
                [newSession.id]: []
            }));
        set(_atoms_tool__WEBPACK_IMPORTED_MODULE_3__.toolResultsAtom, (prev)=>({
                ...prev,
                [newSession.id]: []
            }));
        // Set as active session
        set(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.activeSessionIdAtom, newSession.id);
        return newSession.id;
    } catch (error) {
        console.error('Failed to create session:', error);
        throw error;
    }
});
/**
 * Set the active session
 * 简化加载逻辑，移除恢复会话的复杂性
 */ const setActiveSessionAction = (0,jotai__WEBPACK_IMPORTED_MODULE_7__.atom)(null, async (get, set, sessionId)=>{
    try {
        // 检查是否已经是活动会话
        const currentActiveSessionId = get(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.activeSessionIdAtom);
        if (currentActiveSessionId === sessionId) {
            console.log(`Session ${sessionId} is already active, skipping load`);
            return;
        }
        // 检查回放状态并退出回放模式（除非是同一会话）
        const replayState = get(_atoms_replay__WEBPACK_IMPORTED_MODULE_6__.replayStateAtom);
        if (replayState.isActive) {
            console.log('Exiting replay mode due to session change');
            set(_atoms_replay__WEBPACK_IMPORTED_MODULE_6__.replayStateAtom, {
                isActive: false,
                isPaused: true,
                events: [],
                currentEventIndex: -1,
                startTimestamp: null,
                endTimestamp: null,
                playbackSpeed: 1,
                visibleTimeWindow: null,
                processedEvents: {}
            });
        }
        // 直接获取会话详情，不需要检查 active 状态
        const sessionDetails = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.getSessionDetails(sessionId);
        // 获取当前会话状态以更新 isProcessing 状态
        try {
            const status = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.getSessionStatus(sessionId);
            set(_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.isProcessingAtom, status.isProcessing);
        } catch (error) {
            console.warn('Failed to get session status:', error);
            set(_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.isProcessingAtom, false);
        }
        // 清理工具调用映射缓存
        _atoms_tool__WEBPACK_IMPORTED_MODULE_3__.toolCallResultMap.clear();
        // 只有在消息不存在时才加载会话事件
        const messages = get(_atoms_message__WEBPACK_IMPORTED_MODULE_2__.messagesAtom);
        if (!messages[sessionId] || messages[sessionId].length === 0) {
            console.log(`Loading events for session ${sessionId}`);
            const events = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.getSessionEvents(sessionId);
            // 对流式事件进行预处理，确保正确的连续性
            const processedEvents = preprocessStreamingEvents(events);
            // 处理每个事件以构建消息和工具结果
            for (const event of processedEvents){
                set(_eventProcessor__WEBPACK_IMPORTED_MODULE_5__.processEventAction, {
                    sessionId,
                    event
                });
            }
        } else {
            console.log(`Session ${sessionId} already has messages, skipping event loading`);
        }
        // 设置为活动会话
        set(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.activeSessionIdAtom, sessionId);
    } catch (error) {
        console.error('Failed to set active session:', error);
        set(_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.connectionStatusAtom, (prev)=>({
                ...prev,
                connected: false,
                lastError: error instanceof Error ? error.message : String(error)
            }));
        throw error;
    }
});
/**
 * Update session metadata
 */ const updateSessionAction = (0,jotai__WEBPACK_IMPORTED_MODULE_7__.atom)(null, async (get, set, params)=>{
    const { sessionId, updates } = params;
    try {
        const updatedSession = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.updateSessionMetadata(sessionId, updates);
        // Update session in the list
        set(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.sessionsAtom, (prev)=>prev.map((session)=>session.id === sessionId ? {
                    ...session,
                    ...updatedSession
                } : session));
        return updatedSession;
    } catch (error) {
        console.error('Failed to update session:', error);
        throw error;
    }
});
/**
 * 预处理事件，确保流式事件按正确顺序处理
 */ function preprocessStreamingEvents(events) {
    // 对流式消息进行整理
    const messageStreams = {};
    // 收集所有流式事件，按messageId分组
    events.forEach((event)=>{
        if (event.type === 'final_answer_streaming' && 'messageId' in event) {
            const messageId = event.messageId;
            if (!messageStreams[messageId]) {
                messageStreams[messageId] = [];
            }
            messageStreams[messageId].push(event);
        }
    });
    // 返回预处理后的事件，确保流式事件以正确顺序处理
    return events;
}
/**
 * Delete a session
 */ const deleteSessionAction = (0,jotai__WEBPACK_IMPORTED_MODULE_7__.atom)(null, async (get, set, sessionId)=>{
    try {
        const success = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.deleteSession(sessionId);
        const activeSessionId = get(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.activeSessionIdAtom);
        if (success) {
            // Remove from sessions list
            set(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.sessionsAtom, (prev)=>prev.filter((session)=>session.id !== sessionId));
            // Clear active session if it was deleted
            if (activeSessionId === sessionId) {
                set(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.activeSessionIdAtom, null);
            }
            // Clear session data
            set(_atoms_message__WEBPACK_IMPORTED_MODULE_2__.messagesAtom, (prev)=>{
                const newMessages = {
                    ...prev
                };
                delete newMessages[sessionId];
                return newMessages;
            });
            set(_atoms_tool__WEBPACK_IMPORTED_MODULE_3__.toolResultsAtom, (prev)=>{
                const newResults = {
                    ...prev
                };
                delete newResults[sessionId];
                return newResults;
            });
        }
        return success;
    } catch (error) {
        console.error('Failed to delete session:', error);
        throw error;
    }
});
/**
 * Send a message in the current session
 */ const sendMessageAction = (0,jotai__WEBPACK_IMPORTED_MODULE_7__.atom)(null, async (get, set, content)=>{
    const activeSessionId = get(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.activeSessionIdAtom);
    if (!activeSessionId) {
        throw new Error('No active session');
    }
    // 明确设置处理状态
    set(_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.isProcessingAtom, true);
    // 添加用户消息到状态
    const userMessage = {
        id: (0,uuid__WEBPACK_IMPORTED_MODULE_8__["default"])(),
        role: 'user',
        content,
        timestamp: Date.now()
    };
    set(_atoms_message__WEBPACK_IMPORTED_MODULE_2__.messagesAtom, (prev)=>{
        const sessionMessages = prev[activeSessionId] || [];
        return {
            ...prev,
            [activeSessionId]: [
                ...sessionMessages,
                userMessage
            ]
        };
    });
    // 立即更新会话名称，使用用户查询作为 Summary
    // 这样即使后续更新失败也至少有一个基本的名称
    try {
        // 检查是否是第一条消息，如果是则直接用查询内容作为会话名称
        const messages = get(_atoms_message__WEBPACK_IMPORTED_MODULE_2__.messagesAtom)[activeSessionId] || [];
        if (messages.length <= 2) {
            // 算上刚刚添加的用户消息
            let summary = '';
            if (typeof content === 'string') {
                summary = content.length > 50 ? content.substring(0, 47) + '...' : content;
            } else {
                // 从多模态内容中提取文本部分
                const textPart = content.find((part)=>part.type === 'text');
                if (textPart && 'text' in textPart) {
                    summary = textPart.text.length > 50 ? textPart.text.substring(0, 47) + '...' : textPart.text;
                } else {
                    summary = 'Image message';
                }
            }
            await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.updateSessionMetadata(activeSessionId, {
                name: summary
            });
            // 更新 sessions atom
            set(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.sessionsAtom, (prev)=>prev.map((session)=>session.id === activeSessionId ? {
                        ...session,
                        name: summary
                    } : session));
        }
    } catch (error) {
        console.log('Failed to update initial summary, continuing anyway:', error);
    // 错误不中断主流程
    }
    try {
        // 使用流式查询
        await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.sendStreamingQuery(activeSessionId, content, (event)=>{
            // 处理每个事件
            set(_eventProcessor__WEBPACK_IMPORTED_MODULE_5__.processEventAction, {
                sessionId: activeSessionId,
                event
            });
            // 确保状态保持为处理中，直到明确收到结束事件
            if (event.type !== 'agent_run_end' && event.type !== 'assistant_message') {
                set(_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.isProcessingAtom, true);
            }
        });
    } catch (error) {
        console.error('Error sending message:', error);
        // 错误时重置处理状态
        set(_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.isProcessingAtom, false);
        throw error;
    }
});
/**
 * Abort the current running query
 */ const abortQueryAction = (0,jotai__WEBPACK_IMPORTED_MODULE_7__.atom)(null, async (get, set)=>{
    const activeSessionId = get(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.activeSessionIdAtom);
    if (!activeSessionId) {
        return false;
    }
    try {
        const success = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.abortQuery(activeSessionId);
        if (success) {
            set(_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.isProcessingAtom, false);
            // Add system message about abort
            const abortMessage = {
                id: (0,uuid__WEBPACK_IMPORTED_MODULE_8__["default"])(),
                role: 'system',
                content: 'The operation was aborted.',
                timestamp: Date.now()
            };
            set(_atoms_message__WEBPACK_IMPORTED_MODULE_2__.messagesAtom, (prev)=>{
                const sessionMessages = prev[activeSessionId] || [];
                return {
                    ...prev,
                    [activeSessionId]: [
                        ...sessionMessages,
                        abortMessage
                    ]
                };
            });
        }
        return success;
    } catch (error) {
        console.error('Error aborting query:', error);
        return false;
    }
});
/**
 * Check the current status of a session
 */ const checkSessionStatusAction = (0,jotai__WEBPACK_IMPORTED_MODULE_7__.atom)(null, async (get, set, sessionId)=>{
    if (!sessionId) return;
    try {
        console.log(`Checking status for session: ${sessionId}`);
        const status = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.getSessionStatus(sessionId);
        console.log(`Status for session ${sessionId}:`, status);
        // 根据服务器响应更新处理状态
        set(_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.isProcessingAtom, status.isProcessing);
        return status;
    } catch (error) {
        console.error('Failed to check session status:', error);
    // 错误时不更新处理状态，避免误报
    }
});
/**
 * Handle the end of a conversation
 * 仍然保留此函数，但减少其重要性，避免更新失败带来的影响
 */ async function handleConversationEnd(get, set, sessionId) {
    // 我们不再依赖这个函数来设置会话名称，但仍然保留它作为备份机制
    const allMessages = get(_atoms_message__WEBPACK_IMPORTED_MODULE_2__.messagesAtom)[sessionId] || [];
    // 只在有足够的消息并且会话没有名称时才尝试生成摘要
    const sessions = get(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.sessionsAtom);
    const currentSession = sessions.find((s)=>s.id === sessionId);
    // 如果会话已经有名称，则不需要再生成
    if (currentSession && currentSession.name) {
        return;
    }
    // 只在有实际对话时才尝试生成摘要
    if (allMessages.length > 1) {
        try {
            // 转换消息为 API 期望的格式
            const apiMessages = allMessages.map((msg)=>({
                    role: msg.role,
                    content: typeof msg.content === 'string' ? msg.content : 'multimodal content'
                }));
            // 生成摘要
            const summary = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.generateSummary(sessionId, apiMessages);
            if (summary) {
                // 更新会话名称
                await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.updateSessionMetadata(sessionId, {
                    name: summary
                });
                // 更新 sessions atom
                set(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.sessionsAtom, (prev)=>prev.map((session)=>session.id === sessionId ? {
                            ...session,
                            name: summary
                        } : session));
            }
        } catch (error) {
            console.error('Failed to generate or update summary, continuing anyway:', error);
        // 错误不影响主流程
        }
    }
}

function $RefreshSig$() {
  return $ReactRefreshRuntime$.createSignatureFunctionForTransform();
}
function $RefreshReg$(type, id) {
  $ReactRefreshRuntime$.register(type, module.id + "_" + id);
}
Promise.resolve().then(function() {
  $ReactRefreshRuntime$.refresh(module.id, module.hot);
});


}),

},function(__webpack_require__) {
// webpack/runtime/get_full_hash
(() => {
__webpack_require__.h = () => ("c23511fe6d0b1361")
})();

}
);
//# sourceMappingURL=index.c668ca95dd3dddd7.hot-update.js.map