"use strict";
self["webpackHotUpdate_agent_tars_web_ui"]("index", {
"./src/entry.css": (function (module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
// extracted by css-extract-rspack-plugin

    if(true) {
      (function() {
        var localsJsonString = undefined;
        // 1751741453537
        var cssReload = (__webpack_require__("../node_modules/.pnpm/@rspack+core@1.3.9_@swc+helpers@0.5.17/node_modules/@rspack/core/dist/cssExtractHmr.js")/* .cssReload */.cssReload)(module.id, {});
        // only invalidate when locals change
        if (
          module.hot.data &&
          module.hot.data.value &&
          module.hot.data.value !== localsJsonString
        ) {
          module.hot.invalidate();
        } else {
          module.hot.accept();
        }
        module.hot.dispose(function(data) {
          data.value = localsJsonString;
          cssReload();
        });
      })();
    }
  

}),
"./src/common/hooks/useSession.ts": (function (module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  useSession: () => (useSession)
});
/* ESM import */var jotai__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("../node_modules/.pnpm/jotai@2.12.5_@types+react@18.3.23_react@18.3.1/node_modules/jotai/esm/react.mjs");
/* ESM import */var react_router_dom__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("../node_modules/.pnpm/react-router@7.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-router/dist/development/chunk-DQRVZFIR.mjs");
/* ESM import */var _state_atoms_session__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/common/state/atoms/session.ts");
/* ESM import */var _state_atoms_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/common/state/atoms/message.ts");
/* ESM import */var _state_atoms_tool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/common/state/atoms/tool.ts");
/* ESM import */var _state_atoms_plan__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/common/state/atoms/plan.ts");
/* ESM import */var _state_atoms_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/common/state/atoms/ui.ts");
/* ESM import */var _state_atoms_replay__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/common/state/atoms/replay.ts");
/* ESM import */var _state_actions_sessionActions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/common/state/actions/sessionActions.ts");
/* ESM import */var _state_actions_connectionActions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/common/state/actions/connectionActions.ts");
/* ESM import */var _services_socketService__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/common/services/socketService.ts");
/* ESM import */var react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* ESM import */var react__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_9__);
/* ESM import */var _hooks_useReplayMode__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./src/common/hooks/useReplayMode.tsx");
/* provided dependency */ var $ReactRefreshRuntime$ = __webpack_require__("../node_modules/.pnpm/@rspack+plugin-react-refresh@1.0.3_react-refresh@0.16.0/node_modules/@rspack/plugin-react-refresh/client/reactRefresh.js");













/**
 * Hook for session management functionality
 */ function useSession() {
    // State
    const [sessions, setSessions] = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useAtom)(_state_atoms_session__WEBPACK_IMPORTED_MODULE_0__.sessionsAtom);
    const [activeSessionId, setActiveSessionId] = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useAtom)(_state_atoms_session__WEBPACK_IMPORTED_MODULE_0__.activeSessionIdAtom);
    const messages = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useAtomValue)(_state_atoms_message__WEBPACK_IMPORTED_MODULE_1__.messagesAtom);
    const groupedMessages = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useAtomValue)(_state_atoms_message__WEBPACK_IMPORTED_MODULE_1__.groupedMessagesAtom);
    const toolResults = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useAtomValue)(_state_atoms_tool__WEBPACK_IMPORTED_MODULE_2__.toolResultsAtom);
    const streamingToolCalls = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useAtomValue)(_state_atoms_tool__WEBPACK_IMPORTED_MODULE_2__.streamingToolCallsAtom);
    const [isProcessing, setIsProcessing] = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useAtom)(_state_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.isProcessingAtom);
    const [activePanelContent, setActivePanelContent] = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useAtom)(_state_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.activePanelContentAtom);
    const [connectionStatus, setConnectionStatus] = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useAtom)(_state_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.connectionStatusAtom);
    const [plans, setPlans] = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useAtom)(_state_atoms_plan__WEBPACK_IMPORTED_MODULE_3__.plansAtom);
    const setPlanUIState = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useSetAtom)(_state_atoms_plan__WEBPACK_IMPORTED_MODULE_3__.planUIStateAtom);
    const [replayState, setReplayState] = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useAtom)(_state_atoms_replay__WEBPACK_IMPORTED_MODULE_5__.replayStateAtom);
    const modelInfo = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useAtomValue)(_state_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.modelInfoAtom);
    // Check if we're in replay mode using the context hook
    const isReplayMode = (0,_hooks_useReplayMode__WEBPACK_IMPORTED_MODULE_10__.useReplayMode)();
    // Actions
    const loadSessions = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useSetAtom)(_state_actions_sessionActions__WEBPACK_IMPORTED_MODULE_6__.loadSessionsAction);
    const createSession = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useSetAtom)(_state_actions_sessionActions__WEBPACK_IMPORTED_MODULE_6__.createSessionAction);
    const setActiveSession = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useSetAtom)(_state_actions_sessionActions__WEBPACK_IMPORTED_MODULE_6__.setActiveSessionAction);
    const updateSessionMetadata = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useSetAtom)(_state_actions_sessionActions__WEBPACK_IMPORTED_MODULE_6__.updateSessionAction);
    const deleteSession = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useSetAtom)(_state_actions_sessionActions__WEBPACK_IMPORTED_MODULE_6__.deleteSessionAction);
    const sendMessage = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useSetAtom)(_state_actions_sessionActions__WEBPACK_IMPORTED_MODULE_6__.sendMessageAction);
    const abortQuery = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useSetAtom)(_state_actions_sessionActions__WEBPACK_IMPORTED_MODULE_6__.abortQueryAction);
    const initConnectionMonitoring = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useSetAtom)(_state_actions_connectionActions__WEBPACK_IMPORTED_MODULE_7__.initConnectionMonitoringAction);
    const checkServerStatus = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useSetAtom)(_state_actions_connectionActions__WEBPACK_IMPORTED_MODULE_7__.checkConnectionStatusAction);
    const checkSessionStatus = (0,jotai__WEBPACK_IMPORTED_MODULE_11__.useSetAtom)(_state_actions_sessionActions__WEBPACK_IMPORTED_MODULE_6__.checkSessionStatusAction);
    // Get current location
    const location = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_12__.useLocation)();
    // 保留这个工具函数，但移除自动同步逻辑
    const getSessionIdFromUrl = (0,react__WEBPACK_IMPORTED_MODULE_9__.useCallback)(()=>{
        const pathParts = location.pathname.split('/').filter(Boolean);
        return pathParts.length > 0 ? pathParts[0] : null;
    }, [
        location
    ]);
    // Periodic status checking for active session - 在回放模式下不检查状态
    (0,react__WEBPACK_IMPORTED_MODULE_9__.useEffect)(()=>{
        if (!activeSessionId || !connectionStatus.connected || isReplayMode) return;
        // Initial status check when session becomes active
        checkSessionStatus(activeSessionId);
    }, [
        activeSessionId,
        connectionStatus.connected,
        checkSessionStatus,
        isReplayMode
    ]);
    // Enhanced socket handler for session status sync - 在回放模式下不更新状态
    const handleSessionStatusUpdate = (0,react__WEBPACK_IMPORTED_MODULE_9__.useCallback)((status)=>{
        if (status && typeof status.isProcessing === 'boolean' && !isReplayMode) {
            setIsProcessing(status.isProcessing);
        }
    }, [
        setIsProcessing,
        isReplayMode
    ]);
    // Set up socket event handlers when active session changes - 在回放模式下不设置socket事件处理
    (0,react__WEBPACK_IMPORTED_MODULE_9__.useEffect)(()=>{
        if (!activeSessionId || !_services_socketService__WEBPACK_IMPORTED_MODULE_8__.socketService.isConnected() || isReplayMode) return;
        // Join session and listen for status updates
        _services_socketService__WEBPACK_IMPORTED_MODULE_8__.socketService.joinSession(activeSessionId, ()=>{
        /* existing event handling */ }, handleSessionStatusUpdate);
        // Register global status handler
        _services_socketService__WEBPACK_IMPORTED_MODULE_8__.socketService.on('agent-status', handleSessionStatusUpdate);
        return ()=>{
            // Clean up handlers
            _services_socketService__WEBPACK_IMPORTED_MODULE_8__.socketService.off('agent-status', handleSessionStatusUpdate);
        };
    }, [
        activeSessionId,
        handleSessionStatusUpdate,
        isReplayMode
    ]);
    // Auto-show plan when it's first created - 在回放模式下不自动显示计划
    (0,react__WEBPACK_IMPORTED_MODULE_9__.useEffect)(()=>{
        var _plans_activeSessionId;
        if (activeSessionId && ((_plans_activeSessionId = plans[activeSessionId]) === null || _plans_activeSessionId === void 0 ? void 0 : _plans_activeSessionId.hasGeneratedPlan) && !isReplayMode) {
            const currentPlan = plans[activeSessionId];
            // If this is a newly generated plan, automatically show it
            if (currentPlan.steps.length > 0 && currentPlan.steps.every((step)=>!step.done)) {
                setPlanUIState((prev)=>({
                        ...prev,
                        isVisible: true
                    }));
            }
        }
    }, [
        activeSessionId,
        plans,
        setPlanUIState,
        isReplayMode
    ]);
    // Memoize the session state object to avoid unnecessary re-renders
    const sessionState = (0,react__WEBPACK_IMPORTED_MODULE_9__.useMemo)(()=>({
            // State
            sessions,
            activeSessionId,
            messages,
            groupedMessages,
            toolResults,
            streamingToolCalls,
            isProcessing,
            activePanelContent,
            connectionStatus,
            plans,
            replayState,
            modelInfo,
            // Session operations
            loadSessions,
            createSession,
            setActiveSession,
            updateSessionMetadata,
            deleteSession,
            // Message operations
            sendMessage,
            abortQuery,
            // UI operations
            setActivePanelContent,
            // Connection operations
            initConnectionMonitoring,
            checkServerStatus,
            // Status operations
            checkSessionStatus,
            getSessionIdFromUrl
        }), [
        sessions,
        activeSessionId,
        messages,
        groupedMessages,
        toolResults,
        streamingToolCalls,
        isProcessing,
        activePanelContent,
        connectionStatus,
        plans,
        replayState,
        modelInfo,
        loadSessions,
        createSession,
        setActiveSession,
        updateSessionMetadata,
        deleteSession,
        sendMessage,
        abortQuery,
        setActivePanelContent,
        initConnectionMonitoring,
        checkServerStatus,
        checkSessionStatus,
        getSessionIdFromUrl
    ]);
    return sessionState;
}

function $RefreshSig$() {
  return $ReactRefreshRuntime$.createSignatureFunctionForTransform();
}
function $RefreshReg$(type, id) {
  $ReactRefreshRuntime$.register(type, module.id + "_" + id);
}
Promise.resolve().then(function() {
  $ReactRefreshRuntime$.refresh(module.id, module.hot);
});


}),
"./src/common/services/apiService.ts": (function (module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  apiService: () => (apiService)
});
/* ESM import */var _common_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/common/constants/index.ts");
/* ESM import */var _socketService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/common/services/socketService.ts");
/* provided dependency */ var $ReactRefreshRuntime$ = __webpack_require__("../node_modules/.pnpm/@rspack+plugin-react-refresh@1.0.3_react-refresh@0.16.0/node_modules/@rspack/plugin-react-refresh/client/reactRefresh.js");


/**
 * API Service - Handles HTTP requests to the Agent TARS Server
 *
 * Provides methods for:
 * - Session management (create, get, update, delete)
 * - Query execution (streaming and non-streaming)
 * - Server health checks
 */ class ApiService {
    /**
   * Check server health status
   */ async checkServerHealth() {
        try {
            // Try ping through socket if connected
            if (_socketService__WEBPACK_IMPORTED_MODULE_1__.socketService.isConnected()) {
                const pingSuccessful = await _socketService__WEBPACK_IMPORTED_MODULE_1__.socketService.ping();
                if (pingSuccessful) return true;
            }
            // Fall back to API health endpoint
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.HEALTH}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                },
                signal: AbortSignal.timeout(3000)
            });
            return response.ok;
        } catch (error) {
            console.error('Error checking server health:', error);
            return false;
        }
    }
    /**
   * Create a new session
   */ async createSession() {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.CREATE_SESSION}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            if (!response.ok) {
                throw new Error(`Failed to create session: ${response.statusText}`);
            }
            const { sessionId } = await response.json();
            return this.getSessionDetails(sessionId);
        } catch (error) {
            console.error('Error creating session:', error);
            throw error;
        }
    }
    /**
   * Get all sessions
   */ async getSessions() {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.SESSIONS}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            if (!response.ok) {
                throw new Error(`Failed to get sessions: ${response.statusText}`);
            }
            const { sessions } = await response.json();
            return sessions;
        } catch (error) {
            console.error('Error getting sessions:', error);
            throw error;
        }
    }
    /**
   * Get details for a specific session
   */ async getSessionDetails(sessionId) {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.SESSION_DETAILS}?sessionId=${sessionId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                },
                signal: AbortSignal.timeout(5000)
            });
            if (!response.ok) {
                throw new Error(`Failed to get session details: ${response.statusText}`);
            }
            const { session } = await response.json();
            return session;
        } catch (error) {
            console.error(`Error getting session details (${sessionId}):`, error);
            throw error;
        }
    }
    /**
   * Get events for a specific session
   */ async getSessionEvents(sessionId) {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.SESSION_EVENTS}?sessionId=${sessionId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                },
                signal: AbortSignal.timeout(5000)
            });
            if (!response.ok) {
                throw new Error(`Failed to get session events: ${response.statusText}`);
            }
            const { events } = await response.json();
            return events;
        } catch (error) {
            console.error(`Error getting session events (${sessionId}):`, error);
            throw error;
        }
    }
    /**
   * Get current status of a session
   */ async getSessionStatus(sessionId) {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.SESSION_STATUS}?sessionId=${sessionId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                },
                signal: AbortSignal.timeout(3000)
            });
            if (!response.ok) {
                throw new Error(`Failed to get session status: ${response.statusText}`);
            }
            const { status } = await response.json();
            return status;
        } catch (error) {
            console.error(`Error getting session status (${sessionId}):`, error);
            throw error;
        }
    }
    /**
   * Update session metadata
   */ async updateSessionMetadata(sessionId, updates) {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.UPDATE_SESSION}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    sessionId,
                    ...updates
                })
            });
            if (!response.ok) {
                throw new Error(`Failed to update session: ${response.statusText}`);
            }
            const { session } = await response.json();
            return session;
        } catch (error) {
            console.error(`Error updating session (${sessionId}):`, error);
            throw error;
        }
    }
    /**
   * Delete a session
   */ async deleteSession(sessionId) {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.DELETE_SESSION}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    sessionId
                })
            });
            if (!response.ok) {
                throw new Error(`Failed to delete session: ${response.statusText}`);
            }
            const { success } = await response.json();
            return success;
        } catch (error) {
            console.error(`Error deleting session (${sessionId}):`, error);
            throw error;
        }
    }
    /**
   * Send a streaming query
   */ async sendStreamingQuery(sessionId, query, onEvent) {
        try {
            var _response_body;
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.QUERY_STREAM}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    sessionId,
                    query
                })
            });
            if (!response.ok) {
                throw new Error(`Failed to send query: ${response.statusText}`);
            }
            const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();
            if (!reader) {
                throw new Error('ReadableStream not supported');
            }
            const decoder = new TextDecoder();
            let buffer = '';
            while(true){
                const { done, value } = await reader.read();
                if (done) break;
                // Add the new chunk to the buffer
                buffer += decoder.decode(value, {
                    stream: true
                });
                // Process all complete events in the buffer
                let eventEndIndex;
                while((eventEndIndex = buffer.indexOf('\n\n')) !== -1){
                    const eventString = buffer.slice(0, eventEndIndex);
                    // Move buffer to the next event
                    buffer = buffer.slice(eventEndIndex + 2);
                    if (eventString.startsWith('data: ')) {
                        try {
                            const eventData = JSON.parse(eventString.substring(6));
                            onEvent(eventData);
                        } catch (e) {
                            console.error('Error parsing event data:', e);
                        }
                    }
                }
            }
        } catch (error) {
            console.error('Error in streaming query:', error);
            throw error;
        }
    }
    /**
   * Send a non-streaming query
   */ async sendQuery(sessionId, query) {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.QUERY}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    sessionId,
                    query
                })
            });
            if (!response.ok) {
                throw new Error(`Failed to send query: ${response.statusText}`);
            }
            const data = await response.json();
            return data.result;
        } catch (error) {
            console.error('Error sending query:', error);
            throw error;
        }
    }
    /**
   * Abort a running query
   */ async abortQuery(sessionId) {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.ABORT}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    sessionId
                })
            });
            if (!response.ok) {
                throw new Error(`Failed to abort query: ${response.statusText}`);
            }
            const data = await response.json();
            return data.success;
        } catch (error) {
            console.error('Error aborting query:', error);
            throw error;
        }
    }
    /**
   * Generate a summary for a conversation
   */ async generateSummary(sessionId, messages) {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.GENERATE_SUMMARY}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    sessionId,
                    messages
                })
            });
            if (!response.ok) {
                throw new Error(`Failed to generate summary: ${response.statusText}`);
            }
            const { summary } = await response.json();
            return summary;
        } catch (error) {
            console.error('Error generating summary:', error);
            return 'Untitled Conversation';
        }
    }
    /**
   * Get browser control information for a session
   */ async getBrowserControlInfo(sessionId) {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}/api/v1/sessions/browser-control?sessionId=${sessionId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                },
                signal: AbortSignal.timeout(3000)
            });
            if (!response.ok) {
                throw new Error(`Failed to get browser control info: ${response.statusText}`);
            }
            return await response.json();
        } catch (error) {
            console.error(`Error getting browser control info (${sessionId}):`, error);
            // 返回默认值作为回退
            return {
                mode: 'default',
                tools: []
            };
        }
    }
}
// Export singleton instance
const apiService = new ApiService();

function $RefreshSig$() {
  return $ReactRefreshRuntime$.createSignatureFunctionForTransform();
}
function $RefreshReg$(type, id) {
  $ReactRefreshRuntime$.register(type, module.id + "_" + id);
}
Promise.resolve().then(function() {
  $ReactRefreshRuntime$.refresh(module.id, module.hot);
});


}),
"./src/common/state/actions/connectionActions.ts": (function (module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  checkConnectionStatusAction: () => (checkConnectionStatusAction),
  initConnectionMonitoringAction: () => (initConnectionMonitoringAction)
});
/* ESM import */var jotai__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("../node_modules/.pnpm/jotai@2.12.5_@types+react@18.3.23_react@18.3.1/node_modules/jotai/esm/vanilla.mjs");
/* ESM import */var _common_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/common/constants/index.ts");
/* ESM import */var _services_apiService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/common/services/apiService.ts");
/* ESM import */var _services_socketService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/common/services/socketService.ts");
/* ESM import */var _atoms_ui__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/common/state/atoms/ui.ts");
/* provided dependency */ var $ReactRefreshRuntime$ = __webpack_require__("../node_modules/.pnpm/@rspack+plugin-react-refresh@1.0.3_react-refresh@0.16.0/node_modules/@rspack/plugin-react-refresh/client/reactRefresh.js");





/**
 * Check server connection status
 */ const checkConnectionStatusAction = (0,jotai__WEBPACK_IMPORTED_MODULE_4__.atom)(null, async (get, set)=>{
    const currentStatus = get(_atoms_ui__WEBPACK_IMPORTED_MODULE_3__.connectionStatusAtom);
    try {
        const isConnected = await _services_apiService__WEBPACK_IMPORTED_MODULE_1__.apiService.checkServerHealth();
        set(_atoms_ui__WEBPACK_IMPORTED_MODULE_3__.connectionStatusAtom, {
            ...currentStatus,
            connected: isConnected,
            lastConnected: isConnected ? Date.now() : currentStatus.lastConnected,
            lastError: isConnected ? null : currentStatus.lastError
        });
        return isConnected;
    } catch (error) {
        set(_atoms_ui__WEBPACK_IMPORTED_MODULE_3__.connectionStatusAtom, {
            ...currentStatus,
            connected: false,
            lastError: error instanceof Error ? error.message : String(error)
        });
        return false;
    }
});
/**
 * Initialize connection monitoring
 */ const initConnectionMonitoringAction = (0,jotai__WEBPACK_IMPORTED_MODULE_4__.atom)(null, (get, set)=>{
    // Perform initial check
    set(checkConnectionStatusAction);
    // Set up socket event listeners
    _services_socketService__WEBPACK_IMPORTED_MODULE_2__.socketService.on(_common_constants__WEBPACK_IMPORTED_MODULE_0__.SOCKET_EVENTS.CONNECT, ()=>{
        set(_atoms_ui__WEBPACK_IMPORTED_MODULE_3__.connectionStatusAtom, (prev)=>({
                ...prev,
                connected: true,
                lastConnected: Date.now(),
                lastError: null,
                reconnecting: false
            }));
    });
    _services_socketService__WEBPACK_IMPORTED_MODULE_2__.socketService.on(_common_constants__WEBPACK_IMPORTED_MODULE_0__.SOCKET_EVENTS.DISCONNECT, (reason)=>{
        set(_atoms_ui__WEBPACK_IMPORTED_MODULE_3__.connectionStatusAtom, (prev)=>({
                ...prev,
                connected: false,
                lastError: `Disconnected: ${reason}`,
                reconnecting: true
            }));
    });
    _services_socketService__WEBPACK_IMPORTED_MODULE_2__.socketService.on(_common_constants__WEBPACK_IMPORTED_MODULE_0__.SOCKET_EVENTS.RECONNECT_ATTEMPT, ()=>{
        set(_atoms_ui__WEBPACK_IMPORTED_MODULE_3__.connectionStatusAtom, (prev)=>({
                ...prev,
                reconnecting: true
            }));
    });
    _services_socketService__WEBPACK_IMPORTED_MODULE_2__.socketService.on(_common_constants__WEBPACK_IMPORTED_MODULE_0__.SOCKET_EVENTS.RECONNECT_FAILED, ()=>{
        set(_atoms_ui__WEBPACK_IMPORTED_MODULE_3__.connectionStatusAtom, (prev)=>({
                ...prev,
                connected: false,
                reconnecting: false,
                lastError: 'Failed to reconnect after multiple attempts'
            }));
    });
    // Set up periodic health checks
    const intervalId = setInterval(()=>{
        set(checkConnectionStatusAction);
    }, 30000); // Check every 30 seconds
    // Return cleanup function
    return ()=>{
        clearInterval(intervalId);
        _services_socketService__WEBPACK_IMPORTED_MODULE_2__.socketService.off(_common_constants__WEBPACK_IMPORTED_MODULE_0__.SOCKET_EVENTS.CONNECT, ()=>{});
        _services_socketService__WEBPACK_IMPORTED_MODULE_2__.socketService.off(_common_constants__WEBPACK_IMPORTED_MODULE_0__.SOCKET_EVENTS.DISCONNECT, ()=>{});
        _services_socketService__WEBPACK_IMPORTED_MODULE_2__.socketService.off(_common_constants__WEBPACK_IMPORTED_MODULE_0__.SOCKET_EVENTS.RECONNECT_ATTEMPT, ()=>{});
        _services_socketService__WEBPACK_IMPORTED_MODULE_2__.socketService.off(_common_constants__WEBPACK_IMPORTED_MODULE_0__.SOCKET_EVENTS.RECONNECT_FAILED, ()=>{});
    };
});

function $RefreshSig$() {
  return $ReactRefreshRuntime$.createSignatureFunctionForTransform();
}
function $RefreshReg$(type, id) {
  $ReactRefreshRuntime$.register(type, module.id + "_" + id);
}
Promise.resolve().then(function() {
  $ReactRefreshRuntime$.refresh(module.id, module.hot);
});


}),
"./src/common/state/actions/sessionActions.ts": (function (module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  abortQueryAction: () => (abortQueryAction),
  checkSessionStatusAction: () => (checkSessionStatusAction),
  createSessionAction: () => (createSessionAction),
  deleteSessionAction: () => (deleteSessionAction),
  loadSessionsAction: () => (loadSessionsAction),
  sendMessageAction: () => (sendMessageAction),
  setActiveSessionAction: () => (setActiveSessionAction),
  updateSessionAction: () => (updateSessionAction)
});
/* ESM import */var jotai__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("../node_modules/.pnpm/jotai@2.12.5_@types+react@18.3.23_react@18.3.1/node_modules/jotai/esm/vanilla.mjs");
/* ESM import */var uuid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/v4.js");
/* ESM import */var _services_apiService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/common/services/apiService.ts");
/* ESM import */var _atoms_session__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/common/state/atoms/session.ts");
/* ESM import */var _atoms_message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/common/state/atoms/message.ts");
/* ESM import */var _atoms_tool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/common/state/atoms/tool.ts");
/* ESM import */var _atoms_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/common/state/atoms/ui.ts");
/* ESM import */var _eventProcessor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/common/state/actions/eventProcessor.ts");
/* ESM import */var _atoms_replay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/common/state/atoms/replay.ts");
/* provided dependency */ var $ReactRefreshRuntime$ = __webpack_require__("../node_modules/.pnpm/@rspack+plugin-react-refresh@1.0.3_react-refresh@0.16.0/node_modules/@rspack/plugin-react-refresh/client/reactRefresh.js");










/**
 * Add a session metadata cache to store model information for each session
 */ const sessionMetadataCache = new Map();
/**
 * Load all available sessions
 */ const loadSessionsAction = (0,jotai__WEBPACK_IMPORTED_MODULE_7__.atom)(null, async (get, set)=>{
    try {
        const loadedSessions = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.getSessions();
        set(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.sessionsAtom, loadedSessions);
    } catch (error) {
        console.error('Failed to load sessions:', error);
        throw error;
    }
});
/**
 * Create a new session
 */ const createSessionAction = (0,jotai__WEBPACK_IMPORTED_MODULE_7__.atom)(null, async (get, set)=>{
    try {
        const newSession = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.createSession();
        // Add to sessions list
        set(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.sessionsAtom, (prev)=>[
                newSession,
                ...prev
            ]);
        // Initialize session data
        set(_atoms_message__WEBPACK_IMPORTED_MODULE_2__.messagesAtom, (prev)=>({
                ...prev,
                [newSession.id]: []
            }));
        set(_atoms_tool__WEBPACK_IMPORTED_MODULE_3__.toolResultsAtom, (prev)=>({
                ...prev,
                [newSession.id]: []
            }));
        // Clear workspace panel content to show empty state
        set(_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.activePanelContentAtom, null);
        // Set as active session
        set(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.activeSessionIdAtom, newSession.id);
        return newSession.id;
    } catch (error) {
        console.error('Failed to create session:', error);
        throw error;
    }
});
/**
 * Set the active session
 * 简化加载逻辑，移除恢复会话的复杂性
 */ const setActiveSessionAction = (0,jotai__WEBPACK_IMPORTED_MODULE_7__.atom)(null, async (get, set, sessionId)=>{
    try {
        // 检查是否已经是活动会话
        const currentActiveSessionId = get(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.activeSessionIdAtom);
        if (currentActiveSessionId === sessionId) {
            console.log(`Session ${sessionId} is already active, skipping load`);
            return;
        }
        // 检查回放状态并退出回放模式（除非是同一会话）
        const replayState = get(_atoms_replay__WEBPACK_IMPORTED_MODULE_6__.replayStateAtom);
        if (replayState.isActive) {
            console.log('Exiting replay mode due to session change');
            set(_atoms_replay__WEBPACK_IMPORTED_MODULE_6__.replayStateAtom, {
                isActive: false,
                isPaused: true,
                events: [],
                currentEventIndex: -1,
                startTimestamp: null,
                endTimestamp: null,
                playbackSpeed: 1,
                visibleTimeWindow: null,
                processedEvents: {}
            });
        }
        // 直接获取会话详情，不需要检查 active 状态
        const sessionDetails = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.getSessionDetails(sessionId);
        // 获取当前会话状态以更新 isProcessing 状态
        try {
            const status = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.getSessionStatus(sessionId);
            set(_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.isProcessingAtom, status.isProcessing);
        } catch (error) {
            console.warn('Failed to get session status:', error);
            set(_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.isProcessingAtom, false);
        }
        // 清理工具调用映射缓存
        _atoms_tool__WEBPACK_IMPORTED_MODULE_3__.toolCallResultMap.clear();
        // Check if the session message is loaded
        const messages = get(_atoms_message__WEBPACK_IMPORTED_MODULE_2__.messagesAtom);
        const hasExistingMessages = messages[sessionId] && messages[sessionId].length > 0;
        if (!hasExistingMessages) {
            console.log(`Loading events for session ${sessionId}`);
            const events = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.getSessionEvents(sessionId);
            // Pre-process streaming events to ensure correct continuity
            const processedEvents = preprocessStreamingEvents(events);
            // Process each event to construct messages and tool results
            for (const event of processedEvents){
                set(_eventProcessor__WEBPACK_IMPORTED_MODULE_5__.processEventAction, {
                    sessionId,
                    event
                });
            }
            // Cache key session metadata
            const runStartEvent = events.find((e)=>e.type === 'agent_run_start');
            if (runStartEvent && ('provider' in runStartEvent || 'model' in runStartEvent)) {
                sessionMetadataCache.set(sessionId, {
                    modelInfo: {
                        provider: runStartEvent.provider || '',
                        model: runStartEvent.model || ''
                    }
                });
            }
        } else {
            console.log(`Session ${sessionId} already has messages, skipping event loading`);
            const cachedMetadata = sessionMetadataCache.get(sessionId);
            if (cachedMetadata === null || cachedMetadata === void 0 ? void 0 : cachedMetadata.modelInfo) {
                console.log(`Restoring model info from cache for session ${sessionId}`);
                set(_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.modelInfoAtom, cachedMetadata.modelInfo);
            } else {
                console.log(`No cached model info for session ${sessionId}, loading events to find model info`);
                // If not in the cache, the load event only looks for model information
                try {
                    const events = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.getSessionEvents(sessionId);
                    const runStartEvent = events.find((e)=>e.type === 'agent_run_start');
                    if (runStartEvent && ('provider' in runStartEvent || 'model' in runStartEvent)) {
                        const modelInfo = {
                            provider: runStartEvent.provider || '',
                            model: runStartEvent.model || ''
                        };
                        // Update model information status
                        set(_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.modelInfoAtom, modelInfo);
                        // Cache for future use
                        sessionMetadataCache.set(sessionId, {
                            modelInfo
                        });
                        console.log(`Found and cached model info for session ${sessionId}:`, modelInfo);
                    }
                } catch (error) {
                    console.warn(`Failed to load events for model info recovery:`, error);
                }
            }
        }
        // 设置为活动会话
        set(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.activeSessionIdAtom, sessionId);
    } catch (error) {
        console.error('Failed to set active session:', error);
        set(_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.connectionStatusAtom, (prev)=>({
                ...prev,
                connected: false,
                lastError: error instanceof Error ? error.message : String(error)
            }));
        throw error;
    }
});
/**
 * Update session metadata
 */ const updateSessionAction = (0,jotai__WEBPACK_IMPORTED_MODULE_7__.atom)(null, async (get, set, params)=>{
    const { sessionId, updates } = params;
    try {
        const updatedSession = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.updateSessionMetadata(sessionId, updates);
        // Update session in the list
        set(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.sessionsAtom, (prev)=>prev.map((session)=>session.id === sessionId ? {
                    ...session,
                    ...updatedSession
                } : session));
        return updatedSession;
    } catch (error) {
        console.error('Failed to update session:', error);
        throw error;
    }
});
/**
 * 预处理事件，确保流式事件按正确顺序处理
 */ function preprocessStreamingEvents(events) {
    // 对流式消息进行整理
    const messageStreams = {};
    // 收集所有流式事件，按messageId分组
    events.forEach((event)=>{
        if (event.type === 'final_answer_streaming' && 'messageId' in event) {
            const messageId = event.messageId;
            if (!messageStreams[messageId]) {
                messageStreams[messageId] = [];
            }
            messageStreams[messageId].push(event);
        }
    });
    // 返回预处理后的事件，确保流式事件以正确顺序处理
    return events;
}
/**
 * Delete a session
 */ const deleteSessionAction = (0,jotai__WEBPACK_IMPORTED_MODULE_7__.atom)(null, async (get, set, sessionId)=>{
    try {
        const success = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.deleteSession(sessionId);
        const activeSessionId = get(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.activeSessionIdAtom);
        if (success) {
            // 从会话元数据缓存中删除
            sessionMetadataCache.delete(sessionId);
            // Remove from sessions list
            set(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.sessionsAtom, (prev)=>prev.filter((session)=>session.id !== sessionId));
            // Clear active session if it was deleted
            if (activeSessionId === sessionId) {
                set(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.activeSessionIdAtom, null);
            }
            // Clear session data
            set(_atoms_message__WEBPACK_IMPORTED_MODULE_2__.messagesAtom, (prev)=>{
                const newMessages = {
                    ...prev
                };
                delete newMessages[sessionId];
                return newMessages;
            });
            set(_atoms_tool__WEBPACK_IMPORTED_MODULE_3__.toolResultsAtom, (prev)=>{
                const newResults = {
                    ...prev
                };
                delete newResults[sessionId];
                return newResults;
            });
        }
        return success;
    } catch (error) {
        console.error('Failed to delete session:', error);
        throw error;
    }
});
/**
 * Send a message in the current session
 */ const sendMessageAction = (0,jotai__WEBPACK_IMPORTED_MODULE_7__.atom)(null, async (get, set, content)=>{
    const activeSessionId = get(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.activeSessionIdAtom);
    if (!activeSessionId) {
        throw new Error('No active session');
    }
    // 明确设置处理状态
    set(_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.isProcessingAtom, true);
    // 添加用户消息到状态
    const userMessage = {
        id: (0,uuid__WEBPACK_IMPORTED_MODULE_8__["default"])(),
        role: 'user',
        content,
        timestamp: Date.now()
    };
    set(_atoms_message__WEBPACK_IMPORTED_MODULE_2__.messagesAtom, (prev)=>{
        const sessionMessages = prev[activeSessionId] || [];
        return {
            ...prev,
            [activeSessionId]: [
                ...sessionMessages,
                userMessage
            ]
        };
    });
    // 立即更新会话名称，使用用户查询作为 Summary
    // 这样即使后续更新失败也至少有一个基本的名称
    try {
        // 检查是否是第一条消息，如果是则直接用查询内容作为会话名称
        const messages = get(_atoms_message__WEBPACK_IMPORTED_MODULE_2__.messagesAtom)[activeSessionId] || [];
        if (messages.length <= 2) {
            // 算上刚刚添加的用户消息
            let summary = '';
            if (typeof content === 'string') {
                summary = content.length > 50 ? content.substring(0, 47) + '...' : content;
            } else {
                // 从多模态内容中提取文本部分
                const textPart = content.find((part)=>part.type === 'text');
                if (textPart && 'text' in textPart) {
                    summary = textPart.text.length > 50 ? textPart.text.substring(0, 47) + '...' : textPart.text;
                } else {
                    summary = 'Image message';
                }
            }
            await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.updateSessionMetadata(activeSessionId, {
                name: summary
            });
            // 更新 sessions atom
            set(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.sessionsAtom, (prev)=>prev.map((session)=>session.id === activeSessionId ? {
                        ...session,
                        name: summary
                    } : session));
        }
    } catch (error) {
        console.log('Failed to update initial summary, continuing anyway:', error);
    // 错误不中断主流程
    }
    try {
        // 使用流式查询
        await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.sendStreamingQuery(activeSessionId, content, (event)=>{
            // 处理每个事件
            set(_eventProcessor__WEBPACK_IMPORTED_MODULE_5__.processEventAction, {
                sessionId: activeSessionId,
                event
            });
            // 确保状态保持为处理中，直到明确收到结束事件
            if (event.type !== 'agent_run_end' && event.type !== 'assistant_message') {
                set(_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.isProcessingAtom, true);
            }
        });
    } catch (error) {
        console.error('Error sending message:', error);
        // 错误时重置处理状态
        set(_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.isProcessingAtom, false);
        throw error;
    }
});
/**
 * Abort the current running query
 */ const abortQueryAction = (0,jotai__WEBPACK_IMPORTED_MODULE_7__.atom)(null, async (get, set)=>{
    const activeSessionId = get(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.activeSessionIdAtom);
    if (!activeSessionId) {
        return false;
    }
    try {
        const success = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.abortQuery(activeSessionId);
        if (success) {
            set(_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.isProcessingAtom, false);
            // Add system message about abort
            const abortMessage = {
                id: (0,uuid__WEBPACK_IMPORTED_MODULE_8__["default"])(),
                role: 'system',
                content: 'The operation was aborted.',
                timestamp: Date.now()
            };
            set(_atoms_message__WEBPACK_IMPORTED_MODULE_2__.messagesAtom, (prev)=>{
                const sessionMessages = prev[activeSessionId] || [];
                return {
                    ...prev,
                    [activeSessionId]: [
                        ...sessionMessages,
                        abortMessage
                    ]
                };
            });
        }
        return success;
    } catch (error) {
        console.error('Error aborting query:', error);
        return false;
    }
});
/**
 * Check the current status of a session
 */ const checkSessionStatusAction = (0,jotai__WEBPACK_IMPORTED_MODULE_7__.atom)(null, async (get, set, sessionId)=>{
    if (!sessionId) return;
    try {
        const status = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.getSessionStatus(sessionId);
        set(_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.isProcessingAtom, status.isProcessing);
        return status;
    } catch (error) {
        console.error('Failed to check session status:', error);
    // 错误时不更新处理状态，避免误报
    }
});
/**
 * Handle the end of a conversation
 * 仍然保留此函数，但减少其重要性，避免更新失败带来的影响
 */ async function handleConversationEnd(get, set, sessionId) {
    // 我们不再依赖这个函数来设置会话名称，但仍然保留它作为备份机制
    const allMessages = get(_atoms_message__WEBPACK_IMPORTED_MODULE_2__.messagesAtom)[sessionId] || [];
    // 只在有足够的消息并且会话没有名称时才尝试生成摘要
    const sessions = get(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.sessionsAtom);
    const currentSession = sessions.find((s)=>s.id === sessionId);
    // 如果会话已经有名称，则不需要再生成
    if (currentSession && currentSession.name) {
        return;
    }
    // 只在有实际对话时才尝试生成摘要
    if (allMessages.length > 1) {
        try {
            // 转换消息为 API 期望的格式
            const apiMessages = allMessages.map((msg)=>({
                    role: msg.role,
                    content: typeof msg.content === 'string' ? msg.content : 'multimodal content'
                }));
            // 生成摘要
            const summary = await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.generateSummary(sessionId, apiMessages);
            if (summary) {
                // 更新会话名称
                await _services_apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.updateSessionMetadata(sessionId, {
                    name: summary
                });
                // 更新 sessions atom
                set(_atoms_session__WEBPACK_IMPORTED_MODULE_1__.sessionsAtom, (prev)=>prev.map((session)=>session.id === sessionId ? {
                            ...session,
                            name: summary
                        } : session));
            }
        } catch (error) {
            console.error('Failed to generate or update summary, continuing anyway:', error);
        // 错误不影响主流程
        }
    }
}

function $RefreshSig$() {
  return $ReactRefreshRuntime$.createSignatureFunctionForTransform();
}
function $RefreshReg$(type, id) {
  $ReactRefreshRuntime$.register(type, module.id + "_" + id);
}
Promise.resolve().then(function() {
  $ReactRefreshRuntime$.refresh(module.id, module.hot);
});


}),

},function(__webpack_require__) {
// webpack/runtime/get_full_hash
(() => {
__webpack_require__.h = () => ("c994be2adaeff452")
})();

}
);
//# sourceMappingURL=index.8ac43f9f7015f490.hot-update.js.map