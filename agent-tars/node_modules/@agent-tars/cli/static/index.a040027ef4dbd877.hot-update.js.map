{"version":3,"file":"index.a040027ef4dbd877.hot-update.js","sources":["/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/entry.css","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/v2/services/apiService.ts"],"sourcesContent":["// extracted by css-extract-rspack-plugin\nexport {};\n    if(module.hot) {\n      (function() {\n        var localsJsonString = undefined;\n        // 1749551193760\n        var cssReload = require(\"../../node_modules/.pnpm/@rspack+core@1.3.9_@swc+helpers@0.5.17/node_modules/@rspack/core/dist/cssExtractHmr.js\").cssReload(module.id, {});\n        // only invalidate when locals change\n        if (\n          module.hot.data &&\n          module.hot.data.value &&\n          module.hot.data.value !== localsJsonString\n        ) {\n          module.hot.invalidate();\n        } else {\n          module.hot.accept();\n        }\n        module.hot.dispose(function(data) {\n          data.value = localsJsonString;\n          cssReload();\n        });\n      })();\n    }\n  ","import { API_BASE_URL, API_ENDPOINTS } from '../constants';\nimport { AgentEventStream, SessionMetadata } from '../types';\nimport { socketService } from './socketService';\nimport { ChatCompletionContentPart } from '@multimodal/agent-interface';\n\n/**\n * API Service - Handles HTTP requests to the Agent TARS Server\n *\n * Provides methods for:\n * - Session management (create, get, update, delete)\n * - Query execution (streaming and non-streaming)\n * - Server health checks\n */\nclass ApiService {\n  /**\n   * Check server health status\n   */\n  async checkServerHealth(): Promise<boolean> {\n    try {\n      // Try ping through socket if connected\n      if (socketService.isConnected()) {\n        const pingSuccessful = await socketService.ping();\n        if (pingSuccessful) return true;\n      }\n\n      // Fall back to API health endpoint\n      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.HEALTH}`, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal: AbortSignal.timeout(3000),\n      });\n\n      return response.ok;\n    } catch (error) {\n      console.error('Error checking server health:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Create a new session\n   */\n  async createSession(): Promise<SessionMetadata> {\n    try {\n      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.CREATE_SESSION}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to create session: ${response.statusText}`);\n      }\n\n      const { sessionId } = await response.json();\n      return this.getSessionDetails(sessionId);\n    } catch (error) {\n      console.error('Error creating session:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get all sessions\n   */\n  async getSessions(): Promise<SessionMetadata[]> {\n    try {\n      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.SESSIONS}`, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to get sessions: ${response.statusText}`);\n      }\n\n      const { sessions } = await response.json();\n      return sessions;\n    } catch (error) {\n      console.error('Error getting sessions:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get details for a specific session\n   */\n  async getSessionDetails(sessionId: string): Promise<SessionMetadata> {\n    try {\n      const response = await fetch(\n        `${API_BASE_URL}${API_ENDPOINTS.SESSION_DETAILS}?sessionId=${sessionId}`,\n        {\n          method: 'GET',\n          headers: { 'Content-Type': 'application/json' },\n          signal: AbortSignal.timeout(5000), // 添加 5 秒超时\n        },\n      );\n\n      if (!response.ok) {\n        throw new Error(`Failed to get session details: ${response.statusText}`);\n      }\n\n      const { session } = await response.json();\n      return session;\n    } catch (error) {\n      console.error(`Error getting session details (${sessionId}):`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get events for a specific session\n   */\n  async getSessionEvents(sessionId: string): Promise<AgentEventStream.Event[]> {\n    try {\n      const response = await fetch(\n        `${API_BASE_URL}${API_ENDPOINTS.SESSION_EVENTS}?sessionId=${sessionId}`,\n        {\n          method: 'GET',\n          headers: { 'Content-Type': 'application/json' },\n          signal: AbortSignal.timeout(5000), // 添加 5 秒超时\n        },\n      );\n\n      if (!response.ok) {\n        throw new Error(`Failed to get session events: ${response.statusText}`);\n      }\n\n      const { events } = await response.json();\n      return events;\n    } catch (error) {\n      console.error(`Error getting session events (${sessionId}):`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get current status of a session\n   */\n  async getSessionStatus(sessionId: string): Promise<{ isProcessing: boolean; state: string }> {\n    try {\n      const response = await fetch(\n        `${API_BASE_URL}${API_ENDPOINTS.SESSION_STATUS}?sessionId=${sessionId}`,\n        {\n          method: 'GET',\n          headers: { 'Content-Type': 'application/json' },\n          signal: AbortSignal.timeout(3000), // 3 second timeout\n        },\n      );\n\n      if (!response.ok) {\n        throw new Error(`Failed to get session status: ${response.statusText}`);\n      }\n\n      const { status } = await response.json();\n      return status;\n    } catch (error) {\n      console.error(`Error getting session status (${sessionId}):`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update session metadata\n   */\n  async updateSessionMetadata(\n    sessionId: string,\n    updates: { name?: string; tags?: string[] },\n  ): Promise<SessionMetadata> {\n    try {\n      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.UPDATE_SESSION}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ sessionId, ...updates }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to update session: ${response.statusText}`);\n      }\n\n      const { session } = await response.json();\n      return session;\n    } catch (error) {\n      console.error(`Error updating session (${sessionId}):`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a session\n   */\n  async deleteSession(sessionId: string): Promise<boolean> {\n    try {\n      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.DELETE_SESSION}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ sessionId }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to delete session: ${response.statusText}`);\n      }\n\n      const { success } = await response.json();\n      return success;\n    } catch (error) {\n      console.error(`Error deleting session (${sessionId}):`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Send a streaming query\n   */\n  async sendStreamingQuery(\n    sessionId: string,\n    query: string | ChatCompletionContentPart[],\n    onEvent: (event: AgentEventStream.Event) => void,\n  ): Promise<void> {\n    try {\n      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.QUERY_STREAM}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ sessionId, query }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to send query: ${response.statusText}`);\n      }\n\n      const reader = response.body?.getReader();\n      if (!reader) {\n        throw new Error('ReadableStream not supported');\n      }\n\n      const decoder = new TextDecoder();\n\n      while (true) {\n        const { done, value } = await reader.read();\n\n        if (done) break;\n\n        const chunk = decoder.decode(value, { stream: true });\n        console.log('[GUI] chunk', chunk);\n        const lines = chunk.split('\\n\\n');\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            try {\n              const eventData = JSON.parse(line.substring(6));\n              onEvent(eventData);\n            } catch (e) {\n              console.error('Error parsing event data:', e);\n            }\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error in streaming query:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Send a non-streaming query\n   */\n  async sendQuery(sessionId: string, query: string | ChatCompletionContentPart[]): Promise<string> {\n    try {\n      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.QUERY}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ sessionId, query }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to send query: ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      return data.result;\n    } catch (error) {\n      console.error('Error sending query:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Abort a running query\n   */\n  async abortQuery(sessionId: string): Promise<boolean> {\n    try {\n      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.ABORT}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ sessionId }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to abort query: ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      return data.success;\n    } catch (error) {\n      console.error('Error aborting query:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Generate a summary for a conversation\n   */\n  async generateSummary(sessionId: string, messages: any[]): Promise<string> {\n    try {\n      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.GENERATE_SUMMARY}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ sessionId, messages }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to generate summary: ${response.statusText}`);\n      }\n\n      const { summary } = await response.json();\n      return summary;\n    } catch (error) {\n      console.error('Error generating summary:', error);\n      return 'Untitled Conversation';\n    }\n  }\n\n  /**\n   * Get browser control information for a session\n   */\n  async getBrowserControlInfo(sessionId: string): Promise<{ mode: string; tools: string[] }> {\n    try {\n      const response = await fetch(\n        `${API_BASE_URL}/api/sessions/browser-control?sessionId=${sessionId}`,\n        {\n          method: 'GET',\n          headers: { 'Content-Type': 'application/json' },\n          signal: AbortSignal.timeout(3000),\n        },\n      );\n\n      if (!response.ok) {\n        throw new Error(`Failed to get browser control info: ${response.statusText}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error(`Error getting browser control info (${sessionId}):`, error);\n      // 返回默认值作为回退\n      return { mode: 'default', tools: [] };\n    }\n  }\n\n  /**\n   * Get model information from the server\n   * @returns Model provider and model name information\n   */\n  async getModelInfo(): Promise<{ provider: string; model: string }> {\n    try {\n      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.MODEL_INFO}`, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal: AbortSignal.timeout(3000), // 3 second timeout\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to get model info: ${response.statusText}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Error getting model info:', error);\n      // Return default values in case of error\n      return { provider: 'Unknown Provider', model: 'Unknown Model' };\n    }\n  }\n}\n\n// Export singleton instance\nexport const apiService = new ApiService();\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvBA;AAEA;AAGA;;;;;;;AAOA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAKA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAMA;AAWA;AAVA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;;;AAGA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA"}