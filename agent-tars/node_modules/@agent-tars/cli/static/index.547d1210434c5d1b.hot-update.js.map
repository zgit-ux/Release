{"version":3,"file":"index.547d1210434c5d1b.hot-update.js","sources":["/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/entry.css","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/main/state/atoms/message.ts"],"sourcesContent":["// extracted by css-extract-rspack-plugin\nexport {};\n    if(module.hot) {\n      (function() {\n        var localsJsonString = undefined;\n        // 1749664312211\n        var cssReload = require(\"../../node_modules/.pnpm/@rspack+core@1.3.9_@swc+helpers@0.5.17/node_modules/@rspack/core/dist/cssExtractHmr.js\").cssReload(module.id, {});\n        // only invalidate when locals change\n        if (\n          module.hot.data &&\n          module.hot.data.value &&\n          module.hot.data.value !== localsJsonString\n        ) {\n          module.hot.invalidate();\n        } else {\n          module.hot.accept();\n        }\n        module.hot.dispose(function(data) {\n          data.value = localsJsonString;\n          cssReload();\n        });\n      })();\n    }\n  ","import { atom } from 'jotai';\nimport { Message, MessageGroup } from '@/common/types';\n\n/**\n * Atom for storing messages for each session\n * Key is the session ID, value is an array of messages for that session\n */\nexport const messagesAtom = atom<Record<string, Message[]>>({});\n\n/**\n * Atom for storing grouped messages for each session\n * Key is the session ID, value is an array of message groups for that session\n * This is derived from messagesAtom but with messages properly grouped\n */\nexport const groupedMessagesAtom = atom<Record<string, MessageGroup[]>>((get) => {\n  const allMessages = get(messagesAtom);\n  const result: Record<string, MessageGroup[]> = {};\n\n  // Process each session's messages into groups\n  Object.entries(allMessages).forEach(([sessionId, messages]) => {\n    result[sessionId] = createMessageGroups(messages);\n  });\n\n  return result;\n});\n\n/**\n * Group messages into logical conversation groups\n *\n * The grouping logic creates groups based on:\n * 1. User messages always start a new group\n * 2. System messages are standalone groups\n * 3. Assistant/environment messages that belong together are grouped\n * 4. Thinking/processing sequences are properly maintained\n */\nfunction createMessageGroups(messages: Message[]): MessageGroup[] {\n  if (!messages.length) return [];\n\n  const groups: MessageGroup[] = [];\n  let currentGroup: Message[] = [];\n  let currentThinkingSequence: {\n    startIndex: number;\n    messages: Message[];\n  } | null = null;\n\n  // Process messages in order\n  for (let i = 0; i < messages.length; i++) {\n    const message = messages[i];\n\n    // User messages always start a new group\n    if (message.role === 'user') {\n      if (currentGroup.length > 0) {\n        groups.push({ messages: [...currentGroup] });\n      }\n      currentGroup = [message];\n      currentThinkingSequence = null;\n      continue;\n    }\n\n    // System messages are standalone\n    if (message.role === 'system') {\n      if (currentGroup.length > 0) {\n        groups.push({ messages: [...currentGroup] });\n      }\n      groups.push({ messages: [message] });\n      currentGroup = [];\n      currentThinkingSequence = null;\n      continue;\n    }\n\n    // Process assistant and environment messages\n    if (message.role === 'assistant' || message.role === 'environment') {\n      // Check if this is the start of a thinking sequence\n      if (\n        message.role === 'assistant' &&\n        currentGroup.length > 0 &&\n        currentGroup[currentGroup.length - 1].role === 'user' &&\n        (!message.finishReason || message.finishReason !== 'stop')\n      ) {\n        // Create new thinking sequence\n        currentThinkingSequence = {\n          startIndex: currentGroup.length,\n          messages: [message],\n        };\n        currentGroup.push(message);\n        continue;\n      }\n\n      // Continue existing thinking sequence\n      if (currentThinkingSequence && (!message.finishReason || message.finishReason !== 'stop')) {\n        currentThinkingSequence.messages.push(message);\n        currentGroup.push(message);\n        continue;\n      }\n\n      // Handle final answer in a thinking sequence\n      if (message.role === 'assistant' && message.finishReason === 'stop') {\n        if (currentThinkingSequence) {\n          currentThinkingSequence.messages.push(message);\n          currentGroup.push(message);\n          currentThinkingSequence = null;\n          continue;\n        } else {\n          // Standalone final answer\n          currentGroup.push(message);\n          continue;\n        }\n      }\n\n      // Default: add to current group\n      currentGroup.push(message);\n    }\n  }\n\n  // Add the last group if not empty\n  if (currentGroup.length > 0) {\n    groups.push({ messages: [...currentGroup] });\n  }\n\n  return groups;\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvBA;AAGA;;;AAGA;AAGA;;;;AAIA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAQA;AAEA;AAEA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA"}