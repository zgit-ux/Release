"use strict";
self["webpackHotUpdate_agent_tars_web_ui"]("index", {
"./src/entry.css": (function (module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
// extracted by css-extract-rspack-plugin

    if(true) {
      (function() {
        var localsJsonString = undefined;
        // 1748910481504
        var cssReload = (__webpack_require__("../node_modules/.pnpm/@rspack+core@1.3.9_@swc+helpers@0.5.17/node_modules/@rspack/core/dist/cssExtractHmr.js")/* .cssReload */.cssReload)(module.id, {});
        // only invalidate when locals change
        if (
          module.hot.data &&
          module.hot.data.value &&
          module.hot.data.value !== localsJsonString
        ) {
          module.hot.invalidate();
        } else {
          module.hot.accept();
        }
        module.hot.dispose(function(data) {
          data.value = localsJsonString;
          cssReload();
        });
      })();
    }
  

}),
"./src/v2/state/atoms/message.ts": (function (module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  groupedMessagesAtom: () => (groupedMessagesAtom),
  messagesAtom: () => (messagesAtom)
});
/* ESM import */var jotai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../node_modules/.pnpm/jotai@2.12.5_@types+react@18.3.23_react@18.3.1/node_modules/jotai/esm/vanilla.mjs");
/* ESM import */var _utils_typeGuards__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/v2/utils/typeGuards.ts");
/* provided dependency */ var $ReactRefreshRuntime$ = __webpack_require__("../node_modules/.pnpm/@rspack+plugin-react-refresh@1.0.3_react-refresh@0.16.0/node_modules/@rspack/plugin-react-refresh/client/reactRefresh.js");


/**
 * Atom for storing messages for each session
 * Key is the session ID, value is an array of messages for that session
 */ const messagesAtom = (0,jotai__WEBPACK_IMPORTED_MODULE_1__.atom)({});
/**
 * Atom for storing grouped messages for each session
 * Key is the session ID, value is an array of message groups for that session
 * This is derived from messagesAtom but with messages properly grouped
 */ const groupedMessagesAtom = (0,jotai__WEBPACK_IMPORTED_MODULE_1__.atom)((get)=>{
    const allMessages = get(messagesAtom);
    const result = {};
    // Process each session's messages into groups
    Object.entries(allMessages).forEach((param)=>{
        let [sessionId, messages] = param;
        result[sessionId] = createMessageGroups(messages);
    });
    return result;
});
/**
 * Group messages into logical conversation groups
 *
 * The grouping logic creates groups based on:
 * 1. User messages always start a new group
 * 2. System messages are standalone groups
 * 3. Assistant/environment messages that belong together are grouped
 * 4. Thinking/processing sequences are properly maintained
 * 5. Image messages and text messages are separated into different groups
 */ function createMessageGroups(messages) {
    if (!messages.length) return [];
    const groups = [];
    let currentGroup = [];
    let currentThinkingSequence = null;
    // Process messages in order
    for(let i = 0; i < messages.length; i++){
        const message = messages[i];
        // 检查是否是多模态内容（包含图片）
        const isImageMessage = message.role === 'user' && (0,_utils_typeGuards__WEBPACK_IMPORTED_MODULE_0__.isMultimodalContent)(message.content) && message.content.some((part)=>part.type === 'image_url');
        // 如果是图片消息，并且前一个是文本消息，则创建新组
        if (isImageMessage && currentGroup.length > 0) {
            // 保存当前组并创建新组
            groups.push({
                messages: [
                    ...currentGroup
                ]
            });
            currentGroup = [
                message
            ];
            currentThinkingSequence = null;
            continue;
        }
        // User messages always start a new group
        if (message.role === 'user') {
            if (currentGroup.length > 0) {
                groups.push({
                    messages: [
                        ...currentGroup
                    ]
                });
            }
            currentGroup = [
                message
            ];
            currentThinkingSequence = null;
            continue;
        }
        // System messages are standalone
        if (message.role === 'system') {
            if (currentGroup.length > 0) {
                groups.push({
                    messages: [
                        ...currentGroup
                    ]
                });
            }
            groups.push({
                messages: [
                    message
                ]
            });
            currentGroup = [];
            currentThinkingSequence = null;
            continue;
        }
        // Process assistant and environment messages
        if (message.role === 'assistant' || message.role === 'environment') {
            // Check if this is the start of a thinking sequence
            if (message.role === 'assistant' && currentGroup.length > 0 && currentGroup[currentGroup.length - 1].role === 'user' && (!message.finishReason || message.finishReason !== 'stop')) {
                // Create new thinking sequence
                currentThinkingSequence = {
                    startIndex: currentGroup.length,
                    messages: [
                        message
                    ]
                };
                currentGroup.push(message);
                continue;
            }
            // Continue existing thinking sequence
            if (currentThinkingSequence && (!message.finishReason || message.finishReason !== 'stop')) {
                currentThinkingSequence.messages.push(message);
                currentGroup.push(message);
                continue;
            }
            // Handle final answer in a thinking sequence
            if (message.role === 'assistant' && message.finishReason === 'stop') {
                if (currentThinkingSequence) {
                    currentThinkingSequence.messages.push(message);
                    currentGroup.push(message);
                    currentThinkingSequence = null;
                    continue;
                } else {
                    // Standalone final answer
                    currentGroup.push(message);
                    continue;
                }
            }
            // Default: add to current group
            currentGroup.push(message);
        }
    }
    // Add the last group if not empty
    if (currentGroup.length > 0) {
        groups.push({
            messages: [
                ...currentGroup
            ]
        });
    }
    return groups;
}

function $RefreshSig$() {
  return $ReactRefreshRuntime$.createSignatureFunctionForTransform();
}
function $RefreshReg$(type, id) {
  $ReactRefreshRuntime$.register(type, module.id + "_" + id);
}
Promise.resolve().then(function() {
  $ReactRefreshRuntime$.refresh(module.id, module.hot);
});


}),

},function(__webpack_require__) {
// webpack/runtime/get_full_hash
(() => {
__webpack_require__.h = () => ("acaf666ead093dbf")
})();

}
);
//# sourceMappingURL=index.39b1125c9e76944d.hot-update.js.map