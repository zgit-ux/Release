{"version":3,"file":"index.cd5e5a349d7f9b79.hot-update.js","sources":["/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/entry.css","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/common/utils/formatters.ts","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/main/hooks/useTool.tsx","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/main/services/apiService.ts","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/main/services/socketService.ts","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/main/state/actions/connectionActions.ts","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/standalone/share/shareService.ts"],"sourcesContent":["// extracted by css-extract-rspack-plugin\nexport {};\n    if(module.hot) {\n      (function() {\n        var localsJsonString = undefined;\n        // 1749665494103\n        var cssReload = require(\"../../node_modules/.pnpm/@rspack+core@1.3.9_@swc+helpers@0.5.17/node_modules/@rspack/core/dist/cssExtractHmr.js\").cssReload(module.id, {});\n        // only invalidate when locals change\n        if (\n          module.hot.data &&\n          module.hot.data.value &&\n          module.hot.data.value !== localsJsonString\n        ) {\n          module.hot.invalidate();\n        } else {\n          module.hot.accept();\n        }\n        module.hot.dispose(function(data) {\n          data.value = localsJsonString;\n          cssReload();\n        });\n      })();\n    }\n  ","import { ToolResult } from '@/common/types';\nimport { TOOL_TYPES } from '@/common/constants';\n\n/**\n * Format a timestamp to a user-friendly date string\n */\nexport function formatTimestamp(timestamp: number): string {\n  const date = new Date(timestamp);\n  return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });\n}\n\n/**\n * Format a date relative to today (Today, Yesterday, or date)\n */\nexport function formatRelativeDate(timestamp: number): string {\n  const date = new Date(timestamp);\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n\n  const yesterday = new Date(today);\n  yesterday.setDate(yesterday.getDate() - 1);\n\n  if (date.toDateString() === today.toDateString()) {\n    return 'Today';\n  } else if (date.toDateString() === yesterday.toDateString()) {\n    return 'Yesterday';\n  } else {\n    return date.toLocaleDateString([], { month: 'short', day: 'numeric' });\n  }\n}\n\n/**\n * Determine the tool type from name and content\n */\nexport function determineToolType(name: string, content: any): ToolResult['type'] {\n  const lowerName = name.toLowerCase();\n\n  // Add specialized browser_vision_control detection\n  if (lowerName === 'browser_vision_control') {\n    return 'browser_vision_control';\n  }\n\n  // Check for write_file tool\n  if (lowerName === 'write_file') {\n    return TOOL_TYPES.FILE;\n  }\n\n  // Check the tool name first\n  if (lowerName.includes('search') || lowerName.includes('web_search')) return TOOL_TYPES.SEARCH;\n  if (lowerName.includes('browser')) return TOOL_TYPES.BROWSER;\n  if (\n    lowerName.includes('command') ||\n    lowerName.includes('terminal') ||\n    lowerName === 'run_command'\n  )\n    return TOOL_TYPES.COMMAND;\n  if (lowerName.includes('file') || lowerName.includes('document')) return TOOL_TYPES.FILE;\n\n  // 检查内容是否是新格式的搜索结果\n  if (\n    Array.isArray(content) &&\n    content.some(\n      (item) => item.type === 'text' && (item.name === 'RESULTS' || item.name === 'QUERY'),\n    )\n  ) {\n    return TOOL_TYPES.SEARCH;\n  }\n\n  // 检查内容是否是新格式的浏览器导航结果\n  if (\n    Array.isArray(content) &&\n    content.some(\n      (item) => item.type === 'text' && item.text && item.text.startsWith('Navigated to'),\n    )\n  ) {\n    return TOOL_TYPES.BROWSER;\n  }\n\n  // Check if content contains image data\n  if (\n    content &&\n    ((typeof content === 'object' && content.type === 'image') ||\n      (typeof content === 'string' && content.startsWith('data:image/')))\n  ) {\n    return TOOL_TYPES.IMAGE;\n  }\n\n  // 检查内容是否是包含图像 URL 的数组\n  if (Array.isArray(content) && content.some((item) => item.type === 'image_url')) {\n    return TOOL_TYPES.IMAGE;\n  }\n\n  // 检查内容是否是新格式的命令执行结果\n  if (\n    Array.isArray(content) &&\n    content.some(\n      (item) => item.type === 'text' && (item.name === 'STDOUT' || item.name === 'COMMAND'),\n    )\n  ) {\n    return TOOL_TYPES.COMMAND;\n  }\n\n  return TOOL_TYPES.OTHER;\n}","import { toolCallResultMap } from '../state/atoms/tool';\nimport { ToolResult } from '@/common/types';\nimport { TOOL_TYPES } from '@/common/constants';\nimport {\n  FiSearch,\n  FiMonitor,\n  FiTerminal,\n  FiFile,\n  FiImage,\n  FiCpu,\n  FiBookOpen,\n} from 'react-icons/fi';\n\n/**\n * Hook for tool-related functionality\n */\nexport function useTool() {\n  /**\n   * Get a tool result by its tool call ID\n   */\n  const getToolResultForCall = (toolCallId: string): ToolResult | undefined => {\n    return toolCallResultMap.get(toolCallId);\n  };\n\n  /**\n   * Get the appropriate icon for a tool type with enhanced styling\n   */\n  const getToolIcon = (type: string) => {\n    // 特殊处理 final_answer 工具，使用更友好的图标和名称\n    if (type === 'final_answer') {\n      return (\n        <div className=\"relative\">\n          <div className=\"absolute inset-0 bg-gradient-to-br from-accent-400 to-accent-500 rounded-full opacity-20\"></div>\n          <FiBookOpen className=\"relative z-10 text-accent-600 dark:text-accent-400\" />\n        </div>\n      );\n    }\n\n    switch (type) {\n      case TOOL_TYPES.SEARCH:\n        return (\n          <div className=\"relative\">\n            <div className=\"absolute inset-0 bg-gradient-to-br from-blue-400 to-indigo-500 rounded-full opacity-20\"></div>\n            <FiSearch className=\"relative z-10 text-blue-600 dark:text-blue-400\" />\n          </div>\n        );\n      case TOOL_TYPES.BROWSER:\n        return (\n          <div className=\"relative\">\n            <div className=\"absolute inset-0 bg-gradient-to-br from-purple-400 to-pink-500 rounded-full opacity-20\"></div>\n            <FiMonitor className=\"relative z-10 text-purple-600 dark:text-purple-400\" />\n          </div>\n        );\n      case TOOL_TYPES.COMMAND:\n        return (\n          <div className=\"relative\">\n            <div className=\"absolute inset-0 bg-gradient-to-br from-green-400 to-emerald-500 rounded-full opacity-20\"></div>\n            <FiTerminal className=\"relative z-10 text-green-600 dark:text-green-400\" />\n          </div>\n        );\n      case TOOL_TYPES.FILE:\n        return (\n          <div className=\"relative\">\n            <div className=\"absolute inset-0 bg-gradient-to-br from-yellow-400 to-amber-500 rounded-full opacity-20\"></div>\n            <FiFile className=\"relative z-10 text-yellow-600 dark:text-yellow-400\" />\n          </div>\n        );\n      case TOOL_TYPES.IMAGE:\n        return (\n          <div className=\"relative\">\n            <div className=\"absolute inset-0 bg-gradient-to-br from-red-400 to-rose-500 rounded-full opacity-20\"></div>\n            <FiImage className=\"relative z-10 text-red-600 dark:text-red-400\" />\n          </div>\n        );\n      case TOOL_TYPES.BROWSER_CONTROL:\n        return (\n          <div className=\"relative\">\n            <div className=\"absolute inset-0 bg-gradient-to-br from-cyan-400 to-teal-500 rounded-full opacity-20\"></div>\n            <FiCpu className=\"relative z-10 text-cyan-600 dark:text-cyan-400\" />\n          </div>\n        );\n      default:\n        return (\n          <div className=\"relative\">\n            <div className=\"absolute inset-0 bg-gradient-to-br from-gray-400 to-gray-500 rounded-full opacity-20\"></div>\n            <FiFile className=\"relative z-10 text-gray-600 dark:text-gray-400\" />\n          </div>\n        );\n    }\n  };\n\n  return {\n    getToolResultForCall,\n    getToolIcon,\n  };\n}\n","import { API_BASE_URL, API_ENDPOINTS } from '@/common/constants';\nimport { AgentEventStream, SessionMetadata } from '@/common/types';\nimport { socketService } from './socketService';\nimport { ChatCompletionContentPart } from '@multimodal/agent-interface';\n\n/**\n * API Service - Handles HTTP requests to the Agent TARS Server\n *\n * Provides methods for:\n * - Session management (create, get, update, delete)\n * - Query execution (streaming and non-streaming)\n * - Server health checks\n */\nclass ApiService {\n  /**\n   * Check server health status\n   */\n  async checkServerHealth(): Promise<boolean> {\n    try {\n      // Try ping through socket if connected\n      if (socketService.isConnected()) {\n        const pingSuccessful = await socketService.ping();\n        if (pingSuccessful) return true;\n      }\n\n      // Fall back to API health endpoint\n      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.HEALTH}`, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal: AbortSignal.timeout(3000),\n      });\n\n      return response.ok;\n    } catch (error) {\n      console.error('Error checking server health:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Create a new session\n   */\n  async createSession(): Promise<SessionMetadata> {\n    try {\n      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.CREATE_SESSION}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to create session: ${response.statusText}`);\n      }\n\n      const { sessionId } = await response.json();\n      return this.getSessionDetails(sessionId);\n    } catch (error) {\n      console.error('Error creating session:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get all sessions\n   */\n  async getSessions(): Promise<SessionMetadata[]> {\n    try {\n      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.SESSIONS}`, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to get sessions: ${response.statusText}`);\n      }\n\n      const { sessions } = await response.json();\n      return sessions;\n    } catch (error) {\n      console.error('Error getting sessions:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get details for a specific session\n   */\n  async getSessionDetails(sessionId: string): Promise<SessionMetadata> {\n    try {\n      const response = await fetch(\n        `${API_BASE_URL}${API_ENDPOINTS.SESSION_DETAILS}?sessionId=${sessionId}`,\n        {\n          method: 'GET',\n          headers: { 'Content-Type': 'application/json' },\n          signal: AbortSignal.timeout(5000), // 添加 5 秒超时\n        },\n      );\n\n      if (!response.ok) {\n        throw new Error(`Failed to get session details: ${response.statusText}`);\n      }\n\n      const { session } = await response.json();\n      return session;\n    } catch (error) {\n      console.error(`Error getting session details (${sessionId}):`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get events for a specific session\n   */\n  async getSessionEvents(sessionId: string): Promise<AgentEventStream.Event[]> {\n    try {\n      const response = await fetch(\n        `${API_BASE_URL}${API_ENDPOINTS.SESSION_EVENTS}?sessionId=${sessionId}`,\n        {\n          method: 'GET',\n          headers: { 'Content-Type': 'application/json' },\n          signal: AbortSignal.timeout(5000), // 添加 5 秒超时\n        },\n      );\n\n      if (!response.ok) {\n        throw new Error(`Failed to get session events: ${response.statusText}`);\n      }\n\n      const { events } = await response.json();\n      return events;\n    } catch (error) {\n      console.error(`Error getting session events (${sessionId}):`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get current status of a session\n   */\n  async getSessionStatus(sessionId: string): Promise<{ isProcessing: boolean; state: string }> {\n    try {\n      const response = await fetch(\n        `${API_BASE_URL}${API_ENDPOINTS.SESSION_STATUS}?sessionId=${sessionId}`,\n        {\n          method: 'GET',\n          headers: { 'Content-Type': 'application/json' },\n          signal: AbortSignal.timeout(3000), // 3 second timeout\n        },\n      );\n\n      if (!response.ok) {\n        throw new Error(`Failed to get session status: ${response.statusText}`);\n      }\n\n      const { status } = await response.json();\n      return status;\n    } catch (error) {\n      console.error(`Error getting session status (${sessionId}):`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update session metadata\n   */\n  async updateSessionMetadata(\n    sessionId: string,\n    updates: { name?: string; tags?: string[] },\n  ): Promise<SessionMetadata> {\n    try {\n      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.UPDATE_SESSION}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ sessionId, ...updates }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to update session: ${response.statusText}`);\n      }\n\n      const { session } = await response.json();\n      return session;\n    } catch (error) {\n      console.error(`Error updating session (${sessionId}):`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a session\n   */\n  async deleteSession(sessionId: string): Promise<boolean> {\n    try {\n      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.DELETE_SESSION}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ sessionId }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to delete session: ${response.statusText}`);\n      }\n\n      const { success } = await response.json();\n      return success;\n    } catch (error) {\n      console.error(`Error deleting session (${sessionId}):`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Send a streaming query\n   */\n  async sendStreamingQuery(\n    sessionId: string,\n    query: string | ChatCompletionContentPart[],\n    onEvent: (event: AgentEventStream.Event) => void,\n  ): Promise<void> {\n    try {\n      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.QUERY_STREAM}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ sessionId, query }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to send query: ${response.statusText}`);\n      }\n\n      const reader = response.body?.getReader();\n      if (!reader) {\n        throw new Error('ReadableStream not supported');\n      }\n\n      const decoder = new TextDecoder();\n      let buffer = '';\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        // Add the new chunk to the buffer\n        buffer += decoder.decode(value, { stream: true });\n\n        // Process all complete events in the buffer\n        let eventEndIndex;\n        while ((eventEndIndex = buffer.indexOf('\\n\\n')) !== -1) {\n          const eventString = buffer.slice(0, eventEndIndex);\n          // Move buffer to the next event\n          buffer = buffer.slice(eventEndIndex + 2);\n\n          if (eventString.startsWith('data: ')) {\n            try {\n              const eventData = JSON.parse(eventString.substring(6));\n              onEvent(eventData);\n            } catch (e) {\n              console.error('Error parsing event data:', e);\n            }\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error in streaming query:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Send a non-streaming query\n   */\n  async sendQuery(sessionId: string, query: string | ChatCompletionContentPart[]): Promise<string> {\n    try {\n      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.QUERY}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ sessionId, query }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to send query: ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      return data.result;\n    } catch (error) {\n      console.error('Error sending query:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Abort a running query\n   */\n  async abortQuery(sessionId: string): Promise<boolean> {\n    try {\n      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.ABORT}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ sessionId }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to abort query: ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      return data.success;\n    } catch (error) {\n      console.error('Error aborting query:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Generate a summary for a conversation\n   */\n  async generateSummary(sessionId: string, messages: any[]): Promise<string> {\n    try {\n      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.GENERATE_SUMMARY}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ sessionId, messages }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to generate summary: ${response.statusText}`);\n      }\n\n      const { summary } = await response.json();\n      return summary;\n    } catch (error) {\n      console.error('Error generating summary:', error);\n      return 'Untitled Conversation';\n    }\n  }\n\n  /**\n   * Get browser control information for a session\n   */\n  async getBrowserControlInfo(sessionId: string): Promise<{ mode: string; tools: string[] }> {\n    try {\n      const response = await fetch(\n        `${API_BASE_URL}/api/sessions/browser-control?sessionId=${sessionId}`,\n        {\n          method: 'GET',\n          headers: { 'Content-Type': 'application/json' },\n          signal: AbortSignal.timeout(3000),\n        },\n      );\n\n      if (!response.ok) {\n        throw new Error(`Failed to get browser control info: ${response.statusText}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error(`Error getting browser control info (${sessionId}):`, error);\n      // 返回默认值作为回退\n      return { mode: 'default', tools: [] };\n    }\n  }\n\n  /**\n   * Get model information from the server\n   * @returns Model provider and model name information\n   */\n  async getModelInfo(): Promise<{ provider: string; model: string }> {\n    try {\n      const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.MODEL_INFO}`, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal: AbortSignal.timeout(3000), // 3 second timeout\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to get model info: ${response.statusText}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Error getting model info:', error);\n      // Return default values in case of error\n      return { provider: 'Unknown Provider', model: 'Unknown Model' };\n    }\n  }\n}\n\n// Export singleton instance\nexport const apiService = new ApiService();\n","import { io, Socket } from 'socket.io-client';\nimport { API_BASE_URL, SOCKET_EVENTS, CONNECTION_SETTINGS } from '@/common/constants';\nimport { AgentEventStream } from '@/common/types';\n\n/**\n * Socket Service - Manages WebSocket connection with server\n */\nclass SocketService {\n  private socket: Socket | null = null;\n  private heartbeatTimer: NodeJS.Timeout | null = null;\n  private missedHeartbeats = 0;\n  private reconnectAttempts = 0;\n  private eventHandlers: Record<string, Array<(...args: any[]) => void>> = {};\n\n  /**\n   * Connect to the WebSocket server\n   */\n  connect(): Socket | null {\n    if (this.socket?.connected) {\n      return this.socket;\n    }\n\n    this.socket = io(API_BASE_URL, {\n      reconnection: true,\n      reconnectionDelay: CONNECTION_SETTINGS.RECONNECTION_DELAY,\n      reconnectionDelayMax: CONNECTION_SETTINGS.RECONNECTION_DELAY_MAX,\n      reconnectionAttempts: CONNECTION_SETTINGS.MAX_RECONNECT_ATTEMPTS,\n    });\n\n    // Set up core event handlers\n    this.setupEventHandlers();\n\n    return this.socket;\n  }\n\n  /**\n   * Disconnect from the WebSocket server\n   */\n  disconnect(): void {\n    this.stopHeartbeat();\n\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n\n    this.missedHeartbeats = 0;\n    this.reconnectAttempts = 0;\n  }\n\n  /**\n   * Check if currently connected to the server\n   */\n  isConnected(): boolean {\n    return this.socket?.connected || false;\n  }\n\n  /**\n   * Join a specific session to receive its events\n   */\n  joinSession(\n    sessionId: string,\n    onEvent: (event: AgentEventStream.Event) => void,\n    onStatusUpdate: (status: any) => void,\n  ): void {\n    if (!this.socket) {\n      this.connect();\n    }\n\n    if (!this.socket) return;\n\n    console.log(`Joining session: ${sessionId}`);\n    this.socket.emit(SOCKET_EVENTS.JOIN_SESSION, sessionId);\n\n    // 清理现有监听器\n    this.socket.off(SOCKET_EVENTS.AGENT_EVENT);\n    this.socket.off(SOCKET_EVENTS.AGENT_STATUS);\n\n    // 设置事件监听器\n    this.socket.on(SOCKET_EVENTS.AGENT_EVENT, ({ type, data }) => {\n      if (data) {\n        onEvent(data);\n      }\n    });\n\n    // 增强状态更新处理\n    this.socket.on(SOCKET_EVENTS.AGENT_STATUS, (status) => {\n      console.log('Received agent status:', status);\n      onStatusUpdate(status);\n\n      // 触发全局事件以同步应用中的所有组件\n      this.notifyEventHandlers(SOCKET_EVENTS.AGENT_STATUS, status);\n    });\n\n    // 立即请求当前状态\n    this.socket.emit('request-status', { sessionId });\n  }\n\n  /**\n   * Send a query to the server\n   */\n  sendQuery(params: { sessionId: string; query: string }): void {\n    if (!this.socket?.connected) {\n      throw new Error('Socket not connected');\n    }\n\n    this.socket.emit(SOCKET_EVENTS.SEND_QUERY, params);\n  }\n\n  /**\n   * Abort the current query\n   */\n  abortQuery(params: { sessionId: string }): void {\n    if (!this.socket?.connected) {\n      throw new Error('Socket not connected');\n    }\n\n    this.socket.emit(SOCKET_EVENTS.ABORT_QUERY, params);\n  }\n\n  /**\n   * Add an event listener\n   */\n  on(event: string, callback: (...args: any[]) => void): void {\n    if (!this.eventHandlers[event]) {\n      this.eventHandlers[event] = [];\n    }\n\n    this.eventHandlers[event].push(callback);\n\n    // If we already have a socket, add the listener directly\n    if (this.socket) {\n      this.socket.on(event, callback);\n    }\n  }\n\n  /**\n   * Remove an event listener\n   */\n  off(event: string, callback: (...args: any[]) => void): void {\n    if (this.eventHandlers[event]) {\n      this.eventHandlers[event] = this.eventHandlers[event].filter((cb) => cb !== callback);\n    }\n\n    if (this.socket) {\n      this.socket.off(event, callback);\n    }\n  }\n\n  /**\n   * Send a ping to check server connectivity\n   */\n  ping(): Promise<boolean> {\n    return new Promise((resolve) => {\n      if (!this.socket || !this.socket.connected) {\n        resolve(false);\n        return;\n      }\n\n      const timeout = setTimeout(() => {\n        resolve(false);\n      }, 5000);\n\n      this.socket.emit(SOCKET_EVENTS.PING, () => {\n        clearTimeout(timeout);\n        resolve(true);\n      });\n    });\n  }\n\n  /**\n   * Get the socket instance\n   */\n  getSocket(): Socket | null {\n    return this.socket;\n  }\n\n  /**\n   * Set up event handlers for the socket connection\n   */\n  private setupEventHandlers(): void {\n    if (!this.socket) return;\n\n    this.socket.on(SOCKET_EVENTS.CONNECT, this.handleConnect);\n    this.socket.on(SOCKET_EVENTS.DISCONNECT, this.handleDisconnect);\n    this.socket.on(SOCKET_EVENTS.ERROR, this.handleError);\n    this.socket.on(SOCKET_EVENTS.RECONNECT_ATTEMPT, this.handleReconnectAttempt);\n    this.socket.on(SOCKET_EVENTS.RECONNECT_FAILED, this.handleReconnectFailed);\n\n    // Apply any event handlers that were registered before connecting\n    Object.entries(this.eventHandlers).forEach(([event, handlers]) => {\n      handlers.forEach((handler) => {\n        this.socket?.on(event, handler);\n      });\n    });\n  }\n\n  /**\n   * Handle successful connection\n   */\n  private handleConnect = (): void => {\n    console.log('Connected to server');\n    this.missedHeartbeats = 0;\n    this.reconnectAttempts = 0;\n    this.startHeartbeat();\n\n    // Notify event handlers\n    this.notifyEventHandlers(SOCKET_EVENTS.CONNECT);\n  };\n\n  /**\n   * Handle disconnection\n   */\n  private handleDisconnect = (reason: string): void => {\n    console.log('Disconnected from server:', reason);\n    this.stopHeartbeat();\n\n    // Notify event handlers\n    this.notifyEventHandlers(SOCKET_EVENTS.DISCONNECT, reason);\n  };\n\n  /**\n   * Handle connection errors\n   */\n  private handleError = (error: any): void => {\n    console.error('Socket error:', error);\n\n    // Notify event handlers\n    this.notifyEventHandlers(SOCKET_EVENTS.ERROR, error);\n  };\n\n  /**\n   * Handle reconnection attempts\n   */\n  private handleReconnectAttempt = (): void => {\n    this.reconnectAttempts++;\n    console.log(\n      `Reconnection attempt ${this.reconnectAttempts}/${CONNECTION_SETTINGS.MAX_RECONNECT_ATTEMPTS}`,\n    );\n\n    // Notify event handlers\n    this.notifyEventHandlers(SOCKET_EVENTS.RECONNECT_ATTEMPT, this.reconnectAttempts);\n  };\n\n  /**\n   * Handle failed reconnection\n   */\n  private handleReconnectFailed = (): void => {\n    console.log('Failed to reconnect after multiple attempts');\n\n    // Notify event handlers\n    this.notifyEventHandlers(SOCKET_EVENTS.RECONNECT_FAILED);\n  };\n\n  /**\n   * Start heartbeat monitoring\n   */\n  private startHeartbeat(): void {\n    this.stopHeartbeat();\n    this.missedHeartbeats = 0;\n\n    this.heartbeatTimer = setInterval(() => {\n      this.sendHeartbeat();\n    }, CONNECTION_SETTINGS.HEARTBEAT_INTERVAL);\n  }\n\n  /**\n   * Stop heartbeat monitoring\n   */\n  private stopHeartbeat(): void {\n    if (this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = null;\n    }\n  }\n\n  /**\n   * Send heartbeat to server and track response\n   */\n  private sendHeartbeat(): void {\n    if (!this.socket || !this.socket.connected) {\n      this.missedHeartbeats++;\n\n      if (this.missedHeartbeats >= CONNECTION_SETTINGS.MAX_MISSED_HEARTBEATS) {\n        console.warn(`Missed ${this.missedHeartbeats} heartbeats, connection may be down`);\n        this.socket?.disconnect();\n      }\n      return;\n    }\n\n    this.socket.emit(SOCKET_EVENTS.PING, () => {\n      this.missedHeartbeats = 0;\n    });\n\n    // Increment counter - will be reset when we get a response\n    this.missedHeartbeats++;\n\n    if (this.missedHeartbeats >= CONNECTION_SETTINGS.MAX_MISSED_HEARTBEATS) {\n      console.warn(`Missed ${this.missedHeartbeats} heartbeats, connection may be down`);\n      this.socket.disconnect();\n    }\n  }\n\n  /**\n   * Notify all registered event handlers for a specific event\n   */\n  private notifyEventHandlers(event: string, ...args: any[]): void {\n    if (this.eventHandlers[event]) {\n      this.eventHandlers[event].forEach((handler) => {\n        try {\n          handler(...args);\n        } catch (error) {\n          console.error(`Error in ${event} event handler:`, error);\n        }\n      });\n    }\n  }\n}\n\n// Export singleton instance\nexport const socketService = new SocketService();\n","import { atom } from 'jotai';\nimport { SOCKET_EVENTS } from '@/common/constants';\nimport { apiService } from '../../services/apiService';\nimport { socketService } from '../../services/socketService';\nimport { connectionStatusAtom } from '../atoms/ui';\n\n/**\n * Check server connection status\n */\nexport const checkConnectionStatusAction = atom(null, async (get, set) => {\n  const currentStatus = get(connectionStatusAtom);\n\n  try {\n    const isConnected = await apiService.checkServerHealth();\n\n    set(connectionStatusAtom, {\n      ...currentStatus,\n      connected: isConnected,\n      lastConnected: isConnected ? Date.now() : currentStatus.lastConnected,\n      lastError: isConnected ? null : currentStatus.lastError,\n    });\n\n    return isConnected;\n  } catch (error) {\n    set(connectionStatusAtom, {\n      ...currentStatus,\n      connected: false,\n      lastError: error instanceof Error ? error.message : String(error),\n    });\n\n    return false;\n  }\n});\n\n/**\n * Initialize connection monitoring\n */\nexport const initConnectionMonitoringAction = atom(null, (get, set) => {\n  // Perform initial check\n  set(checkConnectionStatusAction);\n\n  // Set up socket event listeners\n  socketService.on(SOCKET_EVENTS.CONNECT, () => {\n    set(connectionStatusAtom, (prev) => ({\n      ...prev,\n      connected: true,\n      lastConnected: Date.now(),\n      lastError: null,\n      reconnecting: false,\n    }));\n  });\n\n  socketService.on(SOCKET_EVENTS.DISCONNECT, (reason) => {\n    set(connectionStatusAtom, (prev) => ({\n      ...prev,\n      connected: false,\n      lastError: `Disconnected: ${reason}`,\n      reconnecting: true,\n    }));\n  });\n\n  socketService.on(SOCKET_EVENTS.RECONNECT_ATTEMPT, () => {\n    set(connectionStatusAtom, (prev) => ({\n      ...prev,\n      reconnecting: true,\n    }));\n  });\n\n  socketService.on(SOCKET_EVENTS.RECONNECT_FAILED, () => {\n    set(connectionStatusAtom, (prev) => ({\n      ...prev,\n      connected: false,\n      reconnecting: false,\n      lastError: 'Failed to reconnect after multiple attempts',\n    }));\n  });\n\n  // Set up periodic health checks\n  const intervalId = setInterval(() => {\n    set(checkConnectionStatusAction);\n  }, 30000); // Check every 30 seconds\n\n  // Return cleanup function\n  return () => {\n    clearInterval(intervalId);\n    socketService.off(SOCKET_EVENTS.CONNECT, () => {});\n    socketService.off(SOCKET_EVENTS.DISCONNECT, () => {});\n    socketService.off(SOCKET_EVENTS.RECONNECT_ATTEMPT, () => {});\n    socketService.off(SOCKET_EVENTS.RECONNECT_FAILED, () => {});\n  };\n});\n","import { API_BASE_URL } from '@/common/constants';\n\n/**\n * 分享配置接口\n */\nexport interface ShareConfig {\n  hasShareProvider: boolean;\n  shareProvider: string | null;\n}\n\n/**\n * 分享结果接口\n */\nexport interface ShareResult {\n  success: boolean;\n  url?: string;\n  html?: string;\n  sessionId?: string;\n  error?: string;\n}\n\n/**\n * 分享服务类 - 处理分享相关功能\n */\nclass ShareService {\n  private shareConfig: ShareConfig | null = null;\n\n  /**\n   * 获取分享配置\n   */\n  async getShareConfig(): Promise<ShareConfig> {\n    if (this.shareConfig) {\n      return this.shareConfig;\n    }\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/share/config`, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to get share config: ${response.statusText}`);\n      }\n\n      this.shareConfig = await response.json();\n      return this.shareConfig as ShareConfig;\n    } catch (error) {\n      console.error('Failed to get share config:', error);\n      // 默认配置\n      return { hasShareProvider: false, shareProvider: null };\n    }\n  }\n\n  /**\n   * 分享会话\n   * @param sessionId 会话ID\n   * @param upload 是否上传到分享提供者（如果存在）\n   */\n  async shareSession(sessionId: string, upload = false): Promise<ShareResult> {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/sessions/share`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ sessionId, upload }),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.error || `Failed to share session: ${response.statusText}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('Failed to share session:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  /**\n   * 下载 HTML 分享文件\n   * @param html HTML 内容\n   * @param sessionId 会话ID\n   */\n  downloadShareHtml(html: string, sessionId: string): void {\n    const blob = new Blob([html], { type: 'text/html' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `agent-tars-${sessionId}-${Date.now()}.html`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  }\n}\n\nexport const shareService = new ShareService();\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA;AAEA;;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAMA;AAEA;AACA;AAMA;AACA;AAEA;AACA;AAMA;AACA;AAEA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACvGA;AAEA;AACA;AAUA;;AAEA;AAEA;;AAEA;AAEA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;;AACA;AAAA;;;;;;AACA;AAAA;;;;;;;;;;;;AAGA;AAEA;AACA;AACA;AACA;;AACA;AAAA;;;;;;AACA;AAAA;;;;;;;;;;;;AAGA;AACA;AACA;;AACA;AAAA;;;;;;AACA;AAAA;;;;;;;;;;;;AAGA;AACA;AACA;;AACA;AAAA;;;;;;AACA;AAAA;;;;;;;;;;;;AAGA;AACA;AACA;;AACA;AAAA;;;;;;AACA;AAAA;;;;;;;;;;;;AAGA;AACA;AACA;;AACA;AAAA;;;;;;AACA;AAAA;;;;;;;;;;;;AAGA;AACA;AACA;;AACA;AAAA;;;;;;AACA;AAAA;;;;;;;;;;;;AAGA;AACA;AACA;;AACA;AAAA;;;;;;AACA;AAAA;;;;;;;;;;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC/FA;AAEA;AAGA;;;;;;;AAOA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAKA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAMA;AAWA;AAVA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;;;AAGA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACpYA;AACA;AAGA;;AAEA;AAQA;;AAEA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AAEA;AAAA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;;AAEA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AAEA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AA2DA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AAEA;AAEA;AADA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AApTA;AACA;AACA;AACA;AACA;AAyLA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AAEA;AAEA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AAIA;AACA;AACA;AAEA;;AAEA;AAEA;AAEA;AACA;AACA;;AAiEA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AChUA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC1FA;AAqBA;;AAEA;AAIA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAxEA;;AAyEA;AAEA"}