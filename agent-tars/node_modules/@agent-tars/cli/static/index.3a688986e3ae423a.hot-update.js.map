{"version":3,"file":"index.3a688986e3ae423a.hot-update.js","sources":["/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/common/state/actions/eventProcessor.ts","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/standalone/chat/Message/components/MessageGroup.tsx","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/standalone/chat/Message/index.tsx"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { atom, Setter, Getter } from 'jotai';\nimport { v4 as uuidv4 } from 'uuid';\nimport { AgentEventStream, ToolResult, Message } from '@/common/types';\nimport { determineToolType } from '@/common/utils/formatters';\nimport { messagesAtom } from '../atoms/message';\nimport { toolResultsAtom, toolCallResultMap } from '../atoms/tool';\nimport { isProcessingAtom, activePanelContentAtom } from '../atoms/ui';\nimport { plansAtom, PlanKeyframe } from '../atoms/plan';\nimport { replayStateAtom } from '../atoms/replay';\nimport { ChatCompletionContentPartImage } from '@multimodal/agent-interface';\n\n// 存储工具调用参数的映射表 (不是 Atom，是内部缓存)\nconst toolCallArgumentsMap = new Map<string, any>();\n\n/**\n * Process a single event and update the appropriate state atoms\n */\nexport const processEventAction = atom(\n  null,\n  (get, set, params: { sessionId: string; event: AgentEventStream.Event }) => {\n    const { sessionId, event } = params;\n    const replayState = get(replayStateAtom);\n    const isReplayMode = replayState.isActive;\n\n    switch (event.type) {\n      case 'user_message':\n        handleUserMessage(set, sessionId, event);\n        break;\n\n      case 'assistant_message':\n        handleAssistantMessage(get, set, sessionId, event);\n        break;\n\n      case 'assistant_streaming_message':\n        if (!isReplayMode) {\n          handleStreamingMessage(get, set, sessionId, event);\n        }\n        break;\n\n      case 'assistant_thinking_message':\n      case 'assistant_streaming_thinking_message':\n        handleThinkingMessage(get, set, sessionId, event);\n        break;\n\n      case 'tool_call':\n        handleToolCall(set, sessionId, event);\n        break;\n\n      case 'tool_result':\n        handleToolResult(set, sessionId, event);\n        break;\n\n      case 'system':\n        handleSystemMessage(set, sessionId, event);\n        break;\n\n      case 'environment_input':\n        handleEnvironmentInput(get, set, sessionId, event);\n        break;\n\n      case 'agent_run_start':\n        set(isProcessingAtom, true);\n        break;\n\n      case 'agent_run_end':\n        set(isProcessingAtom, false);\n        break;\n\n      case 'plan_start':\n        handlePlanStart(set, sessionId, event);\n        break;\n\n      case 'plan_update':\n        handlePlanUpdate(set, sessionId, event);\n        break;\n\n      case 'plan_finish':\n        handlePlanFinish(set, sessionId, event);\n        break;\n\n      case 'final_answer':\n        handleFinalAnswer(get, set, sessionId, event);\n        break;\n\n      case 'final_answer_streaming':\n        if (!isReplayMode) {\n          handleFinalAnswerStreaming(get, set, sessionId, event);\n        }\n        break;\n    }\n  },\n);\n\nexport const updateProcessingStatusAction = atom(\n  null,\n  (get, set, status: { isProcessing: boolean; state?: string }) => {\n    // Update processing state\n    set(isProcessingAtom, !!status.isProcessing);\n  },\n);\n\n/**\n * Handle user message event\n */\nfunction handleUserMessage(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.UserMessageEvent,\n): void {\n  const userMessage: Message = {\n    id: event.id,\n    role: 'user',\n    content: event.content,\n    timestamp: event.timestamp,\n  };\n\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, userMessage],\n    };\n  });\n\n  // Check for images in user message and set active panel content if found\n  if (Array.isArray(event.content)) {\n    const images = event.content.filter((part) => part.type === 'image_url');\n    if (images.length > 0) {\n      set(activePanelContentAtom, {\n        type: 'image',\n        source: images[0].image_url.url,\n        title: 'User Upload',\n        timestamp: Date.now(),\n      });\n    }\n  }\n}\n\n/**\n * Handle assistant message event (complete message)\n */\nfunction handleAssistantMessage(\n  get: any,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.AssistantMessageEvent,\n): void {\n  // 获取消息ID\n  const messageId = event.messageId;\n\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n\n    // 检查是否已存在相同messageId的消息\n    if (messageId) {\n      const existingMessageIndex = sessionMessages.findIndex((msg) => msg.messageId === messageId);\n\n      // 如果找到了现有消息，更新它而不是添加新消息\n      if (existingMessageIndex !== -1) {\n        const updatedMessages = [...sessionMessages];\n        updatedMessages[existingMessageIndex] = {\n          ...updatedMessages[existingMessageIndex],\n          content: event.content,\n          timestamp: event.timestamp,\n          toolCalls: event.toolCalls,\n          finishReason: event.finishReason,\n          isStreaming: false,\n        };\n\n        return {\n          ...prev,\n          [sessionId]: updatedMessages,\n        };\n      }\n    }\n\n    // 没有找到现有消息，添加新消息\n    return {\n      ...prev,\n      [sessionId]: [\n        ...sessionMessages,\n        {\n          id: event.id,\n          role: 'assistant',\n          content: event.content,\n          timestamp: event.timestamp,\n          toolCalls: event.toolCalls,\n          finishReason: event.finishReason,\n          messageId: messageId,\n        },\n      ],\n    };\n  });\n\n  if (event.finishReason !== 'tool_calls') {\n    // 检查是否需要关联最近的环境输入\n    const currentMessages = get(messagesAtom)[sessionId] || [];\n\n    // 从后往前查找最近的环境输入\n    for (let i = currentMessages.length - 1; i >= 0; i--) {\n      const msg = currentMessages[i];\n      if (msg.role === 'environment' && Array.isArray(msg.content)) {\n        const imageContent = msg.content.find(\n          (item) => item.type === 'image_url' && item.image_url && item.image_url.url,\n        );\n\n        if (imageContent) {\n          set(activePanelContentAtom, {\n            type: 'image',\n            source: msg.content,\n            title: msg.description || 'Final Browser State',\n            timestamp: msg.timestamp,\n            environmentId: msg.id,\n          });\n          break;\n        }\n      }\n    }\n  }\n\n  set(isProcessingAtom, false);\n}\n\n/**\n * Handle streaming message event (incremental content)\n */\nfunction handleStreamingMessage(\n  get: any,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.AssistantStreamingMessageEvent,\n): void {\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    const messageIdToFind = event.messageId;\n    let existingMessageIndex = -1;\n\n    // 优先按messageId查找\n    if (messageIdToFind) {\n      existingMessageIndex = sessionMessages.findIndex((msg) => msg.messageId === messageIdToFind);\n    }\n    // 没有messageId或未找到，尝试查找标记为streaming的最后一条消息\n    else if (sessionMessages.length > 0) {\n      const lastMessageIndex = sessionMessages.length - 1;\n      const lastMessage = sessionMessages[lastMessageIndex];\n      if (lastMessage && lastMessage.isStreaming) {\n        existingMessageIndex = lastMessageIndex;\n      }\n    }\n\n    // 更新现有消息\n    if (existingMessageIndex !== -1) {\n      const existingMessage = sessionMessages[existingMessageIndex];\n      const updatedMessage = {\n        ...existingMessage,\n        content:\n          typeof existingMessage.content === 'string'\n            ? existingMessage.content + event.content\n            : event.content,\n        isStreaming: !event.isComplete,\n        toolCalls: event.toolCalls || existingMessage.toolCalls,\n      };\n\n      return {\n        ...prev,\n        [sessionId]: [\n          ...sessionMessages.slice(0, existingMessageIndex),\n          updatedMessage,\n          ...sessionMessages.slice(existingMessageIndex + 1),\n        ],\n      };\n    }\n\n    // 创建新消息\n    const newMessage: Message = {\n      id: event.id || uuidv4(),\n      role: 'assistant',\n      content: event.content,\n      timestamp: event.timestamp,\n      isStreaming: !event.isComplete,\n      toolCalls: event.toolCalls,\n      messageId: event.messageId,\n    };\n\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, newMessage],\n    };\n  });\n\n  if (event.isComplete) {\n    set(isProcessingAtom, false);\n  }\n}\n\n/**\n * Handle thinking message event\n */\nfunction handleThinkingMessage(\n  get: any,\n  set: Setter,\n  sessionId: string,\n  event:\n    | AgentEventStream.AssistantThinkingMessageEvent\n    | AgentEventStream.AssistantStreamingThinkingMessageEvent,\n): void {\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    const lastAssistantIndex = [...sessionMessages]\n      .reverse()\n      .findIndex((m) => m.role === 'assistant');\n\n    if (lastAssistantIndex !== -1) {\n      const actualIndex = sessionMessages.length - 1 - lastAssistantIndex;\n      const message = sessionMessages[actualIndex];\n\n      return {\n        ...prev,\n        [sessionId]: [\n          ...sessionMessages.slice(0, actualIndex),\n          { ...message, thinking: event.content },\n          ...sessionMessages.slice(actualIndex + 1),\n        ],\n      };\n    }\n\n    return prev;\n  });\n}\n\n/**\n * Handle tool call event - store arguments for later use\n */\nfunction handleToolCall(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.ToolCallEvent,\n): void {\n  // 保存工具调用的参数信息以便后续使用\n  if (event.toolCallId && event.arguments) {\n    toolCallArgumentsMap.set(event.toolCallId, event.arguments);\n  }\n}\n\nfunction handleToolResult(set: Setter, sessionId: string, event: AgentEventStream.ToolResultEvent) {\n  // 获取之前存储的参数信息\n  const args = toolCallArgumentsMap.get(event.toolCallId);\n\n  const result: ToolResult = {\n    id: uuidv4(),\n    toolCallId: event.toolCallId,\n    name: event.name,\n    content: event.content,\n    timestamp: event.timestamp,\n    error: event.error,\n    type: determineToolType(event.name, event.content),\n    arguments: args,\n  };\n\n  // 1. 先更新消息atom和工具结果 - 确保chat UI能立即响应\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n\n    // 找到对应的消息并添加toolResults\n    const messageIndex = [...sessionMessages]\n      .reverse()\n      .findIndex((m) => m.toolCalls?.some((tc) => tc.id === result.toolCallId));\n\n    if (messageIndex !== -1) {\n      const actualIndex = sessionMessages.length - 1 - messageIndex;\n      const message = sessionMessages[actualIndex];\n      const toolResults = message.toolResults || [];\n\n      const updatedMessage = {\n        ...message,\n        toolResults: [...toolResults, result],\n      };\n\n      return {\n        ...prev,\n        [sessionId]: [\n          ...sessionMessages.slice(0, actualIndex),\n          updatedMessage,\n          ...sessionMessages.slice(actualIndex + 1),\n        ],\n      };\n    }\n\n    return prev;\n  });\n\n  // 2. 同时更新工具结果atom\n  set(toolResultsAtom, (prev: Record<string, ToolResult[]>) => {\n    const sessionResults = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionResults, result],\n    };\n  });\n\n  // 3. 最后更新workspace面板内容 - 保持时序一致\n  if (result.type === 'browser_vision_control') {\n    set(activePanelContentAtom, (prev) => {\n      if (prev && prev.type === 'image' && prev.environmentId) {\n        // 在这里添加环境ID到已处理列表，避免重复渲染\n        const environmentId = prev.environmentId;\n\n        return {\n          ...prev,\n          type: 'browser_vision_control',\n          source: event.content,\n          title: prev.title,\n          timestamp: event.timestamp,\n          toolCallId: event.toolCallId,\n          error: event.error,\n          arguments: args,\n          originalContent: prev.source,\n\n          environmentId: environmentId,\n          processedEnvironmentIds: [environmentId], // 新增：记录已处理的环境ID\n        };\n      } else {\n        return {\n          type: result.type,\n          source: result.content,\n          title: result.name,\n          timestamp: result.timestamp,\n          toolCallId: result.toolCallId,\n          error: result.error,\n          arguments: args,\n        };\n      }\n    });\n  } else {\n    set(activePanelContentAtom, {\n      type: result.type,\n      source: result.content,\n      title: result.name,\n      timestamp: result.timestamp,\n      toolCallId: result.toolCallId,\n      error: result.error,\n      arguments: args,\n    });\n  }\n\n  // Store in the map for future reference\n  toolCallResultMap.set(result.toolCallId, result);\n}\n\n/**\n * Handle system message event\n */\nfunction handleSystemMessage(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.Event & { message: string; level?: string },\n): void {\n  const systemMessage: Message = {\n    id: uuidv4(),\n    role: 'system',\n    content: event.message,\n    timestamp: event.timestamp || Date.now(),\n  };\n\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, systemMessage],\n    };\n  });\n}\n\n/**\n * Handle environment input event\n * Adds it to messages but doesn't set it as active panel content\n */\nfunction handleEnvironmentInput(\n  get: Getter,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.EnvironmentInputEvent,\n): void {\n  const environmentMessage: Message = {\n    id: event.id,\n    role: 'environment',\n    content: event.content,\n    timestamp: event.timestamp,\n    description: event.description || 'Environment Input',\n  };\n\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, environmentMessage],\n    };\n  });\n  // 检查是否包含图片内容并直接设置为活动面板内容\n  if (Array.isArray(event.content)) {\n    const imageContent = event.content.find(\n      (item) => item.type === 'image_url' && item.image_url && item.image_url.url,\n    ) as ChatCompletionContentPartImage;\n\n    if (imageContent && imageContent.image_url) {\n      // 获取当前面板状态\n      const currentPanel = get(activePanelContentAtom);\n\n      // 只有当前面板是 browser_vision_control 类型时才更新\n      if (currentPanel && currentPanel.type === 'browser_vision_control') {\n        set(activePanelContentAtom, {\n          ...currentPanel,\n          type: 'browser_vision_control',\n          title: `${currentPanel.title} · Screenshot Update`,\n          timestamp: event.timestamp,\n          originalContent: event.content,\n          environmentId: event.id,\n        });\n      }\n      // 不是 browser_vision_control 类型时完全跳过 set 操作\n      // 这样避免了 Browser Screenshot 被重复渲染\n    }\n  }\n}\n\n/**\n * Handle plan start event\n */\nfunction handlePlanStart(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.PlanStartEvent,\n): void {\n  set(plansAtom, (prev: Record<string, any>) => ({\n    ...prev,\n    [sessionId]: {\n      steps: [],\n      isComplete: false,\n      summary: null,\n      hasGeneratedPlan: true,\n      keyframes: [], // Initialize empty keyframes array\n    },\n  }));\n}\n\n/**\n * Handle plan update event\n */\nfunction handlePlanUpdate(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.PlanUpdateEvent,\n): void {\n  console.log('Plan update event:', event);\n  set(plansAtom, (prev: Record<string, any>) => {\n    const currentPlan = prev[sessionId] || {\n      steps: [],\n      isComplete: false,\n      summary: null,\n      hasGeneratedPlan: true,\n      keyframes: [],\n    };\n\n    // Create a new keyframe for this update\n    const newKeyframe: PlanKeyframe = {\n      timestamp: event.timestamp || Date.now(),\n      steps: event.steps,\n      isComplete: false,\n      summary: null,\n    };\n\n    // Add the keyframe to the history\n    const keyframes = [...(currentPlan.keyframes || []), newKeyframe];\n\n    return {\n      ...prev,\n      [sessionId]: {\n        ...currentPlan,\n        steps: event.steps,\n        hasGeneratedPlan: true,\n        keyframes,\n      },\n    };\n  });\n}\n\n/**\n * Handle plan finish event\n */\nfunction handlePlanFinish(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.Event & { sessionId: string; summary: string },\n): void {\n  console.log('Plan finish event:', event);\n  set(plansAtom, (prev: Record<string, any>) => {\n    const currentPlan = prev[sessionId] || {\n      steps: [],\n      isComplete: false,\n      summary: null,\n      hasGeneratedPlan: true,\n      keyframes: [],\n    };\n\n    // Create a final keyframe for the completed plan\n    const finalKeyframe: PlanKeyframe = {\n      timestamp: event.timestamp || Date.now(),\n      steps: currentPlan.steps,\n      isComplete: true,\n      summary: event.summary,\n    };\n\n    // Add the final keyframe to the history\n    const keyframes = [...(currentPlan.keyframes || []), finalKeyframe];\n\n    return {\n      ...prev,\n      [sessionId]: {\n        ...currentPlan,\n        isComplete: true,\n        summary: event.summary,\n        keyframes,\n      },\n    };\n  });\n}\n\n/**\n * Handle final answer event (complete answer/report)\n */\nfunction handleFinalAnswer(\n  get: any,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.FinalAnswerEvent,\n): void {\n  const messageId = event.messageId || `final-answer-${uuidv4()}`;\n\n  // 始终将内容当作研究报告处理，移除JSON_DATA状态\n  // 设置活动面板内容为研究报告\n  set(activePanelContentAtom, {\n    type: 'research_report',\n    source: event.content,\n    title: event.title || 'Research Report',\n    timestamp: event.timestamp,\n    isDeepResearch: true,\n    messageId,\n  });\n\n  // 添加消息到聊天引用报告\n  const finalAnswerMessage: Message = {\n    id: event.id || uuidv4(),\n    role: 'final_answer',\n    content: event.content, // 存储完整内容以便后续访问\n    timestamp: event.timestamp,\n    messageId,\n    isDeepResearch: true,\n    title: event.title || 'Research Report',\n  };\n\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, finalAnswerMessage],\n    };\n  });\n\n  // 标记处理完成\n  set(isProcessingAtom, false);\n}\n\nfunction handleFinalAnswerStreaming(\n  get: any,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.Event & {\n    content: string;\n    isDeepResearch: boolean;\n    isComplete?: boolean;\n    messageId?: string;\n    title?: string;\n  },\n): void {\n  const messageId = event.messageId || `final-answer-${uuidv4()}`;\n\n  // 从当前消息列表中查找已有的相同 messageId 的消息\n  const messages = get(messagesAtom)[sessionId] || [];\n  const existingMessageIndex = messages.findIndex((msg) => msg.messageId === messageId);\n\n  // 当处理一系列流式事件时，将内容追加到现有消息，或创建新消息\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n\n    // 如果找到现有消息，则更新它\n    if (existingMessageIndex >= 0) {\n      const existingMessage = sessionMessages[existingMessageIndex];\n      const updatedMessage = {\n        ...existingMessage,\n        content:\n          typeof existingMessage.content === 'string'\n            ? existingMessage.content + event.content\n            : event.content,\n        isStreaming: !event.isComplete,\n        timestamp: event.timestamp,\n      };\n\n      return {\n        ...prev,\n        [sessionId]: [\n          ...sessionMessages.slice(0, existingMessageIndex),\n          updatedMessage,\n          ...sessionMessages.slice(existingMessageIndex + 1),\n        ],\n      };\n    }\n\n    // 否则创建新消息\n    const newMessage: Message = {\n      id: event.id || uuidv4(),\n      role: 'final_answer',\n      content: event.content,\n      timestamp: event.timestamp,\n      messageId,\n      isDeepResearch: true,\n      isStreaming: !event.isComplete,\n      title: event.title || 'Research Report',\n    };\n\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, newMessage],\n    };\n  });\n\n  // 更新活动面板内容 - 同步面板与消息状态\n  set(activePanelContentAtom, (prev: any) => {\n    // 如果是新流或不同的messageId，重新开始\n    if (!prev || prev.type !== 'research_report' || prev.messageId !== messageId) {\n      return {\n        role: 'assistant',\n        type: 'research_report',\n        source: event.content,\n        title: event.title || 'Research Report (Generating...)',\n        timestamp: event.timestamp,\n        isDeepResearch: true,\n        messageId,\n        isStreaming: !event.isComplete,\n      };\n    }\n\n    // 否则追加到现有内容\n    return {\n      ...prev,\n      source: prev.source + event.content,\n      isStreaming: !event.isComplete,\n      timestamp: event.timestamp,\n      title: event.title || prev.title,\n    };\n  });\n\n  // 如果这是第一个数据块，也添加一条消息到聊天\n  const prevActivePanelContent = get(activePanelContentAtom);\n  if (!prevActivePanelContent || prevActivePanelContent.messageId !== messageId) {\n    const initialMessage: Message = {\n      id: event.id || uuidv4(),\n      role: 'final_answer',\n      content: event.content, // 存储初始内容\n      timestamp: event.timestamp,\n      messageId,\n      isDeepResearch: true,\n      isStreaming: !event.isComplete,\n      title: event.title || 'Research Report',\n    };\n\n    set(messagesAtom, (prev: Record<string, Message[]>) => {\n      const sessionMessages = prev[sessionId] || [];\n      return {\n        ...prev,\n        [sessionId]: [...sessionMessages, initialMessage],\n      };\n    });\n  } else if (event.isComplete) {\n    // 当流式生成完成时，更新消息的完整内容\n    const fullContent = get(activePanelContentAtom).source;\n\n    set(messagesAtom, (prev: Record<string, Message[]>) => {\n      const sessionMessages = prev[sessionId] || [];\n      const messageIndex = sessionMessages.findIndex((msg) => msg.messageId === messageId);\n\n      if (messageIndex >= 0) {\n        const updatedMessages = [...sessionMessages];\n        updatedMessages[messageIndex] = {\n          ...updatedMessages[messageIndex],\n          content: fullContent,\n          isStreaming: false,\n          title: event.title || updatedMessages[messageIndex].title || 'Research Report',\n        };\n\n        return {\n          ...prev,\n          [sessionId]: updatedMessages,\n        };\n      }\n\n      return prev;\n    });\n  }\n\n  // 如果这是最后一个数据块，标记处理完成\n  if (event.isComplete) {\n    set(isProcessingAtom, false);\n  }\n}\n","import React from 'react';\nimport { Message as MessageType } from '@/common/types';\nimport { Message } from '../index';\nimport { FiClock } from 'react-icons/fi';\nimport { formatTimestamp } from '@/common/utils/formatters';\nimport { isMultimodalContent } from '@/common/utils/typeGuards';\nimport { ThinkingAnimation } from './ThinkingAnimation';\n\ninterface MessageGroupProps {\n  messages: MessageType[];\n  isThinking: boolean;\n}\n\n/**\n * MessageGroup Component - Groups related messages in a thinking sequence\n *\n * Design principles:\n * - Minimalist design with no avatars or indentation\n * - Clean, full-width message layout\n * - All intermediate thinking steps are always visible\n * - Visual hierarchy emphasizing final answers\n * - Consistent monochromatic styling\n */\nexport const MessageGroup: React.FC<MessageGroupProps> = ({ messages, isThinking }) => {\n  // 过滤掉环境消息\n  const filteredMessages = messages.filter((msg) => msg.role !== 'environment');\n\n  // 如果过滤后没有消息，则不渲染任何内容\n  if (filteredMessages.length === 0) {\n    return null;\n  }\n\n  // 如果只有一条消息，检查是否需要拆分\n  if (filteredMessages.length === 1) {\n    const message = filteredMessages[0];\n\n    // 检查是否是包含图片和文本的多模态用户消息\n    if (message.role === 'user' && isMultimodalContent(message.content)) {\n      const imageContents = message.content.filter((part) => part.type === 'image_url');\n      const textContents = message.content.filter((part) => part.type === 'text');\n\n      // 只有同时包含图片和文本时才拆分显示\n      if (imageContents.length > 0 && textContents.length > 0) {\n        return (\n          <div className=\"space-y-3\">\n            {/* 先显示图片消息 */}\n            <Message\n              key={`${message.id}-images`}\n              message={{\n                ...message,\n                content: imageContents,\n                id: `${message.id}-images`,\n              }}\n            />\n\n            {/* 再显示文本消息 */}\n            <Message\n              key={`${message.id}-text`}\n              message={{\n                ...message,\n                content: textContents,\n                id: `${message.id}-text`,\n              }}\n            />\n          </div>\n        );\n      }\n    }\n\n    return <Message message={filteredMessages[0]} />;\n  }\n\n  // 获取第一条消息 - 通常是用户消息\n  const firstMessage = filteredMessages[0];\n\n  // If not a user message, use simplified rendering\n  if (firstMessage.role !== 'user') {\n    return (\n      <div className=\"space-y-3\">\n        {filteredMessages.map((message, index) => (\n          <Message\n            key={message.id}\n            message={message}\n            isInGroup={index > 0 && index < filteredMessages.length - 1}\n            isIntermediate={index > 0 && index < filteredMessages.length - 1}\n            shouldDisplayTimestamp={false}\n          />\n        ))}\n      </div>\n    );\n  }\n\n  // For user-initiated groups, use enhanced rendering with thinking sequence\n\n  const responseMessage = filteredMessages.length > 1 ? filteredMessages[1] : null;\n  const intermediateMessages = filteredMessages.slice(2, -1);\n  const lastMessage = filteredMessages[filteredMessages.length - 1];\n\n  const hasFinalAnswer = lastMessage.role === 'assistant' && lastMessage.finishReason === 'stop';\n  const finalMessage = hasFinalAnswer ? lastMessage : null;\n\n  const hasThinkingSteps = intermediateMessages.length > 0;\n\n  // 检查用户消息是否需要拆分\n  if (isMultimodalContent(firstMessage.content)) {\n    const imageContents = firstMessage.content.filter((part) => part.type === 'image_url');\n    const textContents = firstMessage.content.filter((part) => part.type === 'text');\n\n    // 只有同时包含图片和文本时才拆分显示\n    if (imageContents.length > 0 && textContents.length > 0) {\n      return (\n        <div className=\"message-group-container space-y-3\">\n          {/* 先显示图片消息 */}\n          <Message\n            message={{\n              ...firstMessage,\n              content: imageContents,\n              id: `${firstMessage.id}-images`,\n            }}\n          />\n\n          {/* 再显示文本消息 */}\n          <Message\n            message={{\n              ...firstMessage,\n              content: textContents,\n              id: `${firstMessage.id}-text`,\n            }}\n          />\n\n          {/* Assistant response section with all assistant-related messages */}\n          {responseMessage && (\n            <div className=\"assistant-response-container\">\n              {/* Initial response message - marked as in-group */}\n              <Message message={responseMessage} isInGroup={true} />\n\n              {/* Thinking process section - always shown */}\n              {hasThinkingSteps && (\n                <div className=\"thinking-steps-container\">\n                  {intermediateMessages.map((msg) => (\n                    <Message key={msg.id} message={msg} isIntermediate={true} isInGroup={true} />\n                  ))}\n\n                  {!isThinking && (\n                    <div className=\"mt-1 mb-2\">\n                      <div className=\"flex items-center text-xs text-gray-500 dark:text-gray-400 py-1\">\n                        <FiClock size={10} className=\"mr-1\" />\n                        {responseMessage && formatTimestamp(responseMessage.timestamp)}\n                      </div>\n                    </div>\n                  )}\n                </div>\n              )}\n\n              {/* Final answer - if exists and not currently thinking */}\n              {finalMessage && finalMessage !== responseMessage && !isThinking && (\n                <Message message={finalMessage} isInGroup={false} />\n              )}\n\n              {/* 移除背景的思考加载动画 */}\n              {isThinking && (\n                <div className=\"mt-2 pl-1\">\n                  <ThinkingAnimation />\n                </div>\n              )}\n            </div>\n          )}\n        </div>\n      );\n    }\n  }\n\n  return (\n    <div className=\"message-group-container space-y-3\">\n      {/* User message is always displayed */}\n      <Message message={firstMessage} />\n\n      {/* Assistant response section with all assistant-related messages */}\n      {responseMessage && (\n        <div className=\"assistant-response-container\">\n          {/* Initial response message - marked as in-group */}\n          <Message message={responseMessage} isInGroup={true} />\n\n          {/* Thinking process section - always shown */}\n          {hasThinkingSteps && (\n            <div className=\"thinking-steps-container\">\n              {intermediateMessages.map((msg) => (\n                <Message key={msg.id} message={msg} isIntermediate={true} isInGroup={true} />\n              ))}\n\n              {!isThinking && (\n                <div className=\"mt-1 mb-2\">\n                  <div className=\"flex items-center text-xs text-gray-500 dark:text-gray-400 py-1\">\n                    <FiClock size={10} className=\"mr-1\" />\n                    {responseMessage && formatTimestamp(responseMessage.timestamp)}\n                  </div>\n                </div>\n              )}\n            </div>\n          )}\n\n          {/* Final answer - if exists and not currently thinking */}\n          {finalMessage && finalMessage !== responseMessage && !isThinking && (\n            <Message message={finalMessage} isInGroup={false} />\n          )}\n\n          {/* 移除背景的思考加载动画 */}\n          {isThinking && (\n            <div className=\"mt-2 pl-1\">\n              <ThinkingAnimation />\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n};","import React, { useState } from 'react';\nimport { motion } from 'framer-motion';\nimport { isMultimodalContent } from '@/common/utils/typeGuards';\nimport { ChatCompletionContentPart, Message as MessageType } from '@/common/types';\nimport { useSession } from '@/common/hooks/useSession';\nimport { useTool } from '@/common/hooks/useTool';\nimport { MarkdownRenderer } from '@/sdk/markdown-renderer';\nimport './Message.css';\n\n// Import sub-components\nimport { SystemMessage } from './components/SystemMessage';\nimport { MultimodalContent } from './components/MultimodalContent';\nimport { AssistantExpandableContent } from './components/AssistantExpandableContent';\nimport { ToolCalls } from './components/ToolCalls';\nimport { ThinkingToggle } from './components/ThinkingToggle';\nimport { MessageTimestamp } from './components/MessageTimestamp';\nimport { ThinkingAnimation } from './components/ThinkingAnimation';\nimport { useAtomValue } from 'jotai';\nimport { replayStateAtom } from '@/common/state/atoms/replay';\nimport { ReportFileEntry } from './components/ReportFileEntry';\nimport { messagesAtom } from '@/common/state/atoms/message';\nimport { FiMonitor } from 'react-icons/fi';\nimport { ActionButton } from './components/ActionButton';\n\ninterface MessageProps {\n  message: MessageType;\n  shouldDisplayTimestamp?: boolean;\n  isIntermediate?: boolean;\n  isInGroup?: boolean;\n}\n\n/**\n * Message Component - Displays a single message in the chat\n *\n * Design principles:\n * - Minimalist black & white design with no avatars\n * - Clean, full-width message bubbles with subtle differentiation\n * - Focus on content with minimal visual distractions\n * - Elegant spacing and typography\n * - Progressive disclosure for detailed content\n */\nexport const Message: React.FC<MessageProps> = ({\n  message,\n  isIntermediate = false,\n  isInGroup = false,\n  shouldDisplayTimestamp = true,\n}) => {\n  const [showThinking, setShowThinking] = useState(false);\n  const [showSteps, setShowSteps] = useState(false);\n  const { setActivePanelContent, activeSessionId } = useSession();\n  const { getToolIcon } = useTool();\n  const replayState = useAtomValue(replayStateAtom);\n  const allMessages = useAtomValue(messagesAtom);\n\n  const isMultimodal = isMultimodalContent(message.content);\n  const isEnvironment = message.role === 'environment';\n  const isUserMessage = message.role === 'user';\n\n  const isFinalAnswer = message.role === 'final_answer' || message.isDeepResearch;\n\n  // Check if this is a final assistant response\n  const isFinalAssistantResponse = message.role === 'assistant' && message.finishReason === 'stop';\n\n  // Handle tool call click - show in panel\n  const handleToolCallClick = (toolCall: any) => {\n    if (message.toolResults && message.toolResults.length > 0) {\n      const result = message.toolResults.find((r) => r.toolCallId === toolCall.id);\n      if (result) {\n        setActivePanelContent({\n          type: result.type,\n          source: result.content,\n          title: result.name,\n          timestamp: result.timestamp,\n          toolCallId: result.toolCallId,\n          error: result.error,\n          arguments: result.arguments,\n        });\n      }\n    }\n  };\n\n  // Handle click on final assistant response to show latest environment state\n  const handleFinalResponseClick = () => {\n    if (!activeSessionId || !isFinalAssistantResponse) return;\n\n    const sessionMessages = allMessages[activeSessionId] || [];\n\n    // Find the most recent environment input\n    for (let i = sessionMessages.length - 1; i >= 0; i--) {\n      const msg = sessionMessages[i];\n      if (msg.role === 'environment' && Array.isArray(msg.content)) {\n        const imageContent = msg.content.find(\n          (item) => item.type === 'image_url' && item.image_url && item.image_url.url,\n        );\n\n        if (imageContent) {\n          setActivePanelContent({\n            type: 'image',\n            source: msg.content,\n            title: msg.description || 'Final Environment State',\n            timestamp: msg.timestamp,\n            environmentId: msg.id,\n          });\n          break;\n        }\n      }\n    }\n  };\n\n  // Render content based on type\n  const renderContent = () => {\n    if (isMultimodal) {\n      return (\n        <MultimodalContent\n          content={message.content as ChatCompletionContentPart[]}\n          timestamp={message.timestamp}\n          setActivePanelContent={setActivePanelContent}\n        />\n      );\n    }\n\n    // For assistant messages with tool calls, first show summary\n    if (message.role === 'assistant' && message.toolCalls && message.toolCalls.length > 0) {\n      return (\n        <AssistantExpandableContent\n          content={message.content as string}\n          showSteps={showSteps}\n          setShowSteps={setShowSteps}\n        />\n      );\n    }\n\n    return <MarkdownRenderer content={message.content as string} forceDarkTheme={isUserMessage} />;\n  };\n\n  // Message animation variants\n  const messageVariants = {\n    initial: { opacity: 0, y: 10 },\n    animate: { opacity: 1, y: 0 },\n    transition: { duration: 0.3 },\n  };\n\n  // Determine message bubble style based on role and state\n  const getMessageBubbleClasses = () => {\n    let baseClasses = '';\n\n    if (message.role === 'user') {\n      if (isImageOnlyMessage) {\n        baseClasses = 'message-user message-user-image';\n      } else {\n        baseClasses = 'message-user';\n      }\n    } else if (message.role === 'system') {\n      baseClasses = 'message-system';\n    } else if (message.role === 'environment') {\n      baseClasses = 'environment-message-minimal';\n    } else {\n      baseClasses = 'message-assistant';\n    }\n\n    // 添加更平滑的点击样式\n    if (isFinalAssistantResponse) {\n      baseClasses += ' cursor-pointer transition-all duration-300';\n    }\n\n    return baseClasses;\n  };\n\n  // 检查消息是否只包含图片（用于样式优化）\n  const isImageOnlyMessage = React.useMemo(() => {\n    if (!isMultimodalContent(message.content)) return false;\n\n    const imageContents = message.content.filter((part) => part.type === 'image_url');\n    const textContents = message.content.filter((part) => part.type === 'text');\n\n    return imageContents.length > 0 && textContents.length === 0;\n  }, [message.content]);\n\n  // 检查消息是否只包含文本（用于样式优化）\n  const isTextOnlyMessage = React.useMemo(() => {\n    if (!isMultimodalContent(message.content)) return true;\n\n    const imageContents = message.content.filter((part) => part.type === 'image_url');\n    const textContents = message.content.filter((part) => part.type === 'text');\n\n    return textContents.length > 0 && imageContents.length === 0;\n  }, [message.content]);\n\n  // 检查是否有环境状态可显示\n  const hasEnvironmentState = React.useMemo(() => {\n    if (!activeSessionId || !isFinalAssistantResponse || !allMessages[activeSessionId])\n      return false;\n\n    const sessionMessages = allMessages[activeSessionId] || [];\n    // 检查是否有环境消息\n    return sessionMessages.some(\n      (msg) =>\n        msg.role === 'environment' &&\n        Array.isArray(msg.content) &&\n        msg.content.some(\n          (item) => item.type === 'image_url' && item.image_url && item.image_url.url,\n        ),\n    );\n  }, [activeSessionId, isFinalAssistantResponse, allMessages]);\n\n  return (\n    <motion.div\n      initial=\"initial\"\n      animate=\"animate\"\n      variants={messageVariants}\n      className={`message-container ${message.role === 'user' ? 'message-container-user' : 'message-container-assistant'} ${isIntermediate ? 'message-container-intermediate' : ''}`}\n    >\n      <div\n        className={`message-bubble ${getMessageBubbleClasses()} ${isIntermediate ? 'message-bubble-intermediate' : ''}`}\n      >\n        {/* Role-based content */}\n        {message.role === 'system' ? (\n          <SystemMessage content={message.content as string} />\n        ) : (\n          <>\n            <div\n              className={`prose ${message.role === 'user' ? 'prose-invert' : 'dark:prose-invert'} prose-sm max-w-none text-sm`}\n            >\n              {renderContent()}\n            </div>\n\n            {/* 使用 ActionButton 替代 ViewEnvironmentButton */}\n            {isFinalAssistantResponse && !isIntermediate && !isInGroup && hasEnvironmentState && (\n              <ActionButton\n                icon={<FiMonitor size={14} />}\n                label=\"view final environment state\"\n                onClick={handleFinalResponseClick}\n              />\n            )}\n\n            {/* 总是显示最终答案/研究报告的文件入口，除非是中间消息或组内消息 */}\n            {isFinalAnswer &&\n              message.title &&\n              typeof message.content === 'string' &&\n              !isIntermediate &&\n              !isInGroup && (\n                <ReportFileEntry\n                  title={message.title || 'Research Report'}\n                  timestamp={message.timestamp}\n                  content={message.content}\n                />\n              )}\n\n            {/* Tool calls section - now with loading states and status icons */}\n            {message.toolCalls && message.toolCalls.length > 0 && (\n              <ToolCalls\n                toolCalls={message.toolCalls}\n                onToolCallClick={handleToolCallClick}\n                getToolIcon={getToolIcon}\n                isIntermediate={isIntermediate}\n                toolResults={message.toolResults || []} // Pass tool results for status checking\n              />\n            )}\n\n            {/* Thinking section */}\n            {message.thinking && (\n              <ThinkingToggle\n                thinking={message.thinking}\n                showThinking={showThinking}\n                setShowThinking={setShowThinking}\n              />\n            )}\n          </>\n        )}\n      </div>\n\n      {/* Timestamp and copy button - only for main messages */}\n      {message.role !== 'system' &&\n        !isIntermediate &&\n        !isInGroup &&\n        shouldDisplayTimestamp &&\n        !replayState.isActive && (\n          <MessageTimestamp\n            timestamp={message.timestamp}\n            content={message.content}\n            role={message.role}\n          />\n        )}\n    </motion.div>\n  );\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AAGA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAOA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AASA;AACA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;;;AAGA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAYA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9yBA;AAEA;AACA;AACA;AACA;AACA;AAOA;;;;;;;;;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AALA;;;;;AASA;AAEA;AACA;AACA;AACA;AACA;AALA;;;;;;;;;;;AASA;AACA;AAEA;AAAA;;;;;;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAJA;;;;;;;;;;AASA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;AAIA;AACA;;AAEA;AAAA;AAAA;;;;;;AAGA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;;;;;AAGA;AACA;AACA;AAAA;;AACA;AAAA;AAAA;;;;;;AACA;;;;;;;;;;;;;;;;;;AAQA;AACA;AAAA;;;;;;AAIA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AAOA;AACA;AAEA;AACA;;AAEA;AAAA;;;;;;AAGA;AACA;;AAEA;AAAA;AAAA;;;;;;AAGA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;;;;;AAGA;AACA;AACA;AAAA;;AACA;AAAA;AAAA;;;;;;AACA;;;;;;;;;;;;;;;;;;AAQA;AACA;AAAA;;;;;;AAIA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AAOA;AAjMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AASA;;;;;;;;;AASA;AACA;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;;AAGA;AAEA;AAAA;AAAA;;;;;;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAQA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAGA;AACA;;;;;AAEA;;AACA;AACA;AAEA;;;;;;AAIA;AAEA;AAAA;;;;;;AACA;AACA;;;;;;AAKA;AAMA;AACA;AACA;;;;;;AAKA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAKA;AAEA;AACA;AACA;;;;;;;;;;;;;AAQA;AAMA;AACA;AACA;;;;;;;;;;;;AAKA;AApPA;;AAQA;AACA;AACA;AACA;;;AAXA"}