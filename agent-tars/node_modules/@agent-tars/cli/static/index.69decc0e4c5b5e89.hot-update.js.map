{"version":3,"file":"index.69decc0e4c5b5e89.hot-update.js","sources":["/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/entry.css","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/main/hooks/useReplay.ts"],"sourcesContent":["// extracted by css-extract-rspack-plugin\nexport {};\n    if(module.hot) {\n      (function() {\n        var localsJsonString = undefined;\n        // 1749664229580\n        var cssReload = require(\"../../node_modules/.pnpm/@rspack+core@1.3.9_@swc+helpers@0.5.17/node_modules/@rspack/core/dist/cssExtractHmr.js\").cssReload(module.id, {});\n        // only invalidate when locals change\n        if (\n          module.hot.data &&\n          module.hot.data.value &&\n          module.hot.data.value !== localsJsonString\n        ) {\n          module.hot.invalidate();\n        } else {\n          module.hot.accept();\n        }\n        module.hot.dispose(function(data) {\n          data.value = localsJsonString;\n          cssReload();\n        });\n      })();\n    }\n  ","// /agent-tars-web-ui/src/v2/hooks/useReplay.ts\nimport { useAtom } from 'jotai';\nimport { useCallback, useEffect, useState } from 'react';\nimport { replayStateAtom } from '../state/atoms/replay';\nimport { useSession } from './useSession';\nimport { messagesAtom } from '../state/atoms/message';\nimport { toolResultsAtom } from '../state/atoms/tool';\nimport { processEventAction } from '../state/actions/eventProcessor';\nimport { useSetAtom } from 'jotai';\nimport { plansAtom } from '../state/atoms/plan';\n\n/**\n * Custom hook for managing replay functionality\n *\n * Provides:\n * - Control for playback (play, pause, jump, etc.)\n * - Event processing through the standard event processor\n * - Timeline calculations and positioning\n */\nexport function useReplay() {\n  const [replayState, setReplayState] = useAtom(replayStateAtom);\n  const { activeSessionId } = useSession();\n  const [playbackInterval, setPlaybackInterval] = useState<NodeJS.Timeout | null>(null);\n  const [, setMessages] = useAtom(messagesAtom);\n  const [, setToolResults] = useAtom(toolResultsAtom);\n  const [, setPlans] = useAtom(plansAtom);\n  const processEvent = useSetAtom(processEventAction);\n\n  /**\n   * 重置会话状态并处理事件至指定索引\n   */\n  const processEventsUpToIndex = useCallback(\n    (targetIndex: number) => {\n      if (!activeSessionId || !replayState.events.length || targetIndex < 0) return;\n\n      // 获取需要处理的事件\n      const eventsToProcess = replayState.events.slice(0, targetIndex + 1);\n\n      // 清空当前会话状态\n      setMessages((prev) => ({\n        ...prev,\n        [activeSessionId]: [],\n      }));\n\n      setToolResults((prev) => ({\n        ...prev,\n        [activeSessionId]: [],\n      }));\n\n      setPlans((prev) => ({\n        ...prev,\n        [activeSessionId]: {\n          steps: [],\n          isComplete: false,\n          summary: null,\n          hasGeneratedPlan: false,\n          keyframes: [],\n        },\n      }));\n\n      // 处理环境输入事件优先，确保图片资源先加载\n      const envEvents = eventsToProcess.filter((event) => event.type === 'environment_input');\n      const nonEnvEvents = eventsToProcess.filter((event) => event.type !== 'environment_input');\n\n      // 先处理环境输入事件\n      for (const event of envEvents) {\n        processEvent({ sessionId: activeSessionId, event });\n      }\n\n      // 然后处理其他事件\n      for (const event of nonEnvEvents) {\n        processEvent({ sessionId: activeSessionId, event });\n      }\n    },\n    [activeSessionId, replayState.events, setMessages, setToolResults, setPlans, processEvent],\n  );\n\n  /**\n   * 开始回放\n   */\n  const startReplay = useCallback(() => {\n    // 清除现有的定时器\n    if (playbackInterval) {\n      clearInterval(playbackInterval);\n    }\n\n    setReplayState((prev) => ({\n      ...prev,\n      isPaused: false,\n    }));\n\n    // 设置定时器按间隔前进\n    const interval = setInterval(() => {\n      setReplayState((prev) => {\n        // 到达末尾时停止\n        if (prev.currentEventIndex >= prev.events.length - 1) {\n          clearInterval(interval);\n          return {\n            ...prev,\n            isPaused: true,\n            currentEventIndex: prev.events.length - 1,\n          };\n        }\n\n        // 前进到下一个事件\n        const nextIndex = prev.currentEventIndex + 1;\n\n        // 处理到新位置\n        if (activeSessionId) {\n          processEvent({\n            sessionId: activeSessionId,\n            event: prev.events[nextIndex],\n          });\n        }\n\n        return {\n          ...prev,\n          currentEventIndex: nextIndex,\n        };\n      });\n    }, 500 / replayState.playbackSpeed);\n\n    setPlaybackInterval(interval);\n  }, [activeSessionId, playbackInterval, processEvent, replayState.playbackSpeed, setReplayState]);\n\n  /**\n   * 暂停回放\n   */\n  const pauseReplay = useCallback(() => {\n    if (playbackInterval) {\n      clearInterval(playbackInterval);\n      setPlaybackInterval(null);\n    }\n\n    setReplayState((prev) => ({\n      ...prev,\n      isPaused: true,\n    }));\n  }, [playbackInterval, setReplayState]);\n\n  /**\n   * 跳转到时间轴上的指定位置\n   */\n  const jumpToPosition = useCallback(\n    (position: number) => {\n      // 确保位置在有效范围内\n      const normalizedPosition = Math.max(0, Math.min(1, position));\n\n      if (replayState.events.length === 0 || !activeSessionId) return;\n\n      // 根据位置计算目标事件索引\n      const targetIndex = Math.floor(normalizedPosition * (replayState.events.length - 1));\n\n      // 暂停任何正在进行的回放\n      if (playbackInterval) {\n        clearInterval(playbackInterval);\n        setPlaybackInterval(null);\n      }\n\n      // 处理到新位置\n      processEventsUpToIndex(targetIndex);\n\n      setReplayState((prev) => ({\n        ...prev,\n        isPaused: true,\n        currentEventIndex: targetIndex,\n      }));\n    },\n    [\n      activeSessionId,\n      playbackInterval,\n      processEventsUpToIndex,\n      replayState.events.length,\n      setReplayState,\n    ],\n  );\n\n  /**\n   * 跳转到最终结果\n   */\n  const jumpToResult = useCallback(() => {\n    if (replayState.events.length === 0 || !activeSessionId) return;\n\n    const finalIndex = replayState.events.length - 1;\n\n    // 暂停任何正在进行的回放\n    if (playbackInterval) {\n      clearInterval(playbackInterval);\n      setPlaybackInterval(null);\n    }\n\n    // 处理到最终位置\n    processEventsUpToIndex(finalIndex);\n\n    setReplayState((prev) => ({\n      ...prev,\n      isPaused: true,\n      currentEventIndex: finalIndex,\n    }));\n  }, [\n    activeSessionId,\n    playbackInterval,\n    processEventsUpToIndex,\n    replayState.events.length,\n    setReplayState,\n  ]);\n\n  /**\n   * 重置回放到初始状态，允许从头开始播放\n   */\n  const resetReplay = useCallback(() => {\n    // 暂停任何正在进行的回放\n    if (playbackInterval) {\n      clearInterval(playbackInterval);\n      setPlaybackInterval(null);\n    }\n\n    // 处理到初始位置\n    processEventsUpToIndex(0);\n\n    setReplayState((prev) => ({\n      ...prev,\n      isPaused: true,\n      currentEventIndex: 0,\n    }));\n  }, [playbackInterval, processEventsUpToIndex, setReplayState]);\n\n  /**\n   * 设置播放速度\n   */\n  const setPlaybackSpeed = useCallback(\n    (speed: number) => {\n      setReplayState((prev) => ({\n        ...prev,\n        playbackSpeed: speed,\n      }));\n\n      // 如果正在播放，以新速度重启\n      if (!replayState.isPaused && playbackInterval) {\n        clearInterval(playbackInterval);\n        startReplay();\n      }\n    },\n    [playbackInterval, replayState.isPaused, setReplayState, startReplay],\n  );\n\n  /**\n   * 退出回放模式\n   */\n  const exitReplay = useCallback(() => {\n    if (playbackInterval) {\n      clearInterval(playbackInterval);\n    }\n\n    setReplayState((prev) => ({\n      ...prev,\n      isActive: false,\n      isPaused: true,\n      currentEventIndex: -1,\n      events: [],\n      processedEvents: {},\n    }));\n  }, [playbackInterval, setReplayState]);\n\n  /**\n   * 获取当前事件\n   */\n  const getCurrentEvent = useCallback(() => {\n    if (\n      !replayState.isActive ||\n      replayState.currentEventIndex < 0 ||\n      replayState.currentEventIndex >= replayState.events.length\n    ) {\n      return null;\n    }\n\n    return replayState.events[replayState.currentEventIndex];\n  }, [replayState.currentEventIndex, replayState.events, replayState.isActive]);\n\n  /**\n   * 获取当前位置百分比 (0-100)\n   */\n  const getCurrentPosition = useCallback(() => {\n    if (!replayState.isActive || replayState.events.length <= 1) {\n      return 0;\n    }\n\n    return (replayState.currentEventIndex / (replayState.events.length - 1)) * 100;\n  }, [replayState.currentEventIndex, replayState.events.length, replayState.isActive]);\n\n  /**\n   * 获取当前所有事件\n   */\n  const getCurrentEvents = useCallback(() => {\n    if (!replayState.isActive || replayState.currentEventIndex < 0) {\n      return [];\n    }\n\n    return replayState.events.slice(0, replayState.currentEventIndex + 1);\n  }, [replayState.currentEventIndex, replayState.events, replayState.isActive]);\n\n  // 组件卸载时清理定时器\n  useEffect(() => {\n    return () => {\n      if (playbackInterval) {\n        clearInterval(playbackInterval);\n      }\n    };\n  }, [playbackInterval]);\n\n  // 回放模式初始化时：如果索引为-1，需要手动触发第一步，否则会显示为空白\n  useEffect(() => {\n    if (\n      replayState.isActive &&\n      replayState.currentEventIndex === -1 &&\n      replayState.events.length > 0\n    ) {\n      // 如果启动回放后立即跳到第一个事件\n      processEventsUpToIndex(0);\n      setReplayState((prev) => ({\n        ...prev,\n        currentEventIndex: 0,\n      }));\n    }\n  }, [\n    replayState.isActive,\n    replayState.currentEventIndex,\n    replayState.events.length,\n    processEventsUpToIndex,\n    setReplayState,\n  ]);\n\n  /**\n   * 取消自动播放倒计时\n   */\n  const cancelAutoPlay = useCallback(() => {\n    setReplayState((prev) => ({\n      ...prev,\n      autoPlayCountdown: null,\n    }));\n  }, [setReplayState]);\n\n  // 添加对自动播放事件的监听\n  useEffect(() => {\n    const handleAutoStart = () => {\n      console.log('Auto-play event received, starting replay...');\n      startReplay();\n    };\n\n    // 添加事件监听器\n    window.addEventListener('replay-autostart', handleAutoStart);\n\n    // 清理函数\n    return () => {\n      window.removeEventListener('replay-autostart', handleAutoStart);\n    };\n  }, [startReplay]); // 依赖于startReplay函数\n\n  return {\n    // 状态\n    replayState,\n\n    // 操作方法\n    startReplay,\n    pauseReplay,\n    jumpToPosition,\n    jumpToResult,\n    setPlaybackSpeed,\n    exitReplay,\n    cancelAutoPlay,\n    resetReplay,\n\n    // 工具方法\n    getCurrentEvents,\n    getCurrentPosition,\n    getCurrentEvent,\n  };\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAGA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAEA;AAKA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA"}