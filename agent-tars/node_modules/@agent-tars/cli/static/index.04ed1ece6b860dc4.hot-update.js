"use strict";
self["webpackHotUpdate_agent_tars_web_ui"]("index", {
"./src/entry.css": (function (module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
// extracted by css-extract-rspack-plugin

    if(true) {
      (function() {
        var localsJsonString = undefined;
        // 1748915480317
        var cssReload = (__webpack_require__("../node_modules/.pnpm/@rspack+core@1.3.9_@swc+helpers@0.5.17/node_modules/@rspack/core/dist/cssExtractHmr.js")/* .cssReload */.cssReload)(module.id, {});
        // only invalidate when locals change
        if (
          module.hot.data &&
          module.hot.data.value &&
          module.hot.data.value !== localsJsonString
        ) {
          module.hot.invalidate();
        } else {
          module.hot.accept();
        }
        module.hot.dispose(function(data) {
          data.value = localsJsonString;
          cssReload();
        });
      })();
    }
  

}),
"./src/v2/hooks/useSession.ts": (function (module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  useSession: () => (useSession)
});
/* ESM import */var jotai__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("../node_modules/.pnpm/jotai@2.12.5_@types+react@18.3.23_react@18.3.1/node_modules/jotai/esm/react.mjs");
/* ESM import */var react_router_dom__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("../node_modules/.pnpm/react-router@7.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-router/dist/development/chunk-DQRVZFIR.mjs");
/* ESM import */var _state_atoms_session__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/v2/state/atoms/session.ts");
/* ESM import */var _state_atoms_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/v2/state/atoms/message.ts");
/* ESM import */var _state_atoms_tool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/v2/state/atoms/tool.ts");
/* ESM import */var _state_atoms_plan__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/v2/state/atoms/plan.ts");
/* ESM import */var _state_atoms_ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/v2/state/atoms/ui.ts");
/* ESM import */var _state_atoms_replay__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/v2/state/atoms/replay.ts");
/* ESM import */var _state_actions_sessionActions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/v2/state/actions/sessionActions.ts");
/* ESM import */var _state_actions_connectionActions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/v2/state/actions/connectionActions.ts");
/* ESM import */var _services_socketService__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/v2/services/socketService.ts");
/* ESM import */var react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* ESM import */var react__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_9__);
/* ESM import */var _context_ReplayModeContext__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./src/v2/context/ReplayModeContext.tsx");
/* ESM import */var _services_apiService__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./src/v2/services/apiService.ts");
/* provided dependency */ var $ReactRefreshRuntime$ = __webpack_require__("../node_modules/.pnpm/@rspack+plugin-react-refresh@1.0.3_react-refresh@0.16.0/node_modules/@rspack/plugin-react-refresh/client/reactRefresh.js");














/**
 * Hook for session management functionality
 *
 * Optimized to reduce unnecessary re-renders when switching sessions
 * and to prevent API calls when in replay mode
 */ function useSession() {
    // State
    const [sessions, setSessions] = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useAtom)(_state_atoms_session__WEBPACK_IMPORTED_MODULE_0__.sessionsAtom);
    const [activeSessionId, setActiveSessionId] = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useAtom)(_state_atoms_session__WEBPACK_IMPORTED_MODULE_0__.activeSessionIdAtom);
    const messages = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useAtomValue)(_state_atoms_message__WEBPACK_IMPORTED_MODULE_1__.messagesAtom);
    const groupedMessages = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useAtomValue)(_state_atoms_message__WEBPACK_IMPORTED_MODULE_1__.groupedMessagesAtom);
    const toolResults = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useAtomValue)(_state_atoms_tool__WEBPACK_IMPORTED_MODULE_2__.toolResultsAtom);
    const [isProcessing, setIsProcessing] = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useAtom)(_state_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.isProcessingAtom);
    const [activePanelContent, setActivePanelContent] = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useAtom)(_state_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.activePanelContentAtom);
    const [connectionStatus, setConnectionStatus] = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useAtom)(_state_atoms_ui__WEBPACK_IMPORTED_MODULE_4__.connectionStatusAtom);
    const [plans, setPlans] = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useAtom)(_state_atoms_plan__WEBPACK_IMPORTED_MODULE_3__.plansAtom);
    const setPlanUIState = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useSetAtom)(_state_atoms_plan__WEBPACK_IMPORTED_MODULE_3__.planUIStateAtom);
    const [replayState, setReplayState] = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useAtom)(_state_atoms_replay__WEBPACK_IMPORTED_MODULE_5__.replayStateAtom);
    // 替换写死的模型信息，改为状态管理
    const [modelInfo, setModelInfo] = (0,react__WEBPACK_IMPORTED_MODULE_9__.useState)({
        provider: '',
        model: ''
    });
    // Check if we're in replay mode using the context hook
    const isReplayMode = (0,_context_ReplayModeContext__WEBPACK_IMPORTED_MODULE_10__.useReplayMode)();
    // 获取回放模式下的模型信息
    const replayModelInfo = (0,_context_ReplayModeContext__WEBPACK_IMPORTED_MODULE_10__.useReplayMode)();
    // Actions
    const loadSessions = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useSetAtom)(_state_actions_sessionActions__WEBPACK_IMPORTED_MODULE_6__.loadSessionsAction);
    const createSession = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useSetAtom)(_state_actions_sessionActions__WEBPACK_IMPORTED_MODULE_6__.createSessionAction);
    const setActiveSession = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useSetAtom)(_state_actions_sessionActions__WEBPACK_IMPORTED_MODULE_6__.setActiveSessionAction);
    const updateSessionMetadata = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useSetAtom)(_state_actions_sessionActions__WEBPACK_IMPORTED_MODULE_6__.updateSessionAction);
    const deleteSession = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useSetAtom)(_state_actions_sessionActions__WEBPACK_IMPORTED_MODULE_6__.deleteSessionAction);
    const sendMessage = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useSetAtom)(_state_actions_sessionActions__WEBPACK_IMPORTED_MODULE_6__.sendMessageAction);
    const abortQuery = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useSetAtom)(_state_actions_sessionActions__WEBPACK_IMPORTED_MODULE_6__.abortQueryAction);
    const initConnectionMonitoring = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useSetAtom)(_state_actions_connectionActions__WEBPACK_IMPORTED_MODULE_7__.initConnectionMonitoringAction);
    const checkServerStatus = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useSetAtom)(_state_actions_connectionActions__WEBPACK_IMPORTED_MODULE_7__.checkConnectionStatusAction);
    const checkSessionStatus = (0,jotai__WEBPACK_IMPORTED_MODULE_12__.useSetAtom)(_state_actions_sessionActions__WEBPACK_IMPORTED_MODULE_6__.checkSessionStatusAction);
    // Get current location
    const location = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_13__.useLocation)();
    // 保留这个工具函数，但移除自动同步逻辑
    const getSessionIdFromUrl = (0,react__WEBPACK_IMPORTED_MODULE_9__.useCallback)(()=>{
        const pathParts = location.pathname.split('/').filter(Boolean);
        return pathParts.length > 0 ? pathParts[0] : null;
    }, [
        location
    ]);
    // Periodic status checking for active session - 在回放模式下不检查状态
    (0,react__WEBPACK_IMPORTED_MODULE_9__.useEffect)(()=>{
        if (!activeSessionId || !connectionStatus.connected || isReplayMode) return;
        // Initial status check when session becomes active
        checkSessionStatus(activeSessionId);
    }, [
        activeSessionId,
        connectionStatus.connected,
        checkSessionStatus,
        isReplayMode
    ]);
    // Enhanced socket handler for session status sync - 在回放模式下不更新状态
    const handleSessionStatusUpdate = (0,react__WEBPACK_IMPORTED_MODULE_9__.useCallback)((status)=>{
        if (status && typeof status.isProcessing === 'boolean' && !isReplayMode) {
            setIsProcessing(status.isProcessing);
        }
    }, [
        setIsProcessing,
        isReplayMode
    ]);
    // Set up socket event handlers when active session changes - 在回放模式下不设置socket事件处理
    (0,react__WEBPACK_IMPORTED_MODULE_9__.useEffect)(()=>{
        if (!activeSessionId || !_services_socketService__WEBPACK_IMPORTED_MODULE_8__.socketService.isConnected() || isReplayMode) return;
        // Join session and listen for status updates
        _services_socketService__WEBPACK_IMPORTED_MODULE_8__.socketService.joinSession(activeSessionId, ()=>{
        /* existing event handling */ }, handleSessionStatusUpdate);
        // Register global status handler
        _services_socketService__WEBPACK_IMPORTED_MODULE_8__.socketService.on('agent-status', handleSessionStatusUpdate);
        return ()=>{
            // Clean up handlers
            _services_socketService__WEBPACK_IMPORTED_MODULE_8__.socketService.off('agent-status', handleSessionStatusUpdate);
        };
    }, [
        activeSessionId,
        handleSessionStatusUpdate,
        isReplayMode
    ]);
    // Auto-show plan when it's first created - 在回放模式下不自动显示计划
    (0,react__WEBPACK_IMPORTED_MODULE_9__.useEffect)(()=>{
        var _plans_activeSessionId;
        if (activeSessionId && ((_plans_activeSessionId = plans[activeSessionId]) === null || _plans_activeSessionId === void 0 ? void 0 : _plans_activeSessionId.hasGeneratedPlan) && !isReplayMode) {
            const currentPlan = plans[activeSessionId];
            // If this is a newly generated plan, automatically show it
            if (currentPlan.steps.length > 0 && currentPlan.steps.every((step)=>!step.done)) {
                setPlanUIState((prev)=>({
                        ...prev,
                        isVisible: true
                    }));
            }
        }
    }, [
        activeSessionId,
        plans,
        setPlanUIState,
        isReplayMode
    ]);
    // 添加获取模型信息的效果
    (0,react__WEBPACK_IMPORTED_MODULE_9__.useEffect)(()=>{
        // 在回放模式或未连接时不获取模型信息
        if (isReplayMode || !connectionStatus.connected) return;
        const fetchModelInfo = async ()=>{
            try {
                const info = await _services_apiService__WEBPACK_IMPORTED_MODULE_11__.apiService.getModelInfo();
                setModelInfo(info);
            } catch (error) {
                console.error('Failed to fetch model info:', error);
            }
        };
        fetchModelInfo();
    }, [
        connectionStatus.connected,
        isReplayMode
    ]);
    // Memoize the session state object to avoid unnecessary re-renders
    const sessionState = (0,react__WEBPACK_IMPORTED_MODULE_9__.useMemo)(()=>({
            // State
            sessions,
            activeSessionId,
            messages,
            groupedMessages,
            toolResults,
            isProcessing,
            activePanelContent,
            connectionStatus,
            plans,
            replayState,
            modelInfo,
            // Session operations
            loadSessions,
            createSession,
            setActiveSession,
            updateSessionMetadata,
            deleteSession,
            // Message operations
            sendMessage,
            abortQuery,
            // UI operations
            setActivePanelContent,
            // Connection operations
            initConnectionMonitoring,
            checkServerStatus,
            // Status operations
            checkSessionStatus,
            getSessionIdFromUrl
        }), [
        sessions,
        activeSessionId,
        messages,
        groupedMessages,
        toolResults,
        isProcessing,
        activePanelContent,
        connectionStatus,
        plans,
        replayState,
        modelInfo,
        loadSessions,
        createSession,
        setActiveSession,
        updateSessionMetadata,
        deleteSession,
        sendMessage,
        abortQuery,
        setActivePanelContent,
        initConnectionMonitoring,
        checkServerStatus,
        checkSessionStatus,
        getSessionIdFromUrl
    ]);
    return sessionState;
}

function $RefreshSig$() {
  return $ReactRefreshRuntime$.createSignatureFunctionForTransform();
}
function $RefreshReg$(type, id) {
  $ReactRefreshRuntime$.register(type, module.id + "_" + id);
}
Promise.resolve().then(function() {
  $ReactRefreshRuntime$.refresh(module.id, module.hot);
});


}),

},function(__webpack_require__) {
// webpack/runtime/get_full_hash
(() => {
__webpack_require__.h = () => ("43dbbb18b8433791")
})();

}
);
//# sourceMappingURL=index.04ed1ece6b860dc4.hot-update.js.map