{"version":3,"file":"index.205117dcfdd1ca96.hot-update.js","sources":["/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/entry.css","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/common/state/actions/eventProcessor.ts","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/common/state/atoms/streamingToolCall.ts","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/standalone/chat/Message/components/ActionButton.tsx"],"sourcesContent":["// extracted by css-extract-rspack-plugin\nexport {};\n    if(module.hot) {\n      (function() {\n        var localsJsonString = undefined;\n        // 1751740633166\n        var cssReload = require(\"../../node_modules/.pnpm/@rspack+core@1.3.9_@swc+helpers@0.5.17/node_modules/@rspack/core/dist/cssExtractHmr.js\").cssReload(module.id, {});\n        // only invalidate when locals change\n        if (\n          module.hot.data &&\n          module.hot.data.value &&\n          module.hot.data.value !== localsJsonString\n        ) {\n          module.hot.invalidate();\n        } else {\n          module.hot.accept();\n        }\n        module.hot.dispose(function(data) {\n          data.value = localsJsonString;\n          cssReload();\n        });\n      })();\n    }\n  ","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { atom, Setter, Getter } from 'jotai';\nimport { v4 as uuidv4 } from 'uuid';\nimport { AgentEventStream, ToolResult, Message } from '@/common/types';\nimport { determineToolType } from '@/common/utils/formatters';\nimport { messagesAtom } from '../atoms/message';\nimport { toolResultsAtom, toolCallResultMap } from '../atoms/tool';\nimport { isProcessingAtom, activePanelContentAtom, modelInfoAtom } from '../atoms/ui';\nimport { plansAtom, PlanKeyframe } from '../atoms/plan';\nimport { replayStateAtom } from '../atoms/replay';\nimport { streamingToolCallsAtom } from '../atoms/streamingToolCall';\nimport { ChatCompletionContentPartImage } from '@multimodal/agent-interface';\nimport { jsonrepair } from 'json-repair';\n\n// 存储工具调用参数的映射表 (不是 Atom，是内部缓存)\nconst toolCallArgumentsMap = new Map<string, any>();\n\n/**\n * Process a single event and update the appropriate state atoms\n */\nexport const processEventAction = atom(\n  null,\n  (get, set, params: { sessionId: string; event: AgentEventStream.Event }) => {\n    const { sessionId, event } = params;\n    const replayState = get(replayStateAtom);\n    const isReplayMode = replayState.isActive;\n\n    switch (event.type) {\n      case 'user_message':\n        handleUserMessage(set, sessionId, event);\n        break;\n\n      case 'assistant_message':\n        handleAssistantMessage(get, set, sessionId, event);\n        break;\n\n      case 'assistant_streaming_message':\n        if (!isReplayMode) {\n          handleStreamingMessage(get, set, sessionId, event);\n        }\n        break;\n\n      case 'assistant_thinking_message':\n      case 'assistant_streaming_thinking_message':\n        handleThinkingMessage(get, set, sessionId, event);\n        break;\n\n      case 'tool_call':\n        handleToolCall(set, sessionId, event);\n        break;\n\n      case 'tool_result':\n        handleToolResult(set, sessionId, event);\n        break;\n\n      case 'system':\n        handleSystemMessage(set, sessionId, event);\n        break;\n\n      case 'environment_input':\n        handleEnvironmentInput(get, set, sessionId, event);\n        break;\n\n      case 'agent_run_start':\n        if (event.provider || event.model) {\n          set(modelInfoAtom, {\n            provider: event.provider || '',\n            model: event.model || '',\n          });\n        }\n        set(isProcessingAtom, true);\n        break;\n\n      case 'agent_run_end':\n        set(isProcessingAtom, false);\n        break;\n\n      case 'plan_start':\n        handlePlanStart(set, sessionId, event);\n        break;\n\n      case 'plan_update':\n        handlePlanUpdate(set, sessionId, event);\n        break;\n\n      case 'plan_finish':\n        handlePlanFinish(set, sessionId, event);\n        break;\n\n      case 'final_answer':\n        handleFinalAnswer(get, set, sessionId, event);\n        break;\n\n      case 'final_answer_streaming':\n        if (!isReplayMode) {\n          handleFinalAnswerStreaming(get, set, sessionId, event);\n        }\n        break;\n\n      case 'assistant_streaming_tool_call':\n        if (!isReplayMode) {\n          handleStreamingToolCall(get, set, sessionId, event);\n        }\n        break;\n    }\n  },\n);\n\nexport const updateProcessingStatusAction = atom(\n  null,\n  (get, set, status: { isProcessing: boolean; state?: string }) => {\n    // Update processing state\n    set(isProcessingAtom, !!status.isProcessing);\n  },\n);\n\n/**\n * Handle user message event\n */\nfunction handleUserMessage(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.UserMessageEvent,\n): void {\n  const userMessage: Message = {\n    id: event.id,\n    role: 'user',\n    content: event.content,\n    timestamp: event.timestamp,\n  };\n\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, userMessage],\n    };\n  });\n\n  // Check for images in user message and set active panel content if found\n  if (Array.isArray(event.content)) {\n    const images = event.content.filter((part) => part.type === 'image_url');\n    if (images.length > 0) {\n      set(activePanelContentAtom, {\n        type: 'image',\n        source: images[0].image_url.url,\n        title: 'User Upload',\n        timestamp: Date.now(),\n      });\n    }\n  }\n}\n\n/**\n * Handle assistant message event (complete message)\n */\nfunction handleAssistantMessage(\n  get: any,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.AssistantMessageEvent,\n): void {\n  // 获取消息ID\n  const messageId = event.messageId;\n\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n\n    // 检查是否已存在相同messageId的消息\n    if (messageId) {\n      const existingMessageIndex = sessionMessages.findIndex((msg) => msg.messageId === messageId);\n\n      // 如果找到了现有消息，更新它而不是添加新消息\n      if (existingMessageIndex !== -1) {\n        const updatedMessages = [...sessionMessages];\n        updatedMessages[existingMessageIndex] = {\n          ...updatedMessages[existingMessageIndex],\n          content: event.content,\n          timestamp: event.timestamp,\n          toolCalls: event.toolCalls,\n          finishReason: event.finishReason,\n          isStreaming: false,\n        };\n\n        return {\n          ...prev,\n          [sessionId]: updatedMessages,\n        };\n      }\n    }\n\n    // 没有找到现有消息，添加新消息\n    return {\n      ...prev,\n      [sessionId]: [\n        ...sessionMessages,\n        {\n          id: event.id,\n          role: 'assistant',\n          content: event.content,\n          timestamp: event.timestamp,\n          toolCalls: event.toolCalls,\n          finishReason: event.finishReason,\n          messageId: messageId,\n        },\n      ],\n    };\n  });\n\n  if (event.finishReason !== 'tool_calls') {\n    // 检查是否需要关联最近的环境输入\n    const currentMessages = get(messagesAtom)[sessionId] || [];\n\n    // 从后往前查找最近的环境输入\n    for (let i = currentMessages.length - 1; i >= 0; i--) {\n      const msg = currentMessages[i];\n      if (msg.role === 'environment' && Array.isArray(msg.content)) {\n        const imageContent = msg.content.find(\n          (item) => item.type === 'image_url' && item.image_url && item.image_url.url,\n        );\n\n        if (imageContent) {\n          set(activePanelContentAtom, {\n            type: 'image',\n            source: msg.content,\n            title: msg.description || 'Final Browser State',\n            timestamp: msg.timestamp,\n            environmentId: msg.id,\n          });\n          break;\n        }\n      }\n    }\n  }\n\n  set(isProcessingAtom, false);\n}\n\n/**\n * Handle streaming message event (incremental content)\n */\nfunction handleStreamingMessage(\n  get: any,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.AssistantStreamingMessageEvent,\n): void {\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    const messageIdToFind = event.messageId;\n    let existingMessageIndex = -1;\n\n    // 优先按messageId查找\n    if (messageIdToFind) {\n      existingMessageIndex = sessionMessages.findIndex((msg) => msg.messageId === messageIdToFind);\n    }\n    // 没有messageId或未找到，尝试查找标记为streaming的最后一条消息\n    else if (sessionMessages.length > 0) {\n      const lastMessageIndex = sessionMessages.length - 1;\n      const lastMessage = sessionMessages[lastMessageIndex];\n      if (lastMessage && lastMessage.isStreaming) {\n        existingMessageIndex = lastMessageIndex;\n      }\n    }\n\n    // 更新现有消息\n    if (existingMessageIndex !== -1) {\n      const existingMessage = sessionMessages[existingMessageIndex];\n      const updatedMessage = {\n        ...existingMessage,\n        content:\n          typeof existingMessage.content === 'string'\n            ? existingMessage.content + event.content\n            : event.content,\n        isStreaming: !event.isComplete,\n        toolCalls: event.toolCalls || existingMessage.toolCalls,\n      };\n\n      return {\n        ...prev,\n        [sessionId]: [\n          ...sessionMessages.slice(0, existingMessageIndex),\n          updatedMessage,\n          ...sessionMessages.slice(existingMessageIndex + 1),\n        ],\n      };\n    }\n\n    // 创建新消息\n    const newMessage: Message = {\n      id: event.id || uuidv4(),\n      role: 'assistant',\n      content: event.content,\n      timestamp: event.timestamp,\n      isStreaming: !event.isComplete,\n      toolCalls: event.toolCalls,\n      messageId: event.messageId,\n    };\n\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, newMessage],\n    };\n  });\n\n  if (event.isComplete) {\n    set(isProcessingAtom, false);\n  }\n}\n\n/**\n * Handle thinking message event\n */\nfunction handleThinkingMessage(\n  get: any,\n  set: Setter,\n  sessionId: string,\n  event:\n    | AgentEventStream.AssistantThinkingMessageEvent\n    | AgentEventStream.AssistantStreamingThinkingMessageEvent,\n): void {\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    const lastAssistantIndex = [...sessionMessages]\n      .reverse()\n      .findIndex((m) => m.role === 'assistant');\n\n    if (lastAssistantIndex !== -1) {\n      const actualIndex = sessionMessages.length - 1 - lastAssistantIndex;\n      const message = sessionMessages[actualIndex];\n\n      return {\n        ...prev,\n        [sessionId]: [\n          ...sessionMessages.slice(0, actualIndex),\n          { ...message, thinking: event.content },\n          ...sessionMessages.slice(actualIndex + 1),\n        ],\n      };\n    }\n\n    return prev;\n  });\n}\n\n/**\n * Handle tool call event - store arguments for later use\n */\nfunction handleToolCall(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.ToolCallEvent,\n): void {\n  // 保存工具调用的参数信息以便后续使用\n  if (event.toolCallId && event.arguments) {\n    toolCallArgumentsMap.set(event.toolCallId, event.arguments);\n  }\n}\n\nfunction handleToolResult(set: Setter, sessionId: string, event: AgentEventStream.ToolResultEvent) {\n  // 获取之前存储的参数信息\n  const args = toolCallArgumentsMap.get(event.toolCallId);\n\n  const result: ToolResult = {\n    id: uuidv4(),\n    toolCallId: event.toolCallId,\n    name: event.name,\n    content: event.content,\n    timestamp: event.timestamp,\n    error: event.error,\n    type: determineToolType(event.name, event.content),\n    arguments: args,\n    _extra: event._extra,\n  };\n\n  // 1. 先更新消息atom和工具结果 - 确保chat UI能立即响应\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n\n    // 找到对应的消息并添加toolResults\n    const messageIndex = [...sessionMessages]\n      .reverse()\n      .findIndex((m) => m.toolCalls?.some((tc) => tc.id === result.toolCallId));\n\n    if (messageIndex !== -1) {\n      const actualIndex = sessionMessages.length - 1 - messageIndex;\n      const message = sessionMessages[actualIndex];\n      const toolResults = message.toolResults || [];\n\n      const updatedMessage = {\n        ...message,\n        toolResults: [...toolResults, result],\n      };\n\n      return {\n        ...prev,\n        [sessionId]: [\n          ...sessionMessages.slice(0, actualIndex),\n          updatedMessage,\n          ...sessionMessages.slice(actualIndex + 1),\n        ],\n      };\n    }\n\n    return prev;\n  });\n\n  // 2. 同时更新工具结果atom\n  set(toolResultsAtom, (prev: Record<string, ToolResult[]>) => {\n    const sessionResults = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionResults, result],\n    };\n  });\n\n  // 3. 最后更新workspace面板内容 - 保持时序一致\n  if (result.type === 'browser_vision_control') {\n    set(activePanelContentAtom, (prev) => {\n      if (prev && prev.type === 'image' && prev.environmentId) {\n        // 在这里添加环境ID到已处理列表，避免重复渲染\n        const environmentId = prev.environmentId;\n\n        return {\n          ...prev,\n          type: 'browser_vision_control',\n          source: event.content,\n          title: prev.title,\n          timestamp: event.timestamp,\n          toolCallId: event.toolCallId,\n          error: event.error,\n          arguments: args,\n          originalContent: prev.source,\n\n          environmentId: environmentId,\n          processedEnvironmentIds: [environmentId], // 新增：记录已处理的环境ID\n        };\n      } else {\n        return {\n          type: result.type,\n          source: result.content,\n          title: result.name,\n          timestamp: result.timestamp,\n          toolCallId: result.toolCallId,\n          error: result.error,\n          arguments: args,\n        };\n      }\n    });\n  } else {\n    set(activePanelContentAtom, {\n      type: result.type,\n      source: result.content,\n      title: result.name,\n      timestamp: result.timestamp,\n      toolCallId: result.toolCallId,\n      error: result.error,\n      arguments: args,\n      _extra: result._extra,\n    });\n  }\n\n  // Store in the map for future reference\n  toolCallResultMap.set(result.toolCallId, result);\n}\n\n/**\n * Handle system message event\n */\nfunction handleSystemMessage(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.Event & { message: string; level?: string },\n): void {\n  const systemMessage: Message = {\n    id: uuidv4(),\n    role: 'system',\n    content: event.message,\n    timestamp: event.timestamp || Date.now(),\n  };\n\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, systemMessage],\n    };\n  });\n}\n\n/**\n * Handle environment input event\n * Adds it to messages but doesn't set it as active panel content\n */\nfunction handleEnvironmentInput(\n  get: Getter,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.EnvironmentInputEvent,\n): void {\n  const environmentMessage: Message = {\n    id: event.id,\n    role: 'environment',\n    content: event.content,\n    timestamp: event.timestamp,\n    description: event.description || 'Environment Input',\n  };\n\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, environmentMessage],\n    };\n  });\n  // 检查是否包含图片内容并直接设置为活动面板内容\n  if (Array.isArray(event.content)) {\n    const imageContent = event.content.find(\n      (item) => item.type === 'image_url' && item.image_url && item.image_url.url,\n    ) as ChatCompletionContentPartImage;\n\n    if (imageContent && imageContent.image_url) {\n      // 获取当前面板状态\n      const currentPanel = get(activePanelContentAtom);\n\n      // 只有当前面板是 browser_vision_control 类型时才更新\n      if (currentPanel && currentPanel.type === 'browser_vision_control') {\n        set(activePanelContentAtom, {\n          ...currentPanel,\n          type: 'browser_vision_control',\n          title: `${currentPanel.title} · Screenshot Update`,\n          timestamp: event.timestamp,\n          originalContent: event.content,\n          environmentId: event.id,\n        });\n      }\n      // 不是 browser_vision_control 类型时完全跳过 set 操作\n      // 这样避免了 Browser Screenshot 被重复渲染\n    }\n  }\n}\n\n/**\n * Handle plan start event\n */\nfunction handlePlanStart(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.PlanStartEvent,\n): void {\n  set(plansAtom, (prev: Record<string, any>) => ({\n    ...prev,\n    [sessionId]: {\n      steps: [],\n      isComplete: false,\n      summary: null,\n      hasGeneratedPlan: true,\n      keyframes: [], // Initialize empty keyframes array\n    },\n  }));\n}\n\n/**\n * Handle plan update event\n */\nfunction handlePlanUpdate(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.PlanUpdateEvent,\n): void {\n  console.log('Plan update event:', event);\n  set(plansAtom, (prev: Record<string, any>) => {\n    const currentPlan = prev[sessionId] || {\n      steps: [],\n      isComplete: false,\n      summary: null,\n      hasGeneratedPlan: true,\n      keyframes: [],\n    };\n\n    // Create a new keyframe for this update\n    const newKeyframe: PlanKeyframe = {\n      timestamp: event.timestamp || Date.now(),\n      steps: event.steps,\n      isComplete: false,\n      summary: null,\n    };\n\n    // Add the keyframe to the history\n    const keyframes = [...(currentPlan.keyframes || []), newKeyframe];\n\n    return {\n      ...prev,\n      [sessionId]: {\n        ...currentPlan,\n        steps: event.steps,\n        hasGeneratedPlan: true,\n        keyframes,\n      },\n    };\n  });\n}\n\n/**\n * Handle plan finish event\n */\nfunction handlePlanFinish(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.Event & { sessionId: string; summary: string },\n): void {\n  console.log('Plan finish event:', event);\n  set(plansAtom, (prev: Record<string, any>) => {\n    const currentPlan = prev[sessionId] || {\n      steps: [],\n      isComplete: false,\n      summary: null,\n      hasGeneratedPlan: true,\n      keyframes: [],\n    };\n\n    // Create a final keyframe for the completed plan\n    const finalKeyframe: PlanKeyframe = {\n      timestamp: event.timestamp || Date.now(),\n      steps: currentPlan.steps,\n      isComplete: true,\n      summary: event.summary,\n    };\n\n    // Add the final keyframe to the history\n    const keyframes = [...(currentPlan.keyframes || []), finalKeyframe];\n\n    return {\n      ...prev,\n      [sessionId]: {\n        ...currentPlan,\n        isComplete: true,\n        summary: event.summary,\n        keyframes,\n      },\n    };\n  });\n}\n\n/**\n * Handle final answer event (complete answer/report)\n */\nfunction handleFinalAnswer(\n  get: any,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.FinalAnswerEvent,\n): void {\n  const messageId = event.messageId || `final-answer-${uuidv4()}`;\n\n  // 始终将内容当作研究报告处理，移除JSON_DATA状态\n  // 设置活动面板内容为研究报告\n  set(activePanelContentAtom, {\n    type: 'research_report',\n    source: event.content,\n    title: event.title || 'Research Report',\n    timestamp: event.timestamp,\n    isDeepResearch: true,\n    messageId,\n  });\n\n  // 添加消息到聊天引用报告\n  const finalAnswerMessage: Message = {\n    id: event.id || uuidv4(),\n    role: 'final_answer',\n    content: event.content, // 存储完整内容以便后续访问\n    timestamp: event.timestamp,\n    messageId,\n    isDeepResearch: true,\n    title: event.title || 'Research Report',\n  };\n\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, finalAnswerMessage],\n    };\n  });\n\n  // 标记处理完成\n  set(isProcessingAtom, false);\n}\n\nfunction handleFinalAnswerStreaming(\n  get: any,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.Event & {\n    content: string;\n    isDeepResearch: boolean;\n    isComplete?: boolean;\n    messageId?: string;\n    title?: string;\n  },\n): void {\n  const messageId = event.messageId || `final-answer-${uuidv4()}`;\n\n  // 从当前消息列表中查找已有的相同 messageId 的消息\n  const messages = get(messagesAtom)[sessionId] || [];\n  const existingMessageIndex = messages.findIndex((msg) => msg.messageId === messageId);\n\n  // 当处理一系列流式事件时，将内容追加到现有消息，或创建新消息\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n\n    // 如果找到现有消息，则更新它\n    if (existingMessageIndex >= 0) {\n      const existingMessage = sessionMessages[existingMessageIndex];\n      const updatedMessage = {\n        ...existingMessage,\n        content:\n          typeof existingMessage.content === 'string'\n            ? existingMessage.content + event.content\n            : event.content,\n        isStreaming: !event.isComplete,\n        timestamp: event.timestamp,\n      };\n\n      return {\n        ...prev,\n        [sessionId]: [\n          ...sessionMessages.slice(0, existingMessageIndex),\n          updatedMessage,\n          ...sessionMessages.slice(existingMessageIndex + 1),\n        ],\n      };\n    }\n\n    // 否则创建新消息\n    const newMessage: Message = {\n      id: event.id || uuidv4(),\n      role: 'final_answer',\n      content: event.content,\n      timestamp: event.timestamp,\n      messageId,\n      isDeepResearch: true,\n      isStreaming: !event.isComplete,\n      title: event.title || 'Research Report',\n    };\n\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, newMessage],\n    };\n  });\n\n  // 更新活动面板内容 - 同步面板与消息状态\n  set(activePanelContentAtom, (prev: any) => {\n    // 如果是新流或不同的messageId，重新开始\n    if (!prev || prev.type !== 'research_report' || prev.messageId !== messageId) {\n      return {\n        role: 'assistant',\n        type: 'research_report',\n        source: event.content,\n        title: event.title || 'Research Report (Generating...)',\n        timestamp: event.timestamp,\n        isDeepResearch: true,\n        messageId,\n        isStreaming: !event.isComplete,\n      };\n    }\n\n    // 否则追加到现有内容\n    return {\n      ...prev,\n      source: prev.source + event.content,\n      isStreaming: !event.isComplete,\n      timestamp: event.timestamp,\n      title: event.title || prev.title,\n    };\n  });\n\n  // 如果这是第一个数据块，也添加一条消息到聊天\n  const prevActivePanelContent = get(activePanelContentAtom);\n  if (!prevActivePanelContent || prevActivePanelContent.messageId !== messageId) {\n    const initialMessage: Message = {\n      id: event.id || uuidv4(),\n      role: 'final_answer',\n      content: event.content, // 存储初始内容\n      timestamp: event.timestamp,\n      messageId,\n      isDeepResearch: true,\n      isStreaming: !event.isComplete,\n      title: event.title || 'Research Report',\n    };\n\n    set(messagesAtom, (prev: Record<string, Message[]>) => {\n      const sessionMessages = prev[sessionId] || [];\n      return {\n        ...prev,\n        [sessionId]: [...sessionMessages, initialMessage],\n      };\n    });\n  } else if (event.isComplete) {\n    // 当流式生成完成时，更新消息的完整内容\n    const fullContent = get(activePanelContentAtom).source;\n\n    set(messagesAtom, (prev: Record<string, Message[]>) => {\n      const sessionMessages = prev[sessionId] || [];\n      const messageIndex = sessionMessages.findIndex((msg) => msg.messageId === messageId);\n\n      if (messageIndex >= 0) {\n        const updatedMessages = [...sessionMessages];\n        updatedMessages[messageIndex] = {\n          ...updatedMessages[messageIndex],\n          content: fullContent,\n          isStreaming: false,\n          title: event.title || updatedMessages[messageIndex].title || 'Research Report',\n        };\n\n        return {\n          ...prev,\n          [sessionId]: updatedMessages,\n        };\n      }\n\n      return prev;\n    });\n  }\n\n  // 如果这是最后一个数据块，标记处理完成\n  if (event.isComplete) {\n    set(isProcessingAtom, false);\n  }\n}\n\n// Define the state for streaming tool calls\ntype StreamingToolCallState = {\n  toolCallId: string;\n  toolName: string;\n  accumulatedArguments: string;\n  messageId: string;\n  timestamp: number;\n};\n\n/**\n * Handle streaming tool call event - accumulate arguments and show early preview\n */\nfunction handleStreamingToolCall(\n  get: Getter,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.AssistantStreamingToolCallEvent,\n): void {\n  const streamingToolCalls = get(streamingToolCallsAtom);\n  const sessionToolCalls = streamingToolCalls[sessionId] || {};\n  \n  // Get or create streaming state for this tool call\n  let streamingState = sessionToolCalls[event.toolCallId];\n  \n  if (!streamingState) {\n    streamingState = {\n      toolCallId: event.toolCallId,\n      toolName: event.toolName,\n      accumulatedArguments: '',\n      messageId: event.messageId || '',\n      timestamp: event.timestamp,\n    };\n  }\n  \n  // Accumulate arguments\n  streamingState.accumulatedArguments += event.arguments;\n  streamingState.timestamp = event.timestamp;\n  \n  // Update streaming state\n  set(streamingToolCallsAtom, {\n    ...streamingToolCalls,\n    [sessionId]: {\n      ...sessionToolCalls,\n      [event.toolCallId]: streamingState,\n    },\n  });\n  \n  // Only show workspace preview for write_file tool calls\n  if (event.toolName === 'write_file' || event.toolName.includes('write')) {\n    handleWriteFileStreaming(get, set, sessionId, streamingState, event.isComplete);\n  }\n  \n  // Clean up completed streaming tool calls\n  if (event.isComplete) {\n    // Remove from streaming state after a delay to allow final processing\n    setTimeout(() => {\n      set(streamingToolCallsAtom, (prev) => {\n        const updated = { ...prev };\n        if (updated[sessionId]) {\n          const { [event.toolCallId]: removed, ...remaining } = updated[sessionId];\n          updated[sessionId] = remaining;\n        }\n        return updated;\n      });\n    }, 1000);\n  }\n}\n\n/**\n * Handle write_file streaming - show file content in workspace as it streams\n */\nfunction handleWriteFileStreaming(\n  get: Getter,\n  set: Setter,\n  sessionId: string,\n  streamingState: StreamingToolCallState,\n  isComplete: boolean,\n): void {\n  try {\n    // Try to parse accumulated arguments safely\n    let parsedArgs: any = {};\n    \n    if (streamingState.accumulatedArguments.trim()) {\n      try {\n        // First try regular JSON.parse\n        parsedArgs = JSON.parse(streamingState.accumulatedArguments);\n      } catch {\n        try {\n          // If that fails, use json-repair\n          const repairedJson = jsonrepair(streamingState.accumulatedArguments);\n          parsedArgs = JSON.parse(repairedJson);\n        } catch {\n          // If json-repair also fails, create a partial object\n          parsedArgs = extractPartialArgs(streamingState.accumulatedArguments);\n        }\n      }\n    }\n    \n    // Only show if we have meaningful content\n    if (parsedArgs.path || parsedArgs.content) {\n      const fileName = parsedArgs.path ? parsedArgs.path.split('/').pop() || 'file' : 'file';\n      const content = parsedArgs.content || '';\n      \n      set(activePanelContentAtom, {\n        type: 'file',\n        source: content,\n        title: isComplete ? `File: ${fileName}` : `Writing: ${fileName}...`,\n        timestamp: streamingState.timestamp,\n        toolCallId: streamingState.toolCallId,\n        arguments: {\n          path: parsedArgs.path,\n          content: content,\n        },\n        isStreaming: !isComplete,\n      });\n    }\n  } catch (error) {\n    console.warn('Failed to process streaming write_file:', error);\n  }\n}\n\n/**\n * Extract partial arguments from incomplete JSON string\n */\nfunction extractPartialArgs(jsonString: string): any {\n  const result: any = {};\n  \n  // Try to extract path from incomplete JSON\n  const pathMatch = jsonString.match(/\"path\"\\s*:\\s*\"([^\"]*)/);\n  if (pathMatch) {\n    result.path = pathMatch[1];\n  }\n  \n  // Try to extract content from incomplete JSON\n  const contentMatch = jsonString.match(/\"content\"\\s*:\\s*\"([^\"]*)/);\n  if (contentMatch) {\n    result.content = contentMatch[1];\n  }\n  \n  return result;\n}","import { atom } from 'jotai';\n\n/**\n * Interface for tracking streaming tool call state\n */\nexport interface StreamingToolCallState {\n  toolCallId: string;\n  toolName: string;\n  accumulatedArguments: string;\n  messageId: string;\n  timestamp: number;\n}\n\n/**\n * Atom for storing streaming tool calls by session\n * Key is the session ID, value is a map of toolCallId to streaming state\n */\nexport const streamingToolCallsAtom = atom<Record<string, Record<string, StreamingToolCallState>>>({});\n","import React from 'react';\nimport { motion } from 'framer-motion';\nimport { FiArrowRight } from 'react-icons/fi';\n\ninterface ActionButtonProps {\n  icon: React.ReactNode;\n  label: string;\n  onClick: () => void;\n  status?: 'default' | 'pending' | 'success' | 'error' | 'streaming';\n  statusIcon?: React.ReactNode;\n  description?: string;\n}\n\n/**\n * ActionButton - Generic action button component for tool calls and environment viewing\n * Now supports streaming status for real-time tool call feedback\n */\nexport const ActionButton: React.FC<ActionButtonProps> = ({\n  icon,\n  label,\n  onClick,\n  status = 'default',\n  statusIcon,\n  description,\n}) => {\n  // Helper function to get status color classes\n  const getStatusColorClasses = () => {\n    switch (status) {\n      case 'streaming':\n        return 'border-blue-200 dark:border-blue-600 bg-blue-50 dark:bg-blue-900/20 text-blue-700 dark:text-blue-300';\n      case 'pending':\n        return 'border-slate-200 dark:border-slate-600 bg-slate-50 dark:bg-slate-800/40 text-slate-700 dark:text-slate-300';\n      case 'success':\n        return 'border-slate-200 dark:border-slate-600 bg-[#f9fafb] dark:bg-slate-800/60 text-slate-800 dark:text-slate-200';\n      case 'error':\n        return 'border-red-200 dark:border-red-700 bg-red-50 dark:bg-red-900/20 text-red-700 dark:text-red-300';\n      default:\n        return 'border-slate-200 dark:border-slate-600 bg-[#f9fafb] dark:bg-slate-800/60 text-slate-800 dark:text-slate-200';\n    }\n  };\n\n  // Helper function to get hover effect classes\n  const getHoverColorClasses = () => {\n    switch (status) {\n      case 'streaming':\n        return 'hover:bg-blue-100 dark:hover:bg-blue-800/30 hover:border-blue-300 dark:hover:border-blue-500';\n      case 'pending':\n        return 'hover:bg-slate-100 dark:hover:bg-slate-700/50 hover:border-slate-300 dark:hover:border-slate-500';\n      case 'success':\n        return 'hover:bg-slate-50 dark:hover:bg-slate-700/60 hover:border-slate-300 dark:hover:border-slate-500';\n      case 'error':\n        return 'hover:bg-red-100 dark:hover:bg-red-800/30 hover:border-red-300 dark:hover:border-red-600';\n      default:\n        return 'hover:bg-slate-50 dark:hover:bg-slate-700/60 hover:border-slate-300 dark:hover:border-slate-500';\n    }\n  };\n\n  return (\n    <motion.button\n      onClick={onClick}\n      className={`flex items-center gap-2 px-3 py-1.5 text-xs font-medium rounded-xl hover:scale-[1.01] active:scale-[0.99] border text-left group w-full ${getStatusColorClasses()} ${getHoverColorClasses()}`}\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      transition={{ duration: 0.5 }}\n    >\n      {/* Icon container with enhanced visual styling */}\n      <div className=\"flex-shrink-0 w-5 h-5 flex items-center justify-center\">{icon}</div>\n\n      {/* Button text */}\n      <div className=\"truncate flex-1\">\n        <span className=\"font-medium\">{label}</span>\n        {description && (\n          <span className=\"font-[400] text-xs opacity-70 truncate ml-1\">{description}</span>\n        )}\n      </div>\n\n      {/* Status icon or arrow */}\n      <div className=\"flex items-center gap-1.5 flex-shrink-0\">\n        {statusIcon || (\n          <FiArrowRight\n            className=\"opacity-60 group-hover:opacity-100 group-hover:translate-x-0.5 transition-all duration-200 text-slate-500 dark:text-slate-400\"\n            size={16}\n          />\n        )}\n      </div>\n    </motion.button>\n  );\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACvBA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AAGA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAOA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AASA;AACA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;;;AAGA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAYA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAWA;;AAEA;AAOA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAQA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;AC58BA;AAaA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AAWA;;;AAGA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;;;;;;AAGA;AAAA;;AACA;AAAA;AAAA;;;;;;AACA;AACA;AAAA;;;;;;;;;;;;AAKA;AAAA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;AAMA;AAtEA"}