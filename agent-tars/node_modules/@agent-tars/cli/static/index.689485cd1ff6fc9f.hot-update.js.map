{"version":3,"file":"index.689485cd1ff6fc9f.hot-update.js","sources":["/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/entry.css","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/common/state/actions/eventProcessor.ts","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/common/state/atoms/tool.ts","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/standalone/chat/Message/components/ToolCalls.tsx","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/standalone/workspace/WorkspaceDetail.tsx","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/standalone/workspace/renderers/StreamingToolCallRenderer.tsx","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/standalone/workspace/renderers/ToolResultRenderer.tsx"],"sourcesContent":["// extracted by css-extract-rspack-plugin\nexport {};\n    if(module.hot) {\n      (function() {\n        var localsJsonString = undefined;\n        // 1751739067017\n        var cssReload = require(\"../../node_modules/.pnpm/@rspack+core@1.3.9_@swc+helpers@0.5.17/node_modules/@rspack/core/dist/cssExtractHmr.js\").cssReload(module.id, {});\n        // only invalidate when locals change\n        if (\n          module.hot.data &&\n          module.hot.data.value &&\n          module.hot.data.value !== localsJsonString\n        ) {\n          module.hot.invalidate();\n        } else {\n          module.hot.accept();\n        }\n        module.hot.dispose(function(data) {\n          data.value = localsJsonString;\n          cssReload();\n        });\n      })();\n    }\n  ","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { atom, Setter, Getter } from 'jotai';\nimport { v4 as uuidv4 } from 'uuid';\nimport { AgentEventStream, ToolResult, Message } from '@/common/types';\nimport { determineToolType } from '@/common/utils/formatters';\nimport { messagesAtom } from '../atoms/message';\nimport { toolResultsAtom, toolCallResultMap, streamingToolCallsAtom, StreamingToolCall } from '../atoms/tool';\nimport { isProcessingAtom, activePanelContentAtom, modelInfoAtom } from '../atoms/ui';\nimport { plansAtom, PlanKeyframe } from '../atoms/plan';\nimport { replayStateAtom } from '../atoms/replay';\nimport { ChatCompletionContentPartImage } from '@multimodal/agent-interface';\n\n// 存储工具调用参数的映射表 (不是 Atom，是内部缓存)\nconst toolCallArgumentsMap = new Map<string, any>();\n\n/**\n * Process a single event and update the appropriate state atoms\n */\nexport const processEventAction = atom(\n  null,\n  (get, set, params: { sessionId: string; event: AgentEventStream.Event }) => {\n    const { sessionId, event } = params;\n    const replayState = get(replayStateAtom);\n    const isReplayMode = replayState.isActive;\n\n    switch (event.type) {\n      case 'user_message':\n        handleUserMessage(set, sessionId, event);\n        break;\n\n      case 'assistant_message':\n        handleAssistantMessage(get, set, sessionId, event);\n        break;\n\n      case 'assistant_streaming_message':\n        if (!isReplayMode) {\n          handleStreamingMessage(get, set, sessionId, event);\n        }\n        break;\n\n      case 'assistant_thinking_message':\n      case 'assistant_streaming_thinking_message':\n        handleThinkingMessage(get, set, sessionId, event);\n        break;\n\n      case 'assistant_streaming_tool_call':\n        if (!isReplayMode) {\n          handleStreamingToolCall(get, set, sessionId, event);\n        }\n        break;\n\n      case 'tool_call':\n        handleToolCall(set, sessionId, event);\n        break;\n\n      case 'tool_result':\n        handleToolResult(get, set, sessionId, event);\n        break;\n\n      case 'system':\n        handleSystemMessage(set, sessionId, event);\n        break;\n\n      case 'environment_input':\n        handleEnvironmentInput(get, set, sessionId, event);\n        break;\n\n      case 'agent_run_start':\n        if (event.provider || event.model) {\n          set(modelInfoAtom, {\n            provider: event.provider || '',\n            model: event.model || '',\n          });\n        }\n        set(isProcessingAtom, true);\n        break;\n\n      case 'agent_run_end':\n        set(isProcessingAtom, false);\n        break;\n\n      case 'plan_start':\n        handlePlanStart(set, sessionId, event);\n        break;\n\n      case 'plan_update':\n        handlePlanUpdate(set, sessionId, event);\n        break;\n\n      case 'plan_finish':\n        handlePlanFinish(set, sessionId, event);\n        break;\n\n      case 'final_answer':\n        handleFinalAnswer(get, set, sessionId, event);\n        break;\n\n      case 'final_answer_streaming':\n        if (!isReplayMode) {\n          handleFinalAnswerStreaming(get, set, sessionId, event);\n        }\n        break;\n    }\n  },\n);\n\n/**\n * Handle user message event\n */\nfunction handleUserMessage(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.UserMessageEvent,\n): void {\n  const userMessage: Message = {\n    id: event.id,\n    role: 'user',\n    content: event.content,\n    timestamp: event.timestamp,\n  };\n\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, userMessage],\n    };\n  });\n\n  // Check for images in user message and set active panel content if found\n  if (Array.isArray(event.content)) {\n    const images = event.content.filter((part) => part.type === 'image_url');\n    if (images.length > 0) {\n      set(activePanelContentAtom, {\n        type: 'image',\n        source: images[0].image_url.url,\n        title: 'User Upload',\n        timestamp: Date.now(),\n      });\n    }\n  }\n}\n\n/**\n * Handle assistant message event (complete message)\n */\nfunction handleAssistantMessage(\n  get: any,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.AssistantMessageEvent,\n): void {\n  // 获取消息ID\n  const messageId = event.messageId;\n\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n\n    // 检查是否已存在相同messageId的消息\n    if (messageId) {\n      const existingMessageIndex = sessionMessages.findIndex((msg) => msg.messageId === messageId);\n\n      // 如果找到了现有消息，更新它而不是添加新消息\n      if (existingMessageIndex !== -1) {\n        const updatedMessages = [...sessionMessages];\n        updatedMessages[existingMessageIndex] = {\n          ...updatedMessages[existingMessageIndex],\n          content: event.content,\n          timestamp: event.timestamp,\n          toolCalls: event.toolCalls,\n          finishReason: event.finishReason,\n          isStreaming: false,\n        };\n\n        return {\n          ...prev,\n          [sessionId]: updatedMessages,\n        };\n      }\n    }\n\n    // 没有找到现有消息，添加新消息\n    return {\n      ...prev,\n      [sessionId]: [\n        ...sessionMessages,\n        {\n          id: event.id,\n          role: 'assistant',\n          content: event.content,\n          timestamp: event.timestamp,\n          toolCalls: event.toolCalls,\n          finishReason: event.finishReason,\n          messageId: messageId,\n        },\n      ],\n    };\n  });\n\n  if (event.finishReason !== 'tool_calls') {\n    // 检查是否需要关联最近的环境输入\n    const currentMessages = get(messagesAtom)[sessionId] || [];\n\n    // 从后往前查找最近的环境输入\n    for (let i = currentMessages.length - 1; i >= 0; i--) {\n      const msg = currentMessages[i];\n      if (msg.role === 'environment' && Array.isArray(msg.content)) {\n        const imageContent = msg.content.find(\n          (item) => item.type === 'image_url' && item.image_url && item.image_url.url,\n        );\n\n        if (imageContent) {\n          set(activePanelContentAtom, {\n            type: 'image',\n            source: msg.content,\n            title: msg.description || 'Final Browser State',\n            timestamp: msg.timestamp,\n            environmentId: msg.id,\n          });\n          break;\n        }\n      }\n    }\n  }\n\n  set(isProcessingAtom, false);\n}\n\n/**\n * Handle streaming message event (incremental content)\n */\nfunction handleStreamingMessage(\n  get: any,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.AssistantStreamingMessageEvent,\n): void {\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    const messageIdToFind = event.messageId;\n    let existingMessageIndex = -1;\n\n    // 优先按messageId查找\n    if (messageIdToFind) {\n      existingMessageIndex = sessionMessages.findIndex((msg) => msg.messageId === messageIdToFind);\n    }\n    // 没有messageId或未找到，尝试查找标记为streaming的最后一条消息\n    else if (sessionMessages.length > 0) {\n      const lastMessageIndex = sessionMessages.length - 1;\n      const lastMessage = sessionMessages[lastMessageIndex];\n      if (lastMessage && lastMessage.isStreaming) {\n        existingMessageIndex = lastMessageIndex;\n      }\n    }\n\n    // 更新现有消息\n    if (existingMessageIndex !== -1) {\n      const existingMessage = sessionMessages[existingMessageIndex];\n      const updatedMessage = {\n        ...existingMessage,\n        content:\n          typeof existingMessage.content === 'string'\n            ? existingMessage.content + event.content\n            : event.content,\n        isStreaming: !event.isComplete,\n        toolCalls: event.toolCalls || existingMessage.toolCalls,\n      };\n\n      return {\n        ...prev,\n        [sessionId]: [\n          ...sessionMessages.slice(0, existingMessageIndex),\n          updatedMessage,\n          ...sessionMessages.slice(existingMessageIndex + 1),\n        ],\n      };\n    }\n\n    // 创建新消息\n    const newMessage: Message = {\n      id: event.id || uuidv4(),\n      role: 'assistant',\n      content: event.content,\n      timestamp: event.timestamp,\n      isStreaming: !event.isComplete,\n      toolCalls: event.toolCalls,\n      messageId: event.messageId,\n    };\n\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, newMessage],\n    };\n  });\n\n  if (event.isComplete) {\n    set(isProcessingAtom, false);\n  }\n}\n\n/**\n * Handle thinking message event\n */\nfunction handleThinkingMessage(\n  get: any,\n  set: Setter,\n  sessionId: string,\n  event:\n    | AgentEventStream.AssistantThinkingMessageEvent\n    | AgentEventStream.AssistantStreamingThinkingMessageEvent,\n): void {\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    const lastAssistantIndex = [...sessionMessages]\n      .reverse()\n      .findIndex((m) => m.role === 'assistant');\n\n    if (lastAssistantIndex !== -1) {\n      const actualIndex = sessionMessages.length - 1 - lastAssistantIndex;\n      const message = sessionMessages[actualIndex];\n\n      return {\n        ...prev,\n        [sessionId]: [\n          ...sessionMessages.slice(0, actualIndex),\n          { ...message, thinking: event.content },\n          ...sessionMessages.slice(actualIndex + 1),\n        ],\n      };\n    }\n\n    return prev;\n  });\n}\n\n/**\n * Handle tool call event - store arguments for later use\n */\nfunction handleToolCall(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.ToolCallEvent,\n): void {\n  // 保存工具调用的参数信息以便后续使用\n  if (event.toolCallId && event.arguments) {\n    toolCallArgumentsMap.set(event.toolCallId, event.arguments);\n  }\n}\n\nfunction handleToolResult(set: Setter, sessionId: string, event: AgentEventStream.ToolResultEvent) {\n  // Clear any streaming state for this tool call\n  set(streamingToolCallsAtom, (prev) => {\n    const sessionCalls = prev[sessionId];\n    if (sessionCalls && sessionCalls[event.toolCallId]) {\n      const updatedSessionCalls = { ...sessionCalls };\n      delete updatedSessionCalls[event.toolCallId];\n      \n      return {\n        ...prev,\n        [sessionId]: updatedSessionCalls,\n      };\n    }\n    return prev;\n  });\n\n  // 获取之前存储的参数信息\n  const args = toolCallArgumentsMap.get(event.toolCallId);\n\n  const result: ToolResult = {\n    id: uuidv4(),\n    toolCallId: event.toolCallId,\n    name: event.name,\n    content: event.content,\n    timestamp: event.timestamp,\n    error: event.error,\n    type: determineToolType(event.name, event.content),\n    arguments: args,\n    _extra: event._extra,\n  };\n\n  // 1. 先更新消息atom和工具结果 - 确保chat UI能立即响应\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n\n    // 找到对应的消息并添加toolResults\n    const messageIndex = [...sessionMessages]\n      .reverse()\n      .findIndex((m) => m.toolCalls?.some((tc) => tc.id === result.toolCallId));\n\n    if (messageIndex !== -1) {\n      const actualIndex = sessionMessages.length - 1 - messageIndex;\n      const message = sessionMessages[actualIndex];\n      const toolResults = message.toolResults || [];\n\n      const updatedMessage = {\n        ...message,\n        toolResults: [...toolResults, result],\n      };\n\n      return {\n        ...prev,\n        [sessionId]: [\n          ...sessionMessages.slice(0, actualIndex),\n          updatedMessage,\n          ...sessionMessages.slice(actualIndex + 1),\n        ],\n      };\n    }\n\n    return prev;\n  });\n\n  // 2. 同时更新工具结果atom\n  set(toolResultsAtom, (prev: Record<string, ToolResult[]>) => {\n    const sessionResults = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionResults, result],\n    };\n  });\n\n  // 3. 最后更新workspace面板内容 - 保持时序一致\n  if (result.type === 'browser_vision_control') {\n    set(activePanelContentAtom, (prev) => {\n      if (prev && prev.type === 'image' && prev.environmentId) {\n        // 在这里添加环境ID到已处理列表，避免重复渲染\n        const environmentId = prev.environmentId;\n\n        return {\n          ...prev,\n          type: 'browser_vision_control',\n          source: event.content,\n          title: prev.title,\n          timestamp: event.timestamp,\n          toolCallId: event.toolCallId,\n          error: event.error,\n          arguments: args,\n          originalContent: prev.source,\n\n          environmentId: environmentId,\n          processedEnvironmentIds: [environmentId], // 新增：记录已处理的环境ID\n        };\n      } else {\n        return {\n          type: result.type,\n          source: result.content,\n          title: result.name,\n          timestamp: result.timestamp,\n          toolCallId: result.toolCallId,\n          error: result.error,\n          arguments: args,\n        };\n      }\n    });\n  } else {\n    set(activePanelContentAtom, {\n      type: result.type,\n      source: result.content,\n      title: result.name,\n      timestamp: result.timestamp,\n      toolCallId: result.toolCallId,\n      error: result.error,\n      arguments: args,\n      _extra: result._extra,\n    });\n  }\n\n  // Store in the map for future reference\n  toolCallResultMap.set(result.toolCallId, result);\n}\n\n/**\n * Handle system message event\n */\nfunction handleSystemMessage(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.Event & { message: string; level?: string },\n): void {\n  const systemMessage: Message = {\n    id: uuidv4(),\n    role: 'system',\n    content: event.message,\n    timestamp: event.timestamp || Date.now(),\n  };\n\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, systemMessage],\n    };\n  });\n}\n\n/**\n * Handle environment input event\n * Adds it to messages but doesn't set it as active panel content\n */\nfunction handleEnvironmentInput(\n  get: Getter,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.EnvironmentInputEvent,\n): void {\n  const environmentMessage: Message = {\n    id: event.id,\n    role: 'environment',\n    content: event.content,\n    timestamp: event.timestamp,\n    description: event.description || 'Environment Input',\n  };\n\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, environmentMessage],\n    };\n  });\n  // 检查是否包含图片内容并直接设置为活动面板内容\n  if (Array.isArray(event.content)) {\n    const imageContent = event.content.find(\n      (item) => item.type === 'image_url' && item.image_url && item.image_url.url,\n    ) as ChatCompletionContentPartImage;\n\n    if (imageContent && imageContent.image_url) {\n      // 获取当前面板状态\n      const currentPanel = get(activePanelContentAtom);\n\n      // 只有当前面板是 browser_vision_control 类型时才更新\n      if (currentPanel && currentPanel.type === 'browser_vision_control') {\n        set(activePanelContentAtom, {\n          ...currentPanel,\n          type: 'browser_vision_control',\n          title: `${currentPanel.title} · Screenshot Update`,\n          timestamp: event.timestamp,\n          originalContent: event.content,\n          environmentId: event.id,\n        });\n      }\n      // 不是 browser_vision_control 类型时完全跳过 set 操作\n      // 这样避免了 Browser Screenshot 被重复渲染\n    }\n  }\n}\n\n/**\n * Handle plan start event\n */\nfunction handlePlanStart(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.PlanStartEvent,\n): void {\n  set(plansAtom, (prev: Record<string, any>) => ({\n    ...prev,\n    [sessionId]: {\n      steps: [],\n      isComplete: false,\n      summary: null,\n      hasGeneratedPlan: true,\n      keyframes: [], // Initialize empty keyframes array\n    },\n  }));\n}\n\n/**\n * Handle plan update event\n */\nfunction handlePlanUpdate(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.PlanUpdateEvent,\n): void {\n  console.log('Plan update event:', event);\n  set(plansAtom, (prev: Record<string, any>) => {\n    const currentPlan = prev[sessionId] || {\n      steps: [],\n      isComplete: false,\n      summary: null,\n      hasGeneratedPlan: true,\n      keyframes: [],\n    };\n\n    // Create a new keyframe for this update\n    const newKeyframe: PlanKeyframe = {\n      timestamp: event.timestamp || Date.now(),\n      steps: event.steps,\n      isComplete: false,\n      summary: null,\n    };\n\n    // Add the keyframe to the history\n    const keyframes = [...(currentPlan.keyframes || []), newKeyframe];\n\n    return {\n      ...prev,\n      [sessionId]: {\n        ...currentPlan,\n        steps: event.steps,\n        hasGeneratedPlan: true,\n        keyframes,\n      },\n    };\n  });\n}\n\n/**\n * Handle plan finish event\n */\nfunction handlePlanFinish(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.Event & { sessionId: string; summary: string },\n): void {\n  console.log('Plan finish event:', event);\n  set(plansAtom, (prev: Record<string, any>) => {\n    const currentPlan = prev[sessionId] || {\n      steps: [],\n      isComplete: false,\n      summary: null,\n      hasGeneratedPlan: true,\n      keyframes: [],\n    };\n\n    // Create a final keyframe for the completed plan\n    const finalKeyframe: PlanKeyframe = {\n      timestamp: event.timestamp || Date.now(),\n      steps: currentPlan.steps,\n      isComplete: true,\n      summary: event.summary,\n    };\n\n    // Add the final keyframe to the history\n    const keyframes = [...(currentPlan.keyframes || []), finalKeyframe];\n\n    return {\n      ...prev,\n      [sessionId]: {\n        ...currentPlan,\n        isComplete: true,\n        summary: event.summary,\n        keyframes,\n      },\n    };\n  });\n}\n\n/**\n * Handle final answer event (complete answer/report)\n */\nfunction handleFinalAnswer(\n  get: any,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.FinalAnswerEvent,\n): void {\n  const messageId = event.messageId || `final-answer-${uuidv4()}`;\n\n  // 始终将内容当作研究报告处理，移除JSON_DATA状态\n  // 设置活动面板内容为研究报告\n  set(activePanelContentAtom, {\n    type: 'research_report',\n    source: event.content,\n    title: event.title || 'Research Report',\n    timestamp: event.timestamp,\n    isDeepResearch: true,\n    messageId,\n  });\n\n  // 添加消息到聊天引用报告\n  const finalAnswerMessage: Message = {\n    id: event.id || uuidv4(),\n    role: 'final_answer',\n    content: event.content, // 存储完整内容以便后续访问\n    timestamp: event.timestamp,\n    messageId,\n    isDeepResearch: true,\n    title: event.title || 'Research Report',\n  };\n\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, finalAnswerMessage],\n    };\n  });\n\n  // 标记处理完成\n  set(isProcessingAtom, false);\n}\n\nfunction handleFinalAnswerStreaming(\n  get: any,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.Event & {\n    content: string;\n    isDeepResearch: boolean;\n    isComplete?: boolean;\n    messageId?: string;\n    title?: string;\n  },\n): void {\n  const messageId = event.messageId || `final-answer-${uuidv4()}`;\n\n  // 从当前消息列表中查找已有的相同 messageId 的消息\n  const messages = get(messagesAtom)[sessionId] || [];\n  const existingMessageIndex = messages.findIndex((msg) => msg.messageId === messageId);\n\n  // 当处理一系列流式事件时，将内容追加到现有消息，或创建新消息\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n\n    // 如果找到现有消息，则更新它\n    if (existingMessageIndex >= 0) {\n      const existingMessage = sessionMessages[existingMessageIndex];\n      const updatedMessage = {\n        ...existingMessage,\n        content:\n          typeof existingMessage.content === 'string'\n            ? existingMessage.content + event.content\n            : event.content,\n        isStreaming: !event.isComplete,\n        timestamp: event.timestamp,\n      };\n\n      return {\n        ...prev,\n        [sessionId]: [\n          ...sessionMessages.slice(0, existingMessageIndex),\n          updatedMessage,\n          ...sessionMessages.slice(existingMessageIndex + 1),\n        ],\n      };\n    }\n\n    // 否则创建新消息\n    const newMessage: Message = {\n      id: event.id || uuidv4(),\n      role: 'final_answer',\n      content: event.content,\n      timestamp: event.timestamp,\n      messageId,\n      isDeepResearch: true,\n      isStreaming: !event.isComplete,\n      title: event.title || 'Research Report',\n    };\n\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, newMessage],\n    };\n  });\n\n  // 更新活动面板内容 - 同步面板与消息状态\n  set(activePanelContentAtom, (prev: any) => {\n    // 如果是新流或不同的messageId，重新开始\n    if (!prev || prev.type !== 'research_report' || prev.messageId !== messageId) {\n      return {\n        role: 'assistant',\n        type: 'research_report',\n        source: event.content,\n        title: event.title || 'Research Report (Generating...)',\n        timestamp: event.timestamp,\n        isDeepResearch: true,\n        messageId,\n        isStreaming: !event.isComplete,\n      };\n    }\n\n    // 否则追加到现有内容\n    return {\n      ...prev,\n      source: prev.source + event.content,\n      isStreaming: !event.isComplete,\n      timestamp: event.timestamp,\n      title: event.title || prev.title,\n    };\n  });\n\n  // 如果这是第一个数据块，也添加一条消息到聊天\n  const prevActivePanelContent = get(activePanelContentAtom);\n  if (!prevActivePanelContent || prevActivePanelContent.messageId !== messageId) {\n    const initialMessage: Message = {\n      id: event.id || uuidv4(),\n      role: 'final_answer',\n      content: event.content, // 存储初始内容\n      timestamp: event.timestamp,\n      messageId,\n      isDeepResearch: true,\n      isStreaming: !event.isComplete,\n      title: event.title || 'Research Report',\n    };\n\n    set(messagesAtom, (prev: Record<string, Message[]>) => {\n      const sessionMessages = prev[sessionId] || [];\n      return {\n        ...prev,\n        [sessionId]: [...sessionMessages, initialMessage],\n      };\n    });\n  } else if (event.isComplete) {\n    // 当流式生成完成时，更新消息的完整内容\n    const fullContent = get(activePanelContentAtom).source;\n\n    set(messagesAtom, (prev: Record<string, Message[]>) => {\n      const sessionMessages = prev[sessionId] || [];\n      const messageIndex = sessionMessages.findIndex((msg) => msg.messageId === messageId);\n\n      if (messageIndex >= 0) {\n        const updatedMessages = [...sessionMessages];\n        updatedMessages[messageIndex] = {\n          ...updatedMessages[messageIndex],\n          content: fullContent,\n          isStreaming: false,\n          title: event.title || updatedMessages[messageIndex].title || 'Research Report',\n        };\n\n        return {\n          ...prev,\n          [sessionId]: updatedMessages,\n        };\n      }\n\n      return prev;\n    });\n  }\n\n  // 如果这是最后一个数据块，标记处理完成\n  if (event.isComplete) {\n    set(isProcessingAtom, false);\n  }\n}\n\n// Handle streaming tool call event - tracks tool calls as they're being constructed\nfunction handleStreamingToolCall(\n  get: Getter,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.AssistantStreamingToolCallEvent,\n): void {\n  const currentStreamingCalls = get(streamingToolCallsAtom);\n  const sessionStreamingCalls = currentStreamingCalls[sessionId] || {};\n\n  const existingCall = sessionStreamingCalls[event.toolCallId];\n  const now = Date.now();\n\n  // Create or update the streaming tool call\n  const streamingCall: StreamingToolCall = {\n    toolCallId: event.toolCallId,\n    toolName: event.toolName,\n    messageId: event.messageId || '',\n    accumulatedArguments: existingCall \n      ? existingCall.accumulatedArguments + event.arguments \n      : event.arguments,\n    isComplete: event.isComplete,\n    startTimestamp: existingCall ? existingCall.startTimestamp : now,\n    lastUpdateTimestamp: now,\n  };\n\n  // Update the streaming tool calls state\n  set(streamingToolCallsAtom, (prev) => ({\n    ...prev,\n    [sessionId]: {\n      ...prev[sessionId],\n      [event.toolCallId]: streamingCall,\n    },\n  }));\n\n  // If this is the first chunk and we have a tool name, show it in the workspace\n  if (!existingCall && event.toolName && event.toolName.trim()) {\n    // Determine if this tool call should be shown in workspace immediately\n    const shouldShowInWorkspace = shouldShowStreamingToolCall(event.toolName);\n    \n    if (shouldShowInWorkspace) {\n      set(activePanelContentAtom, {\n        type: 'streaming_tool_call',\n        source: streamingCall,\n        title: `${event.toolName} (in progress...)`,\n        timestamp: now,\n        toolCallId: event.toolCallId,\n      });\n    }\n  }\n\n  // If the tool call is complete, clean up the streaming state\n  if (event.isComplete) {\n    set(streamingToolCallsAtom, (prev) => {\n      const updatedSessionCalls = { ...prev[sessionId] };\n      delete updatedSessionCalls[event.toolCallId];\n      \n      return {\n        ...prev,\n        [sessionId]: updatedSessionCalls,\n      };\n    });\n  }\n}\n\n// Determine if a streaming tool call should be shown in workspace immediately\nfunction shouldShowStreamingToolCall(toolName: string): boolean {\n  // Show streaming for tools that typically have large outputs or take time\n  const streamingToolNames = [\n    'write_file',\n    'edit_file',\n    'run_command',\n    'browser_get_markdown',\n    'web_search',\n    'read_file',\n    'list_directory',\n    'directory_tree',\n  ];\n  \n  return streamingToolNames.includes(toolName);\n}\n\n/**\n * Update processing status\n */\nexport const updateProcessingStatusAction = atom(\n  null,\n  (get, set, status: { isProcessing: boolean; state?: string }) => {\n    // Update processing state\n    set(isProcessingAtom, !!status.isProcessing);\n  },\n);","import { atom } from 'jotai';\nimport { ToolResult } from '@/common/types';\n\n/**\n * Interface for tracking streaming tool calls in progress\n */\nexport interface StreamingToolCall {\n  toolCallId: string;\n  toolName: string;\n  messageId: string;\n  accumulatedArguments: string;\n  isComplete: boolean;\n  startTimestamp: number;\n  lastUpdateTimestamp: number;\n}\n\n/**\n * Atom for storing tool results for each session\n * Key is the session ID, value is an array of tool results for that session\n */\nexport const toolResultsAtom = atom<Record<string, ToolResult[]>>({});\n\n/**\n * Atom for tracking streaming tool calls in progress\n * Key is the session ID, value is a map of toolCallId to StreamingToolCall\n */\nexport const streamingToolCallsAtom = atom<Record<string, Record<string, StreamingToolCall>>>({});\n\n/**\n * Map to track tool calls to their results (not an atom, just a cache)\n */\nexport const toolCallResultMap = new Map<string, ToolResult>();\n","import React from 'react';\nimport { FiLoader, FiCheck, FiX, FiClock, FiAlertCircle } from 'react-icons/fi';\nimport { motion } from 'framer-motion';\nimport { ActionButton } from './ActionButton';\nimport { useAtomValue } from 'jotai';\nimport { streamingToolCallsAtom } from '@/common/state/atoms/tool';\nimport { useSession } from '@/common/hooks/useSession';\n\ninterface ToolCallsProps {\n  toolCalls: any[];\n  onToolCallClick: (toolCall: any) => void;\n  getToolIcon: (name: string) => React.ReactNode;\n  isIntermediate?: boolean;\n  toolResults?: any[]; // Add toolResults to check completion status\n}\n\n/**\n * Component for displaying tool calls with enhanced icons and loading states\n *\n * Design principles:\n * - Distinct visual identity for different tool types\n * - Shows loading state for pending tool calls\n * - Displays success/error status with appropriate icons\n * - Provides clear visual feedback with enhanced tool-specific colors\n * - Supports streaming tool call state display\n */\nexport const ToolCalls: React.FC<ToolCallsProps> = ({\n  toolCalls,\n  onToolCallClick,\n  getToolIcon,\n  isIntermediate = false,\n  toolResults = [],\n}) => {\n  const { activeSessionId } = useSession();\n  const streamingToolCalls = useAtomValue(streamingToolCallsAtom);\n  const sessionStreamingCalls = activeSessionId ? streamingToolCalls[activeSessionId] || {} : {};\n\n  // Helper function to get tool call status\n  const getToolCallStatus = (toolCall: any) => {\n    // Check if this tool call is currently streaming\n    if (sessionStreamingCalls[toolCall.id]) {\n      return 'streaming';\n    }\n\n    const result = toolResults.find((result) => result.toolCallId === toolCall.id);\n\n    if (!result) {\n      return 'pending'; // No result yet, tool is still running\n    }\n\n    if (result.error) {\n      return 'error'; // Tool execution failed\n    }\n\n    return 'success'; // Tool completed successfully\n  };\n\n  // Helper function to get status icon with enhanced visual styling\n  const getStatusIcon = (status: string, toolName: string) => {\n    switch (status) {\n      case 'streaming':\n        return (\n          <div className=\"flex items-center\">\n            <motion.div\n              animate={{ scale: [1, 1.2, 1] }}\n              transition={{ duration: 1, repeat: Infinity }}\n              className=\"w-2 h-2 rounded-full bg-blue-500 dark:bg-blue-400 mr-2\"\n            />\n            <span className=\"text-xs text-blue-600 dark:text-blue-400\">streaming</span>\n          </div>\n        );\n      case 'pending':\n        return (\n          <motion.div\n            animate={{ rotate: 360 }}\n            transition={{ duration: 1, repeat: Infinity, ease: 'linear' }}\n          >\n            <FiLoader size={16} className=\"text-slate-500 dark:text-slate-400\" />\n          </motion.div>\n        );\n      case 'success':\n        return <FiCheck size={16} className=\"text-green-600 dark:text-green-400\" />;\n      case 'error':\n        return <FiAlertCircle size={16} className=\"text-red-600 dark:text-red-400\" />;\n      default:\n        return <FiClock size={16} className=\"text-slate-500 dark:text-slate-400\" />;\n    }\n  };\n\n  // 生成工具描述文本 - 增强描述信息的可读性\n  const getToolDescription = (toolCall: any) => {\n    const status = getToolCallStatus(toolCall);\n    \n    // For streaming calls, show streaming indicator\n    if (status === 'streaming') {\n      const streamingCall = sessionStreamingCalls[toolCall.id];\n      if (streamingCall && streamingCall.accumulatedArguments) {\n        try {\n          const parsed = JSON.parse(streamingCall.accumulatedArguments);\n          // Show relevant field based on tool type\n          if (toolCall.function.name === 'write_file' && parsed.path) {\n            return `${parsed.path} (streaming...)`;\n          }\n          if (toolCall.function.name === 'run_command' && parsed.command) {\n            return `${parsed.command} (streaming...)`;\n          }\n        } catch {\n          // If not valid JSON yet, show streaming indicator\n          return 'streaming arguments...';\n        }\n      }\n      return 'starting...';\n    }\n\n    try {\n      const args = JSON.parse(toolCall.function.arguments || '{}');\n\n      switch (toolCall.function.name) {\n        case 'web_search':\n          return args.query ? `\"${args.query}\"` : '';\n        case 'browser_navigate':\n          // 限制 URL 长度以避免溢出\n          return args.url;\n        case 'browser_vision_control':\n        case 'browser_control':\n          return args.action ? `${args.action}` : '';\n        case 'browser_click':\n          return args.selector || args.text ? `click: ${args.selector || args.text}` : 'click';\n        case 'list_directory':\n          return args.path ? `path: ${args.path}` : '';\n        case 'run_command':\n          return args.command;\n\n        case 'read_file':\n        case 'write_file':\n          return args.path ? `file: ${args.path.split('/').pop()}` : '';\n        default:\n          return '';\n      }\n    } catch (error) {\n      console.error('Failed to parse tool arguments:', error);\n      return '';\n    }\n  };\n\n  // 获取浏览器操作结果说明\n  const getResultInfo = (toolCall: any, status: string) => {\n    const result = toolResults.find((result) => result.toolCallId === toolCall.id);\n\n    if (status === 'error' && result?.error) {\n      return '\"operation failed\"';\n    } else if (status === 'success') {\n      if (toolCall.function.name === 'browser_get_markdown') {\n        return '\"content retrieved\"';\n      } else if (toolCall.function.name === 'browser_navigate') {\n        return '\"navigation success\"';\n      } else if (toolCall.function.name === 'browser_click') {\n        return '\"click successful\"';\n      } else if (toolCall.function.name.startsWith('run_')) {\n        return '\"command executed\"';\n      } else if (toolCall.function.name.startsWith('list_')) {\n        return '\"files listed\"';\n      } else if (toolCall.function.name.startsWith('read_')) {\n        return '\"file read\"';\n      } else if (toolCall.function.name.startsWith('write_')) {\n        return '\"file saved\"';\n      }\n    }\n\n    return '';\n  };\n\n  // 获取工具的格式化名称，使其更易读\n  const getToolDisplayName = (toolName: string) => {\n    // 替换下划线为空格\n    const nameWithSpaces = toolName.replace(/_/g, ' ');\n\n    // 特殊情况处理\n    switch (toolName) {\n      case 'browser_navigate':\n        return 'Navigate';\n      case 'browser_get_markdown':\n        return 'Extract Content';\n      case 'browser_click':\n        return 'Click Element';\n      case 'web_search':\n        return 'Web Search';\n      case 'list_directory':\n        return 'List Files';\n      case 'run_command':\n        return 'Run Command';\n      case 'read_file':\n        return 'Read File';\n      case 'write_file':\n        return 'Write File';\n      default:\n        // 首字母大写\n        return nameWithSpaces\n          .split(' ')\n          .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n          .join(' ');\n    }\n  };\n\n  return (\n    <div className=\"mt-2 space-y-1.5\">\n      {toolCalls.map((toolCall) => {\n        const status = getToolCallStatus(toolCall) as 'pending' | 'success' | 'error' | 'streaming';\n        const description = getToolDescription(toolCall);\n        const browserInfo = getResultInfo(toolCall, status);\n        const displayName = getToolDisplayName(toolCall.function.name);\n\n        return (\n          <ActionButton\n            key={toolCall.id}\n            icon={getToolIcon(toolCall.function.name)}\n            label={displayName}\n            onClick={() => onToolCallClick(toolCall)}\n            status={status === 'streaming' ? 'pending' : status}\n            statusIcon={getStatusIcon(status, toolCall.function.name)}\n            description={description || browserInfo || undefined}\n          />\n        );\n      })}\n    </div>\n  );\n};\n","import React, { useState } from 'react';\nimport { motion } from 'framer-motion';\nimport { useSession } from '@/common/hooks/useSession';\nimport { ToolResultRenderer } from './renderers/ToolResultRenderer';\nimport { ResearchReportRenderer } from './renderers/ResearchReportRenderer';\nimport { WorkspaceHeader } from './components/WorkspaceHeader';\nimport { ImageModal } from './components/ImageModal';\nimport { FullscreenModal } from './components/FullscreenModal';\nimport { standardizeContent } from './utils/contentStandardizer';\nimport { StandardPanelContent, ZoomedImageData, FullscreenFileData } from './types/panelContent';\nimport { StreamingToolCall } from '@/common/state/atoms/tool';\n\n/**\n * WorkspaceDetail Component - Displays details of a single tool result or report\n */\nexport const WorkspaceDetail: React.FC = () => {\n  const { activePanelContent, setActivePanelContent } = useSession();\n  const [zoomedImage, setZoomedImage] = useState<ZoomedImageData | null>(null);\n  const [fullscreenData, setFullscreenData] = useState<FullscreenFileData | null>(null);\n\n  if (!activePanelContent) {\n    return null;\n  }\n\n  // Type assertion with runtime validation\n  const panelContent = activePanelContent as StandardPanelContent;\n\n  // Handle streaming tool calls\n  if (panelContent.type === 'streaming_tool_call' && isStreamingToolCall(panelContent.source)) {\n    return (\n      <motion.div\n        initial={{ opacity: 0 }}\n        animate={{ opacity: 1 }}\n        exit={{ opacity: 0 }}\n        className=\"h-full flex flex-col bg-white dark:bg-gray-900/20\"\n      >\n        {/* Header */}\n        <WorkspaceHeader panelContent={panelContent} onBack={() => setActivePanelContent(null)} />\n\n        {/* Content area */}\n        <div className=\"flex-1 overflow-auto p-4\">\n          <ToolResultRenderer content={panelContent.source} onAction={handleContentAction} />\n        </div>\n      </motion.div>\n    );\n  }\n\n  // Handle research reports and deliverables\n  if (isResearchReportType(panelContent)) {\n    return (\n      <ResearchReportRenderer\n        content={getReportContent(panelContent)}\n        title={panelContent.title || 'Research Report'}\n        isStreaming={panelContent.isStreaming}\n      />\n    );\n  }\n\n  // Handle tool result content actions\n  const handleContentAction = (action: string, data: unknown) => {\n    switch (action) {\n      case 'zoom':\n        if (isZoomData(data)) {\n          setZoomedImage({ src: data.src, alt: data.alt });\n        }\n        break;\n      case 'fullscreen':\n        if (isFullscreenData(data)) {\n          setFullscreenData(data);\n        }\n        break;\n    }\n  };\n\n  // Handle back navigation\n  const handleBack = () => {\n    setActivePanelContent(null);\n  };\n\n  // Get standardized content\n  const standardizedContent = standardizeContent(panelContent);\n\n  return (\n    <>\n      <motion.div\n        initial={{ opacity: 0 }}\n        animate={{ opacity: 1 }}\n        exit={{ opacity: 0 }}\n        className=\"h-full flex flex-col bg-white dark:bg-gray-900/20\"\n      >\n        {/* Header */}\n        <WorkspaceHeader panelContent={panelContent} onBack={handleBack} />\n\n        {/* Content area */}\n        <div className=\"flex-1 overflow-auto p-4\">\n          <ToolResultRenderer content={standardizedContent} onAction={handleContentAction} />\n        </div>\n      </motion.div>\n\n      {/* Modals */}\n      <ImageModal imageData={zoomedImage} onClose={() => setZoomedImage(null)} />\n\n      <FullscreenModal data={fullscreenData} onClose={() => setFullscreenData(null)} />\n    </>\n  );\n};\n\n// Type guard functions\nfunction isStreamingToolCall(source: unknown): source is StreamingToolCall {\n  return source !== null && \n         typeof source === 'object' && \n         'toolCallId' in source && \n         'accumulatedArguments' in source &&\n         'toolName' in source;\n}\n\nfunction isResearchReportType(content: StandardPanelContent): boolean {\n  return (\n    content.type === 'research_report' ||\n    content.type === 'deliverable' ||\n    Boolean(content.toolCallId?.startsWith('final-answer'))\n  );\n}\n\nfunction getReportContent(content: StandardPanelContent): string {\n  if (typeof content.source === 'string') {\n    return content.source;\n  }\n  return JSON.stringify(content.source, null, 2);\n}\n\nfunction isZoomData(data: unknown): data is { src: string; alt?: string } {\n  return data !== null && typeof data === 'object' && 'src' in data && typeof data.src === 'string';\n}\n\nfunction isFullscreenData(data: unknown): data is FullscreenFileData {\n  return (\n    data !== null &&\n    typeof data === 'object' &&\n    'content' in data &&\n    'fileName' in data &&\n    'filePath' in data &&\n    'displayMode' in data &&\n    'isMarkdown' in data &&\n    typeof (data as FullscreenFileData).content === 'string' &&\n    typeof (data as FullscreenFileData).fileName === 'string' &&\n    typeof (data as FullscreenFileData).filePath === 'string'\n  );\n}\n","import React, { useEffect, useState } from 'react';\nimport { motion } from 'framer-motion';\nimport { FiLoader, FiClock, FiCode, FiFileText } from 'react-icons/fi';\nimport { StreamingToolCall } from '@/common/state/atoms/tool';\nimport { formatTimestamp } from '@/common/utils/formatters';\n\ninterface StreamingToolCallRendererProps {\n  streamingCall: StreamingToolCall;\n  onAction?: (action: string, data: unknown) => void;\n}\n\n/**\n * StreamingToolCallRenderer - Renders a tool call that is currently in progress\n * \n * This component shows real-time progress of tool calls, especially useful for\n * long-running operations like write_file with large content.\n */\nexport const StreamingToolCallRenderer: React.FC<StreamingToolCallRendererProps> = ({\n  streamingCall,\n}) => {\n  const [displayArguments, setDisplayArguments] = useState('');\n  const [isAnimating, setIsAnimating] = useState(false);\n\n  // Update display arguments with a slight delay for smooth animation\n  useEffect(() => {\n    setIsAnimating(true);\n    const timer = setTimeout(() => {\n      setDisplayArguments(streamingCall.accumulatedArguments);\n      setIsAnimating(false);\n    }, 100);\n\n    return () => clearTimeout(timer);\n  }, [streamingCall.accumulatedArguments]);\n\n  // Parse arguments for better display\n  const parsedArguments = React.useMemo(() => {\n    if (!displayArguments.trim()) return null;\n    \n    try {\n      return JSON.parse(displayArguments);\n    } catch {\n      // If not valid JSON yet, return the raw string\n      return displayArguments;\n    }\n  }, [displayArguments]);\n\n  // Get tool-specific display information\n  const getToolDisplayInfo = () => {\n    switch (streamingCall.toolName) {\n      case 'write_file':\n        return {\n          icon: <FiFileText size={18} />,\n          title: 'Writing File',\n          description: 'Content is being written to file...',\n          color: 'text-blue-500 dark:text-blue-400',\n          bgColor: 'bg-blue-50 dark:bg-blue-900/20',\n          borderColor: 'border-blue-200 dark:border-blue-800/30',\n        };\n      case 'edit_file':\n        return {\n          icon: <FiCode size={18} />,\n          title: 'Editing File',\n          description: 'File modifications in progress...',\n          color: 'text-purple-500 dark:text-purple-400',\n          bgColor: 'bg-purple-50 dark:bg-purple-900/20',\n          borderColor: 'border-purple-200 dark:border-purple-800/30',\n        };\n      case 'run_command':\n        return {\n          icon: <FiLoader size={18} />,\n          title: 'Running Command',\n          description: 'Command is being executed...',\n          color: 'text-green-500 dark:text-green-400',\n          bgColor: 'bg-green-50 dark:bg-green-900/20',\n          borderColor: 'border-green-200 dark:border-green-800/30',\n        };\n      default:\n        return {\n          icon: <FiLoader size={18} />,\n          title: streamingCall.toolName.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase()),\n          description: 'Operation in progress...',\n          color: 'text-gray-500 dark:text-gray-400',\n          bgColor: 'bg-gray-50 dark:bg-gray-900/20',\n          borderColor: 'border-gray-200 dark:border-gray-800/30',\n        };\n    }\n  };\n\n  const toolInfo = getToolDisplayInfo();\n\n  return (\n    <div className=\"space-y-4\">\n      {/* Header */}\n      <div className={`p-4 rounded-xl border ${toolInfo.borderColor} ${toolInfo.bgColor}`}>\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex items-center\">\n            <div className={`w-10 h-10 rounded-xl flex items-center justify-center mr-3 ${toolInfo.color}`}>\n              <motion.div\n                animate={{ rotate: streamingCall.toolName === 'run_command' ? 360 : 0 }}\n                transition={{ \n                  duration: 2, \n                  repeat: streamingCall.toolName === 'run_command' ? Infinity : 0,\n                  ease: 'linear' \n                }}\n              >\n                {toolInfo.icon}\n              </motion.div>\n            </div>\n            <div>\n              <h3 className=\"font-medium text-gray-800 dark:text-gray-200\">\n                {toolInfo.title}\n              </h3>\n              <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n                {toolInfo.description}\n              </p>\n            </div>\n          </div>\n          \n          <div className=\"flex items-center text-xs text-gray-500 dark:text-gray-400\">\n            <FiClock className=\"mr-1\" size={12} />\n            {formatTimestamp(streamingCall.startTimestamp)}\n          </div>\n        </div>\n      </div>\n\n      {/* Arguments display */}\n      {displayArguments && (\n        <div className=\"bg-white dark:bg-gray-800 rounded-xl border border-gray-200/50 dark:border-gray-700/30 overflow-hidden\">\n          <div className=\"px-4 py-3 bg-gray-50/80 dark:bg-gray-800/80 border-b border-gray-100/50 dark:border-gray-700/30 flex items-center justify-between\">\n            <div className=\"font-medium text-gray-700 dark:text-gray-300 text-sm\">\n              Tool Arguments\n            </div>\n            <motion.div\n              animate={{ opacity: isAnimating ? [1, 0.3, 1] : 1 }}\n              transition={{ duration: 0.3 }}\n              className=\"flex items-center text-xs text-gray-500 dark:text-gray-400\"\n            >\n              <motion.div\n                animate={{ scale: [1, 1.2, 1] }}\n                transition={{ duration: 1, repeat: Infinity }}\n                className=\"w-2 h-2 rounded-full bg-green-500 dark:bg-green-400 mr-2\"\n              />\n              Live\n            </motion.div>\n          </div>\n          \n          <div className=\"p-4 max-h-[60vh] overflow-auto\">\n            {typeof parsedArguments === 'string' ? (\n              <motion.pre \n                className=\"text-sm whitespace-pre-wrap font-mono text-gray-700 dark:text-gray-300\"\n                animate={{ opacity: isAnimating ? 0.7 : 1 }}\n                transition={{ duration: 0.2 }}\n              >\n                {parsedArguments}\n              </motion.pre>\n            ) : parsedArguments ? (\n              <motion.pre \n                className=\"text-sm whitespace-pre-wrap font-mono text-gray-700 dark:text-gray-300 bg-gray-50 dark:bg-gray-800/50 p-3 rounded-lg overflow-x-auto\"\n                animate={{ opacity: isAnimating ? 0.7 : 1 }}\n                transition={{ duration: 0.2 }}\n              >\n                {JSON.stringify(parsedArguments, null, 2)}\n              </motion.pre>\n            ) : (\n              <div className=\"flex items-center justify-center py-8 text-gray-500 dark:text-gray-400\">\n                <motion.div\n                  animate={{ rotate: 360 }}\n                  transition={{ duration: 2, repeat: Infinity, ease: 'linear' }}\n                  className=\"mr-2\"\n                >\n                  <FiLoader size={16} />\n                </motion.div>\n                Waiting for arguments...\n              </div>\n            )}\n          </div>\n        </div>\n      )}\n\n      {/* Progress indicator */}\n      <div className=\"flex items-center justify-center py-2\">\n        <div className=\"flex items-center text-sm text-gray-600 dark:text-gray-400\">\n          <motion.div\n            animate={{ rotate: 360 }}\n            transition={{ duration: 2, repeat: Infinity, ease: 'linear' }}\n            className=\"mr-2\"\n          >\n            <FiLoader size={14} />\n          </motion.div>\n          Tool call in progress...\n        </div>\n      </div>\n    </div>\n  );\n};\n","import React from 'react';\nimport { ImageRenderer } from './ImageRenderer';\nimport { LinkRenderer } from './LinkRenderer';\nimport { SearchResultRenderer } from './SearchResultRenderer';\nimport { CommandResultRenderer } from './CommandResultRenderer';\nimport { ScriptResultRenderer } from './ScriptResultRenderer';\nimport { BrowserResultRenderer } from './BrowserResultRenderer';\nimport { BrowserControlRenderer } from './BrowserControlRenderer';\nimport { PlanViewerRenderer } from './PlanViewerRenderer';\nimport { ResearchReportRenderer } from './ResearchReportRenderer';\nimport { GenericResultRenderer } from './generic/GenericResultRenderer';\nimport { DeliverableRenderer } from './DeliverableRenderer';\nimport { StreamingToolCallRenderer } from './StreamingToolCallRenderer';\nimport { ToolResultContentPart } from '../types';\nimport { StreamingToolCall } from '@/common/state/atoms/tool';\n\n/**\n * Registry of content part renderers\n * Maps content types to their renderer components\n *\n * Design pattern: Component Registry pattern - allows dynamic registration of\n * renderers for different content types without modifying the core renderer\n */\nconst CONTENT_RENDERERS: Record<\n  string,\n  React.FC<{ part: ToolResultContentPart; onAction?: (action: string, data: any) => void }>\n> = {\n  image: ImageRenderer,\n  link: LinkRenderer,\n  search_result: SearchResultRenderer,\n  command_result: CommandResultRenderer,\n  script_result: ScriptResultRenderer,\n  browser_result: BrowserResultRenderer,\n  browser_control: BrowserControlRenderer,\n  plan: PlanViewerRenderer,\n  research_report: ResearchReportRenderer,\n  json: GenericResultRenderer,\n  deliverable: DeliverableRenderer,\n  file_result: GenericResultRenderer,\n};\n\ninterface ToolResultRendererProps {\n  /**\n   * Array of content parts to render, or a single streaming tool call\n   */\n  content: ToolResultContentPart[] | StreamingToolCall;\n\n  /**\n   * Optional handler for interactive actions\n   */\n  onAction?: (action: string, data: any) => void;\n\n  /**\n   * Optional className for the container\n   */\n  className?: string;\n}\n\n/**\n * Type guard to check if content is a StreamingToolCall\n */\nfunction isStreamingToolCall(content: ToolResultContentPart[] | StreamingToolCall): content is StreamingToolCall {\n  return content && typeof content === 'object' && 'toolCallId' in content && 'accumulatedArguments' in content;\n}\n\n/**\n * Renders tool result content parts using the appropriate renderer for each part\n *\n * This component acts as a router that delegates rendering to specialized components\n * based on the content type, making it easily extensible to new content types.\n *\n * Improvements:\n * - Special handling for browser_get_markdown content\n * - Uses browser shell for browser-related tool results\n * - Consistent styling across all tool result types\n * - Intelligent generic renderer for unknown formats\n * - Support for streaming tool calls\n */\nexport const ToolResultRenderer: React.FC<ToolResultRendererProps> = ({\n  content,\n  onAction,\n  className = '',\n}) => {\n  // Handle streaming tool call\n  if (isStreamingToolCall(content)) {\n    return (\n      <div className={`streaming-tool-call-container ${className}`}>\n        <StreamingToolCallRenderer streamingCall={content} onAction={onAction} />\n      </div>\n    );\n  }\n\n  // Handle regular content parts\n  if (!content || content.length === 0) {\n    return (\n      <div className=\"p-4 text-gray-500 dark:text-gray-400 text-sm italic\">\n        No content to display\n      </div>\n    );\n  }\n\n  return (\n    <div className={`space-y-4 ${className}`}>\n      {content.map((part, index) => {\n        if (part.type === 'json') {\n          return (\n            <div key={`json-${part.name || ''}-${index}`} className=\"tool-result-part\">\n              <GenericResultRenderer part={part} onAction={onAction} />\n            </div>\n          );\n        }\n\n        const Renderer = CONTENT_RENDERERS[part.type] || GenericResultRenderer;\n\n        return (\n          <div key={`${part.type}-${part.name || ''}-${index}`} className=\"tool-result-part\">\n            <Renderer part={part} onAction={onAction} />\n          </div>\n        );\n      })}\n    </div>\n  );\n};\n\n/**\n * Register a custom renderer for a specific content type\n * This allows extending the system with new renderers without modifying this file\n */\nexport function registerRenderer(\n  contentType: string,\n  renderer: React.FC<{\n    part: ToolResultContentPart;\n    onAction?: (action: string, data: any) => void;\n  }>,\n): void {\n  CONTENT_RENDERERS[contentType] = renderer;\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACvBA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAOA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AASA;AACA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;;;AAGA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAYA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AAIA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC/5BA;AAgBA;;;AAGA;AAGA;;;AAGA;AAGA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;;;;;;;;;AASA;AACA;;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;AAEA;AAAA;AAAA;;;;;;;;;;;;AAGA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;;;;;;;;;AAGA;AACA;AAAA;AAAA;;;;;;AACA;AACA;AAAA;AAAA;;;;;;AACA;AACA;AAAA;AAAA;;;;;;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AANA;;;;;AASA;;;;;;AAGA;AAxMA;;AAOA;AACA;;;AARA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;;;;;;AAGA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;;;;;;AAGA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;;;;;;;;AAGA;AA1FA;;AACA;;;AADA;AA4FA;AACA;AACA;AAKA;AAEA;AAIA;AAHA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpJA;AACA;AACA;AAEA;AAOA;;;;;AAKA;AACA;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AAEA;AAAA;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AAGA;;AACA;AAAA;AACA;;;;;;AAEA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAKA;AAAA;;AACA;AAAA;AAAA;;;;;;AACA;;;;;;;;;;;;;;;;;;AAMA;AACA;;AACA;AAAA;;AACA;AAAA;AAAA;;;;;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;AACA;;;;;;;;;;;;;AAKA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;;;;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;;;;AAGA;AAAA;;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;AASA;AAAA;AACA;AAAA;;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;AAMA;AAjLA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;;;;;;AAMA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAmBA;;AAEA;AAEA;AACA;AAEA;;;;;;;;;;;;AAYA;AACA;AAKA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;AAGA;AAEA;AACA;AACA;AACA;AAAA;;;;;;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;AADA;;;;;AAIA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;;;;;;AADA;;;;;AAIA;;;;;;AAGA;AA5CA;AA8CA;;;AAGA;AAQA;AACA"}