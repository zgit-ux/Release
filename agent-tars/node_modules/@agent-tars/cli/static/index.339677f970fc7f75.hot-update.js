"use strict";
self["webpackHotUpdate_agent_tars_web_ui"]("index", {
"./src/entry.css": (function (module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
// extracted by css-extract-rspack-plugin

    if(true) {
      (function() {
        var localsJsonString = undefined;
        // 1749663241895
        var cssReload = (__webpack_require__("../node_modules/.pnpm/@rspack+core@1.3.9_@swc+helpers@0.5.17/node_modules/@rspack/core/dist/cssExtractHmr.js")/* .cssReload */.cssReload)(module.id, {});
        // only invalidate when locals change
        if (
          module.hot.data &&
          module.hot.data.value &&
          module.hot.data.value !== localsJsonString
        ) {
          module.hot.invalidate();
        } else {
          module.hot.accept();
        }
        module.hot.dispose(function(data) {
          data.value = localsJsonString;
          cssReload();
        });
      })();
    }
  

}),
"./src/main/services/socketService.ts": (function (module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  socketService: () => (socketService)
});
/* ESM import */var _swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("../node_modules/.pnpm/@swc+helpers@0.5.17/node_modules/@swc/helpers/esm/_define_property.js");
/* ESM import */var socket_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../node_modules/.pnpm/socket.io-client@4.8.1/node_modules/socket.io-client/build/esm/index.js");
/* ESM import */var _common_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/common/constants/index.ts");
/* provided dependency */ var $ReactRefreshRuntime$ = __webpack_require__("../node_modules/.pnpm/@rspack+plugin-react-refresh@1.0.3_react-refresh@0.16.0/node_modules/@rspack/plugin-react-refresh/client/reactRefresh.js");



/**
 * Socket Service - Manages WebSocket connection with server
 */ class SocketService {
    /**
   * Connect to the WebSocket server
   */ connect() {
        var _this_socket;
        if ((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) {
            return this.socket;
        }
        this.socket = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_0__.io)(_common_constants__WEBPACK_IMPORTED_MODULE_1__.API_BASE_URL, {
            reconnection: true,
            reconnectionDelay: _common_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_SETTINGS.RECONNECTION_DELAY,
            reconnectionDelayMax: _common_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_SETTINGS.RECONNECTION_DELAY_MAX,
            reconnectionAttempts: _common_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_SETTINGS.MAX_RECONNECT_ATTEMPTS
        });
        // Set up core event handlers
        this.setupEventHandlers();
        return this.socket;
    }
    /**
   * Disconnect from the WebSocket server
   */ disconnect() {
        this.stopHeartbeat();
        if (this.socket) {
            this.socket.disconnect();
            this.socket = null;
        }
        this.missedHeartbeats = 0;
        this.reconnectAttempts = 0;
    }
    /**
   * Check if currently connected to the server
   */ isConnected() {
        var _this_socket;
        return ((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected) || false;
    }
    /**
   * Join a specific session to receive its events
   */ joinSession(sessionId, onEvent, onStatusUpdate) {
        if (!this.socket) {
            this.connect();
        }
        if (!this.socket) return;
        console.log(`Joining session: ${sessionId}`);
        this.socket.emit(_common_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_EVENTS.JOIN_SESSION, sessionId);
        // 清理现有监听器
        this.socket.off(_common_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_EVENTS.AGENT_EVENT);
        this.socket.off(_common_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_EVENTS.AGENT_STATUS);
        // 设置事件监听器
        this.socket.on(_common_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_EVENTS.AGENT_EVENT, (param)=>{
            let { type, data } = param;
            if (data) {
                onEvent(data);
            }
        });
        // 增强状态更新处理
        this.socket.on(_common_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_EVENTS.AGENT_STATUS, (status)=>{
            console.log('Received agent status:', status);
            onStatusUpdate(status);
            // 触发全局事件以同步应用中的所有组件
            this.notifyEventHandlers(_common_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_EVENTS.AGENT_STATUS, status);
        });
        // 立即请求当前状态
        this.socket.emit('request-status', {
            sessionId
        });
    }
    /**
   * Send a query to the server
   */ sendQuery(params) {
        var _this_socket;
        if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected)) {
            throw new Error('Socket not connected');
        }
        this.socket.emit(_common_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_EVENTS.SEND_QUERY, params);
    }
    /**
   * Abort the current query
   */ abortQuery(params) {
        var _this_socket;
        if (!((_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.connected)) {
            throw new Error('Socket not connected');
        }
        this.socket.emit(_common_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_EVENTS.ABORT_QUERY, params);
    }
    /**
   * Add an event listener
   */ on(event, callback) {
        if (!this.eventHandlers[event]) {
            this.eventHandlers[event] = [];
        }
        this.eventHandlers[event].push(callback);
        // If we already have a socket, add the listener directly
        if (this.socket) {
            this.socket.on(event, callback);
        }
    }
    /**
   * Remove an event listener
   */ off(event, callback) {
        if (this.eventHandlers[event]) {
            this.eventHandlers[event] = this.eventHandlers[event].filter((cb)=>cb !== callback);
        }
        if (this.socket) {
            this.socket.off(event, callback);
        }
    }
    /**
   * Send a ping to check server connectivity
   */ ping() {
        return new Promise((resolve)=>{
            if (!this.socket || !this.socket.connected) {
                resolve(false);
                return;
            }
            const timeout = setTimeout(()=>{
                resolve(false);
            }, 5000);
            this.socket.emit(_common_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_EVENTS.PING, ()=>{
                clearTimeout(timeout);
                resolve(true);
            });
        });
    }
    /**
   * Get the socket instance
   */ getSocket() {
        return this.socket;
    }
    /**
   * Set up event handlers for the socket connection
   */ setupEventHandlers() {
        if (!this.socket) return;
        this.socket.on(_common_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_EVENTS.CONNECT, this.handleConnect);
        this.socket.on(_common_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_EVENTS.DISCONNECT, this.handleDisconnect);
        this.socket.on(_common_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_EVENTS.ERROR, this.handleError);
        this.socket.on(_common_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_EVENTS.RECONNECT_ATTEMPT, this.handleReconnectAttempt);
        this.socket.on(_common_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_EVENTS.RECONNECT_FAILED, this.handleReconnectFailed);
        // Apply any event handlers that were registered before connecting
        Object.entries(this.eventHandlers).forEach((param)=>{
            let [event, handlers] = param;
            handlers.forEach((handler)=>{
                var _this_socket;
                (_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.on(event, handler);
            });
        });
    }
    /**
   * Start heartbeat monitoring
   */ startHeartbeat() {
        this.stopHeartbeat();
        this.missedHeartbeats = 0;
        this.heartbeatTimer = setInterval(()=>{
            this.sendHeartbeat();
        }, _common_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_SETTINGS.HEARTBEAT_INTERVAL);
    }
    /**
   * Stop heartbeat monitoring
   */ stopHeartbeat() {
        if (this.heartbeatTimer) {
            clearInterval(this.heartbeatTimer);
            this.heartbeatTimer = null;
        }
    }
    /**
   * Send heartbeat to server and track response
   */ sendHeartbeat() {
        if (!this.socket || !this.socket.connected) {
            this.missedHeartbeats++;
            if (this.missedHeartbeats >= _common_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_SETTINGS.MAX_MISSED_HEARTBEATS) {
                var _this_socket;
                console.warn(`Missed ${this.missedHeartbeats} heartbeats, connection may be down`);
                (_this_socket = this.socket) === null || _this_socket === void 0 ? void 0 : _this_socket.disconnect();
            }
            return;
        }
        this.socket.emit(_common_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_EVENTS.PING, ()=>{
            this.missedHeartbeats = 0;
        });
        // Increment counter - will be reset when we get a response
        this.missedHeartbeats++;
        if (this.missedHeartbeats >= _common_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_SETTINGS.MAX_MISSED_HEARTBEATS) {
            console.warn(`Missed ${this.missedHeartbeats} heartbeats, connection may be down`);
            this.socket.disconnect();
        }
    }
    /**
   * Notify all registered event handlers for a specific event
   */ notifyEventHandlers(event) {
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            args[_key - 1] = arguments[_key];
        }
        if (this.eventHandlers[event]) {
            this.eventHandlers[event].forEach((handler)=>{
                try {
                    handler(...args);
                } catch (error) {
                    console.error(`Error in ${event} event handler:`, error);
                }
            });
        }
    }
    constructor(){
        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_2__._)(this, "socket", null);
        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_2__._)(this, "heartbeatTimer", null);
        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_2__._)(this, "missedHeartbeats", 0);
        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_2__._)(this, "reconnectAttempts", 0);
        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_2__._)(this, "eventHandlers", {});
        /**
   * Handle successful connection
   */ (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_2__._)(this, "handleConnect", ()=>{
            console.log('Connected to server');
            this.missedHeartbeats = 0;
            this.reconnectAttempts = 0;
            this.startHeartbeat();
            // Notify event handlers
            this.notifyEventHandlers(_common_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_EVENTS.CONNECT);
        });
        /**
   * Handle disconnection
   */ (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_2__._)(this, "handleDisconnect", (reason)=>{
            console.log('Disconnected from server:', reason);
            this.stopHeartbeat();
            // Notify event handlers
            this.notifyEventHandlers(_common_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_EVENTS.DISCONNECT, reason);
        });
        /**
   * Handle connection errors
   */ (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_2__._)(this, "handleError", (error)=>{
            console.error('Socket error:', error);
            // Notify event handlers
            this.notifyEventHandlers(_common_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_EVENTS.ERROR, error);
        });
        /**
   * Handle reconnection attempts
   */ (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_2__._)(this, "handleReconnectAttempt", ()=>{
            this.reconnectAttempts++;
            console.log(`Reconnection attempt ${this.reconnectAttempts}/${_common_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_SETTINGS.MAX_RECONNECT_ATTEMPTS}`);
            // Notify event handlers
            this.notifyEventHandlers(_common_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_EVENTS.RECONNECT_ATTEMPT, this.reconnectAttempts);
        });
        /**
   * Handle failed reconnection
   */ (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_2__._)(this, "handleReconnectFailed", ()=>{
            console.log('Failed to reconnect after multiple attempts');
            // Notify event handlers
            this.notifyEventHandlers(_common_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_EVENTS.RECONNECT_FAILED);
        });
    }
}
// Export singleton instance
const socketService = new SocketService();

function $RefreshSig$() {
  return $ReactRefreshRuntime$.createSignatureFunctionForTransform();
}
function $RefreshReg$(type, id) {
  $ReactRefreshRuntime$.register(type, module.id + "_" + id);
}
Promise.resolve().then(function() {
  $ReactRefreshRuntime$.refresh(module.id, module.hot);
});


}),

},function(__webpack_require__) {
// webpack/runtime/get_full_hash
(() => {
__webpack_require__.h = () => ("41e9e488fd575898")
})();

}
);
//# sourceMappingURL=index.339677f970fc7f75.hot-update.js.map