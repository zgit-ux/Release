{"version":3,"file":"index.e01c02bb70e777e1.hot-update.js","sources":["/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/entry.css","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/v2/state/actions/eventProcessor.ts"],"sourcesContent":["// extracted by css-extract-rspack-plugin\nexport {};\n    if(module.hot) {\n      (function() {\n        var localsJsonString = undefined;\n        // 1749580247009\n        var cssReload = require(\"../../node_modules/.pnpm/@rspack+core@1.3.9_@swc+helpers@0.5.17/node_modules/@rspack/core/dist/cssExtractHmr.js\").cssReload(module.id, {});\n        // only invalidate when locals change\n        if (\n          module.hot.data &&\n          module.hot.data.value &&\n          module.hot.data.value !== localsJsonString\n        ) {\n          module.hot.invalidate();\n        } else {\n          module.hot.accept();\n        }\n        module.hot.dispose(function(data) {\n          data.value = localsJsonString;\n          cssReload();\n        });\n      })();\n    }\n  ","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { atom, Setter } from 'jotai';\nimport { v4 as uuidv4 } from 'uuid';\nimport { AgentEventStream, ToolResult, Message } from '../../types';\nimport { messagesAtom } from '../atoms/message';\nimport { toolResultsAtom, toolCallResultMap } from '../atoms/tool';\nimport { isProcessingAtom, activePanelContentAtom } from '../atoms/ui';\nimport { determineToolType } from '../../utils/formatters';\nimport { plansAtom, PlanKeyframe } from '../atoms/plan';\nimport { replayStateAtom } from '../atoms/replay';\nimport { ChatCompletionContentPartImage } from '@multimodal/agent-interface';\n\n// 存储工具调用参数的映射表 (不是 Atom，是内部缓存)\nconst toolCallArgumentsMap = new Map<string, any>();\n\n/**\n * Process a single event and update the appropriate state atoms\n */\nexport const processEventAction = atom(\n  null,\n  (get, set, params: { sessionId: string; event: AgentEventStream.Event }) => {\n    const { sessionId, event } = params;\n    const replayState = get(replayStateAtom);\n    const isReplayMode = replayState.isActive;\n\n    console.log('[GUI] event.type', event.type);\n\n    switch (event.type) {\n      case 'user_message':\n        handleUserMessage(set, sessionId, event);\n        break;\n\n      case 'assistant_message':\n        handleAssistantMessage(get, set, sessionId, event);\n        break;\n\n      case 'assistant_streaming_message':\n        if (!isReplayMode) {\n          handleStreamingMessage(get, set, sessionId, event);\n        }\n        break;\n\n      case 'assistant_thinking_message':\n      case 'assistant_streaming_thinking_message':\n        handleThinkingMessage(get, set, sessionId, event);\n        break;\n\n      case 'tool_call':\n        handleToolCall(set, sessionId, event);\n        break;\n\n      case 'tool_result':\n        handleToolResult(set, sessionId, event);\n        break;\n\n      case 'system':\n        handleSystemMessage(set, sessionId, event);\n        break;\n\n      case 'environment_input':\n        handleEnvironmentInput(set, sessionId, event);\n        break;\n\n      case 'agent_run_start':\n        set(isProcessingAtom, true);\n        break;\n\n      case 'agent_run_end':\n        set(isProcessingAtom, false);\n        break;\n\n      case 'plan_start':\n        handlePlanStart(set, sessionId, event);\n        break;\n\n      case 'plan_update':\n        handlePlanUpdate(set, sessionId, event);\n        break;\n\n      case 'plan_finish':\n        handlePlanFinish(set, sessionId, event);\n        break;\n\n      case 'final_answer':\n        handleFinalAnswer(get, set, sessionId, event);\n        break;\n\n      case 'final_answer_streaming':\n        if (!isReplayMode) {\n          handleFinalAnswerStreaming(get, set, sessionId, event);\n        }\n        break;\n    }\n  },\n);\n\nexport const updateProcessingStatusAction = atom(\n  null,\n  (get, set, status: { isProcessing: boolean; state?: string }) => {\n    // Update processing state\n    set(isProcessingAtom, !!status.isProcessing);\n  },\n);\n\n/**\n * Handle user message event\n */\nfunction handleUserMessage(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.UserMessageEvent,\n): void {\n  const userMessage: Message = {\n    id: event.id,\n    role: 'user',\n    content: event.content,\n    timestamp: event.timestamp,\n  };\n\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, userMessage],\n    };\n  });\n\n  // Check for images in user message and set active panel content if found\n  if (Array.isArray(event.content)) {\n    const images = event.content.filter((part) => part.type === 'image_url');\n    if (images.length > 0) {\n      set(activePanelContentAtom, {\n        type: 'image',\n        source: images[0].image_url.url,\n        title: 'User Upload',\n        timestamp: Date.now(),\n      });\n    }\n  }\n}\n\n/**\n * Handle assistant message event (complete message)\n */\nfunction handleAssistantMessage(\n  get: any,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.AssistantMessageEvent,\n): void {\n  // 获取消息ID\n  const messageId = event.messageId;\n\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n\n    // 检查是否已存在相同messageId的消息\n    if (messageId) {\n      const existingMessageIndex = sessionMessages.findIndex((msg) => msg.messageId === messageId);\n\n      // 如果找到了现有消息，更新它而不是添加新消息\n      if (existingMessageIndex !== -1) {\n        const updatedMessages = [...sessionMessages];\n        updatedMessages[existingMessageIndex] = {\n          ...updatedMessages[existingMessageIndex],\n          content: event.content,\n          timestamp: event.timestamp,\n          toolCalls: event.toolCalls,\n          finishReason: event.finishReason,\n          isStreaming: false,\n        };\n\n        return {\n          ...prev,\n          [sessionId]: updatedMessages,\n        };\n      }\n    }\n\n    // 没有找到现有消息，添加新消息\n    return {\n      ...prev,\n      [sessionId]: [\n        ...sessionMessages,\n        {\n          id: event.id,\n          role: 'assistant',\n          content: event.content,\n          timestamp: event.timestamp,\n          toolCalls: event.toolCalls,\n          finishReason: event.finishReason,\n          messageId: messageId,\n        },\n      ],\n    };\n  });\n\n  set(isProcessingAtom, false);\n}\n\n/**\n * Handle streaming message event (incremental content)\n */\nfunction handleStreamingMessage(\n  get: any,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.AssistantStreamingMessageEvent,\n): void {\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    const messageIdToFind = event.messageId;\n    let existingMessageIndex = -1;\n\n    // 优先按messageId查找\n    if (messageIdToFind) {\n      existingMessageIndex = sessionMessages.findIndex((msg) => msg.messageId === messageIdToFind);\n    }\n    // 没有messageId或未找到，尝试查找标记为streaming的最后一条消息\n    else if (sessionMessages.length > 0) {\n      const lastMessageIndex = sessionMessages.length - 1;\n      const lastMessage = sessionMessages[lastMessageIndex];\n      if (lastMessage && lastMessage.isStreaming) {\n        existingMessageIndex = lastMessageIndex;\n      }\n    }\n\n    // 更新现有消息\n    if (existingMessageIndex !== -1) {\n      const existingMessage = sessionMessages[existingMessageIndex];\n      const updatedMessage = {\n        ...existingMessage,\n        content:\n          typeof existingMessage.content === 'string'\n            ? existingMessage.content + event.content\n            : event.content,\n        isStreaming: !event.isComplete,\n        toolCalls: event.toolCalls || existingMessage.toolCalls,\n      };\n\n      return {\n        ...prev,\n        [sessionId]: [\n          ...sessionMessages.slice(0, existingMessageIndex),\n          updatedMessage,\n          ...sessionMessages.slice(existingMessageIndex + 1),\n        ],\n      };\n    }\n\n    // 创建新消息\n    const newMessage: Message = {\n      id: event.id || uuidv4(),\n      role: 'assistant',\n      content: event.content,\n      timestamp: event.timestamp,\n      isStreaming: !event.isComplete,\n      toolCalls: event.toolCalls,\n      messageId: event.messageId,\n    };\n\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, newMessage],\n    };\n  });\n\n  if (event.isComplete) {\n    set(isProcessingAtom, false);\n  }\n}\n\n/**\n * Handle thinking message event\n */\nfunction handleThinkingMessage(\n  get: any,\n  set: Setter,\n  sessionId: string,\n  event:\n    | AgentEventStream.AssistantThinkingMessageEvent\n    | AgentEventStream.AssistantStreamingThinkingMessageEvent,\n): void {\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    const lastAssistantIndex = [...sessionMessages]\n      .reverse()\n      .findIndex((m) => m.role === 'assistant');\n\n    if (lastAssistantIndex !== -1) {\n      const actualIndex = sessionMessages.length - 1 - lastAssistantIndex;\n      const message = sessionMessages[actualIndex];\n\n      return {\n        ...prev,\n        [sessionId]: [\n          ...sessionMessages.slice(0, actualIndex),\n          { ...message, thinking: event.content },\n          ...sessionMessages.slice(actualIndex + 1),\n        ],\n      };\n    }\n\n    return prev;\n  });\n}\n\n/**\n * Handle tool call event - store arguments for later use\n */\nfunction handleToolCall(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.ToolCallEvent,\n): void {\n  // 保存工具调用的参数信息以便后续使用\n  if (event.toolCallId && event.arguments) {\n    toolCallArgumentsMap.set(event.toolCallId, event.arguments);\n  }\n\n  console.log('Tool call stored:', event.name, event.toolCallId);\n}\n\n/**\n * Handle tool result event\n */\nfunction handleToolResult(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.ToolResultEvent,\n): void {\n  // 获取之前存储的参数信息\n  const args = toolCallArgumentsMap.get(event.toolCallId);\n\n  // 添加调试日志来跟踪内容格式\n  console.log(`Tool result for ${event.name}:`, {\n    content: event.content,\n    isArray: Array.isArray(event.content),\n    hasTextItems:\n      Array.isArray(event.content) && event.content.some((item) => item.type === 'text'),\n    names: Array.isArray(event.content) ? event.content.map((item) => item.name) : 'not-an-array',\n  });\n\n  // 如果内容是标准化工具结果格式的数组，则直接使用\n  const isStandardFormat =\n    Array.isArray(event.content) &&\n    event.content.length > 0 &&\n    typeof event.content[0] === 'object' &&\n    'type' in event.content[0];\n\n  const result: ToolResult = {\n    id: uuidv4(),\n    toolCallId: event.toolCallId,\n    name: event.name,\n    content: event.content,\n    timestamp: event.timestamp,\n    error: event.error,\n    type: determineToolType(event.name, event.content),\n    arguments: args, // 使用保存的参数信息\n  };\n\n  // 添加调试日志，显示确定的类型\n  console.log(`Determined type for ${event.name}: ${result.type}`);\n\n  // 如果是browser_vision_control工具，检查是否有关联的环境输入面板\n  if (result.type === 'browser_vision_control') {\n    // 获取当前活动面板内容\n    set(activePanelContentAtom, (prev) => {\n      // 如果当前面板是图片类型且来自环境输入，则进行增强而非替换\n      if (prev && prev.type === 'image' && prev.environmentId) {\n        return {\n          ...prev,\n          type: 'browser_vision_control',\n          source: event.content,\n          title: prev.title,\n          timestamp: event.timestamp,\n          toolCallId: event.toolCallId,\n          error: event.error,\n          arguments: args,\n          originalContent: prev.source, // 保存原始环境内容\n        };\n      } else {\n        // 否则使用标准处理方式\n        return {\n          type: result.type,\n          source: result.content,\n          title: result.name,\n          timestamp: result.timestamp,\n          toolCallId: result.toolCallId,\n          error: result.error,\n          arguments: args,\n        };\n      }\n    });\n  } else {\n    // 非browser_vision_control工具使用标准处理\n    set(activePanelContentAtom, {\n      type: result.type,\n      source: result.content,\n      title: result.name,\n      timestamp: result.timestamp,\n      toolCallId: result.toolCallId,\n      error: result.error,\n      arguments: args,\n    });\n  }\n\n  // Store in the map for future reference\n  toolCallResultMap.set(result.toolCallId, result);\n\n  // Add to toolResults atom\n  set(toolResultsAtom, (prev: Record<string, ToolResult[]>) => {\n    const sessionResults = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionResults, result],\n    };\n  });\n\n  // Link to message with this tool call\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n\n    // Find message with this tool call\n    const messageIndex = [...sessionMessages]\n      .reverse()\n      .findIndex((m) => m.toolCalls?.some((tc) => tc.id === result.toolCallId));\n\n    if (messageIndex !== -1) {\n      const actualIndex = sessionMessages.length - 1 - messageIndex;\n      const message = sessionMessages[actualIndex];\n      const toolResults = message.toolResults || [];\n\n      const updatedMessage = {\n        ...message,\n        toolResults: [...toolResults, result],\n      };\n\n      return {\n        ...prev,\n        [sessionId]: [\n          ...sessionMessages.slice(0, actualIndex),\n          updatedMessage,\n          ...sessionMessages.slice(actualIndex + 1),\n        ],\n      };\n    }\n\n    return prev;\n  });\n}\n\n/**\n * Handle system message event\n */\nfunction handleSystemMessage(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.Event & { message: string; level?: string },\n): void {\n  const systemMessage: Message = {\n    id: uuidv4(),\n    role: 'system',\n    content: event.message,\n    timestamp: event.timestamp || Date.now(),\n  };\n\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, systemMessage],\n    };\n  });\n}\n\n/**\n * Handle environment input event\n * Adds it to messages but doesn't set it as active panel content\n */\nfunction handleEnvironmentInput(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.EnvironmentInputEvent,\n): void {\n  const environmentMessage: Message = {\n    id: event.id,\n    role: 'environment',\n    content: event.content,\n    timestamp: event.timestamp,\n    description: event.description || 'Environment Input',\n  };\n\n  console.log('[GUI] environmentMessage', environmentMessage);\n\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, environmentMessage],\n    };\n  });\n  // 检查是否包含图片内容并直接设置为活动面板内容\n  if (Array.isArray(event.content)) {\n    const imageContent = event.content.find(\n      (item) => item.type === 'image_url' && item.image_url && item.image_url.url,\n    ) as ChatCompletionContentPartImage;\n\n    if (imageContent && imageContent.image_url) {\n      set(activePanelContentAtom, (prev) => {\n        console.log('[GUI] prev', prev?.type);\n        // 如果当前面板是来自 browser_vision_control，选择增强而不是替换\n        if (prev && prev.type === 'browser_vision_control') {\n          return {\n            ...prev,\n            type: 'browser_vision_control',\n            source: event.content,\n            title: `${prev.title} - New Screenshot`,\n            timestamp: event.timestamp,\n            originalContent: prev.source, // 保存原始环境内容\n          };\n        } else {\n          console.log('[GUI] prev', 111);\n          // 否则使用标准处理方式\n          return {\n            type: 'image',\n            source: event.content,\n            title: event.description || 'Browser Screenshot',\n            timestamp: event.timestamp,\n            environmentId: event.id, // 添加标识，用于browser_vision_control增量更新\n          };\n        }\n      });\n    }\n  }\n}\n\n/**\n * Handle plan start event\n */\nfunction handlePlanStart(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.PlanStartEvent,\n): void {\n  console.log('Plan start event:', event);\n  set(plansAtom, (prev: Record<string, any>) => ({\n    ...prev,\n    [sessionId]: {\n      steps: [],\n      isComplete: false,\n      summary: null,\n      hasGeneratedPlan: true,\n      keyframes: [], // Initialize empty keyframes array\n    },\n  }));\n}\n\n/**\n * Handle plan update event\n */\nfunction handlePlanUpdate(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.PlanUpdateEvent,\n): void {\n  console.log('Plan update event:', event);\n  set(plansAtom, (prev: Record<string, any>) => {\n    const currentPlan = prev[sessionId] || {\n      steps: [],\n      isComplete: false,\n      summary: null,\n      hasGeneratedPlan: true,\n      keyframes: [],\n    };\n\n    // Create a new keyframe for this update\n    const newKeyframe: PlanKeyframe = {\n      timestamp: event.timestamp || Date.now(),\n      steps: event.steps,\n      isComplete: false,\n      summary: null,\n    };\n\n    // Add the keyframe to the history\n    const keyframes = [...(currentPlan.keyframes || []), newKeyframe];\n\n    return {\n      ...prev,\n      [sessionId]: {\n        ...currentPlan,\n        steps: event.steps,\n        hasGeneratedPlan: true,\n        keyframes,\n      },\n    };\n  });\n}\n\n/**\n * Handle plan finish event\n */\nfunction handlePlanFinish(\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.Event & { sessionId: string; summary: string },\n): void {\n  console.log('Plan finish event:', event);\n  set(plansAtom, (prev: Record<string, any>) => {\n    const currentPlan = prev[sessionId] || {\n      steps: [],\n      isComplete: false,\n      summary: null,\n      hasGeneratedPlan: true,\n      keyframes: [],\n    };\n\n    // Create a final keyframe for the completed plan\n    const finalKeyframe: PlanKeyframe = {\n      timestamp: event.timestamp || Date.now(),\n      steps: currentPlan.steps,\n      isComplete: true,\n      summary: event.summary,\n    };\n\n    // Add the final keyframe to the history\n    const keyframes = [...(currentPlan.keyframes || []), finalKeyframe];\n\n    return {\n      ...prev,\n      [sessionId]: {\n        ...currentPlan,\n        isComplete: true,\n        summary: event.summary,\n        keyframes,\n      },\n    };\n  });\n}\n\n/**\n * Handle final answer event (complete answer/report)\n */\nfunction handleFinalAnswer(\n  get: any,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.FinalAnswerEvent,\n): void {\n  const messageId = event.messageId || `final-answer-${uuidv4()}`;\n\n  // 始终将内容当作研究报告处理，移除JSON_DATA状态\n  // 设置活动面板内容为研究报告\n  set(activePanelContentAtom, {\n    type: 'research_report',\n    source: event.content,\n    title: event.title || 'Research Report',\n    timestamp: event.timestamp,\n    isDeepResearch: true,\n    messageId,\n  });\n\n  // 添加消息到聊天引用报告\n  const finalAnswerMessage: Message = {\n    id: event.id || uuidv4(),\n    role: 'final_answer',\n    content: event.content, // 存储完整内容以便后续访问\n    timestamp: event.timestamp,\n    messageId,\n    isDeepResearch: true,\n    title: event.title || 'Research Report',\n  };\n\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, finalAnswerMessage],\n    };\n  });\n\n  // 标记处理完成\n  set(isProcessingAtom, false);\n}\n\nfunction handleFinalAnswerStreaming(\n  get: any,\n  set: Setter,\n  sessionId: string,\n  event: AgentEventStream.Event & {\n    content: string;\n    isDeepResearch: boolean;\n    isComplete?: boolean;\n    messageId?: string;\n    title?: string;\n  },\n): void {\n  const messageId = event.messageId || `final-answer-${uuidv4()}`;\n\n  // 从当前消息列表中查找已有的相同 messageId 的消息\n  const messages = get(messagesAtom)[sessionId] || [];\n  const existingMessageIndex = messages.findIndex((msg) => msg.messageId === messageId);\n\n  // 当处理一系列流式事件时，将内容追加到现有消息，或创建新消息\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n\n    // 如果找到现有消息，则更新它\n    if (existingMessageIndex >= 0) {\n      const existingMessage = sessionMessages[existingMessageIndex];\n      const updatedMessage = {\n        ...existingMessage,\n        content:\n          typeof existingMessage.content === 'string'\n            ? existingMessage.content + event.content\n            : event.content,\n        isStreaming: !event.isComplete,\n        timestamp: event.timestamp,\n      };\n\n      return {\n        ...prev,\n        [sessionId]: [\n          ...sessionMessages.slice(0, existingMessageIndex),\n          updatedMessage,\n          ...sessionMessages.slice(existingMessageIndex + 1),\n        ],\n      };\n    }\n\n    // 否则创建新消息\n    const newMessage: Message = {\n      id: event.id || uuidv4(),\n      role: 'final_answer',\n      content: event.content,\n      timestamp: event.timestamp,\n      messageId,\n      isDeepResearch: true,\n      isStreaming: !event.isComplete,\n      title: event.title || 'Research Report',\n    };\n\n    return {\n      ...prev,\n      [sessionId]: [...sessionMessages, newMessage],\n    };\n  });\n\n  // 更新活动面板内容 - 同步面板与消息状态\n  set(activePanelContentAtom, (prev: any) => {\n    // 如果是新流或不同的messageId，重新开始\n    if (!prev || prev.type !== 'research_report' || prev.messageId !== messageId) {\n      return {\n        role: 'assistant',\n        type: 'research_report',\n        source: event.content,\n        title: event.title || 'Research Report (Generating...)',\n        timestamp: event.timestamp,\n        isDeepResearch: true,\n        messageId,\n        isStreaming: !event.isComplete,\n      };\n    }\n\n    // 否则追加到现有内容\n    return {\n      ...prev,\n      source: prev.source + event.content,\n      isStreaming: !event.isComplete,\n      timestamp: event.timestamp,\n      title: event.title || prev.title,\n    };\n  });\n\n  // 如果这是第一个数据块，也添加一条消息到聊天\n  const prevActivePanelContent = get(activePanelContentAtom);\n  if (!prevActivePanelContent || prevActivePanelContent.messageId !== messageId) {\n    const initialMessage: Message = {\n      id: event.id || uuidv4(),\n      role: 'final_answer',\n      content: event.content, // 存储初始内容\n      timestamp: event.timestamp,\n      messageId,\n      isDeepResearch: true,\n      isStreaming: !event.isComplete,\n      title: event.title || 'Research Report',\n    };\n\n    set(messagesAtom, (prev: Record<string, Message[]>) => {\n      const sessionMessages = prev[sessionId] || [];\n      return {\n        ...prev,\n        [sessionId]: [...sessionMessages, initialMessage],\n      };\n    });\n  } else if (event.isComplete) {\n    // 当流式生成完成时，更新消息的完整内容\n    const fullContent = get(activePanelContentAtom).source;\n\n    set(messagesAtom, (prev: Record<string, Message[]>) => {\n      const sessionMessages = prev[sessionId] || [];\n      const messageIndex = sessionMessages.findIndex((msg) => msg.messageId === messageId);\n\n      if (messageIndex >= 0) {\n        const updatedMessages = [...sessionMessages];\n        updatedMessages[messageIndex] = {\n          ...updatedMessages[messageIndex],\n          content: fullContent,\n          isStreaming: false,\n          title: event.title || updatedMessages[messageIndex].title || 'Research Report',\n        };\n\n        return {\n          ...prev,\n          [sessionId]: updatedMessages,\n        };\n      }\n\n      return prev;\n    });\n  }\n\n  // 如果这是最后一个数据块，标记处理完成\n  if (event.isComplete) {\n    set(isProcessingAtom, false);\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACvBA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;;AAEA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AAGA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAOA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AASA;AACA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;;;AAGA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAYA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA"}