"use strict";
self["webpackHotUpdate_agent_tars_web_ui"]("index", {
"./src/entry.css": (function (module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
// extracted by css-extract-rspack-plugin

    if(true) {
      (function() {
        var localsJsonString = undefined;
        // 1751956941375
        var cssReload = (__webpack_require__("../node_modules/.pnpm/@rspack+core@1.3.9_@swc+helpers@0.5.17/node_modules/@rspack/core/dist/cssExtractHmr.js")/* .cssReload */.cssReload)(module.id, {});
        // only invalidate when locals change
        if (
          module.hot.data &&
          module.hot.data.value &&
          module.hot.data.value !== localsJsonString
        ) {
          module.hot.invalidate();
        } else {
          module.hot.accept();
        }
        module.hot.dispose(function(data) {
          data.value = localsJsonString;
          cssReload();
        });
      })();
    }
  

}),
"./src/common/constants/index.ts": (function (module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  API_BASE_URL: () => (API_BASE_URL),
  API_ENDPOINTS: () => (API_ENDPOINTS),
  CONNECTION_SETTINGS: () => (CONNECTION_SETTINGS),
  MESSAGE_ROLES: () => (MESSAGE_ROLES),
  SOCKET_EVENTS: () => (SOCKET_EVENTS),
  STORAGE_KEYS: () => (STORAGE_KEYS),
  TOOL_CATEGORIES: () => (/* reexport safe */ _toolTypes__WEBPACK_IMPORTED_MODULE_0__.TOOL_CATEGORIES),
  TOOL_NAMES: () => (/* reexport safe */ _toolTypes__WEBPACK_IMPORTED_MODULE_0__.TOOL_NAMES),
  TOOL_NAME_TO_CATEGORY_MAP: () => (/* reexport safe */ _toolTypes__WEBPACK_IMPORTED_MODULE_0__.TOOL_NAME_TO_CATEGORY_MAP),
  TOOL_TYPES: () => (/* reexport safe */ _toolTypes__WEBPACK_IMPORTED_MODULE_0__.TOOL_TYPES),
  getToolCategory: () => (/* reexport safe */ _toolTypes__WEBPACK_IMPORTED_MODULE_0__.getToolCategory)
});
/* ESM import */var _toolTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/common/constants/toolTypes.ts");
/* provided dependency */ var $ReactRefreshRuntime$ = __webpack_require__("../node_modules/.pnpm/@rspack+plugin-react-refresh@1.0.3_react-refresh@0.16.0/node_modules/@rspack/plugin-react-refresh/client/reactRefresh.js");
/**
 * Base API URL for server communication
 */ const API_BASE_URL = window.AGENT_TARS_BASE_URL ?? 'http://localhost:3000';
/**
 * Default API endpoints
 */ const API_ENDPOINTS = {
    SESSIONS: '/api/v1/sessions',
    CREATE_SESSION: '/api/v1/sessions/create',
    SESSION_DETAILS: '/api/v1/sessions/details',
    SESSION_EVENTS: '/api/v1/sessions/events',
    SESSION_STATUS: '/api/v1/sessions/status',
    UPDATE_SESSION: '/api/v1/sessions/update',
    DELETE_SESSION: '/api/v1/sessions/delete',
    QUERY: '/api/v1/sessions/query',
    QUERY_STREAM: '/api/v1/sessions/query/stream',
    ABORT: '/api/v1/sessions/abort',
    GENERATE_SUMMARY: '/api/v1/sessions/generate-summary',
    HEALTH: '/api/v1/health',
    BROWSER_CONTROL_INFO: '/api/v1/sessions/browser-control',
    // Share endpoints
    SHARE_CONFIG: '/api/v1/share/config',
    SESSIONS_SHARE: '/api/v1/sessions/share'
};
/**
 * WebSocket events
 */ const SOCKET_EVENTS = {
    CONNECT: 'connect',
    DISCONNECT: 'disconnect',
    ERROR: 'error',
    RECONNECT_ATTEMPT: 'reconnect_attempt',
    RECONNECT_FAILED: 'reconnect_failed',
    JOIN_SESSION: 'join-session',
    AGENT_EVENT: 'agent-event',
    AGENT_STATUS: 'agent-status',
    PING: 'ping',
    SEND_QUERY: 'send-query',
    ABORT_QUERY: 'abort-query'
};
/**
 * Local storage keys
 */ const STORAGE_KEYS = {
    ACTIVE_SESSION: 'agent-tars-active-session',
    THEME: 'agent-tars-theme'
};
/**
 * Message roles
 */ const MESSAGE_ROLES = {
    USER: 'user',
    ASSISTANT: 'assistant',
    SYSTEM: 'system',
    TOOL: 'tool'
};
/**
 * Connection settings
 */ const CONNECTION_SETTINGS = {
    HEARTBEAT_INTERVAL: 15000,
    MAX_MISSED_HEARTBEATS: 2,
    MAX_RECONNECT_ATTEMPTS: 5,
    RECONNECTION_DELAY: 1000,
    RECONNECTION_DELAY_MAX: 5000
};


function $RefreshSig$() {
  return $ReactRefreshRuntime$.createSignatureFunctionForTransform();
}
function $RefreshReg$(type, id) {
  $ReactRefreshRuntime$.register(type, module.id + "_" + id);
}
Promise.resolve().then(function() {
  $ReactRefreshRuntime$.refresh(module.id, module.hot);
});


}),
"./src/common/services/apiService.ts": (function (module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  apiService: () => (apiService)
});
/* ESM import */var _common_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/common/constants/index.ts");
/* ESM import */var _socketService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/common/services/socketService.ts");
/* provided dependency */ var $ReactRefreshRuntime$ = __webpack_require__("../node_modules/.pnpm/@rspack+plugin-react-refresh@1.0.3_react-refresh@0.16.0/node_modules/@rspack/plugin-react-refresh/client/reactRefresh.js");


/**
 * API Service - Handles HTTP requests to the Agent TARS Server
 *
 * Provides methods for:
 * - Session management (create, get, update, delete)
 * - Query execution (streaming and non-streaming)
 * - Server health checks
 */ class ApiService {
    /**
   * Check server health status
   */ async checkServerHealth() {
        try {
            // Try ping through socket if connected
            if (_socketService__WEBPACK_IMPORTED_MODULE_1__.socketService.isConnected()) {
                const pingSuccessful = await _socketService__WEBPACK_IMPORTED_MODULE_1__.socketService.ping();
                if (pingSuccessful) return true;
            }
            // Fall back to API health endpoint
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.HEALTH}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                },
                signal: AbortSignal.timeout(3000)
            });
            return response.ok;
        } catch (error) {
            console.error('Error checking server health:', error);
            return false;
        }
    }
    /**
   * Create a new session
   */ async createSession() {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.CREATE_SESSION}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            if (!response.ok) {
                throw new Error(`Failed to create session: ${response.statusText}`);
            }
            const { sessionId } = await response.json();
            return this.getSessionDetails(sessionId);
        } catch (error) {
            console.error('Error creating session:', error);
            throw error;
        }
    }
    /**
   * Get all sessions
   */ async getSessions() {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.SESSIONS}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            if (!response.ok) {
                throw new Error(`Failed to get sessions: ${response.statusText}`);
            }
            const { sessions } = await response.json();
            return sessions;
        } catch (error) {
            console.error('Error getting sessions:', error);
            throw error;
        }
    }
    /**
   * Get details for a specific session
   */ async getSessionDetails(sessionId) {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.SESSION_DETAILS}?sessionId=${sessionId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                },
                signal: AbortSignal.timeout(5000)
            });
            if (!response.ok) {
                throw new Error(`Failed to get session details: ${response.statusText}`);
            }
            const { session } = await response.json();
            return session;
        } catch (error) {
            console.error(`Error getting session details (${sessionId}):`, error);
            throw error;
        }
    }
    /**
   * Get events for a specific session
   */ async getSessionEvents(sessionId) {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.SESSION_EVENTS}?sessionId=${sessionId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                },
                signal: AbortSignal.timeout(5000)
            });
            if (!response.ok) {
                throw new Error(`Failed to get session events: ${response.statusText}`);
            }
            const { events } = await response.json();
            return events;
        } catch (error) {
            console.error(`Error getting session events (${sessionId}):`, error);
            throw error;
        }
    }
    /**
   * Get current status of a session
   */ async getSessionStatus(sessionId) {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.SESSION_STATUS}?sessionId=${sessionId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                },
                signal: AbortSignal.timeout(3000)
            });
            if (!response.ok) {
                throw new Error(`Failed to get session status: ${response.statusText}`);
            }
            const { status } = await response.json();
            return status;
        } catch (error) {
            console.error(`Error getting session status (${sessionId}):`, error);
            throw error;
        }
    }
    /**
   * Update session metadata
   */ async updateSessionMetadata(sessionId, updates) {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.UPDATE_SESSION}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    sessionId,
                    ...updates
                })
            });
            if (!response.ok) {
                throw new Error(`Failed to update session: ${response.statusText}`);
            }
            const { session } = await response.json();
            return session;
        } catch (error) {
            console.error(`Error updating session (${sessionId}):`, error);
            throw error;
        }
    }
    /**
   * Delete a session
   */ async deleteSession(sessionId) {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.DELETE_SESSION}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    sessionId
                })
            });
            if (!response.ok) {
                throw new Error(`Failed to delete session: ${response.statusText}`);
            }
            const { success } = await response.json();
            return success;
        } catch (error) {
            console.error(`Error deleting session (${sessionId}):`, error);
            throw error;
        }
    }
    /**
   * Send a streaming query
   */ async sendStreamingQuery(sessionId, query, onEvent) {
        try {
            var _response_body;
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.QUERY_STREAM}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    sessionId,
                    query
                })
            });
            if (!response.ok) {
                throw new Error(`Failed to send query: ${response.statusText}`);
            }
            const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();
            if (!reader) {
                throw new Error('ReadableStream not supported');
            }
            const decoder = new TextDecoder();
            let buffer = '';
            while(true){
                const { done, value } = await reader.read();
                if (done) break;
                // Add the new chunk to the buffer
                buffer += decoder.decode(value, {
                    stream: true
                });
                // Process all complete events in the buffer
                let eventEndIndex;
                while((eventEndIndex = buffer.indexOf('\n\n')) !== -1){
                    const eventString = buffer.slice(0, eventEndIndex);
                    // Move buffer to the next event
                    buffer = buffer.slice(eventEndIndex + 2);
                    if (eventString.startsWith('data: ')) {
                        try {
                            const eventData = JSON.parse(eventString.substring(6));
                            onEvent(eventData);
                        } catch (e) {
                            console.error('Error parsing event data:', e);
                        }
                    }
                }
            }
        } catch (error) {
            console.error('Error in streaming query:', error);
            throw error;
        }
    }
    /**
   * Send a non-streaming query
   */ async sendQuery(sessionId, query) {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.QUERY}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    sessionId,
                    query
                })
            });
            if (!response.ok) {
                throw new Error(`Failed to send query: ${response.statusText}`);
            }
            const data = await response.json();
            return data.result;
        } catch (error) {
            console.error('Error sending query:', error);
            throw error;
        }
    }
    /**
   * Abort a running query
   */ async abortQuery(sessionId) {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.ABORT}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    sessionId
                })
            });
            if (!response.ok) {
                throw new Error(`Failed to abort query: ${response.statusText}`);
            }
            const data = await response.json();
            return data.success;
        } catch (error) {
            console.error('Error aborting query:', error);
            throw error;
        }
    }
    /**
   * Generate a summary for a conversation
   */ async generateSummary(sessionId, messages) {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.GENERATE_SUMMARY}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    sessionId,
                    messages
                })
            });
            if (!response.ok) {
                throw new Error(`Failed to generate summary: ${response.statusText}`);
            }
            const { summary } = await response.json();
            return summary;
        } catch (error) {
            console.error('Error generating summary:', error);
            return 'Untitled Conversation';
        }
    }
    /**
   * Get browser control information for a session
   */ async getBrowserControlInfo(sessionId) {
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.BROWSER_CONTROL_INFO}?sessionId=${sessionId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                },
                signal: AbortSignal.timeout(3000)
            });
            if (!response.ok) {
                throw new Error(`Failed to get browser control info: ${response.statusText}`);
            }
            return await response.json();
        } catch (error) {
            console.error(`Error getting browser control info (${sessionId}):`, error);
            // 返回默认值作为回退
            return {
                mode: 'default',
                tools: []
            };
        }
    }
}
// Export singleton instance
const apiService = new ApiService();

function $RefreshSig$() {
  return $ReactRefreshRuntime$.createSignatureFunctionForTransform();
}
function $RefreshReg$(type, id) {
  $ReactRefreshRuntime$.register(type, module.id + "_" + id);
}
Promise.resolve().then(function() {
  $ReactRefreshRuntime$.refresh(module.id, module.hot);
});


}),
"./src/standalone/share/shareService.ts": (function (module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  shareService: () => (shareService)
});
/* ESM import */var _swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("../node_modules/.pnpm/@swc+helpers@0.5.17/node_modules/@swc/helpers/esm/_define_property.js");
/* ESM import */var _common_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/common/constants/index.ts");
/* provided dependency */ var $ReactRefreshRuntime$ = __webpack_require__("../node_modules/.pnpm/@rspack+plugin-react-refresh@1.0.3_react-refresh@0.16.0/node_modules/@rspack/plugin-react-refresh/client/reactRefresh.js");


/**
 * 分享服务类 - 处理分享相关功能
 */ class ShareService {
    /**
   * 获取分享配置
   */ async getShareConfig() {
        if (this.shareConfig) {
            return this.shareConfig;
        }
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.SHARE_CONFIG}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            if (!response.ok) {
                throw new Error(`Failed to get share config: ${response.statusText}`);
            }
            this.shareConfig = await response.json();
            return this.shareConfig;
        } catch (error) {
            console.error('Failed to get share config:', error);
            // 默认配置
            return {
                hasShareProvider: false,
                shareProvider: null
            };
        }
    }
    /**
   * 分享会话
   * @param sessionId 会话ID
   * @param upload 是否上传到分享提供者（如果存在）
   */ async shareSession(sessionId) {
        let upload = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        try {
            const response = await fetch(`${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL}${_common_constants__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.SESSIONS_SHARE}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    sessionId,
                    upload
                })
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `Failed to share session: ${response.statusText}`);
            }
            return await response.json();
        } catch (error) {
            console.error('Failed to share session:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error)
            };
        }
    }
    /**
   * 下载 HTML 分享文件
   * @param html HTML 内容
   * @param sessionId 会话ID
   */ downloadShareHtml(html, sessionId) {
        const blob = new Blob([
            html
        ], {
            type: 'text/html'
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `agent-tars-${sessionId}-${Date.now()}.html`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
    constructor(){
        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_1__._)(this, "shareConfig", null);
    }
}
const shareService = new ShareService();

function $RefreshSig$() {
  return $ReactRefreshRuntime$.createSignatureFunctionForTransform();
}
function $RefreshReg$(type, id) {
  $ReactRefreshRuntime$.register(type, module.id + "_" + id);
}
Promise.resolve().then(function() {
  $ReactRefreshRuntime$.refresh(module.id, module.hot);
});


}),

},function(__webpack_require__) {
// webpack/runtime/get_full_hash
(() => {
__webpack_require__.h = () => ("c671417bde0f1042")
})();

}
);
//# sourceMappingURL=index.0e2f2698a8d922be.hot-update.js.map