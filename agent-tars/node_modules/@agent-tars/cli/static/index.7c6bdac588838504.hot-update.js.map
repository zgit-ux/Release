{"version":3,"file":"index.7c6bdac588838504.hot-update.js","sources":["/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/entry.css","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/v2/hooks/useReplay.ts","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/v2/state/actions/eventProcessor.ts","/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/agent-tars-web-ui/src/v2/state/actions/sessionActions.ts"],"sourcesContent":["// extracted by css-extract-rspack-plugin\nexport {};\n    if(module.hot) {\n      (function() {\n        var localsJsonString = undefined;\n        // 1749610703351\n        var cssReload = require(\"../../node_modules/.pnpm/@rspack+core@1.3.9_@swc+helpers@0.5.17/node_modules/@rspack/core/dist/cssExtractHmr.js\").cssReload(module.id, {});\n        // only invalidate when locals change\n        if (\n          module.hot.data &&\n          module.hot.data.value &&\n          module.hot.data.value !== localsJsonString\n        ) {\n          module.hot.invalidate();\n        } else {\n          module.hot.accept();\n        }\n        module.hot.dispose(function(data) {\n          data.value = localsJsonString;\n          cssReload();\n        });\n      })();\n    }\n  ","// /agent-tars-web-ui/src/v2/hooks/useReplay.ts\nimport { useAtom } from 'jotai';\nimport { useCallback, useEffect, useState } from 'react';\nimport { replayStateAtom } from '../state/atoms/replay';\nimport { AgentEventStream } from '../types';\nimport { useSession } from './useSession';\nimport { messagesAtom } from '../state/atoms/message';\nimport { toolResultsAtom } from '../state/atoms/tool';\nimport { processEventAction } from '../state/actions/eventProcessor';\nimport { atom, useSetAtom } from 'jotai';\nimport { plansAtom } from '../state/atoms/plan';\n\n/**\n * Custom hook for managing replay functionality\n *\n * Provides:\n * - Control for playback (play, pause, jump, etc.)\n * - Event processing through the standard event processor\n * - Timeline calculations and positioning\n */\nexport function useReplay() {\n  const [replayState, setReplayState] = useAtom(replayStateAtom);\n  const { activeSessionId } = useSession();\n  const [playbackInterval, setPlaybackInterval] = useState<NodeJS.Timeout | null>(null);\n  const [, setMessages] = useAtom(messagesAtom);\n  const [, setToolResults] = useAtom(toolResultsAtom);\n  const [, setPlans] = useAtom(plansAtom);\n  const processEvent = useSetAtom(processEventAction);\n\n  /**\n   * 重置会话状态并处理事件至指定索引\n   */\n  const processEventsUpToIndex = useCallback(\n    (targetIndex: number) => {\n      if (!activeSessionId || !replayState.events.length || targetIndex < 0) return;\n\n      // 获取需要处理的事件\n      const eventsToProcess = replayState.events.slice(0, targetIndex + 1);\n\n      // 清空当前会话状态\n      setMessages((prev) => ({\n        ...prev,\n        [activeSessionId]: [],\n      }));\n\n      setToolResults((prev) => ({\n        ...prev,\n        [activeSessionId]: [],\n      }));\n\n      setPlans((prev) => ({\n        ...prev,\n        [activeSessionId]: {\n          steps: [],\n          isComplete: false,\n          summary: null,\n          hasGeneratedPlan: false,\n          keyframes: [],\n        },\n      }));\n\n      // 处理环境输入事件优先，确保图片资源先加载\n      const envEvents = eventsToProcess.filter((event) => event.type === 'environment_input');\n      const nonEnvEvents = eventsToProcess.filter((event) => event.type !== 'environment_input');\n\n      // 先处理环境输入事件\n      for (const event of envEvents) {\n        processEvent({ sessionId: activeSessionId, event });\n      }\n\n      // 然后处理其他事件\n      for (const event of nonEnvEvents) {\n        processEvent({ sessionId: activeSessionId, event });\n      }\n    },\n    [activeSessionId, replayState.events, setMessages, setToolResults, setPlans, processEvent],\n  );\n\n  /**\n   * 开始回放\n   */\n  const startReplay = useCallback(() => {\n    // 清除现有的定时器\n    if (playbackInterval) {\n      clearInterval(playbackInterval);\n    }\n\n    setReplayState((prev) => ({\n      ...prev,\n      isPaused: false,\n    }));\n\n    // 设置定时器按间隔前进\n    const interval = setInterval(() => {\n      setReplayState((prev) => {\n        // 到达末尾时停止\n        if (prev.currentEventIndex >= prev.events.length - 1) {\n          clearInterval(interval);\n          return {\n            ...prev,\n            isPaused: true,\n            currentEventIndex: prev.events.length - 1,\n          };\n        }\n\n        // 前进到下一个事件\n        const nextIndex = prev.currentEventIndex + 1;\n\n        // 处理到新位置\n        if (activeSessionId) {\n          processEvent({\n            sessionId: activeSessionId,\n            event: prev.events[nextIndex],\n          });\n        }\n\n        return {\n          ...prev,\n          currentEventIndex: nextIndex,\n        };\n      });\n    }, 500 / replayState.playbackSpeed);\n\n    setPlaybackInterval(interval);\n  }, [activeSessionId, playbackInterval, processEvent, replayState.playbackSpeed, setReplayState]);\n\n  /**\n   * 暂停回放\n   */\n  const pauseReplay = useCallback(() => {\n    if (playbackInterval) {\n      clearInterval(playbackInterval);\n      setPlaybackInterval(null);\n    }\n\n    setReplayState((prev) => ({\n      ...prev,\n      isPaused: true,\n    }));\n  }, [playbackInterval, setReplayState]);\n\n  /**\n   * 跳转到时间轴上的指定位置\n   */\n  const jumpToPosition = useCallback(\n    (position: number) => {\n      // 确保位置在有效范围内\n      const normalizedPosition = Math.max(0, Math.min(1, position));\n\n      if (replayState.events.length === 0 || !activeSessionId) return;\n\n      // 根据位置计算目标事件索引\n      const targetIndex = Math.floor(normalizedPosition * (replayState.events.length - 1));\n\n      // 暂停任何正在进行的回放\n      if (playbackInterval) {\n        clearInterval(playbackInterval);\n        setPlaybackInterval(null);\n      }\n\n      // 处理到新位置\n      processEventsUpToIndex(targetIndex);\n\n      setReplayState((prev) => ({\n        ...prev,\n        isPaused: true,\n        currentEventIndex: targetIndex,\n      }));\n    },\n    [\n      activeSessionId,\n      playbackInterval,\n      processEventsUpToIndex,\n      replayState.events.length,\n      setReplayState,\n    ],\n  );\n\n  /**\n   * 跳转到最终结果\n   */\n  const jumpToResult = useCallback(() => {\n    if (replayState.events.length === 0 || !activeSessionId) return;\n\n    const finalIndex = replayState.events.length - 1;\n\n    // 暂停任何正在进行的回放\n    if (playbackInterval) {\n      clearInterval(playbackInterval);\n      setPlaybackInterval(null);\n    }\n\n    // 处理到最终位置\n    processEventsUpToIndex(finalIndex);\n\n    setReplayState((prev) => ({\n      ...prev,\n      isPaused: true,\n      currentEventIndex: finalIndex,\n    }));\n  }, [\n    activeSessionId,\n    playbackInterval,\n    processEventsUpToIndex,\n    replayState.events.length,\n    setReplayState,\n  ]);\n\n  /**\n   * 设置播放速度\n   */\n  const setPlaybackSpeed = useCallback(\n    (speed: number) => {\n      setReplayState((prev) => ({\n        ...prev,\n        playbackSpeed: speed,\n      }));\n\n      // 如果正在播放，以新速度重启\n      if (!replayState.isPaused && playbackInterval) {\n        clearInterval(playbackInterval);\n        startReplay();\n      }\n    },\n    [playbackInterval, replayState.isPaused, setReplayState, startReplay],\n  );\n\n  /**\n   * 退出回放模式\n   */\n  const exitReplay = useCallback(() => {\n    if (playbackInterval) {\n      clearInterval(playbackInterval);\n    }\n\n    setReplayState((prev) => ({\n      ...prev,\n      isActive: false,\n      isPaused: true,\n      currentEventIndex: -1,\n      events: [],\n      processedEvents: {},\n    }));\n  }, [playbackInterval, setReplayState]);\n\n  /**\n   * 获取当前事件\n   */\n  const getCurrentEvent = useCallback(() => {\n    if (\n      !replayState.isActive ||\n      replayState.currentEventIndex < 0 ||\n      replayState.currentEventIndex >= replayState.events.length\n    ) {\n      return null;\n    }\n\n    return replayState.events[replayState.currentEventIndex];\n  }, [replayState.currentEventIndex, replayState.events, replayState.isActive]);\n\n  /**\n   * 获取当前位置百分比 (0-100)\n   */\n  const getCurrentPosition = useCallback(() => {\n    if (!replayState.isActive || replayState.events.length <= 1) {\n      return 0;\n    }\n\n    return (replayState.currentEventIndex / (replayState.events.length - 1)) * 100;\n  }, [replayState.currentEventIndex, replayState.events.length, replayState.isActive]);\n\n  /**\n   * 获取当前所有事件\n   */\n  const getCurrentEvents = useCallback(() => {\n    if (!replayState.isActive || replayState.currentEventIndex < 0) {\n      return [];\n    }\n\n    return replayState.events.slice(0, replayState.currentEventIndex + 1);\n  }, [replayState.currentEventIndex, replayState.events, replayState.isActive]);\n\n  // 组件卸载时清理定时器\n  useEffect(() => {\n    return () => {\n      if (playbackInterval) {\n        clearInterval(playbackInterval);\n      }\n    };\n  }, [playbackInterval]);\n\n  // 回放模式初始化时：如果索引为-1，需要手动触发第一步，否则会显示为空白\n  useEffect(() => {\n    if (\n      replayState.isActive &&\n      replayState.currentEventIndex === -1 &&\n      replayState.events.length > 0\n    ) {\n      // 如果启动回放后立即跳到第一个事件\n      processEventsUpToIndex(0);\n      setReplayState((prev) => ({\n        ...prev,\n        currentEventIndex: 0,\n      }));\n    }\n  }, [\n    replayState.isActive,\n    replayState.currentEventIndex,\n    replayState.events.length,\n    processEventsUpToIndex,\n    setReplayState,\n  ]);\n\n  /**\n   * 取消自动播放倒计时\n   */\n  const cancelAutoPlay = useCallback(() => {\n    setReplayState((prev) => ({\n      ...prev,\n      autoPlayCountdown: null,\n    }));\n  }, [setReplayState]);\n\n  // 添加对自动播放事件的监听\n  useEffect(() => {\n    const handleAutoStart = () => {\n      console.log('Auto-play event received, starting replay...');\n      startReplay();\n    };\n\n    // 添加事件监听器\n    window.addEventListener('replay-autostart', handleAutoStart);\n\n    // 清理函数\n    return () => {\n      window.removeEventListener('replay-autostart', handleAutoStart);\n    };\n  }, [startReplay]); // 依赖于startReplay函数\n\n  return {\n    // 状态\n    replayState,\n\n    // 操作方法\n    startReplay,\n    pauseReplay,\n    jumpToPosition,\n    jumpToResult,\n    setPlaybackSpeed,\n    exitReplay,\n    cancelAutoPlay,\n\n    // 工具方法\n    getCurrentEvents,\n    getCurrentPosition,\n    getCurrentEvent,\n  };\n}\n","function handleToolResult(set: Setter, sessionId: string, event: AgentEventStream.ToolResultEvent) {\n  // 获取之前存储的参数信息\n  const args = toolCallArgumentsMap.get(event.toolCallId);\n\n  const result: ToolResult = {\n    id: uuidv4(),\n    toolCallId: event.toolCallId,\n    name: event.name,\n    content: event.content,\n    timestamp: event.timestamp,\n    error: event.error,\n    type: determineToolType(event.name, event.content),\n    arguments: args,\n  };\n\n  // 1. 先更新消息atom和工具结果 - 确保chat UI能立即响应\n  set(messagesAtom, (prev: Record<string, Message[]>) => {\n    const sessionMessages = prev[sessionId] || [];\n\n    // 找到对应的消息并添加toolResults\n    const messageIndex = [...sessionMessages]\n      .reverse()\n      .findIndex((m) => m.toolCalls?.some((tc) => tc.id === result.toolCallId));\n\n    if (messageIndex !== -1) {\n      const actualIndex = sessionMessages.length - 1 - messageIndex;\n      const message = sessionMessages[actualIndex];\n      const toolResults = message.toolResults || [];\n\n      // 如果是 browser_vision_control，尝试添加关联的 environmentId\n      if (result.type === 'browser_vision_control') {\n        // 查找最近的环境输入 ID\n        for (let i = sessionMessages.length - 1; i >= 0; i--) {\n          const msg = sessionMessages[i];\n          if (msg.role === 'environment' && Array.isArray(msg.content)) {\n            const hasImage = msg.content.some(\n              item => item.type === 'image_url' && item.image_url && item.image_url.url\n            );\n            if (hasImage) {\n              result.environmentId = msg.id;\n              break;\n            }\n          }\n        }\n      }\n\n      const updatedMessage = {\n        ...message,\n        toolResults: [...toolResults, result],\n      };\n\n      return {\n        ...prev,\n        [sessionId]: [\n          ...sessionMessages.slice(0, actualIndex),\n          updatedMessage,\n          ...sessionMessages.slice(actualIndex + 1),\n        ],\n      };\n    }\n\n    return prev;\n  });\n\n  // 2. 同时更新工具结果atom\n  set(toolResultsAtom, (prev: Record<string, ToolResult[]>) => {\n    const sessionResults = prev[sessionId] || [];\n    return {\n      ...prev,\n      [sessionId]: [...sessionResults, result],\n    };\n  });\n\n  // 3. 查找关联的环境输入ID (如果上面没有找到)\n  if (result.type === 'browser_vision_control' && !result.environmentId) {\n    set(messagesAtom, (prev: Record<string, Message[]>) => {\n      const sessionMessages = prev[sessionId] || [];\n      // 从后往前找最近的环境输入\n      for (let i = sessionMessages.length - 1; i >= 0; i--) {\n        const msg = sessionMessages[i];\n        if (msg.role === 'environment' && Array.isArray(msg.content)) {\n          const hasImage = msg.content.some(\n            item => item.type === 'image_url' && item.image_url && item.image_url.url\n          );\n          if (hasImage) {\n            result.environmentId = msg.id;\n            break;\n          }\n        }\n      }\n      return prev; // 不修改状态，只是查找\n    });\n  }\n\n  // 4. 最后更新workspace面板内容 - 保持时序一致\n  if (result.type === 'browser_vision_control') {\n    set(activePanelContentAtom, (prev) => {\n      if (prev && prev.type === 'image' && prev.environmentId) {\n        return {\n          ...prev,\n          type: 'browser_vision_control',\n          source: event.content,\n          title: prev.title,\n          timestamp: event.timestamp,\n          toolCallId: event.toolCallId,\n          error: event.error,\n          arguments: args,\n          originalContent: prev.source,\n          environmentId: prev.environmentId,\n        };\n      } else {\n        return {\n          type: result.type,\n          source: result.content,\n          title: result.name,\n          timestamp: result.timestamp,\n          toolCallId: result.toolCallId,\n          error: result.error,\n          arguments: args,\n          environmentId: result.environmentId, // 包含找到的环境ID\n        };\n      }\n    });\n  } else {\n    set(activePanelContentAtom, {\n      type: result.type,\n      source: result.content,\n      title: result.name,\n      timestamp: result.timestamp,\n      toolCallId: result.toolCallId,\n      error: result.error,\n      arguments: args,\n    });\n  }\n\n  // Store in the map for future reference\n  toolCallResultMap.set(result.toolCallId, result);\n}\n","import { atom } from 'jotai';\nimport { v4 as uuidv4 } from 'uuid';\nimport { apiService } from '../../services/apiService';\nimport { sessionsAtom, activeSessionIdAtom } from '../atoms/session';\nimport { messagesAtom } from '../atoms/message';\nimport { toolResultsAtom, toolCallResultMap } from '../atoms/tool';\nimport { isProcessingAtom, activePanelContentAtom } from '../atoms/ui';\nimport { processEventAction } from './eventProcessor';\nimport { Message } from '../../types';\nimport { connectionStatusAtom } from '../atoms/ui';\nimport { replayStateAtom } from '../atoms/replay';\nimport { ChatCompletionContentPart, AgentEventStream } from '@multimodal/agent-interface';\n\n/**\n * Load all available sessions\n */\nexport const loadSessionsAction = atom(null, async (get, set) => {\n  try {\n    const loadedSessions = await apiService.getSessions();\n    set(sessionsAtom, loadedSessions);\n  } catch (error) {\n    console.error('Failed to load sessions:', error);\n    throw error;\n  }\n});\n\n/**\n * Create a new session\n */\nexport const createSessionAction = atom(null, async (get, set) => {\n  try {\n    const newSession = await apiService.createSession();\n\n    // Add to sessions list\n    set(sessionsAtom, (prev) => [newSession, ...prev]);\n\n    // Initialize session data\n    set(messagesAtom, (prev) => ({\n      ...prev,\n      [newSession.id]: [],\n    }));\n\n    set(toolResultsAtom, (prev) => ({\n      ...prev,\n      [newSession.id]: [],\n    }));\n\n    // Clear workspace panel content to show empty state\n    set(activePanelContentAtom, null);\n\n    // Set as active session\n    set(activeSessionIdAtom, newSession.id);\n\n    return newSession.id;\n  } catch (error) {\n    console.error('Failed to create session:', error);\n    throw error;\n  }\n});\n\n/**\n * Set the active session\n * 简化加载逻辑，移除恢复会话的复杂性\n */\nexport const setActiveSessionAction = atom(null, async (get, set, sessionId: string) => {\n  try {\n    // 检查是否已经是活动会话\n    const currentActiveSessionId = get(activeSessionIdAtom);\n    if (currentActiveSessionId === sessionId) {\n      console.log(`Session ${sessionId} is already active, skipping load`);\n      return;\n    }\n\n    // 检查回放状态并退出回放模式（除非是同一会话）\n    const replayState = get(replayStateAtom);\n    if (replayState.isActive) {\n      console.log('Exiting replay mode due to session change');\n      set(replayStateAtom, {\n        isActive: false,\n        isPaused: true,\n        events: [],\n        currentEventIndex: -1,\n        startTimestamp: null,\n        endTimestamp: null,\n        playbackSpeed: 1,\n        visibleTimeWindow: null,\n        processedEvents: {},\n      });\n    }\n\n    // 直接获取会话详情，不需要检查 active 状态\n    const sessionDetails = await apiService.getSessionDetails(sessionId);\n\n    // 获取当前会话状态以更新 isProcessing 状态\n    try {\n      const status = await apiService.getSessionStatus(sessionId);\n      set(isProcessingAtom, status.isProcessing);\n    } catch (error) {\n      console.warn('Failed to get session status:', error);\n      set(isProcessingAtom, false);\n    }\n\n    // 清理工具调用映射缓存\n    toolCallResultMap.clear();\n\n    // 只有在消息不存在时才加载会话事件\n    const messages = get(messagesAtom);\n    if (!messages[sessionId] || messages[sessionId].length === 0) {\n      console.log(`Loading events for session ${sessionId}`);\n      const events = await apiService.getSessionEvents(sessionId);\n\n      // 对流式事件进行预处理，确保正确的连续性\n      const processedEvents = preprocessStreamingEvents(events);\n\n      // 处理每个事件以构建消息和工具结果\n      for (const event of processedEvents) {\n        set(processEventAction, { sessionId, event });\n      }\n    } else {\n      console.log(`Session ${sessionId} already has messages, skipping event loading`);\n    }\n\n    // 设置为活动会话\n    set(activeSessionIdAtom, sessionId);\n  } catch (error) {\n    console.error('Failed to set active session:', error);\n    set(connectionStatusAtom, (prev) => ({\n      ...prev,\n      connected: false,\n      lastError: error instanceof Error ? error.message : String(error),\n    }));\n    throw error;\n  }\n});\n\n/**\n * Update session metadata\n */\nexport const updateSessionAction = atom(\n  null,\n  async (get, set, params: { sessionId: string; updates: { name?: string; tags?: string[] } }) => {\n    const { sessionId, updates } = params;\n\n    try {\n      const updatedSession = await apiService.updateSessionMetadata(sessionId, updates);\n\n      // Update session in the list\n      set(sessionsAtom, (prev) =>\n        prev.map((session) =>\n          session.id === sessionId ? { ...session, ...updatedSession } : session,\n        ),\n      );\n\n      return updatedSession;\n    } catch (error) {\n      console.error('Failed to update session:', error);\n      throw error;\n    }\n  },\n);\n\n/**\n * 预处理事件，确保流式事件按正确顺序处理\n */\nfunction preprocessStreamingEvents(events: AgentEventStream.Event[]): AgentEventStream.Event[] {\n  // 对流式消息进行整理\n  const messageStreams: Record<string, AgentEventStream.Event[]> = {};\n\n  // 收集所有流式事件，按messageId分组\n  events.forEach((event) => {\n    if (event.type === 'final_answer_streaming' && 'messageId' in event) {\n      const messageId = event.messageId as string;\n      if (!messageStreams[messageId]) {\n        messageStreams[messageId] = [];\n      }\n      messageStreams[messageId].push(event);\n    }\n  });\n\n  // 返回预处理后的事件，确保流式事件以正确顺序处理\n  return events;\n}\n\n/**\n * Delete a session\n */\nexport const deleteSessionAction = atom(null, async (get, set, sessionId: string) => {\n  try {\n    const success = await apiService.deleteSession(sessionId);\n    const activeSessionId = get(activeSessionIdAtom);\n\n    if (success) {\n      // Remove from sessions list\n      set(sessionsAtom, (prev) => prev.filter((session) => session.id !== sessionId));\n\n      // Clear active session if it was deleted\n      if (activeSessionId === sessionId) {\n        set(activeSessionIdAtom, null);\n      }\n\n      // Clear session data\n      set(messagesAtom, (prev) => {\n        const newMessages = { ...prev };\n        delete newMessages[sessionId];\n        return newMessages;\n      });\n\n      set(toolResultsAtom, (prev) => {\n        const newResults = { ...prev };\n        delete newResults[sessionId];\n        return newResults;\n      });\n    }\n\n    return success;\n  } catch (error) {\n    console.error('Failed to delete session:', error);\n    throw error;\n  }\n});\n\n/**\n * Send a message in the current session\n */\nexport const sendMessageAction = atom(\n  null,\n  async (get, set, content: string | ChatCompletionContentPart[]) => {\n    const activeSessionId = get(activeSessionIdAtom);\n\n    if (!activeSessionId) {\n      throw new Error('No active session');\n    }\n\n    // 明确设置处理状态\n    set(isProcessingAtom, true);\n\n    // 添加用户消息到状态\n    const userMessage: Message = {\n      id: uuidv4(),\n      role: 'user',\n      content,\n      timestamp: Date.now(),\n    };\n\n    set(messagesAtom, (prev) => {\n      const sessionMessages = prev[activeSessionId] || [];\n      return {\n        ...prev,\n        [activeSessionId]: [...sessionMessages, userMessage],\n      };\n    });\n\n    // 立即更新会话名称，使用用户查询作为 Summary\n    // 这样即使后续更新失败也至少有一个基本的名称\n    try {\n      // 检查是否是第一条消息，如果是则直接用查询内容作为会话名称\n      const messages = get(messagesAtom)[activeSessionId] || [];\n      if (messages.length <= 2) {\n        // 算上刚刚添加的用户消息\n        let summary = '';\n        if (typeof content === 'string') {\n          summary = content.length > 50 ? content.substring(0, 47) + '...' : content;\n        } else {\n          // 从多模态内容中提取文本部分\n          const textPart = content.find((part) => part.type === 'text');\n          if (textPart && 'text' in textPart) {\n            summary =\n              textPart.text.length > 50 ? textPart.text.substring(0, 47) + '...' : textPart.text;\n          } else {\n            summary = 'Image message';\n          }\n        }\n\n        await apiService.updateSessionMetadata(activeSessionId, { name: summary });\n\n        // 更新 sessions atom\n        set(sessionsAtom, (prev) =>\n          prev.map((session) =>\n            session.id === activeSessionId ? { ...session, name: summary } : session,\n          ),\n        );\n      }\n    } catch (error) {\n      console.log('Failed to update initial summary, continuing anyway:', error);\n      // 错误不中断主流程\n    }\n\n    try {\n      // 使用流式查询\n      await apiService.sendStreamingQuery(activeSessionId, content, (event) => {\n        // 处理每个事件\n        set(processEventAction, { sessionId: activeSessionId, event });\n\n        // 确保状态保持为处理中，直到明确收到结束事件\n        if (event.type !== 'agent_run_end' && event.type !== 'assistant_message') {\n          set(isProcessingAtom, true);\n        }\n      });\n    } catch (error) {\n      console.error('Error sending message:', error);\n      // 错误时重置处理状态\n      set(isProcessingAtom, false);\n      throw error;\n    }\n  },\n);\n\n/**\n * Abort the current running query\n */\nexport const abortQueryAction = atom(null, async (get, set) => {\n  const activeSessionId = get(activeSessionIdAtom);\n\n  if (!activeSessionId) {\n    return false;\n  }\n\n  try {\n    const success = await apiService.abortQuery(activeSessionId);\n\n    if (success) {\n      set(isProcessingAtom, false);\n\n      // Add system message about abort\n      const abortMessage: Message = {\n        id: uuidv4(),\n        role: 'system',\n        content: 'The operation was aborted.',\n        timestamp: Date.now(),\n      };\n\n      set(messagesAtom, (prev) => {\n        const sessionMessages = prev[activeSessionId] || [];\n        return {\n          ...prev,\n          [activeSessionId]: [...sessionMessages, abortMessage],\n        };\n      });\n    }\n\n    return success;\n  } catch (error) {\n    console.error('Error aborting query:', error);\n    return false;\n  }\n});\n\n/**\n * Check the current status of a session\n */\nexport const checkSessionStatusAction = atom(null, async (get, set, sessionId: string) => {\n  if (!sessionId) return;\n\n  try {\n    console.log(`Checking status for session: ${sessionId}`);\n    const status = await apiService.getSessionStatus(sessionId);\n\n    console.log(`Status for session ${sessionId}:`, status);\n\n    // 根据服务器响应更新处理状态\n    set(isProcessingAtom, status.isProcessing);\n\n    return status;\n  } catch (error) {\n    console.error('Failed to check session status:', error);\n    // 错误时不更新处理状态，避免误报\n  }\n});\n\n/**\n * Handle the end of a conversation\n * 仍然保留此函数，但减少其重要性，避免更新失败带来的影响\n */\nasync function handleConversationEnd(get: any, set: any, sessionId: string): Promise<void> {\n  // 我们不再依赖这个函数来设置会话名称，但仍然保留它作为备份机制\n  const allMessages = get(messagesAtom)[sessionId] || [];\n\n  // 只在有足够的消息并且会话没有名称时才尝试生成摘要\n  const sessions = get(sessionsAtom);\n  const currentSession = sessions.find((s) => s.id === sessionId);\n\n  // 如果会话已经有名称，则不需要再生成\n  if (currentSession && currentSession.name) {\n    return;\n  }\n\n  // 只在有实际对话时才尝试生成摘要\n  if (allMessages.length > 1) {\n    try {\n      // 转换消息为 API 期望的格式\n      const apiMessages = allMessages.map((msg: Message) => ({\n        role: msg.role,\n        content: typeof msg.content === 'string' ? msg.content : 'multimodal content',\n      }));\n\n      // 生成摘要\n      const summary = await apiService.generateSummary(sessionId, apiMessages);\n\n      if (summary) {\n        // 更新会话名称\n        await apiService.updateSessionMetadata(sessionId, { name: summary });\n\n        // 更新 sessions atom\n        set(sessionsAtom, (prev: any[]) =>\n          prev.map((session) =>\n            session.id === sessionId ? { ...session, name: summary } : session,\n          ),\n        );\n      }\n    } catch (error) {\n      console.error('Failed to generate or update summary, continuing anyway:', error);\n      // 错误不影响主流程\n    }\n  }\n}"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAGA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAEA;AAKA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrWA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAIA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA"}