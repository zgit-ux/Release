/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    loadTarsConfig: ()=>loadTarsConfig,
    deepMerge: ()=>deepMerge,
    CONFIG_FILES: ()=>CONFIG_FILES
});
const config_loader_namespaceObject = require("@multimodal/config-loader");
const external_node_fetch_namespaceObject = require("node-fetch");
var external_node_fetch_default = /*#__PURE__*/ __webpack_require__.n(external_node_fetch_namespaceObject);
const index_js_namespaceObject = require("../utils/index.js");
const CONFIG_FILES = [
    'agent-tars.config.ts',
    'agent-tars.config.yml',
    'agent-tars.config.yaml',
    'agent-tars.config.json',
    'agent-tars.config.js'
];
async function loadRemoteConfig(url, isDebug = false) {
    try {
        if (isDebug) index_js_namespaceObject.logger.debug(`Loading remote config from: ${url}`);
        const response = await external_node_fetch_default()(url);
        if (!response.ok) throw new Error(`Failed to fetch remote config: ${response.statusText}`);
        const contentType = response.headers.get('content-type') || '';
        if (contentType.includes('application/json')) return await response.json();
        {
            console.warn(`Remote config has non-JSON content type: ${contentType}`);
            const text = await response.text();
            try {
                return JSON.parse(text);
            } catch (error) {
                throw new Error(`Failed to parse remote config as JSON: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    } catch (error) {
        console.error(`Error loading remote config from ${url}: ${error instanceof Error ? error.message : String(error)}`);
        return {};
    }
}
function isUrl(str) {
    try {
        new URL(str);
        return true;
    } catch  {
        return false;
    }
}
async function loadTarsConfig(configPaths, isDebug = false) {
    if (!configPaths || 0 === configPaths.length) try {
        const { content, filePath } = await (0, config_loader_namespaceObject.loadConfig)({
            cwd: process.cwd(),
            configFiles: CONFIG_FILES
        });
        if (filePath && isDebug) index_js_namespaceObject.logger.debug(`Loaded default config from: ${filePath}`);
        return content;
    } catch (err) {
        if (isDebug) index_js_namespaceObject.logger.debug(`Failed to load default configuration: ${err instanceof Error ? err.message : String(err)}`);
        return {};
    }
    let mergedConfig = {};
    for (const path of configPaths){
        let config = {};
        if (isUrl(path)) config = await loadRemoteConfig(path, isDebug);
        else try {
            const { content, filePath } = await (0, config_loader_namespaceObject.loadConfig)({
                cwd: process.cwd(),
                path
            });
            if (filePath && isDebug) index_js_namespaceObject.logger.debug(`Loaded config from: ${filePath}`);
            config = content;
        } catch (err) {
            console.error(`Failed to load configuration from ${path}: ${err instanceof Error ? err.message : String(err)}`);
            continue;
        }
        mergedConfig = deepMerge(mergedConfig, config);
    }
    return mergedConfig;
}
function deepMerge(target, source) {
    const output = {
        ...target
    };
    if (isObject(target) && isObject(source)) Object.keys(source).forEach((key)=>{
        if (isObject(source[key])) if (key in target) output[key] = deepMerge(target[key], source[key]);
        else Object.assign(output, {
            [key]: source[key]
        });
        else Object.assign(output, {
            [key]: source[key]
        });
    });
    return output;
}
function isObject(item) {
    return item && 'object' == typeof item && !Array.isArray(item);
}
exports.CONFIG_FILES = __webpack_exports__.CONFIG_FILES;
exports.deepMerge = __webpack_exports__.deepMerge;
exports.loadTarsConfig = __webpack_exports__.loadTarsConfig;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "CONFIG_FILES",
    "deepMerge",
    "loadTarsConfig"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
