/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
/*! For license information please see 943.js.LICENSE.txt */
"use strict";
exports.ids = [
    "943"
];
exports.modules = {
    "../node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/dist/js-yaml.mjs": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            default: ()=>__WEBPACK_DEFAULT_EXPORT__
        });
        /*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */ function isNothing(subject) {
            return null == subject;
        }
        function isObject(subject) {
            return 'object' == typeof subject && null !== subject;
        }
        function toArray(sequence) {
            if (Array.isArray(sequence)) return sequence;
            if (isNothing(sequence)) return [];
            return [
                sequence
            ];
        }
        function extend(target, source) {
            var index, length, key, sourceKeys;
            if (source) {
                sourceKeys = Object.keys(source);
                for(index = 0, length = sourceKeys.length; index < length; index += 1){
                    key = sourceKeys[index];
                    target[key] = source[key];
                }
            }
            return target;
        }
        function repeat(string, count) {
            var result = '', cycle;
            for(cycle = 0; cycle < count; cycle += 1)result += string;
            return result;
        }
        function isNegativeZero(number) {
            return 0 === number && Number.NEGATIVE_INFINITY === 1 / number;
        }
        var isNothing_1 = isNothing;
        var isObject_1 = isObject;
        var toArray_1 = toArray;
        var repeat_1 = repeat;
        var isNegativeZero_1 = isNegativeZero;
        var extend_1 = extend;
        var common = {
            isNothing: isNothing_1,
            isObject: isObject_1,
            toArray: toArray_1,
            repeat: repeat_1,
            isNegativeZero: isNegativeZero_1,
            extend: extend_1
        };
        function formatError(exception, compact) {
            var where = '', message = exception.reason || '(unknown reason)';
            if (!exception.mark) return message;
            if (exception.mark.name) where += 'in "' + exception.mark.name + '" ';
            where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';
            if (!compact && exception.mark.snippet) where += '\n\n' + exception.mark.snippet;
            return message + ' ' + where;
        }
        function YAMLException$1(reason, mark) {
            Error.call(this);
            this.name = 'YAMLException';
            this.reason = reason;
            this.mark = mark;
            this.message = formatError(this, false);
            if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
            else this.stack = new Error().stack || '';
        }
        YAMLException$1.prototype = Object.create(Error.prototype);
        YAMLException$1.prototype.constructor = YAMLException$1;
        YAMLException$1.prototype.toString = function(compact) {
            return this.name + ': ' + formatError(this, compact);
        };
        var exception = YAMLException$1;
        function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
            var head = '';
            var tail = '';
            var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
            if (position - lineStart > maxHalfLength) {
                head = ' ... ';
                lineStart = position - maxHalfLength + head.length;
            }
            if (lineEnd - position > maxHalfLength) {
                tail = ' ...';
                lineEnd = position + maxHalfLength - tail.length;
            }
            return {
                str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, 'â†’') + tail,
                pos: position - lineStart + head.length
            };
        }
        function padStart(string, max) {
            return common.repeat(' ', max - string.length) + string;
        }
        function makeSnippet(mark, options) {
            options = Object.create(options || null);
            if (!mark.buffer) return null;
            if (!options.maxLength) options.maxLength = 79;
            if ('number' != typeof options.indent) options.indent = 1;
            if ('number' != typeof options.linesBefore) options.linesBefore = 3;
            if ('number' != typeof options.linesAfter) options.linesAfter = 2;
            var re = /\r?\n|\r|\0/g;
            var lineStarts = [
                0
            ];
            var lineEnds = [];
            var match;
            var foundLineNo = -1;
            while(match = re.exec(mark.buffer)){
                lineEnds.push(match.index);
                lineStarts.push(match.index + match[0].length);
                if (mark.position <= match.index && foundLineNo < 0) foundLineNo = lineStarts.length - 2;
            }
            if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
            var result = '', i, line;
            var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
            var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
            for(i = 1; i <= options.linesBefore; i++){
                if (foundLineNo - i < 0) break;
                line = getLine(mark.buffer, lineStarts[foundLineNo - i], lineEnds[foundLineNo - i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]), maxLineLength);
                result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + ' | ' + line.str + '\n' + result;
            }
            line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
            result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + ' | ' + line.str + '\n';
            result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + "^\n";
            for(i = 1; i <= options.linesAfter; i++){
                if (foundLineNo + i >= lineEnds.length) break;
                line = getLine(mark.buffer, lineStarts[foundLineNo + i], lineEnds[foundLineNo + i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]), maxLineLength);
                result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + ' | ' + line.str + '\n';
            }
            return result.replace(/\n$/, '');
        }
        var snippet = makeSnippet;
        var TYPE_CONSTRUCTOR_OPTIONS = [
            'kind',
            'multi',
            'resolve',
            'construct',
            'instanceOf',
            'predicate',
            'represent',
            'representName',
            'defaultStyle',
            'styleAliases'
        ];
        var YAML_NODE_KINDS = [
            'scalar',
            'sequence',
            'mapping'
        ];
        function compileStyleAliases(map) {
            var result = {};
            if (null !== map) Object.keys(map).forEach(function(style) {
                map[style].forEach(function(alias) {
                    result[String(alias)] = style;
                });
            });
            return result;
        }
        function Type$1(tag, options) {
            options = options || {};
            Object.keys(options).forEach(function(name) {
                if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
            });
            this.options = options;
            this.tag = tag;
            this.kind = options['kind'] || null;
            this.resolve = options['resolve'] || function() {
                return true;
            };
            this.construct = options['construct'] || function(data) {
                return data;
            };
            this.instanceOf = options['instanceOf'] || null;
            this.predicate = options['predicate'] || null;
            this.represent = options['represent'] || null;
            this.representName = options['representName'] || null;
            this.defaultStyle = options['defaultStyle'] || null;
            this.multi = options['multi'] || false;
            this.styleAliases = compileStyleAliases(options['styleAliases'] || null);
            if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
        }
        var type = Type$1;
        function compileList(schema, name) {
            var result = [];
            schema[name].forEach(function(currentType) {
                var newIndex = result.length;
                result.forEach(function(previousType, previousIndex) {
                    if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) newIndex = previousIndex;
                });
                result[newIndex] = currentType;
            });
            return result;
        }
        function compileMap() {
            var result = {
                scalar: {},
                sequence: {},
                mapping: {},
                fallback: {},
                multi: {
                    scalar: [],
                    sequence: [],
                    mapping: [],
                    fallback: []
                }
            }, index, length;
            function collectType(type) {
                if (type.multi) {
                    result.multi[type.kind].push(type);
                    result.multi['fallback'].push(type);
                } else result[type.kind][type.tag] = result['fallback'][type.tag] = type;
            }
            for(index = 0, length = arguments.length; index < length; index += 1)arguments[index].forEach(collectType);
            return result;
        }
        function Schema$1(definition) {
            return this.extend(definition);
        }
        Schema$1.prototype.extend = function(definition) {
            var implicit = [];
            var explicit = [];
            if (definition instanceof type) explicit.push(definition);
            else if (Array.isArray(definition)) explicit = explicit.concat(definition);
            else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
                if (definition.implicit) implicit = implicit.concat(definition.implicit);
                if (definition.explicit) explicit = explicit.concat(definition.explicit);
            } else throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
            implicit.forEach(function(type$1) {
                if (!(type$1 instanceof type)) throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
                if (type$1.loadKind && 'scalar' !== type$1.loadKind) throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
                if (type$1.multi) throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');
            });
            explicit.forEach(function(type$1) {
                if (!(type$1 instanceof type)) throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
            });
            var result = Object.create(Schema$1.prototype);
            result.implicit = (this.implicit || []).concat(implicit);
            result.explicit = (this.explicit || []).concat(explicit);
            result.compiledImplicit = compileList(result, 'implicit');
            result.compiledExplicit = compileList(result, 'explicit');
            result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
            return result;
        };
        var schema = Schema$1;
        var str = new type('tag:yaml.org,2002:str', {
            kind: 'scalar',
            construct: function(data) {
                return null !== data ? data : '';
            }
        });
        var seq = new type('tag:yaml.org,2002:seq', {
            kind: 'sequence',
            construct: function(data) {
                return null !== data ? data : [];
            }
        });
        var map = new type('tag:yaml.org,2002:map', {
            kind: 'mapping',
            construct: function(data) {
                return null !== data ? data : {};
            }
        });
        var failsafe = new schema({
            explicit: [
                str,
                seq,
                map
            ]
        });
        function resolveYamlNull(data) {
            if (null === data) return true;
            var max = data.length;
            return 1 === max && '~' === data || 4 === max && ('null' === data || 'Null' === data || 'NULL' === data);
        }
        function constructYamlNull() {
            return null;
        }
        function isNull(object) {
            return null === object;
        }
        var _null = new type('tag:yaml.org,2002:null', {
            kind: 'scalar',
            resolve: resolveYamlNull,
            construct: constructYamlNull,
            predicate: isNull,
            represent: {
                canonical: function() {
                    return '~';
                },
                lowercase: function() {
                    return 'null';
                },
                uppercase: function() {
                    return 'NULL';
                },
                camelcase: function() {
                    return 'Null';
                },
                empty: function() {
                    return '';
                }
            },
            defaultStyle: 'lowercase'
        });
        function resolveYamlBoolean(data) {
            if (null === data) return false;
            var max = data.length;
            return 4 === max && ('true' === data || 'True' === data || 'TRUE' === data) || 5 === max && ('false' === data || 'False' === data || 'FALSE' === data);
        }
        function constructYamlBoolean(data) {
            return 'true' === data || 'True' === data || 'TRUE' === data;
        }
        function isBoolean(object) {
            return '[object Boolean]' === Object.prototype.toString.call(object);
        }
        var bool = new type('tag:yaml.org,2002:bool', {
            kind: 'scalar',
            resolve: resolveYamlBoolean,
            construct: constructYamlBoolean,
            predicate: isBoolean,
            represent: {
                lowercase: function(object) {
                    return object ? 'true' : 'false';
                },
                uppercase: function(object) {
                    return object ? 'TRUE' : 'FALSE';
                },
                camelcase: function(object) {
                    return object ? 'True' : 'False';
                }
            },
            defaultStyle: 'lowercase'
        });
        function isHexCode(c) {
            return 0x30 <= c && c <= 0x39 || 0x41 <= c && c <= 0x46 || 0x61 <= c && c <= 0x66;
        }
        function isOctCode(c) {
            return 0x30 <= c && c <= 0x37;
        }
        function isDecCode(c) {
            return 0x30 <= c && c <= 0x39;
        }
        function resolveYamlInteger(data) {
            if (null === data) return false;
            var max = data.length, index = 0, hasDigits = false, ch;
            if (!max) return false;
            ch = data[index];
            if ('-' === ch || '+' === ch) ch = data[++index];
            if ('0' === ch) {
                if (index + 1 === max) return true;
                ch = data[++index];
                if ('b' === ch) {
                    index++;
                    for(; index < max; index++){
                        ch = data[index];
                        if ('_' !== ch) {
                            if ('0' !== ch && '1' !== ch) return false;
                            hasDigits = true;
                        }
                    }
                    return hasDigits && '_' !== ch;
                }
                if ('x' === ch) {
                    index++;
                    for(; index < max; index++){
                        ch = data[index];
                        if ('_' !== ch) {
                            if (!isHexCode(data.charCodeAt(index))) return false;
                            hasDigits = true;
                        }
                    }
                    return hasDigits && '_' !== ch;
                }
                if ('o' === ch) {
                    index++;
                    for(; index < max; index++){
                        ch = data[index];
                        if ('_' !== ch) {
                            if (!isOctCode(data.charCodeAt(index))) return false;
                            hasDigits = true;
                        }
                    }
                    return hasDigits && '_' !== ch;
                }
            }
            if ('_' === ch) return false;
            for(; index < max; index++){
                ch = data[index];
                if ('_' !== ch) {
                    if (!isDecCode(data.charCodeAt(index))) return false;
                    hasDigits = true;
                }
            }
            if (!hasDigits || '_' === ch) return false;
            return true;
        }
        function constructYamlInteger(data) {
            var value = data, sign = 1, ch;
            if (-1 !== value.indexOf('_')) value = value.replace(/_/g, '');
            ch = value[0];
            if ('-' === ch || '+' === ch) {
                if ('-' === ch) sign = -1;
                value = value.slice(1);
                ch = value[0];
            }
            if ('0' === value) return 0;
            if ('0' === ch) {
                if ('b' === value[1]) return sign * parseInt(value.slice(2), 2);
                if ('x' === value[1]) return sign * parseInt(value.slice(2), 16);
                if ('o' === value[1]) return sign * parseInt(value.slice(2), 8);
            }
            return sign * parseInt(value, 10);
        }
        function isInteger(object) {
            return '[object Number]' === Object.prototype.toString.call(object) && object % 1 === 0 && !common.isNegativeZero(object);
        }
        var int = new type('tag:yaml.org,2002:int', {
            kind: 'scalar',
            resolve: resolveYamlInteger,
            construct: constructYamlInteger,
            predicate: isInteger,
            represent: {
                binary: function(obj) {
                    return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);
                },
                octal: function(obj) {
                    return obj >= 0 ? '0o' + obj.toString(8) : '-0o' + obj.toString(8).slice(1);
                },
                decimal: function(obj) {
                    return obj.toString(10);
                },
                hexadecimal: function(obj) {
                    return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);
                }
            },
            defaultStyle: 'decimal',
            styleAliases: {
                binary: [
                    2,
                    'bin'
                ],
                octal: [
                    8,
                    'oct'
                ],
                decimal: [
                    10,
                    'dec'
                ],
                hexadecimal: [
                    16,
                    'hex'
                ]
            }
        });
        var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
        function resolveYamlFloat(data) {
            if (null === data) return false;
            if (!YAML_FLOAT_PATTERN.test(data) || '_' === data[data.length - 1]) return false;
            return true;
        }
        function constructYamlFloat(data) {
            var value, sign;
            value = data.replace(/_/g, '').toLowerCase();
            sign = '-' === value[0] ? -1 : 1;
            if ('+-'.indexOf(value[0]) >= 0) value = value.slice(1);
            if ('.inf' === value) return 1 === sign ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
            if ('.nan' === value) return NaN;
            return sign * parseFloat(value, 10);
        }
        var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
        function representYamlFloat(object, style) {
            var res;
            if (isNaN(object)) switch(style){
                case 'lowercase':
                    return '.nan';
                case 'uppercase':
                    return '.NAN';
                case 'camelcase':
                    return '.NaN';
            }
            else if (Number.POSITIVE_INFINITY === object) switch(style){
                case 'lowercase':
                    return '.inf';
                case 'uppercase':
                    return '.INF';
                case 'camelcase':
                    return '.Inf';
            }
            else if (Number.NEGATIVE_INFINITY === object) switch(style){
                case 'lowercase':
                    return '-.inf';
                case 'uppercase':
                    return '-.INF';
                case 'camelcase':
                    return '-.Inf';
            }
            else if (common.isNegativeZero(object)) return '-0.0';
            res = object.toString(10);
            return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
        }
        function isFloat(object) {
            return '[object Number]' === Object.prototype.toString.call(object) && (object % 1 !== 0 || common.isNegativeZero(object));
        }
        var float = new type('tag:yaml.org,2002:float', {
            kind: 'scalar',
            resolve: resolveYamlFloat,
            construct: constructYamlFloat,
            predicate: isFloat,
            represent: representYamlFloat,
            defaultStyle: 'lowercase'
        });
        var json = failsafe.extend({
            implicit: [
                _null,
                bool,
                int,
                float
            ]
        });
        var core = json;
        var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
        var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
        function resolveYamlTimestamp(data) {
            if (null === data) return false;
            if (null !== YAML_DATE_REGEXP.exec(data)) return true;
            if (null !== YAML_TIMESTAMP_REGEXP.exec(data)) return true;
            return false;
        }
        function constructYamlTimestamp(data) {
            var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
            match = YAML_DATE_REGEXP.exec(data);
            if (null === match) match = YAML_TIMESTAMP_REGEXP.exec(data);
            if (null === match) throw new Error('Date resolve error');
            year = +match[1];
            month = match[2] - 1;
            day = +match[3];
            if (!match[4]) return new Date(Date.UTC(year, month, day));
            hour = +match[4];
            minute = +match[5];
            second = +match[6];
            if (match[7]) {
                fraction = match[7].slice(0, 3);
                while(fraction.length < 3)fraction += '0';
                fraction *= 1;
            }
            if (match[9]) {
                tz_hour = +match[10];
                tz_minute = +(match[11] || 0);
                delta = (60 * tz_hour + tz_minute) * 60000;
                if ('-' === match[9]) delta = -delta;
            }
            date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
            if (delta) date.setTime(date.getTime() - delta);
            return date;
        }
        function representYamlTimestamp(object) {
            return object.toISOString();
        }
        var timestamp = new type('tag:yaml.org,2002:timestamp', {
            kind: 'scalar',
            resolve: resolveYamlTimestamp,
            construct: constructYamlTimestamp,
            instanceOf: Date,
            represent: representYamlTimestamp
        });
        function resolveYamlMerge(data) {
            return '<<' === data || null === data;
        }
        var merge = new type('tag:yaml.org,2002:merge', {
            kind: 'scalar',
            resolve: resolveYamlMerge
        });
        var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';
        function resolveYamlBinary(data) {
            if (null === data) return false;
            var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
            for(idx = 0; idx < max; idx++){
                code = map.indexOf(data.charAt(idx));
                if (!(code > 64)) {
                    if (code < 0) return false;
                    bitlen += 6;
                }
            }
            return bitlen % 8 === 0;
        }
        function constructYamlBinary(data) {
            var idx, tailbits, input = data.replace(/[\r\n=]/g, ''), max = input.length, map = BASE64_MAP, bits = 0, result = [];
            for(idx = 0; idx < max; idx++){
                if (idx % 4 === 0 && idx) {
                    result.push(bits >> 16 & 0xFF);
                    result.push(bits >> 8 & 0xFF);
                    result.push(0xFF & bits);
                }
                bits = bits << 6 | map.indexOf(input.charAt(idx));
            }
            tailbits = max % 4 * 6;
            if (0 === tailbits) {
                result.push(bits >> 16 & 0xFF);
                result.push(bits >> 8 & 0xFF);
                result.push(0xFF & bits);
            } else if (18 === tailbits) {
                result.push(bits >> 10 & 0xFF);
                result.push(bits >> 2 & 0xFF);
            } else if (12 === tailbits) result.push(bits >> 4 & 0xFF);
            return new Uint8Array(result);
        }
        function representYamlBinary(object) {
            var result = '', bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
            for(idx = 0; idx < max; idx++){
                if (idx % 3 === 0 && idx) {
                    result += map[bits >> 18 & 0x3F];
                    result += map[bits >> 12 & 0x3F];
                    result += map[bits >> 6 & 0x3F];
                    result += map[0x3F & bits];
                }
                bits = (bits << 8) + object[idx];
            }
            tail = max % 3;
            if (0 === tail) {
                result += map[bits >> 18 & 0x3F];
                result += map[bits >> 12 & 0x3F];
                result += map[bits >> 6 & 0x3F];
                result += map[0x3F & bits];
            } else if (2 === tail) {
                result += map[bits >> 10 & 0x3F];
                result += map[bits >> 4 & 0x3F];
                result += map[bits << 2 & 0x3F];
                result += map[64];
            } else if (1 === tail) {
                result += map[bits >> 2 & 0x3F];
                result += map[bits << 4 & 0x3F];
                result += map[64];
                result += map[64];
            }
            return result;
        }
        function isBinary(obj) {
            return '[object Uint8Array]' === Object.prototype.toString.call(obj);
        }
        var binary = new type('tag:yaml.org,2002:binary', {
            kind: 'scalar',
            resolve: resolveYamlBinary,
            construct: constructYamlBinary,
            predicate: isBinary,
            represent: representYamlBinary
        });
        var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
        var _toString$2 = Object.prototype.toString;
        function resolveYamlOmap(data) {
            if (null === data) return true;
            var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
            for(index = 0, length = object.length; index < length; index += 1){
                pair = object[index];
                pairHasKey = false;
                if ('[object Object]' !== _toString$2.call(pair)) return false;
                for(pairKey in pair)if (_hasOwnProperty$3.call(pair, pairKey)) if (pairHasKey) return false;
                else pairHasKey = true;
                if (!pairHasKey) return false;
                if (-1 !== objectKeys.indexOf(pairKey)) return false;
                objectKeys.push(pairKey);
            }
            return true;
        }
        function constructYamlOmap(data) {
            return null !== data ? data : [];
        }
        var omap = new type('tag:yaml.org,2002:omap', {
            kind: 'sequence',
            resolve: resolveYamlOmap,
            construct: constructYamlOmap
        });
        var _toString$1 = Object.prototype.toString;
        function resolveYamlPairs(data) {
            if (null === data) return true;
            var index, length, pair, keys, result, object = data;
            result = new Array(object.length);
            for(index = 0, length = object.length; index < length; index += 1){
                pair = object[index];
                if ('[object Object]' !== _toString$1.call(pair)) return false;
                keys = Object.keys(pair);
                if (1 !== keys.length) return false;
                result[index] = [
                    keys[0],
                    pair[keys[0]]
                ];
            }
            return true;
        }
        function constructYamlPairs(data) {
            if (null === data) return [];
            var index, length, pair, keys, result, object = data;
            result = new Array(object.length);
            for(index = 0, length = object.length; index < length; index += 1){
                pair = object[index];
                keys = Object.keys(pair);
                result[index] = [
                    keys[0],
                    pair[keys[0]]
                ];
            }
            return result;
        }
        var pairs = new type('tag:yaml.org,2002:pairs', {
            kind: 'sequence',
            resolve: resolveYamlPairs,
            construct: constructYamlPairs
        });
        var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
        function resolveYamlSet(data) {
            if (null === data) return true;
            var key, object = data;
            for(key in object)if (_hasOwnProperty$2.call(object, key)) {
                if (null !== object[key]) return false;
            }
            return true;
        }
        function constructYamlSet(data) {
            return null !== data ? data : {};
        }
        var set = new type('tag:yaml.org,2002:set', {
            kind: 'mapping',
            resolve: resolveYamlSet,
            construct: constructYamlSet
        });
        var _default = core.extend({
            implicit: [
                timestamp,
                merge
            ],
            explicit: [
                binary,
                omap,
                pairs,
                set
            ]
        });
        var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
        var CONTEXT_FLOW_IN = 1;
        var CONTEXT_FLOW_OUT = 2;
        var CONTEXT_BLOCK_IN = 3;
        var CONTEXT_BLOCK_OUT = 4;
        var CHOMPING_CLIP = 1;
        var CHOMPING_STRIP = 2;
        var CHOMPING_KEEP = 3;
        var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
        var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
        var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
        var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
        var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
        function _class(obj) {
            return Object.prototype.toString.call(obj);
        }
        function is_EOL(c) {
            return 0x0A === c || 0x0D === c;
        }
        function is_WHITE_SPACE(c) {
            return 0x09 === c || 0x20 === c;
        }
        function is_WS_OR_EOL(c) {
            return 0x09 === c || 0x20 === c || 0x0A === c || 0x0D === c;
        }
        function is_FLOW_INDICATOR(c) {
            return 0x2C === c || 0x5B === c || 0x5D === c || 0x7B === c || 0x7D === c;
        }
        function fromHexCode(c) {
            var lc;
            if (0x30 <= c && c <= 0x39) return c - 0x30;
            lc = 0x20 | c;
            if (0x61 <= lc && lc <= 0x66) return lc - 0x61 + 10;
            return -1;
        }
        function escapedHexLen(c) {
            if (0x78 === c) return 2;
            if (0x75 === c) return 4;
            if (0x55 === c) return 8;
            return 0;
        }
        function fromDecimalCode(c) {
            if (0x30 <= c && c <= 0x39) return c - 0x30;
            return -1;
        }
        function simpleEscapeSequence(c) {
            return 0x30 === c ? '\x00' : 0x61 === c ? '\x07' : 0x62 === c ? '\x08' : 0x74 === c ? '\x09' : 0x09 === c ? '\x09' : 0x6E === c ? '\x0A' : 0x76 === c ? '\x0B' : 0x66 === c ? '\x0C' : 0x72 === c ? '\x0D' : 0x65 === c ? '\x1B' : 0x20 === c ? ' ' : 0x22 === c ? '\x22' : 0x2F === c ? '/' : 0x5C === c ? '\x5C' : 0x4E === c ? '\x85' : 0x5F === c ? '\xA0' : 0x4C === c ? '\u2028' : 0x50 === c ? '\u2029' : '';
        }
        function charFromCodepoint(c) {
            if (c <= 0xFFFF) return String.fromCharCode(c);
            return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
        }
        var simpleEscapeCheck = new Array(256);
        var simpleEscapeMap = new Array(256);
        for(var i = 0; i < 256; i++){
            simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
            simpleEscapeMap[i] = simpleEscapeSequence(i);
        }
        function State$1(input, options) {
            this.input = input;
            this.filename = options['filename'] || null;
            this.schema = options['schema'] || _default;
            this.onWarning = options['onWarning'] || null;
            this.legacy = options['legacy'] || false;
            this.json = options['json'] || false;
            this.listener = options['listener'] || null;
            this.implicitTypes = this.schema.compiledImplicit;
            this.typeMap = this.schema.compiledTypeMap;
            this.length = input.length;
            this.position = 0;
            this.line = 0;
            this.lineStart = 0;
            this.lineIndent = 0;
            this.firstTabInLine = -1;
            this.documents = [];
        }
        function generateError(state, message) {
            var mark = {
                name: state.filename,
                buffer: state.input.slice(0, -1),
                position: state.position,
                line: state.line,
                column: state.position - state.lineStart
            };
            mark.snippet = snippet(mark);
            return new exception(message, mark);
        }
        function throwError(state, message) {
            throw generateError(state, message);
        }
        function throwWarning(state, message) {
            if (state.onWarning) state.onWarning.call(null, generateError(state, message));
        }
        var directiveHandlers = {
            YAML: function(state, name, args) {
                var match, major, minor;
                if (null !== state.version) throwError(state, 'duplication of %YAML directive');
                if (1 !== args.length) throwError(state, 'YAML directive accepts exactly one argument');
                match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
                if (null === match) throwError(state, 'ill-formed argument of the YAML directive');
                major = parseInt(match[1], 10);
                minor = parseInt(match[2], 10);
                if (1 !== major) throwError(state, 'unacceptable YAML version of the document');
                state.version = args[0];
                state.checkLineBreaks = minor < 2;
                if (1 !== minor && 2 !== minor) throwWarning(state, 'unsupported YAML version of the document');
            },
            TAG: function(state, name, args) {
                var handle, prefix;
                if (2 !== args.length) throwError(state, 'TAG directive accepts exactly two arguments');
                handle = args[0];
                prefix = args[1];
                if (!PATTERN_TAG_HANDLE.test(handle)) throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
                if (_hasOwnProperty$1.call(state.tagMap, handle)) throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
                if (!PATTERN_TAG_URI.test(prefix)) throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
                try {
                    prefix = decodeURIComponent(prefix);
                } catch (err) {
                    throwError(state, 'tag prefix is malformed: ' + prefix);
                }
                state.tagMap[handle] = prefix;
            }
        };
        function captureSegment(state, start, end, checkJson) {
            var _position, _length, _character, _result;
            if (start < end) {
                _result = state.input.slice(start, end);
                if (checkJson) for(_position = 0, _length = _result.length; _position < _length; _position += 1){
                    _character = _result.charCodeAt(_position);
                    if (!(0x09 === _character || 0x20 <= _character && _character <= 0x10FFFF)) throwError(state, 'expected valid JSON character');
                }
                else if (PATTERN_NON_PRINTABLE.test(_result)) throwError(state, 'the stream contains non-printable characters');
                state.result += _result;
            }
        }
        function mergeMappings(state, destination, source, overridableKeys) {
            var sourceKeys, key, index, quantity;
            if (!common.isObject(source)) throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
            sourceKeys = Object.keys(source);
            for(index = 0, quantity = sourceKeys.length; index < quantity; index += 1){
                key = sourceKeys[index];
                if (!_hasOwnProperty$1.call(destination, key)) {
                    destination[key] = source[key];
                    overridableKeys[key] = true;
                }
            }
        }
        function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
            var index, quantity;
            if (Array.isArray(keyNode)) {
                keyNode = Array.prototype.slice.call(keyNode);
                for(index = 0, quantity = keyNode.length; index < quantity; index += 1){
                    if (Array.isArray(keyNode[index])) throwError(state, 'nested arrays are not supported inside keys');
                    if ('object' == typeof keyNode && '[object Object]' === _class(keyNode[index])) keyNode[index] = '[object Object]';
                }
            }
            if ('object' == typeof keyNode && '[object Object]' === _class(keyNode)) keyNode = '[object Object]';
            keyNode = String(keyNode);
            if (null === _result) _result = {};
            if ('tag:yaml.org,2002:merge' === keyTag) if (Array.isArray(valueNode)) for(index = 0, quantity = valueNode.length; index < quantity; index += 1)mergeMappings(state, _result, valueNode[index], overridableKeys);
            else mergeMappings(state, _result, valueNode, overridableKeys);
            else {
                if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
                    state.line = startLine || state.line;
                    state.lineStart = startLineStart || state.lineStart;
                    state.position = startPos || state.position;
                    throwError(state, 'duplicated mapping key');
                }
                if ('__proto__' === keyNode) Object.defineProperty(_result, keyNode, {
                    configurable: true,
                    enumerable: true,
                    writable: true,
                    value: valueNode
                });
                else _result[keyNode] = valueNode;
                delete overridableKeys[keyNode];
            }
            return _result;
        }
        function readLineBreak(state) {
            var ch;
            ch = state.input.charCodeAt(state.position);
            if (0x0A === ch) state.position++;
            else if (0x0D === ch) {
                state.position++;
                if (0x0A === state.input.charCodeAt(state.position)) state.position++;
            } else throwError(state, 'a line break is expected');
            state.line += 1;
            state.lineStart = state.position;
            state.firstTabInLine = -1;
        }
        function skipSeparationSpace(state, allowComments, checkIndent) {
            var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
            while(0 !== ch){
                while(is_WHITE_SPACE(ch)){
                    if (0x09 === ch && -1 === state.firstTabInLine) state.firstTabInLine = state.position;
                    ch = state.input.charCodeAt(++state.position);
                }
                if (allowComments && 0x23 === ch) do ch = state.input.charCodeAt(++state.position);
                while (0x0A !== ch && 0x0D !== ch && 0 !== ch);
                if (is_EOL(ch)) {
                    readLineBreak(state);
                    ch = state.input.charCodeAt(state.position);
                    lineBreaks++;
                    state.lineIndent = 0;
                    while(0x20 === ch){
                        state.lineIndent++;
                        ch = state.input.charCodeAt(++state.position);
                    }
                } else break;
            }
            if (-1 !== checkIndent && 0 !== lineBreaks && state.lineIndent < checkIndent) throwWarning(state, 'deficient indentation');
            return lineBreaks;
        }
        function testDocumentSeparator(state) {
            var _position = state.position, ch;
            ch = state.input.charCodeAt(_position);
            if ((0x2D === ch || 0x2E === ch) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
                _position += 3;
                ch = state.input.charCodeAt(_position);
                if (0 === ch || is_WS_OR_EOL(ch)) return true;
            }
            return false;
        }
        function writeFoldedLines(state, count) {
            if (1 === count) state.result += ' ';
            else if (count > 1) state.result += common.repeat('\n', count - 1);
        }
        function readPlainScalar(state, nodeIndent, withinFlowCollection) {
            var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
            ch = state.input.charCodeAt(state.position);
            if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || 0x23 === ch || 0x26 === ch || 0x2A === ch || 0x21 === ch || 0x7C === ch || 0x3E === ch || 0x27 === ch || 0x22 === ch || 0x25 === ch || 0x40 === ch || 0x60 === ch) return false;
            if (0x3F === ch || 0x2D === ch) {
                following = state.input.charCodeAt(state.position + 1);
                if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) return false;
            }
            state.kind = 'scalar';
            state.result = '';
            captureStart = captureEnd = state.position;
            hasPendingContent = false;
            while(0 !== ch){
                if (0x3A === ch) {
                    following = state.input.charCodeAt(state.position + 1);
                    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) break;
                } else if (0x23 === ch) {
                    preceding = state.input.charCodeAt(state.position - 1);
                    if (is_WS_OR_EOL(preceding)) break;
                } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) break;
                else if (is_EOL(ch)) {
                    _line = state.line;
                    _lineStart = state.lineStart;
                    _lineIndent = state.lineIndent;
                    skipSeparationSpace(state, false, -1);
                    if (state.lineIndent >= nodeIndent) {
                        hasPendingContent = true;
                        ch = state.input.charCodeAt(state.position);
                        continue;
                    }
                    state.position = captureEnd;
                    state.line = _line;
                    state.lineStart = _lineStart;
                    state.lineIndent = _lineIndent;
                    break;
                }
                if (hasPendingContent) {
                    captureSegment(state, captureStart, captureEnd, false);
                    writeFoldedLines(state, state.line - _line);
                    captureStart = captureEnd = state.position;
                    hasPendingContent = false;
                }
                if (!is_WHITE_SPACE(ch)) captureEnd = state.position + 1;
                ch = state.input.charCodeAt(++state.position);
            }
            captureSegment(state, captureStart, captureEnd, false);
            if (state.result) return true;
            state.kind = _kind;
            state.result = _result;
            return false;
        }
        function readSingleQuotedScalar(state, nodeIndent) {
            var ch, captureStart, captureEnd;
            ch = state.input.charCodeAt(state.position);
            if (0x27 !== ch) return false;
            state.kind = 'scalar';
            state.result = '';
            state.position++;
            captureStart = captureEnd = state.position;
            while(0 !== (ch = state.input.charCodeAt(state.position)))if (0x27 === ch) {
                captureSegment(state, captureStart, state.position, true);
                ch = state.input.charCodeAt(++state.position);
                if (0x27 !== ch) return true;
                captureStart = state.position;
                state.position++;
                captureEnd = state.position;
            } else if (is_EOL(ch)) {
                captureSegment(state, captureStart, captureEnd, true);
                writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
                captureStart = captureEnd = state.position;
            } else if (state.position === state.lineStart && testDocumentSeparator(state)) throwError(state, 'unexpected end of the document within a single quoted scalar');
            else {
                state.position++;
                captureEnd = state.position;
            }
            throwError(state, 'unexpected end of the stream within a single quoted scalar');
        }
        function readDoubleQuotedScalar(state, nodeIndent) {
            var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
            ch = state.input.charCodeAt(state.position);
            if (0x22 !== ch) return false;
            state.kind = 'scalar';
            state.result = '';
            state.position++;
            captureStart = captureEnd = state.position;
            while(0 !== (ch = state.input.charCodeAt(state.position)))if (0x22 === ch) {
                captureSegment(state, captureStart, state.position, true);
                state.position++;
                return true;
            } else if (0x5C === ch) {
                captureSegment(state, captureStart, state.position, true);
                ch = state.input.charCodeAt(++state.position);
                if (is_EOL(ch)) skipSeparationSpace(state, false, nodeIndent);
                else if (ch < 256 && simpleEscapeCheck[ch]) {
                    state.result += simpleEscapeMap[ch];
                    state.position++;
                } else if ((tmp = escapedHexLen(ch)) > 0) {
                    hexLength = tmp;
                    hexResult = 0;
                    for(; hexLength > 0; hexLength--){
                        ch = state.input.charCodeAt(++state.position);
                        if ((tmp = fromHexCode(ch)) >= 0) hexResult = (hexResult << 4) + tmp;
                        else throwError(state, 'expected hexadecimal character');
                    }
                    state.result += charFromCodepoint(hexResult);
                    state.position++;
                } else throwError(state, 'unknown escape sequence');
                captureStart = captureEnd = state.position;
            } else if (is_EOL(ch)) {
                captureSegment(state, captureStart, captureEnd, true);
                writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
                captureStart = captureEnd = state.position;
            } else if (state.position === state.lineStart && testDocumentSeparator(state)) throwError(state, 'unexpected end of the document within a double quoted scalar');
            else {
                state.position++;
                captureEnd = state.position;
            }
            throwError(state, 'unexpected end of the stream within a double quoted scalar');
        }
        function readFlowCollection(state, nodeIndent) {
            var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = Object.create(null), keyNode, keyTag, valueNode, ch;
            ch = state.input.charCodeAt(state.position);
            if (0x5B === ch) {
                terminator = 0x5D;
                isMapping = false;
                _result = [];
            } else {
                if (0x7B !== ch) return false;
                terminator = 0x7D;
                isMapping = true;
                _result = {};
            }
            if (null !== state.anchor) state.anchorMap[state.anchor] = _result;
            ch = state.input.charCodeAt(++state.position);
            while(0 !== ch){
                skipSeparationSpace(state, true, nodeIndent);
                ch = state.input.charCodeAt(state.position);
                if (ch === terminator) {
                    state.position++;
                    state.tag = _tag;
                    state.anchor = _anchor;
                    state.kind = isMapping ? 'mapping' : 'sequence';
                    state.result = _result;
                    return true;
                }
                if (readNext) {
                    if (0x2C === ch) throwError(state, "expected the node content, but found ','");
                } else throwError(state, 'missed comma between flow collection entries');
                keyTag = keyNode = valueNode = null;
                isPair = isExplicitPair = false;
                if (0x3F === ch) {
                    following = state.input.charCodeAt(state.position + 1);
                    if (is_WS_OR_EOL(following)) {
                        isPair = isExplicitPair = true;
                        state.position++;
                        skipSeparationSpace(state, true, nodeIndent);
                    }
                }
                _line = state.line;
                _lineStart = state.lineStart;
                _pos = state.position;
                composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
                keyTag = state.tag;
                keyNode = state.result;
                skipSeparationSpace(state, true, nodeIndent);
                ch = state.input.charCodeAt(state.position);
                if ((isExplicitPair || state.line === _line) && 0x3A === ch) {
                    isPair = true;
                    ch = state.input.charCodeAt(++state.position);
                    skipSeparationSpace(state, true, nodeIndent);
                    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
                    valueNode = state.result;
                }
                if (isMapping) storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
                else if (isPair) _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
                else _result.push(keyNode);
                skipSeparationSpace(state, true, nodeIndent);
                ch = state.input.charCodeAt(state.position);
                if (0x2C === ch) {
                    readNext = true;
                    ch = state.input.charCodeAt(++state.position);
                } else readNext = false;
            }
            throwError(state, 'unexpected end of the stream within a flow collection');
        }
        function readBlockScalar(state, nodeIndent) {
            var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
            ch = state.input.charCodeAt(state.position);
            if (0x7C === ch) folding = false;
            else {
                if (0x3E !== ch) return false;
                folding = true;
            }
            state.kind = 'scalar';
            state.result = '';
            while(0 !== ch){
                ch = state.input.charCodeAt(++state.position);
                if (0x2B === ch || 0x2D === ch) if (CHOMPING_CLIP === chomping) chomping = 0x2B === ch ? CHOMPING_KEEP : CHOMPING_STRIP;
                else throwError(state, 'repeat of a chomping mode identifier');
                else if ((tmp = fromDecimalCode(ch)) >= 0) if (0 === tmp) throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
                else if (detectedIndent) throwError(state, 'repeat of an indentation width identifier');
                else {
                    textIndent = nodeIndent + tmp - 1;
                    detectedIndent = true;
                }
                else break;
            }
            if (is_WHITE_SPACE(ch)) {
                do ch = state.input.charCodeAt(++state.position);
                while (is_WHITE_SPACE(ch));
                if (0x23 === ch) do ch = state.input.charCodeAt(++state.position);
                while (!is_EOL(ch) && 0 !== ch);
            }
            while(0 !== ch){
                readLineBreak(state);
                state.lineIndent = 0;
                ch = state.input.charCodeAt(state.position);
                while((!detectedIndent || state.lineIndent < textIndent) && 0x20 === ch){
                    state.lineIndent++;
                    ch = state.input.charCodeAt(++state.position);
                }
                if (!detectedIndent && state.lineIndent > textIndent) textIndent = state.lineIndent;
                if (is_EOL(ch)) {
                    emptyLines++;
                    continue;
                }
                if (state.lineIndent < textIndent) {
                    if (chomping === CHOMPING_KEEP) state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
                    else if (chomping === CHOMPING_CLIP) {
                        if (didReadContent) state.result += '\n';
                    }
                    break;
                }
                if (folding) if (is_WHITE_SPACE(ch)) {
                    atMoreIndented = true;
                    state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
                } else if (atMoreIndented) {
                    atMoreIndented = false;
                    state.result += common.repeat('\n', emptyLines + 1);
                } else if (0 === emptyLines) {
                    if (didReadContent) state.result += ' ';
                } else state.result += common.repeat('\n', emptyLines);
                else state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
                didReadContent = true;
                detectedIndent = true;
                emptyLines = 0;
                captureStart = state.position;
                while(!is_EOL(ch) && 0 !== ch)ch = state.input.charCodeAt(++state.position);
                captureSegment(state, captureStart, state.position, false);
            }
            return true;
        }
        function readBlockSequence(state, nodeIndent) {
            var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
            if (-1 !== state.firstTabInLine) return false;
            if (null !== state.anchor) state.anchorMap[state.anchor] = _result;
            ch = state.input.charCodeAt(state.position);
            while(0 !== ch){
                if (-1 !== state.firstTabInLine) {
                    state.position = state.firstTabInLine;
                    throwError(state, 'tab characters must not be used in indentation');
                }
                if (0x2D !== ch) break;
                following = state.input.charCodeAt(state.position + 1);
                if (!is_WS_OR_EOL(following)) break;
                detected = true;
                state.position++;
                if (skipSeparationSpace(state, true, -1)) {
                    if (state.lineIndent <= nodeIndent) {
                        _result.push(null);
                        ch = state.input.charCodeAt(state.position);
                        continue;
                    }
                }
                _line = state.line;
                composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
                _result.push(state.result);
                skipSeparationSpace(state, true, -1);
                ch = state.input.charCodeAt(state.position);
                if ((state.line === _line || state.lineIndent > nodeIndent) && 0 !== ch) throwError(state, 'bad indentation of a sequence entry');
                else if (state.lineIndent < nodeIndent) break;
            }
            if (detected) {
                state.tag = _tag;
                state.anchor = _anchor;
                state.kind = 'sequence';
                state.result = _result;
                return true;
            }
            return false;
        }
        function readBlockMapping(state, nodeIndent, flowIndent) {
            var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
            if (-1 !== state.firstTabInLine) return false;
            if (null !== state.anchor) state.anchorMap[state.anchor] = _result;
            ch = state.input.charCodeAt(state.position);
            while(0 !== ch){
                if (!atExplicitKey && -1 !== state.firstTabInLine) {
                    state.position = state.firstTabInLine;
                    throwError(state, 'tab characters must not be used in indentation');
                }
                following = state.input.charCodeAt(state.position + 1);
                _line = state.line;
                if ((0x3F === ch || 0x3A === ch) && is_WS_OR_EOL(following)) {
                    if (0x3F === ch) {
                        if (atExplicitKey) {
                            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                            keyTag = keyNode = valueNode = null;
                        }
                        detected = true;
                        atExplicitKey = true;
                        allowCompact = true;
                    } else if (atExplicitKey) {
                        atExplicitKey = false;
                        allowCompact = true;
                    } else throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
                    state.position += 1;
                    ch = following;
                } else {
                    _keyLine = state.line;
                    _keyLineStart = state.lineStart;
                    _keyPos = state.position;
                    if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) break;
                    if (state.line === _line) {
                        ch = state.input.charCodeAt(state.position);
                        while(is_WHITE_SPACE(ch))ch = state.input.charCodeAt(++state.position);
                        if (0x3A === ch) {
                            ch = state.input.charCodeAt(++state.position);
                            if (!is_WS_OR_EOL(ch)) throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
                            if (atExplicitKey) {
                                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                                keyTag = keyNode = valueNode = null;
                            }
                            detected = true;
                            atExplicitKey = false;
                            allowCompact = false;
                            keyTag = state.tag;
                            keyNode = state.result;
                        } else if (detected) throwError(state, 'can not read an implicit mapping pair; a colon is missed');
                        else {
                            state.tag = _tag;
                            state.anchor = _anchor;
                            return true;
                        }
                    } else if (detected) throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
                    else {
                        state.tag = _tag;
                        state.anchor = _anchor;
                        return true;
                    }
                }
                if (state.line === _line || state.lineIndent > nodeIndent) {
                    if (atExplicitKey) {
                        _keyLine = state.line;
                        _keyLineStart = state.lineStart;
                        _keyPos = state.position;
                    }
                    if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) if (atExplicitKey) keyNode = state.result;
                    else valueNode = state.result;
                    if (!atExplicitKey) {
                        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
                        keyTag = keyNode = valueNode = null;
                    }
                    skipSeparationSpace(state, true, -1);
                    ch = state.input.charCodeAt(state.position);
                }
                if ((state.line === _line || state.lineIndent > nodeIndent) && 0 !== ch) throwError(state, 'bad indentation of a mapping entry');
                else if (state.lineIndent < nodeIndent) break;
            }
            if (atExplicitKey) storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            if (detected) {
                state.tag = _tag;
                state.anchor = _anchor;
                state.kind = 'mapping';
                state.result = _result;
            }
            return detected;
        }
        function readTagProperty(state) {
            var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
            ch = state.input.charCodeAt(state.position);
            if (0x21 !== ch) return false;
            if (null !== state.tag) throwError(state, 'duplication of a tag property');
            ch = state.input.charCodeAt(++state.position);
            if (0x3C === ch) {
                isVerbatim = true;
                ch = state.input.charCodeAt(++state.position);
            } else if (0x21 === ch) {
                isNamed = true;
                tagHandle = '!!';
                ch = state.input.charCodeAt(++state.position);
            } else tagHandle = '!';
            _position = state.position;
            if (isVerbatim) {
                do ch = state.input.charCodeAt(++state.position);
                while (0 !== ch && 0x3E !== ch);
                if (state.position < state.length) {
                    tagName = state.input.slice(_position, state.position);
                    ch = state.input.charCodeAt(++state.position);
                } else throwError(state, 'unexpected end of the stream within a verbatim tag');
            } else {
                while(0 !== ch && !is_WS_OR_EOL(ch)){
                    if (0x21 === ch) if (isNamed) throwError(state, 'tag suffix cannot contain exclamation marks');
                    else {
                        tagHandle = state.input.slice(_position - 1, state.position + 1);
                        if (!PATTERN_TAG_HANDLE.test(tagHandle)) throwError(state, 'named tag handle cannot contain such characters');
                        isNamed = true;
                        _position = state.position + 1;
                    }
                    ch = state.input.charCodeAt(++state.position);
                }
                tagName = state.input.slice(_position, state.position);
                if (PATTERN_FLOW_INDICATORS.test(tagName)) throwError(state, 'tag suffix cannot contain flow indicator characters');
            }
            if (tagName && !PATTERN_TAG_URI.test(tagName)) throwError(state, 'tag name cannot contain such characters: ' + tagName);
            try {
                tagName = decodeURIComponent(tagName);
            } catch (err) {
                throwError(state, 'tag name is malformed: ' + tagName);
            }
            if (isVerbatim) state.tag = tagName;
            else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) state.tag = state.tagMap[tagHandle] + tagName;
            else if ('!' === tagHandle) state.tag = '!' + tagName;
            else if ('!!' === tagHandle) state.tag = 'tag:yaml.org,2002:' + tagName;
            else throwError(state, 'undeclared tag handle "' + tagHandle + '"');
            return true;
        }
        function readAnchorProperty(state) {
            var _position, ch;
            ch = state.input.charCodeAt(state.position);
            if (0x26 !== ch) return false;
            if (null !== state.anchor) throwError(state, 'duplication of an anchor property');
            ch = state.input.charCodeAt(++state.position);
            _position = state.position;
            while(0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch))ch = state.input.charCodeAt(++state.position);
            if (state.position === _position) throwError(state, 'name of an anchor node must contain at least one character');
            state.anchor = state.input.slice(_position, state.position);
            return true;
        }
        function readAlias(state) {
            var _position, alias, ch;
            ch = state.input.charCodeAt(state.position);
            if (0x2A !== ch) return false;
            ch = state.input.charCodeAt(++state.position);
            _position = state.position;
            while(0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch))ch = state.input.charCodeAt(++state.position);
            if (state.position === _position) throwError(state, 'name of an alias node must contain at least one character');
            alias = state.input.slice(_position, state.position);
            if (!_hasOwnProperty$1.call(state.anchorMap, alias)) throwError(state, 'unidentified alias "' + alias + '"');
            state.result = state.anchorMap[alias];
            skipSeparationSpace(state, true, -1);
            return true;
        }
        function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
            var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type, flowIndent, blockIndent;
            if (null !== state.listener) state.listener('open', state);
            state.tag = null;
            state.anchor = null;
            state.kind = null;
            state.result = null;
            allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
            if (allowToSeek) {
                if (skipSeparationSpace(state, true, -1)) {
                    atNewLine = true;
                    if (state.lineIndent > parentIndent) indentStatus = 1;
                    else if (state.lineIndent === parentIndent) indentStatus = 0;
                    else if (state.lineIndent < parentIndent) indentStatus = -1;
                }
            }
            if (1 === indentStatus) while(readTagProperty(state) || readAnchorProperty(state))if (skipSeparationSpace(state, true, -1)) {
                atNewLine = true;
                allowBlockCollections = allowBlockStyles;
                if (state.lineIndent > parentIndent) indentStatus = 1;
                else if (state.lineIndent === parentIndent) indentStatus = 0;
                else if (state.lineIndent < parentIndent) indentStatus = -1;
            } else allowBlockCollections = false;
            if (allowBlockCollections) allowBlockCollections = atNewLine || allowCompact;
            if (1 === indentStatus || CONTEXT_BLOCK_OUT === nodeContext) {
                flowIndent = CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext ? parentIndent : parentIndent + 1;
                blockIndent = state.position - state.lineStart;
                if (1 === indentStatus) if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) hasContent = true;
                else {
                    if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) hasContent = true;
                    else if (readAlias(state)) {
                        hasContent = true;
                        if (null !== state.tag || null !== state.anchor) throwError(state, 'alias node should not have any properties');
                    } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
                        hasContent = true;
                        if (null === state.tag) state.tag = '?';
                    }
                    if (null !== state.anchor) state.anchorMap[state.anchor] = state.result;
                }
                else if (0 === indentStatus) hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
            }
            if (null === state.tag) {
                if (null !== state.anchor) state.anchorMap[state.anchor] = state.result;
            } else if ('?' === state.tag) {
                if (null !== state.result && 'scalar' !== state.kind) throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
                for(typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1){
                    type = state.implicitTypes[typeIndex];
                    if (type.resolve(state.result)) {
                        state.result = type.construct(state.result);
                        state.tag = type.tag;
                        if (null !== state.anchor) state.anchorMap[state.anchor] = state.result;
                        break;
                    }
                }
            } else if ('!' !== state.tag) {
                if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) type = state.typeMap[state.kind || 'fallback'][state.tag];
                else {
                    type = null;
                    typeList = state.typeMap.multi[state.kind || 'fallback'];
                    for(typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1)if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
                        type = typeList[typeIndex];
                        break;
                    }
                }
                if (!type) throwError(state, 'unknown tag !<' + state.tag + '>');
                if (null !== state.result && type.kind !== state.kind) throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
                if (type.resolve(state.result, state.tag)) {
                    state.result = type.construct(state.result, state.tag);
                    if (null !== state.anchor) state.anchorMap[state.anchor] = state.result;
                } else throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
            }
            if (null !== state.listener) state.listener('close', state);
            return null !== state.tag || null !== state.anchor || hasContent;
        }
        function readDocument(state) {
            var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
            state.version = null;
            state.checkLineBreaks = state.legacy;
            state.tagMap = Object.create(null);
            state.anchorMap = Object.create(null);
            while(0 !== (ch = state.input.charCodeAt(state.position))){
                skipSeparationSpace(state, true, -1);
                ch = state.input.charCodeAt(state.position);
                if (state.lineIndent > 0 || 0x25 !== ch) break;
                hasDirectives = true;
                ch = state.input.charCodeAt(++state.position);
                _position = state.position;
                while(0 !== ch && !is_WS_OR_EOL(ch))ch = state.input.charCodeAt(++state.position);
                directiveName = state.input.slice(_position, state.position);
                directiveArgs = [];
                if (directiveName.length < 1) throwError(state, 'directive name must not be less than one character in length');
                while(0 !== ch){
                    while(is_WHITE_SPACE(ch))ch = state.input.charCodeAt(++state.position);
                    if (0x23 === ch) {
                        do ch = state.input.charCodeAt(++state.position);
                        while (0 !== ch && !is_EOL(ch));
                        break;
                    }
                    if (is_EOL(ch)) break;
                    _position = state.position;
                    while(0 !== ch && !is_WS_OR_EOL(ch))ch = state.input.charCodeAt(++state.position);
                    directiveArgs.push(state.input.slice(_position, state.position));
                }
                if (0 !== ch) readLineBreak(state);
                if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) directiveHandlers[directiveName](state, directiveName, directiveArgs);
                else throwWarning(state, 'unknown document directive "' + directiveName + '"');
            }
            skipSeparationSpace(state, true, -1);
            if (0 === state.lineIndent && 0x2D === state.input.charCodeAt(state.position) && 0x2D === state.input.charCodeAt(state.position + 1) && 0x2D === state.input.charCodeAt(state.position + 2)) {
                state.position += 3;
                skipSeparationSpace(state, true, -1);
            } else if (hasDirectives) throwError(state, 'directives end mark is expected');
            composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
            skipSeparationSpace(state, true, -1);
            if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) throwWarning(state, 'non-ASCII line breaks are interpreted as content');
            state.documents.push(state.result);
            if (state.position === state.lineStart && testDocumentSeparator(state)) {
                if (0x2E === state.input.charCodeAt(state.position)) {
                    state.position += 3;
                    skipSeparationSpace(state, true, -1);
                }
                return;
            }
            if (!(state.position < state.length - 1)) return;
            throwError(state, 'end of the stream or a document separator is expected');
        }
        function loadDocuments(input, options) {
            input = String(input);
            options = options || {};
            if (0 !== input.length) {
                if (0x0A !== input.charCodeAt(input.length - 1) && 0x0D !== input.charCodeAt(input.length - 1)) input += '\n';
                if (0xFEFF === input.charCodeAt(0)) input = input.slice(1);
            }
            var state = new State$1(input, options);
            var nullpos = input.indexOf('\0');
            if (-1 !== nullpos) {
                state.position = nullpos;
                throwError(state, 'null byte is not allowed in input');
            }
            state.input += '\0';
            while(0x20 === state.input.charCodeAt(state.position)){
                state.lineIndent += 1;
                state.position += 1;
            }
            while(state.position < state.length - 1)readDocument(state);
            return state.documents;
        }
        function loadAll$1(input, iterator, options) {
            if (null !== iterator && 'object' == typeof iterator && void 0 === options) {
                options = iterator;
                iterator = null;
            }
            var documents = loadDocuments(input, options);
            if ('function' != typeof iterator) return documents;
            for(var index = 0, length = documents.length; index < length; index += 1)iterator(documents[index]);
        }
        function load$1(input, options) {
            var documents = loadDocuments(input, options);
            if (0 === documents.length) return;
            if (1 === documents.length) return documents[0];
            throw new exception('expected a single document in the stream, but found more');
        }
        var loadAll_1 = loadAll$1;
        var load_1 = load$1;
        var loader = {
            loadAll: loadAll_1,
            load: load_1
        };
        var _toString = Object.prototype.toString;
        var _hasOwnProperty = Object.prototype.hasOwnProperty;
        var CHAR_BOM = 0xFEFF;
        var CHAR_TAB = 0x09;
        var CHAR_LINE_FEED = 0x0A;
        var CHAR_CARRIAGE_RETURN = 0x0D;
        var CHAR_SPACE = 0x20;
        var CHAR_EXCLAMATION = 0x21;
        var CHAR_DOUBLE_QUOTE = 0x22;
        var CHAR_SHARP = 0x23;
        var CHAR_PERCENT = 0x25;
        var CHAR_AMPERSAND = 0x26;
        var CHAR_SINGLE_QUOTE = 0x27;
        var CHAR_ASTERISK = 0x2A;
        var CHAR_COMMA = 0x2C;
        var CHAR_MINUS = 0x2D;
        var CHAR_COLON = 0x3A;
        var CHAR_EQUALS = 0x3D;
        var CHAR_GREATER_THAN = 0x3E;
        var CHAR_QUESTION = 0x3F;
        var CHAR_COMMERCIAL_AT = 0x40;
        var CHAR_LEFT_SQUARE_BRACKET = 0x5B;
        var CHAR_RIGHT_SQUARE_BRACKET = 0x5D;
        var CHAR_GRAVE_ACCENT = 0x60;
        var CHAR_LEFT_CURLY_BRACKET = 0x7B;
        var CHAR_VERTICAL_LINE = 0x7C;
        var CHAR_RIGHT_CURLY_BRACKET = 0x7D;
        var ESCAPE_SEQUENCES = {};
        ESCAPE_SEQUENCES[0x00] = '\\0';
        ESCAPE_SEQUENCES[0x07] = '\\a';
        ESCAPE_SEQUENCES[0x08] = '\\b';
        ESCAPE_SEQUENCES[0x09] = '\\t';
        ESCAPE_SEQUENCES[0x0A] = '\\n';
        ESCAPE_SEQUENCES[0x0B] = '\\v';
        ESCAPE_SEQUENCES[0x0C] = '\\f';
        ESCAPE_SEQUENCES[0x0D] = '\\r';
        ESCAPE_SEQUENCES[0x1B] = '\\e';
        ESCAPE_SEQUENCES[0x22] = '\\"';
        ESCAPE_SEQUENCES[0x5C] = '\\\\';
        ESCAPE_SEQUENCES[0x85] = '\\N';
        ESCAPE_SEQUENCES[0xA0] = '\\_';
        ESCAPE_SEQUENCES[0x2028] = '\\L';
        ESCAPE_SEQUENCES[0x2029] = '\\P';
        var DEPRECATED_BOOLEANS_SYNTAX = [
            'y',
            'Y',
            'yes',
            'Yes',
            'YES',
            'on',
            'On',
            'ON',
            'n',
            'N',
            'no',
            'No',
            'NO',
            'off',
            'Off',
            'OFF'
        ];
        var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
        function compileStyleMap(schema, map) {
            var result, keys, index, length, tag, style, type;
            if (null === map) return {};
            result = {};
            keys = Object.keys(map);
            for(index = 0, length = keys.length; index < length; index += 1){
                tag = keys[index];
                style = String(map[tag]);
                if ('!!' === tag.slice(0, 2)) tag = 'tag:yaml.org,2002:' + tag.slice(2);
                type = schema.compiledTypeMap['fallback'][tag];
                if (type && _hasOwnProperty.call(type.styleAliases, style)) style = type.styleAliases[style];
                result[tag] = style;
            }
            return result;
        }
        function encodeHex(character) {
            var string, handle, length;
            string = character.toString(16).toUpperCase();
            if (character <= 0xFF) {
                handle = 'x';
                length = 2;
            } else if (character <= 0xFFFF) {
                handle = 'u';
                length = 4;
            } else if (character <= 0xFFFFFFFF) {
                handle = 'U';
                length = 8;
            } else throw new exception('code point within a string may not be greater than 0xFFFFFFFF');
            return '\\' + handle + common.repeat('0', length - string.length) + string;
        }
        var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
        function State(options) {
            this.schema = options['schema'] || _default;
            this.indent = Math.max(1, options['indent'] || 2);
            this.noArrayIndent = options['noArrayIndent'] || false;
            this.skipInvalid = options['skipInvalid'] || false;
            this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];
            this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
            this.sortKeys = options['sortKeys'] || false;
            this.lineWidth = options['lineWidth'] || 80;
            this.noRefs = options['noRefs'] || false;
            this.noCompatMode = options['noCompatMode'] || false;
            this.condenseFlow = options['condenseFlow'] || false;
            this.quotingType = '"' === options['quotingType'] ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
            this.forceQuotes = options['forceQuotes'] || false;
            this.replacer = 'function' == typeof options['replacer'] ? options['replacer'] : null;
            this.implicitTypes = this.schema.compiledImplicit;
            this.explicitTypes = this.schema.compiledExplicit;
            this.tag = null;
            this.result = '';
            this.duplicates = [];
            this.usedDuplicates = null;
        }
        function indentString(string, spaces) {
            var ind = common.repeat(' ', spaces), position = 0, next = -1, result = '', line, length = string.length;
            while(position < length){
                next = string.indexOf('\n', position);
                if (-1 === next) {
                    line = string.slice(position);
                    position = length;
                } else {
                    line = string.slice(position, next + 1);
                    position = next + 1;
                }
                if (line.length && '\n' !== line) result += ind;
                result += line;
            }
            return result;
        }
        function generateNextLine(state, level) {
            return '\n' + common.repeat(' ', state.indent * level);
        }
        function testImplicitResolving(state, str) {
            var index, length, type;
            for(index = 0, length = state.implicitTypes.length; index < length; index += 1){
                type = state.implicitTypes[index];
                if (type.resolve(str)) return true;
            }
            return false;
        }
        function isWhitespace(c) {
            return c === CHAR_SPACE || c === CHAR_TAB;
        }
        function isPrintable(c) {
            return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && 0x2028 !== c && 0x2029 !== c || 0x0E000 <= c && c <= 0x00FFFD && c !== CHAR_BOM || 0x10000 <= c && c <= 0x10FFFF;
        }
        function isNsCharOrWhitespace(c) {
            return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
        }
        function isPlainSafe(c, prev, inblock) {
            var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
            var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
            return (inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar;
        }
        function isPlainSafeFirst(c) {
            return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
        }
        function isPlainSafeLast(c) {
            return !isWhitespace(c) && c !== CHAR_COLON;
        }
        function codePointAt(string, pos) {
            var first = string.charCodeAt(pos), second;
            if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {
                second = string.charCodeAt(pos + 1);
                if (second >= 0xDC00 && second <= 0xDFFF) return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            }
            return first;
        }
        function needIndentIndicator(string) {
            var leadingSpaceRe = /^\n* /;
            return leadingSpaceRe.test(string);
        }
        var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
        function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
            var i;
            var char = 0;
            var prevChar = null;
            var hasLineBreak = false;
            var hasFoldableLine = false;
            var shouldTrackWidth = -1 !== lineWidth;
            var previousLineBreak = -1;
            var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
            if (singleLineOnly || forceQuotes) for(i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++){
                char = codePointAt(string, i);
                if (!isPrintable(char)) return STYLE_DOUBLE;
                plain = plain && isPlainSafe(char, prevChar, inblock);
                prevChar = char;
            }
            else {
                for(i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++){
                    char = codePointAt(string, i);
                    if (char === CHAR_LINE_FEED) {
                        hasLineBreak = true;
                        if (shouldTrackWidth) {
                            hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && ' ' !== string[previousLineBreak + 1];
                            previousLineBreak = i;
                        }
                    } else if (!isPrintable(char)) return STYLE_DOUBLE;
                    plain = plain && isPlainSafe(char, prevChar, inblock);
                    prevChar = char;
                }
                hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && ' ' !== string[previousLineBreak + 1];
            }
            if (!hasLineBreak && !hasFoldableLine) {
                if (plain && !forceQuotes && !testAmbiguousType(string)) return STYLE_PLAIN;
                return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
            }
            if (indentPerLevel > 9 && needIndentIndicator(string)) return STYLE_DOUBLE;
            if (!forceQuotes) return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
            return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
        }
        function writeScalar(state, string, level, iskey, inblock) {
            state.dump = function() {
                if (0 === string.length) return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
                if (!state.noCompatMode) {
                    if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) || DEPRECATED_BASE60_SYNTAX.test(string)) return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
                }
                var indent = state.indent * Math.max(1, level);
                var lineWidth = -1 === state.lineWidth ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
                var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
                function testAmbiguity(string) {
                    return testImplicitResolving(state, string);
                }
                switch(chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)){
                    case STYLE_PLAIN:
                        return string;
                    case STYLE_SINGLE:
                        return "'" + string.replace(/'/g, "''") + "'";
                    case STYLE_LITERAL:
                        return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
                    case STYLE_FOLDED:
                        return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
                    case STYLE_DOUBLE:
                        return '"' + escapeString(string) + '"';
                    default:
                        throw new exception('impossible error: invalid scalar style');
                }
            }();
        }
        function blockHeader(string, indentPerLevel) {
            var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';
            var clip = '\n' === string[string.length - 1];
            var keep = clip && ('\n' === string[string.length - 2] || '\n' === string);
            var chomp = keep ? '+' : clip ? '' : '-';
            return indentIndicator + chomp + '\n';
        }
        function dropEndingNewline(string) {
            return '\n' === string[string.length - 1] ? string.slice(0, -1) : string;
        }
        function foldString(string, width) {
            var lineRe = /(\n+)([^\n]*)/g;
            var result = function() {
                var nextLF = string.indexOf('\n');
                nextLF = -1 !== nextLF ? nextLF : string.length;
                lineRe.lastIndex = nextLF;
                return foldLine(string.slice(0, nextLF), width);
            }();
            var prevMoreIndented = '\n' === string[0] || ' ' === string[0];
            var moreIndented;
            var match;
            while(match = lineRe.exec(string)){
                var prefix = match[1], line = match[2];
                moreIndented = ' ' === line[0];
                result += prefix + (prevMoreIndented || moreIndented || '' === line ? '' : '\n') + foldLine(line, width);
                prevMoreIndented = moreIndented;
            }
            return result;
        }
        function foldLine(line, width) {
            if ('' === line || ' ' === line[0]) return line;
            var breakRe = / [^ ]/g;
            var match;
            var start = 0, end, curr = 0, next = 0;
            var result = '';
            while(match = breakRe.exec(line)){
                next = match.index;
                if (next - start > width) {
                    end = curr > start ? curr : next;
                    result += '\n' + line.slice(start, end);
                    start = end + 1;
                }
                curr = next;
            }
            result += '\n';
            if (line.length - start > width && curr > start) result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
            else result += line.slice(start);
            return result.slice(1);
        }
        function escapeString(string) {
            var result = '';
            var char = 0;
            var escapeSeq;
            for(var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++){
                char = codePointAt(string, i);
                escapeSeq = ESCAPE_SEQUENCES[char];
                if (!escapeSeq && isPrintable(char)) {
                    result += string[i];
                    if (char >= 0x10000) result += string[i + 1];
                } else result += escapeSeq || encodeHex(char);
            }
            return result;
        }
        function writeFlowSequence(state, level, object) {
            var _result = '', _tag = state.tag, index, length, value;
            for(index = 0, length = object.length; index < length; index += 1){
                value = object[index];
                if (state.replacer) value = state.replacer.call(object, String(index), value);
                if (writeNode(state, level, value, false, false) || void 0 === value && writeNode(state, level, null, false, false)) {
                    if ('' !== _result) _result += ',' + (state.condenseFlow ? '' : ' ');
                    _result += state.dump;
                }
            }
            state.tag = _tag;
            state.dump = '[' + _result + ']';
        }
        function writeBlockSequence(state, level, object, compact) {
            var _result = '', _tag = state.tag, index, length, value;
            for(index = 0, length = object.length; index < length; index += 1){
                value = object[index];
                if (state.replacer) value = state.replacer.call(object, String(index), value);
                if (writeNode(state, level + 1, value, true, true, false, true) || void 0 === value && writeNode(state, level + 1, null, true, true, false, true)) {
                    if (!compact || '' !== _result) _result += generateNextLine(state, level);
                    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) _result += '-';
                    else _result += '- ';
                    _result += state.dump;
                }
            }
            state.tag = _tag;
            state.dump = _result || '[]';
        }
        function writeFlowMapping(state, level, object) {
            var _result = '', _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
            for(index = 0, length = objectKeyList.length; index < length; index += 1){
                pairBuffer = '';
                if ('' !== _result) pairBuffer += ', ';
                if (state.condenseFlow) pairBuffer += '"';
                objectKey = objectKeyList[index];
                objectValue = object[objectKey];
                if (state.replacer) objectValue = state.replacer.call(object, objectKey, objectValue);
                if (writeNode(state, level, objectKey, false, false)) {
                    if (state.dump.length > 1024) pairBuffer += '? ';
                    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');
                    if (writeNode(state, level, objectValue, false, false)) {
                        pairBuffer += state.dump;
                        _result += pairBuffer;
                    }
                }
            }
            state.tag = _tag;
            state.dump = '{' + _result + '}';
        }
        function writeBlockMapping(state, level, object, compact) {
            var _result = '', _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
            if (true === state.sortKeys) objectKeyList.sort();
            else if ('function' == typeof state.sortKeys) objectKeyList.sort(state.sortKeys);
            else if (state.sortKeys) throw new exception('sortKeys must be a boolean or a function');
            for(index = 0, length = objectKeyList.length; index < length; index += 1){
                pairBuffer = '';
                if (!compact || '' !== _result) pairBuffer += generateNextLine(state, level);
                objectKey = objectKeyList[index];
                objectValue = object[objectKey];
                if (state.replacer) objectValue = state.replacer.call(object, objectKey, objectValue);
                if (writeNode(state, level + 1, objectKey, true, true, true)) {
                    explicitPair = null !== state.tag && '?' !== state.tag || state.dump && state.dump.length > 1024;
                    if (explicitPair) if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) pairBuffer += '?';
                    else pairBuffer += '? ';
                    pairBuffer += state.dump;
                    if (explicitPair) pairBuffer += generateNextLine(state, level);
                    if (writeNode(state, level + 1, objectValue, true, explicitPair)) {
                        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) pairBuffer += ':';
                        else pairBuffer += ': ';
                        pairBuffer += state.dump;
                        _result += pairBuffer;
                    }
                }
            }
            state.tag = _tag;
            state.dump = _result || '{}';
        }
        function detectType(state, object, explicit) {
            var _result, typeList, index, length, type, style;
            typeList = explicit ? state.explicitTypes : state.implicitTypes;
            for(index = 0, length = typeList.length; index < length; index += 1){
                type = typeList[index];
                if ((type.instanceOf || type.predicate) && (!type.instanceOf || 'object' == typeof object && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
                    if (explicit) if (type.multi && type.representName) state.tag = type.representName(object);
                    else state.tag = type.tag;
                    else state.tag = '?';
                    if (type.represent) {
                        style = state.styleMap[type.tag] || type.defaultStyle;
                        if ('[object Function]' === _toString.call(type.represent)) _result = type.represent(object, style);
                        else if (_hasOwnProperty.call(type.represent, style)) _result = type.represent[style](object, style);
                        else throw new exception('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
                        state.dump = _result;
                    }
                    return true;
                }
            }
            return false;
        }
        function writeNode(state, level, object, block, compact, iskey, isblockseq) {
            state.tag = null;
            state.dump = object;
            if (!detectType(state, object, false)) detectType(state, object, true);
            var type = _toString.call(state.dump);
            var inblock = block;
            var tagStr;
            if (block) block = state.flowLevel < 0 || state.flowLevel > level;
            var objectOrArray = '[object Object]' === type || '[object Array]' === type, duplicateIndex, duplicate;
            if (objectOrArray) {
                duplicateIndex = state.duplicates.indexOf(object);
                duplicate = -1 !== duplicateIndex;
            }
            if (null !== state.tag && '?' !== state.tag || duplicate || 2 !== state.indent && level > 0) compact = false;
            if (duplicate && state.usedDuplicates[duplicateIndex]) state.dump = '*ref_' + duplicateIndex;
            else {
                if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) state.usedDuplicates[duplicateIndex] = true;
                if ('[object Object]' === type) if (block && 0 !== Object.keys(state.dump).length) {
                    writeBlockMapping(state, level, state.dump, compact);
                    if (duplicate) state.dump = '&ref_' + duplicateIndex + state.dump;
                } else {
                    writeFlowMapping(state, level, state.dump);
                    if (duplicate) state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
                }
                else if ('[object Array]' === type) if (block && 0 !== state.dump.length) {
                    state.noArrayIndent && !isblockseq && level > 0 ? writeBlockSequence(state, level - 1, state.dump, compact) : writeBlockSequence(state, level, state.dump, compact);
                    if (duplicate) state.dump = '&ref_' + duplicateIndex + state.dump;
                } else {
                    writeFlowSequence(state, level, state.dump);
                    if (duplicate) state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
                }
                else if ('[object String]' === type) {
                    if ('?' !== state.tag) writeScalar(state, state.dump, level, iskey, inblock);
                } else {
                    if ('[object Undefined]' === type) return false;
                    if (state.skipInvalid) return false;
                    throw new exception('unacceptable kind of an object to dump ' + type);
                }
                if (null !== state.tag && '?' !== state.tag) {
                    tagStr = encodeURI('!' === state.tag[0] ? state.tag.slice(1) : state.tag).replace(/!/g, '%21');
                    tagStr = '!' === state.tag[0] ? '!' + tagStr : 'tag:yaml.org,2002:' === tagStr.slice(0, 18) ? '!!' + tagStr.slice(18) : '!<' + tagStr + '>';
                    state.dump = tagStr + ' ' + state.dump;
                }
            }
            return true;
        }
        function getDuplicateReferences(object, state) {
            var objects = [], duplicatesIndexes = [], index, length;
            inspectNode(object, objects, duplicatesIndexes);
            for(index = 0, length = duplicatesIndexes.length; index < length; index += 1)state.duplicates.push(objects[duplicatesIndexes[index]]);
            state.usedDuplicates = new Array(length);
        }
        function inspectNode(object, objects, duplicatesIndexes) {
            var objectKeyList, index, length;
            if (null !== object && 'object' == typeof object) {
                index = objects.indexOf(object);
                if (-1 !== index) {
                    if (-1 === duplicatesIndexes.indexOf(index)) duplicatesIndexes.push(index);
                } else {
                    objects.push(object);
                    if (Array.isArray(object)) for(index = 0, length = object.length; index < length; index += 1)inspectNode(object[index], objects, duplicatesIndexes);
                    else {
                        objectKeyList = Object.keys(object);
                        for(index = 0, length = objectKeyList.length; index < length; index += 1)inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
                    }
                }
            }
        }
        function dump$1(input, options) {
            options = options || {};
            var state = new State(options);
            if (!state.noRefs) getDuplicateReferences(input, state);
            var value = input;
            if (state.replacer) value = state.replacer.call({
                '': value
            }, '', value);
            if (writeNode(state, 0, value, true, true)) return state.dump + '\n';
            return '';
        }
        var dump_1 = dump$1;
        var dumper = {
            dump: dump_1
        };
        function renamed(from, to) {
            return function() {
                throw new Error('Function yaml.' + from + " is removed in js-yaml 4. Use yaml." + to + ' instead, which is now safe by default.');
            };
        }
        var Type = type;
        var Schema = schema;
        var FAILSAFE_SCHEMA = failsafe;
        var JSON_SCHEMA = json;
        var CORE_SCHEMA = core;
        var DEFAULT_SCHEMA = _default;
        var load = loader.load;
        var loadAll = loader.loadAll;
        var dump = dumper.dump;
        var YAMLException = exception;
        var types = {
            binary: binary,
            float: float,
            map: map,
            null: _null,
            pairs: pairs,
            set: set,
            timestamp: timestamp,
            bool: bool,
            int: int,
            merge: merge,
            omap: omap,
            seq: seq,
            str: str
        };
        var safeLoad = renamed('safeLoad', 'load');
        var safeLoadAll = renamed('safeLoadAll', 'loadAll');
        var safeDump = renamed('safeDump', 'dump');
        var jsYaml = {
            Type: Type,
            Schema: Schema,
            FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
            JSON_SCHEMA: JSON_SCHEMA,
            CORE_SCHEMA: CORE_SCHEMA,
            DEFAULT_SCHEMA: DEFAULT_SCHEMA,
            load: load,
            loadAll: loadAll,
            dump: dump,
            YAMLException: YAMLException,
            types: types,
            safeLoad: safeLoad,
            safeLoadAll: safeLoadAll,
            safeDump: safeDump
        };
        const __WEBPACK_DEFAULT_EXPORT__ = jsYaml;
    }
};
