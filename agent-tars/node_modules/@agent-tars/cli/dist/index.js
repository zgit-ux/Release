/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
var __webpack_modules__ = {
    "../node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/formats.js": function(__unused_webpack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.formatNames = exports1.fastFormats = exports1.fullFormats = void 0;
        function fmtDef(validate, compare) {
            return {
                validate,
                compare
            };
        }
        exports1.fullFormats = {
            date: fmtDef(date, compareDate),
            time: fmtDef(getTime(true), compareTime),
            "date-time": fmtDef(getDateTime(true), compareDateTime),
            "iso-time": fmtDef(getTime(), compareIsoTime),
            "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
            duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
            uri,
            "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
            "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
            url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
            email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
            hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
            ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
            ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
            regex,
            uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
            "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
            "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
            "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
            byte,
            int32: {
                type: "number",
                validate: validateInt32
            },
            int64: {
                type: "number",
                validate: validateInt64
            },
            float: {
                type: "number",
                validate: validateNumber
            },
            double: {
                type: "number",
                validate: validateNumber
            },
            password: true,
            binary: true
        };
        exports1.fastFormats = {
            ...exports1.fullFormats,
            date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
            time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
            "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
            "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
            "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
            uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
            "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
            email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
        };
        exports1.formatNames = Object.keys(exports1.fullFormats);
        function isLeapYear(year) {
            return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
        }
        const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
        const DAYS = [
            0,
            31,
            28,
            31,
            30,
            31,
            30,
            31,
            31,
            30,
            31,
            30,
            31
        ];
        function date(str) {
            const matches = DATE.exec(str);
            if (!matches) return false;
            const year = +matches[1];
            const month = +matches[2];
            const day = +matches[3];
            return month >= 1 && month <= 12 && day >= 1 && day <= (2 === month && isLeapYear(year) ? 29 : DAYS[month]);
        }
        function compareDate(d1, d2) {
            if (!(d1 && d2)) return;
            if (d1 > d2) return 1;
            if (d1 < d2) return -1;
            return 0;
        }
        const TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
        function getTime(strictTimeZone) {
            return function(str) {
                const matches = TIME.exec(str);
                if (!matches) return false;
                const hr = +matches[1];
                const min = +matches[2];
                const sec = +matches[3];
                const tz = matches[4];
                const tzSign = "-" === matches[5] ? -1 : 1;
                const tzH = +(matches[6] || 0);
                const tzM = +(matches[7] || 0);
                if (tzH > 23 || tzM > 59 || strictTimeZone && !tz) return false;
                if (hr <= 23 && min <= 59 && sec < 60) return true;
                const utcMin = min - tzM * tzSign;
                const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
                return (23 === utcHr || -1 === utcHr) && (59 === utcMin || -1 === utcMin) && sec < 61;
            };
        }
        function compareTime(s1, s2) {
            if (!(s1 && s2)) return;
            const t1 = new Date("2020-01-01T" + s1).valueOf();
            const t2 = new Date("2020-01-01T" + s2).valueOf();
            if (!(t1 && t2)) return;
            return t1 - t2;
        }
        function compareIsoTime(t1, t2) {
            if (!(t1 && t2)) return;
            const a1 = TIME.exec(t1);
            const a2 = TIME.exec(t2);
            if (!(a1 && a2)) return;
            t1 = a1[1] + a1[2] + a1[3];
            t2 = a2[1] + a2[2] + a2[3];
            if (t1 > t2) return 1;
            if (t1 < t2) return -1;
            return 0;
        }
        const DATE_TIME_SEPARATOR = /t|\s/i;
        function getDateTime(strictTimeZone) {
            const time = getTime(strictTimeZone);
            return function(str) {
                const dateTime = str.split(DATE_TIME_SEPARATOR);
                return 2 === dateTime.length && date(dateTime[0]) && time(dateTime[1]);
            };
        }
        function compareDateTime(dt1, dt2) {
            if (!(dt1 && dt2)) return;
            const d1 = new Date(dt1).valueOf();
            const d2 = new Date(dt2).valueOf();
            if (!(d1 && d2)) return;
            return d1 - d2;
        }
        function compareIsoDateTime(dt1, dt2) {
            if (!(dt1 && dt2)) return;
            const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
            const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
            const res = compareDate(d1, d2);
            if (void 0 === res) return;
            return res || compareTime(t1, t2);
        }
        const NOT_URI_FRAGMENT = /\/|:/;
        const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
        function uri(str) {
            return NOT_URI_FRAGMENT.test(str) && URI.test(str);
        }
        const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
        function byte(str) {
            BYTE.lastIndex = 0;
            return BYTE.test(str);
        }
        const MIN_INT32 = -(2 ** 31);
        const MAX_INT32 = 2 ** 31 - 1;
        function validateInt32(value) {
            return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
        }
        function validateInt64(value) {
            return Number.isInteger(value);
        }
        function validateNumber() {
            return true;
        }
        const Z_ANCHOR = /[^\\]\\Z/;
        function regex(str) {
            if (Z_ANCHOR.test(str)) return false;
            try {
                new RegExp(str);
                return true;
            } catch (e) {
                return false;
            }
        }
    },
    "../node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/index.js": function(module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const formats_1 = __webpack_require__("../node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/formats.js");
        const limit_1 = __webpack_require__("../node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/limit.js");
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const fullName = new codegen_1.Name("fullFormats");
        const fastName = new codegen_1.Name("fastFormats");
        const formatsPlugin = (ajv, opts = {
            keywords: true
        })=>{
            if (Array.isArray(opts)) {
                addFormats(ajv, opts, formats_1.fullFormats, fullName);
                return ajv;
            }
            const [formats, exportName] = "fast" === opts.mode ? [
                formats_1.fastFormats,
                fastName
            ] : [
                formats_1.fullFormats,
                fullName
            ];
            const list = opts.formats || formats_1.formatNames;
            addFormats(ajv, list, formats, exportName);
            if (opts.keywords) (0, limit_1.default)(ajv);
            return ajv;
        };
        formatsPlugin.get = (name, mode = "full")=>{
            const formats = "fast" === mode ? formats_1.fastFormats : formats_1.fullFormats;
            const f = formats[name];
            if (!f) throw new Error(`Unknown format "${name}"`);
            return f;
        };
        function addFormats(ajv, list, fs, exportName) {
            var _a;
            var _b;
            null != (_b = ajv.opts.code).formats || (_b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`);
            for (const f of list)ajv.addFormat(f, fs[f]);
        }
        module.exports = exports1 = formatsPlugin;
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1["default"] = formatsPlugin;
    },
    "../node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/limit.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.formatLimitDefinition = void 0;
        const ajv_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/ajv.js");
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const ops = codegen_1.operators;
        const KWDs = {
            formatMaximum: {
                okStr: "<=",
                ok: ops.LTE,
                fail: ops.GT
            },
            formatMinimum: {
                okStr: ">=",
                ok: ops.GTE,
                fail: ops.LT
            },
            formatExclusiveMaximum: {
                okStr: "<",
                ok: ops.LT,
                fail: ops.GTE
            },
            formatExclusiveMinimum: {
                okStr: ">",
                ok: ops.GT,
                fail: ops.LTE
            }
        };
        const error = {
            message: ({ keyword, schemaCode })=>(0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
            params: ({ keyword, schemaCode })=>(0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
        };
        exports1.formatLimitDefinition = {
            keyword: Object.keys(KWDs),
            type: "string",
            schemaType: "string",
            $data: true,
            error,
            code (cxt) {
                const { gen, data, schemaCode, keyword, it } = cxt;
                const { opts, self } = it;
                if (!opts.validateFormats) return;
                const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
                if (fCxt.$data) validate$DataFormat();
                else validateFormat();
                function validate$DataFormat() {
                    const fmts = gen.scopeValue("formats", {
                        ref: self.formats,
                        code: opts.code.formats
                    });
                    const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
                    cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
                }
                function validateFormat() {
                    const format = fCxt.schema;
                    const fmtDef = self.formats[format];
                    if (!fmtDef || true === fmtDef) return;
                    if ("object" != typeof fmtDef || fmtDef instanceof RegExp || "function" != typeof fmtDef.compare) throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
                    const fmt = gen.scopeValue("formats", {
                        key: format,
                        ref: fmtDef,
                        code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : void 0
                    });
                    cxt.fail$data(compareCode(fmt));
                }
                function compareCode(fmt) {
                    return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
                }
            },
            dependencies: [
                "format"
            ]
        };
        const formatLimitPlugin = (ajv)=>{
            ajv.addKeyword(exports1.formatLimitDefinition);
            return ajv;
        };
        exports1["default"] = formatLimitPlugin;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/2020.js": function(module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.MissingRefError = exports1.ValidationError = exports1.CodeGen = exports1.Name = exports1.nil = exports1.stringify = exports1.str = exports1._ = exports1.KeywordCxt = exports1.Ajv2020 = void 0;
        const core_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/core.js");
        const draft2020_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/draft2020.js");
        const discriminator_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/index.js");
        const json_schema_2020_12_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-2020-12/index.js");
        const META_SCHEMA_ID = "https://json-schema.org/draft/2020-12/schema";
        class Ajv2020 extends core_1.default {
            constructor(opts = {}){
                super({
                    ...opts,
                    dynamicRef: true,
                    next: true,
                    unevaluated: true
                });
            }
            _addVocabularies() {
                super._addVocabularies();
                draft2020_1.default.forEach((v)=>this.addVocabulary(v));
                if (this.opts.discriminator) this.addKeyword(discriminator_1.default);
            }
            _addDefaultMetaSchema() {
                super._addDefaultMetaSchema();
                const { $data, meta } = this.opts;
                if (!meta) return;
                json_schema_2020_12_1.default.call(this, $data);
                this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
            }
            defaultMeta() {
                return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
            }
        }
        exports1.Ajv2020 = Ajv2020;
        module.exports = exports1 = Ajv2020;
        module.exports.Ajv2020 = Ajv2020;
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1["default"] = Ajv2020;
        var validate_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js");
        Object.defineProperty(exports1, "KeywordCxt", {
            enumerable: true,
            get: function() {
                return validate_1.KeywordCxt;
            }
        });
        var codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        Object.defineProperty(exports1, "_", {
            enumerable: true,
            get: function() {
                return codegen_1._;
            }
        });
        Object.defineProperty(exports1, "str", {
            enumerable: true,
            get: function() {
                return codegen_1.str;
            }
        });
        Object.defineProperty(exports1, "stringify", {
            enumerable: true,
            get: function() {
                return codegen_1.stringify;
            }
        });
        Object.defineProperty(exports1, "nil", {
            enumerable: true,
            get: function() {
                return codegen_1.nil;
            }
        });
        Object.defineProperty(exports1, "Name", {
            enumerable: true,
            get: function() {
                return codegen_1.Name;
            }
        });
        Object.defineProperty(exports1, "CodeGen", {
            enumerable: true,
            get: function() {
                return codegen_1.CodeGen;
            }
        });
        var validation_error_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js");
        Object.defineProperty(exports1, "ValidationError", {
            enumerable: true,
            get: function() {
                return validation_error_1.default;
            }
        });
        var ref_error_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js");
        Object.defineProperty(exports1, "MissingRefError", {
            enumerable: true,
            get: function() {
                return ref_error_1.default;
            }
        });
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/ajv.js": function(module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.MissingRefError = exports1.ValidationError = exports1.CodeGen = exports1.Name = exports1.nil = exports1.stringify = exports1.str = exports1._ = exports1.KeywordCxt = exports1.Ajv = void 0;
        const core_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/core.js");
        const draft7_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/draft7.js");
        const discriminator_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/index.js");
        const draft7MetaSchema = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-draft-07.json");
        const META_SUPPORT_DATA = [
            "/properties"
        ];
        const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
        class Ajv extends core_1.default {
            _addVocabularies() {
                super._addVocabularies();
                draft7_1.default.forEach((v)=>this.addVocabulary(v));
                if (this.opts.discriminator) this.addKeyword(discriminator_1.default);
            }
            _addDefaultMetaSchema() {
                super._addDefaultMetaSchema();
                if (!this.opts.meta) return;
                const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
                this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
                this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
            }
            defaultMeta() {
                return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
            }
        }
        exports1.Ajv = Ajv;
        module.exports = exports1 = Ajv;
        module.exports.Ajv = Ajv;
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1["default"] = Ajv;
        var validate_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js");
        Object.defineProperty(exports1, "KeywordCxt", {
            enumerable: true,
            get: function() {
                return validate_1.KeywordCxt;
            }
        });
        var codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        Object.defineProperty(exports1, "_", {
            enumerable: true,
            get: function() {
                return codegen_1._;
            }
        });
        Object.defineProperty(exports1, "str", {
            enumerable: true,
            get: function() {
                return codegen_1.str;
            }
        });
        Object.defineProperty(exports1, "stringify", {
            enumerable: true,
            get: function() {
                return codegen_1.stringify;
            }
        });
        Object.defineProperty(exports1, "nil", {
            enumerable: true,
            get: function() {
                return codegen_1.nil;
            }
        });
        Object.defineProperty(exports1, "Name", {
            enumerable: true,
            get: function() {
                return codegen_1.Name;
            }
        });
        Object.defineProperty(exports1, "CodeGen", {
            enumerable: true,
            get: function() {
                return codegen_1.CodeGen;
            }
        });
        var validation_error_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js");
        Object.defineProperty(exports1, "ValidationError", {
            enumerable: true,
            get: function() {
                return validation_error_1.default;
            }
        });
        var ref_error_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js");
        Object.defineProperty(exports1, "MissingRefError", {
            enumerable: true,
            get: function() {
                return ref_error_1.default;
            }
        });
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js": function(__unused_webpack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.regexpCode = exports1.getEsmExportName = exports1.getProperty = exports1.safeStringify = exports1.stringify = exports1.strConcat = exports1.addCodeArg = exports1.str = exports1._ = exports1.nil = exports1._Code = exports1.Name = exports1.IDENTIFIER = exports1._CodeOrName = void 0;
        class _CodeOrName {
        }
        exports1._CodeOrName = _CodeOrName;
        exports1.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
        class Name extends _CodeOrName {
            constructor(s){
                super();
                if (!exports1.IDENTIFIER.test(s)) throw new Error("CodeGen: name must be a valid identifier");
                this.str = s;
            }
            toString() {
                return this.str;
            }
            emptyStr() {
                return false;
            }
            get names() {
                return {
                    [this.str]: 1
                };
            }
        }
        exports1.Name = Name;
        class _Code extends _CodeOrName {
            constructor(code){
                super();
                this._items = "string" == typeof code ? [
                    code
                ] : code;
            }
            toString() {
                return this.str;
            }
            emptyStr() {
                if (this._items.length > 1) return false;
                const item = this._items[0];
                return "" === item || '""' === item;
            }
            get str() {
                var _a;
                return null != (_a = this._str) ? _a : this._str = this._items.reduce((s, c)=>`${s}${c}`, "");
            }
            get names() {
                var _a;
                return null != (_a = this._names) ? _a : this._names = this._items.reduce((names, c)=>{
                    if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1;
                    return names;
                }, {});
            }
        }
        exports1._Code = _Code;
        exports1.nil = new _Code("");
        function _(strs, ...args) {
            const code = [
                strs[0]
            ];
            let i = 0;
            while(i < args.length){
                addCodeArg(code, args[i]);
                code.push(strs[++i]);
            }
            return new _Code(code);
        }
        exports1._ = _;
        const plus = new _Code("+");
        function str(strs, ...args) {
            const expr = [
                safeStringify(strs[0])
            ];
            let i = 0;
            while(i < args.length){
                expr.push(plus);
                addCodeArg(expr, args[i]);
                expr.push(plus, safeStringify(strs[++i]));
            }
            optimize(expr);
            return new _Code(expr);
        }
        exports1.str = str;
        function addCodeArg(code, arg) {
            if (arg instanceof _Code) code.push(...arg._items);
            else if (arg instanceof Name) code.push(arg);
            else code.push(interpolate(arg));
        }
        exports1.addCodeArg = addCodeArg;
        function optimize(expr) {
            let i = 1;
            while(i < expr.length - 1){
                if (expr[i] === plus) {
                    const res = mergeExprItems(expr[i - 1], expr[i + 1]);
                    if (void 0 !== res) {
                        expr.splice(i - 1, 3, res);
                        continue;
                    }
                    expr[i++] = "+";
                }
                i++;
            }
        }
        function mergeExprItems(a, b) {
            if ('""' === b) return a;
            if ('""' === a) return b;
            if ("string" == typeof a) {
                if (b instanceof Name || '"' !== a[a.length - 1]) return;
                if ("string" != typeof b) return `${a.slice(0, -1)}${b}"`;
                if ('"' === b[0]) return a.slice(0, -1) + b.slice(1);
                return;
            }
            if ("string" == typeof b && '"' === b[0] && !(a instanceof Name)) return `"${a}${b.slice(1)}`;
        }
        function strConcat(c1, c2) {
            return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
        }
        exports1.strConcat = strConcat;
        function interpolate(x) {
            return "number" == typeof x || "boolean" == typeof x || null === x ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
        }
        function stringify(x) {
            return new _Code(safeStringify(x));
        }
        exports1.stringify = stringify;
        function safeStringify(x) {
            return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
        }
        exports1.safeStringify = safeStringify;
        function getProperty(key) {
            return "string" == typeof key && exports1.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
        }
        exports1.getProperty = getProperty;
        function getEsmExportName(key) {
            if ("string" == typeof key && exports1.IDENTIFIER.test(key)) return new _Code(`${key}`);
            throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
        }
        exports1.getEsmExportName = getEsmExportName;
        function regexpCode(rx) {
            return new _Code(rx.toString());
        }
        exports1.regexpCode = regexpCode;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.or = exports1.and = exports1.not = exports1.CodeGen = exports1.operators = exports1.varKinds = exports1.ValueScopeName = exports1.ValueScope = exports1.Scope = exports1.Name = exports1.regexpCode = exports1.stringify = exports1.getProperty = exports1.nil = exports1.strConcat = exports1.str = exports1._ = void 0;
        const code_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js");
        const scope_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/scope.js");
        var code_2 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js");
        Object.defineProperty(exports1, "_", {
            enumerable: true,
            get: function() {
                return code_2._;
            }
        });
        Object.defineProperty(exports1, "str", {
            enumerable: true,
            get: function() {
                return code_2.str;
            }
        });
        Object.defineProperty(exports1, "strConcat", {
            enumerable: true,
            get: function() {
                return code_2.strConcat;
            }
        });
        Object.defineProperty(exports1, "nil", {
            enumerable: true,
            get: function() {
                return code_2.nil;
            }
        });
        Object.defineProperty(exports1, "getProperty", {
            enumerable: true,
            get: function() {
                return code_2.getProperty;
            }
        });
        Object.defineProperty(exports1, "stringify", {
            enumerable: true,
            get: function() {
                return code_2.stringify;
            }
        });
        Object.defineProperty(exports1, "regexpCode", {
            enumerable: true,
            get: function() {
                return code_2.regexpCode;
            }
        });
        Object.defineProperty(exports1, "Name", {
            enumerable: true,
            get: function() {
                return code_2.Name;
            }
        });
        var scope_2 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/scope.js");
        Object.defineProperty(exports1, "Scope", {
            enumerable: true,
            get: function() {
                return scope_2.Scope;
            }
        });
        Object.defineProperty(exports1, "ValueScope", {
            enumerable: true,
            get: function() {
                return scope_2.ValueScope;
            }
        });
        Object.defineProperty(exports1, "ValueScopeName", {
            enumerable: true,
            get: function() {
                return scope_2.ValueScopeName;
            }
        });
        Object.defineProperty(exports1, "varKinds", {
            enumerable: true,
            get: function() {
                return scope_2.varKinds;
            }
        });
        exports1.operators = {
            GT: new code_1._Code(">"),
            GTE: new code_1._Code(">="),
            LT: new code_1._Code("<"),
            LTE: new code_1._Code("<="),
            EQ: new code_1._Code("==="),
            NEQ: new code_1._Code("!=="),
            NOT: new code_1._Code("!"),
            OR: new code_1._Code("||"),
            AND: new code_1._Code("&&"),
            ADD: new code_1._Code("+")
        };
        class Node {
            optimizeNodes() {
                return this;
            }
            optimizeNames(_names, _constants) {
                return this;
            }
        }
        class Def extends Node {
            constructor(varKind, name, rhs){
                super();
                this.varKind = varKind;
                this.name = name;
                this.rhs = rhs;
            }
            render({ es5, _n }) {
                const varKind = es5 ? scope_1.varKinds.var : this.varKind;
                const rhs = void 0 === this.rhs ? "" : ` = ${this.rhs}`;
                return `${varKind} ${this.name}${rhs};` + _n;
            }
            optimizeNames(names, constants) {
                if (!names[this.name.str]) return;
                if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants);
                return this;
            }
            get names() {
                return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
            }
        }
        class Assign extends Node {
            constructor(lhs, rhs, sideEffects){
                super();
                this.lhs = lhs;
                this.rhs = rhs;
                this.sideEffects = sideEffects;
            }
            render({ _n }) {
                return `${this.lhs} = ${this.rhs};` + _n;
            }
            optimizeNames(names, constants) {
                if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects) return;
                this.rhs = optimizeExpr(this.rhs, names, constants);
                return this;
            }
            get names() {
                const names = this.lhs instanceof code_1.Name ? {} : {
                    ...this.lhs.names
                };
                return addExprNames(names, this.rhs);
            }
        }
        class AssignOp extends Assign {
            constructor(lhs, op, rhs, sideEffects){
                super(lhs, rhs, sideEffects);
                this.op = op;
            }
            render({ _n }) {
                return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
            }
        }
        class Label extends Node {
            constructor(label){
                super();
                this.label = label;
                this.names = {};
            }
            render({ _n }) {
                return `${this.label}:` + _n;
            }
        }
        class Break extends Node {
            constructor(label){
                super();
                this.label = label;
                this.names = {};
            }
            render({ _n }) {
                const label = this.label ? ` ${this.label}` : "";
                return `break${label};` + _n;
            }
        }
        class Throw extends Node {
            constructor(error){
                super();
                this.error = error;
            }
            render({ _n }) {
                return `throw ${this.error};` + _n;
            }
            get names() {
                return this.error.names;
            }
        }
        class AnyCode extends Node {
            constructor(code){
                super();
                this.code = code;
            }
            render({ _n }) {
                return `${this.code};` + _n;
            }
            optimizeNodes() {
                return `${this.code}` ? this : void 0;
            }
            optimizeNames(names, constants) {
                this.code = optimizeExpr(this.code, names, constants);
                return this;
            }
            get names() {
                return this.code instanceof code_1._CodeOrName ? this.code.names : {};
            }
        }
        class ParentNode extends Node {
            constructor(nodes = []){
                super();
                this.nodes = nodes;
            }
            render(opts) {
                return this.nodes.reduce((code, n)=>code + n.render(opts), "");
            }
            optimizeNodes() {
                const { nodes } = this;
                let i = nodes.length;
                while(i--){
                    const n = nodes[i].optimizeNodes();
                    if (Array.isArray(n)) nodes.splice(i, 1, ...n);
                    else if (n) nodes[i] = n;
                    else nodes.splice(i, 1);
                }
                return nodes.length > 0 ? this : void 0;
            }
            optimizeNames(names, constants) {
                const { nodes } = this;
                let i = nodes.length;
                while(i--){
                    const n = nodes[i];
                    if (n.optimizeNames(names, constants)) continue;
                    subtractNames(names, n.names);
                    nodes.splice(i, 1);
                }
                return nodes.length > 0 ? this : void 0;
            }
            get names() {
                return this.nodes.reduce((names, n)=>addNames(names, n.names), {});
            }
        }
        class BlockNode extends ParentNode {
            render(opts) {
                return "{" + opts._n + super.render(opts) + "}" + opts._n;
            }
        }
        class Root extends ParentNode {
        }
        class Else extends BlockNode {
        }
        Else.kind = "else";
        class If extends BlockNode {
            constructor(condition, nodes){
                super(nodes);
                this.condition = condition;
            }
            render(opts) {
                let code = `if(${this.condition})` + super.render(opts);
                if (this.else) code += "else " + this.else.render(opts);
                return code;
            }
            optimizeNodes() {
                super.optimizeNodes();
                const cond = this.condition;
                if (true === cond) return this.nodes;
                let e = this.else;
                if (e) {
                    const ns = e.optimizeNodes();
                    e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
                }
                if (e) {
                    if (false === cond) return e instanceof If ? e : e.nodes;
                    if (this.nodes.length) return this;
                    return new If(not(cond), e instanceof If ? [
                        e
                    ] : e.nodes);
                }
                if (false === cond || !this.nodes.length) return;
                return this;
            }
            optimizeNames(names, constants) {
                var _a;
                this.else = null == (_a = this.else) ? void 0 : _a.optimizeNames(names, constants);
                if (!(super.optimizeNames(names, constants) || this.else)) return;
                this.condition = optimizeExpr(this.condition, names, constants);
                return this;
            }
            get names() {
                const names = super.names;
                addExprNames(names, this.condition);
                if (this.else) addNames(names, this.else.names);
                return names;
            }
        }
        If.kind = "if";
        class For extends BlockNode {
        }
        For.kind = "for";
        class ForLoop extends For {
            constructor(iteration){
                super();
                this.iteration = iteration;
            }
            render(opts) {
                return `for(${this.iteration})` + super.render(opts);
            }
            optimizeNames(names, constants) {
                if (!super.optimizeNames(names, constants)) return;
                this.iteration = optimizeExpr(this.iteration, names, constants);
                return this;
            }
            get names() {
                return addNames(super.names, this.iteration.names);
            }
        }
        class ForRange extends For {
            constructor(varKind, name, from, to){
                super();
                this.varKind = varKind;
                this.name = name;
                this.from = from;
                this.to = to;
            }
            render(opts) {
                const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
                const { name, from, to } = this;
                return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
            }
            get names() {
                const names = addExprNames(super.names, this.from);
                return addExprNames(names, this.to);
            }
        }
        class ForIter extends For {
            constructor(loop, varKind, name, iterable){
                super();
                this.loop = loop;
                this.varKind = varKind;
                this.name = name;
                this.iterable = iterable;
            }
            render(opts) {
                return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
            }
            optimizeNames(names, constants) {
                if (!super.optimizeNames(names, constants)) return;
                this.iterable = optimizeExpr(this.iterable, names, constants);
                return this;
            }
            get names() {
                return addNames(super.names, this.iterable.names);
            }
        }
        class Func extends BlockNode {
            constructor(name, args, async){
                super();
                this.name = name;
                this.args = args;
                this.async = async;
            }
            render(opts) {
                const _async = this.async ? "async " : "";
                return `${_async}function ${this.name}(${this.args})` + super.render(opts);
            }
        }
        Func.kind = "func";
        class Return extends ParentNode {
            render(opts) {
                return "return " + super.render(opts);
            }
        }
        Return.kind = "return";
        class Try extends BlockNode {
            render(opts) {
                let code = "try" + super.render(opts);
                if (this.catch) code += this.catch.render(opts);
                if (this.finally) code += this.finally.render(opts);
                return code;
            }
            optimizeNodes() {
                var _a, _b;
                super.optimizeNodes();
                null == (_a = this.catch) || _a.optimizeNodes();
                null == (_b = this.finally) || _b.optimizeNodes();
                return this;
            }
            optimizeNames(names, constants) {
                var _a, _b;
                super.optimizeNames(names, constants);
                null == (_a = this.catch) || _a.optimizeNames(names, constants);
                null == (_b = this.finally) || _b.optimizeNames(names, constants);
                return this;
            }
            get names() {
                const names = super.names;
                if (this.catch) addNames(names, this.catch.names);
                if (this.finally) addNames(names, this.finally.names);
                return names;
            }
        }
        class Catch extends BlockNode {
            constructor(error){
                super();
                this.error = error;
            }
            render(opts) {
                return `catch(${this.error})` + super.render(opts);
            }
        }
        Catch.kind = "catch";
        class Finally extends BlockNode {
            render(opts) {
                return "finally" + super.render(opts);
            }
        }
        Finally.kind = "finally";
        class CodeGen {
            constructor(extScope, opts = {}){
                this._values = {};
                this._blockStarts = [];
                this._constants = {};
                this.opts = {
                    ...opts,
                    _n: opts.lines ? "\n" : ""
                };
                this._extScope = extScope;
                this._scope = new scope_1.Scope({
                    parent: extScope
                });
                this._nodes = [
                    new Root()
                ];
            }
            toString() {
                return this._root.render(this.opts);
            }
            name(prefix) {
                return this._scope.name(prefix);
            }
            scopeName(prefix) {
                return this._extScope.name(prefix);
            }
            scopeValue(prefixOrName, value) {
                const name = this._extScope.value(prefixOrName, value);
                const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
                vs.add(name);
                return name;
            }
            getScopeValue(prefix, keyOrRef) {
                return this._extScope.getValue(prefix, keyOrRef);
            }
            scopeRefs(scopeName) {
                return this._extScope.scopeRefs(scopeName, this._values);
            }
            scopeCode() {
                return this._extScope.scopeCode(this._values);
            }
            _def(varKind, nameOrPrefix, rhs, constant) {
                const name = this._scope.toName(nameOrPrefix);
                if (void 0 !== rhs && constant) this._constants[name.str] = rhs;
                this._leafNode(new Def(varKind, name, rhs));
                return name;
            }
            const(nameOrPrefix, rhs, _constant) {
                return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
            }
            let(nameOrPrefix, rhs, _constant) {
                return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
            }
            var(nameOrPrefix, rhs, _constant) {
                return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
            }
            assign(lhs, rhs, sideEffects) {
                return this._leafNode(new Assign(lhs, rhs, sideEffects));
            }
            add(lhs, rhs) {
                return this._leafNode(new AssignOp(lhs, exports1.operators.ADD, rhs));
            }
            code(c) {
                if ("function" == typeof c) c();
                else if (c !== code_1.nil) this._leafNode(new AnyCode(c));
                return this;
            }
            object(...keyValues) {
                const code = [
                    "{"
                ];
                for (const [key, value] of keyValues){
                    if (code.length > 1) code.push(",");
                    code.push(key);
                    if (key !== value || this.opts.es5) {
                        code.push(":");
                        (0, code_1.addCodeArg)(code, value);
                    }
                }
                code.push("}");
                return new code_1._Code(code);
            }
            if(condition, thenBody, elseBody) {
                this._blockNode(new If(condition));
                if (thenBody && elseBody) this.code(thenBody).else().code(elseBody).endIf();
                else if (thenBody) this.code(thenBody).endIf();
                else if (elseBody) throw new Error('CodeGen: "else" body without "then" body');
                return this;
            }
            elseIf(condition) {
                return this._elseNode(new If(condition));
            }
            else() {
                return this._elseNode(new Else());
            }
            endIf() {
                return this._endBlockNode(If, Else);
            }
            _for(node, forBody) {
                this._blockNode(node);
                if (forBody) this.code(forBody).endFor();
                return this;
            }
            for(iteration, forBody) {
                return this._for(new ForLoop(iteration), forBody);
            }
            forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
                const name = this._scope.toName(nameOrPrefix);
                return this._for(new ForRange(varKind, name, from, to), ()=>forBody(name));
            }
            forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
                const name = this._scope.toName(nameOrPrefix);
                if (this.opts.es5) {
                    const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
                    return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i)=>{
                        this.var(name, (0, code_1._)`${arr}[${i}]`);
                        forBody(name);
                    });
                }
                return this._for(new ForIter("of", varKind, name, iterable), ()=>forBody(name));
            }
            forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
                if (this.opts.ownProperties) return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
                const name = this._scope.toName(nameOrPrefix);
                return this._for(new ForIter("in", varKind, name, obj), ()=>forBody(name));
            }
            endFor() {
                return this._endBlockNode(For);
            }
            label(label) {
                return this._leafNode(new Label(label));
            }
            break(label) {
                return this._leafNode(new Break(label));
            }
            return(value) {
                const node = new Return();
                this._blockNode(node);
                this.code(value);
                if (1 !== node.nodes.length) throw new Error('CodeGen: "return" should have one node');
                return this._endBlockNode(Return);
            }
            try(tryBody, catchCode, finallyCode) {
                if (!catchCode && !finallyCode) throw new Error('CodeGen: "try" without "catch" and "finally"');
                const node = new Try();
                this._blockNode(node);
                this.code(tryBody);
                if (catchCode) {
                    const error = this.name("e");
                    this._currNode = node.catch = new Catch(error);
                    catchCode(error);
                }
                if (finallyCode) {
                    this._currNode = node.finally = new Finally();
                    this.code(finallyCode);
                }
                return this._endBlockNode(Catch, Finally);
            }
            throw(error) {
                return this._leafNode(new Throw(error));
            }
            block(body, nodeCount) {
                this._blockStarts.push(this._nodes.length);
                if (body) this.code(body).endBlock(nodeCount);
                return this;
            }
            endBlock(nodeCount) {
                const len = this._blockStarts.pop();
                if (void 0 === len) throw new Error("CodeGen: not in self-balancing block");
                const toClose = this._nodes.length - len;
                if (toClose < 0 || void 0 !== nodeCount && toClose !== nodeCount) throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
                this._nodes.length = len;
                return this;
            }
            func(name, args = code_1.nil, async, funcBody) {
                this._blockNode(new Func(name, args, async));
                if (funcBody) this.code(funcBody).endFunc();
                return this;
            }
            endFunc() {
                return this._endBlockNode(Func);
            }
            optimize(n = 1) {
                while(n-- > 0){
                    this._root.optimizeNodes();
                    this._root.optimizeNames(this._root.names, this._constants);
                }
            }
            _leafNode(node) {
                this._currNode.nodes.push(node);
                return this;
            }
            _blockNode(node) {
                this._currNode.nodes.push(node);
                this._nodes.push(node);
            }
            _endBlockNode(N1, N2) {
                const n = this._currNode;
                if (n instanceof N1 || N2 && n instanceof N2) {
                    this._nodes.pop();
                    return this;
                }
                throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
            }
            _elseNode(node) {
                const n = this._currNode;
                if (!(n instanceof If)) throw new Error('CodeGen: "else" without "if"');
                this._currNode = n.else = node;
                return this;
            }
            get _root() {
                return this._nodes[0];
            }
            get _currNode() {
                const ns = this._nodes;
                return ns[ns.length - 1];
            }
            set _currNode(node) {
                const ns = this._nodes;
                ns[ns.length - 1] = node;
            }
        }
        exports1.CodeGen = CodeGen;
        function addNames(names, from) {
            for(const n in from)names[n] = (names[n] || 0) + (from[n] || 0);
            return names;
        }
        function addExprNames(names, from) {
            return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
        }
        function optimizeExpr(expr, names, constants) {
            if (expr instanceof code_1.Name) return replaceName(expr);
            if (!canOptimize(expr)) return expr;
            return new code_1._Code(expr._items.reduce((items, c)=>{
                if (c instanceof code_1.Name) c = replaceName(c);
                if (c instanceof code_1._Code) items.push(...c._items);
                else items.push(c);
                return items;
            }, []));
            function replaceName(n) {
                const c = constants[n.str];
                if (void 0 === c || 1 !== names[n.str]) return n;
                delete names[n.str];
                return c;
            }
            function canOptimize(e) {
                return e instanceof code_1._Code && e._items.some((c)=>c instanceof code_1.Name && 1 === names[c.str] && void 0 !== constants[c.str]);
            }
        }
        function subtractNames(names, from) {
            for(const n in from)names[n] = (names[n] || 0) - (from[n] || 0);
        }
        function not(x) {
            return "boolean" == typeof x || "number" == typeof x || null === x ? !x : (0, code_1._)`!${par(x)}`;
        }
        exports1.not = not;
        const andCode = mappend(exports1.operators.AND);
        function and(...args) {
            return args.reduce(andCode);
        }
        exports1.and = and;
        const orCode = mappend(exports1.operators.OR);
        function or(...args) {
            return args.reduce(orCode);
        }
        exports1.or = or;
        function mappend(op) {
            return (x, y)=>x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
        }
        function par(x) {
            return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
        }
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/scope.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.ValueScope = exports1.ValueScopeName = exports1.Scope = exports1.varKinds = exports1.UsedValueState = void 0;
        const code_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js");
        class ValueError extends Error {
            constructor(name){
                super(`CodeGen: "code" for ${name} not defined`);
                this.value = name.value;
            }
        }
        var UsedValueState;
        (function(UsedValueState) {
            UsedValueState[UsedValueState["Started"] = 0] = "Started";
            UsedValueState[UsedValueState["Completed"] = 1] = "Completed";
        })(UsedValueState || (exports1.UsedValueState = UsedValueState = {}));
        exports1.varKinds = {
            const: new code_1.Name("const"),
            let: new code_1.Name("let"),
            var: new code_1.Name("var")
        };
        class Scope {
            constructor({ prefixes, parent } = {}){
                this._names = {};
                this._prefixes = prefixes;
                this._parent = parent;
            }
            toName(nameOrPrefix) {
                return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
            }
            name(prefix) {
                return new code_1.Name(this._newName(prefix));
            }
            _newName(prefix) {
                const ng = this._names[prefix] || this._nameGroup(prefix);
                return `${prefix}${ng.index++}`;
            }
            _nameGroup(prefix) {
                var _a, _b;
                if ((null == (_b = null == (_a = this._parent) ? void 0 : _a._prefixes) ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
                return this._names[prefix] = {
                    prefix,
                    index: 0
                };
            }
        }
        exports1.Scope = Scope;
        class ValueScopeName extends code_1.Name {
            constructor(prefix, nameStr){
                super(nameStr);
                this.prefix = prefix;
            }
            setValue(value, { property, itemIndex }) {
                this.value = value;
                this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
            }
        }
        exports1.ValueScopeName = ValueScopeName;
        const line = (0, code_1._)`\n`;
        class ValueScope extends Scope {
            constructor(opts){
                super(opts);
                this._values = {};
                this._scope = opts.scope;
                this.opts = {
                    ...opts,
                    _n: opts.lines ? line : code_1.nil
                };
            }
            get() {
                return this._scope;
            }
            name(prefix) {
                return new ValueScopeName(prefix, this._newName(prefix));
            }
            value(nameOrPrefix, value) {
                var _a;
                if (void 0 === value.ref) throw new Error("CodeGen: ref must be passed in value");
                const name = this.toName(nameOrPrefix);
                const { prefix } = name;
                const valueKey = null != (_a = value.key) ? _a : value.ref;
                let vs = this._values[prefix];
                if (vs) {
                    const _name = vs.get(valueKey);
                    if (_name) return _name;
                } else vs = this._values[prefix] = new Map();
                vs.set(valueKey, name);
                const s = this._scope[prefix] || (this._scope[prefix] = []);
                const itemIndex = s.length;
                s[itemIndex] = value.ref;
                name.setValue(value, {
                    property: prefix,
                    itemIndex
                });
                return name;
            }
            getValue(prefix, keyOrRef) {
                const vs = this._values[prefix];
                if (!vs) return;
                return vs.get(keyOrRef);
            }
            scopeRefs(scopeName, values = this._values) {
                return this._reduceValues(values, (name)=>{
                    if (void 0 === name.scopePath) throw new Error(`CodeGen: name "${name}" has no value`);
                    return (0, code_1._)`${scopeName}${name.scopePath}`;
                });
            }
            scopeCode(values = this._values, usedValues, getCode) {
                return this._reduceValues(values, (name)=>{
                    if (void 0 === name.value) throw new Error(`CodeGen: name "${name}" has no value`);
                    return name.value.code;
                }, usedValues, getCode);
            }
            _reduceValues(values, valueCode, usedValues = {}, getCode) {
                let code = code_1.nil;
                for(const prefix in values){
                    const vs = values[prefix];
                    if (!vs) continue;
                    const nameSet = usedValues[prefix] = usedValues[prefix] || new Map();
                    vs.forEach((name)=>{
                        if (nameSet.has(name)) return;
                        nameSet.set(name, UsedValueState.Started);
                        let c = valueCode(name);
                        if (c) {
                            const def = this.opts.es5 ? exports1.varKinds.var : exports1.varKinds.const;
                            code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
                        } else if (c = null == getCode ? void 0 : getCode(name)) code = (0, code_1._)`${code}${c}${this.opts._n}`;
                        else throw new ValueError(name);
                        nameSet.set(name, UsedValueState.Completed);
                    });
                }
                return code;
            }
        }
        exports1.ValueScope = ValueScope;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.extendErrors = exports1.resetErrorsCount = exports1.reportExtraError = exports1.reportError = exports1.keyword$DataError = exports1.keywordError = void 0;
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const names_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js");
        exports1.keywordError = {
            message: ({ keyword })=>(0, codegen_1.str)`must pass "${keyword}" keyword validation`
        };
        exports1.keyword$DataError = {
            message: ({ keyword, schemaType })=>schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
        };
        function reportError(cxt, error = exports1.keywordError, errorPaths, overrideAllErrors) {
            const { it } = cxt;
            const { gen, compositeRule, allErrors } = it;
            const errObj = errorObjectCode(cxt, error, errorPaths);
            if (null != overrideAllErrors ? overrideAllErrors : compositeRule || allErrors) addError(gen, errObj);
            else returnErrors(it, (0, codegen_1._)`[${errObj}]`);
        }
        exports1.reportError = reportError;
        function reportExtraError(cxt, error = exports1.keywordError, errorPaths) {
            const { it } = cxt;
            const { gen, compositeRule, allErrors } = it;
            const errObj = errorObjectCode(cxt, error, errorPaths);
            addError(gen, errObj);
            if (!(compositeRule || allErrors)) returnErrors(it, names_1.default.vErrors);
        }
        exports1.reportExtraError = reportExtraError;
        function resetErrorsCount(gen, errsCount) {
            gen.assign(names_1.default.errors, errsCount);
            gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, ()=>gen.if(errsCount, ()=>gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), ()=>gen.assign(names_1.default.vErrors, null)));
        }
        exports1.resetErrorsCount = resetErrorsCount;
        function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
            if (void 0 === errsCount) throw new Error("ajv implementation error");
            const err = gen.name("err");
            gen.forRange("i", errsCount, names_1.default.errors, (i)=>{
                gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
                gen.if((0, codegen_1._)`${err}.instancePath === undefined`, ()=>gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
                gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
                if (it.opts.verbose) {
                    gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
                    gen.assign((0, codegen_1._)`${err}.data`, data);
                }
            });
        }
        exports1.extendErrors = extendErrors;
        function addError(gen, errObj) {
            const err = gen.const("err", errObj);
            gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, ()=>gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
            gen.code((0, codegen_1._)`${names_1.default.errors}++`);
        }
        function returnErrors(it, errs) {
            const { gen, validateName, schemaEnv } = it;
            if (schemaEnv.$async) gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
            else {
                gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
                gen.return(false);
            }
        }
        const E = {
            keyword: new codegen_1.Name("keyword"),
            schemaPath: new codegen_1.Name("schemaPath"),
            params: new codegen_1.Name("params"),
            propertyName: new codegen_1.Name("propertyName"),
            message: new codegen_1.Name("message"),
            schema: new codegen_1.Name("schema"),
            parentSchema: new codegen_1.Name("parentSchema")
        };
        function errorObjectCode(cxt, error, errorPaths) {
            const { createErrors } = cxt.it;
            if (false === createErrors) return (0, codegen_1._)`{}`;
            return errorObject(cxt, error, errorPaths);
        }
        function errorObject(cxt, error, errorPaths = {}) {
            const { gen, it } = cxt;
            const keyValues = [
                errorInstancePath(it, errorPaths),
                errorSchemaPath(cxt, errorPaths)
            ];
            extraErrorProps(cxt, error, keyValues);
            return gen.object(...keyValues);
        }
        function errorInstancePath({ errorPath }, { instancePath }) {
            const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
            return [
                names_1.default.instancePath,
                (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)
            ];
        }
        function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
            let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
            if (schemaPath) schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
            return [
                E.schemaPath,
                schPath
            ];
        }
        function extraErrorProps(cxt, { params, message }, keyValues) {
            const { keyword, data, schemaValue, it } = cxt;
            const { opts, propertyName, topSchemaRef, schemaPath } = it;
            keyValues.push([
                E.keyword,
                keyword
            ], [
                E.params,
                "function" == typeof params ? params(cxt) : params || (0, codegen_1._)`{}`
            ]);
            if (opts.messages) keyValues.push([
                E.message,
                "function" == typeof message ? message(cxt) : message
            ]);
            if (opts.verbose) keyValues.push([
                E.schema,
                schemaValue
            ], [
                E.parentSchema,
                (0, codegen_1._)`${topSchemaRef}${schemaPath}`
            ], [
                names_1.default.data,
                data
            ]);
            if (propertyName) keyValues.push([
                E.propertyName,
                propertyName
            ]);
        }
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.resolveSchema = exports1.getCompilingSchema = exports1.resolveRef = exports1.compileSchema = exports1.SchemaEnv = void 0;
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const validation_error_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js");
        const names_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js");
        const resolve_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const validate_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js");
        class SchemaEnv {
            constructor(env){
                var _a;
                this.refs = {};
                this.dynamicAnchors = {};
                let schema;
                if ("object" == typeof env.schema) schema = env.schema;
                this.schema = env.schema;
                this.schemaId = env.schemaId;
                this.root = env.root || this;
                this.baseId = null != (_a = env.baseId) ? _a : (0, resolve_1.normalizeId)(null == schema ? void 0 : schema[env.schemaId || "$id"]);
                this.schemaPath = env.schemaPath;
                this.localRefs = env.localRefs;
                this.meta = env.meta;
                this.$async = null == schema ? void 0 : schema.$async;
                this.refs = {};
            }
        }
        exports1.SchemaEnv = SchemaEnv;
        function compileSchema(sch) {
            const _sch = getCompilingSchema.call(this, sch);
            if (_sch) return _sch;
            const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
            const { es5, lines } = this.opts.code;
            const { ownProperties } = this.opts;
            const gen = new codegen_1.CodeGen(this.scope, {
                es5,
                lines,
                ownProperties
            });
            let _ValidationError;
            if (sch.$async) _ValidationError = gen.scopeValue("Error", {
                ref: validation_error_1.default,
                code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
            });
            const validateName = gen.scopeName("validate");
            sch.validateName = validateName;
            const schemaCxt = {
                gen,
                allErrors: this.opts.allErrors,
                data: names_1.default.data,
                parentData: names_1.default.parentData,
                parentDataProperty: names_1.default.parentDataProperty,
                dataNames: [
                    names_1.default.data
                ],
                dataPathArr: [
                    codegen_1.nil
                ],
                dataLevel: 0,
                dataTypes: [],
                definedProperties: new Set(),
                topSchemaRef: gen.scopeValue("schema", true === this.opts.code.source ? {
                    ref: sch.schema,
                    code: (0, codegen_1.stringify)(sch.schema)
                } : {
                    ref: sch.schema
                }),
                validateName,
                ValidationError: _ValidationError,
                schema: sch.schema,
                schemaEnv: sch,
                rootId,
                baseId: sch.baseId || rootId,
                schemaPath: codegen_1.nil,
                errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
                errorPath: (0, codegen_1._)`""`,
                opts: this.opts,
                self: this
            };
            let sourceCode;
            try {
                this._compilations.add(sch);
                (0, validate_1.validateFunctionCode)(schemaCxt);
                gen.optimize(this.opts.code.optimize);
                const validateCode = gen.toString();
                sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
                if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch);
                const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
                const validate = makeValidate(this, this.scope.get());
                this.scope.value(validateName, {
                    ref: validate
                });
                validate.errors = null;
                validate.schema = sch.schema;
                validate.schemaEnv = sch;
                if (sch.$async) validate.$async = true;
                if (true === this.opts.code.source) validate.source = {
                    validateName,
                    validateCode,
                    scopeValues: gen._values
                };
                if (this.opts.unevaluated) {
                    const { props, items } = schemaCxt;
                    validate.evaluated = {
                        props: props instanceof codegen_1.Name ? void 0 : props,
                        items: items instanceof codegen_1.Name ? void 0 : items,
                        dynamicProps: props instanceof codegen_1.Name,
                        dynamicItems: items instanceof codegen_1.Name
                    };
                    if (validate.source) validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
                }
                sch.validate = validate;
                return sch;
            } catch (e) {
                delete sch.validate;
                delete sch.validateName;
                if (sourceCode) this.logger.error("Error compiling schema, function code:", sourceCode);
                throw e;
            } finally{
                this._compilations.delete(sch);
            }
        }
        exports1.compileSchema = compileSchema;
        function resolveRef(root, baseId, ref) {
            var _a;
            ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
            const schOrFunc = root.refs[ref];
            if (schOrFunc) return schOrFunc;
            let _sch = resolve.call(this, root, ref);
            if (void 0 === _sch) {
                const schema = null == (_a = root.localRefs) ? void 0 : _a[ref];
                const { schemaId } = this.opts;
                if (schema) _sch = new SchemaEnv({
                    schema,
                    schemaId,
                    root,
                    baseId
                });
            }
            if (void 0 === _sch) return;
            return root.refs[ref] = inlineOrCompile.call(this, _sch);
        }
        exports1.resolveRef = resolveRef;
        function inlineOrCompile(sch) {
            if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs)) return sch.schema;
            return sch.validate ? sch : compileSchema.call(this, sch);
        }
        function getCompilingSchema(schEnv) {
            for (const sch of this._compilations)if (sameSchemaEnv(sch, schEnv)) return sch;
        }
        exports1.getCompilingSchema = getCompilingSchema;
        function sameSchemaEnv(s1, s2) {
            return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
        }
        function resolve(root, ref) {
            let sch;
            while("string" == typeof (sch = this.refs[ref]))ref = sch;
            return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
        }
        function resolveSchema(root, ref) {
            const p = this.opts.uriResolver.parse(ref);
            const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
            let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
            if (Object.keys(root.schema).length > 0 && refPath === baseId) return getJsonPointer.call(this, p, root);
            const id = (0, resolve_1.normalizeId)(refPath);
            const schOrRef = this.refs[id] || this.schemas[id];
            if ("string" == typeof schOrRef) {
                const sch = resolveSchema.call(this, root, schOrRef);
                if ("object" != typeof (null == sch ? void 0 : sch.schema)) return;
                return getJsonPointer.call(this, p, sch);
            }
            if ("object" != typeof (null == schOrRef ? void 0 : schOrRef.schema)) return;
            if (!schOrRef.validate) compileSchema.call(this, schOrRef);
            if (id === (0, resolve_1.normalizeId)(ref)) {
                const { schema } = schOrRef;
                const { schemaId } = this.opts;
                const schId = schema[schemaId];
                if (schId) baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
                return new SchemaEnv({
                    schema,
                    schemaId,
                    root,
                    baseId
                });
            }
            return getJsonPointer.call(this, p, schOrRef);
        }
        exports1.resolveSchema = resolveSchema;
        const PREVENT_SCOPE_CHANGE = new Set([
            "properties",
            "patternProperties",
            "enum",
            "dependencies",
            "definitions"
        ]);
        function getJsonPointer(parsedRef, { baseId, schema, root }) {
            var _a;
            if ((null == (_a = parsedRef.fragment) ? void 0 : _a[0]) !== "/") return;
            for (const part of parsedRef.fragment.slice(1).split("/")){
                if ("boolean" == typeof schema) return;
                const partSchema = schema[(0, util_1.unescapeFragment)(part)];
                if (void 0 === partSchema) return;
                schema = partSchema;
                const schId = "object" == typeof schema && schema[this.opts.schemaId];
                if (!PREVENT_SCOPE_CHANGE.has(part) && schId) baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
            }
            let env;
            if ("boolean" != typeof schema && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
                const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
                env = resolveSchema.call(this, root, $ref);
            }
            const { schemaId } = this.opts;
            env = env || new SchemaEnv({
                schema,
                schemaId,
                root,
                baseId
            });
            if (env.schema !== env.root.schema) return env;
        }
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const names = {
            data: new codegen_1.Name("data"),
            valCxt: new codegen_1.Name("valCxt"),
            instancePath: new codegen_1.Name("instancePath"),
            parentData: new codegen_1.Name("parentData"),
            parentDataProperty: new codegen_1.Name("parentDataProperty"),
            rootData: new codegen_1.Name("rootData"),
            dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
            vErrors: new codegen_1.Name("vErrors"),
            errors: new codegen_1.Name("errors"),
            this: new codegen_1.Name("this"),
            self: new codegen_1.Name("self"),
            scope: new codegen_1.Name("scope"),
            json: new codegen_1.Name("json"),
            jsonPos: new codegen_1.Name("jsonPos"),
            jsonLen: new codegen_1.Name("jsonLen"),
            jsonPart: new codegen_1.Name("jsonPart")
        };
        exports1["default"] = names;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const resolve_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js");
        class MissingRefError extends Error {
            constructor(resolver, baseId, ref, msg){
                super(msg || `can't resolve reference ${ref} from id ${baseId}`);
                this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
                this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
            }
        }
        exports1["default"] = MissingRefError;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.getSchemaRefs = exports1.resolveUrl = exports1.normalizeId = exports1._getFullPath = exports1.getFullPath = exports1.inlineRef = void 0;
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const equal = __webpack_require__("../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js");
        const traverse = __webpack_require__("../node_modules/.pnpm/json-schema-traverse@1.0.0/node_modules/json-schema-traverse/index.js");
        const SIMPLE_INLINED = new Set([
            "type",
            "format",
            "pattern",
            "maxLength",
            "minLength",
            "maxProperties",
            "minProperties",
            "maxItems",
            "minItems",
            "maximum",
            "minimum",
            "uniqueItems",
            "multipleOf",
            "required",
            "enum",
            "const"
        ]);
        function inlineRef(schema, limit = true) {
            if ("boolean" == typeof schema) return true;
            if (true === limit) return !hasRef(schema);
            if (!limit) return false;
            return countKeys(schema) <= limit;
        }
        exports1.inlineRef = inlineRef;
        const REF_KEYWORDS = new Set([
            "$ref",
            "$recursiveRef",
            "$recursiveAnchor",
            "$dynamicRef",
            "$dynamicAnchor"
        ]);
        function hasRef(schema) {
            for(const key in schema){
                if (REF_KEYWORDS.has(key)) return true;
                const sch = schema[key];
                if (Array.isArray(sch) && sch.some(hasRef)) return true;
                if ("object" == typeof sch && hasRef(sch)) return true;
            }
            return false;
        }
        function countKeys(schema) {
            let count = 0;
            for(const key in schema){
                if ("$ref" === key) return 1 / 0;
                count++;
                if (!SIMPLE_INLINED.has(key)) {
                    if ("object" == typeof schema[key]) (0, util_1.eachItem)(schema[key], (sch)=>count += countKeys(sch));
                    if (count === 1 / 0) return 1 / 0;
                }
            }
            return count;
        }
        function getFullPath(resolver, id = "", normalize) {
            if (false !== normalize) id = normalizeId(id);
            const p = resolver.parse(id);
            return _getFullPath(resolver, p);
        }
        exports1.getFullPath = getFullPath;
        function _getFullPath(resolver, p) {
            const serialized = resolver.serialize(p);
            return serialized.split("#")[0] + "#";
        }
        exports1._getFullPath = _getFullPath;
        const TRAILING_SLASH_HASH = /#\/?$/;
        function normalizeId(id) {
            return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
        }
        exports1.normalizeId = normalizeId;
        function resolveUrl(resolver, baseId, id) {
            id = normalizeId(id);
            return resolver.resolve(baseId, id);
        }
        exports1.resolveUrl = resolveUrl;
        const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
        function getSchemaRefs(schema, baseId) {
            if ("boolean" == typeof schema) return {};
            const { schemaId, uriResolver } = this.opts;
            const schId = normalizeId(schema[schemaId] || baseId);
            const baseIds = {
                "": schId
            };
            const pathPrefix = getFullPath(uriResolver, schId, false);
            const localRefs = {};
            const schemaRefs = new Set();
            traverse(schema, {
                allKeys: true
            }, (sch, jsonPtr, _, parentJsonPtr)=>{
                if (void 0 === parentJsonPtr) return;
                const fullPath = pathPrefix + jsonPtr;
                let innerBaseId = baseIds[parentJsonPtr];
                if ("string" == typeof sch[schemaId]) innerBaseId = addRef.call(this, sch[schemaId]);
                addAnchor.call(this, sch.$anchor);
                addAnchor.call(this, sch.$dynamicAnchor);
                baseIds[jsonPtr] = innerBaseId;
                function addRef(ref) {
                    const _resolve = this.opts.uriResolver.resolve;
                    ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
                    if (schemaRefs.has(ref)) throw ambiguos(ref);
                    schemaRefs.add(ref);
                    let schOrRef = this.refs[ref];
                    if ("string" == typeof schOrRef) schOrRef = this.refs[schOrRef];
                    if ("object" == typeof schOrRef) checkAmbiguosRef(sch, schOrRef.schema, ref);
                    else if (ref !== normalizeId(fullPath)) if ("#" === ref[0]) {
                        checkAmbiguosRef(sch, localRefs[ref], ref);
                        localRefs[ref] = sch;
                    } else this.refs[ref] = fullPath;
                    return ref;
                }
                function addAnchor(anchor) {
                    if ("string" == typeof anchor) {
                        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor "${anchor}"`);
                        addRef.call(this, `#${anchor}`);
                    }
                }
            });
            return localRefs;
            function checkAmbiguosRef(sch1, sch2, ref) {
                if (void 0 !== sch2 && !equal(sch1, sch2)) throw ambiguos(ref);
            }
            function ambiguos(ref) {
                return new Error(`reference "${ref}" resolves to more than one schema`);
            }
        }
        exports1.getSchemaRefs = getSchemaRefs;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/rules.js": function(__unused_webpack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.getRules = exports1.isJSONType = void 0;
        const _jsonTypes = [
            "string",
            "number",
            "integer",
            "boolean",
            "null",
            "object",
            "array"
        ];
        const jsonTypes = new Set(_jsonTypes);
        function isJSONType(x) {
            return "string" == typeof x && jsonTypes.has(x);
        }
        exports1.isJSONType = isJSONType;
        function getRules() {
            const groups = {
                number: {
                    type: "number",
                    rules: []
                },
                string: {
                    type: "string",
                    rules: []
                },
                array: {
                    type: "array",
                    rules: []
                },
                object: {
                    type: "object",
                    rules: []
                }
            };
            return {
                types: {
                    ...groups,
                    integer: true,
                    boolean: true,
                    null: true
                },
                rules: [
                    {
                        rules: []
                    },
                    groups.number,
                    groups.string,
                    groups.array,
                    groups.object
                ],
                post: {
                    rules: []
                },
                all: {},
                keywords: {}
            };
        }
        exports1.getRules = getRules;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.checkStrictMode = exports1.getErrorPath = exports1.Type = exports1.useFunc = exports1.setEvaluated = exports1.evaluatedPropsToName = exports1.mergeEvaluated = exports1.eachItem = exports1.unescapeJsonPointer = exports1.escapeJsonPointer = exports1.escapeFragment = exports1.unescapeFragment = exports1.schemaRefOrVal = exports1.schemaHasRulesButRef = exports1.schemaHasRules = exports1.checkUnknownRules = exports1.alwaysValidSchema = exports1.toHash = void 0;
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const code_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js");
        function toHash(arr) {
            const hash = {};
            for (const item of arr)hash[item] = true;
            return hash;
        }
        exports1.toHash = toHash;
        function alwaysValidSchema(it, schema) {
            if ("boolean" == typeof schema) return schema;
            if (0 === Object.keys(schema).length) return true;
            checkUnknownRules(it, schema);
            return !schemaHasRules(schema, it.self.RULES.all);
        }
        exports1.alwaysValidSchema = alwaysValidSchema;
        function checkUnknownRules(it, schema = it.schema) {
            const { opts, self } = it;
            if (!opts.strictSchema) return;
            if ("boolean" == typeof schema) return;
            const rules = self.RULES.keywords;
            for(const key in schema)if (!rules[key]) checkStrictMode(it, `unknown keyword: "${key}"`);
        }
        exports1.checkUnknownRules = checkUnknownRules;
        function schemaHasRules(schema, rules) {
            if ("boolean" == typeof schema) return !schema;
            for(const key in schema)if (rules[key]) return true;
            return false;
        }
        exports1.schemaHasRules = schemaHasRules;
        function schemaHasRulesButRef(schema, RULES) {
            if ("boolean" == typeof schema) return !schema;
            for(const key in schema)if ("$ref" !== key && RULES.all[key]) return true;
            return false;
        }
        exports1.schemaHasRulesButRef = schemaHasRulesButRef;
        function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
            if (!$data) {
                if ("number" == typeof schema || "boolean" == typeof schema) return schema;
                if ("string" == typeof schema) return (0, codegen_1._)`${schema}`;
            }
            return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
        }
        exports1.schemaRefOrVal = schemaRefOrVal;
        function unescapeFragment(str) {
            return unescapeJsonPointer(decodeURIComponent(str));
        }
        exports1.unescapeFragment = unescapeFragment;
        function escapeFragment(str) {
            return encodeURIComponent(escapeJsonPointer(str));
        }
        exports1.escapeFragment = escapeFragment;
        function escapeJsonPointer(str) {
            if ("number" == typeof str) return `${str}`;
            return str.replace(/~/g, "~0").replace(/\//g, "~1");
        }
        exports1.escapeJsonPointer = escapeJsonPointer;
        function unescapeJsonPointer(str) {
            return str.replace(/~1/g, "/").replace(/~0/g, "~");
        }
        exports1.unescapeJsonPointer = unescapeJsonPointer;
        function eachItem(xs, f) {
            if (Array.isArray(xs)) for (const x of xs)f(x);
            else f(xs);
        }
        exports1.eachItem = eachItem;
        function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
            return (gen, from, to, toName)=>{
                const res = void 0 === to ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
                return toName !== codegen_1.Name || res instanceof codegen_1.Name ? res : resultToName(gen, res);
            };
        }
        exports1.mergeEvaluated = {
            props: makeMergeEvaluated({
                mergeNames: (gen, from, to)=>gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, ()=>{
                        gen.if((0, codegen_1._)`${from} === true`, ()=>gen.assign(to, true), ()=>gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
                    }),
                mergeToName: (gen, from, to)=>gen.if((0, codegen_1._)`${to} !== true`, ()=>{
                        if (true === from) gen.assign(to, true);
                        else {
                            gen.assign(to, (0, codegen_1._)`${to} || {}`);
                            setEvaluated(gen, to, from);
                        }
                    }),
                mergeValues: (from, to)=>true === from ? true : {
                        ...from,
                        ...to
                    },
                resultToName: evaluatedPropsToName
            }),
            items: makeMergeEvaluated({
                mergeNames: (gen, from, to)=>gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, ()=>gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
                mergeToName: (gen, from, to)=>gen.if((0, codegen_1._)`${to} !== true`, ()=>gen.assign(to, true === from ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
                mergeValues: (from, to)=>true === from ? true : Math.max(from, to),
                resultToName: (gen, items)=>gen.var("items", items)
            })
        };
        function evaluatedPropsToName(gen, ps) {
            if (true === ps) return gen.var("props", true);
            const props = gen.var("props", (0, codegen_1._)`{}`);
            if (void 0 !== ps) setEvaluated(gen, props, ps);
            return props;
        }
        exports1.evaluatedPropsToName = evaluatedPropsToName;
        function setEvaluated(gen, props, ps) {
            Object.keys(ps).forEach((p)=>gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
        }
        exports1.setEvaluated = setEvaluated;
        const snippets = {};
        function useFunc(gen, f) {
            return gen.scopeValue("func", {
                ref: f,
                code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
            });
        }
        exports1.useFunc = useFunc;
        var Type;
        (function(Type) {
            Type[Type["Num"] = 0] = "Num";
            Type[Type["Str"] = 1] = "Str";
        })(Type || (exports1.Type = Type = {}));
        function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
            if (dataProp instanceof codegen_1.Name) {
                const isNumber = dataPropType === Type.Num;
                return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
            }
            return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
        }
        exports1.getErrorPath = getErrorPath;
        function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
            if (!mode) return;
            msg = `strict mode: ${msg}`;
            if (true === mode) throw new Error(msg);
            it.self.logger.warn(msg);
        }
        exports1.checkStrictMode = checkStrictMode;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/applicability.js": function(__unused_webpack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.shouldUseRule = exports1.shouldUseGroup = exports1.schemaHasRulesForType = void 0;
        function schemaHasRulesForType({ schema, self }, type) {
            const group = self.RULES.types[type];
            return group && true !== group && shouldUseGroup(schema, group);
        }
        exports1.schemaHasRulesForType = schemaHasRulesForType;
        function shouldUseGroup(schema, group) {
            return group.rules.some((rule)=>shouldUseRule(schema, rule));
        }
        exports1.shouldUseGroup = shouldUseGroup;
        function shouldUseRule(schema, rule) {
            var _a;
            return void 0 !== schema[rule.keyword] || (null == (_a = rule.definition.implements) ? void 0 : _a.some((kwd)=>void 0 !== schema[kwd]));
        }
        exports1.shouldUseRule = shouldUseRule;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/boolSchema.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.boolOrEmptySchema = exports1.topBoolOrEmptySchema = void 0;
        const errors_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js");
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const names_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js");
        const boolError = {
            message: "boolean schema is false"
        };
        function topBoolOrEmptySchema(it) {
            const { gen, schema, validateName } = it;
            if (false === schema) falseSchemaError(it, false);
            else if ("object" == typeof schema && true === schema.$async) gen.return(names_1.default.data);
            else {
                gen.assign((0, codegen_1._)`${validateName}.errors`, null);
                gen.return(true);
            }
        }
        exports1.topBoolOrEmptySchema = topBoolOrEmptySchema;
        function boolOrEmptySchema(it, valid) {
            const { gen, schema } = it;
            if (false === schema) {
                gen.var(valid, false);
                falseSchemaError(it);
            } else gen.var(valid, true);
        }
        exports1.boolOrEmptySchema = boolOrEmptySchema;
        function falseSchemaError(it, overrideAllErrors) {
            const { gen, data } = it;
            const cxt = {
                gen,
                keyword: "false schema",
                data,
                schema: false,
                schemaCode: false,
                schemaValue: false,
                params: {},
                it
            };
            (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
        }
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.reportTypeError = exports1.checkDataTypes = exports1.checkDataType = exports1.coerceAndCheckDataType = exports1.getJSONTypes = exports1.getSchemaTypes = exports1.DataType = void 0;
        const rules_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/rules.js");
        const applicability_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/applicability.js");
        const errors_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js");
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        var DataType;
        (function(DataType) {
            DataType[DataType["Correct"] = 0] = "Correct";
            DataType[DataType["Wrong"] = 1] = "Wrong";
        })(DataType || (exports1.DataType = DataType = {}));
        function getSchemaTypes(schema) {
            const types = getJSONTypes(schema.type);
            const hasNull = types.includes("null");
            if (hasNull) {
                if (false === schema.nullable) throw new Error("type: null contradicts nullable: false");
            } else {
                if (!types.length && void 0 !== schema.nullable) throw new Error('"nullable" cannot be used without "type"');
                if (true === schema.nullable) types.push("null");
            }
            return types;
        }
        exports1.getSchemaTypes = getSchemaTypes;
        function getJSONTypes(ts) {
            const types = Array.isArray(ts) ? ts : ts ? [
                ts
            ] : [];
            if (types.every(rules_1.isJSONType)) return types;
            throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
        }
        exports1.getJSONTypes = getJSONTypes;
        function coerceAndCheckDataType(it, types) {
            const { gen, data, opts } = it;
            const coerceTo = coerceToTypes(types, opts.coerceTypes);
            const checkTypes = types.length > 0 && !(0 === coerceTo.length && 1 === types.length && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
            if (checkTypes) {
                const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
                gen.if(wrongType, ()=>{
                    if (coerceTo.length) coerceData(it, types, coerceTo);
                    else reportTypeError(it);
                });
            }
            return checkTypes;
        }
        exports1.coerceAndCheckDataType = coerceAndCheckDataType;
        const COERCIBLE = new Set([
            "string",
            "number",
            "integer",
            "boolean",
            "null"
        ]);
        function coerceToTypes(types, coerceTypes) {
            return coerceTypes ? types.filter((t)=>COERCIBLE.has(t) || "array" === coerceTypes && "array" === t) : [];
        }
        function coerceData(it, types, coerceTo) {
            const { gen, data, opts } = it;
            const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
            const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
            if ("array" === opts.coerceTypes) gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, ()=>gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), ()=>gen.assign(coerced, data)));
            gen.if((0, codegen_1._)`${coerced} !== undefined`);
            for (const t of coerceTo)if (COERCIBLE.has(t) || "array" === t && "array" === opts.coerceTypes) coerceSpecificType(t);
            gen.else();
            reportTypeError(it);
            gen.endIf();
            gen.if((0, codegen_1._)`${coerced} !== undefined`, ()=>{
                gen.assign(data, coerced);
                assignParentData(it, coerced);
            });
            function coerceSpecificType(t) {
                switch(t){
                    case "string":
                        gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
                        return;
                    case "number":
                        gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
                        return;
                    case "integer":
                        gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
                        return;
                    case "boolean":
                        gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
                        return;
                    case "null":
                        gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
                        gen.assign(coerced, null);
                        return;
                    case "array":
                        gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
                }
            }
        }
        function assignParentData({ gen, parentData, parentDataProperty }, expr) {
            gen.if((0, codegen_1._)`${parentData} !== undefined`, ()=>gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
        }
        function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
            const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
            let cond;
            switch(dataType){
                case "null":
                    return (0, codegen_1._)`${data} ${EQ} null`;
                case "array":
                    cond = (0, codegen_1._)`Array.isArray(${data})`;
                    break;
                case "object":
                    cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
                    break;
                case "integer":
                    cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
                    break;
                case "number":
                    cond = numCond();
                    break;
                default:
                    return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
            }
            return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
            function numCond(_cond = codegen_1.nil) {
                return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
            }
        }
        exports1.checkDataType = checkDataType;
        function checkDataTypes(dataTypes, data, strictNums, correct) {
            if (1 === dataTypes.length) return checkDataType(dataTypes[0], data, strictNums, correct);
            let cond;
            const types = (0, util_1.toHash)(dataTypes);
            if (types.array && types.object) {
                const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
                cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
                delete types.null;
                delete types.array;
                delete types.object;
            } else cond = codegen_1.nil;
            if (types.number) delete types.integer;
            for(const t in types)cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
            return cond;
        }
        exports1.checkDataTypes = checkDataTypes;
        const typeError = {
            message: ({ schema })=>`must be ${schema}`,
            params: ({ schema, schemaValue })=>"string" == typeof schema ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
        };
        function reportTypeError(it) {
            const cxt = getTypeErrorContext(it);
            (0, errors_1.reportError)(cxt, typeError);
        }
        exports1.reportTypeError = reportTypeError;
        function getTypeErrorContext(it) {
            const { gen, data, schema } = it;
            const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
            return {
                gen,
                keyword: "type",
                data,
                schema: schema.type,
                schemaCode,
                schemaValue: schemaCode,
                parentSchema: schema,
                params: {},
                it
            };
        }
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/defaults.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.assignDefaults = void 0;
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        function assignDefaults(it, ty) {
            const { properties, items } = it.schema;
            if ("object" === ty && properties) for(const key in properties)assignDefault(it, key, properties[key].default);
            else if ("array" === ty && Array.isArray(items)) items.forEach((sch, i)=>assignDefault(it, i, sch.default));
        }
        exports1.assignDefaults = assignDefaults;
        function assignDefault(it, prop, defaultValue) {
            const { gen, compositeRule, data, opts } = it;
            if (void 0 === defaultValue) return;
            const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
            if (compositeRule) return void (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
            let condition = (0, codegen_1._)`${childData} === undefined`;
            if ("empty" === opts.useDefaults) condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
            gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
        }
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.getData = exports1.KeywordCxt = exports1.validateFunctionCode = void 0;
        const boolSchema_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/boolSchema.js");
        const dataType_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js");
        const applicability_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/applicability.js");
        const dataType_2 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js");
        const defaults_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/defaults.js");
        const keyword_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/keyword.js");
        const subschema_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/subschema.js");
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const names_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js");
        const resolve_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const errors_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js");
        function validateFunctionCode(it) {
            if (isSchemaObj(it)) {
                checkKeywords(it);
                if (schemaCxtHasRules(it)) return void topSchemaObjCode(it);
            }
            validateFunction(it, ()=>(0, boolSchema_1.topBoolOrEmptySchema)(it));
        }
        exports1.validateFunctionCode = validateFunctionCode;
        function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
            if (opts.code.es5) gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, ()=>{
                gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
                destructureValCxtES5(gen, opts);
                gen.code(body);
            });
            else gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, ()=>gen.code(funcSourceUrl(schema, opts)).code(body));
        }
        function destructureValCxt(opts) {
            return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
        }
        function destructureValCxtES5(gen, opts) {
            gen.if(names_1.default.valCxt, ()=>{
                gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
                gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
                gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
                gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
                if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
            }, ()=>{
                gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
                gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
                gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
                gen.var(names_1.default.rootData, names_1.default.data);
                if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
            });
        }
        function topSchemaObjCode(it) {
            const { schema, opts, gen } = it;
            validateFunction(it, ()=>{
                if (opts.$comment && schema.$comment) commentKeyword(it);
                checkNoDefault(it);
                gen.let(names_1.default.vErrors, null);
                gen.let(names_1.default.errors, 0);
                if (opts.unevaluated) resetEvaluated(it);
                typeAndKeywords(it);
                returnResults(it);
            });
        }
        function resetEvaluated(it) {
            const { gen, validateName } = it;
            it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
            gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, ()=>gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
            gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, ()=>gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
        }
        function funcSourceUrl(schema, opts) {
            const schId = "object" == typeof schema && schema[opts.schemaId];
            return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
        }
        function subschemaCode(it, valid) {
            if (isSchemaObj(it)) {
                checkKeywords(it);
                if (schemaCxtHasRules(it)) return void subSchemaObjCode(it, valid);
            }
            (0, boolSchema_1.boolOrEmptySchema)(it, valid);
        }
        function schemaCxtHasRules({ schema, self }) {
            if ("boolean" == typeof schema) return !schema;
            for(const key in schema)if (self.RULES.all[key]) return true;
            return false;
        }
        function isSchemaObj(it) {
            return "boolean" != typeof it.schema;
        }
        function subSchemaObjCode(it, valid) {
            const { schema, gen, opts } = it;
            if (opts.$comment && schema.$comment) commentKeyword(it);
            updateContext(it);
            checkAsyncSchema(it);
            const errsCount = gen.const("_errs", names_1.default.errors);
            typeAndKeywords(it, errsCount);
            gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        }
        function checkKeywords(it) {
            (0, util_1.checkUnknownRules)(it);
            checkRefsAndKeywords(it);
        }
        function typeAndKeywords(it, errsCount) {
            if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);
            const types = (0, dataType_1.getSchemaTypes)(it.schema);
            const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
            schemaKeywords(it, types, !checkedTypes, errsCount);
        }
        function checkRefsAndKeywords(it) {
            const { schema, errSchemaPath, opts, self } = it;
            if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
        }
        function checkNoDefault(it) {
            const { schema, opts } = it;
            if (void 0 !== schema.default && opts.useDefaults && opts.strictSchema) (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
        }
        function updateContext(it) {
            const schId = it.schema[it.opts.schemaId];
            if (schId) it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
        }
        function checkAsyncSchema(it) {
            if (it.schema.$async && !it.schemaEnv.$async) throw new Error("async schema in sync schema");
        }
        function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
            const msg = schema.$comment;
            if (true === opts.$comment) gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
            else if ("function" == typeof opts.$comment) {
                const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
                const rootName = gen.scopeValue("root", {
                    ref: schemaEnv.root
                });
                gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
            }
        }
        function returnResults(it) {
            const { gen, schemaEnv, validateName, ValidationError, opts } = it;
            if (schemaEnv.$async) gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, ()=>gen.return(names_1.default.data), ()=>gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
            else {
                gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
                if (opts.unevaluated) assignEvaluated(it);
                gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
            }
        }
        function assignEvaluated({ gen, evaluated, props, items }) {
            if (props instanceof codegen_1.Name) gen.assign((0, codegen_1._)`${evaluated}.props`, props);
            if (items instanceof codegen_1.Name) gen.assign((0, codegen_1._)`${evaluated}.items`, items);
        }
        function schemaKeywords(it, types, typeErrors, errsCount) {
            const { gen, schema, data, allErrors, opts, self } = it;
            const { RULES } = self;
            if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) return void gen.block(()=>keywordCode(it, "$ref", RULES.all.$ref.definition));
            if (!opts.jtd) checkStrictTypes(it, types);
            gen.block(()=>{
                for (const group of RULES.rules)groupKeywords(group);
                groupKeywords(RULES.post);
            });
            function groupKeywords(group) {
                if (!(0, applicability_1.shouldUseGroup)(schema, group)) return;
                if (group.type) {
                    gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
                    iterateKeywords(it, group);
                    if (1 === types.length && types[0] === group.type && typeErrors) {
                        gen.else();
                        (0, dataType_2.reportTypeError)(it);
                    }
                    gen.endIf();
                } else iterateKeywords(it, group);
                if (!allErrors) gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
            }
        }
        function iterateKeywords(it, group) {
            const { gen, schema, opts: { useDefaults } } = it;
            if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type);
            gen.block(()=>{
                for (const rule of group.rules)if ((0, applicability_1.shouldUseRule)(schema, rule)) keywordCode(it, rule.keyword, rule.definition, group.type);
            });
        }
        function checkStrictTypes(it, types) {
            if (it.schemaEnv.meta || !it.opts.strictTypes) return;
            checkContextTypes(it, types);
            if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);
            checkKeywordTypes(it, it.dataTypes);
        }
        function checkContextTypes(it, types) {
            if (!types.length) return;
            if (!it.dataTypes.length) {
                it.dataTypes = types;
                return;
            }
            types.forEach((t)=>{
                if (!includesType(it.dataTypes, t)) strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
            });
            narrowSchemaTypes(it, types);
        }
        function checkMultipleTypes(it, ts) {
            if (ts.length > 1 && !(2 === ts.length && ts.includes("null"))) strictTypesError(it, "use allowUnionTypes to allow union type keyword");
        }
        function checkKeywordTypes(it, ts) {
            const rules = it.self.RULES.all;
            for(const keyword in rules){
                const rule = rules[keyword];
                if ("object" == typeof rule && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
                    const { type } = rule.definition;
                    if (type.length && !type.some((t)=>hasApplicableType(ts, t))) strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
                }
            }
        }
        function hasApplicableType(schTs, kwdT) {
            return schTs.includes(kwdT) || "number" === kwdT && schTs.includes("integer");
        }
        function includesType(ts, t) {
            return ts.includes(t) || "integer" === t && ts.includes("number");
        }
        function narrowSchemaTypes(it, withTypes) {
            const ts = [];
            for (const t of it.dataTypes)if (includesType(withTypes, t)) ts.push(t);
            else if (withTypes.includes("integer") && "number" === t) ts.push("integer");
            it.dataTypes = ts;
        }
        function strictTypesError(it, msg) {
            const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
            msg += ` at "${schemaPath}" (strictTypes)`;
            (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
        }
        class KeywordCxt {
            constructor(it, def, keyword){
                (0, keyword_1.validateKeywordUsage)(it, def, keyword);
                this.gen = it.gen;
                this.allErrors = it.allErrors;
                this.keyword = keyword;
                this.data = it.data;
                this.schema = it.schema[keyword];
                this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
                this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
                this.schemaType = def.schemaType;
                this.parentSchema = it.schema;
                this.params = {};
                this.it = it;
                this.def = def;
                if (this.$data) this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
                else {
                    this.schemaCode = this.schemaValue;
                    if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
                }
                if ("code" in def ? def.trackErrors : false !== def.errors) this.errsCount = it.gen.const("_errs", names_1.default.errors);
            }
            result(condition, successAction, failAction) {
                this.failResult((0, codegen_1.not)(condition), successAction, failAction);
            }
            failResult(condition, successAction, failAction) {
                this.gen.if(condition);
                if (failAction) failAction();
                else this.error();
                if (successAction) {
                    this.gen.else();
                    successAction();
                    if (this.allErrors) this.gen.endIf();
                } else if (this.allErrors) this.gen.endIf();
                else this.gen.else();
            }
            pass(condition, failAction) {
                this.failResult((0, codegen_1.not)(condition), void 0, failAction);
            }
            fail(condition) {
                if (void 0 === condition) {
                    this.error();
                    if (!this.allErrors) this.gen.if(false);
                    return;
                }
                this.gen.if(condition);
                this.error();
                if (this.allErrors) this.gen.endIf();
                else this.gen.else();
            }
            fail$data(condition) {
                if (!this.$data) return this.fail(condition);
                const { schemaCode } = this;
                this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
            }
            error(append, errorParams, errorPaths) {
                if (errorParams) {
                    this.setParams(errorParams);
                    this._error(append, errorPaths);
                    this.setParams({});
                    return;
                }
                this._error(append, errorPaths);
            }
            _error(append, errorPaths) {
                (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
            }
            $dataError() {
                (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
            }
            reset() {
                if (void 0 === this.errsCount) throw new Error('add "trackErrors" to keyword definition');
                (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
            }
            ok(cond) {
                if (!this.allErrors) this.gen.if(cond);
            }
            setParams(obj, assign) {
                if (assign) Object.assign(this.params, obj);
                else this.params = obj;
            }
            block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
                this.gen.block(()=>{
                    this.check$data(valid, $dataValid);
                    codeBlock();
                });
            }
            check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
                if (!this.$data) return;
                const { gen, schemaCode, schemaType, def } = this;
                gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
                if (valid !== codegen_1.nil) gen.assign(valid, true);
                if (schemaType.length || def.validateSchema) {
                    gen.elseIf(this.invalid$data());
                    this.$dataError();
                    if (valid !== codegen_1.nil) gen.assign(valid, false);
                }
                gen.else();
            }
            invalid$data() {
                const { gen, schemaCode, schemaType, def, it } = this;
                return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
                function wrong$DataType() {
                    if (schemaType.length) {
                        if (!(schemaCode instanceof codegen_1.Name)) throw new Error("ajv implementation error");
                        const st = Array.isArray(schemaType) ? schemaType : [
                            schemaType
                        ];
                        return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
                    }
                    return codegen_1.nil;
                }
                function invalid$DataSchema() {
                    if (def.validateSchema) {
                        const validateSchemaRef = gen.scopeValue("validate$data", {
                            ref: def.validateSchema
                        });
                        return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
                    }
                    return codegen_1.nil;
                }
            }
            subschema(appl, valid) {
                const subschema = (0, subschema_1.getSubschema)(this.it, appl);
                (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
                (0, subschema_1.extendSubschemaMode)(subschema, appl);
                const nextContext = {
                    ...this.it,
                    ...subschema,
                    items: void 0,
                    props: void 0
                };
                subschemaCode(nextContext, valid);
                return nextContext;
            }
            mergeEvaluated(schemaCxt, toName) {
                const { it, gen } = this;
                if (!it.opts.unevaluated) return;
                if (true !== it.props && void 0 !== schemaCxt.props) it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
                if (true !== it.items && void 0 !== schemaCxt.items) it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
            }
            mergeValidEvaluated(schemaCxt, valid) {
                const { it, gen } = this;
                if (it.opts.unevaluated && (true !== it.props || true !== it.items)) {
                    gen.if(valid, ()=>this.mergeEvaluated(schemaCxt, codegen_1.Name));
                    return true;
                }
            }
        }
        exports1.KeywordCxt = KeywordCxt;
        function keywordCode(it, keyword, def, ruleType) {
            const cxt = new KeywordCxt(it, def, keyword);
            if ("code" in def) def.code(cxt, ruleType);
            else if (cxt.$data && def.validate) (0, keyword_1.funcKeywordCode)(cxt, def);
            else if ("macro" in def) (0, keyword_1.macroKeywordCode)(cxt, def);
            else if (def.compile || def.validate) (0, keyword_1.funcKeywordCode)(cxt, def);
        }
        const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
        const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
        function getData($data, { dataLevel, dataNames, dataPathArr }) {
            let jsonPointer;
            let data;
            if ("" === $data) return names_1.default.rootData;
            if ("/" === $data[0]) {
                if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`);
                jsonPointer = $data;
                data = names_1.default.rootData;
            } else {
                const matches = RELATIVE_JSON_POINTER.exec($data);
                if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`);
                const up = +matches[1];
                jsonPointer = matches[2];
                if ("#" === jsonPointer) {
                    if (up >= dataLevel) throw new Error(errorMsg("property/index", up));
                    return dataPathArr[dataLevel - up];
                }
                if (up > dataLevel) throw new Error(errorMsg("data", up));
                data = dataNames[dataLevel - up];
                if (!jsonPointer) return data;
            }
            let expr = data;
            const segments = jsonPointer.split("/");
            for (const segment of segments)if (segment) {
                data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
                expr = (0, codegen_1._)`${expr} && ${data}`;
            }
            return expr;
            function errorMsg(pointerType, up) {
                return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
            }
        }
        exports1.getData = getData;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/keyword.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.validateKeywordUsage = exports1.validSchemaType = exports1.funcKeywordCode = exports1.macroKeywordCode = void 0;
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const names_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js");
        const code_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js");
        const errors_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js");
        function macroKeywordCode(cxt, def) {
            const { gen, keyword, schema, parentSchema, it } = cxt;
            const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
            const schemaRef = useKeyword(gen, keyword, macroSchema);
            if (false !== it.opts.validateSchema) it.self.validateSchema(macroSchema, true);
            const valid = gen.name("valid");
            cxt.subschema({
                schema: macroSchema,
                schemaPath: codegen_1.nil,
                errSchemaPath: `${it.errSchemaPath}/${keyword}`,
                topSchemaRef: schemaRef,
                compositeRule: true
            }, valid);
            cxt.pass(valid, ()=>cxt.error(true));
        }
        exports1.macroKeywordCode = macroKeywordCode;
        function funcKeywordCode(cxt, def) {
            var _a;
            const { gen, keyword, schema, parentSchema, $data, it } = cxt;
            checkAsyncKeyword(it, def);
            const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
            const validateRef = useKeyword(gen, keyword, validate);
            const valid = gen.let("valid");
            cxt.block$data(valid, validateKeyword);
            cxt.ok(null != (_a = def.valid) ? _a : valid);
            function validateKeyword() {
                if (false === def.errors) {
                    assignValid();
                    if (def.modifying) modifyData(cxt);
                    reportErrs(()=>cxt.error());
                } else {
                    const ruleErrs = def.async ? validateAsync() : validateSync();
                    if (def.modifying) modifyData(cxt);
                    reportErrs(()=>addErrs(cxt, ruleErrs));
                }
            }
            function validateAsync() {
                const ruleErrs = gen.let("ruleErrs", null);
                gen.try(()=>assignValid((0, codegen_1._)`await `), (e)=>gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, ()=>gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), ()=>gen.throw(e)));
                return ruleErrs;
            }
            function validateSync() {
                const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
                gen.assign(validateErrs, null);
                assignValid(codegen_1.nil);
                return validateErrs;
            }
            function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
                const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
                const passSchema = !("compile" in def && !$data || false === def.schema);
                gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
            }
            function reportErrs(errors) {
                var _a;
                gen.if((0, codegen_1.not)(null != (_a = def.valid) ? _a : valid), errors);
            }
        }
        exports1.funcKeywordCode = funcKeywordCode;
        function modifyData(cxt) {
            const { gen, data, it } = cxt;
            gen.if(it.parentData, ()=>gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
        }
        function addErrs(cxt, errs) {
            const { gen } = cxt;
            gen.if((0, codegen_1._)`Array.isArray(${errs})`, ()=>{
                gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
                (0, errors_1.extendErrors)(cxt);
            }, ()=>cxt.error());
        }
        function checkAsyncKeyword({ schemaEnv }, def) {
            if (def.async && !schemaEnv.$async) throw new Error("async keyword in sync schema");
        }
        function useKeyword(gen, keyword, result) {
            if (void 0 === result) throw new Error(`keyword "${keyword}" failed to compile`);
            return gen.scopeValue("keyword", "function" == typeof result ? {
                ref: result
            } : {
                ref: result,
                code: (0, codegen_1.stringify)(result)
            });
        }
        function validSchemaType(schema, schemaType, allowUndefined = false) {
            return !schemaType.length || schemaType.some((st)=>"array" === st ? Array.isArray(schema) : "object" === st ? schema && "object" == typeof schema && !Array.isArray(schema) : typeof schema == st || allowUndefined && void 0 === schema);
        }
        exports1.validSchemaType = validSchemaType;
        function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
            if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) throw new Error("ajv implementation error");
            const deps = def.dependencies;
            if (null == deps ? void 0 : deps.some((kwd)=>!Object.prototype.hasOwnProperty.call(schema, kwd))) throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
            if (def.validateSchema) {
                const valid = def.validateSchema(schema[keyword]);
                if (!valid) {
                    const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
                    if ("log" === opts.validateSchema) self.logger.error(msg);
                    else throw new Error(msg);
                }
            }
        }
        exports1.validateKeywordUsage = validateKeywordUsage;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/subschema.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.extendSubschemaMode = exports1.extendSubschemaData = exports1.getSubschema = void 0;
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
            if (void 0 !== keyword && void 0 !== schema) throw new Error('both "keyword" and "schema" passed, only one allowed');
            if (void 0 !== keyword) {
                const sch = it.schema[keyword];
                return void 0 === schemaProp ? {
                    schema: sch,
                    schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
                    errSchemaPath: `${it.errSchemaPath}/${keyword}`
                } : {
                    schema: sch[schemaProp],
                    schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
                    errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
                };
            }
            if (void 0 !== schema) {
                if (void 0 === schemaPath || void 0 === errSchemaPath || void 0 === topSchemaRef) throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
                return {
                    schema,
                    schemaPath,
                    topSchemaRef,
                    errSchemaPath
                };
            }
            throw new Error('either "keyword" or "schema" must be passed');
        }
        exports1.getSubschema = getSubschema;
        function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
            if (void 0 !== data && void 0 !== dataProp) throw new Error('both "data" and "dataProp" passed, only one allowed');
            const { gen } = it;
            if (void 0 !== dataProp) {
                const { errorPath, dataPathArr, opts } = it;
                const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
                dataContextProps(nextData);
                subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
                subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
                subschema.dataPathArr = [
                    ...dataPathArr,
                    subschema.parentDataProperty
                ];
            }
            if (void 0 !== data) {
                const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
                dataContextProps(nextData);
                if (void 0 !== propertyName) subschema.propertyName = propertyName;
            }
            if (dataTypes) subschema.dataTypes = dataTypes;
            function dataContextProps(_nextData) {
                subschema.data = _nextData;
                subschema.dataLevel = it.dataLevel + 1;
                subschema.dataTypes = [];
                it.definedProperties = new Set();
                subschema.parentData = it.data;
                subschema.dataNames = [
                    ...it.dataNames,
                    _nextData
                ];
            }
        }
        exports1.extendSubschemaData = extendSubschemaData;
        function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
            if (void 0 !== compositeRule) subschema.compositeRule = compositeRule;
            if (void 0 !== createErrors) subschema.createErrors = createErrors;
            if (void 0 !== allErrors) subschema.allErrors = allErrors;
            subschema.jtdDiscriminator = jtdDiscriminator;
            subschema.jtdMetadata = jtdMetadata;
        }
        exports1.extendSubschemaMode = extendSubschemaMode;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/core.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.CodeGen = exports1.Name = exports1.nil = exports1.stringify = exports1.str = exports1._ = exports1.KeywordCxt = void 0;
        var validate_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js");
        Object.defineProperty(exports1, "KeywordCxt", {
            enumerable: true,
            get: function() {
                return validate_1.KeywordCxt;
            }
        });
        var codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        Object.defineProperty(exports1, "_", {
            enumerable: true,
            get: function() {
                return codegen_1._;
            }
        });
        Object.defineProperty(exports1, "str", {
            enumerable: true,
            get: function() {
                return codegen_1.str;
            }
        });
        Object.defineProperty(exports1, "stringify", {
            enumerable: true,
            get: function() {
                return codegen_1.stringify;
            }
        });
        Object.defineProperty(exports1, "nil", {
            enumerable: true,
            get: function() {
                return codegen_1.nil;
            }
        });
        Object.defineProperty(exports1, "Name", {
            enumerable: true,
            get: function() {
                return codegen_1.Name;
            }
        });
        Object.defineProperty(exports1, "CodeGen", {
            enumerable: true,
            get: function() {
                return codegen_1.CodeGen;
            }
        });
        const validation_error_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js");
        const ref_error_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js");
        const rules_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/rules.js");
        const compile_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js");
        const codegen_2 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const resolve_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js");
        const dataType_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const $dataRefSchema = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/data.json");
        const uri_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/uri.js");
        const defaultRegExp = (str, flags)=>new RegExp(str, flags);
        defaultRegExp.code = "new RegExp";
        const META_IGNORE_OPTIONS = [
            "removeAdditional",
            "useDefaults",
            "coerceTypes"
        ];
        const EXT_SCOPE_NAMES = new Set([
            "validate",
            "serialize",
            "parse",
            "wrapper",
            "root",
            "schema",
            "keyword",
            "pattern",
            "formats",
            "validate$data",
            "func",
            "obj",
            "Error"
        ]);
        const removedOptions = {
            errorDataPath: "",
            format: "`validateFormats: false` can be used instead.",
            nullable: '"nullable" keyword is supported by default.',
            jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
            extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
            missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
            processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
            sourceCode: "Use option `code: {source: true}`",
            strictDefaults: "It is default now, see option `strict`.",
            strictKeywords: "It is default now, see option `strict`.",
            uniqueItems: '"uniqueItems" keyword is always validated.',
            unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
            cache: "Map is used as cache, schema object as key.",
            serialize: "Map is used as cache, schema object as key.",
            ajvErrors: "It is default now."
        };
        const deprecatedOptions = {
            ignoreKeywordsWithRef: "",
            jsPropertySyntax: "",
            unicode: '"minLength"/"maxLength" account for unicode characters by default.'
        };
        const MAX_EXPRESSION = 200;
        function requiredOptions(o) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
            const s = o.strict;
            const _optz = null == (_a = o.code) ? void 0 : _a.optimize;
            const optimize = true === _optz || void 0 === _optz ? 1 : _optz || 0;
            const regExp = null != (_c = null == (_b = o.code) ? void 0 : _b.regExp) ? _c : defaultRegExp;
            const uriResolver = null != (_d = o.uriResolver) ? _d : uri_1.default;
            return {
                strictSchema: null != (_f = null != (_e = o.strictSchema) ? _e : s) ? _f : true,
                strictNumbers: null != (_h = null != (_g = o.strictNumbers) ? _g : s) ? _h : true,
                strictTypes: null != (_k = null != (_j = o.strictTypes) ? _j : s) ? _k : "log",
                strictTuples: null != (_m = null != (_l = o.strictTuples) ? _l : s) ? _m : "log",
                strictRequired: null != (_p = null != (_o = o.strictRequired) ? _o : s) ? _p : false,
                code: o.code ? {
                    ...o.code,
                    optimize,
                    regExp
                } : {
                    optimize,
                    regExp
                },
                loopRequired: null != (_q = o.loopRequired) ? _q : MAX_EXPRESSION,
                loopEnum: null != (_r = o.loopEnum) ? _r : MAX_EXPRESSION,
                meta: null != (_s = o.meta) ? _s : true,
                messages: null != (_t = o.messages) ? _t : true,
                inlineRefs: null != (_u = o.inlineRefs) ? _u : true,
                schemaId: null != (_v = o.schemaId) ? _v : "$id",
                addUsedSchema: null != (_w = o.addUsedSchema) ? _w : true,
                validateSchema: null != (_x = o.validateSchema) ? _x : true,
                validateFormats: null != (_y = o.validateFormats) ? _y : true,
                unicodeRegExp: null != (_z = o.unicodeRegExp) ? _z : true,
                int32range: null != (_0 = o.int32range) ? _0 : true,
                uriResolver: uriResolver
            };
        }
        class Ajv {
            constructor(opts = {}){
                this.schemas = {};
                this.refs = {};
                this.formats = {};
                this._compilations = new Set();
                this._loading = {};
                this._cache = new Map();
                opts = this.opts = {
                    ...opts,
                    ...requiredOptions(opts)
                };
                const { es5, lines } = this.opts.code;
                this.scope = new codegen_2.ValueScope({
                    scope: {},
                    prefixes: EXT_SCOPE_NAMES,
                    es5,
                    lines
                });
                this.logger = getLogger(opts.logger);
                const formatOpt = opts.validateFormats;
                opts.validateFormats = false;
                this.RULES = (0, rules_1.getRules)();
                checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
                checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
                this._metaOpts = getMetaSchemaOptions.call(this);
                if (opts.formats) addInitialFormats.call(this);
                this._addVocabularies();
                this._addDefaultMetaSchema();
                if (opts.keywords) addInitialKeywords.call(this, opts.keywords);
                if ("object" == typeof opts.meta) this.addMetaSchema(opts.meta);
                addInitialSchemas.call(this);
                opts.validateFormats = formatOpt;
            }
            _addVocabularies() {
                this.addKeyword("$async");
            }
            _addDefaultMetaSchema() {
                const { $data, meta, schemaId } = this.opts;
                let _dataRefSchema = $dataRefSchema;
                if ("id" === schemaId) {
                    _dataRefSchema = {
                        ...$dataRefSchema
                    };
                    _dataRefSchema.id = _dataRefSchema.$id;
                    delete _dataRefSchema.$id;
                }
                if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
            }
            defaultMeta() {
                const { meta, schemaId } = this.opts;
                return this.opts.defaultMeta = "object" == typeof meta ? meta[schemaId] || meta : void 0;
            }
            validate(schemaKeyRef, data) {
                let v;
                if ("string" == typeof schemaKeyRef) {
                    v = this.getSchema(schemaKeyRef);
                    if (!v) throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
                } else v = this.compile(schemaKeyRef);
                const valid = v(data);
                if (!("$async" in v)) this.errors = v.errors;
                return valid;
            }
            compile(schema, _meta) {
                const sch = this._addSchema(schema, _meta);
                return sch.validate || this._compileSchemaEnv(sch);
            }
            compileAsync(schema, meta) {
                if ("function" != typeof this.opts.loadSchema) throw new Error("options.loadSchema should be a function");
                const { loadSchema } = this.opts;
                return runCompileAsync.call(this, schema, meta);
                async function runCompileAsync(_schema, _meta) {
                    await loadMetaSchema.call(this, _schema.$schema);
                    const sch = this._addSchema(_schema, _meta);
                    return sch.validate || _compileAsync.call(this, sch);
                }
                async function loadMetaSchema($ref) {
                    if ($ref && !this.getSchema($ref)) await runCompileAsync.call(this, {
                        $ref
                    }, true);
                }
                async function _compileAsync(sch) {
                    try {
                        return this._compileSchemaEnv(sch);
                    } catch (e) {
                        if (!(e instanceof ref_error_1.default)) throw e;
                        checkLoaded.call(this, e);
                        await loadMissingSchema.call(this, e.missingSchema);
                        return _compileAsync.call(this, sch);
                    }
                }
                function checkLoaded({ missingSchema: ref, missingRef }) {
                    if (this.refs[ref]) throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
                }
                async function loadMissingSchema(ref) {
                    const _schema = await _loadSchema.call(this, ref);
                    if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema);
                    if (!this.refs[ref]) this.addSchema(_schema, ref, meta);
                }
                async function _loadSchema(ref) {
                    const p = this._loading[ref];
                    if (p) return p;
                    try {
                        return await (this._loading[ref] = loadSchema(ref));
                    } finally{
                        delete this._loading[ref];
                    }
                }
            }
            addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
                if (Array.isArray(schema)) {
                    for (const sch of schema)this.addSchema(sch, void 0, _meta, _validateSchema);
                    return this;
                }
                let id;
                if ("object" == typeof schema) {
                    const { schemaId } = this.opts;
                    id = schema[schemaId];
                    if (void 0 !== id && "string" != typeof id) throw new Error(`schema ${schemaId} must be string`);
                }
                key = (0, resolve_1.normalizeId)(key || id);
                this._checkUnique(key);
                this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
                return this;
            }
            addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
                this.addSchema(schema, key, true, _validateSchema);
                return this;
            }
            validateSchema(schema, throwOrLogError) {
                if ("boolean" == typeof schema) return true;
                let $schema;
                $schema = schema.$schema;
                if (void 0 !== $schema && "string" != typeof $schema) throw new Error("$schema must be a string");
                $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
                if (!$schema) {
                    this.logger.warn("meta-schema not available");
                    this.errors = null;
                    return true;
                }
                const valid = this.validate($schema, schema);
                if (!valid && throwOrLogError) {
                    const message = "schema is invalid: " + this.errorsText();
                    if ("log" === this.opts.validateSchema) this.logger.error(message);
                    else throw new Error(message);
                }
                return valid;
            }
            getSchema(keyRef) {
                let sch;
                while("string" == typeof (sch = getSchEnv.call(this, keyRef)))keyRef = sch;
                if (void 0 === sch) {
                    const { schemaId } = this.opts;
                    const root = new compile_1.SchemaEnv({
                        schema: {},
                        schemaId
                    });
                    sch = compile_1.resolveSchema.call(this, root, keyRef);
                    if (!sch) return;
                    this.refs[keyRef] = sch;
                }
                return sch.validate || this._compileSchemaEnv(sch);
            }
            removeSchema(schemaKeyRef) {
                if (schemaKeyRef instanceof RegExp) {
                    this._removeAllSchemas(this.schemas, schemaKeyRef);
                    this._removeAllSchemas(this.refs, schemaKeyRef);
                    return this;
                }
                switch(typeof schemaKeyRef){
                    case "undefined":
                        this._removeAllSchemas(this.schemas);
                        this._removeAllSchemas(this.refs);
                        this._cache.clear();
                        return this;
                    case "string":
                        {
                            const sch = getSchEnv.call(this, schemaKeyRef);
                            if ("object" == typeof sch) this._cache.delete(sch.schema);
                            delete this.schemas[schemaKeyRef];
                            delete this.refs[schemaKeyRef];
                            return this;
                        }
                    case "object":
                        {
                            const cacheKey = schemaKeyRef;
                            this._cache.delete(cacheKey);
                            let id = schemaKeyRef[this.opts.schemaId];
                            if (id) {
                                id = (0, resolve_1.normalizeId)(id);
                                delete this.schemas[id];
                                delete this.refs[id];
                            }
                            return this;
                        }
                    default:
                        throw new Error("ajv.removeSchema: invalid parameter");
                }
            }
            addVocabulary(definitions) {
                for (const def of definitions)this.addKeyword(def);
                return this;
            }
            addKeyword(kwdOrDef, def) {
                let keyword;
                if ("string" == typeof kwdOrDef) {
                    keyword = kwdOrDef;
                    if ("object" == typeof def) {
                        this.logger.warn("these parameters are deprecated, see docs for addKeyword");
                        def.keyword = keyword;
                    }
                } else if ("object" == typeof kwdOrDef && void 0 === def) {
                    def = kwdOrDef;
                    keyword = def.keyword;
                    if (Array.isArray(keyword) && !keyword.length) throw new Error("addKeywords: keyword must be string or non-empty array");
                } else throw new Error("invalid addKeywords parameters");
                checkKeyword.call(this, keyword, def);
                if (!def) {
                    (0, util_1.eachItem)(keyword, (kwd)=>addRule.call(this, kwd));
                    return this;
                }
                keywordMetaschema.call(this, def);
                const definition = {
                    ...def,
                    type: (0, dataType_1.getJSONTypes)(def.type),
                    schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
                };
                (0, util_1.eachItem)(keyword, 0 === definition.type.length ? (k)=>addRule.call(this, k, definition) : (k)=>definition.type.forEach((t)=>addRule.call(this, k, definition, t)));
                return this;
            }
            getKeyword(keyword) {
                const rule = this.RULES.all[keyword];
                return "object" == typeof rule ? rule.definition : !!rule;
            }
            removeKeyword(keyword) {
                const { RULES } = this;
                delete RULES.keywords[keyword];
                delete RULES.all[keyword];
                for (const group of RULES.rules){
                    const i = group.rules.findIndex((rule)=>rule.keyword === keyword);
                    if (i >= 0) group.rules.splice(i, 1);
                }
                return this;
            }
            addFormat(name, format) {
                if ("string" == typeof format) format = new RegExp(format);
                this.formats[name] = format;
                return this;
            }
            errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
                if (!errors || 0 === errors.length) return "No errors";
                return errors.map((e)=>`${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg)=>text + separator + msg);
            }
            $dataMetaSchema(metaSchema, keywordsJsonPointers) {
                const rules = this.RULES.all;
                metaSchema = JSON.parse(JSON.stringify(metaSchema));
                for (const jsonPointer of keywordsJsonPointers){
                    const segments = jsonPointer.split("/").slice(1);
                    let keywords = metaSchema;
                    for (const seg of segments)keywords = keywords[seg];
                    for(const key in rules){
                        const rule = rules[key];
                        if ("object" != typeof rule) continue;
                        const { $data } = rule.definition;
                        const schema = keywords[key];
                        if ($data && schema) keywords[key] = schemaOrData(schema);
                    }
                }
                return metaSchema;
            }
            _removeAllSchemas(schemas, regex) {
                for(const keyRef in schemas){
                    const sch = schemas[keyRef];
                    if (!regex || regex.test(keyRef)) {
                        if ("string" == typeof sch) delete schemas[keyRef];
                        else if (sch && !sch.meta) {
                            this._cache.delete(sch.schema);
                            delete schemas[keyRef];
                        }
                    }
                }
            }
            _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
                let id;
                const { schemaId } = this.opts;
                if ("object" == typeof schema) id = schema[schemaId];
                else if (this.opts.jtd) throw new Error("schema must be object");
                else if ("boolean" != typeof schema) throw new Error("schema must be object or boolean");
                let sch = this._cache.get(schema);
                if (void 0 !== sch) return sch;
                baseId = (0, resolve_1.normalizeId)(id || baseId);
                const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
                sch = new compile_1.SchemaEnv({
                    schema,
                    schemaId,
                    meta,
                    baseId,
                    localRefs
                });
                this._cache.set(sch.schema, sch);
                if (addSchema && !baseId.startsWith("#")) {
                    if (baseId) this._checkUnique(baseId);
                    this.refs[baseId] = sch;
                }
                if (validateSchema) this.validateSchema(schema, true);
                return sch;
            }
            _checkUnique(id) {
                if (this.schemas[id] || this.refs[id]) throw new Error(`schema with key or id "${id}" already exists`);
            }
            _compileSchemaEnv(sch) {
                if (sch.meta) this._compileMetaSchema(sch);
                else compile_1.compileSchema.call(this, sch);
                if (!sch.validate) throw new Error("ajv implementation error");
                return sch.validate;
            }
            _compileMetaSchema(sch) {
                const currentOpts = this.opts;
                this.opts = this._metaOpts;
                try {
                    compile_1.compileSchema.call(this, sch);
                } finally{
                    this.opts = currentOpts;
                }
            }
        }
        Ajv.ValidationError = validation_error_1.default;
        Ajv.MissingRefError = ref_error_1.default;
        exports1["default"] = Ajv;
        function checkOptions(checkOpts, options, msg, log = "error") {
            for(const key in checkOpts){
                const opt = key;
                if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
            }
        }
        function getSchEnv(keyRef) {
            keyRef = (0, resolve_1.normalizeId)(keyRef);
            return this.schemas[keyRef] || this.refs[keyRef];
        }
        function addInitialSchemas() {
            const optsSchemas = this.opts.schemas;
            if (!optsSchemas) return;
            if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);
            else for(const key in optsSchemas)this.addSchema(optsSchemas[key], key);
        }
        function addInitialFormats() {
            for(const name in this.opts.formats){
                const format = this.opts.formats[name];
                if (format) this.addFormat(name, format);
            }
        }
        function addInitialKeywords(defs) {
            if (Array.isArray(defs)) return void this.addVocabulary(defs);
            this.logger.warn("keywords option as map is deprecated, pass array");
            for(const keyword in defs){
                const def = defs[keyword];
                if (!def.keyword) def.keyword = keyword;
                this.addKeyword(def);
            }
        }
        function getMetaSchemaOptions() {
            const metaOpts = {
                ...this.opts
            };
            for (const opt of META_IGNORE_OPTIONS)delete metaOpts[opt];
            return metaOpts;
        }
        const noLogs = {
            log () {},
            warn () {},
            error () {}
        };
        function getLogger(logger) {
            if (false === logger) return noLogs;
            if (void 0 === logger) return console;
            if (logger.log && logger.warn && logger.error) return logger;
            throw new Error("logger must implement log, warn and error methods");
        }
        const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
        function checkKeyword(keyword, def) {
            const { RULES } = this;
            (0, util_1.eachItem)(keyword, (kwd)=>{
                if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`);
                if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`);
            });
            if (!def) return;
            if (def.$data && !("code" in def || "validate" in def)) throw new Error('$data keyword must have "code" or "validate" function');
        }
        function addRule(keyword, definition, dataType) {
            var _a;
            const post = null == definition ? void 0 : definition.post;
            if (dataType && post) throw new Error('keyword with "post" flag cannot have "type"');
            const { RULES } = this;
            let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t })=>t === dataType);
            if (!ruleGroup) {
                ruleGroup = {
                    type: dataType,
                    rules: []
                };
                RULES.rules.push(ruleGroup);
            }
            RULES.keywords[keyword] = true;
            if (!definition) return;
            const rule = {
                keyword,
                definition: {
                    ...definition,
                    type: (0, dataType_1.getJSONTypes)(definition.type),
                    schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
                }
            };
            if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before);
            else ruleGroup.rules.push(rule);
            RULES.all[keyword] = rule;
            null == (_a = definition.implements) || _a.forEach((kwd)=>this.addKeyword(kwd));
        }
        function addBeforeRule(ruleGroup, rule, before) {
            const i = ruleGroup.rules.findIndex((_rule)=>_rule.keyword === before);
            if (i >= 0) ruleGroup.rules.splice(i, 0, rule);
            else {
                ruleGroup.rules.push(rule);
                this.logger.warn(`rule ${before} is not defined`);
            }
        }
        function keywordMetaschema(def) {
            let { metaSchema } = def;
            if (void 0 === metaSchema) return;
            if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);
            def.validateSchema = this.compile(metaSchema, true);
        }
        const $dataRef = {
            $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
        };
        function schemaOrData(schema) {
            return {
                anyOf: [
                    schema,
                    $dataRef
                ]
            };
        }
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-2020-12/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const metaSchema = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-2020-12/schema.json");
        const applicator = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-2020-12/meta/applicator.json");
        const unevaluated = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-2020-12/meta/unevaluated.json");
        const content = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-2020-12/meta/content.json");
        const core = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-2020-12/meta/core.json");
        const format = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-2020-12/meta/format-annotation.json");
        const metadata = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-2020-12/meta/meta-data.json");
        const validation = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-2020-12/meta/validation.json");
        const META_SUPPORT_DATA = [
            "/properties"
        ];
        function addMetaSchema2020($data) {
            [
                metaSchema,
                applicator,
                unevaluated,
                content,
                core,
                with$data(this, format),
                metadata,
                with$data(this, validation)
            ].forEach((sch)=>this.addMetaSchema(sch, void 0, false));
            return this;
            function with$data(ajv, sch) {
                return $data ? ajv.$dataMetaSchema(sch, META_SUPPORT_DATA) : sch;
            }
        }
        exports1["default"] = addMetaSchema2020;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/equal.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const equal = __webpack_require__("../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js");
        equal.code = 'require("ajv/dist/runtime/equal").default';
        exports1["default"] = equal;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/ucs2length.js": function(__unused_webpack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        function ucs2length(str) {
            const len = str.length;
            let length = 0;
            let pos = 0;
            let value;
            while(pos < len){
                length++;
                value = str.charCodeAt(pos++);
                if (value >= 0xd800 && value <= 0xdbff && pos < len) {
                    value = str.charCodeAt(pos);
                    if ((0xfc00 & value) === 0xdc00) pos++;
                }
            }
            return length;
        }
        exports1["default"] = ucs2length;
        ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/uri.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const uri = __webpack_require__("../node_modules/.pnpm/fast-uri@3.0.6/node_modules/fast-uri/index.js");
        uri.code = 'require("ajv/dist/runtime/uri").default';
        exports1["default"] = uri;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js": function(__unused_webpack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        class ValidationError extends Error {
            constructor(errors){
                super("validation failed");
                this.errors = errors;
                this.ajv = this.validation = true;
            }
        }
        exports1["default"] = ValidationError;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.validateAdditionalItems = void 0;
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const error = {
            message: ({ params: { len } })=>(0, codegen_1.str)`must NOT have more than ${len} items`,
            params: ({ params: { len } })=>(0, codegen_1._)`{limit: ${len}}`
        };
        const def = {
            keyword: "additionalItems",
            type: "array",
            schemaType: [
                "boolean",
                "object"
            ],
            before: "uniqueItems",
            error,
            code (cxt) {
                const { parentSchema, it } = cxt;
                const { items } = parentSchema;
                if (!Array.isArray(items)) return void (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
                validateAdditionalItems(cxt, items);
            }
        };
        function validateAdditionalItems(cxt, items) {
            const { gen, schema, data, keyword, it } = cxt;
            it.items = true;
            const len = gen.const("len", (0, codegen_1._)`${data}.length`);
            if (false === schema) {
                cxt.setParams({
                    len: items.length
                });
                cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
            } else if ("object" == typeof schema && !(0, util_1.alwaysValidSchema)(it, schema)) {
                const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
                gen.if((0, codegen_1.not)(valid), ()=>validateItems(valid));
                cxt.ok(valid);
            }
            function validateItems(valid) {
                gen.forRange("i", items.length, len, (i)=>{
                    cxt.subschema({
                        keyword,
                        dataProp: i,
                        dataPropType: util_1.Type.Num
                    }, valid);
                    if (!it.allErrors) gen.if((0, codegen_1.not)(valid), ()=>gen.break());
                });
            }
        }
        exports1.validateAdditionalItems = validateAdditionalItems;
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const code_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js");
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const names_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const error = {
            message: "must NOT have additional properties",
            params: ({ params })=>(0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
        };
        const def = {
            keyword: "additionalProperties",
            type: [
                "object"
            ],
            schemaType: [
                "boolean",
                "object"
            ],
            allowUndefined: true,
            trackErrors: true,
            error,
            code (cxt) {
                const { gen, schema, parentSchema, data, errsCount, it } = cxt;
                if (!errsCount) throw new Error("ajv implementation error");
                const { allErrors, opts } = it;
                it.props = true;
                if ("all" !== opts.removeAdditional && (0, util_1.alwaysValidSchema)(it, schema)) return;
                const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
                const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
                checkAdditionalProperties();
                cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
                function checkAdditionalProperties() {
                    gen.forIn("key", data, (key)=>{
                        if (props.length || patProps.length) gen.if(isAdditional(key), ()=>additionalPropertyCode(key));
                        else additionalPropertyCode(key);
                    });
                }
                function isAdditional(key) {
                    let definedProp;
                    if (props.length > 8) {
                        const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
                        definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
                    } else definedProp = props.length ? (0, codegen_1.or)(...props.map((p)=>(0, codegen_1._)`${key} === ${p}`)) : codegen_1.nil;
                    if (patProps.length) definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p)=>(0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
                    return (0, codegen_1.not)(definedProp);
                }
                function deleteAdditional(key) {
                    gen.code((0, codegen_1._)`delete ${data}[${key}]`);
                }
                function additionalPropertyCode(key) {
                    if ("all" === opts.removeAdditional || opts.removeAdditional && false === schema) return void deleteAdditional(key);
                    if (false === schema) {
                        cxt.setParams({
                            additionalProperty: key
                        });
                        cxt.error();
                        if (!allErrors) gen.break();
                        return;
                    }
                    if ("object" == typeof schema && !(0, util_1.alwaysValidSchema)(it, schema)) {
                        const valid = gen.name("valid");
                        if ("failing" === opts.removeAdditional) {
                            applyAdditionalSchema(key, valid, false);
                            gen.if((0, codegen_1.not)(valid), ()=>{
                                cxt.reset();
                                deleteAdditional(key);
                            });
                        } else {
                            applyAdditionalSchema(key, valid);
                            if (!allErrors) gen.if((0, codegen_1.not)(valid), ()=>gen.break());
                        }
                    }
                }
                function applyAdditionalSchema(key, valid, errors) {
                    const subschema = {
                        keyword: "additionalProperties",
                        dataProp: key,
                        dataPropType: util_1.Type.Str
                    };
                    if (false === errors) Object.assign(subschema, {
                        compositeRule: true,
                        createErrors: false,
                        allErrors: false
                    });
                    cxt.subschema(subschema, valid);
                }
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/allOf.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const def = {
            keyword: "allOf",
            schemaType: "array",
            code (cxt) {
                const { gen, schema, it } = cxt;
                if (!Array.isArray(schema)) throw new Error("ajv implementation error");
                const valid = gen.name("valid");
                schema.forEach((sch, i)=>{
                    if ((0, util_1.alwaysValidSchema)(it, sch)) return;
                    const schCxt = cxt.subschema({
                        keyword: "allOf",
                        schemaProp: i
                    }, valid);
                    cxt.ok(valid);
                    cxt.mergeEvaluated(schCxt);
                });
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/anyOf.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const code_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js");
        const def = {
            keyword: "anyOf",
            schemaType: "array",
            trackErrors: true,
            code: code_1.validateUnion,
            error: {
                message: "must match a schema in anyOf"
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/contains.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const error = {
            message: ({ params: { min, max } })=>void 0 === max ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
            params: ({ params: { min, max } })=>void 0 === max ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
        };
        const def = {
            keyword: "contains",
            type: "array",
            schemaType: [
                "object",
                "boolean"
            ],
            before: "uniqueItems",
            trackErrors: true,
            error,
            code (cxt) {
                const { gen, schema, parentSchema, data, it } = cxt;
                let min;
                let max;
                const { minContains, maxContains } = parentSchema;
                if (it.opts.next) {
                    min = void 0 === minContains ? 1 : minContains;
                    max = maxContains;
                } else min = 1;
                const len = gen.const("len", (0, codegen_1._)`${data}.length`);
                cxt.setParams({
                    min,
                    max
                });
                if (void 0 === max && 0 === min) return void (0, util_1.checkStrictMode)(it, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
                if (void 0 !== max && min > max) {
                    (0, util_1.checkStrictMode)(it, '"minContains" > "maxContains" is always invalid');
                    cxt.fail();
                    return;
                }
                if ((0, util_1.alwaysValidSchema)(it, schema)) {
                    let cond = (0, codegen_1._)`${len} >= ${min}`;
                    if (void 0 !== max) cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
                    cxt.pass(cond);
                    return;
                }
                it.items = true;
                const valid = gen.name("valid");
                if (void 0 === max && 1 === min) validateItems(valid, ()=>gen.if(valid, ()=>gen.break()));
                else if (0 === min) {
                    gen.let(valid, true);
                    if (void 0 !== max) gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
                } else {
                    gen.let(valid, false);
                    validateItemsWithCount();
                }
                cxt.result(valid, ()=>cxt.reset());
                function validateItemsWithCount() {
                    const schValid = gen.name("_valid");
                    const count = gen.let("count", 0);
                    validateItems(schValid, ()=>gen.if(schValid, ()=>checkLimits(count)));
                }
                function validateItems(_valid, block) {
                    gen.forRange("i", 0, len, (i)=>{
                        cxt.subschema({
                            keyword: "contains",
                            dataProp: i,
                            dataPropType: util_1.Type.Num,
                            compositeRule: true
                        }, _valid);
                        block();
                    });
                }
                function checkLimits(count) {
                    gen.code((0, codegen_1._)`${count}++`);
                    if (void 0 === max) gen.if((0, codegen_1._)`${count} >= ${min}`, ()=>gen.assign(valid, true).break());
                    else {
                        gen.if((0, codegen_1._)`${count} > ${max}`, ()=>gen.assign(valid, false).break());
                        if (1 === min) gen.assign(valid, true);
                        else gen.if((0, codegen_1._)`${count} >= ${min}`, ()=>gen.assign(valid, true));
                    }
                }
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/dependencies.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.validateSchemaDeps = exports1.validatePropertyDeps = exports1.error = void 0;
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const code_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js");
        exports1.error = {
            message: ({ params: { property, depsCount, deps } })=>{
                const property_ies = 1 === depsCount ? "property" : "properties";
                return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
            },
            params: ({ params: { property, depsCount, deps, missingProperty } })=>(0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
        };
        const def = {
            keyword: "dependencies",
            type: "object",
            schemaType: "object",
            error: exports1.error,
            code (cxt) {
                const [propDeps, schDeps] = splitDependencies(cxt);
                validatePropertyDeps(cxt, propDeps);
                validateSchemaDeps(cxt, schDeps);
            }
        };
        function splitDependencies({ schema }) {
            const propertyDeps = {};
            const schemaDeps = {};
            for(const key in schema){
                if ("__proto__" === key) continue;
                const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
                deps[key] = schema[key];
            }
            return [
                propertyDeps,
                schemaDeps
            ];
        }
        function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
            const { gen, data, it } = cxt;
            if (0 === Object.keys(propertyDeps).length) return;
            const missing = gen.let("missing");
            for(const prop in propertyDeps){
                const deps = propertyDeps[prop];
                if (0 === deps.length) continue;
                const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
                cxt.setParams({
                    property: prop,
                    depsCount: deps.length,
                    deps: deps.join(", ")
                });
                if (it.allErrors) gen.if(hasProperty, ()=>{
                    for (const depProp of deps)(0, code_1.checkReportMissingProp)(cxt, depProp);
                });
                else {
                    gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
                    (0, code_1.reportMissingProp)(cxt, missing);
                    gen.else();
                }
            }
        }
        exports1.validatePropertyDeps = validatePropertyDeps;
        function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
            const { gen, data, keyword, it } = cxt;
            const valid = gen.name("valid");
            for(const prop in schemaDeps)if (!(0, util_1.alwaysValidSchema)(it, schemaDeps[prop])) {
                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), ()=>{
                    const schCxt = cxt.subschema({
                        keyword,
                        schemaProp: prop
                    }, valid);
                    cxt.mergeValidEvaluated(schCxt, valid);
                }, ()=>gen.var(valid, true));
                cxt.ok(valid);
            }
        }
        exports1.validateSchemaDeps = validateSchemaDeps;
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/dependentSchemas.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const dependencies_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/dependencies.js");
        const def = {
            keyword: "dependentSchemas",
            type: "object",
            schemaType: "object",
            code: (cxt)=>(0, dependencies_1.validateSchemaDeps)(cxt)
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/if.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const error = {
            message: ({ params })=>(0, codegen_1.str)`must match "${params.ifClause}" schema`,
            params: ({ params })=>(0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
        };
        const def = {
            keyword: "if",
            schemaType: [
                "object",
                "boolean"
            ],
            trackErrors: true,
            error,
            code (cxt) {
                const { gen, parentSchema, it } = cxt;
                if (void 0 === parentSchema.then && void 0 === parentSchema.else) (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
                const hasThen = hasSchema(it, "then");
                const hasElse = hasSchema(it, "else");
                if (!hasThen && !hasElse) return;
                const valid = gen.let("valid", true);
                const schValid = gen.name("_valid");
                validateIf();
                cxt.reset();
                if (hasThen && hasElse) {
                    const ifClause = gen.let("ifClause");
                    cxt.setParams({
                        ifClause
                    });
                    gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
                } else if (hasThen) gen.if(schValid, validateClause("then"));
                else gen.if((0, codegen_1.not)(schValid), validateClause("else"));
                cxt.pass(valid, ()=>cxt.error(true));
                function validateIf() {
                    const schCxt = cxt.subschema({
                        keyword: "if",
                        compositeRule: true,
                        createErrors: false,
                        allErrors: false
                    }, schValid);
                    cxt.mergeEvaluated(schCxt);
                }
                function validateClause(keyword, ifClause) {
                    return ()=>{
                        const schCxt = cxt.subschema({
                            keyword
                        }, schValid);
                        gen.assign(valid, schValid);
                        cxt.mergeValidEvaluated(schCxt, valid);
                        if (ifClause) gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
                        else cxt.setParams({
                            ifClause: keyword
                        });
                    };
                }
            }
        };
        function hasSchema(it, keyword) {
            const schema = it.schema[keyword];
            return void 0 !== schema && !(0, util_1.alwaysValidSchema)(it, schema);
        }
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const additionalItems_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js");
        const prefixItems_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js");
        const items_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items.js");
        const items2020_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items2020.js");
        const contains_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/contains.js");
        const dependencies_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/dependencies.js");
        const propertyNames_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js");
        const additionalProperties_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js");
        const properties_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/properties.js");
        const patternProperties_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js");
        const not_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/not.js");
        const anyOf_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/anyOf.js");
        const oneOf_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/oneOf.js");
        const allOf_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/allOf.js");
        const if_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/if.js");
        const thenElse_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/thenElse.js");
        function getApplicator(draft2020 = false) {
            const applicator = [
                not_1.default,
                anyOf_1.default,
                oneOf_1.default,
                allOf_1.default,
                if_1.default,
                thenElse_1.default,
                propertyNames_1.default,
                additionalProperties_1.default,
                dependencies_1.default,
                properties_1.default,
                patternProperties_1.default
            ];
            if (draft2020) applicator.push(prefixItems_1.default, items2020_1.default);
            else applicator.push(additionalItems_1.default, items_1.default);
            applicator.push(contains_1.default);
            return applicator;
        }
        exports1["default"] = getApplicator;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.validateTuple = void 0;
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const code_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js");
        const def = {
            keyword: "items",
            type: "array",
            schemaType: [
                "object",
                "array",
                "boolean"
            ],
            before: "uniqueItems",
            code (cxt) {
                const { schema, it } = cxt;
                if (Array.isArray(schema)) return validateTuple(cxt, "additionalItems", schema);
                it.items = true;
                if ((0, util_1.alwaysValidSchema)(it, schema)) return;
                cxt.ok((0, code_1.validateArray)(cxt));
            }
        };
        function validateTuple(cxt, extraItems, schArr = cxt.schema) {
            const { gen, parentSchema, data, keyword, it } = cxt;
            checkStrictTuple(parentSchema);
            if (it.opts.unevaluated && schArr.length && true !== it.items) it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
            const valid = gen.name("valid");
            const len = gen.const("len", (0, codegen_1._)`${data}.length`);
            schArr.forEach((sch, i)=>{
                if ((0, util_1.alwaysValidSchema)(it, sch)) return;
                gen.if((0, codegen_1._)`${len} > ${i}`, ()=>cxt.subschema({
                        keyword,
                        schemaProp: i,
                        dataProp: i
                    }, valid));
                cxt.ok(valid);
            });
            function checkStrictTuple(sch) {
                const { opts, errSchemaPath } = it;
                const l = schArr.length;
                const fullTuple = l === sch.minItems && (l === sch.maxItems || false === sch[extraItems]);
                if (opts.strictTuples && !fullTuple) {
                    const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
                    (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
                }
            }
        }
        exports1.validateTuple = validateTuple;
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items2020.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const code_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js");
        const additionalItems_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js");
        const error = {
            message: ({ params: { len } })=>(0, codegen_1.str)`must NOT have more than ${len} items`,
            params: ({ params: { len } })=>(0, codegen_1._)`{limit: ${len}}`
        };
        const def = {
            keyword: "items",
            type: "array",
            schemaType: [
                "object",
                "boolean"
            ],
            before: "uniqueItems",
            error,
            code (cxt) {
                const { schema, parentSchema, it } = cxt;
                const { prefixItems } = parentSchema;
                it.items = true;
                if ((0, util_1.alwaysValidSchema)(it, schema)) return;
                if (prefixItems) (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
                else cxt.ok((0, code_1.validateArray)(cxt));
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/not.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const def = {
            keyword: "not",
            schemaType: [
                "object",
                "boolean"
            ],
            trackErrors: true,
            code (cxt) {
                const { gen, schema, it } = cxt;
                if ((0, util_1.alwaysValidSchema)(it, schema)) return void cxt.fail();
                const valid = gen.name("valid");
                cxt.subschema({
                    keyword: "not",
                    compositeRule: true,
                    createErrors: false,
                    allErrors: false
                }, valid);
                cxt.failResult(valid, ()=>cxt.reset(), ()=>cxt.error());
            },
            error: {
                message: "must NOT be valid"
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/oneOf.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const error = {
            message: "must match exactly one schema in oneOf",
            params: ({ params })=>(0, codegen_1._)`{passingSchemas: ${params.passing}}`
        };
        const def = {
            keyword: "oneOf",
            schemaType: "array",
            trackErrors: true,
            error,
            code (cxt) {
                const { gen, schema, parentSchema, it } = cxt;
                if (!Array.isArray(schema)) throw new Error("ajv implementation error");
                if (it.opts.discriminator && parentSchema.discriminator) return;
                const schArr = schema;
                const valid = gen.let("valid", false);
                const passing = gen.let("passing", null);
                const schValid = gen.name("_valid");
                cxt.setParams({
                    passing
                });
                gen.block(validateOneOf);
                cxt.result(valid, ()=>cxt.reset(), ()=>cxt.error(true));
                function validateOneOf() {
                    schArr.forEach((sch, i)=>{
                        let schCxt;
                        if ((0, util_1.alwaysValidSchema)(it, sch)) gen.var(schValid, true);
                        else schCxt = cxt.subschema({
                            keyword: "oneOf",
                            schemaProp: i,
                            compositeRule: true
                        }, schValid);
                        if (i > 0) gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
                        gen.if(schValid, ()=>{
                            gen.assign(valid, true);
                            gen.assign(passing, i);
                            if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1.Name);
                        });
                    });
                }
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const code_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js");
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const util_2 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const def = {
            keyword: "patternProperties",
            type: "object",
            schemaType: "object",
            code (cxt) {
                const { gen, schema, data, parentSchema, it } = cxt;
                const { opts } = it;
                const patterns = (0, code_1.allSchemaProperties)(schema);
                const alwaysValidPatterns = patterns.filter((p)=>(0, util_1.alwaysValidSchema)(it, schema[p]));
                if (0 === patterns.length || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || true === it.props)) return;
                const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
                const valid = gen.name("valid");
                if (true !== it.props && !(it.props instanceof codegen_1.Name)) it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
                const { props } = it;
                validatePatternProperties();
                function validatePatternProperties() {
                    for (const pat of patterns){
                        if (checkProperties) checkMatchingProperties(pat);
                        if (it.allErrors) validateProperties(pat);
                        else {
                            gen.var(valid, true);
                            validateProperties(pat);
                            gen.if(valid);
                        }
                    }
                }
                function checkMatchingProperties(pat) {
                    for(const prop in checkProperties)if (new RegExp(pat).test(prop)) (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
                }
                function validateProperties(pat) {
                    gen.forIn("key", data, (key)=>{
                        gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, ()=>{
                            const alwaysValid = alwaysValidPatterns.includes(pat);
                            if (!alwaysValid) cxt.subschema({
                                keyword: "patternProperties",
                                schemaProp: pat,
                                dataProp: key,
                                dataPropType: util_2.Type.Str
                            }, valid);
                            if (it.opts.unevaluated && true !== props) gen.assign((0, codegen_1._)`${props}[${key}]`, true);
                            else if (!alwaysValid && !it.allErrors) gen.if((0, codegen_1.not)(valid), ()=>gen.break());
                        });
                    });
                }
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const items_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items.js");
        const def = {
            keyword: "prefixItems",
            type: "array",
            schemaType: [
                "array"
            ],
            before: "uniqueItems",
            code: (cxt)=>(0, items_1.validateTuple)(cxt, "items")
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/properties.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const validate_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js");
        const code_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const additionalProperties_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js");
        const def = {
            keyword: "properties",
            type: "object",
            schemaType: "object",
            code (cxt) {
                const { gen, schema, parentSchema, data, it } = cxt;
                if ("all" === it.opts.removeAdditional && void 0 === parentSchema.additionalProperties) additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
                const allProps = (0, code_1.allSchemaProperties)(schema);
                for (const prop of allProps)it.definedProperties.add(prop);
                if (it.opts.unevaluated && allProps.length && true !== it.props) it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
                const properties = allProps.filter((p)=>!(0, util_1.alwaysValidSchema)(it, schema[p]));
                if (0 === properties.length) return;
                const valid = gen.name("valid");
                for (const prop of properties){
                    if (hasDefault(prop)) applyPropertySchema(prop);
                    else {
                        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
                        applyPropertySchema(prop);
                        if (!it.allErrors) gen.else().var(valid, true);
                        gen.endIf();
                    }
                    cxt.it.definedProperties.add(prop);
                    cxt.ok(valid);
                }
                function hasDefault(prop) {
                    return it.opts.useDefaults && !it.compositeRule && void 0 !== schema[prop].default;
                }
                function applyPropertySchema(prop) {
                    cxt.subschema({
                        keyword: "properties",
                        schemaProp: prop,
                        dataProp: prop
                    }, valid);
                }
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const error = {
            message: "property name must be valid",
            params: ({ params })=>(0, codegen_1._)`{propertyName: ${params.propertyName}}`
        };
        const def = {
            keyword: "propertyNames",
            type: "object",
            schemaType: [
                "object",
                "boolean"
            ],
            error,
            code (cxt) {
                const { gen, schema, data, it } = cxt;
                if ((0, util_1.alwaysValidSchema)(it, schema)) return;
                const valid = gen.name("valid");
                gen.forIn("key", data, (key)=>{
                    cxt.setParams({
                        propertyName: key
                    });
                    cxt.subschema({
                        keyword: "propertyNames",
                        data: key,
                        dataTypes: [
                            "string"
                        ],
                        propertyName: key,
                        compositeRule: true
                    }, valid);
                    gen.if((0, codegen_1.not)(valid), ()=>{
                        cxt.error(true);
                        if (!it.allErrors) gen.break();
                    });
                });
                cxt.ok(valid);
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/thenElse.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const def = {
            keyword: [
                "then",
                "else"
            ],
            schemaType: [
                "object",
                "boolean"
            ],
            code ({ keyword, parentSchema, it }) {
                if (void 0 === parentSchema.if) (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.validateUnion = exports1.validateArray = exports1.usePattern = exports1.callValidateCode = exports1.schemaProperties = exports1.allSchemaProperties = exports1.noPropertyInData = exports1.propertyInData = exports1.isOwnProperty = exports1.hasPropFunc = exports1.reportMissingProp = exports1.checkMissingProp = exports1.checkReportMissingProp = void 0;
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const names_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js");
        const util_2 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        function checkReportMissingProp(cxt, prop) {
            const { gen, data, it } = cxt;
            gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), ()=>{
                cxt.setParams({
                    missingProperty: (0, codegen_1._)`${prop}`
                }, true);
                cxt.error();
            });
        }
        exports1.checkReportMissingProp = checkReportMissingProp;
        function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
            return (0, codegen_1.or)(...properties.map((prop)=>(0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
        }
        exports1.checkMissingProp = checkMissingProp;
        function reportMissingProp(cxt, missing) {
            cxt.setParams({
                missingProperty: missing
            }, true);
            cxt.error();
        }
        exports1.reportMissingProp = reportMissingProp;
        function hasPropFunc(gen) {
            return gen.scopeValue("func", {
                ref: Object.prototype.hasOwnProperty,
                code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
            });
        }
        exports1.hasPropFunc = hasPropFunc;
        function isOwnProperty(gen, data, property) {
            return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
        }
        exports1.isOwnProperty = isOwnProperty;
        function propertyInData(gen, data, property, ownProperties) {
            const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
            return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
        }
        exports1.propertyInData = propertyInData;
        function noPropertyInData(gen, data, property, ownProperties) {
            const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
            return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
        }
        exports1.noPropertyInData = noPropertyInData;
        function allSchemaProperties(schemaMap) {
            return schemaMap ? Object.keys(schemaMap).filter((p)=>"__proto__" !== p) : [];
        }
        exports1.allSchemaProperties = allSchemaProperties;
        function schemaProperties(it, schemaMap) {
            return allSchemaProperties(schemaMap).filter((p)=>!(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
        }
        exports1.schemaProperties = schemaProperties;
        function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
            const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
            const valCxt = [
                [
                    names_1.default.instancePath,
                    (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)
                ],
                [
                    names_1.default.parentData,
                    it.parentData
                ],
                [
                    names_1.default.parentDataProperty,
                    it.parentDataProperty
                ],
                [
                    names_1.default.rootData,
                    names_1.default.rootData
                ]
            ];
            if (it.opts.dynamicRef) valCxt.push([
                names_1.default.dynamicAnchors,
                names_1.default.dynamicAnchors
            ]);
            const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
            return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
        }
        exports1.callValidateCode = callValidateCode;
        const newRegExp = (0, codegen_1._)`new RegExp`;
        function usePattern({ gen, it: { opts } }, pattern) {
            const u = opts.unicodeRegExp ? "u" : "";
            const { regExp } = opts.code;
            const rx = regExp(pattern, u);
            return gen.scopeValue("pattern", {
                key: rx.toString(),
                ref: rx,
                code: (0, codegen_1._)`${"new RegExp" === regExp.code ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
            });
        }
        exports1.usePattern = usePattern;
        function validateArray(cxt) {
            const { gen, data, keyword, it } = cxt;
            const valid = gen.name("valid");
            if (it.allErrors) {
                const validArr = gen.let("valid", true);
                validateItems(()=>gen.assign(validArr, false));
                return validArr;
            }
            gen.var(valid, true);
            validateItems(()=>gen.break());
            return valid;
            function validateItems(notValid) {
                const len = gen.const("len", (0, codegen_1._)`${data}.length`);
                gen.forRange("i", 0, len, (i)=>{
                    cxt.subschema({
                        keyword,
                        dataProp: i,
                        dataPropType: util_1.Type.Num
                    }, valid);
                    gen.if((0, codegen_1.not)(valid), notValid);
                });
            }
        }
        exports1.validateArray = validateArray;
        function validateUnion(cxt) {
            const { gen, schema, keyword, it } = cxt;
            if (!Array.isArray(schema)) throw new Error("ajv implementation error");
            const alwaysValid = schema.some((sch)=>(0, util_1.alwaysValidSchema)(it, sch));
            if (alwaysValid && !it.opts.unevaluated) return;
            const valid = gen.let("valid", false);
            const schValid = gen.name("_valid");
            gen.block(()=>schema.forEach((_sch, i)=>{
                    const schCxt = cxt.subschema({
                        keyword,
                        schemaProp: i,
                        compositeRule: true
                    }, schValid);
                    gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
                    const merged = cxt.mergeValidEvaluated(schCxt, schValid);
                    if (!merged) gen.if((0, codegen_1.not)(valid));
                }));
            cxt.result(valid, ()=>cxt.reset(), ()=>cxt.error(true));
        }
        exports1.validateUnion = validateUnion;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/id.js": function(__unused_webpack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const def = {
            keyword: "id",
            code () {
                throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const id_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/id.js");
        const ref_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/ref.js");
        const core = [
            "$schema",
            "$id",
            "$defs",
            "$vocabulary",
            {
                keyword: "$comment"
            },
            "definitions",
            id_1.default,
            ref_1.default
        ];
        exports1["default"] = core;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/ref.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.callRef = exports1.getValidate = void 0;
        const ref_error_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js");
        const code_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js");
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const names_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js");
        const compile_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const def = {
            keyword: "$ref",
            schemaType: "string",
            code (cxt) {
                const { gen, schema: $ref, it } = cxt;
                const { baseId, schemaEnv: env, validateName, opts, self } = it;
                const { root } = env;
                if (("#" === $ref || "#/" === $ref) && baseId === root.baseId) return callRootRef();
                const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
                if (void 0 === schOrEnv) throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
                if (schOrEnv instanceof compile_1.SchemaEnv) return callValidate(schOrEnv);
                return inlineRefSchema(schOrEnv);
                function callRootRef() {
                    if (env === root) return callRef(cxt, validateName, env, env.$async);
                    const rootName = gen.scopeValue("root", {
                        ref: root
                    });
                    return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
                }
                function callValidate(sch) {
                    const v = getValidate(cxt, sch);
                    callRef(cxt, v, sch, sch.$async);
                }
                function inlineRefSchema(sch) {
                    const schName = gen.scopeValue("schema", true === opts.code.source ? {
                        ref: sch,
                        code: (0, codegen_1.stringify)(sch)
                    } : {
                        ref: sch
                    });
                    const valid = gen.name("valid");
                    const schCxt = cxt.subschema({
                        schema: sch,
                        dataTypes: [],
                        schemaPath: codegen_1.nil,
                        topSchemaRef: schName,
                        errSchemaPath: $ref
                    }, valid);
                    cxt.mergeEvaluated(schCxt);
                    cxt.ok(valid);
                }
            }
        };
        function getValidate(cxt, sch) {
            const { gen } = cxt;
            return sch.validate ? gen.scopeValue("validate", {
                ref: sch.validate
            }) : (0, codegen_1._)`${gen.scopeValue("wrapper", {
                ref: sch
            })}.validate`;
        }
        exports1.getValidate = getValidate;
        function callRef(cxt, v, sch, $async) {
            const { gen, it } = cxt;
            const { allErrors, schemaEnv: env, opts } = it;
            const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
            if ($async) callAsyncRef();
            else callSyncRef();
            function callAsyncRef() {
                if (!env.$async) throw new Error("async schema referenced by sync schema");
                const valid = gen.let("valid");
                gen.try(()=>{
                    gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
                    addEvaluatedFrom(v);
                    if (!allErrors) gen.assign(valid, true);
                }, (e)=>{
                    gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, ()=>gen.throw(e));
                    addErrorsFrom(e);
                    if (!allErrors) gen.assign(valid, false);
                });
                cxt.ok(valid);
            }
            function callSyncRef() {
                cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), ()=>addEvaluatedFrom(v), ()=>addErrorsFrom(v));
            }
            function addErrorsFrom(source) {
                const errs = (0, codegen_1._)`${source}.errors`;
                gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
                gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
            }
            function addEvaluatedFrom(source) {
                var _a;
                if (!it.opts.unevaluated) return;
                const schEvaluated = null == (_a = null == sch ? void 0 : sch.validate) ? void 0 : _a.evaluated;
                if (true !== it.props) if (schEvaluated && !schEvaluated.dynamicProps) {
                    if (void 0 !== schEvaluated.props) it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
                } else {
                    const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
                    it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
                }
                if (true !== it.items) if (schEvaluated && !schEvaluated.dynamicItems) {
                    if (void 0 !== schEvaluated.items) it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
                } else {
                    const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
                    it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
                }
            }
        }
        exports1.callRef = callRef;
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const types_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/types.js");
        const compile_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js");
        const ref_error_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const error = {
            message: ({ params: { discrError, tagName } })=>discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
            params: ({ params: { discrError, tag, tagName } })=>(0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
        };
        const def = {
            keyword: "discriminator",
            type: "object",
            schemaType: "object",
            error,
            code (cxt) {
                const { gen, data, schema, parentSchema, it } = cxt;
                const { oneOf } = parentSchema;
                if (!it.opts.discriminator) throw new Error("discriminator: requires discriminator option");
                const tagName = schema.propertyName;
                if ("string" != typeof tagName) throw new Error("discriminator: requires propertyName");
                if (schema.mapping) throw new Error("discriminator: mapping is not supported");
                if (!oneOf) throw new Error("discriminator: requires oneOf keyword");
                const valid = gen.let("valid", false);
                const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
                gen.if((0, codegen_1._)`typeof ${tag} == "string"`, ()=>validateMapping(), ()=>cxt.error(false, {
                        discrError: types_1.DiscrError.Tag,
                        tag,
                        tagName
                    }));
                cxt.ok(valid);
                function validateMapping() {
                    const mapping = getMapping();
                    gen.if(false);
                    for(const tagValue in mapping){
                        gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
                        gen.assign(valid, applyTagSchema(mapping[tagValue]));
                    }
                    gen.else();
                    cxt.error(false, {
                        discrError: types_1.DiscrError.Mapping,
                        tag,
                        tagName
                    });
                    gen.endIf();
                }
                function applyTagSchema(schemaProp) {
                    const _valid = gen.name("valid");
                    const schCxt = cxt.subschema({
                        keyword: "oneOf",
                        schemaProp
                    }, _valid);
                    cxt.mergeEvaluated(schCxt, codegen_1.Name);
                    return _valid;
                }
                function getMapping() {
                    var _a;
                    const oneOfMapping = {};
                    const topRequired = hasRequired(parentSchema);
                    let tagRequired = true;
                    for(let i = 0; i < oneOf.length; i++){
                        let sch = oneOf[i];
                        if ((null == sch ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
                            const ref = sch.$ref;
                            sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
                            if (sch instanceof compile_1.SchemaEnv) sch = sch.schema;
                            if (void 0 === sch) throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
                        }
                        const propSch = null == (_a = null == sch ? void 0 : sch.properties) ? void 0 : _a[tagName];
                        if ("object" != typeof propSch) throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
                        tagRequired = tagRequired && (topRequired || hasRequired(sch));
                        addMappings(propSch, i);
                    }
                    if (!tagRequired) throw new Error(`discriminator: "${tagName}" must be required`);
                    return oneOfMapping;
                    function hasRequired({ required }) {
                        return Array.isArray(required) && required.includes(tagName);
                    }
                    function addMappings(sch, i) {
                        if (sch.const) addMapping(sch.const, i);
                        else if (sch.enum) for (const tagValue of sch.enum)addMapping(tagValue, i);
                        else throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
                    }
                    function addMapping(tagValue, i) {
                        if ("string" != typeof tagValue || tagValue in oneOfMapping) throw new Error(`discriminator: "${tagName}" values must be unique strings`);
                        oneOfMapping[tagValue] = i;
                    }
                }
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/types.js": function(__unused_webpack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.DiscrError = void 0;
        var DiscrError;
        (function(DiscrError) {
            DiscrError["Tag"] = "tag";
            DiscrError["Mapping"] = "mapping";
        })(DiscrError || (exports1.DiscrError = DiscrError = {}));
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/draft2020.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const core_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/index.js");
        const validation_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/index.js");
        const applicator_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/index.js");
        const dynamic_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/dynamic/index.js");
        const next_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/next.js");
        const unevaluated_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/unevaluated/index.js");
        const format_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/index.js");
        const metadata_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/metadata.js");
        const draft2020Vocabularies = [
            dynamic_1.default,
            core_1.default,
            validation_1.default,
            (0, applicator_1.default)(true),
            format_1.default,
            metadata_1.metadataVocabulary,
            metadata_1.contentVocabulary,
            next_1.default,
            unevaluated_1.default
        ];
        exports1["default"] = draft2020Vocabularies;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/draft7.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const core_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/index.js");
        const validation_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/index.js");
        const applicator_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/index.js");
        const format_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/index.js");
        const metadata_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/metadata.js");
        const draft7Vocabularies = [
            core_1.default,
            validation_1.default,
            (0, applicator_1.default)(),
            format_1.default,
            metadata_1.metadataVocabulary,
            metadata_1.contentVocabulary
        ];
        exports1["default"] = draft7Vocabularies;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/dynamic/dynamicAnchor.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.dynamicAnchor = void 0;
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const names_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js");
        const compile_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js");
        const ref_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/ref.js");
        const def = {
            keyword: "$dynamicAnchor",
            schemaType: "string",
            code: (cxt)=>dynamicAnchor(cxt, cxt.schema)
        };
        function dynamicAnchor(cxt, anchor) {
            const { gen, it } = cxt;
            it.schemaEnv.root.dynamicAnchors[anchor] = true;
            const v = (0, codegen_1._)`${names_1.default.dynamicAnchors}${(0, codegen_1.getProperty)(anchor)}`;
            const validate = "#" === it.errSchemaPath ? it.validateName : _getValidate(cxt);
            gen.if((0, codegen_1._)`!${v}`, ()=>gen.assign(v, validate));
        }
        exports1.dynamicAnchor = dynamicAnchor;
        function _getValidate(cxt) {
            const { schemaEnv, schema, self } = cxt.it;
            const { root, baseId, localRefs, meta } = schemaEnv.root;
            const { schemaId } = self.opts;
            const sch = new compile_1.SchemaEnv({
                schema,
                schemaId,
                root,
                baseId,
                localRefs,
                meta
            });
            compile_1.compileSchema.call(self, sch);
            return (0, ref_1.getValidate)(cxt, sch);
        }
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/dynamic/dynamicRef.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.dynamicRef = void 0;
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const names_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js");
        const ref_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/ref.js");
        const def = {
            keyword: "$dynamicRef",
            schemaType: "string",
            code: (cxt)=>dynamicRef(cxt, cxt.schema)
        };
        function dynamicRef(cxt, ref) {
            const { gen, keyword, it } = cxt;
            if ("#" !== ref[0]) throw new Error(`"${keyword}" only supports hash fragment reference`);
            const anchor = ref.slice(1);
            if (it.allErrors) _dynamicRef();
            else {
                const valid = gen.let("valid", false);
                _dynamicRef(valid);
                cxt.ok(valid);
            }
            function _dynamicRef(valid) {
                if (it.schemaEnv.root.dynamicAnchors[anchor]) {
                    const v = gen.let("_v", (0, codegen_1._)`${names_1.default.dynamicAnchors}${(0, codegen_1.getProperty)(anchor)}`);
                    gen.if(v, _callRef(v, valid), _callRef(it.validateName, valid));
                } else _callRef(it.validateName, valid)();
            }
            function _callRef(validate, valid) {
                return valid ? ()=>gen.block(()=>{
                        (0, ref_1.callRef)(cxt, validate);
                        gen.let(valid, true);
                    }) : ()=>(0, ref_1.callRef)(cxt, validate);
            }
        }
        exports1.dynamicRef = dynamicRef;
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/dynamic/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const dynamicAnchor_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/dynamic/dynamicAnchor.js");
        const dynamicRef_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/dynamic/dynamicRef.js");
        const recursiveAnchor_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/dynamic/recursiveAnchor.js");
        const recursiveRef_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/dynamic/recursiveRef.js");
        const dynamic = [
            dynamicAnchor_1.default,
            dynamicRef_1.default,
            recursiveAnchor_1.default,
            recursiveRef_1.default
        ];
        exports1["default"] = dynamic;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/dynamic/recursiveAnchor.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const dynamicAnchor_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/dynamic/dynamicAnchor.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const def = {
            keyword: "$recursiveAnchor",
            schemaType: "boolean",
            code (cxt) {
                if (cxt.schema) (0, dynamicAnchor_1.dynamicAnchor)(cxt, "");
                else (0, util_1.checkStrictMode)(cxt.it, "$recursiveAnchor: false is ignored");
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/dynamic/recursiveRef.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const dynamicRef_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/dynamic/dynamicRef.js");
        const def = {
            keyword: "$recursiveRef",
            schemaType: "string",
            code: (cxt)=>(0, dynamicRef_1.dynamicRef)(cxt, cxt.schema)
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/format.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const error = {
            message: ({ schemaCode })=>(0, codegen_1.str)`must match format "${schemaCode}"`,
            params: ({ schemaCode })=>(0, codegen_1._)`{format: ${schemaCode}}`
        };
        const def = {
            keyword: "format",
            type: [
                "number",
                "string"
            ],
            schemaType: "string",
            $data: true,
            error,
            code (cxt, ruleType) {
                const { gen, data, $data, schema, schemaCode, it } = cxt;
                const { opts, errSchemaPath, schemaEnv, self } = it;
                if (!opts.validateFormats) return;
                if ($data) validate$DataFormat();
                else validateFormat();
                function validate$DataFormat() {
                    const fmts = gen.scopeValue("formats", {
                        ref: self.formats,
                        code: opts.code.formats
                    });
                    const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
                    const fType = gen.let("fType");
                    const format = gen.let("format");
                    gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, ()=>gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), ()=>gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
                    cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
                    function unknownFmt() {
                        if (false === opts.strictSchema) return codegen_1.nil;
                        return (0, codegen_1._)`${schemaCode} && !${format}`;
                    }
                    function invalidFmt() {
                        const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
                        const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
                        return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
                    }
                }
                function validateFormat() {
                    const formatDef = self.formats[schema];
                    if (!formatDef) return void unknownFormat();
                    if (true === formatDef) return;
                    const [fmtType, format, fmtRef] = getFormat(formatDef);
                    if (fmtType === ruleType) cxt.pass(validCondition());
                    function unknownFormat() {
                        if (false === opts.strictSchema) return void self.logger.warn(unknownMsg());
                        throw new Error(unknownMsg());
                        function unknownMsg() {
                            return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
                        }
                    }
                    function getFormat(fmtDef) {
                        const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
                        const fmt = gen.scopeValue("formats", {
                            key: schema,
                            ref: fmtDef,
                            code
                        });
                        if ("object" == typeof fmtDef && !(fmtDef instanceof RegExp)) return [
                            fmtDef.type || "string",
                            fmtDef.validate,
                            (0, codegen_1._)`${fmt}.validate`
                        ];
                        return [
                            "string",
                            fmtDef,
                            fmt
                        ];
                    }
                    function validCondition() {
                        if ("object" == typeof formatDef && !(formatDef instanceof RegExp) && formatDef.async) {
                            if (!schemaEnv.$async) throw new Error("async format in sync schema");
                            return (0, codegen_1._)`await ${fmtRef}(${data})`;
                        }
                        return "function" == typeof format ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
                    }
                }
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const format_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/format.js");
        const format = [
            format_1.default
        ];
        exports1["default"] = format;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/metadata.js": function(__unused_webpack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        exports1.contentVocabulary = exports1.metadataVocabulary = void 0;
        exports1.metadataVocabulary = [
            "title",
            "description",
            "default",
            "deprecated",
            "readOnly",
            "writeOnly",
            "examples"
        ];
        exports1.contentVocabulary = [
            "contentMediaType",
            "contentEncoding",
            "contentSchema"
        ];
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/next.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const dependentRequired_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/dependentRequired.js");
        const dependentSchemas_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/dependentSchemas.js");
        const limitContains_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitContains.js");
        const next = [
            dependentRequired_1.default,
            dependentSchemas_1.default,
            limitContains_1.default
        ];
        exports1["default"] = next;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/unevaluated/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const unevaluatedProperties_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedProperties.js");
        const unevaluatedItems_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedItems.js");
        const unevaluated = [
            unevaluatedProperties_1.default,
            unevaluatedItems_1.default
        ];
        exports1["default"] = unevaluated;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedItems.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const error = {
            message: ({ params: { len } })=>(0, codegen_1.str)`must NOT have more than ${len} items`,
            params: ({ params: { len } })=>(0, codegen_1._)`{limit: ${len}}`
        };
        const def = {
            keyword: "unevaluatedItems",
            type: "array",
            schemaType: [
                "boolean",
                "object"
            ],
            error,
            code (cxt) {
                const { gen, schema, data, it } = cxt;
                const items = it.items || 0;
                if (true === items) return;
                const len = gen.const("len", (0, codegen_1._)`${data}.length`);
                if (false === schema) {
                    cxt.setParams({
                        len: items
                    });
                    cxt.fail((0, codegen_1._)`${len} > ${items}`);
                } else if ("object" == typeof schema && !(0, util_1.alwaysValidSchema)(it, schema)) {
                    const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items}`);
                    gen.if((0, codegen_1.not)(valid), ()=>validateItems(valid, items));
                    cxt.ok(valid);
                }
                it.items = true;
                function validateItems(valid, from) {
                    gen.forRange("i", from, len, (i)=>{
                        cxt.subschema({
                            keyword: "unevaluatedItems",
                            dataProp: i,
                            dataPropType: util_1.Type.Num
                        }, valid);
                        if (!it.allErrors) gen.if((0, codegen_1.not)(valid), ()=>gen.break());
                    });
                }
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedProperties.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const names_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js");
        const error = {
            message: "must NOT have unevaluated properties",
            params: ({ params })=>(0, codegen_1._)`{unevaluatedProperty: ${params.unevaluatedProperty}}`
        };
        const def = {
            keyword: "unevaluatedProperties",
            type: "object",
            schemaType: [
                "boolean",
                "object"
            ],
            trackErrors: true,
            error,
            code (cxt) {
                const { gen, schema, data, errsCount, it } = cxt;
                if (!errsCount) throw new Error("ajv implementation error");
                const { allErrors, props } = it;
                if (props instanceof codegen_1.Name) gen.if((0, codegen_1._)`${props} !== true`, ()=>gen.forIn("key", data, (key)=>gen.if(unevaluatedDynamic(props, key), ()=>unevaluatedPropCode(key))));
                else if (true !== props) gen.forIn("key", data, (key)=>void 0 === props ? unevaluatedPropCode(key) : gen.if(unevaluatedStatic(props, key), ()=>unevaluatedPropCode(key)));
                it.props = true;
                cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
                function unevaluatedPropCode(key) {
                    if (false === schema) {
                        cxt.setParams({
                            unevaluatedProperty: key
                        });
                        cxt.error();
                        if (!allErrors) gen.break();
                        return;
                    }
                    if (!(0, util_1.alwaysValidSchema)(it, schema)) {
                        const valid = gen.name("valid");
                        cxt.subschema({
                            keyword: "unevaluatedProperties",
                            dataProp: key,
                            dataPropType: util_1.Type.Str
                        }, valid);
                        if (!allErrors) gen.if((0, codegen_1.not)(valid), ()=>gen.break());
                    }
                }
                function unevaluatedDynamic(evaluatedProps, key) {
                    return (0, codegen_1._)`!${evaluatedProps} || !${evaluatedProps}[${key}]`;
                }
                function unevaluatedStatic(evaluatedProps, key) {
                    const ps = [];
                    for(const p in evaluatedProps)if (true === evaluatedProps[p]) ps.push((0, codegen_1._)`${key} !== ${p}`);
                    return (0, codegen_1.and)(...ps);
                }
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/const.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const equal_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/equal.js");
        const error = {
            message: "must be equal to constant",
            params: ({ schemaCode })=>(0, codegen_1._)`{allowedValue: ${schemaCode}}`
        };
        const def = {
            keyword: "const",
            $data: true,
            error,
            code (cxt) {
                const { gen, data, $data, schemaCode, schema } = cxt;
                if ($data || schema && "object" == typeof schema) cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
                else cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/dependentRequired.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const dependencies_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/dependencies.js");
        const def = {
            keyword: "dependentRequired",
            type: "object",
            schemaType: "object",
            error: dependencies_1.error,
            code: (cxt)=>(0, dependencies_1.validatePropertyDeps)(cxt)
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/enum.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const equal_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/equal.js");
        const error = {
            message: "must be equal to one of the allowed values",
            params: ({ schemaCode })=>(0, codegen_1._)`{allowedValues: ${schemaCode}}`
        };
        const def = {
            keyword: "enum",
            schemaType: "array",
            $data: true,
            error,
            code (cxt) {
                const { gen, data, $data, schema, schemaCode, it } = cxt;
                if (!$data && 0 === schema.length) throw new Error("enum must have non-empty array");
                const useLoop = schema.length >= it.opts.loopEnum;
                let eql;
                const getEql = ()=>null != eql ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
                let valid;
                if (useLoop || $data) {
                    valid = gen.let("valid");
                    cxt.block$data(valid, loopEnum);
                } else {
                    if (!Array.isArray(schema)) throw new Error("ajv implementation error");
                    const vSchema = gen.const("vSchema", schemaCode);
                    valid = (0, codegen_1.or)(...schema.map((_x, i)=>equalCode(vSchema, i)));
                }
                cxt.pass(valid);
                function loopEnum() {
                    gen.assign(valid, false);
                    gen.forOf("v", schemaCode, (v)=>gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, ()=>gen.assign(valid, true).break()));
                }
                function equalCode(vSchema, i) {
                    const sch = schema[i];
                    return "object" == typeof sch && null !== sch ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
                }
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const limitNumber_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitNumber.js");
        const multipleOf_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/multipleOf.js");
        const limitLength_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitLength.js");
        const pattern_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/pattern.js");
        const limitProperties_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitProperties.js");
        const required_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/required.js");
        const limitItems_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitItems.js");
        const uniqueItems_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js");
        const const_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/const.js");
        const enum_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/enum.js");
        const validation = [
            limitNumber_1.default,
            multipleOf_1.default,
            limitLength_1.default,
            pattern_1.default,
            limitProperties_1.default,
            required_1.default,
            limitItems_1.default,
            uniqueItems_1.default,
            {
                keyword: "type",
                schemaType: [
                    "string",
                    "array"
                ]
            },
            {
                keyword: "nullable",
                schemaType: "boolean"
            },
            const_1.default,
            enum_1.default
        ];
        exports1["default"] = validation;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitContains.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const def = {
            keyword: [
                "maxContains",
                "minContains"
            ],
            type: "array",
            schemaType: "number",
            code ({ keyword, parentSchema, it }) {
                if (void 0 === parentSchema.contains) (0, util_1.checkStrictMode)(it, `"${keyword}" without "contains" is ignored`);
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitItems.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const error = {
            message ({ keyword, schemaCode }) {
                const comp = "maxItems" === keyword ? "more" : "fewer";
                return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
            },
            params: ({ schemaCode })=>(0, codegen_1._)`{limit: ${schemaCode}}`
        };
        const def = {
            keyword: [
                "maxItems",
                "minItems"
            ],
            type: "array",
            schemaType: "number",
            $data: true,
            error,
            code (cxt) {
                const { keyword, data, schemaCode } = cxt;
                const op = "maxItems" === keyword ? codegen_1.operators.GT : codegen_1.operators.LT;
                cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitLength.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const ucs2length_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/ucs2length.js");
        const error = {
            message ({ keyword, schemaCode }) {
                const comp = "maxLength" === keyword ? "more" : "fewer";
                return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
            },
            params: ({ schemaCode })=>(0, codegen_1._)`{limit: ${schemaCode}}`
        };
        const def = {
            keyword: [
                "maxLength",
                "minLength"
            ],
            type: "string",
            schemaType: "number",
            $data: true,
            error,
            code (cxt) {
                const { keyword, data, schemaCode, it } = cxt;
                const op = "maxLength" === keyword ? codegen_1.operators.GT : codegen_1.operators.LT;
                const len = false === it.opts.unicode ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
                cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitNumber.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const ops = codegen_1.operators;
        const KWDs = {
            maximum: {
                okStr: "<=",
                ok: ops.LTE,
                fail: ops.GT
            },
            minimum: {
                okStr: ">=",
                ok: ops.GTE,
                fail: ops.LT
            },
            exclusiveMaximum: {
                okStr: "<",
                ok: ops.LT,
                fail: ops.GTE
            },
            exclusiveMinimum: {
                okStr: ">",
                ok: ops.GT,
                fail: ops.LTE
            }
        };
        const error = {
            message: ({ keyword, schemaCode })=>(0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
            params: ({ keyword, schemaCode })=>(0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
        };
        const def = {
            keyword: Object.keys(KWDs),
            type: "number",
            schemaType: "number",
            $data: true,
            error,
            code (cxt) {
                const { keyword, data, schemaCode } = cxt;
                cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitProperties.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const error = {
            message ({ keyword, schemaCode }) {
                const comp = "maxProperties" === keyword ? "more" : "fewer";
                return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
            },
            params: ({ schemaCode })=>(0, codegen_1._)`{limit: ${schemaCode}}`
        };
        const def = {
            keyword: [
                "maxProperties",
                "minProperties"
            ],
            type: "object",
            schemaType: "number",
            $data: true,
            error,
            code (cxt) {
                const { keyword, data, schemaCode } = cxt;
                const op = "maxProperties" === keyword ? codegen_1.operators.GT : codegen_1.operators.LT;
                cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/multipleOf.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const error = {
            message: ({ schemaCode })=>(0, codegen_1.str)`must be multiple of ${schemaCode}`,
            params: ({ schemaCode })=>(0, codegen_1._)`{multipleOf: ${schemaCode}}`
        };
        const def = {
            keyword: "multipleOf",
            type: "number",
            schemaType: "number",
            $data: true,
            error,
            code (cxt) {
                const { gen, data, schemaCode, it } = cxt;
                const prec = it.opts.multipleOfPrecision;
                const res = gen.let("res");
                const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
                cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/pattern.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const code_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js");
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const error = {
            message: ({ schemaCode })=>(0, codegen_1.str)`must match pattern "${schemaCode}"`,
            params: ({ schemaCode })=>(0, codegen_1._)`{pattern: ${schemaCode}}`
        };
        const def = {
            keyword: "pattern",
            type: "string",
            schemaType: "string",
            $data: true,
            error,
            code (cxt) {
                const { data, $data, schema, schemaCode, it } = cxt;
                const u = it.opts.unicodeRegExp ? "u" : "";
                const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
                cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/required.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const code_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js");
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const error = {
            message: ({ params: { missingProperty } })=>(0, codegen_1.str)`must have required property '${missingProperty}'`,
            params: ({ params: { missingProperty } })=>(0, codegen_1._)`{missingProperty: ${missingProperty}}`
        };
        const def = {
            keyword: "required",
            type: "object",
            schemaType: "array",
            $data: true,
            error,
            code (cxt) {
                const { gen, schema, schemaCode, data, $data, it } = cxt;
                const { opts } = it;
                if (!$data && 0 === schema.length) return;
                const useLoop = schema.length >= opts.loopRequired;
                if (it.allErrors) allErrorsMode();
                else exitOnErrorMode();
                if (opts.strictRequired) {
                    const props = cxt.parentSchema.properties;
                    const { definedProperties } = cxt.it;
                    for (const requiredKey of schema)if ((null == props ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
                        const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
                        const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
                        (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
                    }
                }
                function allErrorsMode() {
                    if (useLoop || $data) cxt.block$data(codegen_1.nil, loopAllRequired);
                    else for (const prop of schema)(0, code_1.checkReportMissingProp)(cxt, prop);
                }
                function exitOnErrorMode() {
                    const missing = gen.let("missing");
                    if (useLoop || $data) {
                        const valid = gen.let("valid", true);
                        cxt.block$data(valid, ()=>loopUntilMissing(missing, valid));
                        cxt.ok(valid);
                    } else {
                        gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
                        (0, code_1.reportMissingProp)(cxt, missing);
                        gen.else();
                    }
                }
                function loopAllRequired() {
                    gen.forOf("prop", schemaCode, (prop)=>{
                        cxt.setParams({
                            missingProperty: prop
                        });
                        gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), ()=>cxt.error());
                    });
                }
                function loopUntilMissing(missing, valid) {
                    cxt.setParams({
                        missingProperty: missing
                    });
                    gen.forOf(missing, schemaCode, ()=>{
                        gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
                        gen.if((0, codegen_1.not)(valid), ()=>{
                            cxt.error();
                            gen.break();
                        });
                    }, codegen_1.nil);
                }
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: true
        });
        const dataType_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js");
        const codegen_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js");
        const util_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js");
        const equal_1 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/equal.js");
        const error = {
            message: ({ params: { i, j } })=>(0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
            params: ({ params: { i, j } })=>(0, codegen_1._)`{i: ${i}, j: ${j}}`
        };
        const def = {
            keyword: "uniqueItems",
            type: "array",
            schemaType: "boolean",
            $data: true,
            error,
            code (cxt) {
                const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
                if (!$data && !schema) return;
                const valid = gen.let("valid");
                const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
                cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
                cxt.ok(valid);
                function validateUniqueItems() {
                    const i = gen.let("i", (0, codegen_1._)`${data}.length`);
                    const j = gen.let("j");
                    cxt.setParams({
                        i,
                        j
                    });
                    gen.assign(valid, true);
                    gen.if((0, codegen_1._)`${i} > 1`, ()=>(canOptimize() ? loopN : loopN2)(i, j));
                }
                function canOptimize() {
                    return itemTypes.length > 0 && !itemTypes.some((t)=>"object" === t || "array" === t);
                }
                function loopN(i, j) {
                    const item = gen.name("item");
                    const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
                    const indices = gen.const("indices", (0, codegen_1._)`{}`);
                    gen.for((0, codegen_1._)`;${i}--;`, ()=>{
                        gen.let(item, (0, codegen_1._)`${data}[${i}]`);
                        gen.if(wrongType, (0, codegen_1._)`continue`);
                        if (itemTypes.length > 1) gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
                        gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, ()=>{
                            gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
                            cxt.error();
                            gen.assign(valid, false).break();
                        }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
                    });
                }
                function loopN2(i, j) {
                    const eql = (0, util_1.useFunc)(gen, equal_1.default);
                    const outer = gen.name("outer");
                    gen.label(outer).for((0, codegen_1._)`;${i}--;`, ()=>gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, ()=>gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, ()=>{
                                cxt.error();
                                gen.assign(valid, false).break(outer);
                            })));
                }
            }
        };
        exports1["default"] = def;
    },
    "../node_modules/.pnpm/ansi-align@3.0.1/node_modules/ansi-align/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const stringWidth = __webpack_require__("../node_modules/.pnpm/string-width@4.2.3/node_modules/string-width/index.js");
        function ansiAlign(text, opts) {
            if (!text) return text;
            opts = opts || {};
            const align = opts.align || 'center';
            if ('left' === align) return text;
            const split = opts.split || '\n';
            const pad = opts.pad || ' ';
            const widthDiffFn = 'right' !== align ? halfDiff : fullDiff;
            let returnString = false;
            if (!Array.isArray(text)) {
                returnString = true;
                text = String(text).split(split);
            }
            let width;
            let maxWidth = 0;
            text = text.map(function(str) {
                str = String(str);
                width = stringWidth(str);
                maxWidth = Math.max(width, maxWidth);
                return {
                    str,
                    width
                };
            }).map(function(obj) {
                return new Array(widthDiffFn(maxWidth, obj.width) + 1).join(pad) + obj.str;
            });
            return returnString ? text.join(split) : text;
        }
        ansiAlign.left = function(text) {
            return ansiAlign(text, {
                align: 'left'
            });
        };
        ansiAlign.center = function(text) {
            return ansiAlign(text, {
                align: 'center'
            });
        };
        ansiAlign.right = function(text) {
            return ansiAlign(text, {
                align: 'right'
            });
        };
        module.exports = ansiAlign;
        function halfDiff(maxWidth, curWidth) {
            return Math.floor((maxWidth - curWidth) / 2);
        }
        function fullDiff(maxWidth, curWidth) {
            return maxWidth - curWidth;
        }
    },
    "../node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js": function(module) {
        "use strict";
        module.exports = ({ onlyFirst = false } = {})=>{
            const pattern = "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
            return new RegExp(pattern, onlyFirst ? void 0 : 'g');
        };
    },
    "../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        module = __webpack_require__.nmd(module);
        const wrapAnsi16 = (fn, offset)=>(...args)=>{
                const code = fn(...args);
                return `\u001B[${code + offset}m`;
            };
        const wrapAnsi256 = (fn, offset)=>(...args)=>{
                const code = fn(...args);
                return `\u001B[${38 + offset};5;${code}m`;
            };
        const wrapAnsi16m = (fn, offset)=>(...args)=>{
                const rgb = fn(...args);
                return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
            };
        const ansi2ansi = (n)=>n;
        const rgb2rgb = (r, g, b)=>[
                r,
                g,
                b
            ];
        const setLazyProperty = (object, property, get)=>{
            Object.defineProperty(object, property, {
                get: ()=>{
                    const value = get();
                    Object.defineProperty(object, property, {
                        value,
                        enumerable: true,
                        configurable: true
                    });
                    return value;
                },
                enumerable: true,
                configurable: true
            });
        };
        let colorConvert;
        const makeDynamicStyles = (wrap, targetSpace, identity, isBackground)=>{
            if (void 0 === colorConvert) colorConvert = __webpack_require__("../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js");
            const offset = isBackground ? 10 : 0;
            const styles = {};
            for (const [sourceSpace, suite] of Object.entries(colorConvert)){
                const name = 'ansi16' === sourceSpace ? 'ansi' : sourceSpace;
                if (sourceSpace === targetSpace) styles[name] = wrap(identity, offset);
                else if ('object' == typeof suite) styles[name] = wrap(suite[targetSpace], offset);
            }
            return styles;
        };
        function assembleStyles() {
            const codes = new Map();
            const styles = {
                modifier: {
                    reset: [
                        0,
                        0
                    ],
                    bold: [
                        1,
                        22
                    ],
                    dim: [
                        2,
                        22
                    ],
                    italic: [
                        3,
                        23
                    ],
                    underline: [
                        4,
                        24
                    ],
                    inverse: [
                        7,
                        27
                    ],
                    hidden: [
                        8,
                        28
                    ],
                    strikethrough: [
                        9,
                        29
                    ]
                },
                color: {
                    black: [
                        30,
                        39
                    ],
                    red: [
                        31,
                        39
                    ],
                    green: [
                        32,
                        39
                    ],
                    yellow: [
                        33,
                        39
                    ],
                    blue: [
                        34,
                        39
                    ],
                    magenta: [
                        35,
                        39
                    ],
                    cyan: [
                        36,
                        39
                    ],
                    white: [
                        37,
                        39
                    ],
                    blackBright: [
                        90,
                        39
                    ],
                    redBright: [
                        91,
                        39
                    ],
                    greenBright: [
                        92,
                        39
                    ],
                    yellowBright: [
                        93,
                        39
                    ],
                    blueBright: [
                        94,
                        39
                    ],
                    magentaBright: [
                        95,
                        39
                    ],
                    cyanBright: [
                        96,
                        39
                    ],
                    whiteBright: [
                        97,
                        39
                    ]
                },
                bgColor: {
                    bgBlack: [
                        40,
                        49
                    ],
                    bgRed: [
                        41,
                        49
                    ],
                    bgGreen: [
                        42,
                        49
                    ],
                    bgYellow: [
                        43,
                        49
                    ],
                    bgBlue: [
                        44,
                        49
                    ],
                    bgMagenta: [
                        45,
                        49
                    ],
                    bgCyan: [
                        46,
                        49
                    ],
                    bgWhite: [
                        47,
                        49
                    ],
                    bgBlackBright: [
                        100,
                        49
                    ],
                    bgRedBright: [
                        101,
                        49
                    ],
                    bgGreenBright: [
                        102,
                        49
                    ],
                    bgYellowBright: [
                        103,
                        49
                    ],
                    bgBlueBright: [
                        104,
                        49
                    ],
                    bgMagentaBright: [
                        105,
                        49
                    ],
                    bgCyanBright: [
                        106,
                        49
                    ],
                    bgWhiteBright: [
                        107,
                        49
                    ]
                }
            };
            styles.color.gray = styles.color.blackBright;
            styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
            styles.color.grey = styles.color.blackBright;
            styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
            for (const [groupName, group] of Object.entries(styles)){
                for (const [styleName, style] of Object.entries(group)){
                    styles[styleName] = {
                        open: `\u001B[${style[0]}m`,
                        close: `\u001B[${style[1]}m`
                    };
                    group[styleName] = styles[styleName];
                    codes.set(style[0], style[1]);
                }
                Object.defineProperty(styles, groupName, {
                    value: group,
                    enumerable: false
                });
            }
            Object.defineProperty(styles, 'codes', {
                value: codes,
                enumerable: false
            });
            styles.color.close = '\u001B[39m';
            styles.bgColor.close = '\u001B[49m';
            setLazyProperty(styles.color, 'ansi', ()=>makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
            setLazyProperty(styles.color, 'ansi256', ()=>makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
            setLazyProperty(styles.color, 'ansi16m', ()=>makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
            setLazyProperty(styles.bgColor, 'ansi', ()=>makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
            setLazyProperty(styles.bgColor, 'ansi256', ()=>makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
            setLazyProperty(styles.bgColor, 'ansi16m', ()=>makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));
            return styles;
        }
        Object.defineProperty(module, 'exports', {
            enumerable: true,
            get: assembleStyles
        });
    },
    "../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const ansiStyles = __webpack_require__("../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js");
        const { stdout: stdoutColor, stderr: stderrColor } = __webpack_require__("../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js");
        const { stringReplaceAll, stringEncaseCRLFWithFirstIndex } = __webpack_require__("../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js");
        const { isArray } = Array;
        const levelMapping = [
            'ansi',
            'ansi',
            'ansi256',
            'ansi16m'
        ];
        const styles = Object.create(null);
        const applyOptions = (object, options = {})=>{
            if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) throw new Error('The `level` option should be an integer from 0 to 3');
            const colorLevel = stdoutColor ? stdoutColor.level : 0;
            object.level = void 0 === options.level ? colorLevel : options.level;
        };
        class ChalkClass {
            constructor(options){
                return chalkFactory(options);
            }
        }
        const chalkFactory = (options)=>{
            const chalk = {};
            applyOptions(chalk, options);
            chalk.template = (...arguments_)=>chalkTag(chalk.template, ...arguments_);
            Object.setPrototypeOf(chalk, Chalk.prototype);
            Object.setPrototypeOf(chalk.template, chalk);
            chalk.template.constructor = ()=>{
                throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
            };
            chalk.template.Instance = ChalkClass;
            return chalk.template;
        };
        function Chalk(options) {
            return chalkFactory(options);
        }
        for (const [styleName, style] of Object.entries(ansiStyles))styles[styleName] = {
            get () {
                const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
                Object.defineProperty(this, styleName, {
                    value: builder
                });
                return builder;
            }
        };
        styles.visible = {
            get () {
                const builder = createBuilder(this, this._styler, true);
                Object.defineProperty(this, 'visible', {
                    value: builder
                });
                return builder;
            }
        };
        const usedModels = [
            'rgb',
            'hex',
            'keyword',
            'hsl',
            'hsv',
            'hwb',
            'ansi',
            'ansi256'
        ];
        for (const model of usedModels)styles[model] = {
            get () {
                const { level } = this;
                return function(...arguments_) {
                    const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
                    return createBuilder(this, styler, this._isEmpty);
                };
            }
        };
        for (const model of usedModels){
            const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
            styles[bgModel] = {
                get () {
                    const { level } = this;
                    return function(...arguments_) {
                        const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
                        return createBuilder(this, styler, this._isEmpty);
                    };
                }
            };
        }
        const proto = Object.defineProperties(()=>{}, {
            ...styles,
            level: {
                enumerable: true,
                get () {
                    return this._generator.level;
                },
                set (level) {
                    this._generator.level = level;
                }
            }
        });
        const createStyler = (open, close, parent)=>{
            let openAll;
            let closeAll;
            if (void 0 === parent) {
                openAll = open;
                closeAll = close;
            } else {
                openAll = parent.openAll + open;
                closeAll = close + parent.closeAll;
            }
            return {
                open,
                close,
                openAll,
                closeAll,
                parent
            };
        };
        const createBuilder = (self, _styler, _isEmpty)=>{
            const builder = (...arguments_)=>{
                if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) return applyStyle(builder, chalkTag(builder, ...arguments_));
                return applyStyle(builder, 1 === arguments_.length ? '' + arguments_[0] : arguments_.join(' '));
            };
            Object.setPrototypeOf(builder, proto);
            builder._generator = self;
            builder._styler = _styler;
            builder._isEmpty = _isEmpty;
            return builder;
        };
        const applyStyle = (self, string)=>{
            if (self.level <= 0 || !string) return self._isEmpty ? '' : string;
            let styler = self._styler;
            if (void 0 === styler) return string;
            const { openAll, closeAll } = styler;
            if (-1 !== string.indexOf('\u001B')) while(void 0 !== styler){
                string = stringReplaceAll(string, styler.close, styler.open);
                styler = styler.parent;
            }
            const lfIndex = string.indexOf('\n');
            if (-1 !== lfIndex) string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
            return openAll + string + closeAll;
        };
        let template;
        const chalkTag = (chalk, ...strings)=>{
            const [firstString] = strings;
            if (!isArray(firstString) || !isArray(firstString.raw)) return strings.join(' ');
            const arguments_ = strings.slice(1);
            const parts = [
                firstString.raw[0]
            ];
            for(let i = 1; i < firstString.length; i++)parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'), String(firstString.raw[i]));
            if (void 0 === template) template = __webpack_require__("../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js");
            return template(chalk, parts.join(''));
        };
        Object.defineProperties(Chalk.prototype, styles);
        const chalk = Chalk();
        chalk.supportsColor = stdoutColor;
        chalk.stderr = Chalk({
            level: stderrColor ? stderrColor.level : 0
        });
        chalk.stderr.supportsColor = stderrColor;
        module.exports = chalk;
    },
    "../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js": function(module) {
        "use strict";
        const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
        const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
        const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
        const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
        const ESCAPES = new Map([
            [
                'n',
                '\n'
            ],
            [
                'r',
                '\r'
            ],
            [
                't',
                '\t'
            ],
            [
                'b',
                '\b'
            ],
            [
                'f',
                '\f'
            ],
            [
                'v',
                '\v'
            ],
            [
                '0',
                '\0'
            ],
            [
                '\\',
                '\\'
            ],
            [
                'e',
                '\u001B'
            ],
            [
                'a',
                '\u0007'
            ]
        ]);
        function unescape1(c) {
            const u = 'u' === c[0];
            const bracket = '{' === c[1];
            if (u && !bracket && 5 === c.length || 'x' === c[0] && 3 === c.length) return String.fromCharCode(parseInt(c.slice(1), 16));
            if (u && bracket) return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
            return ESCAPES.get(c) || c;
        }
        function parseArguments(name, arguments_) {
            const results = [];
            const chunks = arguments_.trim().split(/\s*,\s*/g);
            let matches;
            for (const chunk of chunks){
                const number = Number(chunk);
                if (Number.isNaN(number)) if (matches = chunk.match(STRING_REGEX)) results.push(matches[2].replace(ESCAPE_REGEX, (m, escape1, character)=>escape1 ? unescape1(escape1) : character));
                else throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
                else results.push(number);
            }
            return results;
        }
        function parseStyle(style) {
            STYLE_REGEX.lastIndex = 0;
            const results = [];
            let matches;
            while(null !== (matches = STYLE_REGEX.exec(style))){
                const name = matches[1];
                if (matches[2]) {
                    const args = parseArguments(name, matches[2]);
                    results.push([
                        name
                    ].concat(args));
                } else results.push([
                    name
                ]);
            }
            return results;
        }
        function buildStyle(chalk, styles) {
            const enabled = {};
            for (const layer of styles)for (const style of layer.styles)enabled[style[0]] = layer.inverse ? null : style.slice(1);
            let current = chalk;
            for (const [styleName, styles] of Object.entries(enabled))if (Array.isArray(styles)) {
                if (!(styleName in current)) throw new Error(`Unknown Chalk style: ${styleName}`);
                current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
            }
            return current;
        }
        module.exports = (chalk, temporary)=>{
            const styles = [];
            const chunks = [];
            let chunk = [];
            temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character)=>{
                if (escapeCharacter) chunk.push(unescape1(escapeCharacter));
                else if (style) {
                    const string = chunk.join('');
                    chunk = [];
                    chunks.push(0 === styles.length ? string : buildStyle(chalk, styles)(string));
                    styles.push({
                        inverse,
                        styles: parseStyle(style)
                    });
                } else if (close) {
                    if (0 === styles.length) throw new Error('Found extraneous } in Chalk template literal');
                    chunks.push(buildStyle(chalk, styles)(chunk.join('')));
                    chunk = [];
                    styles.pop();
                } else chunk.push(character);
            });
            chunks.push(chunk.join(''));
            if (styles.length > 0) {
                const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${1 === styles.length ? '' : 's'} (\`}\`)`;
                throw new Error(errMessage);
            }
            return chunks.join('');
        };
    },
    "../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js": function(module) {
        "use strict";
        const stringReplaceAll = (string, substring, replacer)=>{
            let index = string.indexOf(substring);
            if (-1 === index) return string;
            const substringLength = substring.length;
            let endIndex = 0;
            let returnValue = '';
            do {
                returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
                endIndex = index + substringLength;
                index = string.indexOf(substring, endIndex);
            }while (-1 !== index);
            returnValue += string.substr(endIndex);
            return returnValue;
        };
        const stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index)=>{
            let endIndex = 0;
            let returnValue = '';
            do {
                const gotCR = '\r' === string[index - 1];
                returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
                endIndex = index + 1;
                index = string.indexOf('\n', endIndex);
            }while (-1 !== index);
            returnValue += string.substr(endIndex);
            return returnValue;
        };
        module.exports = {
            stringReplaceAll,
            stringEncaseCRLFWithFirstIndex
        };
    },
    "../node_modules/.pnpm/cli-boxes@3.0.0/node_modules/cli-boxes/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const cliBoxes = __webpack_require__("../node_modules/.pnpm/cli-boxes@3.0.0/node_modules/cli-boxes/boxes.json");
        module.exports = cliBoxes;
        module.exports["default"] = cliBoxes;
    },
    "../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const cssKeywords = __webpack_require__("../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js");
        const reverseKeywords = {};
        for (const key of Object.keys(cssKeywords))reverseKeywords[cssKeywords[key]] = key;
        const convert = {
            rgb: {
                channels: 3,
                labels: 'rgb'
            },
            hsl: {
                channels: 3,
                labels: 'hsl'
            },
            hsv: {
                channels: 3,
                labels: 'hsv'
            },
            hwb: {
                channels: 3,
                labels: 'hwb'
            },
            cmyk: {
                channels: 4,
                labels: 'cmyk'
            },
            xyz: {
                channels: 3,
                labels: 'xyz'
            },
            lab: {
                channels: 3,
                labels: 'lab'
            },
            lch: {
                channels: 3,
                labels: 'lch'
            },
            hex: {
                channels: 1,
                labels: [
                    'hex'
                ]
            },
            keyword: {
                channels: 1,
                labels: [
                    'keyword'
                ]
            },
            ansi16: {
                channels: 1,
                labels: [
                    'ansi16'
                ]
            },
            ansi256: {
                channels: 1,
                labels: [
                    'ansi256'
                ]
            },
            hcg: {
                channels: 3,
                labels: [
                    'h',
                    'c',
                    'g'
                ]
            },
            apple: {
                channels: 3,
                labels: [
                    'r16',
                    'g16',
                    'b16'
                ]
            },
            gray: {
                channels: 1,
                labels: [
                    'gray'
                ]
            }
        };
        module.exports = convert;
        for (const model of Object.keys(convert)){
            if (!('channels' in convert[model])) throw new Error('missing channels property: ' + model);
            if (!('labels' in convert[model])) throw new Error('missing channel labels property: ' + model);
            if (convert[model].labels.length !== convert[model].channels) throw new Error('channel and label counts mismatch: ' + model);
            const { channels, labels } = convert[model];
            delete convert[model].channels;
            delete convert[model].labels;
            Object.defineProperty(convert[model], 'channels', {
                value: channels
            });
            Object.defineProperty(convert[model], 'labels', {
                value: labels
            });
        }
        convert.rgb.hsl = function(rgb) {
            const r = rgb[0] / 255;
            const g = rgb[1] / 255;
            const b = rgb[2] / 255;
            const min = Math.min(r, g, b);
            const max = Math.max(r, g, b);
            const delta = max - min;
            let h;
            let s;
            if (max === min) h = 0;
            else if (r === max) h = (g - b) / delta;
            else if (g === max) h = 2 + (b - r) / delta;
            else if (b === max) h = 4 + (r - g) / delta;
            h = Math.min(60 * h, 360);
            if (h < 0) h += 360;
            const l = (min + max) / 2;
            s = max === min ? 0 : l <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
            return [
                h,
                100 * s,
                100 * l
            ];
        };
        convert.rgb.hsv = function(rgb) {
            let rdif;
            let gdif;
            let bdif;
            let h;
            let s;
            const r = rgb[0] / 255;
            const g = rgb[1] / 255;
            const b = rgb[2] / 255;
            const v = Math.max(r, g, b);
            const diff = v - Math.min(r, g, b);
            const diffc = function(c) {
                return (v - c) / 6 / diff + 0.5;
            };
            if (0 === diff) {
                h = 0;
                s = 0;
            } else {
                s = diff / v;
                rdif = diffc(r);
                gdif = diffc(g);
                bdif = diffc(b);
                if (r === v) h = bdif - gdif;
                else if (g === v) h = 1 / 3 + rdif - bdif;
                else if (b === v) h = 2 / 3 + gdif - rdif;
                if (h < 0) h += 1;
                else if (h > 1) h -= 1;
            }
            return [
                360 * h,
                100 * s,
                100 * v
            ];
        };
        convert.rgb.hwb = function(rgb) {
            const r = rgb[0];
            const g = rgb[1];
            let b = rgb[2];
            const h = convert.rgb.hsl(rgb)[0];
            const w = 1 / 255 * Math.min(r, Math.min(g, b));
            b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
            return [
                h,
                100 * w,
                100 * b
            ];
        };
        convert.rgb.cmyk = function(rgb) {
            const r = rgb[0] / 255;
            const g = rgb[1] / 255;
            const b = rgb[2] / 255;
            const k = Math.min(1 - r, 1 - g, 1 - b);
            const c = (1 - r - k) / (1 - k) || 0;
            const m = (1 - g - k) / (1 - k) || 0;
            const y = (1 - b - k) / (1 - k) || 0;
            return [
                100 * c,
                100 * m,
                100 * y,
                100 * k
            ];
        };
        function comparativeDistance(x, y) {
            return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
        }
        convert.rgb.keyword = function(rgb) {
            const reversed = reverseKeywords[rgb];
            if (reversed) return reversed;
            let currentClosestDistance = 1 / 0;
            let currentClosestKeyword;
            for (const keyword of Object.keys(cssKeywords)){
                const value = cssKeywords[keyword];
                const distance = comparativeDistance(rgb, value);
                if (distance < currentClosestDistance) {
                    currentClosestDistance = distance;
                    currentClosestKeyword = keyword;
                }
            }
            return currentClosestKeyword;
        };
        convert.keyword.rgb = function(keyword) {
            return cssKeywords[keyword];
        };
        convert.rgb.xyz = function(rgb) {
            let r = rgb[0] / 255;
            let g = rgb[1] / 255;
            let b = rgb[2] / 255;
            r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
            g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
            b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
            const x = 0.4124 * r + 0.3576 * g + 0.1805 * b;
            const y = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            const z = 0.0193 * r + 0.1192 * g + 0.9505 * b;
            return [
                100 * x,
                100 * y,
                100 * z
            ];
        };
        convert.rgb.lab = function(rgb) {
            const xyz = convert.rgb.xyz(rgb);
            let x = xyz[0];
            let y = xyz[1];
            let z = xyz[2];
            x /= 95.047;
            y /= 100;
            z /= 108.883;
            x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
            y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
            z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
            const l = 116 * y - 16;
            const a = 500 * (x - y);
            const b = 200 * (y - z);
            return [
                l,
                a,
                b
            ];
        };
        convert.hsl.rgb = function(hsl) {
            const h = hsl[0] / 360;
            const s = hsl[1] / 100;
            const l = hsl[2] / 100;
            let t2;
            let t3;
            let val;
            if (0 === s) {
                val = 255 * l;
                return [
                    val,
                    val,
                    val
                ];
            }
            t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const t1 = 2 * l - t2;
            const rgb = [
                0,
                0,
                0
            ];
            for(let i = 0; i < 3; i++){
                t3 = h + 1 / 3 * -(i - 1);
                if (t3 < 0) t3++;
                if (t3 > 1) t3--;
                val = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;
                rgb[i] = 255 * val;
            }
            return rgb;
        };
        convert.hsl.hsv = function(hsl) {
            const h = hsl[0];
            let s = hsl[1] / 100;
            let l = hsl[2] / 100;
            let smin = s;
            const lmin = Math.max(l, 0.01);
            l *= 2;
            s *= l <= 1 ? l : 2 - l;
            smin *= lmin <= 1 ? lmin : 2 - lmin;
            const v = (l + s) / 2;
            const sv = 0 === l ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
            return [
                h,
                100 * sv,
                100 * v
            ];
        };
        convert.hsv.rgb = function(hsv) {
            const h = hsv[0] / 60;
            const s = hsv[1] / 100;
            let v = hsv[2] / 100;
            const hi = Math.floor(h) % 6;
            const f = h - Math.floor(h);
            const p = 255 * v * (1 - s);
            const q = 255 * v * (1 - s * f);
            const t = 255 * v * (1 - s * (1 - f));
            v *= 255;
            switch(hi){
                case 0:
                    return [
                        v,
                        t,
                        p
                    ];
                case 1:
                    return [
                        q,
                        v,
                        p
                    ];
                case 2:
                    return [
                        p,
                        v,
                        t
                    ];
                case 3:
                    return [
                        p,
                        q,
                        v
                    ];
                case 4:
                    return [
                        t,
                        p,
                        v
                    ];
                case 5:
                    return [
                        v,
                        p,
                        q
                    ];
            }
        };
        convert.hsv.hsl = function(hsv) {
            const h = hsv[0];
            const s = hsv[1] / 100;
            const v = hsv[2] / 100;
            const vmin = Math.max(v, 0.01);
            let sl;
            let l;
            l = (2 - s) * v;
            const lmin = (2 - s) * vmin;
            sl = s * vmin;
            sl /= lmin <= 1 ? lmin : 2 - lmin;
            sl = sl || 0;
            l /= 2;
            return [
                h,
                100 * sl,
                100 * l
            ];
        };
        convert.hwb.rgb = function(hwb) {
            const h = hwb[0] / 360;
            let wh = hwb[1] / 100;
            let bl = hwb[2] / 100;
            const ratio = wh + bl;
            let f;
            if (ratio > 1) {
                wh /= ratio;
                bl /= ratio;
            }
            const i = Math.floor(6 * h);
            const v = 1 - bl;
            f = 6 * h - i;
            if ((0x01 & i) !== 0) f = 1 - f;
            const n = wh + f * (v - wh);
            let r;
            let g;
            let b;
            switch(i){
                default:
                case 6:
                case 0:
                    r = v;
                    g = n;
                    b = wh;
                    break;
                case 1:
                    r = n;
                    g = v;
                    b = wh;
                    break;
                case 2:
                    r = wh;
                    g = v;
                    b = n;
                    break;
                case 3:
                    r = wh;
                    g = n;
                    b = v;
                    break;
                case 4:
                    r = n;
                    g = wh;
                    b = v;
                    break;
                case 5:
                    r = v;
                    g = wh;
                    b = n;
                    break;
            }
            return [
                255 * r,
                255 * g,
                255 * b
            ];
        };
        convert.cmyk.rgb = function(cmyk) {
            const c = cmyk[0] / 100;
            const m = cmyk[1] / 100;
            const y = cmyk[2] / 100;
            const k = cmyk[3] / 100;
            const r = 1 - Math.min(1, c * (1 - k) + k);
            const g = 1 - Math.min(1, m * (1 - k) + k);
            const b = 1 - Math.min(1, y * (1 - k) + k);
            return [
                255 * r,
                255 * g,
                255 * b
            ];
        };
        convert.xyz.rgb = function(xyz) {
            const x = xyz[0] / 100;
            const y = xyz[1] / 100;
            const z = xyz[2] / 100;
            let r;
            let g;
            let b;
            r = 3.2406 * x + -1.5372 * y + -0.4986 * z;
            g = -0.9689 * x + 1.8758 * y + 0.0415 * z;
            b = 0.0557 * x + -0.204 * y + 1.0570 * z;
            r = r > 0.0031308 ? 1.055 * r ** (1.0 / 2.4) - 0.055 : 12.92 * r;
            g = g > 0.0031308 ? 1.055 * g ** (1.0 / 2.4) - 0.055 : 12.92 * g;
            b = b > 0.0031308 ? 1.055 * b ** (1.0 / 2.4) - 0.055 : 12.92 * b;
            r = Math.min(Math.max(0, r), 1);
            g = Math.min(Math.max(0, g), 1);
            b = Math.min(Math.max(0, b), 1);
            return [
                255 * r,
                255 * g,
                255 * b
            ];
        };
        convert.xyz.lab = function(xyz) {
            let x = xyz[0];
            let y = xyz[1];
            let z = xyz[2];
            x /= 95.047;
            y /= 100;
            z /= 108.883;
            x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
            y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
            z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
            const l = 116 * y - 16;
            const a = 500 * (x - y);
            const b = 200 * (y - z);
            return [
                l,
                a,
                b
            ];
        };
        convert.lab.xyz = function(lab) {
            const l = lab[0];
            const a = lab[1];
            const b = lab[2];
            let x;
            let y;
            let z;
            y = (l + 16) / 116;
            x = a / 500 + y;
            z = y - b / 200;
            const y2 = y ** 3;
            const x2 = x ** 3;
            const z2 = z ** 3;
            y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
            x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
            z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
            x *= 95.047;
            y *= 100;
            z *= 108.883;
            return [
                x,
                y,
                z
            ];
        };
        convert.lab.lch = function(lab) {
            const l = lab[0];
            const a = lab[1];
            const b = lab[2];
            let h;
            const hr = Math.atan2(b, a);
            h = 360 * hr / 2 / Math.PI;
            if (h < 0) h += 360;
            const c = Math.sqrt(a * a + b * b);
            return [
                l,
                c,
                h
            ];
        };
        convert.lch.lab = function(lch) {
            const l = lch[0];
            const c = lch[1];
            const h = lch[2];
            const hr = h / 360 * 2 * Math.PI;
            const a = c * Math.cos(hr);
            const b = c * Math.sin(hr);
            return [
                l,
                a,
                b
            ];
        };
        convert.rgb.ansi16 = function(args, saturation = null) {
            const [r, g, b] = args;
            let value = null === saturation ? convert.rgb.hsv(args)[2] : saturation;
            value = Math.round(value / 50);
            if (0 === value) return 30;
            let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
            if (2 === value) ansi += 60;
            return ansi;
        };
        convert.hsv.ansi16 = function(args) {
            return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
        };
        convert.rgb.ansi256 = function(args) {
            const r = args[0];
            const g = args[1];
            const b = args[2];
            if (r === g && g === b) {
                if (r < 8) return 16;
                if (r > 248) return 231;
                return Math.round((r - 8) / 247 * 24) + 232;
            }
            const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
            return ansi;
        };
        convert.ansi16.rgb = function(args) {
            let color = args % 10;
            if (0 === color || 7 === color) {
                if (args > 50) color += 3.5;
                color = color / 10.5 * 255;
                return [
                    color,
                    color,
                    color
                ];
            }
            const mult = (~~(args > 50) + 1) * 0.5;
            const r = (1 & color) * mult * 255;
            const g = (color >> 1 & 1) * mult * 255;
            const b = (color >> 2 & 1) * mult * 255;
            return [
                r,
                g,
                b
            ];
        };
        convert.ansi256.rgb = function(args) {
            if (args >= 232) {
                const c = (args - 232) * 10 + 8;
                return [
                    c,
                    c,
                    c
                ];
            }
            args -= 16;
            let rem;
            const r = Math.floor(args / 36) / 5 * 255;
            const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
            const b = rem % 6 / 5 * 255;
            return [
                r,
                g,
                b
            ];
        };
        convert.rgb.hex = function(args) {
            const integer = ((0xFF & Math.round(args[0])) << 16) + ((0xFF & Math.round(args[1])) << 8) + (0xFF & Math.round(args[2]));
            const string = integer.toString(16).toUpperCase();
            return '000000'.substring(string.length) + string;
        };
        convert.hex.rgb = function(args) {
            const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
            if (!match) return [
                0,
                0,
                0
            ];
            let colorString = match[0];
            if (3 === match[0].length) colorString = colorString.split('').map((char)=>char + char).join('');
            const integer = parseInt(colorString, 16);
            const r = integer >> 16 & 0xFF;
            const g = integer >> 8 & 0xFF;
            const b = 0xFF & integer;
            return [
                r,
                g,
                b
            ];
        };
        convert.rgb.hcg = function(rgb) {
            const r = rgb[0] / 255;
            const g = rgb[1] / 255;
            const b = rgb[2] / 255;
            const max = Math.max(Math.max(r, g), b);
            const min = Math.min(Math.min(r, g), b);
            const chroma = max - min;
            let grayscale;
            let hue;
            grayscale = chroma < 1 ? min / (1 - chroma) : 0;
            hue = chroma <= 0 ? 0 : max === r ? (g - b) / chroma % 6 : max === g ? 2 + (b - r) / chroma : 4 + (r - g) / chroma;
            hue /= 6;
            hue %= 1;
            return [
                360 * hue,
                100 * chroma,
                100 * grayscale
            ];
        };
        convert.hsl.hcg = function(hsl) {
            const s = hsl[1] / 100;
            const l = hsl[2] / 100;
            const c = l < 0.5 ? 2.0 * s * l : 2.0 * s * (1.0 - l);
            let f = 0;
            if (c < 1.0) f = (l - 0.5 * c) / (1.0 - c);
            return [
                hsl[0],
                100 * c,
                100 * f
            ];
        };
        convert.hsv.hcg = function(hsv) {
            const s = hsv[1] / 100;
            const v = hsv[2] / 100;
            const c = s * v;
            let f = 0;
            if (c < 1.0) f = (v - c) / (1 - c);
            return [
                hsv[0],
                100 * c,
                100 * f
            ];
        };
        convert.hcg.rgb = function(hcg) {
            const h = hcg[0] / 360;
            const c = hcg[1] / 100;
            const g = hcg[2] / 100;
            if (0.0 === c) return [
                255 * g,
                255 * g,
                255 * g
            ];
            const pure = [
                0,
                0,
                0
            ];
            const hi = h % 1 * 6;
            const v = hi % 1;
            const w = 1 - v;
            let mg = 0;
            switch(Math.floor(hi)){
                case 0:
                    pure[0] = 1;
                    pure[1] = v;
                    pure[2] = 0;
                    break;
                case 1:
                    pure[0] = w;
                    pure[1] = 1;
                    pure[2] = 0;
                    break;
                case 2:
                    pure[0] = 0;
                    pure[1] = 1;
                    pure[2] = v;
                    break;
                case 3:
                    pure[0] = 0;
                    pure[1] = w;
                    pure[2] = 1;
                    break;
                case 4:
                    pure[0] = v;
                    pure[1] = 0;
                    pure[2] = 1;
                    break;
                default:
                    pure[0] = 1;
                    pure[1] = 0;
                    pure[2] = w;
            }
            mg = (1.0 - c) * g;
            return [
                (c * pure[0] + mg) * 255,
                (c * pure[1] + mg) * 255,
                (c * pure[2] + mg) * 255
            ];
        };
        convert.hcg.hsv = function(hcg) {
            const c = hcg[1] / 100;
            const g = hcg[2] / 100;
            const v = c + g * (1.0 - c);
            let f = 0;
            if (v > 0.0) f = c / v;
            return [
                hcg[0],
                100 * f,
                100 * v
            ];
        };
        convert.hcg.hsl = function(hcg) {
            const c = hcg[1] / 100;
            const g = hcg[2] / 100;
            const l = g * (1.0 - c) + 0.5 * c;
            let s = 0;
            if (l > 0.0 && l < 0.5) s = c / (2 * l);
            else if (l >= 0.5 && l < 1.0) s = c / (2 * (1 - l));
            return [
                hcg[0],
                100 * s,
                100 * l
            ];
        };
        convert.hcg.hwb = function(hcg) {
            const c = hcg[1] / 100;
            const g = hcg[2] / 100;
            const v = c + g * (1.0 - c);
            return [
                hcg[0],
                (v - c) * 100,
                (1 - v) * 100
            ];
        };
        convert.hwb.hcg = function(hwb) {
            const w = hwb[1] / 100;
            const b = hwb[2] / 100;
            const v = 1 - b;
            const c = v - w;
            let g = 0;
            if (c < 1) g = (v - c) / (1 - c);
            return [
                hwb[0],
                100 * c,
                100 * g
            ];
        };
        convert.apple.rgb = function(apple) {
            return [
                apple[0] / 65535 * 255,
                apple[1] / 65535 * 255,
                apple[2] / 65535 * 255
            ];
        };
        convert.rgb.apple = function(rgb) {
            return [
                rgb[0] / 255 * 65535,
                rgb[1] / 255 * 65535,
                rgb[2] / 255 * 65535
            ];
        };
        convert.gray.rgb = function(args) {
            return [
                args[0] / 100 * 255,
                args[0] / 100 * 255,
                args[0] / 100 * 255
            ];
        };
        convert.gray.hsl = function(args) {
            return [
                0,
                0,
                args[0]
            ];
        };
        convert.gray.hsv = convert.gray.hsl;
        convert.gray.hwb = function(gray) {
            return [
                0,
                100,
                gray[0]
            ];
        };
        convert.gray.cmyk = function(gray) {
            return [
                0,
                0,
                0,
                gray[0]
            ];
        };
        convert.gray.lab = function(gray) {
            return [
                gray[0],
                0,
                0
            ];
        };
        convert.gray.hex = function(gray) {
            const val = 0xFF & Math.round(gray[0] / 100 * 255);
            const integer = (val << 16) + (val << 8) + val;
            const string = integer.toString(16).toUpperCase();
            return '000000'.substring(string.length) + string;
        };
        convert.rgb.gray = function(rgb) {
            const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
            return [
                val / 255 * 100
            ];
        };
    },
    "../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const conversions = __webpack_require__("../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js");
        const route = __webpack_require__("../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js");
        const convert = {};
        const models = Object.keys(conversions);
        function wrapRaw(fn) {
            const wrappedFn = function(...args) {
                const arg0 = args[0];
                if (null == arg0) return arg0;
                if (arg0.length > 1) args = arg0;
                return fn(args);
            };
            if ('conversion' in fn) wrappedFn.conversion = fn.conversion;
            return wrappedFn;
        }
        function wrapRounded(fn) {
            const wrappedFn = function(...args) {
                const arg0 = args[0];
                if (null == arg0) return arg0;
                if (arg0.length > 1) args = arg0;
                const result = fn(args);
                if ('object' == typeof result) for(let len = result.length, i = 0; i < len; i++)result[i] = Math.round(result[i]);
                return result;
            };
            if ('conversion' in fn) wrappedFn.conversion = fn.conversion;
            return wrappedFn;
        }
        models.forEach((fromModel)=>{
            convert[fromModel] = {};
            Object.defineProperty(convert[fromModel], 'channels', {
                value: conversions[fromModel].channels
            });
            Object.defineProperty(convert[fromModel], 'labels', {
                value: conversions[fromModel].labels
            });
            const routes = route(fromModel);
            const routeModels = Object.keys(routes);
            routeModels.forEach((toModel)=>{
                const fn = routes[toModel];
                convert[fromModel][toModel] = wrapRounded(fn);
                convert[fromModel][toModel].raw = wrapRaw(fn);
            });
        });
        module.exports = convert;
    },
    "../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const conversions = __webpack_require__("../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js");
        function buildGraph() {
            const graph = {};
            const models = Object.keys(conversions);
            for(let len = models.length, i = 0; i < len; i++)graph[models[i]] = {
                distance: -1,
                parent: null
            };
            return graph;
        }
        function deriveBFS(fromModel) {
            const graph = buildGraph();
            const queue = [
                fromModel
            ];
            graph[fromModel].distance = 0;
            while(queue.length){
                const current = queue.pop();
                const adjacents = Object.keys(conversions[current]);
                for(let len = adjacents.length, i = 0; i < len; i++){
                    const adjacent = adjacents[i];
                    const node = graph[adjacent];
                    if (-1 === node.distance) {
                        node.distance = graph[current].distance + 1;
                        node.parent = current;
                        queue.unshift(adjacent);
                    }
                }
            }
            return graph;
        }
        function link(from, to) {
            return function(args) {
                return to(from(args));
            };
        }
        function wrapConversion(toModel, graph) {
            const path = [
                graph[toModel].parent,
                toModel
            ];
            let fn = conversions[graph[toModel].parent][toModel];
            let cur = graph[toModel].parent;
            while(graph[cur].parent){
                path.unshift(graph[cur].parent);
                fn = link(conversions[graph[cur].parent][cur], fn);
                cur = graph[cur].parent;
            }
            fn.conversion = path;
            return fn;
        }
        module.exports = function(fromModel) {
            const graph = deriveBFS(fromModel);
            const conversion = {};
            const models = Object.keys(graph);
            for(let len = models.length, i = 0; i < len; i++){
                const toModel = models[i];
                const node = graph[toModel];
                if (null !== node.parent) conversion[toModel] = wrapConversion(toModel, graph);
            }
            return conversion;
        };
    },
    "../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js": function(module) {
        "use strict";
        module.exports = {
            aliceblue: [
                240,
                248,
                255
            ],
            antiquewhite: [
                250,
                235,
                215
            ],
            aqua: [
                0,
                255,
                255
            ],
            aquamarine: [
                127,
                255,
                212
            ],
            azure: [
                240,
                255,
                255
            ],
            beige: [
                245,
                245,
                220
            ],
            bisque: [
                255,
                228,
                196
            ],
            black: [
                0,
                0,
                0
            ],
            blanchedalmond: [
                255,
                235,
                205
            ],
            blue: [
                0,
                0,
                255
            ],
            blueviolet: [
                138,
                43,
                226
            ],
            brown: [
                165,
                42,
                42
            ],
            burlywood: [
                222,
                184,
                135
            ],
            cadetblue: [
                95,
                158,
                160
            ],
            chartreuse: [
                127,
                255,
                0
            ],
            chocolate: [
                210,
                105,
                30
            ],
            coral: [
                255,
                127,
                80
            ],
            cornflowerblue: [
                100,
                149,
                237
            ],
            cornsilk: [
                255,
                248,
                220
            ],
            crimson: [
                220,
                20,
                60
            ],
            cyan: [
                0,
                255,
                255
            ],
            darkblue: [
                0,
                0,
                139
            ],
            darkcyan: [
                0,
                139,
                139
            ],
            darkgoldenrod: [
                184,
                134,
                11
            ],
            darkgray: [
                169,
                169,
                169
            ],
            darkgreen: [
                0,
                100,
                0
            ],
            darkgrey: [
                169,
                169,
                169
            ],
            darkkhaki: [
                189,
                183,
                107
            ],
            darkmagenta: [
                139,
                0,
                139
            ],
            darkolivegreen: [
                85,
                107,
                47
            ],
            darkorange: [
                255,
                140,
                0
            ],
            darkorchid: [
                153,
                50,
                204
            ],
            darkred: [
                139,
                0,
                0
            ],
            darksalmon: [
                233,
                150,
                122
            ],
            darkseagreen: [
                143,
                188,
                143
            ],
            darkslateblue: [
                72,
                61,
                139
            ],
            darkslategray: [
                47,
                79,
                79
            ],
            darkslategrey: [
                47,
                79,
                79
            ],
            darkturquoise: [
                0,
                206,
                209
            ],
            darkviolet: [
                148,
                0,
                211
            ],
            deeppink: [
                255,
                20,
                147
            ],
            deepskyblue: [
                0,
                191,
                255
            ],
            dimgray: [
                105,
                105,
                105
            ],
            dimgrey: [
                105,
                105,
                105
            ],
            dodgerblue: [
                30,
                144,
                255
            ],
            firebrick: [
                178,
                34,
                34
            ],
            floralwhite: [
                255,
                250,
                240
            ],
            forestgreen: [
                34,
                139,
                34
            ],
            fuchsia: [
                255,
                0,
                255
            ],
            gainsboro: [
                220,
                220,
                220
            ],
            ghostwhite: [
                248,
                248,
                255
            ],
            gold: [
                255,
                215,
                0
            ],
            goldenrod: [
                218,
                165,
                32
            ],
            gray: [
                128,
                128,
                128
            ],
            green: [
                0,
                128,
                0
            ],
            greenyellow: [
                173,
                255,
                47
            ],
            grey: [
                128,
                128,
                128
            ],
            honeydew: [
                240,
                255,
                240
            ],
            hotpink: [
                255,
                105,
                180
            ],
            indianred: [
                205,
                92,
                92
            ],
            indigo: [
                75,
                0,
                130
            ],
            ivory: [
                255,
                255,
                240
            ],
            khaki: [
                240,
                230,
                140
            ],
            lavender: [
                230,
                230,
                250
            ],
            lavenderblush: [
                255,
                240,
                245
            ],
            lawngreen: [
                124,
                252,
                0
            ],
            lemonchiffon: [
                255,
                250,
                205
            ],
            lightblue: [
                173,
                216,
                230
            ],
            lightcoral: [
                240,
                128,
                128
            ],
            lightcyan: [
                224,
                255,
                255
            ],
            lightgoldenrodyellow: [
                250,
                250,
                210
            ],
            lightgray: [
                211,
                211,
                211
            ],
            lightgreen: [
                144,
                238,
                144
            ],
            lightgrey: [
                211,
                211,
                211
            ],
            lightpink: [
                255,
                182,
                193
            ],
            lightsalmon: [
                255,
                160,
                122
            ],
            lightseagreen: [
                32,
                178,
                170
            ],
            lightskyblue: [
                135,
                206,
                250
            ],
            lightslategray: [
                119,
                136,
                153
            ],
            lightslategrey: [
                119,
                136,
                153
            ],
            lightsteelblue: [
                176,
                196,
                222
            ],
            lightyellow: [
                255,
                255,
                224
            ],
            lime: [
                0,
                255,
                0
            ],
            limegreen: [
                50,
                205,
                50
            ],
            linen: [
                250,
                240,
                230
            ],
            magenta: [
                255,
                0,
                255
            ],
            maroon: [
                128,
                0,
                0
            ],
            mediumaquamarine: [
                102,
                205,
                170
            ],
            mediumblue: [
                0,
                0,
                205
            ],
            mediumorchid: [
                186,
                85,
                211
            ],
            mediumpurple: [
                147,
                112,
                219
            ],
            mediumseagreen: [
                60,
                179,
                113
            ],
            mediumslateblue: [
                123,
                104,
                238
            ],
            mediumspringgreen: [
                0,
                250,
                154
            ],
            mediumturquoise: [
                72,
                209,
                204
            ],
            mediumvioletred: [
                199,
                21,
                133
            ],
            midnightblue: [
                25,
                25,
                112
            ],
            mintcream: [
                245,
                255,
                250
            ],
            mistyrose: [
                255,
                228,
                225
            ],
            moccasin: [
                255,
                228,
                181
            ],
            navajowhite: [
                255,
                222,
                173
            ],
            navy: [
                0,
                0,
                128
            ],
            oldlace: [
                253,
                245,
                230
            ],
            olive: [
                128,
                128,
                0
            ],
            olivedrab: [
                107,
                142,
                35
            ],
            orange: [
                255,
                165,
                0
            ],
            orangered: [
                255,
                69,
                0
            ],
            orchid: [
                218,
                112,
                214
            ],
            palegoldenrod: [
                238,
                232,
                170
            ],
            palegreen: [
                152,
                251,
                152
            ],
            paleturquoise: [
                175,
                238,
                238
            ],
            palevioletred: [
                219,
                112,
                147
            ],
            papayawhip: [
                255,
                239,
                213
            ],
            peachpuff: [
                255,
                218,
                185
            ],
            peru: [
                205,
                133,
                63
            ],
            pink: [
                255,
                192,
                203
            ],
            plum: [
                221,
                160,
                221
            ],
            powderblue: [
                176,
                224,
                230
            ],
            purple: [
                128,
                0,
                128
            ],
            rebeccapurple: [
                102,
                51,
                153
            ],
            red: [
                255,
                0,
                0
            ],
            rosybrown: [
                188,
                143,
                143
            ],
            royalblue: [
                65,
                105,
                225
            ],
            saddlebrown: [
                139,
                69,
                19
            ],
            salmon: [
                250,
                128,
                114
            ],
            sandybrown: [
                244,
                164,
                96
            ],
            seagreen: [
                46,
                139,
                87
            ],
            seashell: [
                255,
                245,
                238
            ],
            sienna: [
                160,
                82,
                45
            ],
            silver: [
                192,
                192,
                192
            ],
            skyblue: [
                135,
                206,
                235
            ],
            slateblue: [
                106,
                90,
                205
            ],
            slategray: [
                112,
                128,
                144
            ],
            slategrey: [
                112,
                128,
                144
            ],
            snow: [
                255,
                250,
                250
            ],
            springgreen: [
                0,
                255,
                127
            ],
            steelblue: [
                70,
                130,
                180
            ],
            tan: [
                210,
                180,
                140
            ],
            teal: [
                0,
                128,
                128
            ],
            thistle: [
                216,
                191,
                216
            ],
            tomato: [
                255,
                99,
                71
            ],
            turquoise: [
                64,
                224,
                208
            ],
            violet: [
                238,
                130,
                238
            ],
            wheat: [
                245,
                222,
                179
            ],
            white: [
                255,
                255,
                255
            ],
            whitesmoke: [
                245,
                245,
                245
            ],
            yellow: [
                255,
                255,
                0
            ],
            yellowgreen: [
                154,
                205,
                50
            ]
        };
    },
    "../node_modules/.pnpm/emoji-regex@8.0.0/node_modules/emoji-regex/index.js": function(module) {
        "use strict";
        module.exports = function() {
            return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
        };
    },
    "../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js": function(module) {
        "use strict";
        module.exports = function equal(a, b) {
            if (a === b) return true;
            if (a && b && 'object' == typeof a && 'object' == typeof b) {
                if (a.constructor !== b.constructor) return false;
                var length, i, keys;
                if (Array.isArray(a)) {
                    length = a.length;
                    if (length != b.length) return false;
                    for(i = length; 0 !== i--;)if (!equal(a[i], b[i])) return false;
                    return true;
                }
                if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
                if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
                if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
                keys = Object.keys(a);
                length = keys.length;
                if (length !== Object.keys(b).length) return false;
                for(i = length; 0 !== i--;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
                for(i = length; 0 !== i--;){
                    var key = keys[i];
                    if (!equal(a[key], b[key])) return false;
                }
                return true;
            }
            return a !== a && b !== b;
        };
    },
    "../node_modules/.pnpm/gradient-string@2.0.2/node_modules/gradient-string/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const chalk = __webpack_require__("../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js");
        const tinygradient = __webpack_require__("../node_modules/.pnpm/tinygradient@1.1.5/node_modules/tinygradient/index.js");
        const forbiddenChars = /\s/g;
        function InitGradient(...args) {
            const grad = tinygradient.apply(this, args);
            const ret = (str, opts)=>applyGradient(str ? str.toString() : '', grad, opts);
            ret.multiline = (str, opts)=>multilineGradient(str ? str.toString() : '', grad, opts);
            return ret;
        }
        const getColors = (gradient, options, count)=>'hsv' === options.interpolation.toLowerCase() ? gradient.hsv(count, options.hsvSpin.toLowerCase()) : gradient.rgb(count);
        function applyGradient(str, gradient, opts) {
            const options = validateOptions(opts);
            const colorsCount = Math.max(str.replace(forbiddenChars, '').length, gradient.stops.length);
            const colors = getColors(gradient, options, colorsCount);
            let result = '';
            for (const s of str)result += s.match(forbiddenChars) ? s : chalk.hex(colors.shift().toHex())(s);
            return result;
        }
        function multilineGradient(str, gradient, opts) {
            const options = validateOptions(opts);
            const lines = str.split('\n');
            const maxLength = Math.max.apply(null, lines.map((l)=>l.length).concat([
                gradient.stops.length
            ]));
            const colors = getColors(gradient, options, maxLength);
            const results = [];
            for (const line of lines){
                const lineColors = colors.slice(0);
                let lineResult = '';
                for (const l of line)lineResult += chalk.hex(lineColors.shift().toHex())(l);
                results.push(lineResult);
            }
            return results.join('\n');
        }
        function validateOptions(opts) {
            const options = {
                interpolation: 'rgb',
                hsvSpin: 'short',
                ...opts
            };
            if (void 0 !== opts && 'object' != typeof opts) throw new TypeError(`Expected \`options\` to be an \`object\`, got \`${typeof opts}\``);
            if ('string' != typeof options.interpolation) throw new TypeError(`Expected \`options.interpolation\` to be a \`string\`, got \`${typeof options.interpolation}\``);
            if ('hsv' === options.interpolation.toLowerCase() && 'string' != typeof options.hsvSpin) throw new TypeError(`Expected \`options.hsvSpin\` to be a \`string\`, got \`${typeof options.hsvSpin}\``);
            return options;
        }
        const aliases = {
            atlas: {
                colors: [
                    '#feac5e',
                    '#c779d0',
                    '#4bc0c8'
                ],
                options: {}
            },
            cristal: {
                colors: [
                    '#bdfff3',
                    '#4ac29a'
                ],
                options: {}
            },
            teen: {
                colors: [
                    '#77a1d3',
                    '#79cbca',
                    '#e684ae'
                ],
                options: {}
            },
            mind: {
                colors: [
                    '#473b7b',
                    '#3584a7',
                    '#30d2be'
                ],
                options: {}
            },
            morning: {
                colors: [
                    '#ff5f6d',
                    '#ffc371'
                ],
                options: {
                    interpolation: 'hsv'
                }
            },
            vice: {
                colors: [
                    '#5ee7df',
                    '#b490ca'
                ],
                options: {
                    interpolation: 'hsv'
                }
            },
            passion: {
                colors: [
                    '#f43b47',
                    '#453a94'
                ],
                options: {}
            },
            fruit: {
                colors: [
                    '#ff4e50',
                    '#f9d423'
                ],
                options: {}
            },
            instagram: {
                colors: [
                    '#833ab4',
                    '#fd1d1d',
                    '#fcb045'
                ],
                options: {}
            },
            retro: {
                colors: [
                    '#3f51b1',
                    '#5a55ae',
                    '#7b5fac',
                    '#8f6aae',
                    '#a86aa4',
                    '#cc6b8e',
                    '#f18271',
                    '#f3a469',
                    '#f7c978'
                ],
                options: {}
            },
            summer: {
                colors: [
                    '#fdbb2d',
                    '#22c1c3'
                ],
                options: {}
            },
            rainbow: {
                colors: [
                    '#ff0000',
                    '#ff0100'
                ],
                options: {
                    interpolation: 'hsv',
                    hsvSpin: 'long'
                }
            },
            pastel: {
                colors: [
                    '#74ebd5',
                    '#74ecd5'
                ],
                options: {
                    interpolation: 'hsv',
                    hsvSpin: 'long'
                }
            }
        };
        module.exports = InitGradient;
        for(const a in aliases){
            module.exports[a] = (str)=>new InitGradient(aliases[a].colors)(str, aliases[a].options);
            module.exports[a].multiline = (str)=>new InitGradient(aliases[a].colors).multiline(str, aliases[a].options);
        }
    },
    "../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js": function(module) {
        "use strict";
        module.exports = (flag, argv = process.argv)=>{
            const prefix = flag.startsWith('-') ? '' : 1 === flag.length ? '-' : '--';
            const position = argv.indexOf(prefix + flag);
            const terminatorPosition = argv.indexOf('--');
            return -1 !== position && (-1 === terminatorPosition || position < terminatorPosition);
        };
    },
    "../node_modules/.pnpm/is-fullwidth-code-point@3.0.0/node_modules/is-fullwidth-code-point/index.js": function(module) {
        "use strict";
        const isFullwidthCodePoint = (codePoint)=>{
            if (Number.isNaN(codePoint)) return false;
            if (codePoint >= 0x1100 && (codePoint <= 0x115F || 0x2329 === codePoint || 0x232A === codePoint || 0x2E80 <= codePoint && codePoint <= 0x3247 && 0x303F !== codePoint || 0x3250 <= codePoint && codePoint <= 0x4DBF || 0x4E00 <= codePoint && codePoint <= 0xA4C6 || 0xA960 <= codePoint && codePoint <= 0xA97C || 0xAC00 <= codePoint && codePoint <= 0xD7A3 || 0xF900 <= codePoint && codePoint <= 0xFAFF || 0xFE10 <= codePoint && codePoint <= 0xFE19 || 0xFE30 <= codePoint && codePoint <= 0xFE6B || 0xFF01 <= codePoint && codePoint <= 0xFF60 || 0xFFE0 <= codePoint && codePoint <= 0xFFE6 || 0x1B000 <= codePoint && codePoint <= 0x1B001 || 0x1F200 <= codePoint && codePoint <= 0x1F251 || 0x20000 <= codePoint && codePoint <= 0x3FFFD)) return true;
            return false;
        };
        module.exports = isFullwidthCodePoint;
        module.exports["default"] = isFullwidthCodePoint;
    },
    "../node_modules/.pnpm/json-schema-traverse@1.0.0/node_modules/json-schema-traverse/index.js": function(module) {
        "use strict";
        var traverse = module.exports = function(schema, opts, cb) {
            if ('function' == typeof opts) {
                cb = opts;
                opts = {};
            }
            cb = opts.cb || cb;
            var pre = 'function' == typeof cb ? cb : cb.pre || function() {};
            var post = cb.post || function() {};
            _traverse(opts, pre, post, schema, '', schema);
        };
        traverse.keywords = {
            additionalItems: true,
            items: true,
            contains: true,
            additionalProperties: true,
            propertyNames: true,
            not: true,
            if: true,
            then: true,
            else: true
        };
        traverse.arrayKeywords = {
            items: true,
            allOf: true,
            anyOf: true,
            oneOf: true
        };
        traverse.propsKeywords = {
            $defs: true,
            definitions: true,
            properties: true,
            patternProperties: true,
            dependencies: true
        };
        traverse.skipKeywords = {
            default: true,
            enum: true,
            const: true,
            required: true,
            maximum: true,
            minimum: true,
            exclusiveMaximum: true,
            exclusiveMinimum: true,
            multipleOf: true,
            maxLength: true,
            minLength: true,
            pattern: true,
            format: true,
            maxItems: true,
            minItems: true,
            uniqueItems: true,
            maxProperties: true,
            minProperties: true
        };
        function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
            if (schema && 'object' == typeof schema && !Array.isArray(schema)) {
                pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
                for(var key in schema){
                    var sch = schema[key];
                    if (Array.isArray(sch)) {
                        if (key in traverse.arrayKeywords) for(var i = 0; i < sch.length; i++)_traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
                    } else if (key in traverse.propsKeywords) {
                        if (sch && 'object' == typeof sch) for(var prop in sch)_traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
                    } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
                }
                post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
            }
        }
        function escapeJsonPtr(str) {
            return str.replace(/~/g, '~0').replace(/\//g, '~1');
        }
    },
    "../node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js": function(module) {
        let p = process || {}, argv = p.argv || [], env = p.env || {};
        let isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || "win32" === p.platform || (p.stdout || {}).isTTY && "dumb" !== env.TERM || !!env.CI);
        let formatter = (open, close, replace = open)=>(input)=>{
                let string = "" + input, index = string.indexOf(close, open.length);
                return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
            };
        let replaceClose = (string, close, replace, index)=>{
            let result = "", cursor = 0;
            do {
                result += string.substring(cursor, index) + replace;
                cursor = index + close.length;
                index = string.indexOf(close, cursor);
            }while (~index);
            return result + string.substring(cursor);
        };
        let createColors = (enabled = isColorSupported)=>{
            let f = enabled ? formatter : ()=>String;
            return {
                isColorSupported: enabled,
                reset: f("\x1b[0m", "\x1b[0m"),
                bold: f("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m"),
                dim: f("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m"),
                italic: f("\x1b[3m", "\x1b[23m"),
                underline: f("\x1b[4m", "\x1b[24m"),
                inverse: f("\x1b[7m", "\x1b[27m"),
                hidden: f("\x1b[8m", "\x1b[28m"),
                strikethrough: f("\x1b[9m", "\x1b[29m"),
                black: f("\x1b[30m", "\x1b[39m"),
                red: f("\x1b[31m", "\x1b[39m"),
                green: f("\x1b[32m", "\x1b[39m"),
                yellow: f("\x1b[33m", "\x1b[39m"),
                blue: f("\x1b[34m", "\x1b[39m"),
                magenta: f("\x1b[35m", "\x1b[39m"),
                cyan: f("\x1b[36m", "\x1b[39m"),
                white: f("\x1b[37m", "\x1b[39m"),
                gray: f("\x1b[90m", "\x1b[39m"),
                bgBlack: f("\x1b[40m", "\x1b[49m"),
                bgRed: f("\x1b[41m", "\x1b[49m"),
                bgGreen: f("\x1b[42m", "\x1b[49m"),
                bgYellow: f("\x1b[43m", "\x1b[49m"),
                bgBlue: f("\x1b[44m", "\x1b[49m"),
                bgMagenta: f("\x1b[45m", "\x1b[49m"),
                bgCyan: f("\x1b[46m", "\x1b[49m"),
                bgWhite: f("\x1b[47m", "\x1b[49m"),
                blackBright: f("\x1b[90m", "\x1b[39m"),
                redBright: f("\x1b[91m", "\x1b[39m"),
                greenBright: f("\x1b[92m", "\x1b[39m"),
                yellowBright: f("\x1b[93m", "\x1b[39m"),
                blueBright: f("\x1b[94m", "\x1b[39m"),
                magentaBright: f("\x1b[95m", "\x1b[39m"),
                cyanBright: f("\x1b[96m", "\x1b[39m"),
                whiteBright: f("\x1b[97m", "\x1b[39m"),
                bgBlackBright: f("\x1b[100m", "\x1b[49m"),
                bgRedBright: f("\x1b[101m", "\x1b[49m"),
                bgGreenBright: f("\x1b[102m", "\x1b[49m"),
                bgYellowBright: f("\x1b[103m", "\x1b[49m"),
                bgBlueBright: f("\x1b[104m", "\x1b[49m"),
                bgMagentaBright: f("\x1b[105m", "\x1b[49m"),
                bgCyanBright: f("\x1b[106m", "\x1b[49m"),
                bgWhiteBright: f("\x1b[107m", "\x1b[49m")
            };
        };
        module.exports = createColors();
        module.exports.createColors = createColors;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/comparator.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const ANY = Symbol('SemVer ANY');
        class Comparator {
            static get ANY() {
                return ANY;
            }
            constructor(comp, options){
                options = parseOptions(options);
                if (comp instanceof Comparator) if (!!options.loose === comp.loose) return comp;
                else comp = comp.value;
                comp = comp.trim().split(/\s+/).join(' ');
                debug('comparator', comp, options);
                this.options = options;
                this.loose = !!options.loose;
                this.parse(comp);
                if (this.semver === ANY) this.value = '';
                else this.value = this.operator + this.semver.version;
                debug('comp', this);
            }
            parse(comp) {
                const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
                const m = comp.match(r);
                if (!m) throw new TypeError(`Invalid comparator: ${comp}`);
                this.operator = void 0 !== m[1] ? m[1] : '';
                if ('=' === this.operator) this.operator = '';
                if (m[2]) this.semver = new SemVer(m[2], this.options.loose);
                else this.semver = ANY;
            }
            toString() {
                return this.value;
            }
            test(version) {
                debug('Comparator.test', version, this.options.loose);
                if (this.semver === ANY || version === ANY) return true;
                if ('string' == typeof version) try {
                    version = new SemVer(version, this.options);
                } catch (er) {
                    return false;
                }
                return cmp(version, this.operator, this.semver, this.options);
            }
            intersects(comp, options) {
                if (!(comp instanceof Comparator)) throw new TypeError('a Comparator is required');
                if ('' === this.operator) {
                    if ('' === this.value) return true;
                    return new Range(comp.value, options).test(this.value);
                }
                if ('' === comp.operator) {
                    if ('' === comp.value) return true;
                    return new Range(this.value, options).test(comp.semver);
                }
                options = parseOptions(options);
                if (options.includePrerelease && ('<0.0.0-0' === this.value || '<0.0.0-0' === comp.value)) return false;
                if (!options.includePrerelease && (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) return false;
                if (this.operator.startsWith('>') && comp.operator.startsWith('>')) return true;
                if (this.operator.startsWith('<') && comp.operator.startsWith('<')) return true;
                if (this.semver.version === comp.semver.version && this.operator.includes('=') && comp.operator.includes('=')) return true;
                if (cmp(this.semver, '<', comp.semver, options) && this.operator.startsWith('>') && comp.operator.startsWith('<')) return true;
                if (cmp(this.semver, '>', comp.semver, options) && this.operator.startsWith('<') && comp.operator.startsWith('>')) return true;
                return false;
            }
        }
        module.exports = Comparator;
        const parseOptions = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/parse-options.js");
        const { safeRe: re, t } = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/re.js");
        const cmp = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/cmp.js");
        const debug = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/debug.js");
        const SemVer = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js");
        const Range = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/range.js");
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/range.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const SPACE_CHARACTERS = /\s+/g;
        class Range {
            constructor(range, options){
                options = parseOptions(options);
                if (range instanceof Range) if (!!options.loose === range.loose && !!options.includePrerelease === range.includePrerelease) return range;
                else return new Range(range.raw, options);
                if (range instanceof Comparator) {
                    this.raw = range.value;
                    this.set = [
                        [
                            range
                        ]
                    ];
                    this.formatted = void 0;
                    return this;
                }
                this.options = options;
                this.loose = !!options.loose;
                this.includePrerelease = !!options.includePrerelease;
                this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');
                this.set = this.raw.split('||').map((r)=>this.parseRange(r.trim())).filter((c)=>c.length);
                if (!this.set.length) throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
                if (this.set.length > 1) {
                    const first = this.set[0];
                    this.set = this.set.filter((c)=>!isNullSet(c[0]));
                    if (0 === this.set.length) this.set = [
                        first
                    ];
                    else if (this.set.length > 1) {
                        for (const c of this.set)if (1 === c.length && isAny(c[0])) {
                            this.set = [
                                c
                            ];
                            break;
                        }
                    }
                }
                this.formatted = void 0;
            }
            get range() {
                if (void 0 === this.formatted) {
                    this.formatted = '';
                    for(let i = 0; i < this.set.length; i++){
                        if (i > 0) this.formatted += '||';
                        const comps = this.set[i];
                        for(let k = 0; k < comps.length; k++){
                            if (k > 0) this.formatted += ' ';
                            this.formatted += comps[k].toString().trim();
                        }
                    }
                }
                return this.formatted;
            }
            format() {
                return this.range;
            }
            toString() {
                return this.range;
            }
            parseRange(range) {
                const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
                const memoKey = memoOpts + ':' + range;
                const cached = cache.get(memoKey);
                if (cached) return cached;
                const loose = this.options.loose;
                const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
                range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
                debug('hyphen replace', range);
                range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
                debug('comparator trim', range);
                range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
                debug('tilde trim', range);
                range = range.replace(re[t.CARETTRIM], caretTrimReplace);
                debug('caret trim', range);
                let rangeList = range.split(' ').map((comp)=>parseComparator(comp, this.options)).join(' ').split(/\s+/).map((comp)=>replaceGTE0(comp, this.options));
                if (loose) rangeList = rangeList.filter((comp)=>{
                    debug('loose invalid filter', comp, this.options);
                    return !!comp.match(re[t.COMPARATORLOOSE]);
                });
                debug('range list', rangeList);
                const rangeMap = new Map();
                const comparators = rangeList.map((comp)=>new Comparator(comp, this.options));
                for (const comp of comparators){
                    if (isNullSet(comp)) return [
                        comp
                    ];
                    rangeMap.set(comp.value, comp);
                }
                if (rangeMap.size > 1 && rangeMap.has('')) rangeMap.delete('');
                const result = [
                    ...rangeMap.values()
                ];
                cache.set(memoKey, result);
                return result;
            }
            intersects(range, options) {
                if (!(range instanceof Range)) throw new TypeError('a Range is required');
                return this.set.some((thisComparators)=>isSatisfiable(thisComparators, options) && range.set.some((rangeComparators)=>isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator)=>rangeComparators.every((rangeComparator)=>thisComparator.intersects(rangeComparator, options)))));
            }
            test(version) {
                if (!version) return false;
                if ('string' == typeof version) try {
                    version = new SemVer(version, this.options);
                } catch (er) {
                    return false;
                }
                for(let i = 0; i < this.set.length; i++)if (testSet(this.set[i], version, this.options)) return true;
                return false;
            }
        }
        module.exports = Range;
        const LRU = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/lrucache.js");
        const cache = new LRU();
        const parseOptions = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/parse-options.js");
        const Comparator = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/comparator.js");
        const debug = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/debug.js");
        const SemVer = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js");
        const { safeRe: re, t, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace } = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/re.js");
        const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/constants.js");
        const isNullSet = (c)=>'<0.0.0-0' === c.value;
        const isAny = (c)=>'' === c.value;
        const isSatisfiable = (comparators, options)=>{
            let result = true;
            const remainingComparators = comparators.slice();
            let testComparator = remainingComparators.pop();
            while(result && remainingComparators.length){
                result = remainingComparators.every((otherComparator)=>testComparator.intersects(otherComparator, options));
                testComparator = remainingComparators.pop();
            }
            return result;
        };
        const parseComparator = (comp, options)=>{
            debug('comp', comp, options);
            comp = replaceCarets(comp, options);
            debug('caret', comp);
            comp = replaceTildes(comp, options);
            debug('tildes', comp);
            comp = replaceXRanges(comp, options);
            debug('xrange', comp);
            comp = replaceStars(comp, options);
            debug('stars', comp);
            return comp;
        };
        const isX = (id)=>!id || 'x' === id.toLowerCase() || '*' === id;
        const replaceTildes = (comp, options)=>comp.trim().split(/\s+/).map((c)=>replaceTilde(c, options)).join(' ');
        const replaceTilde = (comp, options)=>{
            const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
            return comp.replace(r, (_, M, m, p, pr)=>{
                debug('tilde', comp, _, M, m, p, pr);
                let ret;
                if (isX(M)) ret = '';
                else if (isX(m)) ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
                else if (isX(p)) ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
                else if (pr) {
                    debug('replaceTilde pr', pr);
                    ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
                } else ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
                debug('tilde return', ret);
                return ret;
            });
        };
        const replaceCarets = (comp, options)=>comp.trim().split(/\s+/).map((c)=>replaceCaret(c, options)).join(' ');
        const replaceCaret = (comp, options)=>{
            debug('caret', comp, options);
            const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
            const z = options.includePrerelease ? '-0' : '';
            return comp.replace(r, (_, M, m, p, pr)=>{
                debug('caret', comp, _, M, m, p, pr);
                let ret;
                if (isX(M)) ret = '';
                else if (isX(m)) ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
                else if (isX(p)) ret = '0' === M ? `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
                else if (pr) {
                    debug('replaceCaret pr', pr);
                    ret = '0' === M ? '0' === m ? `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0` : `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
                } else {
                    debug('no pr');
                    ret = '0' === M ? '0' === m ? `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0` : `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
                }
                debug('caret return', ret);
                return ret;
            });
        };
        const replaceXRanges = (comp, options)=>{
            debug('replaceXRanges', comp, options);
            return comp.split(/\s+/).map((c)=>replaceXRange(c, options)).join(' ');
        };
        const replaceXRange = (comp, options)=>{
            comp = comp.trim();
            const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
            return comp.replace(r, (ret, gtlt, M, m, p, pr)=>{
                debug('xRange', comp, ret, gtlt, M, m, p, pr);
                const xM = isX(M);
                const xm = xM || isX(m);
                const xp = xm || isX(p);
                const anyX = xp;
                if ('=' === gtlt && anyX) gtlt = '';
                pr = options.includePrerelease ? '-0' : '';
                if (xM) ret = '>' === gtlt || '<' === gtlt ? '<0.0.0-0' : '*';
                else if (gtlt && anyX) {
                    if (xm) m = 0;
                    p = 0;
                    if ('>' === gtlt) {
                        gtlt = '>=';
                        if (xm) {
                            M = +M + 1;
                            m = 0;
                            p = 0;
                        } else {
                            m = +m + 1;
                            p = 0;
                        }
                    } else if ('<=' === gtlt) {
                        gtlt = '<';
                        if (xm) M = +M + 1;
                        else m = +m + 1;
                    }
                    if ('<' === gtlt) pr = '-0';
                    ret = `${gtlt + M}.${m}.${p}${pr}`;
                } else if (xm) ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
                else if (xp) ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
                debug('xRange return', ret);
                return ret;
            });
        };
        const replaceStars = (comp, options)=>{
            debug('replaceStars', comp, options);
            return comp.trim().replace(re[t.STAR], '');
        };
        const replaceGTE0 = (comp, options)=>{
            debug('replaceGTE0', comp, options);
            return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '');
        };
        const hyphenReplace = (incPr)=>($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr)=>{
                from = isX(fM) ? '' : isX(fm) ? `>=${fM}.0.0${incPr ? '-0' : ''}` : isX(fp) ? `>=${fM}.${fm}.0${incPr ? '-0' : ''}` : fpr ? `>=${from}` : `>=${from}${incPr ? '-0' : ''}`;
                to = isX(tM) ? '' : isX(tm) ? `<${+tM + 1}.0.0-0` : isX(tp) ? `<${tM}.${+tm + 1}.0-0` : tpr ? `<=${tM}.${tm}.${tp}-${tpr}` : incPr ? `<${tM}.${tm}.${+tp + 1}-0` : `<=${to}`;
                return `${from} ${to}`.trim();
            };
        const testSet = (set, version, options)=>{
            for(let i = 0; i < set.length; i++)if (!set[i].test(version)) return false;
            if (version.prerelease.length && !options.includePrerelease) {
                for(let i = 0; i < set.length; i++){
                    debug(set[i].semver);
                    if (set[i].semver !== Comparator.ANY) {
                        if (set[i].semver.prerelease.length > 0) {
                            const allowed = set[i].semver;
                            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return true;
                        }
                    }
                }
                return false;
            }
            return true;
        };
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const debug = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/debug.js");
        const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/constants.js");
        const { safeRe: re, t } = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/re.js");
        const parseOptions = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/parse-options.js");
        const { compareIdentifiers } = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/identifiers.js");
        class SemVer {
            constructor(version, options){
                options = parseOptions(options);
                if (version instanceof SemVer) if (!!options.loose === version.loose && !!options.includePrerelease === version.includePrerelease) return version;
                else version = version.version;
                else if ('string' != typeof version) throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
                if (version.length > MAX_LENGTH) throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
                debug('SemVer', version, options);
                this.options = options;
                this.loose = !!options.loose;
                this.includePrerelease = !!options.includePrerelease;
                const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
                if (!m) throw new TypeError(`Invalid Version: ${version}`);
                this.raw = version;
                this.major = +m[1];
                this.minor = +m[2];
                this.patch = +m[3];
                if (this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError('Invalid major version');
                if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError('Invalid minor version');
                if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError('Invalid patch version');
                if (m[4]) this.prerelease = m[4].split('.').map((id)=>{
                    if (/^[0-9]+$/.test(id)) {
                        const num = +id;
                        if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
                    }
                    return id;
                });
                else this.prerelease = [];
                this.build = m[5] ? m[5].split('.') : [];
                this.format();
            }
            format() {
                this.version = `${this.major}.${this.minor}.${this.patch}`;
                if (this.prerelease.length) this.version += `-${this.prerelease.join('.')}`;
                return this.version;
            }
            toString() {
                return this.version;
            }
            compare(other) {
                debug('SemVer.compare', this.version, this.options, other);
                if (!(other instanceof SemVer)) {
                    if ('string' == typeof other && other === this.version) return 0;
                    other = new SemVer(other, this.options);
                }
                if (other.version === this.version) return 0;
                return this.compareMain(other) || this.comparePre(other);
            }
            compareMain(other) {
                if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
                return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
            }
            comparePre(other) {
                if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
                if (this.prerelease.length && !other.prerelease.length) return -1;
                if (!this.prerelease.length && other.prerelease.length) return 1;
                if (!this.prerelease.length && !other.prerelease.length) return 0;
                let i = 0;
                do {
                    const a = this.prerelease[i];
                    const b = other.prerelease[i];
                    debug('prerelease compare', i, a, b);
                    if (void 0 === a && void 0 === b) return 0;
                    if (void 0 === b) return 1;
                    if (void 0 === a) return -1;
                    else if (a === b) continue;
                    else return compareIdentifiers(a, b);
                }while (++i);
            }
            compareBuild(other) {
                if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
                let i = 0;
                do {
                    const a = this.build[i];
                    const b = other.build[i];
                    debug('build compare', i, a, b);
                    if (void 0 === a && void 0 === b) return 0;
                    if (void 0 === b) return 1;
                    if (void 0 === a) return -1;
                    else if (a === b) continue;
                    else return compareIdentifiers(a, b);
                }while (++i);
            }
            inc(release, identifier, identifierBase) {
                if (release.startsWith('pre')) {
                    if (!identifier && false === identifierBase) throw new Error('invalid increment argument: identifier is empty');
                    if (identifier) {
                        const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
                        if (!match || match[1] !== identifier) throw new Error(`invalid identifier: ${identifier}`);
                    }
                }
                switch(release){
                    case 'premajor':
                        this.prerelease.length = 0;
                        this.patch = 0;
                        this.minor = 0;
                        this.major++;
                        this.inc('pre', identifier, identifierBase);
                        break;
                    case 'preminor':
                        this.prerelease.length = 0;
                        this.patch = 0;
                        this.minor++;
                        this.inc('pre', identifier, identifierBase);
                        break;
                    case 'prepatch':
                        this.prerelease.length = 0;
                        this.inc('patch', identifier, identifierBase);
                        this.inc('pre', identifier, identifierBase);
                        break;
                    case 'prerelease':
                        if (0 === this.prerelease.length) this.inc('patch', identifier, identifierBase);
                        this.inc('pre', identifier, identifierBase);
                        break;
                    case 'release':
                        if (0 === this.prerelease.length) throw new Error(`version ${this.raw} is not a prerelease`);
                        this.prerelease.length = 0;
                        break;
                    case 'major':
                        if (0 !== this.minor || 0 !== this.patch || 0 === this.prerelease.length) this.major++;
                        this.minor = 0;
                        this.patch = 0;
                        this.prerelease = [];
                        break;
                    case 'minor':
                        if (0 !== this.patch || 0 === this.prerelease.length) this.minor++;
                        this.patch = 0;
                        this.prerelease = [];
                        break;
                    case 'patch':
                        if (0 === this.prerelease.length) this.patch++;
                        this.prerelease = [];
                        break;
                    case 'pre':
                        {
                            const base = Number(identifierBase) ? 1 : 0;
                            if (0 === this.prerelease.length) this.prerelease = [
                                base
                            ];
                            else {
                                let i = this.prerelease.length;
                                while(--i >= 0)if ('number' == typeof this.prerelease[i]) {
                                    this.prerelease[i]++;
                                    i = -2;
                                }
                                if (-1 === i) {
                                    if (identifier === this.prerelease.join('.') && false === identifierBase) throw new Error('invalid increment argument: identifier already exists');
                                    this.prerelease.push(base);
                                }
                            }
                            if (identifier) {
                                let prerelease = [
                                    identifier,
                                    base
                                ];
                                if (false === identifierBase) prerelease = [
                                    identifier
                                ];
                                if (0 === compareIdentifiers(this.prerelease[0], identifier)) {
                                    if (isNaN(this.prerelease[1])) this.prerelease = prerelease;
                                } else this.prerelease = prerelease;
                            }
                            break;
                        }
                    default:
                        throw new Error(`invalid increment argument: ${release}`);
                }
                this.raw = this.format();
                if (this.build.length) this.raw += `+${this.build.join('.')}`;
                return this;
            }
        }
        module.exports = SemVer;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/clean.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const parse = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/parse.js");
        const clean = (version, options)=>{
            const s = parse(version.trim().replace(/^[=v]+/, ''), options);
            return s ? s.version : null;
        };
        module.exports = clean;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/cmp.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const eq = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/eq.js");
        const neq = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/neq.js");
        const gt = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/gt.js");
        const gte = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/gte.js");
        const lt = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/lt.js");
        const lte = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/lte.js");
        const cmp = (a, op, b, loose)=>{
            switch(op){
                case '===':
                    if ('object' == typeof a) a = a.version;
                    if ('object' == typeof b) b = b.version;
                    return a === b;
                case '!==':
                    if ('object' == typeof a) a = a.version;
                    if ('object' == typeof b) b = b.version;
                    return a !== b;
                case '':
                case '=':
                case '==':
                    return eq(a, b, loose);
                case '!=':
                    return neq(a, b, loose);
                case '>':
                    return gt(a, b, loose);
                case '>=':
                    return gte(a, b, loose);
                case '<':
                    return lt(a, b, loose);
                case '<=':
                    return lte(a, b, loose);
                default:
                    throw new TypeError(`Invalid operator: ${op}`);
            }
        };
        module.exports = cmp;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/coerce.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const SemVer = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js");
        const parse = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/parse.js");
        const { safeRe: re, t } = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/re.js");
        const coerce = (version, options)=>{
            if (version instanceof SemVer) return version;
            if ('number' == typeof version) version = String(version);
            if ('string' != typeof version) return null;
            options = options || {};
            let match = null;
            if (options.rtl) {
                const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
                let next;
                while((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)){
                    if (!match || next.index + next[0].length !== match.index + match[0].length) match = next;
                    coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
                }
                coerceRtlRegex.lastIndex = -1;
            } else match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
            if (null === match) return null;
            const major = match[2];
            const minor = match[3] || '0';
            const patch = match[4] || '0';
            const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : '';
            const build = options.includePrerelease && match[6] ? `+${match[6]}` : '';
            return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
        };
        module.exports = coerce;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare-build.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const SemVer = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js");
        const compareBuild = (a, b, loose)=>{
            const versionA = new SemVer(a, loose);
            const versionB = new SemVer(b, loose);
            return versionA.compare(versionB) || versionA.compareBuild(versionB);
        };
        module.exports = compareBuild;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare-loose.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const compare = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare.js");
        const compareLoose = (a, b)=>compare(a, b, true);
        module.exports = compareLoose;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const SemVer = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js");
        const compare = (a, b, loose)=>new SemVer(a, loose).compare(new SemVer(b, loose));
        module.exports = compare;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/diff.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const parse = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/parse.js");
        const diff = (version1, version2)=>{
            const v1 = parse(version1, null, true);
            const v2 = parse(version2, null, true);
            const comparison = v1.compare(v2);
            if (0 === comparison) return null;
            const v1Higher = comparison > 0;
            const highVersion = v1Higher ? v1 : v2;
            const lowVersion = v1Higher ? v2 : v1;
            const highHasPre = !!highVersion.prerelease.length;
            const lowHasPre = !!lowVersion.prerelease.length;
            if (lowHasPre && !highHasPre) {
                if (!lowVersion.patch && !lowVersion.minor) return 'major';
                if (0 === lowVersion.compareMain(highVersion)) {
                    if (lowVersion.minor && !lowVersion.patch) return 'minor';
                    return 'patch';
                }
            }
            const prefix = highHasPre ? 'pre' : '';
            if (v1.major !== v2.major) return prefix + 'major';
            if (v1.minor !== v2.minor) return prefix + 'minor';
            if (v1.patch !== v2.patch) return prefix + 'patch';
            return 'prerelease';
        };
        module.exports = diff;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/eq.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const compare = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare.js");
        const eq = (a, b, loose)=>0 === compare(a, b, loose);
        module.exports = eq;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/gt.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const compare = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare.js");
        const gt = (a, b, loose)=>compare(a, b, loose) > 0;
        module.exports = gt;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/gte.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const compare = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare.js");
        const gte = (a, b, loose)=>compare(a, b, loose) >= 0;
        module.exports = gte;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/inc.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const SemVer = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js");
        const inc = (version, release, options, identifier, identifierBase)=>{
            if ('string' == typeof options) {
                identifierBase = identifier;
                identifier = options;
                options = void 0;
            }
            try {
                return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
            } catch (er) {
                return null;
            }
        };
        module.exports = inc;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/lt.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const compare = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare.js");
        const lt = (a, b, loose)=>compare(a, b, loose) < 0;
        module.exports = lt;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/lte.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const compare = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare.js");
        const lte = (a, b, loose)=>compare(a, b, loose) <= 0;
        module.exports = lte;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/major.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const SemVer = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js");
        const major = (a, loose)=>new SemVer(a, loose).major;
        module.exports = major;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/minor.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const SemVer = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js");
        const minor = (a, loose)=>new SemVer(a, loose).minor;
        module.exports = minor;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/neq.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const compare = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare.js");
        const neq = (a, b, loose)=>0 !== compare(a, b, loose);
        module.exports = neq;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/parse.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const SemVer = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js");
        const parse = (version, options, throwErrors = false)=>{
            if (version instanceof SemVer) return version;
            try {
                return new SemVer(version, options);
            } catch (er) {
                if (!throwErrors) return null;
                throw er;
            }
        };
        module.exports = parse;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/patch.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const SemVer = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js");
        const patch = (a, loose)=>new SemVer(a, loose).patch;
        module.exports = patch;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/prerelease.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const parse = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/parse.js");
        const prerelease = (version, options)=>{
            const parsed = parse(version, options);
            return parsed && parsed.prerelease.length ? parsed.prerelease : null;
        };
        module.exports = prerelease;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/rcompare.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const compare = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare.js");
        const rcompare = (a, b, loose)=>compare(b, a, loose);
        module.exports = rcompare;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/rsort.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const compareBuild = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare-build.js");
        const rsort = (list, loose)=>list.sort((a, b)=>compareBuild(b, a, loose));
        module.exports = rsort;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/satisfies.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const Range = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/range.js");
        const satisfies = (version, range, options)=>{
            try {
                range = new Range(range, options);
            } catch (er) {
                return false;
            }
            return range.test(version);
        };
        module.exports = satisfies;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/sort.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const compareBuild = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare-build.js");
        const sort = (list, loose)=>list.sort((a, b)=>compareBuild(a, b, loose));
        module.exports = sort;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/valid.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const parse = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/parse.js");
        const valid = (version, options)=>{
            const v = parse(version, options);
            return v ? v.version : null;
        };
        module.exports = valid;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const internalRe = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/re.js");
        const constants = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/constants.js");
        const SemVer = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js");
        const identifiers = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/identifiers.js");
        const parse = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/parse.js");
        const valid = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/valid.js");
        const clean = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/clean.js");
        const inc = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/inc.js");
        const diff = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/diff.js");
        const major = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/major.js");
        const minor = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/minor.js");
        const patch = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/patch.js");
        const prerelease = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/prerelease.js");
        const compare = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare.js");
        const rcompare = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/rcompare.js");
        const compareLoose = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare-loose.js");
        const compareBuild = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare-build.js");
        const sort = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/sort.js");
        const rsort = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/rsort.js");
        const gt = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/gt.js");
        const lt = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/lt.js");
        const eq = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/eq.js");
        const neq = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/neq.js");
        const gte = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/gte.js");
        const lte = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/lte.js");
        const cmp = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/cmp.js");
        const coerce = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/coerce.js");
        const Comparator = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/comparator.js");
        const Range = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/range.js");
        const satisfies = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/satisfies.js");
        const toComparators = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/to-comparators.js");
        const maxSatisfying = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/max-satisfying.js");
        const minSatisfying = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/min-satisfying.js");
        const minVersion = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/min-version.js");
        const validRange = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/valid.js");
        const outside = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/outside.js");
        const gtr = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/gtr.js");
        const ltr = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/ltr.js");
        const intersects = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/intersects.js");
        const simplifyRange = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/simplify.js");
        const subset = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/subset.js");
        module.exports = {
            parse,
            valid,
            clean,
            inc,
            diff,
            major,
            minor,
            patch,
            prerelease,
            compare,
            rcompare,
            compareLoose,
            compareBuild,
            sort,
            rsort,
            gt,
            lt,
            eq,
            neq,
            gte,
            lte,
            cmp,
            coerce,
            Comparator,
            Range,
            satisfies,
            toComparators,
            maxSatisfying,
            minSatisfying,
            minVersion,
            validRange,
            outside,
            gtr,
            ltr,
            intersects,
            simplifyRange,
            subset,
            SemVer,
            re: internalRe.re,
            src: internalRe.src,
            tokens: internalRe.t,
            SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
            RELEASE_TYPES: constants.RELEASE_TYPES,
            compareIdentifiers: identifiers.compareIdentifiers,
            rcompareIdentifiers: identifiers.rcompareIdentifiers
        };
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/constants.js": function(module) {
        "use strict";
        const SEMVER_SPEC_VERSION = '2.0.0';
        const MAX_LENGTH = 256;
        const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
        const MAX_SAFE_COMPONENT_LENGTH = 16;
        const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
        const RELEASE_TYPES = [
            'major',
            'premajor',
            'minor',
            'preminor',
            'patch',
            'prepatch',
            'prerelease'
        ];
        module.exports = {
            MAX_LENGTH,
            MAX_SAFE_COMPONENT_LENGTH,
            MAX_SAFE_BUILD_LENGTH,
            MAX_SAFE_INTEGER,
            RELEASE_TYPES,
            SEMVER_SPEC_VERSION,
            FLAG_INCLUDE_PRERELEASE: 1,
            FLAG_LOOSE: 2
        };
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/debug.js": function(module) {
        "use strict";
        const debug = 'object' == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args)=>console.error('SEMVER', ...args) : ()=>{};
        module.exports = debug;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/identifiers.js": function(module) {
        "use strict";
        const numeric = /^[0-9]+$/;
        const compareIdentifiers = (a, b)=>{
            const anum = numeric.test(a);
            const bnum = numeric.test(b);
            if (anum && bnum) {
                a *= 1;
                b *= 1;
            }
            return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
        };
        const rcompareIdentifiers = (a, b)=>compareIdentifiers(b, a);
        module.exports = {
            compareIdentifiers,
            rcompareIdentifiers
        };
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/lrucache.js": function(module) {
        "use strict";
        class LRUCache {
            constructor(){
                this.max = 1000;
                this.map = new Map();
            }
            get(key) {
                const value = this.map.get(key);
                if (void 0 === value) return;
                this.map.delete(key);
                this.map.set(key, value);
                return value;
            }
            delete(key) {
                return this.map.delete(key);
            }
            set(key, value) {
                const deleted = this.delete(key);
                if (!deleted && void 0 !== value) {
                    if (this.map.size >= this.max) {
                        const firstKey = this.map.keys().next().value;
                        this.delete(firstKey);
                    }
                    this.map.set(key, value);
                }
                return this;
            }
        }
        module.exports = LRUCache;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/parse-options.js": function(module) {
        "use strict";
        const looseOption = Object.freeze({
            loose: true
        });
        const emptyOpts = Object.freeze({});
        const parseOptions = (options)=>{
            if (!options) return emptyOpts;
            if ('object' != typeof options) return looseOption;
            return options;
        };
        module.exports = parseOptions;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/re.js": function(module, exports1, __webpack_require__) {
        "use strict";
        const { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH } = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/constants.js");
        const debug = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/internal/debug.js");
        exports1 = module.exports = {};
        const re = exports1.re = [];
        const safeRe = exports1.safeRe = [];
        const src = exports1.src = [];
        const safeSrc = exports1.safeSrc = [];
        const t = exports1.t = {};
        let R = 0;
        const LETTERDASHNUMBER = '[a-zA-Z0-9-]';
        const safeRegexReplacements = [
            [
                '\\s',
                1
            ],
            [
                '\\d',
                MAX_LENGTH
            ],
            [
                LETTERDASHNUMBER,
                MAX_SAFE_BUILD_LENGTH
            ]
        ];
        const makeSafeRegex = (value)=>{
            for (const [token, max] of safeRegexReplacements)value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
            return value;
        };
        const createToken = (name, value, isGlobal)=>{
            const safe = makeSafeRegex(value);
            const index = R++;
            debug(name, index, value);
            t[name] = index;
            src[index] = value;
            safeSrc[index] = safe;
            re[index] = new RegExp(value, isGlobal ? 'g' : void 0);
            safeRe[index] = new RegExp(safe, isGlobal ? 'g' : void 0);
        };
        createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
        createToken('NUMERICIDENTIFIERLOOSE', '\\d+');
        createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
        createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
        createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
        createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
        createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
        createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
        createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
        createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);
        createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
        createToken('FULLPLAIN', `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
        createToken('FULL', `^${src[t.FULLPLAIN]}$`);
        createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
        createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);
        createToken('GTLT', '((?:<|>)?=?)');
        createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
        createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
        createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
        createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
        createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
        createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
        createToken('COERCEPLAIN', `(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
        createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
        createToken('COERCEFULL', src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + "(?:$|[^\\d])");
        createToken('COERCERTL', src[t.COERCE], true);
        createToken('COERCERTLFULL', src[t.COERCEFULL], true);
        createToken('LONETILDE', '(?:~>?)');
        createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
        exports1.tildeTrimReplace = '$1~';
        createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
        createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
        createToken('LONECARET', '(?:\\^)');
        createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
        exports1.caretTrimReplace = '$1^';
        createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
        createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
        createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
        createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
        createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
        exports1.comparatorTrimReplace = '$1$2$3';
        createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*\$`);
        createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*\$`);
        createToken('STAR', '(<|>)?=?\\s*\\*');
        createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
        createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/gtr.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const outside = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/outside.js");
        const gtr = (version, range, options)=>outside(version, range, '>', options);
        module.exports = gtr;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/intersects.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const Range = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/range.js");
        const intersects = (r1, r2, options)=>{
            r1 = new Range(r1, options);
            r2 = new Range(r2, options);
            return r1.intersects(r2, options);
        };
        module.exports = intersects;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/ltr.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const outside = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/outside.js");
        const ltr = (version, range, options)=>outside(version, range, '<', options);
        module.exports = ltr;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/max-satisfying.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const SemVer = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js");
        const Range = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/range.js");
        const maxSatisfying = (versions, range, options)=>{
            let max = null;
            let maxSV = null;
            let rangeObj = null;
            try {
                rangeObj = new Range(range, options);
            } catch (er) {
                return null;
            }
            versions.forEach((v)=>{
                if (rangeObj.test(v)) {
                    if (!max || -1 === maxSV.compare(v)) {
                        max = v;
                        maxSV = new SemVer(max, options);
                    }
                }
            });
            return max;
        };
        module.exports = maxSatisfying;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/min-satisfying.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const SemVer = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js");
        const Range = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/range.js");
        const minSatisfying = (versions, range, options)=>{
            let min = null;
            let minSV = null;
            let rangeObj = null;
            try {
                rangeObj = new Range(range, options);
            } catch (er) {
                return null;
            }
            versions.forEach((v)=>{
                if (rangeObj.test(v)) {
                    if (!min || 1 === minSV.compare(v)) {
                        min = v;
                        minSV = new SemVer(min, options);
                    }
                }
            });
            return min;
        };
        module.exports = minSatisfying;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/min-version.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const SemVer = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js");
        const Range = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/range.js");
        const gt = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/gt.js");
        const minVersion = (range, loose)=>{
            range = new Range(range, loose);
            let minver = new SemVer('0.0.0');
            if (range.test(minver)) return minver;
            minver = new SemVer('0.0.0-0');
            if (range.test(minver)) return minver;
            minver = null;
            for(let i = 0; i < range.set.length; ++i){
                const comparators = range.set[i];
                let setMin = null;
                comparators.forEach((comparator)=>{
                    const compver = new SemVer(comparator.semver.version);
                    switch(comparator.operator){
                        case '>':
                            if (0 === compver.prerelease.length) compver.patch++;
                            else compver.prerelease.push(0);
                            compver.raw = compver.format();
                        case '':
                        case '>=':
                            if (!setMin || gt(compver, setMin)) setMin = compver;
                            break;
                        case '<':
                        case '<=':
                            break;
                        default:
                            throw new Error(`Unexpected operation: ${comparator.operator}`);
                    }
                });
                if (setMin && (!minver || gt(minver, setMin))) minver = setMin;
            }
            if (minver && range.test(minver)) return minver;
            return null;
        };
        module.exports = minVersion;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/outside.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const SemVer = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/semver.js");
        const Comparator = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/comparator.js");
        const { ANY } = Comparator;
        const Range = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/range.js");
        const satisfies = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/satisfies.js");
        const gt = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/gt.js");
        const lt = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/lt.js");
        const lte = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/lte.js");
        const gte = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/gte.js");
        const outside = (version, range, hilo, options)=>{
            version = new SemVer(version, options);
            range = new Range(range, options);
            let gtfn, ltefn, ltfn, comp, ecomp;
            switch(hilo){
                case '>':
                    gtfn = gt;
                    ltefn = lte;
                    ltfn = lt;
                    comp = '>';
                    ecomp = '>=';
                    break;
                case '<':
                    gtfn = lt;
                    ltefn = gte;
                    ltfn = gt;
                    comp = '<';
                    ecomp = '<=';
                    break;
                default:
                    throw new TypeError('Must provide a hilo val of "<" or ">"');
            }
            if (satisfies(version, range, options)) return false;
            for(let i = 0; i < range.set.length; ++i){
                const comparators = range.set[i];
                let high = null;
                let low = null;
                comparators.forEach((comparator)=>{
                    if (comparator.semver === ANY) comparator = new Comparator('>=0.0.0');
                    high = high || comparator;
                    low = low || comparator;
                    if (gtfn(comparator.semver, high.semver, options)) high = comparator;
                    else if (ltfn(comparator.semver, low.semver, options)) low = comparator;
                });
                if (high.operator === comp || high.operator === ecomp) return false;
                if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) return false;
                if (low.operator === ecomp && ltfn(version, low.semver)) return false;
            }
            return true;
        };
        module.exports = outside;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/simplify.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const satisfies = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/satisfies.js");
        const compare = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare.js");
        module.exports = (versions, range, options)=>{
            const set = [];
            let first = null;
            let prev = null;
            const v = versions.sort((a, b)=>compare(a, b, options));
            for (const version of v){
                const included = satisfies(version, range, options);
                if (included) {
                    prev = version;
                    if (!first) first = version;
                } else {
                    if (prev) set.push([
                        first,
                        prev
                    ]);
                    prev = null;
                    first = null;
                }
            }
            if (first) set.push([
                first,
                null
            ]);
            const ranges = [];
            for (const [min, max] of set)if (min === max) ranges.push(min);
            else if (max || min !== v[0]) if (max) if (min === v[0]) ranges.push(`<=${max}`);
            else ranges.push(`${min} - ${max}`);
            else ranges.push(`>=${min}`);
            else ranges.push('*');
            const simplified = ranges.join(' || ');
            const original = 'string' == typeof range.raw ? range.raw : String(range);
            return simplified.length < original.length ? simplified : range;
        };
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/subset.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const Range = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/range.js");
        const Comparator = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/comparator.js");
        const { ANY } = Comparator;
        const satisfies = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/satisfies.js");
        const compare = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/functions/compare.js");
        const subset = (sub, dom, options = {})=>{
            if (sub === dom) return true;
            sub = new Range(sub, options);
            dom = new Range(dom, options);
            let sawNonNull = false;
            OUTER: for (const simpleSub of sub.set){
                for (const simpleDom of dom.set){
                    const isSub = simpleSubset(simpleSub, simpleDom, options);
                    sawNonNull = sawNonNull || null !== isSub;
                    if (isSub) continue OUTER;
                }
                if (sawNonNull) return false;
            }
            return true;
        };
        const minimumVersionWithPreRelease = [
            new Comparator('>=0.0.0-0')
        ];
        const minimumVersion = [
            new Comparator('>=0.0.0')
        ];
        const simpleSubset = (sub, dom, options)=>{
            if (sub === dom) return true;
            if (1 === sub.length && sub[0].semver === ANY) if (1 === dom.length && dom[0].semver === ANY) return true;
            else sub = options.includePrerelease ? minimumVersionWithPreRelease : minimumVersion;
            if (1 === dom.length && dom[0].semver === ANY) if (options.includePrerelease) return true;
            else dom = minimumVersion;
            const eqSet = new Set();
            let gt, lt;
            for (const c of sub)if ('>' === c.operator || '>=' === c.operator) gt = higherGT(gt, c, options);
            else if ('<' === c.operator || '<=' === c.operator) lt = lowerLT(lt, c, options);
            else eqSet.add(c.semver);
            if (eqSet.size > 1) return null;
            let gtltComp;
            if (gt && lt) {
                gtltComp = compare(gt.semver, lt.semver, options);
                if (gtltComp > 0) return null;
                if (0 === gtltComp && ('>=' !== gt.operator || '<=' !== lt.operator)) return null;
            }
            for (const eq of eqSet){
                if (gt && !satisfies(eq, String(gt), options)) return null;
                if (lt && !satisfies(eq, String(lt), options)) return null;
                for (const c of dom)if (!satisfies(eq, String(c), options)) return false;
                return true;
            }
            let higher, lower;
            let hasDomLT, hasDomGT;
            let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
            let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
            if (needDomLTPre && 1 === needDomLTPre.prerelease.length && '<' === lt.operator && 0 === needDomLTPre.prerelease[0]) needDomLTPre = false;
            for (const c of dom){
                hasDomGT = hasDomGT || '>' === c.operator || '>=' === c.operator;
                hasDomLT = hasDomLT || '<' === c.operator || '<=' === c.operator;
                if (gt) {
                    if (needDomGTPre) {
                        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) needDomGTPre = false;
                    }
                    if ('>' === c.operator || '>=' === c.operator) {
                        higher = higherGT(gt, c, options);
                        if (higher === c && higher !== gt) return false;
                    } else if ('>=' === gt.operator && !satisfies(gt.semver, String(c), options)) return false;
                }
                if (lt) {
                    if (needDomLTPre) {
                        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) needDomLTPre = false;
                    }
                    if ('<' === c.operator || '<=' === c.operator) {
                        lower = lowerLT(lt, c, options);
                        if (lower === c && lower !== lt) return false;
                    } else if ('<=' === lt.operator && !satisfies(lt.semver, String(c), options)) return false;
                }
                if (!c.operator && (lt || gt) && 0 !== gtltComp) return false;
            }
            if (gt && hasDomLT && !lt && 0 !== gtltComp) return false;
            if (lt && hasDomGT && !gt && 0 !== gtltComp) return false;
            if (needDomGTPre || needDomLTPre) return false;
            return true;
        };
        const higherGT = (a, b, options)=>{
            if (!a) return b;
            const comp = compare(a.semver, b.semver, options);
            return comp > 0 ? a : comp < 0 ? b : '>' === b.operator && '>=' === a.operator ? b : a;
        };
        const lowerLT = (a, b, options)=>{
            if (!a) return b;
            const comp = compare(a.semver, b.semver, options);
            return comp < 0 ? a : comp > 0 ? b : '<' === b.operator && '<=' === a.operator ? b : a;
        };
        module.exports = subset;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/to-comparators.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const Range = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/range.js");
        const toComparators = (range, options)=>new Range(range, options).set.map((comp)=>comp.map((c)=>c.value).join(' ').trim().split(' '));
        module.exports = toComparators;
    },
    "../node_modules/.pnpm/semver@7.7.2/node_modules/semver/ranges/valid.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const Range = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/classes/range.js");
        const validRange = (range, options)=>{
            try {
                return new Range(range, options).range || '*';
            } catch (er) {
                return null;
            }
        };
        module.exports = validRange;
    },
    "../node_modules/.pnpm/sisteransi@1.0.5/node_modules/sisteransi/src/index.js": function(module) {
        "use strict";
        const ESC = '\x1B';
        const CSI = `${ESC}[`;
        const beep = '\u0007';
        const cursor = {
            to (x, y) {
                if (!y) return `${CSI}${x + 1}G`;
                return `${CSI}${y + 1};${x + 1}H`;
            },
            move (x, y) {
                let ret = '';
                if (x < 0) ret += `${CSI}${-x}D`;
                else if (x > 0) ret += `${CSI}${x}C`;
                if (y < 0) ret += `${CSI}${-y}A`;
                else if (y > 0) ret += `${CSI}${y}B`;
                return ret;
            },
            up: (count = 1)=>`${CSI}${count}A`,
            down: (count = 1)=>`${CSI}${count}B`,
            forward: (count = 1)=>`${CSI}${count}C`,
            backward: (count = 1)=>`${CSI}${count}D`,
            nextLine: (count = 1)=>`${CSI}E`.repeat(count),
            prevLine: (count = 1)=>`${CSI}F`.repeat(count),
            left: `${CSI}G`,
            hide: `${CSI}?25l`,
            show: `${CSI}?25h`,
            save: `${ESC}7`,
            restore: `${ESC}8`
        };
        const scroll = {
            up: (count = 1)=>`${CSI}S`.repeat(count),
            down: (count = 1)=>`${CSI}T`.repeat(count)
        };
        const erase = {
            screen: `${CSI}2J`,
            up: (count = 1)=>`${CSI}1J`.repeat(count),
            down: (count = 1)=>`${CSI}J`.repeat(count),
            line: `${CSI}2K`,
            lineEnd: `${CSI}K`,
            lineStart: `${CSI}1K`,
            lines (count) {
                let clear = '';
                for(let i = 0; i < count; i++)clear += this.line + (i < count - 1 ? cursor.up() : '');
                if (count) clear += cursor.left;
                return clear;
            }
        };
        module.exports = {
            cursor,
            scroll,
            erase,
            beep
        };
    },
    "../node_modules/.pnpm/string-width@4.2.3/node_modules/string-width/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const stripAnsi = __webpack_require__("../node_modules/.pnpm/strip-ansi@6.0.1/node_modules/strip-ansi/index.js");
        const isFullwidthCodePoint = __webpack_require__("../node_modules/.pnpm/is-fullwidth-code-point@3.0.0/node_modules/is-fullwidth-code-point/index.js");
        const emojiRegex = __webpack_require__("../node_modules/.pnpm/emoji-regex@8.0.0/node_modules/emoji-regex/index.js");
        const stringWidth = (string)=>{
            if ('string' != typeof string || 0 === string.length) return 0;
            string = stripAnsi(string);
            if (0 === string.length) return 0;
            string = string.replace(emojiRegex(), '  ');
            let width = 0;
            for(let i = 0; i < string.length; i++){
                const code = string.codePointAt(i);
                if (!(code <= 0x1F) && (!(code >= 0x7F) || !(code <= 0x9F))) {
                    if (!(code >= 0x300) || !(code <= 0x36F)) {
                        if (code > 0xFFFF) i++;
                        width += isFullwidthCodePoint(code) ? 2 : 1;
                    }
                }
            }
            return width;
        };
        module.exports = stringWidth;
        module.exports["default"] = stringWidth;
    },
    "../node_modules/.pnpm/strip-ansi@6.0.1/node_modules/strip-ansi/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const ansiRegex = __webpack_require__("../node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js");
        module.exports = (string)=>'string' == typeof string ? string.replace(ansiRegex(), '') : string;
    },
    "../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const os = __webpack_require__("os");
        const tty = __webpack_require__("tty");
        const hasFlag = __webpack_require__("../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js");
        const { env } = process;
        let forceColor;
        if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) forceColor = 0;
        else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) forceColor = 1;
        if ('FORCE_COLOR' in env) forceColor = 'true' === env.FORCE_COLOR ? 1 : 'false' === env.FORCE_COLOR ? 0 : 0 === env.FORCE_COLOR.length ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
        function translateLevel(level) {
            if (0 === level) return false;
            return {
                level,
                hasBasic: true,
                has256: level >= 2,
                has16m: level >= 3
            };
        }
        function supportsColor(haveStream, streamIsTTY) {
            if (0 === forceColor) return 0;
            if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) return 3;
            if (hasFlag('color=256')) return 2;
            if (haveStream && !streamIsTTY && void 0 === forceColor) return 0;
            const min = forceColor || 0;
            if ('dumb' === env.TERM) return min;
            if ('win32' === process.platform) {
                const osRelease = os.release().split('.');
                if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) return Number(osRelease[2]) >= 14931 ? 3 : 2;
                return 1;
            }
            if ('CI' in env) {
                if ([
                    'TRAVIS',
                    'CIRCLECI',
                    'APPVEYOR',
                    'GITLAB_CI',
                    'GITHUB_ACTIONS',
                    'BUILDKITE'
                ].some((sign)=>sign in env) || 'codeship' === env.CI_NAME) return 1;
                return min;
            }
            if ('TEAMCITY_VERSION' in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
            if ('truecolor' === env.COLORTERM) return 3;
            if ('TERM_PROGRAM' in env) {
                const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
                switch(env.TERM_PROGRAM){
                    case 'iTerm.app':
                        return version >= 3 ? 3 : 2;
                    case 'Apple_Terminal':
                        return 2;
                }
            }
            if (/-256(color)?$/i.test(env.TERM)) return 2;
            if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) return 1;
            if ('COLORTERM' in env) return 1;
            return min;
        }
        function getSupportLevel(stream) {
            const level = supportsColor(stream, stream && stream.isTTY);
            return translateLevel(level);
        }
        module.exports = {
            supportsColor: getSupportLevel,
            stdout: translateLevel(supportsColor(true, tty.isatty(1))),
            stderr: translateLevel(supportsColor(true, tty.isatty(2)))
        };
    },
    "../node_modules/.pnpm/tinygradient@1.1.5/node_modules/tinygradient/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        const tinycolor = __webpack_require__("../node_modules/.pnpm/tinycolor2@1.6.0/node_modules/tinycolor2/cjs/tinycolor.js");
        const RGBA_MAX = {
            r: 256,
            g: 256,
            b: 256,
            a: 1
        };
        const HSVA_MAX = {
            h: 360,
            s: 1,
            v: 1,
            a: 1
        };
        function stepize(start, end, steps) {
            let step = {};
            for(let k in start)if (start.hasOwnProperty(k)) step[k] = 0 === steps ? 0 : (end[k] - start[k]) / steps;
            return step;
        }
        function interpolate(step, start, i, max) {
            let color = {};
            for(let k in start)if (start.hasOwnProperty(k)) {
                color[k] = step[k] * i + start[k];
                color[k] = color[k] < 0 ? color[k] + max[k] : 1 !== max[k] ? color[k] % max[k] : color[k];
            }
            return color;
        }
        function interpolateRgb(stop1, stop2, steps) {
            const start = stop1.color.toRgb();
            const end = stop2.color.toRgb();
            const step = stepize(start, end, steps);
            let gradient = [
                stop1.color
            ];
            for(let i = 1; i < steps; i++){
                const color = interpolate(step, start, i, RGBA_MAX);
                gradient.push(tinycolor(color));
            }
            return gradient;
        }
        function interpolateHsv(stop1, stop2, steps, mode) {
            const start = stop1.color.toHsv();
            const end = stop2.color.toHsv();
            if (0 === start.s || 0 === end.s) return interpolateRgb(stop1, stop2, steps);
            let trigonometric;
            if ('boolean' == typeof mode) trigonometric = mode;
            else {
                const trigShortest = start.h < end.h && end.h - start.h < 180 || start.h > end.h && start.h - end.h > 180;
                trigonometric = 'long' === mode && trigShortest || 'short' === mode && !trigShortest;
            }
            const step = stepize(start, end, steps);
            let gradient = [
                stop1.color
            ];
            let diff;
            diff = start.h <= end.h && !trigonometric || start.h >= end.h && trigonometric ? end.h - start.h : trigonometric ? 360 - end.h + start.h : 360 - start.h + end.h;
            step.h = Math.pow(-1, trigonometric ? 1 : 0) * Math.abs(diff) / steps;
            for(let i = 1; i < steps; i++){
                const color = interpolate(step, start, i, HSVA_MAX);
                gradient.push(tinycolor(color));
            }
            return gradient;
        }
        function computeSubsteps(stops, steps) {
            const l = stops.length;
            steps = parseInt(steps, 10);
            if (isNaN(steps) || steps < 2) throw new Error('Invalid number of steps (< 2)');
            if (steps < l) throw new Error('Number of steps cannot be inferior to number of stops');
            let substeps = [];
            for(let i = 1; i < l; i++){
                const step = (steps - 1) * (stops[i].pos - stops[i - 1].pos);
                substeps.push(Math.max(1, Math.round(step)));
            }
            let totalSubsteps = 1;
            for(let n = l - 1; n--;)totalSubsteps += substeps[n];
            while(totalSubsteps !== steps)if (totalSubsteps < steps) {
                const min = Math.min.apply(null, substeps);
                substeps[substeps.indexOf(min)]++;
                totalSubsteps++;
            } else {
                const max = Math.max.apply(null, substeps);
                substeps[substeps.indexOf(max)]--;
                totalSubsteps--;
            }
            return substeps;
        }
        function computeAt(stops, pos, method, max) {
            if (pos < 0 || pos > 1) throw new Error('Position must be between 0 and 1');
            let start, end;
            for(let i = 0, l = stops.length; i < l - 1; i++)if (pos >= stops[i].pos && pos < stops[i + 1].pos) {
                start = stops[i];
                end = stops[i + 1];
                break;
            }
            if (!start) start = end = stops[stops.length - 1];
            const step = stepize(start.color[method](), end.color[method](), (end.pos - start.pos) * 100);
            const color = interpolate(step, start.color[method](), (pos - start.pos) * 100, max);
            return tinycolor(color);
        }
        class TinyGradient {
            constructor(stops){
                if (stops.length < 2) throw new Error('Invalid number of stops (< 2)');
                const havingPositions = void 0 !== stops[0].pos;
                let l = stops.length;
                let p = -1;
                let lastColorLess = false;
                this.stops = stops.map((stop, i)=>{
                    const hasPosition = void 0 !== stop.pos;
                    if (havingPositions ^ hasPosition) throw new Error('Cannot mix positionned and not posionned color stops');
                    if (hasPosition) {
                        const hasColor = void 0 !== stop.color;
                        if (!hasColor && (lastColorLess || 0 === i || i === l - 1)) throw new Error('Cannot define two consecutive position-only stops');
                        lastColorLess = !hasColor;
                        stop = {
                            color: hasColor ? tinycolor(stop.color) : null,
                            colorLess: !hasColor,
                            pos: stop.pos
                        };
                        if (stop.pos < 0 || stop.pos > 1) throw new Error('Color stops positions must be between 0 and 1');
                        if (stop.pos < p) throw new Error('Color stops positions are not ordered');
                        p = stop.pos;
                    } else stop = {
                        color: tinycolor(void 0 !== stop.color ? stop.color : stop),
                        pos: i / (l - 1)
                    };
                    return stop;
                });
                if (0 !== this.stops[0].pos) {
                    this.stops.unshift({
                        color: this.stops[0].color,
                        pos: 0
                    });
                    l++;
                }
                if (1 !== this.stops[l - 1].pos) this.stops.push({
                    color: this.stops[l - 1].color,
                    pos: 1
                });
            }
            reverse() {
                let stops = [];
                this.stops.forEach(function(stop) {
                    stops.push({
                        color: stop.color,
                        pos: 1 - stop.pos
                    });
                });
                return new TinyGradient(stops.reverse());
            }
            loop() {
                let stops1 = [];
                let stops2 = [];
                this.stops.forEach((stop)=>{
                    stops1.push({
                        color: stop.color,
                        pos: stop.pos / 2
                    });
                });
                this.stops.slice(0, -1).forEach((stop)=>{
                    stops2.push({
                        color: stop.color,
                        pos: 1 - stop.pos / 2
                    });
                });
                return new TinyGradient(stops1.concat(stops2.reverse()));
            }
            rgb(steps) {
                const substeps = computeSubsteps(this.stops, steps);
                let gradient = [];
                this.stops.forEach((stop, i)=>{
                    if (stop.colorLess) stop.color = interpolateRgb(this.stops[i - 1], this.stops[i + 1], 2)[1];
                });
                for(let i = 0, l = this.stops.length; i < l - 1; i++){
                    const rgb = interpolateRgb(this.stops[i], this.stops[i + 1], substeps[i]);
                    gradient.splice(gradient.length, 0, ...rgb);
                }
                gradient.push(this.stops[this.stops.length - 1].color);
                return gradient;
            }
            hsv(steps, mode) {
                const substeps = computeSubsteps(this.stops, steps);
                let gradient = [];
                this.stops.forEach((stop, i)=>{
                    if (stop.colorLess) stop.color = interpolateHsv(this.stops[i - 1], this.stops[i + 1], 2, mode)[1];
                });
                for(let i = 0, l = this.stops.length; i < l - 1; i++){
                    const hsv = interpolateHsv(this.stops[i], this.stops[i + 1], substeps[i], mode);
                    gradient.splice(gradient.length, 0, ...hsv);
                }
                gradient.push(this.stops[this.stops.length - 1].color);
                return gradient;
            }
            css(mode, direction) {
                mode = mode || 'linear';
                direction = direction || ('linear' === mode ? 'to right' : 'ellipse at center');
                let css = mode + '-gradient(' + direction;
                this.stops.forEach(function(stop) {
                    css += ', ' + (stop.colorLess ? '' : stop.color.toRgbString() + ' ') + 100 * stop.pos + '%';
                });
                css += ')';
                return css;
            }
            rgbAt(pos) {
                return computeAt(this.stops, pos, 'toRgb', RGBA_MAX);
            }
            hsvAt(pos) {
                return computeAt(this.stops, pos, 'toHsv', HSVA_MAX);
            }
        }
        module.exports = function(stops) {
            if (1 === arguments.length) {
                if (!Array.isArray(arguments[0])) throw new Error('"stops" is not an array');
                stops = arguments[0];
            } else stops = Array.prototype.slice.call(arguments);
            return new TinyGradient(stops);
        };
    },
    "../node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var punycode = __webpack_require__("punycode");
        var mappingTable = __webpack_require__("../node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/lib/mappingTable.json");
        var PROCESSING_OPTIONS = {
            TRANSITIONAL: 0,
            NONTRANSITIONAL: 1
        };
        function normalize(str) {
            return str.split('\u0000').map(function(s) {
                return s.normalize('NFC');
            }).join('\u0000');
        }
        function findStatus(val) {
            var start = 0;
            var end = mappingTable.length - 1;
            while(start <= end){
                var mid = Math.floor((start + end) / 2);
                var target = mappingTable[mid];
                if (target[0][0] <= val && target[0][1] >= val) return target;
                if (target[0][0] > val) end = mid - 1;
                else start = mid + 1;
            }
            return null;
        }
        var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        function countSymbols(string) {
            return string.replace(regexAstralSymbols, '_').length;
        }
        function mapChars(domain_name, useSTD3, processing_option) {
            var hasError = false;
            var processed = "";
            var len = countSymbols(domain_name);
            for(var i = 0; i < len; ++i){
                var codePoint = domain_name.codePointAt(i);
                var status = findStatus(codePoint);
                switch(status[1]){
                    case "disallowed":
                        hasError = true;
                        processed += String.fromCodePoint(codePoint);
                        break;
                    case "ignored":
                        break;
                    case "mapped":
                        processed += String.fromCodePoint.apply(String, status[2]);
                        break;
                    case "deviation":
                        if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) processed += String.fromCodePoint.apply(String, status[2]);
                        else processed += String.fromCodePoint(codePoint);
                        break;
                    case "valid":
                        processed += String.fromCodePoint(codePoint);
                        break;
                    case "disallowed_STD3_mapped":
                        if (useSTD3) {
                            hasError = true;
                            processed += String.fromCodePoint(codePoint);
                        } else processed += String.fromCodePoint.apply(String, status[2]);
                        break;
                    case "disallowed_STD3_valid":
                        if (useSTD3) hasError = true;
                        processed += String.fromCodePoint(codePoint);
                        break;
                }
            }
            return {
                string: processed,
                error: hasError
            };
        }
        var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
        function validateLabel(label, processing_option) {
            if ("xn--" === label.substr(0, 4)) {
                label = punycode.toUnicode(label);
                PROCESSING_OPTIONS.NONTRANSITIONAL;
            }
            var error = false;
            if (normalize(label) !== label || "-" === label[3] && "-" === label[4] || "-" === label[0] || "-" === label[label.length - 1] || -1 !== label.indexOf(".") || 0 === label.search(combiningMarksRegex)) error = true;
            var len = countSymbols(label);
            for(var i = 0; i < len; ++i){
                var status = findStatus(label.codePointAt(i));
                if (processing === PROCESSING_OPTIONS.TRANSITIONAL && "valid" !== status[1] || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && "valid" !== status[1] && "deviation" !== status[1]) {
                    error = true;
                    break;
                }
            }
            return {
                label: label,
                error: error
            };
        }
        function processing(domain_name, useSTD3, processing_option) {
            var result = mapChars(domain_name, useSTD3, processing_option);
            result.string = normalize(result.string);
            var labels = result.string.split(".");
            for(var i = 0; i < labels.length; ++i)try {
                var validation = validateLabel(labels[i]);
                labels[i] = validation.label;
                result.error = result.error || validation.error;
            } catch (e) {
                result.error = true;
            }
            return {
                string: labels.join("."),
                error: result.error
            };
        }
        module.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
            var result = processing(domain_name, useSTD3, processing_option);
            var labels = result.string.split(".");
            labels = labels.map(function(l) {
                try {
                    return punycode.toASCII(l);
                } catch (e) {
                    result.error = true;
                    return l;
                }
            });
            if (verifyDnsLength) {
                var total = labels.slice(0, labels.length - 1).join(".").length;
                if (total.length > 253 || 0 === total.length) result.error = true;
                for(var i = 0; i < labels.length; ++i)if (labels.length > 63 || 0 === labels.length) {
                    result.error = true;
                    break;
                }
            }
            if (result.error) return null;
            return labels.join(".");
        };
        module.exports.toUnicode = function(domain_name, useSTD3) {
            var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
            return {
                domain: result.string,
                error: result.error
            };
        };
        module.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
    },
    "../node_modules/.pnpm/webidl-conversions@3.0.1/node_modules/webidl-conversions/lib/index.js": function(module) {
        "use strict";
        var conversions = {};
        module.exports = conversions;
        function sign(x) {
            return x < 0 ? -1 : 1;
        }
        function evenRound(x) {
            if (x % 1 === 0.5 && (1 & x) === 0) return Math.floor(x);
            return Math.round(x);
        }
        function createNumberConversion(bitLength, typeOpts) {
            if (!typeOpts.unsigned) --bitLength;
            const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
            const upperBound = Math.pow(2, bitLength) - 1;
            const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
            const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
            return function(V, opts) {
                if (!opts) opts = {};
                let x = +V;
                if (opts.enforceRange) {
                    if (!Number.isFinite(x)) throw new TypeError("Argument is not a finite number");
                    x = sign(x) * Math.floor(Math.abs(x));
                    if (x < lowerBound || x > upperBound) throw new TypeError("Argument is not in byte range");
                    return x;
                }
                if (!isNaN(x) && opts.clamp) {
                    x = evenRound(x);
                    if (x < lowerBound) x = lowerBound;
                    if (x > upperBound) x = upperBound;
                    return x;
                }
                if (!Number.isFinite(x) || 0 === x) return 0;
                x = sign(x) * Math.floor(Math.abs(x));
                x %= moduloVal;
                if (!typeOpts.unsigned && x >= moduloBound) return x - moduloVal;
                if (typeOpts.unsigned) {
                    if (x < 0) x += moduloVal;
                    else if (-0 === x) return 0;
                }
                return x;
            };
        }
        conversions["void"] = function() {};
        conversions["boolean"] = function(val) {
            return !!val;
        };
        conversions["byte"] = createNumberConversion(8, {
            unsigned: false
        });
        conversions["octet"] = createNumberConversion(8, {
            unsigned: true
        });
        conversions["short"] = createNumberConversion(16, {
            unsigned: false
        });
        conversions["unsigned short"] = createNumberConversion(16, {
            unsigned: true
        });
        conversions["long"] = createNumberConversion(32, {
            unsigned: false
        });
        conversions["unsigned long"] = createNumberConversion(32, {
            unsigned: true
        });
        conversions["long long"] = createNumberConversion(32, {
            unsigned: false,
            moduloBitLength: 64
        });
        conversions["unsigned long long"] = createNumberConversion(32, {
            unsigned: true,
            moduloBitLength: 64
        });
        conversions["double"] = function(V) {
            const x = +V;
            if (!Number.isFinite(x)) throw new TypeError("Argument is not a finite floating-point value");
            return x;
        };
        conversions["unrestricted double"] = function(V) {
            const x = +V;
            if (isNaN(x)) throw new TypeError("Argument is NaN");
            return x;
        };
        conversions["float"] = conversions["double"];
        conversions["unrestricted float"] = conversions["unrestricted double"];
        conversions["DOMString"] = function(V, opts) {
            if (!opts) opts = {};
            if (opts.treatNullAsEmptyString && null === V) return "";
            return String(V);
        };
        conversions["ByteString"] = function(V, opts) {
            const x = String(V);
            let c;
            for(let i = 0; void 0 !== (c = x.codePointAt(i)); ++i)if (c > 255) throw new TypeError("Argument is not a valid bytestring");
            return x;
        };
        conversions["USVString"] = function(V) {
            const S = String(V);
            const n = S.length;
            const U = [];
            for(let i = 0; i < n; ++i){
                const c = S.charCodeAt(i);
                if (c < 0xD800 || c > 0xDFFF) U.push(String.fromCodePoint(c));
                else if (0xDC00 <= c && c <= 0xDFFF) U.push(String.fromCodePoint(0xFFFD));
                else if (i === n - 1) U.push(String.fromCodePoint(0xFFFD));
                else {
                    const d = S.charCodeAt(i + 1);
                    if (0xDC00 <= d && d <= 0xDFFF) {
                        const a = 0x3FF & c;
                        const b = 0x3FF & d;
                        U.push(String.fromCodePoint(65536 + 1024 * a + b));
                        ++i;
                    } else U.push(String.fromCodePoint(0xFFFD));
                }
            }
            return U.join('');
        };
        conversions["Date"] = function(V, opts) {
            if (!(V instanceof Date)) throw new TypeError("Argument is not a Date object");
            if (isNaN(V)) return;
            return V;
        };
        conversions["RegExp"] = function(V, opts) {
            if (!(V instanceof RegExp)) V = new RegExp(V);
            return V;
        };
    },
    "../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL-impl.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        const usm = __webpack_require__("../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js");
        exports1.implementation = class {
            constructor(constructorArgs){
                const url = constructorArgs[0];
                const base = constructorArgs[1];
                let parsedBase = null;
                if (void 0 !== base) {
                    parsedBase = usm.basicURLParse(base);
                    if ("failure" === parsedBase) throw new TypeError("Invalid base URL");
                }
                const parsedURL = usm.basicURLParse(url, {
                    baseURL: parsedBase
                });
                if ("failure" === parsedURL) throw new TypeError("Invalid URL");
                this._url = parsedURL;
            }
            get href() {
                return usm.serializeURL(this._url);
            }
            set href(v) {
                const parsedURL = usm.basicURLParse(v);
                if ("failure" === parsedURL) throw new TypeError("Invalid URL");
                this._url = parsedURL;
            }
            get origin() {
                return usm.serializeURLOrigin(this._url);
            }
            get protocol() {
                return this._url.scheme + ":";
            }
            set protocol(v) {
                usm.basicURLParse(v + ":", {
                    url: this._url,
                    stateOverride: "scheme start"
                });
            }
            get username() {
                return this._url.username;
            }
            set username(v) {
                if (usm.cannotHaveAUsernamePasswordPort(this._url)) return;
                usm.setTheUsername(this._url, v);
            }
            get password() {
                return this._url.password;
            }
            set password(v) {
                if (usm.cannotHaveAUsernamePasswordPort(this._url)) return;
                usm.setThePassword(this._url, v);
            }
            get host() {
                const url = this._url;
                if (null === url.host) return "";
                if (null === url.port) return usm.serializeHost(url.host);
                return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
            }
            set host(v) {
                if (this._url.cannotBeABaseURL) return;
                usm.basicURLParse(v, {
                    url: this._url,
                    stateOverride: "host"
                });
            }
            get hostname() {
                if (null === this._url.host) return "";
                return usm.serializeHost(this._url.host);
            }
            set hostname(v) {
                if (this._url.cannotBeABaseURL) return;
                usm.basicURLParse(v, {
                    url: this._url,
                    stateOverride: "hostname"
                });
            }
            get port() {
                if (null === this._url.port) return "";
                return usm.serializeInteger(this._url.port);
            }
            set port(v) {
                if (usm.cannotHaveAUsernamePasswordPort(this._url)) return;
                if ("" === v) this._url.port = null;
                else usm.basicURLParse(v, {
                    url: this._url,
                    stateOverride: "port"
                });
            }
            get pathname() {
                if (this._url.cannotBeABaseURL) return this._url.path[0];
                if (0 === this._url.path.length) return "";
                return "/" + this._url.path.join("/");
            }
            set pathname(v) {
                if (this._url.cannotBeABaseURL) return;
                this._url.path = [];
                usm.basicURLParse(v, {
                    url: this._url,
                    stateOverride: "path start"
                });
            }
            get search() {
                if (null === this._url.query || "" === this._url.query) return "";
                return "?" + this._url.query;
            }
            set search(v) {
                const url = this._url;
                if ("" === v) {
                    url.query = null;
                    return;
                }
                const input = "?" === v[0] ? v.substring(1) : v;
                url.query = "";
                usm.basicURLParse(input, {
                    url,
                    stateOverride: "query"
                });
            }
            get hash() {
                if (null === this._url.fragment || "" === this._url.fragment) return "";
                return "#" + this._url.fragment;
            }
            set hash(v) {
                if ("" === v) {
                    this._url.fragment = null;
                    return;
                }
                const input = "#" === v[0] ? v.substring(1) : v;
                this._url.fragment = "";
                usm.basicURLParse(input, {
                    url: this._url,
                    stateOverride: "fragment"
                });
            }
            toJSON() {
                return this.href;
            }
        };
    },
    "../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const conversions = __webpack_require__("../node_modules/.pnpm/webidl-conversions@3.0.1/node_modules/webidl-conversions/lib/index.js");
        const utils = __webpack_require__("../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/utils.js");
        const Impl = __webpack_require__("../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL-impl.js");
        const impl = utils.implSymbol;
        function URL1(url) {
            if (!this || this[impl] || !(this instanceof URL1)) throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
            if (arguments.length < 1) throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
            const args = [];
            for(let i = 0; i < arguments.length && i < 2; ++i)args[i] = arguments[i];
            args[0] = conversions["USVString"](args[0]);
            if (void 0 !== args[1]) args[1] = conversions["USVString"](args[1]);
            module.exports.setup(this, args);
        }
        URL1.prototype.toJSON = function() {
            if (!this || !module.exports.is(this)) throw new TypeError("Illegal invocation");
            const args = [];
            for(let i = 0; i < arguments.length && i < 0; ++i)args[i] = arguments[i];
            return this[impl].toJSON.apply(this[impl], args);
        };
        Object.defineProperty(URL1.prototype, "href", {
            get () {
                return this[impl].href;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].href = V;
            },
            enumerable: true,
            configurable: true
        });
        URL1.prototype.toString = function() {
            if (!this || !module.exports.is(this)) throw new TypeError("Illegal invocation");
            return this.href;
        };
        Object.defineProperty(URL1.prototype, "origin", {
            get () {
                return this[impl].origin;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "protocol", {
            get () {
                return this[impl].protocol;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].protocol = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "username", {
            get () {
                return this[impl].username;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].username = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "password", {
            get () {
                return this[impl].password;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].password = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "host", {
            get () {
                return this[impl].host;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].host = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "hostname", {
            get () {
                return this[impl].hostname;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].hostname = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "port", {
            get () {
                return this[impl].port;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].port = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "pathname", {
            get () {
                return this[impl].pathname;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].pathname = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "search", {
            get () {
                return this[impl].search;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].search = V;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URL1.prototype, "hash", {
            get () {
                return this[impl].hash;
            },
            set (V) {
                V = conversions["USVString"](V);
                this[impl].hash = V;
            },
            enumerable: true,
            configurable: true
        });
        module.exports = {
            is (obj) {
                return !!obj && obj[impl] instanceof Impl.implementation;
            },
            create (constructorArgs, privateData) {
                let obj = Object.create(URL1.prototype);
                this.setup(obj, constructorArgs, privateData);
                return obj;
            },
            setup (obj, constructorArgs, privateData) {
                if (!privateData) privateData = {};
                privateData.wrapper = obj;
                obj[impl] = new Impl.implementation(constructorArgs, privateData);
                obj[impl][utils.wrapperSymbol] = obj;
            },
            interface: URL1,
            expose: {
                Window: {
                    URL: URL1
                },
                Worker: {
                    URL: URL1
                }
            }
        };
    },
    "../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        exports1.URL = __webpack_require__("../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL.js")["interface"];
        __webpack_require__("../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js").serializeURL;
        __webpack_require__("../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js").serializeURLOrigin;
        __webpack_require__("../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js").basicURLParse;
        __webpack_require__("../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js").setTheUsername;
        __webpack_require__("../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js").setThePassword;
        __webpack_require__("../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js").serializeHost;
        __webpack_require__("../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js").serializeInteger;
        __webpack_require__("../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js").parseURL;
    },
    "../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const punycode = __webpack_require__("punycode");
        const tr46 = __webpack_require__("../node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/index.js");
        const specialSchemes = {
            ftp: 21,
            file: null,
            gopher: 70,
            http: 80,
            https: 443,
            ws: 80,
            wss: 443
        };
        const failure = Symbol("failure");
        function countSymbols(str) {
            return punycode.ucs2.decode(str).length;
        }
        function at(input, idx) {
            const c = input[idx];
            return isNaN(c) ? void 0 : String.fromCodePoint(c);
        }
        function isASCIIDigit(c) {
            return c >= 0x30 && c <= 0x39;
        }
        function isASCIIAlpha(c) {
            return c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A;
        }
        function isASCIIAlphanumeric(c) {
            return isASCIIAlpha(c) || isASCIIDigit(c);
        }
        function isASCIIHex(c) {
            return isASCIIDigit(c) || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66;
        }
        function isSingleDot(buffer) {
            return "." === buffer || "%2e" === buffer.toLowerCase();
        }
        function isDoubleDot(buffer) {
            buffer = buffer.toLowerCase();
            return ".." === buffer || "%2e." === buffer || ".%2e" === buffer || "%2e%2e" === buffer;
        }
        function isWindowsDriveLetterCodePoints(cp1, cp2) {
            return isASCIIAlpha(cp1) && (58 === cp2 || 124 === cp2);
        }
        function isWindowsDriveLetterString(string) {
            return 2 === string.length && isASCIIAlpha(string.codePointAt(0)) && (":" === string[1] || "|" === string[1]);
        }
        function isNormalizedWindowsDriveLetterString(string) {
            return 2 === string.length && isASCIIAlpha(string.codePointAt(0)) && ":" === string[1];
        }
        function containsForbiddenHostCodePoint(string) {
            return -1 !== string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/);
        }
        function containsForbiddenHostCodePointExcludingPercent(string) {
            return -1 !== string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/);
        }
        function isSpecialScheme(scheme) {
            return void 0 !== specialSchemes[scheme];
        }
        function isSpecial(url) {
            return isSpecialScheme(url.scheme);
        }
        function defaultPort(scheme) {
            return specialSchemes[scheme];
        }
        function percentEncode(c) {
            let hex = c.toString(16).toUpperCase();
            if (1 === hex.length) hex = "0" + hex;
            return "%" + hex;
        }
        function utf8PercentEncode(c) {
            const buf = new Buffer(c);
            let str = "";
            for(let i = 0; i < buf.length; ++i)str += percentEncode(buf[i]);
            return str;
        }
        function utf8PercentDecode(str) {
            const input = new Buffer(str);
            const output = [];
            for(let i = 0; i < input.length; ++i)if (37 !== input[i]) output.push(input[i]);
            else if (37 === input[i] && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
                output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
                i += 2;
            } else output.push(input[i]);
            return new Buffer(output).toString();
        }
        function isC0ControlPercentEncode(c) {
            return c <= 0x1F || c > 0x7E;
        }
        const extraPathPercentEncodeSet = new Set([
            32,
            34,
            35,
            60,
            62,
            63,
            96,
            123,
            125
        ]);
        function isPathPercentEncode(c) {
            return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
        }
        const extraUserinfoPercentEncodeSet = new Set([
            47,
            58,
            59,
            61,
            64,
            91,
            92,
            93,
            94,
            124
        ]);
        function isUserinfoPercentEncode(c) {
            return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
        }
        function percentEncodeChar(c, encodeSetPredicate) {
            const cStr = String.fromCodePoint(c);
            if (encodeSetPredicate(c)) return utf8PercentEncode(cStr);
            return cStr;
        }
        function parseIPv4Number(input) {
            let R = 10;
            if (input.length >= 2 && "0" === input.charAt(0) && "x" === input.charAt(1).toLowerCase()) {
                input = input.substring(2);
                R = 16;
            } else if (input.length >= 2 && "0" === input.charAt(0)) {
                input = input.substring(1);
                R = 8;
            }
            if ("" === input) return 0;
            const regex = 10 === R ? /[^0-9]/ : 16 === R ? /[^0-9A-Fa-f]/ : /[^0-7]/;
            if (regex.test(input)) return failure;
            return parseInt(input, R);
        }
        function parseIPv4(input) {
            const parts = input.split(".");
            if ("" === parts[parts.length - 1]) {
                if (parts.length > 1) parts.pop();
            }
            if (parts.length > 4) return input;
            const numbers = [];
            for (const part of parts){
                if ("" === part) return input;
                const n = parseIPv4Number(part);
                if (n === failure) return input;
                numbers.push(n);
            }
            for(let i = 0; i < numbers.length - 1; ++i)if (numbers[i] > 255) return failure;
            if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) return failure;
            let ipv4 = numbers.pop();
            let counter = 0;
            for (const n of numbers){
                ipv4 += n * Math.pow(256, 3 - counter);
                ++counter;
            }
            return ipv4;
        }
        function serializeIPv4(address) {
            let output = "";
            let n = address;
            for(let i = 1; i <= 4; ++i){
                output = String(n % 256) + output;
                if (4 !== i) output = "." + output;
                n = Math.floor(n / 256);
            }
            return output;
        }
        function parseIPv6(input) {
            const address = [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ];
            let pieceIndex = 0;
            let compress = null;
            let pointer = 0;
            input = punycode.ucs2.decode(input);
            if (58 === input[pointer]) {
                if (58 !== input[pointer + 1]) return failure;
                pointer += 2;
                ++pieceIndex;
                compress = pieceIndex;
            }
            while(pointer < input.length){
                if (8 === pieceIndex) return failure;
                if (58 === input[pointer]) {
                    if (null !== compress) return failure;
                    ++pointer;
                    ++pieceIndex;
                    compress = pieceIndex;
                    continue;
                }
                let value = 0;
                let length = 0;
                while(length < 4 && isASCIIHex(input[pointer])){
                    value = 0x10 * value + parseInt(at(input, pointer), 16);
                    ++pointer;
                    ++length;
                }
                if (46 === input[pointer]) {
                    if (0 === length) return failure;
                    pointer -= length;
                    if (pieceIndex > 6) return failure;
                    let numbersSeen = 0;
                    while(void 0 !== input[pointer]){
                        let ipv4Piece = null;
                        if (numbersSeen > 0) if (46 !== input[pointer] || !(numbersSeen < 4)) return failure;
                        else ++pointer;
                        if (!isASCIIDigit(input[pointer])) return failure;
                        while(isASCIIDigit(input[pointer])){
                            const number = parseInt(at(input, pointer));
                            if (null === ipv4Piece) ipv4Piece = number;
                            else {
                                if (0 === ipv4Piece) return failure;
                                ipv4Piece = 10 * ipv4Piece + number;
                            }
                            if (ipv4Piece > 255) return failure;
                            ++pointer;
                        }
                        address[pieceIndex] = 0x100 * address[pieceIndex] + ipv4Piece;
                        ++numbersSeen;
                        if (2 === numbersSeen || 4 === numbersSeen) ++pieceIndex;
                    }
                    if (4 !== numbersSeen) return failure;
                    break;
                }
                if (58 === input[pointer]) {
                    ++pointer;
                    if (void 0 === input[pointer]) return failure;
                } else if (void 0 !== input[pointer]) return failure;
                address[pieceIndex] = value;
                ++pieceIndex;
            }
            if (null !== compress) {
                let swaps = pieceIndex - compress;
                pieceIndex = 7;
                while(0 !== pieceIndex && swaps > 0){
                    const temp = address[compress + swaps - 1];
                    address[compress + swaps - 1] = address[pieceIndex];
                    address[pieceIndex] = temp;
                    --pieceIndex;
                    --swaps;
                }
            } else if (null === compress && 8 !== pieceIndex) return failure;
            return address;
        }
        function serializeIPv6(address) {
            let output = "";
            const seqResult = findLongestZeroSequence(address);
            const compress = seqResult.idx;
            let ignore0 = false;
            for(let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex)if (!ignore0 || 0 !== address[pieceIndex]) {
                if (ignore0) ignore0 = false;
                if (compress === pieceIndex) {
                    const separator = 0 === pieceIndex ? "::" : ":";
                    output += separator;
                    ignore0 = true;
                    continue;
                }
                output += address[pieceIndex].toString(16);
                if (7 !== pieceIndex) output += ":";
            }
            return output;
        }
        function parseHost(input, isSpecialArg) {
            if ("[" === input[0]) {
                if ("]" !== input[input.length - 1]) return failure;
                return parseIPv6(input.substring(1, input.length - 1));
            }
            if (!isSpecialArg) return parseOpaqueHost(input);
            const domain = utf8PercentDecode(input);
            const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
            if (null === asciiDomain) return failure;
            if (containsForbiddenHostCodePoint(asciiDomain)) return failure;
            const ipv4Host = parseIPv4(asciiDomain);
            if ("number" == typeof ipv4Host || ipv4Host === failure) return ipv4Host;
            return asciiDomain;
        }
        function parseOpaqueHost(input) {
            if (containsForbiddenHostCodePointExcludingPercent(input)) return failure;
            let output = "";
            const decoded = punycode.ucs2.decode(input);
            for(let i = 0; i < decoded.length; ++i)output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
            return output;
        }
        function findLongestZeroSequence(arr) {
            let maxIdx = null;
            let maxLen = 1;
            let currStart = null;
            let currLen = 0;
            for(let i = 0; i < arr.length; ++i)if (0 !== arr[i]) {
                if (currLen > maxLen) {
                    maxIdx = currStart;
                    maxLen = currLen;
                }
                currStart = null;
                currLen = 0;
            } else {
                if (null === currStart) currStart = i;
                ++currLen;
            }
            if (currLen > maxLen) {
                maxIdx = currStart;
                maxLen = currLen;
            }
            return {
                idx: maxIdx,
                len: maxLen
            };
        }
        function serializeHost(host) {
            if ("number" == typeof host) return serializeIPv4(host);
            if (host instanceof Array) return "[" + serializeIPv6(host) + "]";
            return host;
        }
        function trimControlChars(url) {
            return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
        }
        function trimTabAndNewline(url) {
            return url.replace(/\u0009|\u000A|\u000D/g, "");
        }
        function shortenPath(url) {
            const path = url.path;
            if (0 === path.length) return;
            if ("file" === url.scheme && 1 === path.length && isNormalizedWindowsDriveLetter(path[0])) return;
            path.pop();
        }
        function includesCredentials(url) {
            return "" !== url.username || "" !== url.password;
        }
        function cannotHaveAUsernamePasswordPort(url) {
            return null === url.host || "" === url.host || url.cannotBeABaseURL || "file" === url.scheme;
        }
        function isNormalizedWindowsDriveLetter(string) {
            return /^[A-Za-z]:$/.test(string);
        }
        function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
            this.pointer = 0;
            this.input = input;
            this.base = base || null;
            this.encodingOverride = encodingOverride || "utf-8";
            this.stateOverride = stateOverride;
            this.url = url;
            this.failure = false;
            this.parseError = false;
            if (!this.url) {
                this.url = {
                    scheme: "",
                    username: "",
                    password: "",
                    host: null,
                    port: null,
                    path: [],
                    query: null,
                    fragment: null,
                    cannotBeABaseURL: false
                };
                const res = trimControlChars(this.input);
                if (res !== this.input) this.parseError = true;
                this.input = res;
            }
            const res = trimTabAndNewline(this.input);
            if (res !== this.input) this.parseError = true;
            this.input = res;
            this.state = stateOverride || "scheme start";
            this.buffer = "";
            this.atFlag = false;
            this.arrFlag = false;
            this.passwordTokenSeenFlag = false;
            this.input = punycode.ucs2.decode(this.input);
            for(; this.pointer <= this.input.length; ++this.pointer){
                const c = this.input[this.pointer];
                const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
                const ret = this["parse " + this.state](c, cStr);
                if (ret) {
                    if (ret === failure) {
                        this.failure = true;
                        break;
                    }
                } else break;
            }
        }
        URLStateMachine.prototype["parse scheme start"] = function(c, cStr) {
            if (isASCIIAlpha(c)) {
                this.buffer += cStr.toLowerCase();
                this.state = "scheme";
            } else if (this.stateOverride) {
                this.parseError = true;
                return failure;
            } else {
                this.state = "no scheme";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse scheme"] = function(c, cStr) {
            if (isASCIIAlphanumeric(c) || 43 === c || 45 === c || 46 === c) this.buffer += cStr.toLowerCase();
            else if (58 === c) {
                if (this.stateOverride) {
                    if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) return false;
                    if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) return false;
                    if ((includesCredentials(this.url) || null !== this.url.port) && "file" === this.buffer) return false;
                    if ("file" === this.url.scheme && ("" === this.url.host || null === this.url.host)) return false;
                }
                this.url.scheme = this.buffer;
                this.buffer = "";
                if (this.stateOverride) return false;
                if ("file" === this.url.scheme) {
                    if (47 !== this.input[this.pointer + 1] || 47 !== this.input[this.pointer + 2]) this.parseError = true;
                    this.state = "file";
                } else if (isSpecial(this.url) && null !== this.base && this.base.scheme === this.url.scheme) this.state = "special relative or authority";
                else if (isSpecial(this.url)) this.state = "special authority slashes";
                else if (47 === this.input[this.pointer + 1]) {
                    this.state = "path or authority";
                    ++this.pointer;
                } else {
                    this.url.cannotBeABaseURL = true;
                    this.url.path.push("");
                    this.state = "cannot-be-a-base-URL path";
                }
            } else if (this.stateOverride) {
                this.parseError = true;
                return failure;
            } else {
                this.buffer = "";
                this.state = "no scheme";
                this.pointer = -1;
            }
            return true;
        };
        URLStateMachine.prototype["parse no scheme"] = function(c) {
            if (null === this.base || this.base.cannotBeABaseURL && 35 !== c) return failure;
            if (this.base.cannotBeABaseURL && 35 === c) {
                this.url.scheme = this.base.scheme;
                this.url.path = this.base.path.slice();
                this.url.query = this.base.query;
                this.url.fragment = "";
                this.url.cannotBeABaseURL = true;
                this.state = "fragment";
            } else if ("file" === this.base.scheme) {
                this.state = "file";
                --this.pointer;
            } else {
                this.state = "relative";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse special relative or authority"] = function(c) {
            if (47 === c && 47 === this.input[this.pointer + 1]) {
                this.state = "special authority ignore slashes";
                ++this.pointer;
            } else {
                this.parseError = true;
                this.state = "relative";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse path or authority"] = function(c) {
            if (47 === c) this.state = "authority";
            else {
                this.state = "path";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse relative"] = function(c) {
            this.url.scheme = this.base.scheme;
            if (isNaN(c)) {
                this.url.username = this.base.username;
                this.url.password = this.base.password;
                this.url.host = this.base.host;
                this.url.port = this.base.port;
                this.url.path = this.base.path.slice();
                this.url.query = this.base.query;
            } else if (47 === c) this.state = "relative slash";
            else if (63 === c) {
                this.url.username = this.base.username;
                this.url.password = this.base.password;
                this.url.host = this.base.host;
                this.url.port = this.base.port;
                this.url.path = this.base.path.slice();
                this.url.query = "";
                this.state = "query";
            } else if (35 === c) {
                this.url.username = this.base.username;
                this.url.password = this.base.password;
                this.url.host = this.base.host;
                this.url.port = this.base.port;
                this.url.path = this.base.path.slice();
                this.url.query = this.base.query;
                this.url.fragment = "";
                this.state = "fragment";
            } else if (isSpecial(this.url) && 92 === c) {
                this.parseError = true;
                this.state = "relative slash";
            } else {
                this.url.username = this.base.username;
                this.url.password = this.base.password;
                this.url.host = this.base.host;
                this.url.port = this.base.port;
                this.url.path = this.base.path.slice(0, this.base.path.length - 1);
                this.state = "path";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse relative slash"] = function(c) {
            if (isSpecial(this.url) && (47 === c || 92 === c)) {
                if (92 === c) this.parseError = true;
                this.state = "special authority ignore slashes";
            } else if (47 === c) this.state = "authority";
            else {
                this.url.username = this.base.username;
                this.url.password = this.base.password;
                this.url.host = this.base.host;
                this.url.port = this.base.port;
                this.state = "path";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse special authority slashes"] = function(c) {
            if (47 === c && 47 === this.input[this.pointer + 1]) {
                this.state = "special authority ignore slashes";
                ++this.pointer;
            } else {
                this.parseError = true;
                this.state = "special authority ignore slashes";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse special authority ignore slashes"] = function(c) {
            if (47 !== c && 92 !== c) {
                this.state = "authority";
                --this.pointer;
            } else this.parseError = true;
            return true;
        };
        URLStateMachine.prototype["parse authority"] = function(c, cStr) {
            if (64 === c) {
                this.parseError = true;
                if (this.atFlag) this.buffer = "%40" + this.buffer;
                this.atFlag = true;
                const len = countSymbols(this.buffer);
                for(let pointer = 0; pointer < len; ++pointer){
                    const codePoint = this.buffer.codePointAt(pointer);
                    if (58 === codePoint && !this.passwordTokenSeenFlag) {
                        this.passwordTokenSeenFlag = true;
                        continue;
                    }
                    const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
                    if (this.passwordTokenSeenFlag) this.url.password += encodedCodePoints;
                    else this.url.username += encodedCodePoints;
                }
                this.buffer = "";
            } else if (isNaN(c) || 47 === c || 63 === c || 35 === c || isSpecial(this.url) && 92 === c) {
                if (this.atFlag && "" === this.buffer) {
                    this.parseError = true;
                    return failure;
                }
                this.pointer -= countSymbols(this.buffer) + 1;
                this.buffer = "";
                this.state = "host";
            } else this.buffer += cStr;
            return true;
        };
        URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function(c, cStr) {
            if (this.stateOverride && "file" === this.url.scheme) {
                --this.pointer;
                this.state = "file host";
            } else if (58 !== c || this.arrFlag) if (isNaN(c) || 47 === c || 63 === c || 35 === c || isSpecial(this.url) && 92 === c) {
                --this.pointer;
                if (isSpecial(this.url) && "" === this.buffer) {
                    this.parseError = true;
                    return failure;
                }
                if (this.stateOverride && "" === this.buffer && (includesCredentials(this.url) || null !== this.url.port)) {
                    this.parseError = true;
                    return false;
                }
                const host = parseHost(this.buffer, isSpecial(this.url));
                if (host === failure) return failure;
                this.url.host = host;
                this.buffer = "";
                this.state = "path start";
                if (this.stateOverride) return false;
            } else {
                if (91 === c) this.arrFlag = true;
                else if (93 === c) this.arrFlag = false;
                this.buffer += cStr;
            }
            else {
                if ("" === this.buffer) {
                    this.parseError = true;
                    return failure;
                }
                const host = parseHost(this.buffer, isSpecial(this.url));
                if (host === failure) return failure;
                this.url.host = host;
                this.buffer = "";
                this.state = "port";
                if ("hostname" === this.stateOverride) return false;
            }
            return true;
        };
        URLStateMachine.prototype["parse port"] = function(c, cStr) {
            if (isASCIIDigit(c)) this.buffer += cStr;
            else if (isNaN(c) || 47 === c || 63 === c || 35 === c || isSpecial(this.url) && 92 === c || this.stateOverride) {
                if ("" !== this.buffer) {
                    const port = parseInt(this.buffer);
                    if (port > Math.pow(2, 16) - 1) {
                        this.parseError = true;
                        return failure;
                    }
                    this.url.port = port === defaultPort(this.url.scheme) ? null : port;
                    this.buffer = "";
                }
                if (this.stateOverride) return false;
                this.state = "path start";
                --this.pointer;
            } else {
                this.parseError = true;
                return failure;
            }
            return true;
        };
        const fileOtherwiseCodePoints = new Set([
            47,
            92,
            63,
            35
        ]);
        URLStateMachine.prototype["parse file"] = function(c) {
            this.url.scheme = "file";
            if (47 === c || 92 === c) {
                if (92 === c) this.parseError = true;
                this.state = "file slash";
            } else if (null !== this.base && "file" === this.base.scheme) if (isNaN(c)) {
                this.url.host = this.base.host;
                this.url.path = this.base.path.slice();
                this.url.query = this.base.query;
            } else if (63 === c) {
                this.url.host = this.base.host;
                this.url.path = this.base.path.slice();
                this.url.query = "";
                this.state = "query";
            } else if (35 === c) {
                this.url.host = this.base.host;
                this.url.path = this.base.path.slice();
                this.url.query = this.base.query;
                this.url.fragment = "";
                this.state = "fragment";
            } else {
                if (this.input.length - this.pointer - 1 !== 0 && isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) && (!(this.input.length - this.pointer - 1 >= 2) || fileOtherwiseCodePoints.has(this.input[this.pointer + 2]))) this.parseError = true;
                else {
                    this.url.host = this.base.host;
                    this.url.path = this.base.path.slice();
                    shortenPath(this.url);
                }
                this.state = "path";
                --this.pointer;
            }
            else {
                this.state = "path";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse file slash"] = function(c) {
            if (47 === c || 92 === c) {
                if (92 === c) this.parseError = true;
                this.state = "file host";
            } else {
                if (null !== this.base && "file" === this.base.scheme) if (isNormalizedWindowsDriveLetterString(this.base.path[0])) this.url.path.push(this.base.path[0]);
                else this.url.host = this.base.host;
                this.state = "path";
                --this.pointer;
            }
            return true;
        };
        URLStateMachine.prototype["parse file host"] = function(c, cStr) {
            if (isNaN(c) || 47 === c || 92 === c || 63 === c || 35 === c) {
                --this.pointer;
                if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
                    this.parseError = true;
                    this.state = "path";
                } else if ("" === this.buffer) {
                    this.url.host = "";
                    if (this.stateOverride) return false;
                    this.state = "path start";
                } else {
                    let host = parseHost(this.buffer, isSpecial(this.url));
                    if (host === failure) return failure;
                    if ("localhost" === host) host = "";
                    this.url.host = host;
                    if (this.stateOverride) return false;
                    this.buffer = "";
                    this.state = "path start";
                }
            } else this.buffer += cStr;
            return true;
        };
        URLStateMachine.prototype["parse path start"] = function(c) {
            if (isSpecial(this.url)) {
                if (92 === c) this.parseError = true;
                this.state = "path";
                if (47 !== c && 92 !== c) --this.pointer;
            } else if (this.stateOverride || 63 !== c) if (this.stateOverride || 35 !== c) {
                if (void 0 !== c) {
                    this.state = "path";
                    if (47 !== c) --this.pointer;
                }
            } else {
                this.url.fragment = "";
                this.state = "fragment";
            }
            else {
                this.url.query = "";
                this.state = "query";
            }
            return true;
        };
        URLStateMachine.prototype["parse path"] = function(c) {
            if (isNaN(c) || 47 === c || isSpecial(this.url) && 92 === c || !this.stateOverride && (63 === c || 35 === c)) {
                if (isSpecial(this.url) && 92 === c) this.parseError = true;
                if (isDoubleDot(this.buffer)) {
                    shortenPath(this.url);
                    if (47 !== c && !(isSpecial(this.url) && 92 === c)) this.url.path.push("");
                } else if (isSingleDot(this.buffer) && 47 !== c && !(isSpecial(this.url) && 92 === c)) this.url.path.push("");
                else if (!isSingleDot(this.buffer)) {
                    if ("file" === this.url.scheme && 0 === this.url.path.length && isWindowsDriveLetterString(this.buffer)) {
                        if ("" !== this.url.host && null !== this.url.host) {
                            this.parseError = true;
                            this.url.host = "";
                        }
                        this.buffer = this.buffer[0] + ":";
                    }
                    this.url.path.push(this.buffer);
                }
                this.buffer = "";
                if ("file" === this.url.scheme && (void 0 === c || 63 === c || 35 === c)) while(this.url.path.length > 1 && "" === this.url.path[0]){
                    this.parseError = true;
                    this.url.path.shift();
                }
                if (63 === c) {
                    this.url.query = "";
                    this.state = "query";
                }
                if (35 === c) {
                    this.url.fragment = "";
                    this.state = "fragment";
                }
            } else {
                if (37 === c && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) this.parseError = true;
                this.buffer += percentEncodeChar(c, isPathPercentEncode);
            }
            return true;
        };
        URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function(c) {
            if (63 === c) {
                this.url.query = "";
                this.state = "query";
            } else if (35 === c) {
                this.url.fragment = "";
                this.state = "fragment";
            } else {
                if (!isNaN(c) && 37 !== c) this.parseError = true;
                if (37 === c && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) this.parseError = true;
                if (!isNaN(c)) this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
            }
            return true;
        };
        URLStateMachine.prototype["parse query"] = function(c, cStr) {
            if (isNaN(c) || !this.stateOverride && 35 === c) {
                if (!isSpecial(this.url) || "ws" === this.url.scheme || "wss" === this.url.scheme) this.encodingOverride = "utf-8";
                const buffer = new Buffer(this.buffer);
                for(let i = 0; i < buffer.length; ++i)if (buffer[i] < 0x21 || buffer[i] > 0x7E || 0x22 === buffer[i] || 0x23 === buffer[i] || 0x3C === buffer[i] || 0x3E === buffer[i]) this.url.query += percentEncode(buffer[i]);
                else this.url.query += String.fromCodePoint(buffer[i]);
                this.buffer = "";
                if (35 === c) {
                    this.url.fragment = "";
                    this.state = "fragment";
                }
            } else {
                if (37 === c && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) this.parseError = true;
                this.buffer += cStr;
            }
            return true;
        };
        URLStateMachine.prototype["parse fragment"] = function(c) {
            if (isNaN(c)) ;
            else if (0x0 === c) this.parseError = true;
            else {
                if (37 === c && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) this.parseError = true;
                this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
            }
            return true;
        };
        function serializeURL(url, excludeFragment) {
            let output = url.scheme + ":";
            if (null !== url.host) {
                output += "//";
                if ("" !== url.username || "" !== url.password) {
                    output += url.username;
                    if ("" !== url.password) output += ":" + url.password;
                    output += "@";
                }
                output += serializeHost(url.host);
                if (null !== url.port) output += ":" + url.port;
            } else if (null === url.host && "file" === url.scheme) output += "//";
            if (url.cannotBeABaseURL) output += url.path[0];
            else for (const string of url.path)output += "/" + string;
            if (null !== url.query) output += "?" + url.query;
            if (!excludeFragment && null !== url.fragment) output += "#" + url.fragment;
            return output;
        }
        function serializeOrigin(tuple) {
            let result = tuple.scheme + "://";
            result += serializeHost(tuple.host);
            if (null !== tuple.port) result += ":" + tuple.port;
            return result;
        }
        module.exports.serializeURL = serializeURL;
        module.exports.serializeURLOrigin = function(url) {
            switch(url.scheme){
                case "blob":
                    try {
                        return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
                    } catch (e) {
                        return "null";
                    }
                case "ftp":
                case "gopher":
                case "http":
                case "https":
                case "ws":
                case "wss":
                    return serializeOrigin({
                        scheme: url.scheme,
                        host: url.host,
                        port: url.port
                    });
                case "file":
                    return "file://";
                default:
                    return "null";
            }
        };
        module.exports.basicURLParse = function(input, options) {
            if (void 0 === options) options = {};
            const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
            if (usm.failure) return "failure";
            return usm.url;
        };
        module.exports.setTheUsername = function(url, username) {
            url.username = "";
            const decoded = punycode.ucs2.decode(username);
            for(let i = 0; i < decoded.length; ++i)url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
        };
        module.exports.setThePassword = function(url, password) {
            url.password = "";
            const decoded = punycode.ucs2.decode(password);
            for(let i = 0; i < decoded.length; ++i)url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
        };
        module.exports.serializeHost = serializeHost;
        module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
        module.exports.serializeInteger = function(integer) {
            return String(integer);
        };
        module.exports.parseURL = function(input, options) {
            if (void 0 === options) options = {};
            return module.exports.basicURLParse(input, {
                baseURL: options.baseURL,
                encodingOverride: options.encodingOverride
            });
        };
    },
    "../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/utils.js": function(module) {
        "use strict";
        module.exports.mixin = function(target, source) {
            const keys = Object.getOwnPropertyNames(source);
            for(let i = 0; i < keys.length; ++i)Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
        };
        module.exports.wrapperSymbol = Symbol("wrapper");
        module.exports.implSymbol = Symbol("impl");
        module.exports.wrapperForImpl = function(impl) {
            return impl[module.exports.wrapperSymbol];
        };
        module.exports.implForWrapper = function(wrapper) {
            return wrapper[module.exports.implSymbol];
        };
    },
    "../agent-interface/dist/agent.mjs": function() {},
    assert: function(module) {
        "use strict";
        module.exports = require("assert");
    },
    fs: function(module) {
        "use strict";
        module.exports = require("fs");
    },
    module: function(module) {
        "use strict";
        module.exports = require("module");
    },
    "node:assert": function(module) {
        "use strict";
        module.exports = require("node:assert");
    },
    "node:crypto": function(module) {
        "use strict";
        module.exports = require("node:crypto");
    },
    "node:fs": function(module) {
        "use strict";
        module.exports = require("node:fs");
    },
    "node:module": function(module) {
        "use strict";
        module.exports = require("node:module");
    },
    "node:os": function(module) {
        "use strict";
        module.exports = require("node:os");
    },
    "node:path": function(module) {
        "use strict";
        module.exports = require("node:path");
    },
    "node:perf_hooks": function(module) {
        "use strict";
        module.exports = require("node:perf_hooks");
    },
    "node:process": function(module) {
        "use strict";
        module.exports = require("node:process");
    },
    "node:tty": function(module) {
        "use strict";
        module.exports = require("node:tty");
    },
    "node:url": function(module) {
        "use strict";
        module.exports = require("node:url");
    },
    "node:util": function(module) {
        "use strict";
        module.exports = require("node:util");
    },
    "node:v8": function(module) {
        "use strict";
        module.exports = require("node:v8");
    },
    "node:vm": function(module) {
        "use strict";
        module.exports = require("node:vm");
    },
    os: function(module) {
        "use strict";
        module.exports = require("os");
    },
    path: function(module) {
        "use strict";
        module.exports = require("path");
    },
    process: function(module) {
        "use strict";
        module.exports = require("process");
    },
    punycode: function(module) {
        "use strict";
        module.exports = require("punycode");
    },
    tty: function(module) {
        "use strict";
        module.exports = require("tty");
    },
    url: function(module) {
        "use strict";
        module.exports = require("url");
    },
    util: function(module) {
        "use strict";
        module.exports = require("util");
    },
    v8: function(module) {
        "use strict";
        module.exports = require("v8");
    },
    "../node_modules/.pnpm/fast-uri@3.0.6/node_modules/fast-uri/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = __webpack_require__("../node_modules/.pnpm/fast-uri@3.0.6/node_modules/fast-uri/lib/utils.js");
        const SCHEMES = __webpack_require__("../node_modules/.pnpm/fast-uri@3.0.6/node_modules/fast-uri/lib/schemes.js");
        function normalize(uri, options) {
            if ('string' == typeof uri) uri = serialize(parse(uri, options), options);
            else if ('object' == typeof uri) uri = parse(serialize(uri, options), options);
            return uri;
        }
        function resolve(baseURI, relativeURI, options) {
            const schemelessOptions = Object.assign({
                scheme: 'null'
            }, options);
            const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
            return serialize(resolved, {
                ...schemelessOptions,
                skipEscape: true
            });
        }
        function resolveComponents(base, relative, options, skipNormalization) {
            const target = {};
            if (!skipNormalization) {
                base = parse(serialize(base, options), options);
                relative = parse(serialize(relative, options), options);
            }
            options = options || {};
            if (!options.tolerant && relative.scheme) {
                target.scheme = relative.scheme;
                target.userinfo = relative.userinfo;
                target.host = relative.host;
                target.port = relative.port;
                target.path = removeDotSegments(relative.path || '');
                target.query = relative.query;
            } else {
                if (void 0 !== relative.userinfo || void 0 !== relative.host || void 0 !== relative.port) {
                    target.userinfo = relative.userinfo;
                    target.host = relative.host;
                    target.port = relative.port;
                    target.path = removeDotSegments(relative.path || '');
                    target.query = relative.query;
                } else {
                    if (relative.path) {
                        if ('/' === relative.path.charAt(0)) target.path = removeDotSegments(relative.path);
                        else {
                            if (void 0 === base.userinfo && void 0 === base.host && void 0 === base.port || base.path) if (base.path) target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path;
                            else target.path = relative.path;
                            else target.path = '/' + relative.path;
                            target.path = removeDotSegments(target.path);
                        }
                        target.query = relative.query;
                    } else {
                        target.path = base.path;
                        if (void 0 !== relative.query) target.query = relative.query;
                        else target.query = base.query;
                    }
                    target.userinfo = base.userinfo;
                    target.host = base.host;
                    target.port = base.port;
                }
                target.scheme = base.scheme;
            }
            target.fragment = relative.fragment;
            return target;
        }
        function equal(uriA, uriB, options) {
            if ('string' == typeof uriA) {
                uriA = unescape(uriA);
                uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), {
                    ...options,
                    skipEscape: true
                });
            } else if ('object' == typeof uriA) uriA = serialize(normalizeComponentEncoding(uriA, true), {
                ...options,
                skipEscape: true
            });
            if ('string' == typeof uriB) {
                uriB = unescape(uriB);
                uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), {
                    ...options,
                    skipEscape: true
                });
            } else if ('object' == typeof uriB) uriB = serialize(normalizeComponentEncoding(uriB, true), {
                ...options,
                skipEscape: true
            });
            return uriA.toLowerCase() === uriB.toLowerCase();
        }
        function serialize(cmpts, opts) {
            const components = {
                host: cmpts.host,
                scheme: cmpts.scheme,
                userinfo: cmpts.userinfo,
                port: cmpts.port,
                path: cmpts.path,
                query: cmpts.query,
                nid: cmpts.nid,
                nss: cmpts.nss,
                uuid: cmpts.uuid,
                fragment: cmpts.fragment,
                reference: cmpts.reference,
                resourceName: cmpts.resourceName,
                secure: cmpts.secure,
                error: ''
            };
            const options = Object.assign({}, opts);
            const uriTokens = [];
            const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()];
            if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
            if (void 0 !== components.path) if (options.skipEscape) components.path = unescape(components.path);
            else {
                components.path = escape(components.path);
                if (void 0 !== components.scheme) components.path = components.path.split('%3A').join(':');
            }
            if ('suffix' !== options.reference && components.scheme) uriTokens.push(components.scheme, ':');
            const authority = recomposeAuthority(components);
            if (void 0 !== authority) {
                if ('suffix' !== options.reference) uriTokens.push('//');
                uriTokens.push(authority);
                if (components.path && '/' !== components.path.charAt(0)) uriTokens.push('/');
            }
            if (void 0 !== components.path) {
                let s = components.path;
                if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) s = removeDotSegments(s);
                if (void 0 === authority) s = s.replace(/^\/\//u, '/%2F');
                uriTokens.push(s);
            }
            if (void 0 !== components.query) uriTokens.push('?', components.query);
            if (void 0 !== components.fragment) uriTokens.push('#', components.fragment);
            return uriTokens.join('');
        }
        const hexLookUp = Array.from({
            length: 127
        }, (_v, k)=>/[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
        function nonSimpleDomain(value) {
            let code = 0;
            for(let i = 0, len = value.length; i < len; ++i){
                code = value.charCodeAt(i);
                if (code > 126 || hexLookUp[code]) return true;
            }
            return false;
        }
        const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
        function parse(uri, opts) {
            const options = Object.assign({}, opts);
            const parsed = {
                scheme: void 0,
                userinfo: void 0,
                host: '',
                port: void 0,
                path: '',
                query: void 0,
                fragment: void 0
            };
            const gotEncoding = -1 !== uri.indexOf('%');
            let isIP = false;
            if ('suffix' === options.reference) uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri;
            const matches = uri.match(URI_PARSE);
            if (matches) {
                parsed.scheme = matches[1];
                parsed.userinfo = matches[3];
                parsed.host = matches[4];
                parsed.port = parseInt(matches[5], 10);
                parsed.path = matches[6] || '';
                parsed.query = matches[7];
                parsed.fragment = matches[8];
                if (isNaN(parsed.port)) parsed.port = matches[5];
                if (parsed.host) {
                    const ipv4result = normalizeIPv4(parsed.host);
                    if (false === ipv4result.isIPV4) {
                        const ipv6result = normalizeIPv6(ipv4result.host);
                        parsed.host = ipv6result.host.toLowerCase();
                        isIP = ipv6result.isIPV6;
                    } else {
                        parsed.host = ipv4result.host;
                        isIP = true;
                    }
                }
                if (void 0 !== parsed.scheme || void 0 !== parsed.userinfo || void 0 !== parsed.host || void 0 !== parsed.port || void 0 !== parsed.query || parsed.path) if (void 0 === parsed.scheme) parsed.reference = 'relative';
                else if (void 0 === parsed.fragment) parsed.reference = 'absolute';
                else parsed.reference = 'uri';
                else parsed.reference = 'same-document';
                if (options.reference && 'suffix' !== options.reference && options.reference !== parsed.reference) parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.';
                const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()];
                if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
                    if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && false === isIP && nonSimpleDomain(parsed.host)) try {
                        parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
                    } catch (e) {
                        parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
                    }
                }
                if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
                    if (gotEncoding && void 0 !== parsed.scheme) parsed.scheme = unescape(parsed.scheme);
                    if (gotEncoding && void 0 !== parsed.host) parsed.host = unescape(parsed.host);
                    if (parsed.path) parsed.path = escape(unescape(parsed.path));
                    if (parsed.fragment) parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
                }
                if (schemeHandler && schemeHandler.parse) schemeHandler.parse(parsed, options);
            } else parsed.error = parsed.error || 'URI can not be parsed.';
            return parsed;
        }
        const fastUri = {
            SCHEMES,
            normalize,
            resolve,
            resolveComponents,
            equal,
            serialize,
            parse
        };
        module.exports = fastUri;
        module.exports["default"] = fastUri;
        module.exports.fastUri = fastUri;
    },
    "../node_modules/.pnpm/fast-uri@3.0.6/node_modules/fast-uri/lib/schemes.js": function(module) {
        "use strict";
        const UUID_REG = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu;
        const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
        function isSecure(wsComponents) {
            return 'boolean' == typeof wsComponents.secure ? wsComponents.secure : 'wss' === String(wsComponents.scheme).toLowerCase();
        }
        function httpParse(components) {
            if (!components.host) components.error = components.error || 'HTTP URIs must have a host.';
            return components;
        }
        function httpSerialize(components) {
            const secure = 'https' === String(components.scheme).toLowerCase();
            if (components.port === (secure ? 443 : 80) || '' === components.port) components.port = void 0;
            if (!components.path) components.path = '/';
            return components;
        }
        function wsParse(wsComponents) {
            wsComponents.secure = isSecure(wsComponents);
            wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
            wsComponents.path = void 0;
            wsComponents.query = void 0;
            return wsComponents;
        }
        function wsSerialize(wsComponents) {
            if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || '' === wsComponents.port) wsComponents.port = void 0;
            if ('boolean' == typeof wsComponents.secure) {
                wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';
                wsComponents.secure = void 0;
            }
            if (wsComponents.resourceName) {
                const [path, query] = wsComponents.resourceName.split('?');
                wsComponents.path = path && '/' !== path ? path : void 0;
                wsComponents.query = query;
                wsComponents.resourceName = void 0;
            }
            wsComponents.fragment = void 0;
            return wsComponents;
        }
        function urnParse(urnComponents, options) {
            if (!urnComponents.path) {
                urnComponents.error = 'URN can not be parsed';
                return urnComponents;
            }
            const matches = urnComponents.path.match(URN_REG);
            if (matches) {
                const scheme = options.scheme || urnComponents.scheme || 'urn';
                urnComponents.nid = matches[1].toLowerCase();
                urnComponents.nss = matches[2];
                const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
                const schemeHandler = SCHEMES[urnScheme];
                urnComponents.path = void 0;
                if (schemeHandler) urnComponents = schemeHandler.parse(urnComponents, options);
            } else urnComponents.error = urnComponents.error || 'URN can not be parsed.';
            return urnComponents;
        }
        function urnSerialize(urnComponents, options) {
            const scheme = options.scheme || urnComponents.scheme || 'urn';
            const nid = urnComponents.nid.toLowerCase();
            const urnScheme = `${scheme}:${options.nid || nid}`;
            const schemeHandler = SCHEMES[urnScheme];
            if (schemeHandler) urnComponents = schemeHandler.serialize(urnComponents, options);
            const uriComponents = urnComponents;
            const nss = urnComponents.nss;
            uriComponents.path = `${nid || options.nid}:${nss}`;
            options.skipEscape = true;
            return uriComponents;
        }
        function urnuuidParse(urnComponents, options) {
            const uuidComponents = urnComponents;
            uuidComponents.uuid = uuidComponents.nss;
            uuidComponents.nss = void 0;
            if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) uuidComponents.error = uuidComponents.error || 'UUID is not valid.';
            return uuidComponents;
        }
        function urnuuidSerialize(uuidComponents) {
            const urnComponents = uuidComponents;
            urnComponents.nss = (uuidComponents.uuid || '').toLowerCase();
            return urnComponents;
        }
        const http = {
            scheme: 'http',
            domainHost: true,
            parse: httpParse,
            serialize: httpSerialize
        };
        const https = {
            scheme: 'https',
            domainHost: http.domainHost,
            parse: httpParse,
            serialize: httpSerialize
        };
        const ws = {
            scheme: 'ws',
            domainHost: true,
            parse: wsParse,
            serialize: wsSerialize
        };
        const wss = {
            scheme: 'wss',
            domainHost: ws.domainHost,
            parse: ws.parse,
            serialize: ws.serialize
        };
        const urn = {
            scheme: 'urn',
            parse: urnParse,
            serialize: urnSerialize,
            skipNormalize: true
        };
        const urnuuid = {
            scheme: 'urn:uuid',
            parse: urnuuidParse,
            serialize: urnuuidSerialize,
            skipNormalize: true
        };
        const SCHEMES = {
            http,
            https,
            ws,
            wss,
            urn,
            'urn:uuid': urnuuid
        };
        module.exports = SCHEMES;
    },
    "../node_modules/.pnpm/fast-uri@3.0.6/node_modules/fast-uri/lib/scopedChars.js": function(module) {
        "use strict";
        const HEX = {
            0: 0,
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 5,
            6: 6,
            7: 7,
            8: 8,
            9: 9,
            a: 10,
            A: 10,
            b: 11,
            B: 11,
            c: 12,
            C: 12,
            d: 13,
            D: 13,
            e: 14,
            E: 14,
            f: 15,
            F: 15
        };
        module.exports = {
            HEX
        };
    },
    "../node_modules/.pnpm/fast-uri@3.0.6/node_modules/fast-uri/lib/utils.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        const { HEX } = __webpack_require__("../node_modules/.pnpm/fast-uri@3.0.6/node_modules/fast-uri/lib/scopedChars.js");
        const IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
        function normalizeIPv4(host) {
            if (findToken(host, '.') < 3) return {
                host,
                isIPV4: false
            };
            const matches = host.match(IPV4_REG) || [];
            const [address] = matches;
            if (address) return {
                host: stripLeadingZeros(address, '.'),
                isIPV4: true
            };
            return {
                host,
                isIPV4: false
            };
        }
        function stringArrayToHexStripped(input, keepZero = false) {
            let acc = '';
            let strip = true;
            for (const c of input){
                if (void 0 === HEX[c]) return;
                if ('0' !== c && true === strip) strip = false;
                if (!strip) acc += c;
            }
            if (keepZero && 0 === acc.length) acc = '0';
            return acc;
        }
        function getIPV6(input) {
            let tokenCount = 0;
            const output = {
                error: false,
                address: '',
                zone: ''
            };
            const address = [];
            const buffer = [];
            let isZone = false;
            let endipv6Encountered = false;
            let endIpv6 = false;
            function consume() {
                if (buffer.length) {
                    if (false === isZone) {
                        const hex = stringArrayToHexStripped(buffer);
                        if (void 0 !== hex) address.push(hex);
                        else {
                            output.error = true;
                            return false;
                        }
                    }
                    buffer.length = 0;
                }
                return true;
            }
            for(let i = 0; i < input.length; i++){
                const cursor = input[i];
                if ('[' !== cursor && ']' !== cursor) if (':' === cursor) {
                    if (true === endipv6Encountered) endIpv6 = true;
                    if (!consume()) break;
                    tokenCount++;
                    address.push(':');
                    if (tokenCount > 7) {
                        output.error = true;
                        break;
                    }
                    if (i - 1 >= 0 && ':' === input[i - 1]) endipv6Encountered = true;
                    continue;
                } else if ('%' === cursor) {
                    if (!consume()) break;
                    isZone = true;
                } else {
                    buffer.push(cursor);
                    continue;
                }
            }
            if (buffer.length) if (isZone) output.zone = buffer.join('');
            else if (endIpv6) address.push(buffer.join(''));
            else address.push(stringArrayToHexStripped(buffer));
            output.address = address.join('');
            return output;
        }
        function normalizeIPv6(host) {
            if (findToken(host, ':') < 2) return {
                host,
                isIPV6: false
            };
            const ipv6 = getIPV6(host);
            if (ipv6.error) return {
                host,
                isIPV6: false
            };
            {
                let newHost = ipv6.address;
                let escapedHost = ipv6.address;
                if (ipv6.zone) {
                    newHost += '%' + ipv6.zone;
                    escapedHost += '%25' + ipv6.zone;
                }
                return {
                    host: newHost,
                    escapedHost,
                    isIPV6: true
                };
            }
        }
        function stripLeadingZeros(str, token) {
            let out = '';
            let skip = true;
            const l = str.length;
            for(let i = 0; i < l; i++){
                const c = str[i];
                if ('0' === c && skip) {
                    if (i + 1 <= l && str[i + 1] === token || i + 1 === l) {
                        out += c;
                        skip = false;
                    }
                } else {
                    skip = c === token;
                    out += c;
                }
            }
            return out;
        }
        function findToken(str, token) {
            let ind = 0;
            for(let i = 0; i < str.length; i++)if (str[i] === token) ind++;
            return ind;
        }
        const RDS1 = /^\.\.?\//u;
        const RDS2 = /^\/\.(?:\/|$)/u;
        const RDS3 = /^\/\.\.(?:\/|$)/u;
        const RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
        function removeDotSegments(input) {
            const output = [];
            while(input.length)if (input.match(RDS1)) input = input.replace(RDS1, '');
            else if (input.match(RDS2)) input = input.replace(RDS2, '/');
            else if (input.match(RDS3)) {
                input = input.replace(RDS3, '/');
                output.pop();
            } else if ('.' === input || '..' === input) input = '';
            else {
                const im = input.match(RDS5);
                if (im) {
                    const s = im[0];
                    input = input.slice(s.length);
                    output.push(s);
                } else throw new Error('Unexpected dot segment condition');
            }
            return output.join('');
        }
        function normalizeComponentEncoding(components, esc) {
            const func = true !== esc ? escape : unescape;
            if (void 0 !== components.scheme) components.scheme = func(components.scheme);
            if (void 0 !== components.userinfo) components.userinfo = func(components.userinfo);
            if (void 0 !== components.host) components.host = func(components.host);
            if (void 0 !== components.path) components.path = func(components.path);
            if (void 0 !== components.query) components.query = func(components.query);
            if (void 0 !== components.fragment) components.fragment = func(components.fragment);
            return components;
        }
        function recomposeAuthority(components) {
            const uriTokens = [];
            if (void 0 !== components.userinfo) {
                uriTokens.push(components.userinfo);
                uriTokens.push('@');
            }
            if (void 0 !== components.host) {
                let host = unescape(components.host);
                const ipV4res = normalizeIPv4(host);
                if (ipV4res.isIPV4) host = ipV4res.host;
                else {
                    const ipV6res = normalizeIPv6(ipV4res.host);
                    host = true === ipV6res.isIPV6 ? `[${ipV6res.escapedHost}]` : components.host;
                }
                uriTokens.push(host);
            }
            if ('number' == typeof components.port || 'string' == typeof components.port) {
                uriTokens.push(':');
                uriTokens.push(String(components.port));
            }
            return uriTokens.length ? uriTokens.join('') : void 0;
        }
        module.exports = {
            recomposeAuthority,
            normalizeComponentEncoding,
            removeDotSegments,
            normalizeIPv4,
            normalizeIPv6,
            stringArrayToHexStripped
        };
    },
    "../node_modules/.pnpm/tinycolor2@1.6.0/node_modules/tinycolor2/cjs/tinycolor.js": function(module) {
        (function(global1, factory) {
            module.exports = factory();
        })(0, function() {
            'use strict';
            function _typeof(obj) {
                return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                    return typeof obj;
                } : function(obj) {
                    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                }, _typeof(obj);
            }
            var trimLeft = /^\s+/;
            var trimRight = /\s+$/;
            function tinycolor(color, opts) {
                color = color ? color : "";
                opts = opts || {};
                if (color instanceof tinycolor) return color;
                if (!(this instanceof tinycolor)) return new tinycolor(color, opts);
                var rgb = inputToRGB(color);
                this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
                this._gradientType = opts.gradientType;
                if (this._r < 1) this._r = Math.round(this._r);
                if (this._g < 1) this._g = Math.round(this._g);
                if (this._b < 1) this._b = Math.round(this._b);
                this._ok = rgb.ok;
            }
            tinycolor.prototype = {
                isDark: function() {
                    return this.getBrightness() < 128;
                },
                isLight: function() {
                    return !this.isDark();
                },
                isValid: function() {
                    return this._ok;
                },
                getOriginalInput: function() {
                    return this._originalInput;
                },
                getFormat: function() {
                    return this._format;
                },
                getAlpha: function() {
                    return this._a;
                },
                getBrightness: function() {
                    var rgb = this.toRgb();
                    return (299 * rgb.r + 587 * rgb.g + 114 * rgb.b) / 1000;
                },
                getLuminance: function() {
                    var rgb = this.toRgb();
                    var RsRGB, GsRGB, BsRGB, R, G, B;
                    RsRGB = rgb.r / 255;
                    GsRGB = rgb.g / 255;
                    BsRGB = rgb.b / 255;
                    R = RsRGB <= 0.03928 ? RsRGB / 12.92 : Math.pow((RsRGB + 0.055) / 1.055, 2.4);
                    G = GsRGB <= 0.03928 ? GsRGB / 12.92 : Math.pow((GsRGB + 0.055) / 1.055, 2.4);
                    B = BsRGB <= 0.03928 ? BsRGB / 12.92 : Math.pow((BsRGB + 0.055) / 1.055, 2.4);
                    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
                },
                setAlpha: function(value) {
                    this._a = boundAlpha(value);
                    this._roundA = Math.round(100 * this._a) / 100;
                    return this;
                },
                toHsv: function() {
                    var hsv = rgbToHsv(this._r, this._g, this._b);
                    return {
                        h: 360 * hsv.h,
                        s: hsv.s,
                        v: hsv.v,
                        a: this._a
                    };
                },
                toHsvString: function() {
                    var hsv = rgbToHsv(this._r, this._g, this._b);
                    var h = Math.round(360 * hsv.h), s = Math.round(100 * hsv.s), v = Math.round(100 * hsv.v);
                    return 1 == this._a ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
                },
                toHsl: function() {
                    var hsl = rgbToHsl(this._r, this._g, this._b);
                    return {
                        h: 360 * hsl.h,
                        s: hsl.s,
                        l: hsl.l,
                        a: this._a
                    };
                },
                toHslString: function() {
                    var hsl = rgbToHsl(this._r, this._g, this._b);
                    var h = Math.round(360 * hsl.h), s = Math.round(100 * hsl.s), l = Math.round(100 * hsl.l);
                    return 1 == this._a ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
                },
                toHex: function(allow3Char) {
                    return rgbToHex(this._r, this._g, this._b, allow3Char);
                },
                toHexString: function(allow3Char) {
                    return "#" + this.toHex(allow3Char);
                },
                toHex8: function(allow4Char) {
                    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
                },
                toHex8String: function(allow4Char) {
                    return "#" + this.toHex8(allow4Char);
                },
                toRgb: function() {
                    return {
                        r: Math.round(this._r),
                        g: Math.round(this._g),
                        b: Math.round(this._b),
                        a: this._a
                    };
                },
                toRgbString: function() {
                    return 1 == this._a ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
                },
                toPercentageRgb: function() {
                    return {
                        r: Math.round(100 * bound01(this._r, 255)) + "%",
                        g: Math.round(100 * bound01(this._g, 255)) + "%",
                        b: Math.round(100 * bound01(this._b, 255)) + "%",
                        a: this._a
                    };
                },
                toPercentageRgbString: function() {
                    return 1 == this._a ? "rgb(" + Math.round(100 * bound01(this._r, 255)) + "%, " + Math.round(100 * bound01(this._g, 255)) + "%, " + Math.round(100 * bound01(this._b, 255)) + "%)" : "rgba(" + Math.round(100 * bound01(this._r, 255)) + "%, " + Math.round(100 * bound01(this._g, 255)) + "%, " + Math.round(100 * bound01(this._b, 255)) + "%, " + this._roundA + ")";
                },
                toName: function() {
                    if (0 === this._a) return "transparent";
                    if (this._a < 1) return false;
                    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
                },
                toFilter: function(secondColor) {
                    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
                    var secondHex8String = hex8String;
                    var gradientType = this._gradientType ? "GradientType = 1, " : "";
                    if (secondColor) {
                        var s = tinycolor(secondColor);
                        secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
                    }
                    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
                },
                toString: function(format) {
                    var formatSet = !!format;
                    format = format || this._format;
                    var formattedString = false;
                    var hasAlpha = this._a < 1 && this._a >= 0;
                    var needsAlphaFormat = !formatSet && hasAlpha && ("hex" === format || "hex6" === format || "hex3" === format || "hex4" === format || "hex8" === format || "name" === format);
                    if (needsAlphaFormat) {
                        if ("name" === format && 0 === this._a) return this.toName();
                        return this.toRgbString();
                    }
                    if ("rgb" === format) formattedString = this.toRgbString();
                    if ("prgb" === format) formattedString = this.toPercentageRgbString();
                    if ("hex" === format || "hex6" === format) formattedString = this.toHexString();
                    if ("hex3" === format) formattedString = this.toHexString(true);
                    if ("hex4" === format) formattedString = this.toHex8String(true);
                    if ("hex8" === format) formattedString = this.toHex8String();
                    if ("name" === format) formattedString = this.toName();
                    if ("hsl" === format) formattedString = this.toHslString();
                    if ("hsv" === format) formattedString = this.toHsvString();
                    return formattedString || this.toHexString();
                },
                clone: function() {
                    return tinycolor(this.toString());
                },
                _applyModification: function(fn, args) {
                    var color = fn.apply(null, [
                        this
                    ].concat([].slice.call(args)));
                    this._r = color._r;
                    this._g = color._g;
                    this._b = color._b;
                    this.setAlpha(color._a);
                    return this;
                },
                lighten: function() {
                    return this._applyModification(_lighten, arguments);
                },
                brighten: function() {
                    return this._applyModification(_brighten, arguments);
                },
                darken: function() {
                    return this._applyModification(_darken, arguments);
                },
                desaturate: function() {
                    return this._applyModification(_desaturate, arguments);
                },
                saturate: function() {
                    return this._applyModification(_saturate, arguments);
                },
                greyscale: function() {
                    return this._applyModification(_greyscale, arguments);
                },
                spin: function() {
                    return this._applyModification(_spin, arguments);
                },
                _applyCombination: function(fn, args) {
                    return fn.apply(null, [
                        this
                    ].concat([].slice.call(args)));
                },
                analogous: function() {
                    return this._applyCombination(_analogous, arguments);
                },
                complement: function() {
                    return this._applyCombination(_complement, arguments);
                },
                monochromatic: function() {
                    return this._applyCombination(_monochromatic, arguments);
                },
                splitcomplement: function() {
                    return this._applyCombination(_splitcomplement, arguments);
                },
                triad: function() {
                    return this._applyCombination(polyad, [
                        3
                    ]);
                },
                tetrad: function() {
                    return this._applyCombination(polyad, [
                        4
                    ]);
                }
            };
            tinycolor.fromRatio = function(color, opts) {
                if ("object" == _typeof(color)) {
                    var newColor = {};
                    for(var i in color)if (color.hasOwnProperty(i)) if ("a" === i) newColor[i] = color[i];
                    else newColor[i] = convertToPercentage(color[i]);
                    color = newColor;
                }
                return tinycolor(color, opts);
            };
            function inputToRGB(color) {
                var rgb = {
                    r: 0,
                    g: 0,
                    b: 0
                };
                var a = 1;
                var s = null;
                var v = null;
                var l = null;
                var ok = false;
                var format = false;
                if ("string" == typeof color) color = stringInputToObject(color);
                if ("object" == _typeof(color)) {
                    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
                        rgb = rgbToRgb(color.r, color.g, color.b);
                        ok = true;
                        format = "%" === String(color.r).substr(-1) ? "prgb" : "rgb";
                    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
                        s = convertToPercentage(color.s);
                        v = convertToPercentage(color.v);
                        rgb = hsvToRgb(color.h, s, v);
                        ok = true;
                        format = "hsv";
                    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
                        s = convertToPercentage(color.s);
                        l = convertToPercentage(color.l);
                        rgb = hslToRgb(color.h, s, l);
                        ok = true;
                        format = "hsl";
                    }
                    if (color.hasOwnProperty("a")) a = color.a;
                }
                a = boundAlpha(a);
                return {
                    ok: ok,
                    format: color.format || format,
                    r: Math.min(255, Math.max(rgb.r, 0)),
                    g: Math.min(255, Math.max(rgb.g, 0)),
                    b: Math.min(255, Math.max(rgb.b, 0)),
                    a: a
                };
            }
            function rgbToRgb(r, g, b) {
                return {
                    r: 255 * bound01(r, 255),
                    g: 255 * bound01(g, 255),
                    b: 255 * bound01(b, 255)
                };
            }
            function rgbToHsl(r, g, b) {
                r = bound01(r, 255);
                g = bound01(g, 255);
                b = bound01(b, 255);
                var max = Math.max(r, g, b), min = Math.min(r, g, b);
                var h, s, l = (max + min) / 2;
                if (max == min) h = s = 0;
                else {
                    var d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch(max){
                        case r:
                            h = (g - b) / d + (g < b ? 6 : 0);
                            break;
                        case g:
                            h = (b - r) / d + 2;
                            break;
                        case b:
                            h = (r - g) / d + 4;
                            break;
                    }
                    h /= 6;
                }
                return {
                    h: h,
                    s: s,
                    l: l
                };
            }
            function hslToRgb(h, s, l) {
                var r, g, b;
                h = bound01(h, 360);
                s = bound01(s, 100);
                l = bound01(l, 100);
                function hue2rgb(p, q, t) {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 0.5) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                }
                if (0 === s) r = g = b = l;
                else {
                    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    var p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1 / 3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1 / 3);
                }
                return {
                    r: 255 * r,
                    g: 255 * g,
                    b: 255 * b
                };
            }
            function rgbToHsv(r, g, b) {
                r = bound01(r, 255);
                g = bound01(g, 255);
                b = bound01(b, 255);
                var max = Math.max(r, g, b), min = Math.min(r, g, b);
                var h, s, v = max;
                var d = max - min;
                s = 0 === max ? 0 : d / max;
                if (max == min) h = 0;
                else {
                    switch(max){
                        case r:
                            h = (g - b) / d + (g < b ? 6 : 0);
                            break;
                        case g:
                            h = (b - r) / d + 2;
                            break;
                        case b:
                            h = (r - g) / d + 4;
                            break;
                    }
                    h /= 6;
                }
                return {
                    h: h,
                    s: s,
                    v: v
                };
            }
            function hsvToRgb(h, s, v) {
                h = 6 * bound01(h, 360);
                s = bound01(s, 100);
                v = bound01(v, 100);
                var i = Math.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6, r = [
                    v,
                    q,
                    p,
                    p,
                    t,
                    v
                ][mod], g = [
                    t,
                    v,
                    v,
                    q,
                    p,
                    p
                ][mod], b = [
                    p,
                    p,
                    t,
                    v,
                    v,
                    q
                ][mod];
                return {
                    r: 255 * r,
                    g: 255 * g,
                    b: 255 * b
                };
            }
            function rgbToHex(r, g, b, allow3Char) {
                var hex = [
                    pad2(Math.round(r).toString(16)),
                    pad2(Math.round(g).toString(16)),
                    pad2(Math.round(b).toString(16))
                ];
                if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
                return hex.join("");
            }
            function rgbaToHex(r, g, b, a, allow4Char) {
                var hex = [
                    pad2(Math.round(r).toString(16)),
                    pad2(Math.round(g).toString(16)),
                    pad2(Math.round(b).toString(16)),
                    pad2(convertDecimalToHex(a))
                ];
                if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
                return hex.join("");
            }
            function rgbaToArgbHex(r, g, b, a) {
                var hex = [
                    pad2(convertDecimalToHex(a)),
                    pad2(Math.round(r).toString(16)),
                    pad2(Math.round(g).toString(16)),
                    pad2(Math.round(b).toString(16))
                ];
                return hex.join("");
            }
            tinycolor.equals = function(color1, color2) {
                if (!color1 || !color2) return false;
                return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
            };
            tinycolor.random = function() {
                return tinycolor.fromRatio({
                    r: Math.random(),
                    g: Math.random(),
                    b: Math.random()
                });
            };
            function _desaturate(color, amount) {
                amount = 0 === amount ? 0 : amount || 10;
                var hsl = tinycolor(color).toHsl();
                hsl.s -= amount / 100;
                hsl.s = clamp01(hsl.s);
                return tinycolor(hsl);
            }
            function _saturate(color, amount) {
                amount = 0 === amount ? 0 : amount || 10;
                var hsl = tinycolor(color).toHsl();
                hsl.s += amount / 100;
                hsl.s = clamp01(hsl.s);
                return tinycolor(hsl);
            }
            function _greyscale(color) {
                return tinycolor(color).desaturate(100);
            }
            function _lighten(color, amount) {
                amount = 0 === amount ? 0 : amount || 10;
                var hsl = tinycolor(color).toHsl();
                hsl.l += amount / 100;
                hsl.l = clamp01(hsl.l);
                return tinycolor(hsl);
            }
            function _brighten(color, amount) {
                amount = 0 === amount ? 0 : amount || 10;
                var rgb = tinycolor(color).toRgb();
                rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
                rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
                rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
                return tinycolor(rgb);
            }
            function _darken(color, amount) {
                amount = 0 === amount ? 0 : amount || 10;
                var hsl = tinycolor(color).toHsl();
                hsl.l -= amount / 100;
                hsl.l = clamp01(hsl.l);
                return tinycolor(hsl);
            }
            function _spin(color, amount) {
                var hsl = tinycolor(color).toHsl();
                var hue = (hsl.h + amount) % 360;
                hsl.h = hue < 0 ? 360 + hue : hue;
                return tinycolor(hsl);
            }
            function _complement(color) {
                var hsl = tinycolor(color).toHsl();
                hsl.h = (hsl.h + 180) % 360;
                return tinycolor(hsl);
            }
            function polyad(color, number) {
                if (isNaN(number) || number <= 0) throw new Error("Argument to polyad must be a positive number");
                var hsl = tinycolor(color).toHsl();
                var result = [
                    tinycolor(color)
                ];
                var step = 360 / number;
                for(var i = 1; i < number; i++)result.push(tinycolor({
                    h: (hsl.h + i * step) % 360,
                    s: hsl.s,
                    l: hsl.l
                }));
                return result;
            }
            function _splitcomplement(color) {
                var hsl = tinycolor(color).toHsl();
                var h = hsl.h;
                return [
                    tinycolor(color),
                    tinycolor({
                        h: (h + 72) % 360,
                        s: hsl.s,
                        l: hsl.l
                    }),
                    tinycolor({
                        h: (h + 216) % 360,
                        s: hsl.s,
                        l: hsl.l
                    })
                ];
            }
            function _analogous(color, results, slices) {
                results = results || 6;
                slices = slices || 30;
                var hsl = tinycolor(color).toHsl();
                var part = 360 / slices;
                var ret = [
                    tinycolor(color)
                ];
                for(hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;){
                    hsl.h = (hsl.h + part) % 360;
                    ret.push(tinycolor(hsl));
                }
                return ret;
            }
            function _monochromatic(color, results) {
                results = results || 6;
                var hsv = tinycolor(color).toHsv();
                var h = hsv.h, s = hsv.s, v = hsv.v;
                var ret = [];
                var modification = 1 / results;
                while(results--){
                    ret.push(tinycolor({
                        h: h,
                        s: s,
                        v: v
                    }));
                    v = (v + modification) % 1;
                }
                return ret;
            }
            tinycolor.mix = function(color1, color2, amount) {
                amount = 0 === amount ? 0 : amount || 50;
                var rgb1 = tinycolor(color1).toRgb();
                var rgb2 = tinycolor(color2).toRgb();
                var p = amount / 100;
                var rgba = {
                    r: (rgb2.r - rgb1.r) * p + rgb1.r,
                    g: (rgb2.g - rgb1.g) * p + rgb1.g,
                    b: (rgb2.b - rgb1.b) * p + rgb1.b,
                    a: (rgb2.a - rgb1.a) * p + rgb1.a
                };
                return tinycolor(rgba);
            };
            tinycolor.readability = function(color1, color2) {
                var c1 = tinycolor(color1);
                var c2 = tinycolor(color2);
                return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
            };
            tinycolor.isReadable = function(color1, color2, wcag2) {
                var readability = tinycolor.readability(color1, color2);
                var wcag2Parms, out;
                out = false;
                wcag2Parms = validateWCAG2Parms(wcag2);
                switch(wcag2Parms.level + wcag2Parms.size){
                    case "AAsmall":
                    case "AAAlarge":
                        out = readability >= 4.5;
                        break;
                    case "AAlarge":
                        out = readability >= 3;
                        break;
                    case "AAAsmall":
                        out = readability >= 7;
                        break;
                }
                return out;
            };
            tinycolor.mostReadable = function(baseColor, colorList, args) {
                var bestColor = null;
                var bestScore = 0;
                var readability;
                var includeFallbackColors, level, size;
                args = args || {};
                includeFallbackColors = args.includeFallbackColors;
                level = args.level;
                size = args.size;
                for(var i = 0; i < colorList.length; i++){
                    readability = tinycolor.readability(baseColor, colorList[i]);
                    if (readability > bestScore) {
                        bestScore = readability;
                        bestColor = tinycolor(colorList[i]);
                    }
                }
                if (tinycolor.isReadable(baseColor, bestColor, {
                    level: level,
                    size: size
                }) || !includeFallbackColors) return bestColor;
                args.includeFallbackColors = false;
                return tinycolor.mostReadable(baseColor, [
                    "#fff",
                    "#000"
                ], args);
            };
            var names = tinycolor.names = {
                aliceblue: "f0f8ff",
                antiquewhite: "faebd7",
                aqua: "0ff",
                aquamarine: "7fffd4",
                azure: "f0ffff",
                beige: "f5f5dc",
                bisque: "ffe4c4",
                black: "000",
                blanchedalmond: "ffebcd",
                blue: "00f",
                blueviolet: "8a2be2",
                brown: "a52a2a",
                burlywood: "deb887",
                burntsienna: "ea7e5d",
                cadetblue: "5f9ea0",
                chartreuse: "7fff00",
                chocolate: "d2691e",
                coral: "ff7f50",
                cornflowerblue: "6495ed",
                cornsilk: "fff8dc",
                crimson: "dc143c",
                cyan: "0ff",
                darkblue: "00008b",
                darkcyan: "008b8b",
                darkgoldenrod: "b8860b",
                darkgray: "a9a9a9",
                darkgreen: "006400",
                darkgrey: "a9a9a9",
                darkkhaki: "bdb76b",
                darkmagenta: "8b008b",
                darkolivegreen: "556b2f",
                darkorange: "ff8c00",
                darkorchid: "9932cc",
                darkred: "8b0000",
                darksalmon: "e9967a",
                darkseagreen: "8fbc8f",
                darkslateblue: "483d8b",
                darkslategray: "2f4f4f",
                darkslategrey: "2f4f4f",
                darkturquoise: "00ced1",
                darkviolet: "9400d3",
                deeppink: "ff1493",
                deepskyblue: "00bfff",
                dimgray: "696969",
                dimgrey: "696969",
                dodgerblue: "1e90ff",
                firebrick: "b22222",
                floralwhite: "fffaf0",
                forestgreen: "228b22",
                fuchsia: "f0f",
                gainsboro: "dcdcdc",
                ghostwhite: "f8f8ff",
                gold: "ffd700",
                goldenrod: "daa520",
                gray: "808080",
                green: "008000",
                greenyellow: "adff2f",
                grey: "808080",
                honeydew: "f0fff0",
                hotpink: "ff69b4",
                indianred: "cd5c5c",
                indigo: "4b0082",
                ivory: "fffff0",
                khaki: "f0e68c",
                lavender: "e6e6fa",
                lavenderblush: "fff0f5",
                lawngreen: "7cfc00",
                lemonchiffon: "fffacd",
                lightblue: "add8e6",
                lightcoral: "f08080",
                lightcyan: "e0ffff",
                lightgoldenrodyellow: "fafad2",
                lightgray: "d3d3d3",
                lightgreen: "90ee90",
                lightgrey: "d3d3d3",
                lightpink: "ffb6c1",
                lightsalmon: "ffa07a",
                lightseagreen: "20b2aa",
                lightskyblue: "87cefa",
                lightslategray: "789",
                lightslategrey: "789",
                lightsteelblue: "b0c4de",
                lightyellow: "ffffe0",
                lime: "0f0",
                limegreen: "32cd32",
                linen: "faf0e6",
                magenta: "f0f",
                maroon: "800000",
                mediumaquamarine: "66cdaa",
                mediumblue: "0000cd",
                mediumorchid: "ba55d3",
                mediumpurple: "9370db",
                mediumseagreen: "3cb371",
                mediumslateblue: "7b68ee",
                mediumspringgreen: "00fa9a",
                mediumturquoise: "48d1cc",
                mediumvioletred: "c71585",
                midnightblue: "191970",
                mintcream: "f5fffa",
                mistyrose: "ffe4e1",
                moccasin: "ffe4b5",
                navajowhite: "ffdead",
                navy: "000080",
                oldlace: "fdf5e6",
                olive: "808000",
                olivedrab: "6b8e23",
                orange: "ffa500",
                orangered: "ff4500",
                orchid: "da70d6",
                palegoldenrod: "eee8aa",
                palegreen: "98fb98",
                paleturquoise: "afeeee",
                palevioletred: "db7093",
                papayawhip: "ffefd5",
                peachpuff: "ffdab9",
                peru: "cd853f",
                pink: "ffc0cb",
                plum: "dda0dd",
                powderblue: "b0e0e6",
                purple: "800080",
                rebeccapurple: "663399",
                red: "f00",
                rosybrown: "bc8f8f",
                royalblue: "4169e1",
                saddlebrown: "8b4513",
                salmon: "fa8072",
                sandybrown: "f4a460",
                seagreen: "2e8b57",
                seashell: "fff5ee",
                sienna: "a0522d",
                silver: "c0c0c0",
                skyblue: "87ceeb",
                slateblue: "6a5acd",
                slategray: "708090",
                slategrey: "708090",
                snow: "fffafa",
                springgreen: "00ff7f",
                steelblue: "4682b4",
                tan: "d2b48c",
                teal: "008080",
                thistle: "d8bfd8",
                tomato: "ff6347",
                turquoise: "40e0d0",
                violet: "ee82ee",
                wheat: "f5deb3",
                white: "fff",
                whitesmoke: "f5f5f5",
                yellow: "ff0",
                yellowgreen: "9acd32"
            };
            var hexNames = tinycolor.hexNames = flip(names);
            function flip(o) {
                var flipped = {};
                for(var i in o)if (o.hasOwnProperty(i)) flipped[o[i]] = i;
                return flipped;
            }
            function boundAlpha(a) {
                a = parseFloat(a);
                if (isNaN(a) || a < 0 || a > 1) a = 1;
                return a;
            }
            function bound01(n, max) {
                if (isOnePointZero(n)) n = "100%";
                var processPercent = isPercentage(n);
                n = Math.min(max, Math.max(0, parseFloat(n)));
                if (processPercent) n = parseInt(n * max, 10) / 100;
                if (Math.abs(n - max) < 0.000001) return 1;
                return n % max / parseFloat(max);
            }
            function clamp01(val) {
                return Math.min(1, Math.max(0, val));
            }
            function parseIntFromHex(val) {
                return parseInt(val, 16);
            }
            function isOnePointZero(n) {
                return "string" == typeof n && -1 != n.indexOf(".") && 1 === parseFloat(n);
            }
            function isPercentage(n) {
                return "string" == typeof n && -1 != n.indexOf("%");
            }
            function pad2(c) {
                return 1 == c.length ? "0" + c : "" + c;
            }
            function convertToPercentage(n) {
                if (n <= 1) n = 100 * n + "%";
                return n;
            }
            function convertDecimalToHex(d) {
                return Math.round(255 * parseFloat(d)).toString(16);
            }
            function convertHexToDecimal(h) {
                return parseIntFromHex(h) / 255;
            }
            var matchers = function() {
                var CSS_INTEGER = "[-\\+]?\\d+%?";
                var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
                var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
                var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
                var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
                return {
                    CSS_UNIT: new RegExp(CSS_UNIT),
                    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
                    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
                    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
                    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
                    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
                    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
                    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
                    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
                };
            }();
            function isValidCSSUnit(color) {
                return !!matchers.CSS_UNIT.exec(color);
            }
            function stringInputToObject(color) {
                color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
                var named = false;
                if (names[color]) {
                    color = names[color];
                    named = true;
                } else if ("transparent" == color) return {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 0,
                    format: "name"
                };
                var match;
                if (match = matchers.rgb.exec(color)) return {
                    r: match[1],
                    g: match[2],
                    b: match[3]
                };
                if (match = matchers.rgba.exec(color)) return {
                    r: match[1],
                    g: match[2],
                    b: match[3],
                    a: match[4]
                };
                if (match = matchers.hsl.exec(color)) return {
                    h: match[1],
                    s: match[2],
                    l: match[3]
                };
                if (match = matchers.hsla.exec(color)) return {
                    h: match[1],
                    s: match[2],
                    l: match[3],
                    a: match[4]
                };
                if (match = matchers.hsv.exec(color)) return {
                    h: match[1],
                    s: match[2],
                    v: match[3]
                };
                if (match = matchers.hsva.exec(color)) return {
                    h: match[1],
                    s: match[2],
                    v: match[3],
                    a: match[4]
                };
                if (match = matchers.hex8.exec(color)) return {
                    r: parseIntFromHex(match[1]),
                    g: parseIntFromHex(match[2]),
                    b: parseIntFromHex(match[3]),
                    a: convertHexToDecimal(match[4]),
                    format: named ? "name" : "hex8"
                };
                if (match = matchers.hex6.exec(color)) return {
                    r: parseIntFromHex(match[1]),
                    g: parseIntFromHex(match[2]),
                    b: parseIntFromHex(match[3]),
                    format: named ? "name" : "hex"
                };
                if (match = matchers.hex4.exec(color)) return {
                    r: parseIntFromHex(match[1] + "" + match[1]),
                    g: parseIntFromHex(match[2] + "" + match[2]),
                    b: parseIntFromHex(match[3] + "" + match[3]),
                    a: convertHexToDecimal(match[4] + "" + match[4]),
                    format: named ? "name" : "hex8"
                };
                if (match = matchers.hex3.exec(color)) return {
                    r: parseIntFromHex(match[1] + "" + match[1]),
                    g: parseIntFromHex(match[2] + "" + match[2]),
                    b: parseIntFromHex(match[3] + "" + match[3]),
                    format: named ? "name" : "hex"
                };
                return false;
            }
            function validateWCAG2Parms(parms) {
                var level, size;
                parms = parms || {
                    level: "AA",
                    size: "small"
                };
                level = (parms.level || "AA").toUpperCase();
                size = (parms.size || "small").toLowerCase();
                if ("AA" !== level && "AAA" !== level) level = "AA";
                if ("small" !== size && "large" !== size) size = "small";
                return {
                    level: level,
                    size: size
                };
            }
            return tinycolor;
        });
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/data.json": function(module) {
        "use strict";
        module.exports = JSON.parse('{"$id":"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#","description":"Meta-schema for $data reference (JSON AnySchema extension proposal)","type":"object","required":["$data"],"properties":{"$data":{"type":"string","anyOf":[{"format":"relative-json-pointer"},{"format":"json-pointer"}]}},"additionalProperties":false}');
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-2020-12/meta/applicator.json": function(module) {
        "use strict";
        module.exports = JSON.parse('{"$schema":"https://json-schema.org/draft/2020-12/schema","$id":"https://json-schema.org/draft/2020-12/meta/applicator","$vocabulary":{"https://json-schema.org/draft/2020-12/vocab/applicator":true},"$dynamicAnchor":"meta","title":"Applicator vocabulary meta-schema","type":["object","boolean"],"properties":{"prefixItems":{"$ref":"#/$defs/schemaArray"},"items":{"$dynamicRef":"#meta"},"contains":{"$dynamicRef":"#meta"},"additionalProperties":{"$dynamicRef":"#meta"},"properties":{"type":"object","additionalProperties":{"$dynamicRef":"#meta"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$dynamicRef":"#meta"},"propertyNames":{"format":"regex"},"default":{}},"dependentSchemas":{"type":"object","additionalProperties":{"$dynamicRef":"#meta"},"default":{}},"propertyNames":{"$dynamicRef":"#meta"},"if":{"$dynamicRef":"#meta"},"then":{"$dynamicRef":"#meta"},"else":{"$dynamicRef":"#meta"},"allOf":{"$ref":"#/$defs/schemaArray"},"anyOf":{"$ref":"#/$defs/schemaArray"},"oneOf":{"$ref":"#/$defs/schemaArray"},"not":{"$dynamicRef":"#meta"}},"$defs":{"schemaArray":{"type":"array","minItems":1,"items":{"$dynamicRef":"#meta"}}}}');
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-2020-12/meta/content.json": function(module) {
        "use strict";
        module.exports = JSON.parse('{"$schema":"https://json-schema.org/draft/2020-12/schema","$id":"https://json-schema.org/draft/2020-12/meta/content","$vocabulary":{"https://json-schema.org/draft/2020-12/vocab/content":true},"$dynamicAnchor":"meta","title":"Content vocabulary meta-schema","type":["object","boolean"],"properties":{"contentEncoding":{"type":"string"},"contentMediaType":{"type":"string"},"contentSchema":{"$dynamicRef":"#meta"}}}');
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-2020-12/meta/core.json": function(module) {
        "use strict";
        module.exports = JSON.parse('{"$schema":"https://json-schema.org/draft/2020-12/schema","$id":"https://json-schema.org/draft/2020-12/meta/core","$vocabulary":{"https://json-schema.org/draft/2020-12/vocab/core":true},"$dynamicAnchor":"meta","title":"Core vocabulary meta-schema","type":["object","boolean"],"properties":{"$id":{"$ref":"#/$defs/uriReferenceString","$comment":"Non-empty fragments not allowed.","pattern":"^[^#]*#?$"},"$schema":{"$ref":"#/$defs/uriString"},"$ref":{"$ref":"#/$defs/uriReferenceString"},"$anchor":{"$ref":"#/$defs/anchorString"},"$dynamicRef":{"$ref":"#/$defs/uriReferenceString"},"$dynamicAnchor":{"$ref":"#/$defs/anchorString"},"$vocabulary":{"type":"object","propertyNames":{"$ref":"#/$defs/uriString"},"additionalProperties":{"type":"boolean"}},"$comment":{"type":"string"},"$defs":{"type":"object","additionalProperties":{"$dynamicRef":"#meta"}}},"$defs":{"anchorString":{"type":"string","pattern":"^[A-Za-z_][-A-Za-z0-9._]*$"},"uriString":{"type":"string","format":"uri"},"uriReferenceString":{"type":"string","format":"uri-reference"}}}');
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-2020-12/meta/format-annotation.json": function(module) {
        "use strict";
        module.exports = JSON.parse('{"$schema":"https://json-schema.org/draft/2020-12/schema","$id":"https://json-schema.org/draft/2020-12/meta/format-annotation","$vocabulary":{"https://json-schema.org/draft/2020-12/vocab/format-annotation":true},"$dynamicAnchor":"meta","title":"Format vocabulary meta-schema for annotation results","type":["object","boolean"],"properties":{"format":{"type":"string"}}}');
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-2020-12/meta/meta-data.json": function(module) {
        "use strict";
        module.exports = JSON.parse('{"$schema":"https://json-schema.org/draft/2020-12/schema","$id":"https://json-schema.org/draft/2020-12/meta/meta-data","$vocabulary":{"https://json-schema.org/draft/2020-12/vocab/meta-data":true},"$dynamicAnchor":"meta","title":"Meta-data vocabulary meta-schema","type":["object","boolean"],"properties":{"title":{"type":"string"},"description":{"type":"string"},"default":true,"deprecated":{"type":"boolean","default":false},"readOnly":{"type":"boolean","default":false},"writeOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true}}}');
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-2020-12/meta/unevaluated.json": function(module) {
        "use strict";
        module.exports = JSON.parse('{"$schema":"https://json-schema.org/draft/2020-12/schema","$id":"https://json-schema.org/draft/2020-12/meta/unevaluated","$vocabulary":{"https://json-schema.org/draft/2020-12/vocab/unevaluated":true},"$dynamicAnchor":"meta","title":"Unevaluated applicator vocabulary meta-schema","type":["object","boolean"],"properties":{"unevaluatedItems":{"$dynamicRef":"#meta"},"unevaluatedProperties":{"$dynamicRef":"#meta"}}}');
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-2020-12/meta/validation.json": function(module) {
        "use strict";
        module.exports = JSON.parse('{"$schema":"https://json-schema.org/draft/2020-12/schema","$id":"https://json-schema.org/draft/2020-12/meta/validation","$vocabulary":{"https://json-schema.org/draft/2020-12/vocab/validation":true},"$dynamicAnchor":"meta","title":"Validation vocabulary meta-schema","type":["object","boolean"],"properties":{"type":{"anyOf":[{"$ref":"#/$defs/simpleTypes"},{"type":"array","items":{"$ref":"#/$defs/simpleTypes"},"minItems":1,"uniqueItems":true}]},"const":true,"enum":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/$defs/nonNegativeInteger"},"minLength":{"$ref":"#/$defs/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"maxItems":{"$ref":"#/$defs/nonNegativeInteger"},"minItems":{"$ref":"#/$defs/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"maxContains":{"$ref":"#/$defs/nonNegativeInteger"},"minContains":{"$ref":"#/$defs/nonNegativeInteger","default":1},"maxProperties":{"$ref":"#/$defs/nonNegativeInteger"},"minProperties":{"$ref":"#/$defs/nonNegativeIntegerDefault0"},"required":{"$ref":"#/$defs/stringArray"},"dependentRequired":{"type":"object","additionalProperties":{"$ref":"#/$defs/stringArray"}}},"$defs":{"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"$ref":"#/$defs/nonNegativeInteger","default":0},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}}}');
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-2020-12/schema.json": function(module) {
        "use strict";
        module.exports = JSON.parse('{"$schema":"https://json-schema.org/draft/2020-12/schema","$id":"https://json-schema.org/draft/2020-12/schema","$vocabulary":{"https://json-schema.org/draft/2020-12/vocab/core":true,"https://json-schema.org/draft/2020-12/vocab/applicator":true,"https://json-schema.org/draft/2020-12/vocab/unevaluated":true,"https://json-schema.org/draft/2020-12/vocab/validation":true,"https://json-schema.org/draft/2020-12/vocab/meta-data":true,"https://json-schema.org/draft/2020-12/vocab/format-annotation":true,"https://json-schema.org/draft/2020-12/vocab/content":true},"$dynamicAnchor":"meta","title":"Core and Validation specifications meta-schema","allOf":[{"$ref":"meta/core"},{"$ref":"meta/applicator"},{"$ref":"meta/unevaluated"},{"$ref":"meta/validation"},{"$ref":"meta/meta-data"},{"$ref":"meta/format-annotation"},{"$ref":"meta/content"}],"type":["object","boolean"],"$comment":"This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.","properties":{"definitions":{"$comment":"\\"definitions\\" has been replaced by \\"$defs\\".","type":"object","additionalProperties":{"$dynamicRef":"#meta"},"deprecated":true,"default":{}},"dependencies":{"$comment":"\\"dependencies\\" has been split and replaced by \\"dependentSchemas\\" and \\"dependentRequired\\" in order to serve their differing semantics.","type":"object","additionalProperties":{"anyOf":[{"$dynamicRef":"#meta"},{"$ref":"meta/validation#/$defs/stringArray"}]},"deprecated":true,"default":{}},"$recursiveAnchor":{"$comment":"\\"$recursiveAnchor\\" has been replaced by \\"$dynamicAnchor\\".","$ref":"meta/core#/$defs/anchorString","deprecated":true},"$recursiveRef":{"$comment":"\\"$recursiveRef\\" has been replaced by \\"$dynamicRef\\".","$ref":"meta/core#/$defs/uriReferenceString","deprecated":true}}}');
    },
    "../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-draft-07.json": function(module) {
        "use strict";
        module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema#","$id":"http://json-schema.org/draft-07/schema#","title":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}},"type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"$comment":{"type":"string"},"title":{"type":"string"},"description":{"type":"string"},"default":true,"readOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":true},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"propertyNames":{"format":"regex"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":true,"enum":{"type":"array","items":true,"minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"contentMediaType":{"type":"string"},"contentEncoding":{"type":"string"},"if":{"$ref":"#"},"then":{"$ref":"#"},"else":{"$ref":"#"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"default":true}');
    },
    "../node_modules/.pnpm/cli-boxes@3.0.0/node_modules/cli-boxes/boxes.json": function(module) {
        "use strict";
        module.exports = JSON.parse('{"single":{"topLeft":"┌","top":"─","topRight":"┐","right":"│","bottomRight":"┘","bottom":"─","bottomLeft":"└","left":"│"},"double":{"topLeft":"╔","top":"═","topRight":"╗","right":"║","bottomRight":"╝","bottom":"═","bottomLeft":"╚","left":"║"},"round":{"topLeft":"╭","top":"─","topRight":"╮","right":"│","bottomRight":"╯","bottom":"─","bottomLeft":"╰","left":"│"},"bold":{"topLeft":"┏","top":"━","topRight":"┓","right":"┃","bottomRight":"┛","bottom":"━","bottomLeft":"┗","left":"┃"},"singleDouble":{"topLeft":"╓","top":"─","topRight":"╖","right":"║","bottomRight":"╜","bottom":"─","bottomLeft":"╙","left":"║"},"doubleSingle":{"topLeft":"╒","top":"═","topRight":"╕","right":"│","bottomRight":"╛","bottom":"═","bottomLeft":"╘","left":"│"},"classic":{"topLeft":"+","top":"-","topRight":"+","right":"|","bottomRight":"+","bottom":"-","bottomLeft":"+","left":"|"},"arrow":{"topLeft":"↘","top":"↓","topRight":"↙","right":"←","bottomRight":"↖","bottom":"↑","bottomLeft":"↗","left":"→"}}');
    },
    "../node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/lib/mappingTable.json": function(module) {
        "use strict";
        module.exports = JSON.parse('[[[0,44],"disallowed_STD3_valid"],[[45,46],"valid"],[[47,47],"disallowed_STD3_valid"],[[48,57],"valid"],[[58,64],"disallowed_STD3_valid"],[[65,65],"mapped",[97]],[[66,66],"mapped",[98]],[[67,67],"mapped",[99]],[[68,68],"mapped",[100]],[[69,69],"mapped",[101]],[[70,70],"mapped",[102]],[[71,71],"mapped",[103]],[[72,72],"mapped",[104]],[[73,73],"mapped",[105]],[[74,74],"mapped",[106]],[[75,75],"mapped",[107]],[[76,76],"mapped",[108]],[[77,77],"mapped",[109]],[[78,78],"mapped",[110]],[[79,79],"mapped",[111]],[[80,80],"mapped",[112]],[[81,81],"mapped",[113]],[[82,82],"mapped",[114]],[[83,83],"mapped",[115]],[[84,84],"mapped",[116]],[[85,85],"mapped",[117]],[[86,86],"mapped",[118]],[[87,87],"mapped",[119]],[[88,88],"mapped",[120]],[[89,89],"mapped",[121]],[[90,90],"mapped",[122]],[[91,96],"disallowed_STD3_valid"],[[97,122],"valid"],[[123,127],"disallowed_STD3_valid"],[[128,159],"disallowed"],[[160,160],"disallowed_STD3_mapped",[32]],[[161,167],"valid",[],"NV8"],[[168,168],"disallowed_STD3_mapped",[32,776]],[[169,169],"valid",[],"NV8"],[[170,170],"mapped",[97]],[[171,172],"valid",[],"NV8"],[[173,173],"ignored"],[[174,174],"valid",[],"NV8"],[[175,175],"disallowed_STD3_mapped",[32,772]],[[176,177],"valid",[],"NV8"],[[178,178],"mapped",[50]],[[179,179],"mapped",[51]],[[180,180],"disallowed_STD3_mapped",[32,769]],[[181,181],"mapped",[956]],[[182,182],"valid",[],"NV8"],[[183,183],"valid"],[[184,184],"disallowed_STD3_mapped",[32,807]],[[185,185],"mapped",[49]],[[186,186],"mapped",[111]],[[187,187],"valid",[],"NV8"],[[188,188],"mapped",[49,8260,52]],[[189,189],"mapped",[49,8260,50]],[[190,190],"mapped",[51,8260,52]],[[191,191],"valid",[],"NV8"],[[192,192],"mapped",[224]],[[193,193],"mapped",[225]],[[194,194],"mapped",[226]],[[195,195],"mapped",[227]],[[196,196],"mapped",[228]],[[197,197],"mapped",[229]],[[198,198],"mapped",[230]],[[199,199],"mapped",[231]],[[200,200],"mapped",[232]],[[201,201],"mapped",[233]],[[202,202],"mapped",[234]],[[203,203],"mapped",[235]],[[204,204],"mapped",[236]],[[205,205],"mapped",[237]],[[206,206],"mapped",[238]],[[207,207],"mapped",[239]],[[208,208],"mapped",[240]],[[209,209],"mapped",[241]],[[210,210],"mapped",[242]],[[211,211],"mapped",[243]],[[212,212],"mapped",[244]],[[213,213],"mapped",[245]],[[214,214],"mapped",[246]],[[215,215],"valid",[],"NV8"],[[216,216],"mapped",[248]],[[217,217],"mapped",[249]],[[218,218],"mapped",[250]],[[219,219],"mapped",[251]],[[220,220],"mapped",[252]],[[221,221],"mapped",[253]],[[222,222],"mapped",[254]],[[223,223],"deviation",[115,115]],[[224,246],"valid"],[[247,247],"valid",[],"NV8"],[[248,255],"valid"],[[256,256],"mapped",[257]],[[257,257],"valid"],[[258,258],"mapped",[259]],[[259,259],"valid"],[[260,260],"mapped",[261]],[[261,261],"valid"],[[262,262],"mapped",[263]],[[263,263],"valid"],[[264,264],"mapped",[265]],[[265,265],"valid"],[[266,266],"mapped",[267]],[[267,267],"valid"],[[268,268],"mapped",[269]],[[269,269],"valid"],[[270,270],"mapped",[271]],[[271,271],"valid"],[[272,272],"mapped",[273]],[[273,273],"valid"],[[274,274],"mapped",[275]],[[275,275],"valid"],[[276,276],"mapped",[277]],[[277,277],"valid"],[[278,278],"mapped",[279]],[[279,279],"valid"],[[280,280],"mapped",[281]],[[281,281],"valid"],[[282,282],"mapped",[283]],[[283,283],"valid"],[[284,284],"mapped",[285]],[[285,285],"valid"],[[286,286],"mapped",[287]],[[287,287],"valid"],[[288,288],"mapped",[289]],[[289,289],"valid"],[[290,290],"mapped",[291]],[[291,291],"valid"],[[292,292],"mapped",[293]],[[293,293],"valid"],[[294,294],"mapped",[295]],[[295,295],"valid"],[[296,296],"mapped",[297]],[[297,297],"valid"],[[298,298],"mapped",[299]],[[299,299],"valid"],[[300,300],"mapped",[301]],[[301,301],"valid"],[[302,302],"mapped",[303]],[[303,303],"valid"],[[304,304],"mapped",[105,775]],[[305,305],"valid"],[[306,307],"mapped",[105,106]],[[308,308],"mapped",[309]],[[309,309],"valid"],[[310,310],"mapped",[311]],[[311,312],"valid"],[[313,313],"mapped",[314]],[[314,314],"valid"],[[315,315],"mapped",[316]],[[316,316],"valid"],[[317,317],"mapped",[318]],[[318,318],"valid"],[[319,320],"mapped",[108,183]],[[321,321],"mapped",[322]],[[322,322],"valid"],[[323,323],"mapped",[324]],[[324,324],"valid"],[[325,325],"mapped",[326]],[[326,326],"valid"],[[327,327],"mapped",[328]],[[328,328],"valid"],[[329,329],"mapped",[700,110]],[[330,330],"mapped",[331]],[[331,331],"valid"],[[332,332],"mapped",[333]],[[333,333],"valid"],[[334,334],"mapped",[335]],[[335,335],"valid"],[[336,336],"mapped",[337]],[[337,337],"valid"],[[338,338],"mapped",[339]],[[339,339],"valid"],[[340,340],"mapped",[341]],[[341,341],"valid"],[[342,342],"mapped",[343]],[[343,343],"valid"],[[344,344],"mapped",[345]],[[345,345],"valid"],[[346,346],"mapped",[347]],[[347,347],"valid"],[[348,348],"mapped",[349]],[[349,349],"valid"],[[350,350],"mapped",[351]],[[351,351],"valid"],[[352,352],"mapped",[353]],[[353,353],"valid"],[[354,354],"mapped",[355]],[[355,355],"valid"],[[356,356],"mapped",[357]],[[357,357],"valid"],[[358,358],"mapped",[359]],[[359,359],"valid"],[[360,360],"mapped",[361]],[[361,361],"valid"],[[362,362],"mapped",[363]],[[363,363],"valid"],[[364,364],"mapped",[365]],[[365,365],"valid"],[[366,366],"mapped",[367]],[[367,367],"valid"],[[368,368],"mapped",[369]],[[369,369],"valid"],[[370,370],"mapped",[371]],[[371,371],"valid"],[[372,372],"mapped",[373]],[[373,373],"valid"],[[374,374],"mapped",[375]],[[375,375],"valid"],[[376,376],"mapped",[255]],[[377,377],"mapped",[378]],[[378,378],"valid"],[[379,379],"mapped",[380]],[[380,380],"valid"],[[381,381],"mapped",[382]],[[382,382],"valid"],[[383,383],"mapped",[115]],[[384,384],"valid"],[[385,385],"mapped",[595]],[[386,386],"mapped",[387]],[[387,387],"valid"],[[388,388],"mapped",[389]],[[389,389],"valid"],[[390,390],"mapped",[596]],[[391,391],"mapped",[392]],[[392,392],"valid"],[[393,393],"mapped",[598]],[[394,394],"mapped",[599]],[[395,395],"mapped",[396]],[[396,397],"valid"],[[398,398],"mapped",[477]],[[399,399],"mapped",[601]],[[400,400],"mapped",[603]],[[401,401],"mapped",[402]],[[402,402],"valid"],[[403,403],"mapped",[608]],[[404,404],"mapped",[611]],[[405,405],"valid"],[[406,406],"mapped",[617]],[[407,407],"mapped",[616]],[[408,408],"mapped",[409]],[[409,411],"valid"],[[412,412],"mapped",[623]],[[413,413],"mapped",[626]],[[414,414],"valid"],[[415,415],"mapped",[629]],[[416,416],"mapped",[417]],[[417,417],"valid"],[[418,418],"mapped",[419]],[[419,419],"valid"],[[420,420],"mapped",[421]],[[421,421],"valid"],[[422,422],"mapped",[640]],[[423,423],"mapped",[424]],[[424,424],"valid"],[[425,425],"mapped",[643]],[[426,427],"valid"],[[428,428],"mapped",[429]],[[429,429],"valid"],[[430,430],"mapped",[648]],[[431,431],"mapped",[432]],[[432,432],"valid"],[[433,433],"mapped",[650]],[[434,434],"mapped",[651]],[[435,435],"mapped",[436]],[[436,436],"valid"],[[437,437],"mapped",[438]],[[438,438],"valid"],[[439,439],"mapped",[658]],[[440,440],"mapped",[441]],[[441,443],"valid"],[[444,444],"mapped",[445]],[[445,451],"valid"],[[452,454],"mapped",[100,382]],[[455,457],"mapped",[108,106]],[[458,460],"mapped",[110,106]],[[461,461],"mapped",[462]],[[462,462],"valid"],[[463,463],"mapped",[464]],[[464,464],"valid"],[[465,465],"mapped",[466]],[[466,466],"valid"],[[467,467],"mapped",[468]],[[468,468],"valid"],[[469,469],"mapped",[470]],[[470,470],"valid"],[[471,471],"mapped",[472]],[[472,472],"valid"],[[473,473],"mapped",[474]],[[474,474],"valid"],[[475,475],"mapped",[476]],[[476,477],"valid"],[[478,478],"mapped",[479]],[[479,479],"valid"],[[480,480],"mapped",[481]],[[481,481],"valid"],[[482,482],"mapped",[483]],[[483,483],"valid"],[[484,484],"mapped",[485]],[[485,485],"valid"],[[486,486],"mapped",[487]],[[487,487],"valid"],[[488,488],"mapped",[489]],[[489,489],"valid"],[[490,490],"mapped",[491]],[[491,491],"valid"],[[492,492],"mapped",[493]],[[493,493],"valid"],[[494,494],"mapped",[495]],[[495,496],"valid"],[[497,499],"mapped",[100,122]],[[500,500],"mapped",[501]],[[501,501],"valid"],[[502,502],"mapped",[405]],[[503,503],"mapped",[447]],[[504,504],"mapped",[505]],[[505,505],"valid"],[[506,506],"mapped",[507]],[[507,507],"valid"],[[508,508],"mapped",[509]],[[509,509],"valid"],[[510,510],"mapped",[511]],[[511,511],"valid"],[[512,512],"mapped",[513]],[[513,513],"valid"],[[514,514],"mapped",[515]],[[515,515],"valid"],[[516,516],"mapped",[517]],[[517,517],"valid"],[[518,518],"mapped",[519]],[[519,519],"valid"],[[520,520],"mapped",[521]],[[521,521],"valid"],[[522,522],"mapped",[523]],[[523,523],"valid"],[[524,524],"mapped",[525]],[[525,525],"valid"],[[526,526],"mapped",[527]],[[527,527],"valid"],[[528,528],"mapped",[529]],[[529,529],"valid"],[[530,530],"mapped",[531]],[[531,531],"valid"],[[532,532],"mapped",[533]],[[533,533],"valid"],[[534,534],"mapped",[535]],[[535,535],"valid"],[[536,536],"mapped",[537]],[[537,537],"valid"],[[538,538],"mapped",[539]],[[539,539],"valid"],[[540,540],"mapped",[541]],[[541,541],"valid"],[[542,542],"mapped",[543]],[[543,543],"valid"],[[544,544],"mapped",[414]],[[545,545],"valid"],[[546,546],"mapped",[547]],[[547,547],"valid"],[[548,548],"mapped",[549]],[[549,549],"valid"],[[550,550],"mapped",[551]],[[551,551],"valid"],[[552,552],"mapped",[553]],[[553,553],"valid"],[[554,554],"mapped",[555]],[[555,555],"valid"],[[556,556],"mapped",[557]],[[557,557],"valid"],[[558,558],"mapped",[559]],[[559,559],"valid"],[[560,560],"mapped",[561]],[[561,561],"valid"],[[562,562],"mapped",[563]],[[563,563],"valid"],[[564,566],"valid"],[[567,569],"valid"],[[570,570],"mapped",[11365]],[[571,571],"mapped",[572]],[[572,572],"valid"],[[573,573],"mapped",[410]],[[574,574],"mapped",[11366]],[[575,576],"valid"],[[577,577],"mapped",[578]],[[578,578],"valid"],[[579,579],"mapped",[384]],[[580,580],"mapped",[649]],[[581,581],"mapped",[652]],[[582,582],"mapped",[583]],[[583,583],"valid"],[[584,584],"mapped",[585]],[[585,585],"valid"],[[586,586],"mapped",[587]],[[587,587],"valid"],[[588,588],"mapped",[589]],[[589,589],"valid"],[[590,590],"mapped",[591]],[[591,591],"valid"],[[592,680],"valid"],[[681,685],"valid"],[[686,687],"valid"],[[688,688],"mapped",[104]],[[689,689],"mapped",[614]],[[690,690],"mapped",[106]],[[691,691],"mapped",[114]],[[692,692],"mapped",[633]],[[693,693],"mapped",[635]],[[694,694],"mapped",[641]],[[695,695],"mapped",[119]],[[696,696],"mapped",[121]],[[697,705],"valid"],[[706,709],"valid",[],"NV8"],[[710,721],"valid"],[[722,727],"valid",[],"NV8"],[[728,728],"disallowed_STD3_mapped",[32,774]],[[729,729],"disallowed_STD3_mapped",[32,775]],[[730,730],"disallowed_STD3_mapped",[32,778]],[[731,731],"disallowed_STD3_mapped",[32,808]],[[732,732],"disallowed_STD3_mapped",[32,771]],[[733,733],"disallowed_STD3_mapped",[32,779]],[[734,734],"valid",[],"NV8"],[[735,735],"valid",[],"NV8"],[[736,736],"mapped",[611]],[[737,737],"mapped",[108]],[[738,738],"mapped",[115]],[[739,739],"mapped",[120]],[[740,740],"mapped",[661]],[[741,745],"valid",[],"NV8"],[[746,747],"valid",[],"NV8"],[[748,748],"valid"],[[749,749],"valid",[],"NV8"],[[750,750],"valid"],[[751,767],"valid",[],"NV8"],[[768,831],"valid"],[[832,832],"mapped",[768]],[[833,833],"mapped",[769]],[[834,834],"valid"],[[835,835],"mapped",[787]],[[836,836],"mapped",[776,769]],[[837,837],"mapped",[953]],[[838,846],"valid"],[[847,847],"ignored"],[[848,855],"valid"],[[856,860],"valid"],[[861,863],"valid"],[[864,865],"valid"],[[866,866],"valid"],[[867,879],"valid"],[[880,880],"mapped",[881]],[[881,881],"valid"],[[882,882],"mapped",[883]],[[883,883],"valid"],[[884,884],"mapped",[697]],[[885,885],"valid"],[[886,886],"mapped",[887]],[[887,887],"valid"],[[888,889],"disallowed"],[[890,890],"disallowed_STD3_mapped",[32,953]],[[891,893],"valid"],[[894,894],"disallowed_STD3_mapped",[59]],[[895,895],"mapped",[1011]],[[896,899],"disallowed"],[[900,900],"disallowed_STD3_mapped",[32,769]],[[901,901],"disallowed_STD3_mapped",[32,776,769]],[[902,902],"mapped",[940]],[[903,903],"mapped",[183]],[[904,904],"mapped",[941]],[[905,905],"mapped",[942]],[[906,906],"mapped",[943]],[[907,907],"disallowed"],[[908,908],"mapped",[972]],[[909,909],"disallowed"],[[910,910],"mapped",[973]],[[911,911],"mapped",[974]],[[912,912],"valid"],[[913,913],"mapped",[945]],[[914,914],"mapped",[946]],[[915,915],"mapped",[947]],[[916,916],"mapped",[948]],[[917,917],"mapped",[949]],[[918,918],"mapped",[950]],[[919,919],"mapped",[951]],[[920,920],"mapped",[952]],[[921,921],"mapped",[953]],[[922,922],"mapped",[954]],[[923,923],"mapped",[955]],[[924,924],"mapped",[956]],[[925,925],"mapped",[957]],[[926,926],"mapped",[958]],[[927,927],"mapped",[959]],[[928,928],"mapped",[960]],[[929,929],"mapped",[961]],[[930,930],"disallowed"],[[931,931],"mapped",[963]],[[932,932],"mapped",[964]],[[933,933],"mapped",[965]],[[934,934],"mapped",[966]],[[935,935],"mapped",[967]],[[936,936],"mapped",[968]],[[937,937],"mapped",[969]],[[938,938],"mapped",[970]],[[939,939],"mapped",[971]],[[940,961],"valid"],[[962,962],"deviation",[963]],[[963,974],"valid"],[[975,975],"mapped",[983]],[[976,976],"mapped",[946]],[[977,977],"mapped",[952]],[[978,978],"mapped",[965]],[[979,979],"mapped",[973]],[[980,980],"mapped",[971]],[[981,981],"mapped",[966]],[[982,982],"mapped",[960]],[[983,983],"valid"],[[984,984],"mapped",[985]],[[985,985],"valid"],[[986,986],"mapped",[987]],[[987,987],"valid"],[[988,988],"mapped",[989]],[[989,989],"valid"],[[990,990],"mapped",[991]],[[991,991],"valid"],[[992,992],"mapped",[993]],[[993,993],"valid"],[[994,994],"mapped",[995]],[[995,995],"valid"],[[996,996],"mapped",[997]],[[997,997],"valid"],[[998,998],"mapped",[999]],[[999,999],"valid"],[[1000,1000],"mapped",[1001]],[[1001,1001],"valid"],[[1002,1002],"mapped",[1003]],[[1003,1003],"valid"],[[1004,1004],"mapped",[1005]],[[1005,1005],"valid"],[[1006,1006],"mapped",[1007]],[[1007,1007],"valid"],[[1008,1008],"mapped",[954]],[[1009,1009],"mapped",[961]],[[1010,1010],"mapped",[963]],[[1011,1011],"valid"],[[1012,1012],"mapped",[952]],[[1013,1013],"mapped",[949]],[[1014,1014],"valid",[],"NV8"],[[1015,1015],"mapped",[1016]],[[1016,1016],"valid"],[[1017,1017],"mapped",[963]],[[1018,1018],"mapped",[1019]],[[1019,1019],"valid"],[[1020,1020],"valid"],[[1021,1021],"mapped",[891]],[[1022,1022],"mapped",[892]],[[1023,1023],"mapped",[893]],[[1024,1024],"mapped",[1104]],[[1025,1025],"mapped",[1105]],[[1026,1026],"mapped",[1106]],[[1027,1027],"mapped",[1107]],[[1028,1028],"mapped",[1108]],[[1029,1029],"mapped",[1109]],[[1030,1030],"mapped",[1110]],[[1031,1031],"mapped",[1111]],[[1032,1032],"mapped",[1112]],[[1033,1033],"mapped",[1113]],[[1034,1034],"mapped",[1114]],[[1035,1035],"mapped",[1115]],[[1036,1036],"mapped",[1116]],[[1037,1037],"mapped",[1117]],[[1038,1038],"mapped",[1118]],[[1039,1039],"mapped",[1119]],[[1040,1040],"mapped",[1072]],[[1041,1041],"mapped",[1073]],[[1042,1042],"mapped",[1074]],[[1043,1043],"mapped",[1075]],[[1044,1044],"mapped",[1076]],[[1045,1045],"mapped",[1077]],[[1046,1046],"mapped",[1078]],[[1047,1047],"mapped",[1079]],[[1048,1048],"mapped",[1080]],[[1049,1049],"mapped",[1081]],[[1050,1050],"mapped",[1082]],[[1051,1051],"mapped",[1083]],[[1052,1052],"mapped",[1084]],[[1053,1053],"mapped",[1085]],[[1054,1054],"mapped",[1086]],[[1055,1055],"mapped",[1087]],[[1056,1056],"mapped",[1088]],[[1057,1057],"mapped",[1089]],[[1058,1058],"mapped",[1090]],[[1059,1059],"mapped",[1091]],[[1060,1060],"mapped",[1092]],[[1061,1061],"mapped",[1093]],[[1062,1062],"mapped",[1094]],[[1063,1063],"mapped",[1095]],[[1064,1064],"mapped",[1096]],[[1065,1065],"mapped",[1097]],[[1066,1066],"mapped",[1098]],[[1067,1067],"mapped",[1099]],[[1068,1068],"mapped",[1100]],[[1069,1069],"mapped",[1101]],[[1070,1070],"mapped",[1102]],[[1071,1071],"mapped",[1103]],[[1072,1103],"valid"],[[1104,1104],"valid"],[[1105,1116],"valid"],[[1117,1117],"valid"],[[1118,1119],"valid"],[[1120,1120],"mapped",[1121]],[[1121,1121],"valid"],[[1122,1122],"mapped",[1123]],[[1123,1123],"valid"],[[1124,1124],"mapped",[1125]],[[1125,1125],"valid"],[[1126,1126],"mapped",[1127]],[[1127,1127],"valid"],[[1128,1128],"mapped",[1129]],[[1129,1129],"valid"],[[1130,1130],"mapped",[1131]],[[1131,1131],"valid"],[[1132,1132],"mapped",[1133]],[[1133,1133],"valid"],[[1134,1134],"mapped",[1135]],[[1135,1135],"valid"],[[1136,1136],"mapped",[1137]],[[1137,1137],"valid"],[[1138,1138],"mapped",[1139]],[[1139,1139],"valid"],[[1140,1140],"mapped",[1141]],[[1141,1141],"valid"],[[1142,1142],"mapped",[1143]],[[1143,1143],"valid"],[[1144,1144],"mapped",[1145]],[[1145,1145],"valid"],[[1146,1146],"mapped",[1147]],[[1147,1147],"valid"],[[1148,1148],"mapped",[1149]],[[1149,1149],"valid"],[[1150,1150],"mapped",[1151]],[[1151,1151],"valid"],[[1152,1152],"mapped",[1153]],[[1153,1153],"valid"],[[1154,1154],"valid",[],"NV8"],[[1155,1158],"valid"],[[1159,1159],"valid"],[[1160,1161],"valid",[],"NV8"],[[1162,1162],"mapped",[1163]],[[1163,1163],"valid"],[[1164,1164],"mapped",[1165]],[[1165,1165],"valid"],[[1166,1166],"mapped",[1167]],[[1167,1167],"valid"],[[1168,1168],"mapped",[1169]],[[1169,1169],"valid"],[[1170,1170],"mapped",[1171]],[[1171,1171],"valid"],[[1172,1172],"mapped",[1173]],[[1173,1173],"valid"],[[1174,1174],"mapped",[1175]],[[1175,1175],"valid"],[[1176,1176],"mapped",[1177]],[[1177,1177],"valid"],[[1178,1178],"mapped",[1179]],[[1179,1179],"valid"],[[1180,1180],"mapped",[1181]],[[1181,1181],"valid"],[[1182,1182],"mapped",[1183]],[[1183,1183],"valid"],[[1184,1184],"mapped",[1185]],[[1185,1185],"valid"],[[1186,1186],"mapped",[1187]],[[1187,1187],"valid"],[[1188,1188],"mapped",[1189]],[[1189,1189],"valid"],[[1190,1190],"mapped",[1191]],[[1191,1191],"valid"],[[1192,1192],"mapped",[1193]],[[1193,1193],"valid"],[[1194,1194],"mapped",[1195]],[[1195,1195],"valid"],[[1196,1196],"mapped",[1197]],[[1197,1197],"valid"],[[1198,1198],"mapped",[1199]],[[1199,1199],"valid"],[[1200,1200],"mapped",[1201]],[[1201,1201],"valid"],[[1202,1202],"mapped",[1203]],[[1203,1203],"valid"],[[1204,1204],"mapped",[1205]],[[1205,1205],"valid"],[[1206,1206],"mapped",[1207]],[[1207,1207],"valid"],[[1208,1208],"mapped",[1209]],[[1209,1209],"valid"],[[1210,1210],"mapped",[1211]],[[1211,1211],"valid"],[[1212,1212],"mapped",[1213]],[[1213,1213],"valid"],[[1214,1214],"mapped",[1215]],[[1215,1215],"valid"],[[1216,1216],"disallowed"],[[1217,1217],"mapped",[1218]],[[1218,1218],"valid"],[[1219,1219],"mapped",[1220]],[[1220,1220],"valid"],[[1221,1221],"mapped",[1222]],[[1222,1222],"valid"],[[1223,1223],"mapped",[1224]],[[1224,1224],"valid"],[[1225,1225],"mapped",[1226]],[[1226,1226],"valid"],[[1227,1227],"mapped",[1228]],[[1228,1228],"valid"],[[1229,1229],"mapped",[1230]],[[1230,1230],"valid"],[[1231,1231],"valid"],[[1232,1232],"mapped",[1233]],[[1233,1233],"valid"],[[1234,1234],"mapped",[1235]],[[1235,1235],"valid"],[[1236,1236],"mapped",[1237]],[[1237,1237],"valid"],[[1238,1238],"mapped",[1239]],[[1239,1239],"valid"],[[1240,1240],"mapped",[1241]],[[1241,1241],"valid"],[[1242,1242],"mapped",[1243]],[[1243,1243],"valid"],[[1244,1244],"mapped",[1245]],[[1245,1245],"valid"],[[1246,1246],"mapped",[1247]],[[1247,1247],"valid"],[[1248,1248],"mapped",[1249]],[[1249,1249],"valid"],[[1250,1250],"mapped",[1251]],[[1251,1251],"valid"],[[1252,1252],"mapped",[1253]],[[1253,1253],"valid"],[[1254,1254],"mapped",[1255]],[[1255,1255],"valid"],[[1256,1256],"mapped",[1257]],[[1257,1257],"valid"],[[1258,1258],"mapped",[1259]],[[1259,1259],"valid"],[[1260,1260],"mapped",[1261]],[[1261,1261],"valid"],[[1262,1262],"mapped",[1263]],[[1263,1263],"valid"],[[1264,1264],"mapped",[1265]],[[1265,1265],"valid"],[[1266,1266],"mapped",[1267]],[[1267,1267],"valid"],[[1268,1268],"mapped",[1269]],[[1269,1269],"valid"],[[1270,1270],"mapped",[1271]],[[1271,1271],"valid"],[[1272,1272],"mapped",[1273]],[[1273,1273],"valid"],[[1274,1274],"mapped",[1275]],[[1275,1275],"valid"],[[1276,1276],"mapped",[1277]],[[1277,1277],"valid"],[[1278,1278],"mapped",[1279]],[[1279,1279],"valid"],[[1280,1280],"mapped",[1281]],[[1281,1281],"valid"],[[1282,1282],"mapped",[1283]],[[1283,1283],"valid"],[[1284,1284],"mapped",[1285]],[[1285,1285],"valid"],[[1286,1286],"mapped",[1287]],[[1287,1287],"valid"],[[1288,1288],"mapped",[1289]],[[1289,1289],"valid"],[[1290,1290],"mapped",[1291]],[[1291,1291],"valid"],[[1292,1292],"mapped",[1293]],[[1293,1293],"valid"],[[1294,1294],"mapped",[1295]],[[1295,1295],"valid"],[[1296,1296],"mapped",[1297]],[[1297,1297],"valid"],[[1298,1298],"mapped",[1299]],[[1299,1299],"valid"],[[1300,1300],"mapped",[1301]],[[1301,1301],"valid"],[[1302,1302],"mapped",[1303]],[[1303,1303],"valid"],[[1304,1304],"mapped",[1305]],[[1305,1305],"valid"],[[1306,1306],"mapped",[1307]],[[1307,1307],"valid"],[[1308,1308],"mapped",[1309]],[[1309,1309],"valid"],[[1310,1310],"mapped",[1311]],[[1311,1311],"valid"],[[1312,1312],"mapped",[1313]],[[1313,1313],"valid"],[[1314,1314],"mapped",[1315]],[[1315,1315],"valid"],[[1316,1316],"mapped",[1317]],[[1317,1317],"valid"],[[1318,1318],"mapped",[1319]],[[1319,1319],"valid"],[[1320,1320],"mapped",[1321]],[[1321,1321],"valid"],[[1322,1322],"mapped",[1323]],[[1323,1323],"valid"],[[1324,1324],"mapped",[1325]],[[1325,1325],"valid"],[[1326,1326],"mapped",[1327]],[[1327,1327],"valid"],[[1328,1328],"disallowed"],[[1329,1329],"mapped",[1377]],[[1330,1330],"mapped",[1378]],[[1331,1331],"mapped",[1379]],[[1332,1332],"mapped",[1380]],[[1333,1333],"mapped",[1381]],[[1334,1334],"mapped",[1382]],[[1335,1335],"mapped",[1383]],[[1336,1336],"mapped",[1384]],[[1337,1337],"mapped",[1385]],[[1338,1338],"mapped",[1386]],[[1339,1339],"mapped",[1387]],[[1340,1340],"mapped",[1388]],[[1341,1341],"mapped",[1389]],[[1342,1342],"mapped",[1390]],[[1343,1343],"mapped",[1391]],[[1344,1344],"mapped",[1392]],[[1345,1345],"mapped",[1393]],[[1346,1346],"mapped",[1394]],[[1347,1347],"mapped",[1395]],[[1348,1348],"mapped",[1396]],[[1349,1349],"mapped",[1397]],[[1350,1350],"mapped",[1398]],[[1351,1351],"mapped",[1399]],[[1352,1352],"mapped",[1400]],[[1353,1353],"mapped",[1401]],[[1354,1354],"mapped",[1402]],[[1355,1355],"mapped",[1403]],[[1356,1356],"mapped",[1404]],[[1357,1357],"mapped",[1405]],[[1358,1358],"mapped",[1406]],[[1359,1359],"mapped",[1407]],[[1360,1360],"mapped",[1408]],[[1361,1361],"mapped",[1409]],[[1362,1362],"mapped",[1410]],[[1363,1363],"mapped",[1411]],[[1364,1364],"mapped",[1412]],[[1365,1365],"mapped",[1413]],[[1366,1366],"mapped",[1414]],[[1367,1368],"disallowed"],[[1369,1369],"valid"],[[1370,1375],"valid",[],"NV8"],[[1376,1376],"disallowed"],[[1377,1414],"valid"],[[1415,1415],"mapped",[1381,1410]],[[1416,1416],"disallowed"],[[1417,1417],"valid",[],"NV8"],[[1418,1418],"valid",[],"NV8"],[[1419,1420],"disallowed"],[[1421,1422],"valid",[],"NV8"],[[1423,1423],"valid",[],"NV8"],[[1424,1424],"disallowed"],[[1425,1441],"valid"],[[1442,1442],"valid"],[[1443,1455],"valid"],[[1456,1465],"valid"],[[1466,1466],"valid"],[[1467,1469],"valid"],[[1470,1470],"valid",[],"NV8"],[[1471,1471],"valid"],[[1472,1472],"valid",[],"NV8"],[[1473,1474],"valid"],[[1475,1475],"valid",[],"NV8"],[[1476,1476],"valid"],[[1477,1477],"valid"],[[1478,1478],"valid",[],"NV8"],[[1479,1479],"valid"],[[1480,1487],"disallowed"],[[1488,1514],"valid"],[[1515,1519],"disallowed"],[[1520,1524],"valid"],[[1525,1535],"disallowed"],[[1536,1539],"disallowed"],[[1540,1540],"disallowed"],[[1541,1541],"disallowed"],[[1542,1546],"valid",[],"NV8"],[[1547,1547],"valid",[],"NV8"],[[1548,1548],"valid",[],"NV8"],[[1549,1551],"valid",[],"NV8"],[[1552,1557],"valid"],[[1558,1562],"valid"],[[1563,1563],"valid",[],"NV8"],[[1564,1564],"disallowed"],[[1565,1565],"disallowed"],[[1566,1566],"valid",[],"NV8"],[[1567,1567],"valid",[],"NV8"],[[1568,1568],"valid"],[[1569,1594],"valid"],[[1595,1599],"valid"],[[1600,1600],"valid",[],"NV8"],[[1601,1618],"valid"],[[1619,1621],"valid"],[[1622,1624],"valid"],[[1625,1630],"valid"],[[1631,1631],"valid"],[[1632,1641],"valid"],[[1642,1645],"valid",[],"NV8"],[[1646,1647],"valid"],[[1648,1652],"valid"],[[1653,1653],"mapped",[1575,1652]],[[1654,1654],"mapped",[1608,1652]],[[1655,1655],"mapped",[1735,1652]],[[1656,1656],"mapped",[1610,1652]],[[1657,1719],"valid"],[[1720,1721],"valid"],[[1722,1726],"valid"],[[1727,1727],"valid"],[[1728,1742],"valid"],[[1743,1743],"valid"],[[1744,1747],"valid"],[[1748,1748],"valid",[],"NV8"],[[1749,1756],"valid"],[[1757,1757],"disallowed"],[[1758,1758],"valid",[],"NV8"],[[1759,1768],"valid"],[[1769,1769],"valid",[],"NV8"],[[1770,1773],"valid"],[[1774,1775],"valid"],[[1776,1785],"valid"],[[1786,1790],"valid"],[[1791,1791],"valid"],[[1792,1805],"valid",[],"NV8"],[[1806,1806],"disallowed"],[[1807,1807],"disallowed"],[[1808,1836],"valid"],[[1837,1839],"valid"],[[1840,1866],"valid"],[[1867,1868],"disallowed"],[[1869,1871],"valid"],[[1872,1901],"valid"],[[1902,1919],"valid"],[[1920,1968],"valid"],[[1969,1969],"valid"],[[1970,1983],"disallowed"],[[1984,2037],"valid"],[[2038,2042],"valid",[],"NV8"],[[2043,2047],"disallowed"],[[2048,2093],"valid"],[[2094,2095],"disallowed"],[[2096,2110],"valid",[],"NV8"],[[2111,2111],"disallowed"],[[2112,2139],"valid"],[[2140,2141],"disallowed"],[[2142,2142],"valid",[],"NV8"],[[2143,2207],"disallowed"],[[2208,2208],"valid"],[[2209,2209],"valid"],[[2210,2220],"valid"],[[2221,2226],"valid"],[[2227,2228],"valid"],[[2229,2274],"disallowed"],[[2275,2275],"valid"],[[2276,2302],"valid"],[[2303,2303],"valid"],[[2304,2304],"valid"],[[2305,2307],"valid"],[[2308,2308],"valid"],[[2309,2361],"valid"],[[2362,2363],"valid"],[[2364,2381],"valid"],[[2382,2382],"valid"],[[2383,2383],"valid"],[[2384,2388],"valid"],[[2389,2389],"valid"],[[2390,2391],"valid"],[[2392,2392],"mapped",[2325,2364]],[[2393,2393],"mapped",[2326,2364]],[[2394,2394],"mapped",[2327,2364]],[[2395,2395],"mapped",[2332,2364]],[[2396,2396],"mapped",[2337,2364]],[[2397,2397],"mapped",[2338,2364]],[[2398,2398],"mapped",[2347,2364]],[[2399,2399],"mapped",[2351,2364]],[[2400,2403],"valid"],[[2404,2405],"valid",[],"NV8"],[[2406,2415],"valid"],[[2416,2416],"valid",[],"NV8"],[[2417,2418],"valid"],[[2419,2423],"valid"],[[2424,2424],"valid"],[[2425,2426],"valid"],[[2427,2428],"valid"],[[2429,2429],"valid"],[[2430,2431],"valid"],[[2432,2432],"valid"],[[2433,2435],"valid"],[[2436,2436],"disallowed"],[[2437,2444],"valid"],[[2445,2446],"disallowed"],[[2447,2448],"valid"],[[2449,2450],"disallowed"],[[2451,2472],"valid"],[[2473,2473],"disallowed"],[[2474,2480],"valid"],[[2481,2481],"disallowed"],[[2482,2482],"valid"],[[2483,2485],"disallowed"],[[2486,2489],"valid"],[[2490,2491],"disallowed"],[[2492,2492],"valid"],[[2493,2493],"valid"],[[2494,2500],"valid"],[[2501,2502],"disallowed"],[[2503,2504],"valid"],[[2505,2506],"disallowed"],[[2507,2509],"valid"],[[2510,2510],"valid"],[[2511,2518],"disallowed"],[[2519,2519],"valid"],[[2520,2523],"disallowed"],[[2524,2524],"mapped",[2465,2492]],[[2525,2525],"mapped",[2466,2492]],[[2526,2526],"disallowed"],[[2527,2527],"mapped",[2479,2492]],[[2528,2531],"valid"],[[2532,2533],"disallowed"],[[2534,2545],"valid"],[[2546,2554],"valid",[],"NV8"],[[2555,2555],"valid",[],"NV8"],[[2556,2560],"disallowed"],[[2561,2561],"valid"],[[2562,2562],"valid"],[[2563,2563],"valid"],[[2564,2564],"disallowed"],[[2565,2570],"valid"],[[2571,2574],"disallowed"],[[2575,2576],"valid"],[[2577,2578],"disallowed"],[[2579,2600],"valid"],[[2601,2601],"disallowed"],[[2602,2608],"valid"],[[2609,2609],"disallowed"],[[2610,2610],"valid"],[[2611,2611],"mapped",[2610,2620]],[[2612,2612],"disallowed"],[[2613,2613],"valid"],[[2614,2614],"mapped",[2616,2620]],[[2615,2615],"disallowed"],[[2616,2617],"valid"],[[2618,2619],"disallowed"],[[2620,2620],"valid"],[[2621,2621],"disallowed"],[[2622,2626],"valid"],[[2627,2630],"disallowed"],[[2631,2632],"valid"],[[2633,2634],"disallowed"],[[2635,2637],"valid"],[[2638,2640],"disallowed"],[[2641,2641],"valid"],[[2642,2648],"disallowed"],[[2649,2649],"mapped",[2582,2620]],[[2650,2650],"mapped",[2583,2620]],[[2651,2651],"mapped",[2588,2620]],[[2652,2652],"valid"],[[2653,2653],"disallowed"],[[2654,2654],"mapped",[2603,2620]],[[2655,2661],"disallowed"],[[2662,2676],"valid"],[[2677,2677],"valid"],[[2678,2688],"disallowed"],[[2689,2691],"valid"],[[2692,2692],"disallowed"],[[2693,2699],"valid"],[[2700,2700],"valid"],[[2701,2701],"valid"],[[2702,2702],"disallowed"],[[2703,2705],"valid"],[[2706,2706],"disallowed"],[[2707,2728],"valid"],[[2729,2729],"disallowed"],[[2730,2736],"valid"],[[2737,2737],"disallowed"],[[2738,2739],"valid"],[[2740,2740],"disallowed"],[[2741,2745],"valid"],[[2746,2747],"disallowed"],[[2748,2757],"valid"],[[2758,2758],"disallowed"],[[2759,2761],"valid"],[[2762,2762],"disallowed"],[[2763,2765],"valid"],[[2766,2767],"disallowed"],[[2768,2768],"valid"],[[2769,2783],"disallowed"],[[2784,2784],"valid"],[[2785,2787],"valid"],[[2788,2789],"disallowed"],[[2790,2799],"valid"],[[2800,2800],"valid",[],"NV8"],[[2801,2801],"valid",[],"NV8"],[[2802,2808],"disallowed"],[[2809,2809],"valid"],[[2810,2816],"disallowed"],[[2817,2819],"valid"],[[2820,2820],"disallowed"],[[2821,2828],"valid"],[[2829,2830],"disallowed"],[[2831,2832],"valid"],[[2833,2834],"disallowed"],[[2835,2856],"valid"],[[2857,2857],"disallowed"],[[2858,2864],"valid"],[[2865,2865],"disallowed"],[[2866,2867],"valid"],[[2868,2868],"disallowed"],[[2869,2869],"valid"],[[2870,2873],"valid"],[[2874,2875],"disallowed"],[[2876,2883],"valid"],[[2884,2884],"valid"],[[2885,2886],"disallowed"],[[2887,2888],"valid"],[[2889,2890],"disallowed"],[[2891,2893],"valid"],[[2894,2901],"disallowed"],[[2902,2903],"valid"],[[2904,2907],"disallowed"],[[2908,2908],"mapped",[2849,2876]],[[2909,2909],"mapped",[2850,2876]],[[2910,2910],"disallowed"],[[2911,2913],"valid"],[[2914,2915],"valid"],[[2916,2917],"disallowed"],[[2918,2927],"valid"],[[2928,2928],"valid",[],"NV8"],[[2929,2929],"valid"],[[2930,2935],"valid",[],"NV8"],[[2936,2945],"disallowed"],[[2946,2947],"valid"],[[2948,2948],"disallowed"],[[2949,2954],"valid"],[[2955,2957],"disallowed"],[[2958,2960],"valid"],[[2961,2961],"disallowed"],[[2962,2965],"valid"],[[2966,2968],"disallowed"],[[2969,2970],"valid"],[[2971,2971],"disallowed"],[[2972,2972],"valid"],[[2973,2973],"disallowed"],[[2974,2975],"valid"],[[2976,2978],"disallowed"],[[2979,2980],"valid"],[[2981,2983],"disallowed"],[[2984,2986],"valid"],[[2987,2989],"disallowed"],[[2990,2997],"valid"],[[2998,2998],"valid"],[[2999,3001],"valid"],[[3002,3005],"disallowed"],[[3006,3010],"valid"],[[3011,3013],"disallowed"],[[3014,3016],"valid"],[[3017,3017],"disallowed"],[[3018,3021],"valid"],[[3022,3023],"disallowed"],[[3024,3024],"valid"],[[3025,3030],"disallowed"],[[3031,3031],"valid"],[[3032,3045],"disallowed"],[[3046,3046],"valid"],[[3047,3055],"valid"],[[3056,3058],"valid",[],"NV8"],[[3059,3066],"valid",[],"NV8"],[[3067,3071],"disallowed"],[[3072,3072],"valid"],[[3073,3075],"valid"],[[3076,3076],"disallowed"],[[3077,3084],"valid"],[[3085,3085],"disallowed"],[[3086,3088],"valid"],[[3089,3089],"disallowed"],[[3090,3112],"valid"],[[3113,3113],"disallowed"],[[3114,3123],"valid"],[[3124,3124],"valid"],[[3125,3129],"valid"],[[3130,3132],"disallowed"],[[3133,3133],"valid"],[[3134,3140],"valid"],[[3141,3141],"disallowed"],[[3142,3144],"valid"],[[3145,3145],"disallowed"],[[3146,3149],"valid"],[[3150,3156],"disallowed"],[[3157,3158],"valid"],[[3159,3159],"disallowed"],[[3160,3161],"valid"],[[3162,3162],"valid"],[[3163,3167],"disallowed"],[[3168,3169],"valid"],[[3170,3171],"valid"],[[3172,3173],"disallowed"],[[3174,3183],"valid"],[[3184,3191],"disallowed"],[[3192,3199],"valid",[],"NV8"],[[3200,3200],"disallowed"],[[3201,3201],"valid"],[[3202,3203],"valid"],[[3204,3204],"disallowed"],[[3205,3212],"valid"],[[3213,3213],"disallowed"],[[3214,3216],"valid"],[[3217,3217],"disallowed"],[[3218,3240],"valid"],[[3241,3241],"disallowed"],[[3242,3251],"valid"],[[3252,3252],"disallowed"],[[3253,3257],"valid"],[[3258,3259],"disallowed"],[[3260,3261],"valid"],[[3262,3268],"valid"],[[3269,3269],"disallowed"],[[3270,3272],"valid"],[[3273,3273],"disallowed"],[[3274,3277],"valid"],[[3278,3284],"disallowed"],[[3285,3286],"valid"],[[3287,3293],"disallowed"],[[3294,3294],"valid"],[[3295,3295],"disallowed"],[[3296,3297],"valid"],[[3298,3299],"valid"],[[3300,3301],"disallowed"],[[3302,3311],"valid"],[[3312,3312],"disallowed"],[[3313,3314],"valid"],[[3315,3328],"disallowed"],[[3329,3329],"valid"],[[3330,3331],"valid"],[[3332,3332],"disallowed"],[[3333,3340],"valid"],[[3341,3341],"disallowed"],[[3342,3344],"valid"],[[3345,3345],"disallowed"],[[3346,3368],"valid"],[[3369,3369],"valid"],[[3370,3385],"valid"],[[3386,3386],"valid"],[[3387,3388],"disallowed"],[[3389,3389],"valid"],[[3390,3395],"valid"],[[3396,3396],"valid"],[[3397,3397],"disallowed"],[[3398,3400],"valid"],[[3401,3401],"disallowed"],[[3402,3405],"valid"],[[3406,3406],"valid"],[[3407,3414],"disallowed"],[[3415,3415],"valid"],[[3416,3422],"disallowed"],[[3423,3423],"valid"],[[3424,3425],"valid"],[[3426,3427],"valid"],[[3428,3429],"disallowed"],[[3430,3439],"valid"],[[3440,3445],"valid",[],"NV8"],[[3446,3448],"disallowed"],[[3449,3449],"valid",[],"NV8"],[[3450,3455],"valid"],[[3456,3457],"disallowed"],[[3458,3459],"valid"],[[3460,3460],"disallowed"],[[3461,3478],"valid"],[[3479,3481],"disallowed"],[[3482,3505],"valid"],[[3506,3506],"disallowed"],[[3507,3515],"valid"],[[3516,3516],"disallowed"],[[3517,3517],"valid"],[[3518,3519],"disallowed"],[[3520,3526],"valid"],[[3527,3529],"disallowed"],[[3530,3530],"valid"],[[3531,3534],"disallowed"],[[3535,3540],"valid"],[[3541,3541],"disallowed"],[[3542,3542],"valid"],[[3543,3543],"disallowed"],[[3544,3551],"valid"],[[3552,3557],"disallowed"],[[3558,3567],"valid"],[[3568,3569],"disallowed"],[[3570,3571],"valid"],[[3572,3572],"valid",[],"NV8"],[[3573,3584],"disallowed"],[[3585,3634],"valid"],[[3635,3635],"mapped",[3661,3634]],[[3636,3642],"valid"],[[3643,3646],"disallowed"],[[3647,3647],"valid",[],"NV8"],[[3648,3662],"valid"],[[3663,3663],"valid",[],"NV8"],[[3664,3673],"valid"],[[3674,3675],"valid",[],"NV8"],[[3676,3712],"disallowed"],[[3713,3714],"valid"],[[3715,3715],"disallowed"],[[3716,3716],"valid"],[[3717,3718],"disallowed"],[[3719,3720],"valid"],[[3721,3721],"disallowed"],[[3722,3722],"valid"],[[3723,3724],"disallowed"],[[3725,3725],"valid"],[[3726,3731],"disallowed"],[[3732,3735],"valid"],[[3736,3736],"disallowed"],[[3737,3743],"valid"],[[3744,3744],"disallowed"],[[3745,3747],"valid"],[[3748,3748],"disallowed"],[[3749,3749],"valid"],[[3750,3750],"disallowed"],[[3751,3751],"valid"],[[3752,3753],"disallowed"],[[3754,3755],"valid"],[[3756,3756],"disallowed"],[[3757,3762],"valid"],[[3763,3763],"mapped",[3789,3762]],[[3764,3769],"valid"],[[3770,3770],"disallowed"],[[3771,3773],"valid"],[[3774,3775],"disallowed"],[[3776,3780],"valid"],[[3781,3781],"disallowed"],[[3782,3782],"valid"],[[3783,3783],"disallowed"],[[3784,3789],"valid"],[[3790,3791],"disallowed"],[[3792,3801],"valid"],[[3802,3803],"disallowed"],[[3804,3804],"mapped",[3755,3737]],[[3805,3805],"mapped",[3755,3745]],[[3806,3807],"valid"],[[3808,3839],"disallowed"],[[3840,3840],"valid"],[[3841,3850],"valid",[],"NV8"],[[3851,3851],"valid"],[[3852,3852],"mapped",[3851]],[[3853,3863],"valid",[],"NV8"],[[3864,3865],"valid"],[[3866,3871],"valid",[],"NV8"],[[3872,3881],"valid"],[[3882,3892],"valid",[],"NV8"],[[3893,3893],"valid"],[[3894,3894],"valid",[],"NV8"],[[3895,3895],"valid"],[[3896,3896],"valid",[],"NV8"],[[3897,3897],"valid"],[[3898,3901],"valid",[],"NV8"],[[3902,3906],"valid"],[[3907,3907],"mapped",[3906,4023]],[[3908,3911],"valid"],[[3912,3912],"disallowed"],[[3913,3916],"valid"],[[3917,3917],"mapped",[3916,4023]],[[3918,3921],"valid"],[[3922,3922],"mapped",[3921,4023]],[[3923,3926],"valid"],[[3927,3927],"mapped",[3926,4023]],[[3928,3931],"valid"],[[3932,3932],"mapped",[3931,4023]],[[3933,3944],"valid"],[[3945,3945],"mapped",[3904,4021]],[[3946,3946],"valid"],[[3947,3948],"valid"],[[3949,3952],"disallowed"],[[3953,3954],"valid"],[[3955,3955],"mapped",[3953,3954]],[[3956,3956],"valid"],[[3957,3957],"mapped",[3953,3956]],[[3958,3958],"mapped",[4018,3968]],[[3959,3959],"mapped",[4018,3953,3968]],[[3960,3960],"mapped",[4019,3968]],[[3961,3961],"mapped",[4019,3953,3968]],[[3962,3968],"valid"],[[3969,3969],"mapped",[3953,3968]],[[3970,3972],"valid"],[[3973,3973],"valid",[],"NV8"],[[3974,3979],"valid"],[[3980,3983],"valid"],[[3984,3986],"valid"],[[3987,3987],"mapped",[3986,4023]],[[3988,3989],"valid"],[[3990,3990],"valid"],[[3991,3991],"valid"],[[3992,3992],"disallowed"],[[3993,3996],"valid"],[[3997,3997],"mapped",[3996,4023]],[[3998,4001],"valid"],[[4002,4002],"mapped",[4001,4023]],[[4003,4006],"valid"],[[4007,4007],"mapped",[4006,4023]],[[4008,4011],"valid"],[[4012,4012],"mapped",[4011,4023]],[[4013,4013],"valid"],[[4014,4016],"valid"],[[4017,4023],"valid"],[[4024,4024],"valid"],[[4025,4025],"mapped",[3984,4021]],[[4026,4028],"valid"],[[4029,4029],"disallowed"],[[4030,4037],"valid",[],"NV8"],[[4038,4038],"valid"],[[4039,4044],"valid",[],"NV8"],[[4045,4045],"disallowed"],[[4046,4046],"valid",[],"NV8"],[[4047,4047],"valid",[],"NV8"],[[4048,4049],"valid",[],"NV8"],[[4050,4052],"valid",[],"NV8"],[[4053,4056],"valid",[],"NV8"],[[4057,4058],"valid",[],"NV8"],[[4059,4095],"disallowed"],[[4096,4129],"valid"],[[4130,4130],"valid"],[[4131,4135],"valid"],[[4136,4136],"valid"],[[4137,4138],"valid"],[[4139,4139],"valid"],[[4140,4146],"valid"],[[4147,4149],"valid"],[[4150,4153],"valid"],[[4154,4159],"valid"],[[4160,4169],"valid"],[[4170,4175],"valid",[],"NV8"],[[4176,4185],"valid"],[[4186,4249],"valid"],[[4250,4253],"valid"],[[4254,4255],"valid",[],"NV8"],[[4256,4293],"disallowed"],[[4294,4294],"disallowed"],[[4295,4295],"mapped",[11559]],[[4296,4300],"disallowed"],[[4301,4301],"mapped",[11565]],[[4302,4303],"disallowed"],[[4304,4342],"valid"],[[4343,4344],"valid"],[[4345,4346],"valid"],[[4347,4347],"valid",[],"NV8"],[[4348,4348],"mapped",[4316]],[[4349,4351],"valid"],[[4352,4441],"valid",[],"NV8"],[[4442,4446],"valid",[],"NV8"],[[4447,4448],"disallowed"],[[4449,4514],"valid",[],"NV8"],[[4515,4519],"valid",[],"NV8"],[[4520,4601],"valid",[],"NV8"],[[4602,4607],"valid",[],"NV8"],[[4608,4614],"valid"],[[4615,4615],"valid"],[[4616,4678],"valid"],[[4679,4679],"valid"],[[4680,4680],"valid"],[[4681,4681],"disallowed"],[[4682,4685],"valid"],[[4686,4687],"disallowed"],[[4688,4694],"valid"],[[4695,4695],"disallowed"],[[4696,4696],"valid"],[[4697,4697],"disallowed"],[[4698,4701],"valid"],[[4702,4703],"disallowed"],[[4704,4742],"valid"],[[4743,4743],"valid"],[[4744,4744],"valid"],[[4745,4745],"disallowed"],[[4746,4749],"valid"],[[4750,4751],"disallowed"],[[4752,4782],"valid"],[[4783,4783],"valid"],[[4784,4784],"valid"],[[4785,4785],"disallowed"],[[4786,4789],"valid"],[[4790,4791],"disallowed"],[[4792,4798],"valid"],[[4799,4799],"disallowed"],[[4800,4800],"valid"],[[4801,4801],"disallowed"],[[4802,4805],"valid"],[[4806,4807],"disallowed"],[[4808,4814],"valid"],[[4815,4815],"valid"],[[4816,4822],"valid"],[[4823,4823],"disallowed"],[[4824,4846],"valid"],[[4847,4847],"valid"],[[4848,4878],"valid"],[[4879,4879],"valid"],[[4880,4880],"valid"],[[4881,4881],"disallowed"],[[4882,4885],"valid"],[[4886,4887],"disallowed"],[[4888,4894],"valid"],[[4895,4895],"valid"],[[4896,4934],"valid"],[[4935,4935],"valid"],[[4936,4954],"valid"],[[4955,4956],"disallowed"],[[4957,4958],"valid"],[[4959,4959],"valid"],[[4960,4960],"valid",[],"NV8"],[[4961,4988],"valid",[],"NV8"],[[4989,4991],"disallowed"],[[4992,5007],"valid"],[[5008,5017],"valid",[],"NV8"],[[5018,5023],"disallowed"],[[5024,5108],"valid"],[[5109,5109],"valid"],[[5110,5111],"disallowed"],[[5112,5112],"mapped",[5104]],[[5113,5113],"mapped",[5105]],[[5114,5114],"mapped",[5106]],[[5115,5115],"mapped",[5107]],[[5116,5116],"mapped",[5108]],[[5117,5117],"mapped",[5109]],[[5118,5119],"disallowed"],[[5120,5120],"valid",[],"NV8"],[[5121,5740],"valid"],[[5741,5742],"valid",[],"NV8"],[[5743,5750],"valid"],[[5751,5759],"valid"],[[5760,5760],"disallowed"],[[5761,5786],"valid"],[[5787,5788],"valid",[],"NV8"],[[5789,5791],"disallowed"],[[5792,5866],"valid"],[[5867,5872],"valid",[],"NV8"],[[5873,5880],"valid"],[[5881,5887],"disallowed"],[[5888,5900],"valid"],[[5901,5901],"disallowed"],[[5902,5908],"valid"],[[5909,5919],"disallowed"],[[5920,5940],"valid"],[[5941,5942],"valid",[],"NV8"],[[5943,5951],"disallowed"],[[5952,5971],"valid"],[[5972,5983],"disallowed"],[[5984,5996],"valid"],[[5997,5997],"disallowed"],[[5998,6000],"valid"],[[6001,6001],"disallowed"],[[6002,6003],"valid"],[[6004,6015],"disallowed"],[[6016,6067],"valid"],[[6068,6069],"disallowed"],[[6070,6099],"valid"],[[6100,6102],"valid",[],"NV8"],[[6103,6103],"valid"],[[6104,6107],"valid",[],"NV8"],[[6108,6108],"valid"],[[6109,6109],"valid"],[[6110,6111],"disallowed"],[[6112,6121],"valid"],[[6122,6127],"disallowed"],[[6128,6137],"valid",[],"NV8"],[[6138,6143],"disallowed"],[[6144,6149],"valid",[],"NV8"],[[6150,6150],"disallowed"],[[6151,6154],"valid",[],"NV8"],[[6155,6157],"ignored"],[[6158,6158],"disallowed"],[[6159,6159],"disallowed"],[[6160,6169],"valid"],[[6170,6175],"disallowed"],[[6176,6263],"valid"],[[6264,6271],"disallowed"],[[6272,6313],"valid"],[[6314,6314],"valid"],[[6315,6319],"disallowed"],[[6320,6389],"valid"],[[6390,6399],"disallowed"],[[6400,6428],"valid"],[[6429,6430],"valid"],[[6431,6431],"disallowed"],[[6432,6443],"valid"],[[6444,6447],"disallowed"],[[6448,6459],"valid"],[[6460,6463],"disallowed"],[[6464,6464],"valid",[],"NV8"],[[6465,6467],"disallowed"],[[6468,6469],"valid",[],"NV8"],[[6470,6509],"valid"],[[6510,6511],"disallowed"],[[6512,6516],"valid"],[[6517,6527],"disallowed"],[[6528,6569],"valid"],[[6570,6571],"valid"],[[6572,6575],"disallowed"],[[6576,6601],"valid"],[[6602,6607],"disallowed"],[[6608,6617],"valid"],[[6618,6618],"valid",[],"XV8"],[[6619,6621],"disallowed"],[[6622,6623],"valid",[],"NV8"],[[6624,6655],"valid",[],"NV8"],[[6656,6683],"valid"],[[6684,6685],"disallowed"],[[6686,6687],"valid",[],"NV8"],[[6688,6750],"valid"],[[6751,6751],"disallowed"],[[6752,6780],"valid"],[[6781,6782],"disallowed"],[[6783,6793],"valid"],[[6794,6799],"disallowed"],[[6800,6809],"valid"],[[6810,6815],"disallowed"],[[6816,6822],"valid",[],"NV8"],[[6823,6823],"valid"],[[6824,6829],"valid",[],"NV8"],[[6830,6831],"disallowed"],[[6832,6845],"valid"],[[6846,6846],"valid",[],"NV8"],[[6847,6911],"disallowed"],[[6912,6987],"valid"],[[6988,6991],"disallowed"],[[6992,7001],"valid"],[[7002,7018],"valid",[],"NV8"],[[7019,7027],"valid"],[[7028,7036],"valid",[],"NV8"],[[7037,7039],"disallowed"],[[7040,7082],"valid"],[[7083,7085],"valid"],[[7086,7097],"valid"],[[7098,7103],"valid"],[[7104,7155],"valid"],[[7156,7163],"disallowed"],[[7164,7167],"valid",[],"NV8"],[[7168,7223],"valid"],[[7224,7226],"disallowed"],[[7227,7231],"valid",[],"NV8"],[[7232,7241],"valid"],[[7242,7244],"disallowed"],[[7245,7293],"valid"],[[7294,7295],"valid",[],"NV8"],[[7296,7359],"disallowed"],[[7360,7367],"valid",[],"NV8"],[[7368,7375],"disallowed"],[[7376,7378],"valid"],[[7379,7379],"valid",[],"NV8"],[[7380,7410],"valid"],[[7411,7414],"valid"],[[7415,7415],"disallowed"],[[7416,7417],"valid"],[[7418,7423],"disallowed"],[[7424,7467],"valid"],[[7468,7468],"mapped",[97]],[[7469,7469],"mapped",[230]],[[7470,7470],"mapped",[98]],[[7471,7471],"valid"],[[7472,7472],"mapped",[100]],[[7473,7473],"mapped",[101]],[[7474,7474],"mapped",[477]],[[7475,7475],"mapped",[103]],[[7476,7476],"mapped",[104]],[[7477,7477],"mapped",[105]],[[7478,7478],"mapped",[106]],[[7479,7479],"mapped",[107]],[[7480,7480],"mapped",[108]],[[7481,7481],"mapped",[109]],[[7482,7482],"mapped",[110]],[[7483,7483],"valid"],[[7484,7484],"mapped",[111]],[[7485,7485],"mapped",[547]],[[7486,7486],"mapped",[112]],[[7487,7487],"mapped",[114]],[[7488,7488],"mapped",[116]],[[7489,7489],"mapped",[117]],[[7490,7490],"mapped",[119]],[[7491,7491],"mapped",[97]],[[7492,7492],"mapped",[592]],[[7493,7493],"mapped",[593]],[[7494,7494],"mapped",[7426]],[[7495,7495],"mapped",[98]],[[7496,7496],"mapped",[100]],[[7497,7497],"mapped",[101]],[[7498,7498],"mapped",[601]],[[7499,7499],"mapped",[603]],[[7500,7500],"mapped",[604]],[[7501,7501],"mapped",[103]],[[7502,7502],"valid"],[[7503,7503],"mapped",[107]],[[7504,7504],"mapped",[109]],[[7505,7505],"mapped",[331]],[[7506,7506],"mapped",[111]],[[7507,7507],"mapped",[596]],[[7508,7508],"mapped",[7446]],[[7509,7509],"mapped",[7447]],[[7510,7510],"mapped",[112]],[[7511,7511],"mapped",[116]],[[7512,7512],"mapped",[117]],[[7513,7513],"mapped",[7453]],[[7514,7514],"mapped",[623]],[[7515,7515],"mapped",[118]],[[7516,7516],"mapped",[7461]],[[7517,7517],"mapped",[946]],[[7518,7518],"mapped",[947]],[[7519,7519],"mapped",[948]],[[7520,7520],"mapped",[966]],[[7521,7521],"mapped",[967]],[[7522,7522],"mapped",[105]],[[7523,7523],"mapped",[114]],[[7524,7524],"mapped",[117]],[[7525,7525],"mapped",[118]],[[7526,7526],"mapped",[946]],[[7527,7527],"mapped",[947]],[[7528,7528],"mapped",[961]],[[7529,7529],"mapped",[966]],[[7530,7530],"mapped",[967]],[[7531,7531],"valid"],[[7532,7543],"valid"],[[7544,7544],"mapped",[1085]],[[7545,7578],"valid"],[[7579,7579],"mapped",[594]],[[7580,7580],"mapped",[99]],[[7581,7581],"mapped",[597]],[[7582,7582],"mapped",[240]],[[7583,7583],"mapped",[604]],[[7584,7584],"mapped",[102]],[[7585,7585],"mapped",[607]],[[7586,7586],"mapped",[609]],[[7587,7587],"mapped",[613]],[[7588,7588],"mapped",[616]],[[7589,7589],"mapped",[617]],[[7590,7590],"mapped",[618]],[[7591,7591],"mapped",[7547]],[[7592,7592],"mapped",[669]],[[7593,7593],"mapped",[621]],[[7594,7594],"mapped",[7557]],[[7595,7595],"mapped",[671]],[[7596,7596],"mapped",[625]],[[7597,7597],"mapped",[624]],[[7598,7598],"mapped",[626]],[[7599,7599],"mapped",[627]],[[7600,7600],"mapped",[628]],[[7601,7601],"mapped",[629]],[[7602,7602],"mapped",[632]],[[7603,7603],"mapped",[642]],[[7604,7604],"mapped",[643]],[[7605,7605],"mapped",[427]],[[7606,7606],"mapped",[649]],[[7607,7607],"mapped",[650]],[[7608,7608],"mapped",[7452]],[[7609,7609],"mapped",[651]],[[7610,7610],"mapped",[652]],[[7611,7611],"mapped",[122]],[[7612,7612],"mapped",[656]],[[7613,7613],"mapped",[657]],[[7614,7614],"mapped",[658]],[[7615,7615],"mapped",[952]],[[7616,7619],"valid"],[[7620,7626],"valid"],[[7627,7654],"valid"],[[7655,7669],"valid"],[[7670,7675],"disallowed"],[[7676,7676],"valid"],[[7677,7677],"valid"],[[7678,7679],"valid"],[[7680,7680],"mapped",[7681]],[[7681,7681],"valid"],[[7682,7682],"mapped",[7683]],[[7683,7683],"valid"],[[7684,7684],"mapped",[7685]],[[7685,7685],"valid"],[[7686,7686],"mapped",[7687]],[[7687,7687],"valid"],[[7688,7688],"mapped",[7689]],[[7689,7689],"valid"],[[7690,7690],"mapped",[7691]],[[7691,7691],"valid"],[[7692,7692],"mapped",[7693]],[[7693,7693],"valid"],[[7694,7694],"mapped",[7695]],[[7695,7695],"valid"],[[7696,7696],"mapped",[7697]],[[7697,7697],"valid"],[[7698,7698],"mapped",[7699]],[[7699,7699],"valid"],[[7700,7700],"mapped",[7701]],[[7701,7701],"valid"],[[7702,7702],"mapped",[7703]],[[7703,7703],"valid"],[[7704,7704],"mapped",[7705]],[[7705,7705],"valid"],[[7706,7706],"mapped",[7707]],[[7707,7707],"valid"],[[7708,7708],"mapped",[7709]],[[7709,7709],"valid"],[[7710,7710],"mapped",[7711]],[[7711,7711],"valid"],[[7712,7712],"mapped",[7713]],[[7713,7713],"valid"],[[7714,7714],"mapped",[7715]],[[7715,7715],"valid"],[[7716,7716],"mapped",[7717]],[[7717,7717],"valid"],[[7718,7718],"mapped",[7719]],[[7719,7719],"valid"],[[7720,7720],"mapped",[7721]],[[7721,7721],"valid"],[[7722,7722],"mapped",[7723]],[[7723,7723],"valid"],[[7724,7724],"mapped",[7725]],[[7725,7725],"valid"],[[7726,7726],"mapped",[7727]],[[7727,7727],"valid"],[[7728,7728],"mapped",[7729]],[[7729,7729],"valid"],[[7730,7730],"mapped",[7731]],[[7731,7731],"valid"],[[7732,7732],"mapped",[7733]],[[7733,7733],"valid"],[[7734,7734],"mapped",[7735]],[[7735,7735],"valid"],[[7736,7736],"mapped",[7737]],[[7737,7737],"valid"],[[7738,7738],"mapped",[7739]],[[7739,7739],"valid"],[[7740,7740],"mapped",[7741]],[[7741,7741],"valid"],[[7742,7742],"mapped",[7743]],[[7743,7743],"valid"],[[7744,7744],"mapped",[7745]],[[7745,7745],"valid"],[[7746,7746],"mapped",[7747]],[[7747,7747],"valid"],[[7748,7748],"mapped",[7749]],[[7749,7749],"valid"],[[7750,7750],"mapped",[7751]],[[7751,7751],"valid"],[[7752,7752],"mapped",[7753]],[[7753,7753],"valid"],[[7754,7754],"mapped",[7755]],[[7755,7755],"valid"],[[7756,7756],"mapped",[7757]],[[7757,7757],"valid"],[[7758,7758],"mapped",[7759]],[[7759,7759],"valid"],[[7760,7760],"mapped",[7761]],[[7761,7761],"valid"],[[7762,7762],"mapped",[7763]],[[7763,7763],"valid"],[[7764,7764],"mapped",[7765]],[[7765,7765],"valid"],[[7766,7766],"mapped",[7767]],[[7767,7767],"valid"],[[7768,7768],"mapped",[7769]],[[7769,7769],"valid"],[[7770,7770],"mapped",[7771]],[[7771,7771],"valid"],[[7772,7772],"mapped",[7773]],[[7773,7773],"valid"],[[7774,7774],"mapped",[7775]],[[7775,7775],"valid"],[[7776,7776],"mapped",[7777]],[[7777,7777],"valid"],[[7778,7778],"mapped",[7779]],[[7779,7779],"valid"],[[7780,7780],"mapped",[7781]],[[7781,7781],"valid"],[[7782,7782],"mapped",[7783]],[[7783,7783],"valid"],[[7784,7784],"mapped",[7785]],[[7785,7785],"valid"],[[7786,7786],"mapped",[7787]],[[7787,7787],"valid"],[[7788,7788],"mapped",[7789]],[[7789,7789],"valid"],[[7790,7790],"mapped",[7791]],[[7791,7791],"valid"],[[7792,7792],"mapped",[7793]],[[7793,7793],"valid"],[[7794,7794],"mapped",[7795]],[[7795,7795],"valid"],[[7796,7796],"mapped",[7797]],[[7797,7797],"valid"],[[7798,7798],"mapped",[7799]],[[7799,7799],"valid"],[[7800,7800],"mapped",[7801]],[[7801,7801],"valid"],[[7802,7802],"mapped",[7803]],[[7803,7803],"valid"],[[7804,7804],"mapped",[7805]],[[7805,7805],"valid"],[[7806,7806],"mapped",[7807]],[[7807,7807],"valid"],[[7808,7808],"mapped",[7809]],[[7809,7809],"valid"],[[7810,7810],"mapped",[7811]],[[7811,7811],"valid"],[[7812,7812],"mapped",[7813]],[[7813,7813],"valid"],[[7814,7814],"mapped",[7815]],[[7815,7815],"valid"],[[7816,7816],"mapped",[7817]],[[7817,7817],"valid"],[[7818,7818],"mapped",[7819]],[[7819,7819],"valid"],[[7820,7820],"mapped",[7821]],[[7821,7821],"valid"],[[7822,7822],"mapped",[7823]],[[7823,7823],"valid"],[[7824,7824],"mapped",[7825]],[[7825,7825],"valid"],[[7826,7826],"mapped",[7827]],[[7827,7827],"valid"],[[7828,7828],"mapped",[7829]],[[7829,7833],"valid"],[[7834,7834],"mapped",[97,702]],[[7835,7835],"mapped",[7777]],[[7836,7837],"valid"],[[7838,7838],"mapped",[115,115]],[[7839,7839],"valid"],[[7840,7840],"mapped",[7841]],[[7841,7841],"valid"],[[7842,7842],"mapped",[7843]],[[7843,7843],"valid"],[[7844,7844],"mapped",[7845]],[[7845,7845],"valid"],[[7846,7846],"mapped",[7847]],[[7847,7847],"valid"],[[7848,7848],"mapped",[7849]],[[7849,7849],"valid"],[[7850,7850],"mapped",[7851]],[[7851,7851],"valid"],[[7852,7852],"mapped",[7853]],[[7853,7853],"valid"],[[7854,7854],"mapped",[7855]],[[7855,7855],"valid"],[[7856,7856],"mapped",[7857]],[[7857,7857],"valid"],[[7858,7858],"mapped",[7859]],[[7859,7859],"valid"],[[7860,7860],"mapped",[7861]],[[7861,7861],"valid"],[[7862,7862],"mapped",[7863]],[[7863,7863],"valid"],[[7864,7864],"mapped",[7865]],[[7865,7865],"valid"],[[7866,7866],"mapped",[7867]],[[7867,7867],"valid"],[[7868,7868],"mapped",[7869]],[[7869,7869],"valid"],[[7870,7870],"mapped",[7871]],[[7871,7871],"valid"],[[7872,7872],"mapped",[7873]],[[7873,7873],"valid"],[[7874,7874],"mapped",[7875]],[[7875,7875],"valid"],[[7876,7876],"mapped",[7877]],[[7877,7877],"valid"],[[7878,7878],"mapped",[7879]],[[7879,7879],"valid"],[[7880,7880],"mapped",[7881]],[[7881,7881],"valid"],[[7882,7882],"mapped",[7883]],[[7883,7883],"valid"],[[7884,7884],"mapped",[7885]],[[7885,7885],"valid"],[[7886,7886],"mapped",[7887]],[[7887,7887],"valid"],[[7888,7888],"mapped",[7889]],[[7889,7889],"valid"],[[7890,7890],"mapped",[7891]],[[7891,7891],"valid"],[[7892,7892],"mapped",[7893]],[[7893,7893],"valid"],[[7894,7894],"mapped",[7895]],[[7895,7895],"valid"],[[7896,7896],"mapped",[7897]],[[7897,7897],"valid"],[[7898,7898],"mapped",[7899]],[[7899,7899],"valid"],[[7900,7900],"mapped",[7901]],[[7901,7901],"valid"],[[7902,7902],"mapped",[7903]],[[7903,7903],"valid"],[[7904,7904],"mapped",[7905]],[[7905,7905],"valid"],[[7906,7906],"mapped",[7907]],[[7907,7907],"valid"],[[7908,7908],"mapped",[7909]],[[7909,7909],"valid"],[[7910,7910],"mapped",[7911]],[[7911,7911],"valid"],[[7912,7912],"mapped",[7913]],[[7913,7913],"valid"],[[7914,7914],"mapped",[7915]],[[7915,7915],"valid"],[[7916,7916],"mapped",[7917]],[[7917,7917],"valid"],[[7918,7918],"mapped",[7919]],[[7919,7919],"valid"],[[7920,7920],"mapped",[7921]],[[7921,7921],"valid"],[[7922,7922],"mapped",[7923]],[[7923,7923],"valid"],[[7924,7924],"mapped",[7925]],[[7925,7925],"valid"],[[7926,7926],"mapped",[7927]],[[7927,7927],"valid"],[[7928,7928],"mapped",[7929]],[[7929,7929],"valid"],[[7930,7930],"mapped",[7931]],[[7931,7931],"valid"],[[7932,7932],"mapped",[7933]],[[7933,7933],"valid"],[[7934,7934],"mapped",[7935]],[[7935,7935],"valid"],[[7936,7943],"valid"],[[7944,7944],"mapped",[7936]],[[7945,7945],"mapped",[7937]],[[7946,7946],"mapped",[7938]],[[7947,7947],"mapped",[7939]],[[7948,7948],"mapped",[7940]],[[7949,7949],"mapped",[7941]],[[7950,7950],"mapped",[7942]],[[7951,7951],"mapped",[7943]],[[7952,7957],"valid"],[[7958,7959],"disallowed"],[[7960,7960],"mapped",[7952]],[[7961,7961],"mapped",[7953]],[[7962,7962],"mapped",[7954]],[[7963,7963],"mapped",[7955]],[[7964,7964],"mapped",[7956]],[[7965,7965],"mapped",[7957]],[[7966,7967],"disallowed"],[[7968,7975],"valid"],[[7976,7976],"mapped",[7968]],[[7977,7977],"mapped",[7969]],[[7978,7978],"mapped",[7970]],[[7979,7979],"mapped",[7971]],[[7980,7980],"mapped",[7972]],[[7981,7981],"mapped",[7973]],[[7982,7982],"mapped",[7974]],[[7983,7983],"mapped",[7975]],[[7984,7991],"valid"],[[7992,7992],"mapped",[7984]],[[7993,7993],"mapped",[7985]],[[7994,7994],"mapped",[7986]],[[7995,7995],"mapped",[7987]],[[7996,7996],"mapped",[7988]],[[7997,7997],"mapped",[7989]],[[7998,7998],"mapped",[7990]],[[7999,7999],"mapped",[7991]],[[8000,8005],"valid"],[[8006,8007],"disallowed"],[[8008,8008],"mapped",[8000]],[[8009,8009],"mapped",[8001]],[[8010,8010],"mapped",[8002]],[[8011,8011],"mapped",[8003]],[[8012,8012],"mapped",[8004]],[[8013,8013],"mapped",[8005]],[[8014,8015],"disallowed"],[[8016,8023],"valid"],[[8024,8024],"disallowed"],[[8025,8025],"mapped",[8017]],[[8026,8026],"disallowed"],[[8027,8027],"mapped",[8019]],[[8028,8028],"disallowed"],[[8029,8029],"mapped",[8021]],[[8030,8030],"disallowed"],[[8031,8031],"mapped",[8023]],[[8032,8039],"valid"],[[8040,8040],"mapped",[8032]],[[8041,8041],"mapped",[8033]],[[8042,8042],"mapped",[8034]],[[8043,8043],"mapped",[8035]],[[8044,8044],"mapped",[8036]],[[8045,8045],"mapped",[8037]],[[8046,8046],"mapped",[8038]],[[8047,8047],"mapped",[8039]],[[8048,8048],"valid"],[[8049,8049],"mapped",[940]],[[8050,8050],"valid"],[[8051,8051],"mapped",[941]],[[8052,8052],"valid"],[[8053,8053],"mapped",[942]],[[8054,8054],"valid"],[[8055,8055],"mapped",[943]],[[8056,8056],"valid"],[[8057,8057],"mapped",[972]],[[8058,8058],"valid"],[[8059,8059],"mapped",[973]],[[8060,8060],"valid"],[[8061,8061],"mapped",[974]],[[8062,8063],"disallowed"],[[8064,8064],"mapped",[7936,953]],[[8065,8065],"mapped",[7937,953]],[[8066,8066],"mapped",[7938,953]],[[8067,8067],"mapped",[7939,953]],[[8068,8068],"mapped",[7940,953]],[[8069,8069],"mapped",[7941,953]],[[8070,8070],"mapped",[7942,953]],[[8071,8071],"mapped",[7943,953]],[[8072,8072],"mapped",[7936,953]],[[8073,8073],"mapped",[7937,953]],[[8074,8074],"mapped",[7938,953]],[[8075,8075],"mapped",[7939,953]],[[8076,8076],"mapped",[7940,953]],[[8077,8077],"mapped",[7941,953]],[[8078,8078],"mapped",[7942,953]],[[8079,8079],"mapped",[7943,953]],[[8080,8080],"mapped",[7968,953]],[[8081,8081],"mapped",[7969,953]],[[8082,8082],"mapped",[7970,953]],[[8083,8083],"mapped",[7971,953]],[[8084,8084],"mapped",[7972,953]],[[8085,8085],"mapped",[7973,953]],[[8086,8086],"mapped",[7974,953]],[[8087,8087],"mapped",[7975,953]],[[8088,8088],"mapped",[7968,953]],[[8089,8089],"mapped",[7969,953]],[[8090,8090],"mapped",[7970,953]],[[8091,8091],"mapped",[7971,953]],[[8092,8092],"mapped",[7972,953]],[[8093,8093],"mapped",[7973,953]],[[8094,8094],"mapped",[7974,953]],[[8095,8095],"mapped",[7975,953]],[[8096,8096],"mapped",[8032,953]],[[8097,8097],"mapped",[8033,953]],[[8098,8098],"mapped",[8034,953]],[[8099,8099],"mapped",[8035,953]],[[8100,8100],"mapped",[8036,953]],[[8101,8101],"mapped",[8037,953]],[[8102,8102],"mapped",[8038,953]],[[8103,8103],"mapped",[8039,953]],[[8104,8104],"mapped",[8032,953]],[[8105,8105],"mapped",[8033,953]],[[8106,8106],"mapped",[8034,953]],[[8107,8107],"mapped",[8035,953]],[[8108,8108],"mapped",[8036,953]],[[8109,8109],"mapped",[8037,953]],[[8110,8110],"mapped",[8038,953]],[[8111,8111],"mapped",[8039,953]],[[8112,8113],"valid"],[[8114,8114],"mapped",[8048,953]],[[8115,8115],"mapped",[945,953]],[[8116,8116],"mapped",[940,953]],[[8117,8117],"disallowed"],[[8118,8118],"valid"],[[8119,8119],"mapped",[8118,953]],[[8120,8120],"mapped",[8112]],[[8121,8121],"mapped",[8113]],[[8122,8122],"mapped",[8048]],[[8123,8123],"mapped",[940]],[[8124,8124],"mapped",[945,953]],[[8125,8125],"disallowed_STD3_mapped",[32,787]],[[8126,8126],"mapped",[953]],[[8127,8127],"disallowed_STD3_mapped",[32,787]],[[8128,8128],"disallowed_STD3_mapped",[32,834]],[[8129,8129],"disallowed_STD3_mapped",[32,776,834]],[[8130,8130],"mapped",[8052,953]],[[8131,8131],"mapped",[951,953]],[[8132,8132],"mapped",[942,953]],[[8133,8133],"disallowed"],[[8134,8134],"valid"],[[8135,8135],"mapped",[8134,953]],[[8136,8136],"mapped",[8050]],[[8137,8137],"mapped",[941]],[[8138,8138],"mapped",[8052]],[[8139,8139],"mapped",[942]],[[8140,8140],"mapped",[951,953]],[[8141,8141],"disallowed_STD3_mapped",[32,787,768]],[[8142,8142],"disallowed_STD3_mapped",[32,787,769]],[[8143,8143],"disallowed_STD3_mapped",[32,787,834]],[[8144,8146],"valid"],[[8147,8147],"mapped",[912]],[[8148,8149],"disallowed"],[[8150,8151],"valid"],[[8152,8152],"mapped",[8144]],[[8153,8153],"mapped",[8145]],[[8154,8154],"mapped",[8054]],[[8155,8155],"mapped",[943]],[[8156,8156],"disallowed"],[[8157,8157],"disallowed_STD3_mapped",[32,788,768]],[[8158,8158],"disallowed_STD3_mapped",[32,788,769]],[[8159,8159],"disallowed_STD3_mapped",[32,788,834]],[[8160,8162],"valid"],[[8163,8163],"mapped",[944]],[[8164,8167],"valid"],[[8168,8168],"mapped",[8160]],[[8169,8169],"mapped",[8161]],[[8170,8170],"mapped",[8058]],[[8171,8171],"mapped",[973]],[[8172,8172],"mapped",[8165]],[[8173,8173],"disallowed_STD3_mapped",[32,776,768]],[[8174,8174],"disallowed_STD3_mapped",[32,776,769]],[[8175,8175],"disallowed_STD3_mapped",[96]],[[8176,8177],"disallowed"],[[8178,8178],"mapped",[8060,953]],[[8179,8179],"mapped",[969,953]],[[8180,8180],"mapped",[974,953]],[[8181,8181],"disallowed"],[[8182,8182],"valid"],[[8183,8183],"mapped",[8182,953]],[[8184,8184],"mapped",[8056]],[[8185,8185],"mapped",[972]],[[8186,8186],"mapped",[8060]],[[8187,8187],"mapped",[974]],[[8188,8188],"mapped",[969,953]],[[8189,8189],"disallowed_STD3_mapped",[32,769]],[[8190,8190],"disallowed_STD3_mapped",[32,788]],[[8191,8191],"disallowed"],[[8192,8202],"disallowed_STD3_mapped",[32]],[[8203,8203],"ignored"],[[8204,8205],"deviation",[]],[[8206,8207],"disallowed"],[[8208,8208],"valid",[],"NV8"],[[8209,8209],"mapped",[8208]],[[8210,8214],"valid",[],"NV8"],[[8215,8215],"disallowed_STD3_mapped",[32,819]],[[8216,8227],"valid",[],"NV8"],[[8228,8230],"disallowed"],[[8231,8231],"valid",[],"NV8"],[[8232,8238],"disallowed"],[[8239,8239],"disallowed_STD3_mapped",[32]],[[8240,8242],"valid",[],"NV8"],[[8243,8243],"mapped",[8242,8242]],[[8244,8244],"mapped",[8242,8242,8242]],[[8245,8245],"valid",[],"NV8"],[[8246,8246],"mapped",[8245,8245]],[[8247,8247],"mapped",[8245,8245,8245]],[[8248,8251],"valid",[],"NV8"],[[8252,8252],"disallowed_STD3_mapped",[33,33]],[[8253,8253],"valid",[],"NV8"],[[8254,8254],"disallowed_STD3_mapped",[32,773]],[[8255,8262],"valid",[],"NV8"],[[8263,8263],"disallowed_STD3_mapped",[63,63]],[[8264,8264],"disallowed_STD3_mapped",[63,33]],[[8265,8265],"disallowed_STD3_mapped",[33,63]],[[8266,8269],"valid",[],"NV8"],[[8270,8274],"valid",[],"NV8"],[[8275,8276],"valid",[],"NV8"],[[8277,8278],"valid",[],"NV8"],[[8279,8279],"mapped",[8242,8242,8242,8242]],[[8280,8286],"valid",[],"NV8"],[[8287,8287],"disallowed_STD3_mapped",[32]],[[8288,8288],"ignored"],[[8289,8291],"disallowed"],[[8292,8292],"ignored"],[[8293,8293],"disallowed"],[[8294,8297],"disallowed"],[[8298,8303],"disallowed"],[[8304,8304],"mapped",[48]],[[8305,8305],"mapped",[105]],[[8306,8307],"disallowed"],[[8308,8308],"mapped",[52]],[[8309,8309],"mapped",[53]],[[8310,8310],"mapped",[54]],[[8311,8311],"mapped",[55]],[[8312,8312],"mapped",[56]],[[8313,8313],"mapped",[57]],[[8314,8314],"disallowed_STD3_mapped",[43]],[[8315,8315],"mapped",[8722]],[[8316,8316],"disallowed_STD3_mapped",[61]],[[8317,8317],"disallowed_STD3_mapped",[40]],[[8318,8318],"disallowed_STD3_mapped",[41]],[[8319,8319],"mapped",[110]],[[8320,8320],"mapped",[48]],[[8321,8321],"mapped",[49]],[[8322,8322],"mapped",[50]],[[8323,8323],"mapped",[51]],[[8324,8324],"mapped",[52]],[[8325,8325],"mapped",[53]],[[8326,8326],"mapped",[54]],[[8327,8327],"mapped",[55]],[[8328,8328],"mapped",[56]],[[8329,8329],"mapped",[57]],[[8330,8330],"disallowed_STD3_mapped",[43]],[[8331,8331],"mapped",[8722]],[[8332,8332],"disallowed_STD3_mapped",[61]],[[8333,8333],"disallowed_STD3_mapped",[40]],[[8334,8334],"disallowed_STD3_mapped",[41]],[[8335,8335],"disallowed"],[[8336,8336],"mapped",[97]],[[8337,8337],"mapped",[101]],[[8338,8338],"mapped",[111]],[[8339,8339],"mapped",[120]],[[8340,8340],"mapped",[601]],[[8341,8341],"mapped",[104]],[[8342,8342],"mapped",[107]],[[8343,8343],"mapped",[108]],[[8344,8344],"mapped",[109]],[[8345,8345],"mapped",[110]],[[8346,8346],"mapped",[112]],[[8347,8347],"mapped",[115]],[[8348,8348],"mapped",[116]],[[8349,8351],"disallowed"],[[8352,8359],"valid",[],"NV8"],[[8360,8360],"mapped",[114,115]],[[8361,8362],"valid",[],"NV8"],[[8363,8363],"valid",[],"NV8"],[[8364,8364],"valid",[],"NV8"],[[8365,8367],"valid",[],"NV8"],[[8368,8369],"valid",[],"NV8"],[[8370,8373],"valid",[],"NV8"],[[8374,8376],"valid",[],"NV8"],[[8377,8377],"valid",[],"NV8"],[[8378,8378],"valid",[],"NV8"],[[8379,8381],"valid",[],"NV8"],[[8382,8382],"valid",[],"NV8"],[[8383,8399],"disallowed"],[[8400,8417],"valid",[],"NV8"],[[8418,8419],"valid",[],"NV8"],[[8420,8426],"valid",[],"NV8"],[[8427,8427],"valid",[],"NV8"],[[8428,8431],"valid",[],"NV8"],[[8432,8432],"valid",[],"NV8"],[[8433,8447],"disallowed"],[[8448,8448],"disallowed_STD3_mapped",[97,47,99]],[[8449,8449],"disallowed_STD3_mapped",[97,47,115]],[[8450,8450],"mapped",[99]],[[8451,8451],"mapped",[176,99]],[[8452,8452],"valid",[],"NV8"],[[8453,8453],"disallowed_STD3_mapped",[99,47,111]],[[8454,8454],"disallowed_STD3_mapped",[99,47,117]],[[8455,8455],"mapped",[603]],[[8456,8456],"valid",[],"NV8"],[[8457,8457],"mapped",[176,102]],[[8458,8458],"mapped",[103]],[[8459,8462],"mapped",[104]],[[8463,8463],"mapped",[295]],[[8464,8465],"mapped",[105]],[[8466,8467],"mapped",[108]],[[8468,8468],"valid",[],"NV8"],[[8469,8469],"mapped",[110]],[[8470,8470],"mapped",[110,111]],[[8471,8472],"valid",[],"NV8"],[[8473,8473],"mapped",[112]],[[8474,8474],"mapped",[113]],[[8475,8477],"mapped",[114]],[[8478,8479],"valid",[],"NV8"],[[8480,8480],"mapped",[115,109]],[[8481,8481],"mapped",[116,101,108]],[[8482,8482],"mapped",[116,109]],[[8483,8483],"valid",[],"NV8"],[[8484,8484],"mapped",[122]],[[8485,8485],"valid",[],"NV8"],[[8486,8486],"mapped",[969]],[[8487,8487],"valid",[],"NV8"],[[8488,8488],"mapped",[122]],[[8489,8489],"valid",[],"NV8"],[[8490,8490],"mapped",[107]],[[8491,8491],"mapped",[229]],[[8492,8492],"mapped",[98]],[[8493,8493],"mapped",[99]],[[8494,8494],"valid",[],"NV8"],[[8495,8496],"mapped",[101]],[[8497,8497],"mapped",[102]],[[8498,8498],"disallowed"],[[8499,8499],"mapped",[109]],[[8500,8500],"mapped",[111]],[[8501,8501],"mapped",[1488]],[[8502,8502],"mapped",[1489]],[[8503,8503],"mapped",[1490]],[[8504,8504],"mapped",[1491]],[[8505,8505],"mapped",[105]],[[8506,8506],"valid",[],"NV8"],[[8507,8507],"mapped",[102,97,120]],[[8508,8508],"mapped",[960]],[[8509,8510],"mapped",[947]],[[8511,8511],"mapped",[960]],[[8512,8512],"mapped",[8721]],[[8513,8516],"valid",[],"NV8"],[[8517,8518],"mapped",[100]],[[8519,8519],"mapped",[101]],[[8520,8520],"mapped",[105]],[[8521,8521],"mapped",[106]],[[8522,8523],"valid",[],"NV8"],[[8524,8524],"valid",[],"NV8"],[[8525,8525],"valid",[],"NV8"],[[8526,8526],"valid"],[[8527,8527],"valid",[],"NV8"],[[8528,8528],"mapped",[49,8260,55]],[[8529,8529],"mapped",[49,8260,57]],[[8530,8530],"mapped",[49,8260,49,48]],[[8531,8531],"mapped",[49,8260,51]],[[8532,8532],"mapped",[50,8260,51]],[[8533,8533],"mapped",[49,8260,53]],[[8534,8534],"mapped",[50,8260,53]],[[8535,8535],"mapped",[51,8260,53]],[[8536,8536],"mapped",[52,8260,53]],[[8537,8537],"mapped",[49,8260,54]],[[8538,8538],"mapped",[53,8260,54]],[[8539,8539],"mapped",[49,8260,56]],[[8540,8540],"mapped",[51,8260,56]],[[8541,8541],"mapped",[53,8260,56]],[[8542,8542],"mapped",[55,8260,56]],[[8543,8543],"mapped",[49,8260]],[[8544,8544],"mapped",[105]],[[8545,8545],"mapped",[105,105]],[[8546,8546],"mapped",[105,105,105]],[[8547,8547],"mapped",[105,118]],[[8548,8548],"mapped",[118]],[[8549,8549],"mapped",[118,105]],[[8550,8550],"mapped",[118,105,105]],[[8551,8551],"mapped",[118,105,105,105]],[[8552,8552],"mapped",[105,120]],[[8553,8553],"mapped",[120]],[[8554,8554],"mapped",[120,105]],[[8555,8555],"mapped",[120,105,105]],[[8556,8556],"mapped",[108]],[[8557,8557],"mapped",[99]],[[8558,8558],"mapped",[100]],[[8559,8559],"mapped",[109]],[[8560,8560],"mapped",[105]],[[8561,8561],"mapped",[105,105]],[[8562,8562],"mapped",[105,105,105]],[[8563,8563],"mapped",[105,118]],[[8564,8564],"mapped",[118]],[[8565,8565],"mapped",[118,105]],[[8566,8566],"mapped",[118,105,105]],[[8567,8567],"mapped",[118,105,105,105]],[[8568,8568],"mapped",[105,120]],[[8569,8569],"mapped",[120]],[[8570,8570],"mapped",[120,105]],[[8571,8571],"mapped",[120,105,105]],[[8572,8572],"mapped",[108]],[[8573,8573],"mapped",[99]],[[8574,8574],"mapped",[100]],[[8575,8575],"mapped",[109]],[[8576,8578],"valid",[],"NV8"],[[8579,8579],"disallowed"],[[8580,8580],"valid"],[[8581,8584],"valid",[],"NV8"],[[8585,8585],"mapped",[48,8260,51]],[[8586,8587],"valid",[],"NV8"],[[8588,8591],"disallowed"],[[8592,8682],"valid",[],"NV8"],[[8683,8691],"valid",[],"NV8"],[[8692,8703],"valid",[],"NV8"],[[8704,8747],"valid",[],"NV8"],[[8748,8748],"mapped",[8747,8747]],[[8749,8749],"mapped",[8747,8747,8747]],[[8750,8750],"valid",[],"NV8"],[[8751,8751],"mapped",[8750,8750]],[[8752,8752],"mapped",[8750,8750,8750]],[[8753,8799],"valid",[],"NV8"],[[8800,8800],"disallowed_STD3_valid"],[[8801,8813],"valid",[],"NV8"],[[8814,8815],"disallowed_STD3_valid"],[[8816,8945],"valid",[],"NV8"],[[8946,8959],"valid",[],"NV8"],[[8960,8960],"valid",[],"NV8"],[[8961,8961],"valid",[],"NV8"],[[8962,9000],"valid",[],"NV8"],[[9001,9001],"mapped",[12296]],[[9002,9002],"mapped",[12297]],[[9003,9082],"valid",[],"NV8"],[[9083,9083],"valid",[],"NV8"],[[9084,9084],"valid",[],"NV8"],[[9085,9114],"valid",[],"NV8"],[[9115,9166],"valid",[],"NV8"],[[9167,9168],"valid",[],"NV8"],[[9169,9179],"valid",[],"NV8"],[[9180,9191],"valid",[],"NV8"],[[9192,9192],"valid",[],"NV8"],[[9193,9203],"valid",[],"NV8"],[[9204,9210],"valid",[],"NV8"],[[9211,9215],"disallowed"],[[9216,9252],"valid",[],"NV8"],[[9253,9254],"valid",[],"NV8"],[[9255,9279],"disallowed"],[[9280,9290],"valid",[],"NV8"],[[9291,9311],"disallowed"],[[9312,9312],"mapped",[49]],[[9313,9313],"mapped",[50]],[[9314,9314],"mapped",[51]],[[9315,9315],"mapped",[52]],[[9316,9316],"mapped",[53]],[[9317,9317],"mapped",[54]],[[9318,9318],"mapped",[55]],[[9319,9319],"mapped",[56]],[[9320,9320],"mapped",[57]],[[9321,9321],"mapped",[49,48]],[[9322,9322],"mapped",[49,49]],[[9323,9323],"mapped",[49,50]],[[9324,9324],"mapped",[49,51]],[[9325,9325],"mapped",[49,52]],[[9326,9326],"mapped",[49,53]],[[9327,9327],"mapped",[49,54]],[[9328,9328],"mapped",[49,55]],[[9329,9329],"mapped",[49,56]],[[9330,9330],"mapped",[49,57]],[[9331,9331],"mapped",[50,48]],[[9332,9332],"disallowed_STD3_mapped",[40,49,41]],[[9333,9333],"disallowed_STD3_mapped",[40,50,41]],[[9334,9334],"disallowed_STD3_mapped",[40,51,41]],[[9335,9335],"disallowed_STD3_mapped",[40,52,41]],[[9336,9336],"disallowed_STD3_mapped",[40,53,41]],[[9337,9337],"disallowed_STD3_mapped",[40,54,41]],[[9338,9338],"disallowed_STD3_mapped",[40,55,41]],[[9339,9339],"disallowed_STD3_mapped",[40,56,41]],[[9340,9340],"disallowed_STD3_mapped",[40,57,41]],[[9341,9341],"disallowed_STD3_mapped",[40,49,48,41]],[[9342,9342],"disallowed_STD3_mapped",[40,49,49,41]],[[9343,9343],"disallowed_STD3_mapped",[40,49,50,41]],[[9344,9344],"disallowed_STD3_mapped",[40,49,51,41]],[[9345,9345],"disallowed_STD3_mapped",[40,49,52,41]],[[9346,9346],"disallowed_STD3_mapped",[40,49,53,41]],[[9347,9347],"disallowed_STD3_mapped",[40,49,54,41]],[[9348,9348],"disallowed_STD3_mapped",[40,49,55,41]],[[9349,9349],"disallowed_STD3_mapped",[40,49,56,41]],[[9350,9350],"disallowed_STD3_mapped",[40,49,57,41]],[[9351,9351],"disallowed_STD3_mapped",[40,50,48,41]],[[9352,9371],"disallowed"],[[9372,9372],"disallowed_STD3_mapped",[40,97,41]],[[9373,9373],"disallowed_STD3_mapped",[40,98,41]],[[9374,9374],"disallowed_STD3_mapped",[40,99,41]],[[9375,9375],"disallowed_STD3_mapped",[40,100,41]],[[9376,9376],"disallowed_STD3_mapped",[40,101,41]],[[9377,9377],"disallowed_STD3_mapped",[40,102,41]],[[9378,9378],"disallowed_STD3_mapped",[40,103,41]],[[9379,9379],"disallowed_STD3_mapped",[40,104,41]],[[9380,9380],"disallowed_STD3_mapped",[40,105,41]],[[9381,9381],"disallowed_STD3_mapped",[40,106,41]],[[9382,9382],"disallowed_STD3_mapped",[40,107,41]],[[9383,9383],"disallowed_STD3_mapped",[40,108,41]],[[9384,9384],"disallowed_STD3_mapped",[40,109,41]],[[9385,9385],"disallowed_STD3_mapped",[40,110,41]],[[9386,9386],"disallowed_STD3_mapped",[40,111,41]],[[9387,9387],"disallowed_STD3_mapped",[40,112,41]],[[9388,9388],"disallowed_STD3_mapped",[40,113,41]],[[9389,9389],"disallowed_STD3_mapped",[40,114,41]],[[9390,9390],"disallowed_STD3_mapped",[40,115,41]],[[9391,9391],"disallowed_STD3_mapped",[40,116,41]],[[9392,9392],"disallowed_STD3_mapped",[40,117,41]],[[9393,9393],"disallowed_STD3_mapped",[40,118,41]],[[9394,9394],"disallowed_STD3_mapped",[40,119,41]],[[9395,9395],"disallowed_STD3_mapped",[40,120,41]],[[9396,9396],"disallowed_STD3_mapped",[40,121,41]],[[9397,9397],"disallowed_STD3_mapped",[40,122,41]],[[9398,9398],"mapped",[97]],[[9399,9399],"mapped",[98]],[[9400,9400],"mapped",[99]],[[9401,9401],"mapped",[100]],[[9402,9402],"mapped",[101]],[[9403,9403],"mapped",[102]],[[9404,9404],"mapped",[103]],[[9405,9405],"mapped",[104]],[[9406,9406],"mapped",[105]],[[9407,9407],"mapped",[106]],[[9408,9408],"mapped",[107]],[[9409,9409],"mapped",[108]],[[9410,9410],"mapped",[109]],[[9411,9411],"mapped",[110]],[[9412,9412],"mapped",[111]],[[9413,9413],"mapped",[112]],[[9414,9414],"mapped",[113]],[[9415,9415],"mapped",[114]],[[9416,9416],"mapped",[115]],[[9417,9417],"mapped",[116]],[[9418,9418],"mapped",[117]],[[9419,9419],"mapped",[118]],[[9420,9420],"mapped",[119]],[[9421,9421],"mapped",[120]],[[9422,9422],"mapped",[121]],[[9423,9423],"mapped",[122]],[[9424,9424],"mapped",[97]],[[9425,9425],"mapped",[98]],[[9426,9426],"mapped",[99]],[[9427,9427],"mapped",[100]],[[9428,9428],"mapped",[101]],[[9429,9429],"mapped",[102]],[[9430,9430],"mapped",[103]],[[9431,9431],"mapped",[104]],[[9432,9432],"mapped",[105]],[[9433,9433],"mapped",[106]],[[9434,9434],"mapped",[107]],[[9435,9435],"mapped",[108]],[[9436,9436],"mapped",[109]],[[9437,9437],"mapped",[110]],[[9438,9438],"mapped",[111]],[[9439,9439],"mapped",[112]],[[9440,9440],"mapped",[113]],[[9441,9441],"mapped",[114]],[[9442,9442],"mapped",[115]],[[9443,9443],"mapped",[116]],[[9444,9444],"mapped",[117]],[[9445,9445],"mapped",[118]],[[9446,9446],"mapped",[119]],[[9447,9447],"mapped",[120]],[[9448,9448],"mapped",[121]],[[9449,9449],"mapped",[122]],[[9450,9450],"mapped",[48]],[[9451,9470],"valid",[],"NV8"],[[9471,9471],"valid",[],"NV8"],[[9472,9621],"valid",[],"NV8"],[[9622,9631],"valid",[],"NV8"],[[9632,9711],"valid",[],"NV8"],[[9712,9719],"valid",[],"NV8"],[[9720,9727],"valid",[],"NV8"],[[9728,9747],"valid",[],"NV8"],[[9748,9749],"valid",[],"NV8"],[[9750,9751],"valid",[],"NV8"],[[9752,9752],"valid",[],"NV8"],[[9753,9753],"valid",[],"NV8"],[[9754,9839],"valid",[],"NV8"],[[9840,9841],"valid",[],"NV8"],[[9842,9853],"valid",[],"NV8"],[[9854,9855],"valid",[],"NV8"],[[9856,9865],"valid",[],"NV8"],[[9866,9873],"valid",[],"NV8"],[[9874,9884],"valid",[],"NV8"],[[9885,9885],"valid",[],"NV8"],[[9886,9887],"valid",[],"NV8"],[[9888,9889],"valid",[],"NV8"],[[9890,9905],"valid",[],"NV8"],[[9906,9906],"valid",[],"NV8"],[[9907,9916],"valid",[],"NV8"],[[9917,9919],"valid",[],"NV8"],[[9920,9923],"valid",[],"NV8"],[[9924,9933],"valid",[],"NV8"],[[9934,9934],"valid",[],"NV8"],[[9935,9953],"valid",[],"NV8"],[[9954,9954],"valid",[],"NV8"],[[9955,9955],"valid",[],"NV8"],[[9956,9959],"valid",[],"NV8"],[[9960,9983],"valid",[],"NV8"],[[9984,9984],"valid",[],"NV8"],[[9985,9988],"valid",[],"NV8"],[[9989,9989],"valid",[],"NV8"],[[9990,9993],"valid",[],"NV8"],[[9994,9995],"valid",[],"NV8"],[[9996,10023],"valid",[],"NV8"],[[10024,10024],"valid",[],"NV8"],[[10025,10059],"valid",[],"NV8"],[[10060,10060],"valid",[],"NV8"],[[10061,10061],"valid",[],"NV8"],[[10062,10062],"valid",[],"NV8"],[[10063,10066],"valid",[],"NV8"],[[10067,10069],"valid",[],"NV8"],[[10070,10070],"valid",[],"NV8"],[[10071,10071],"valid",[],"NV8"],[[10072,10078],"valid",[],"NV8"],[[10079,10080],"valid",[],"NV8"],[[10081,10087],"valid",[],"NV8"],[[10088,10101],"valid",[],"NV8"],[[10102,10132],"valid",[],"NV8"],[[10133,10135],"valid",[],"NV8"],[[10136,10159],"valid",[],"NV8"],[[10160,10160],"valid",[],"NV8"],[[10161,10174],"valid",[],"NV8"],[[10175,10175],"valid",[],"NV8"],[[10176,10182],"valid",[],"NV8"],[[10183,10186],"valid",[],"NV8"],[[10187,10187],"valid",[],"NV8"],[[10188,10188],"valid",[],"NV8"],[[10189,10189],"valid",[],"NV8"],[[10190,10191],"valid",[],"NV8"],[[10192,10219],"valid",[],"NV8"],[[10220,10223],"valid",[],"NV8"],[[10224,10239],"valid",[],"NV8"],[[10240,10495],"valid",[],"NV8"],[[10496,10763],"valid",[],"NV8"],[[10764,10764],"mapped",[8747,8747,8747,8747]],[[10765,10867],"valid",[],"NV8"],[[10868,10868],"disallowed_STD3_mapped",[58,58,61]],[[10869,10869],"disallowed_STD3_mapped",[61,61]],[[10870,10870],"disallowed_STD3_mapped",[61,61,61]],[[10871,10971],"valid",[],"NV8"],[[10972,10972],"mapped",[10973,824]],[[10973,11007],"valid",[],"NV8"],[[11008,11021],"valid",[],"NV8"],[[11022,11027],"valid",[],"NV8"],[[11028,11034],"valid",[],"NV8"],[[11035,11039],"valid",[],"NV8"],[[11040,11043],"valid",[],"NV8"],[[11044,11084],"valid",[],"NV8"],[[11085,11087],"valid",[],"NV8"],[[11088,11092],"valid",[],"NV8"],[[11093,11097],"valid",[],"NV8"],[[11098,11123],"valid",[],"NV8"],[[11124,11125],"disallowed"],[[11126,11157],"valid",[],"NV8"],[[11158,11159],"disallowed"],[[11160,11193],"valid",[],"NV8"],[[11194,11196],"disallowed"],[[11197,11208],"valid",[],"NV8"],[[11209,11209],"disallowed"],[[11210,11217],"valid",[],"NV8"],[[11218,11243],"disallowed"],[[11244,11247],"valid",[],"NV8"],[[11248,11263],"disallowed"],[[11264,11264],"mapped",[11312]],[[11265,11265],"mapped",[11313]],[[11266,11266],"mapped",[11314]],[[11267,11267],"mapped",[11315]],[[11268,11268],"mapped",[11316]],[[11269,11269],"mapped",[11317]],[[11270,11270],"mapped",[11318]],[[11271,11271],"mapped",[11319]],[[11272,11272],"mapped",[11320]],[[11273,11273],"mapped",[11321]],[[11274,11274],"mapped",[11322]],[[11275,11275],"mapped",[11323]],[[11276,11276],"mapped",[11324]],[[11277,11277],"mapped",[11325]],[[11278,11278],"mapped",[11326]],[[11279,11279],"mapped",[11327]],[[11280,11280],"mapped",[11328]],[[11281,11281],"mapped",[11329]],[[11282,11282],"mapped",[11330]],[[11283,11283],"mapped",[11331]],[[11284,11284],"mapped",[11332]],[[11285,11285],"mapped",[11333]],[[11286,11286],"mapped",[11334]],[[11287,11287],"mapped",[11335]],[[11288,11288],"mapped",[11336]],[[11289,11289],"mapped",[11337]],[[11290,11290],"mapped",[11338]],[[11291,11291],"mapped",[11339]],[[11292,11292],"mapped",[11340]],[[11293,11293],"mapped",[11341]],[[11294,11294],"mapped",[11342]],[[11295,11295],"mapped",[11343]],[[11296,11296],"mapped",[11344]],[[11297,11297],"mapped",[11345]],[[11298,11298],"mapped",[11346]],[[11299,11299],"mapped",[11347]],[[11300,11300],"mapped",[11348]],[[11301,11301],"mapped",[11349]],[[11302,11302],"mapped",[11350]],[[11303,11303],"mapped",[11351]],[[11304,11304],"mapped",[11352]],[[11305,11305],"mapped",[11353]],[[11306,11306],"mapped",[11354]],[[11307,11307],"mapped",[11355]],[[11308,11308],"mapped",[11356]],[[11309,11309],"mapped",[11357]],[[11310,11310],"mapped",[11358]],[[11311,11311],"disallowed"],[[11312,11358],"valid"],[[11359,11359],"disallowed"],[[11360,11360],"mapped",[11361]],[[11361,11361],"valid"],[[11362,11362],"mapped",[619]],[[11363,11363],"mapped",[7549]],[[11364,11364],"mapped",[637]],[[11365,11366],"valid"],[[11367,11367],"mapped",[11368]],[[11368,11368],"valid"],[[11369,11369],"mapped",[11370]],[[11370,11370],"valid"],[[11371,11371],"mapped",[11372]],[[11372,11372],"valid"],[[11373,11373],"mapped",[593]],[[11374,11374],"mapped",[625]],[[11375,11375],"mapped",[592]],[[11376,11376],"mapped",[594]],[[11377,11377],"valid"],[[11378,11378],"mapped",[11379]],[[11379,11379],"valid"],[[11380,11380],"valid"],[[11381,11381],"mapped",[11382]],[[11382,11383],"valid"],[[11384,11387],"valid"],[[11388,11388],"mapped",[106]],[[11389,11389],"mapped",[118]],[[11390,11390],"mapped",[575]],[[11391,11391],"mapped",[576]],[[11392,11392],"mapped",[11393]],[[11393,11393],"valid"],[[11394,11394],"mapped",[11395]],[[11395,11395],"valid"],[[11396,11396],"mapped",[11397]],[[11397,11397],"valid"],[[11398,11398],"mapped",[11399]],[[11399,11399],"valid"],[[11400,11400],"mapped",[11401]],[[11401,11401],"valid"],[[11402,11402],"mapped",[11403]],[[11403,11403],"valid"],[[11404,11404],"mapped",[11405]],[[11405,11405],"valid"],[[11406,11406],"mapped",[11407]],[[11407,11407],"valid"],[[11408,11408],"mapped",[11409]],[[11409,11409],"valid"],[[11410,11410],"mapped",[11411]],[[11411,11411],"valid"],[[11412,11412],"mapped",[11413]],[[11413,11413],"valid"],[[11414,11414],"mapped",[11415]],[[11415,11415],"valid"],[[11416,11416],"mapped",[11417]],[[11417,11417],"valid"],[[11418,11418],"mapped",[11419]],[[11419,11419],"valid"],[[11420,11420],"mapped",[11421]],[[11421,11421],"valid"],[[11422,11422],"mapped",[11423]],[[11423,11423],"valid"],[[11424,11424],"mapped",[11425]],[[11425,11425],"valid"],[[11426,11426],"mapped",[11427]],[[11427,11427],"valid"],[[11428,11428],"mapped",[11429]],[[11429,11429],"valid"],[[11430,11430],"mapped",[11431]],[[11431,11431],"valid"],[[11432,11432],"mapped",[11433]],[[11433,11433],"valid"],[[11434,11434],"mapped",[11435]],[[11435,11435],"valid"],[[11436,11436],"mapped",[11437]],[[11437,11437],"valid"],[[11438,11438],"mapped",[11439]],[[11439,11439],"valid"],[[11440,11440],"mapped",[11441]],[[11441,11441],"valid"],[[11442,11442],"mapped",[11443]],[[11443,11443],"valid"],[[11444,11444],"mapped",[11445]],[[11445,11445],"valid"],[[11446,11446],"mapped",[11447]],[[11447,11447],"valid"],[[11448,11448],"mapped",[11449]],[[11449,11449],"valid"],[[11450,11450],"mapped",[11451]],[[11451,11451],"valid"],[[11452,11452],"mapped",[11453]],[[11453,11453],"valid"],[[11454,11454],"mapped",[11455]],[[11455,11455],"valid"],[[11456,11456],"mapped",[11457]],[[11457,11457],"valid"],[[11458,11458],"mapped",[11459]],[[11459,11459],"valid"],[[11460,11460],"mapped",[11461]],[[11461,11461],"valid"],[[11462,11462],"mapped",[11463]],[[11463,11463],"valid"],[[11464,11464],"mapped",[11465]],[[11465,11465],"valid"],[[11466,11466],"mapped",[11467]],[[11467,11467],"valid"],[[11468,11468],"mapped",[11469]],[[11469,11469],"valid"],[[11470,11470],"mapped",[11471]],[[11471,11471],"valid"],[[11472,11472],"mapped",[11473]],[[11473,11473],"valid"],[[11474,11474],"mapped",[11475]],[[11475,11475],"valid"],[[11476,11476],"mapped",[11477]],[[11477,11477],"valid"],[[11478,11478],"mapped",[11479]],[[11479,11479],"valid"],[[11480,11480],"mapped",[11481]],[[11481,11481],"valid"],[[11482,11482],"mapped",[11483]],[[11483,11483],"valid"],[[11484,11484],"mapped",[11485]],[[11485,11485],"valid"],[[11486,11486],"mapped",[11487]],[[11487,11487],"valid"],[[11488,11488],"mapped",[11489]],[[11489,11489],"valid"],[[11490,11490],"mapped",[11491]],[[11491,11492],"valid"],[[11493,11498],"valid",[],"NV8"],[[11499,11499],"mapped",[11500]],[[11500,11500],"valid"],[[11501,11501],"mapped",[11502]],[[11502,11505],"valid"],[[11506,11506],"mapped",[11507]],[[11507,11507],"valid"],[[11508,11512],"disallowed"],[[11513,11519],"valid",[],"NV8"],[[11520,11557],"valid"],[[11558,11558],"disallowed"],[[11559,11559],"valid"],[[11560,11564],"disallowed"],[[11565,11565],"valid"],[[11566,11567],"disallowed"],[[11568,11621],"valid"],[[11622,11623],"valid"],[[11624,11630],"disallowed"],[[11631,11631],"mapped",[11617]],[[11632,11632],"valid",[],"NV8"],[[11633,11646],"disallowed"],[[11647,11647],"valid"],[[11648,11670],"valid"],[[11671,11679],"disallowed"],[[11680,11686],"valid"],[[11687,11687],"disallowed"],[[11688,11694],"valid"],[[11695,11695],"disallowed"],[[11696,11702],"valid"],[[11703,11703],"disallowed"],[[11704,11710],"valid"],[[11711,11711],"disallowed"],[[11712,11718],"valid"],[[11719,11719],"disallowed"],[[11720,11726],"valid"],[[11727,11727],"disallowed"],[[11728,11734],"valid"],[[11735,11735],"disallowed"],[[11736,11742],"valid"],[[11743,11743],"disallowed"],[[11744,11775],"valid"],[[11776,11799],"valid",[],"NV8"],[[11800,11803],"valid",[],"NV8"],[[11804,11805],"valid",[],"NV8"],[[11806,11822],"valid",[],"NV8"],[[11823,11823],"valid"],[[11824,11824],"valid",[],"NV8"],[[11825,11825],"valid",[],"NV8"],[[11826,11835],"valid",[],"NV8"],[[11836,11842],"valid",[],"NV8"],[[11843,11903],"disallowed"],[[11904,11929],"valid",[],"NV8"],[[11930,11930],"disallowed"],[[11931,11934],"valid",[],"NV8"],[[11935,11935],"mapped",[27597]],[[11936,12018],"valid",[],"NV8"],[[12019,12019],"mapped",[40863]],[[12020,12031],"disallowed"],[[12032,12032],"mapped",[19968]],[[12033,12033],"mapped",[20008]],[[12034,12034],"mapped",[20022]],[[12035,12035],"mapped",[20031]],[[12036,12036],"mapped",[20057]],[[12037,12037],"mapped",[20101]],[[12038,12038],"mapped",[20108]],[[12039,12039],"mapped",[20128]],[[12040,12040],"mapped",[20154]],[[12041,12041],"mapped",[20799]],[[12042,12042],"mapped",[20837]],[[12043,12043],"mapped",[20843]],[[12044,12044],"mapped",[20866]],[[12045,12045],"mapped",[20886]],[[12046,12046],"mapped",[20907]],[[12047,12047],"mapped",[20960]],[[12048,12048],"mapped",[20981]],[[12049,12049],"mapped",[20992]],[[12050,12050],"mapped",[21147]],[[12051,12051],"mapped",[21241]],[[12052,12052],"mapped",[21269]],[[12053,12053],"mapped",[21274]],[[12054,12054],"mapped",[21304]],[[12055,12055],"mapped",[21313]],[[12056,12056],"mapped",[21340]],[[12057,12057],"mapped",[21353]],[[12058,12058],"mapped",[21378]],[[12059,12059],"mapped",[21430]],[[12060,12060],"mapped",[21448]],[[12061,12061],"mapped",[21475]],[[12062,12062],"mapped",[22231]],[[12063,12063],"mapped",[22303]],[[12064,12064],"mapped",[22763]],[[12065,12065],"mapped",[22786]],[[12066,12066],"mapped",[22794]],[[12067,12067],"mapped",[22805]],[[12068,12068],"mapped",[22823]],[[12069,12069],"mapped",[22899]],[[12070,12070],"mapped",[23376]],[[12071,12071],"mapped",[23424]],[[12072,12072],"mapped",[23544]],[[12073,12073],"mapped",[23567]],[[12074,12074],"mapped",[23586]],[[12075,12075],"mapped",[23608]],[[12076,12076],"mapped",[23662]],[[12077,12077],"mapped",[23665]],[[12078,12078],"mapped",[24027]],[[12079,12079],"mapped",[24037]],[[12080,12080],"mapped",[24049]],[[12081,12081],"mapped",[24062]],[[12082,12082],"mapped",[24178]],[[12083,12083],"mapped",[24186]],[[12084,12084],"mapped",[24191]],[[12085,12085],"mapped",[24308]],[[12086,12086],"mapped",[24318]],[[12087,12087],"mapped",[24331]],[[12088,12088],"mapped",[24339]],[[12089,12089],"mapped",[24400]],[[12090,12090],"mapped",[24417]],[[12091,12091],"mapped",[24435]],[[12092,12092],"mapped",[24515]],[[12093,12093],"mapped",[25096]],[[12094,12094],"mapped",[25142]],[[12095,12095],"mapped",[25163]],[[12096,12096],"mapped",[25903]],[[12097,12097],"mapped",[25908]],[[12098,12098],"mapped",[25991]],[[12099,12099],"mapped",[26007]],[[12100,12100],"mapped",[26020]],[[12101,12101],"mapped",[26041]],[[12102,12102],"mapped",[26080]],[[12103,12103],"mapped",[26085]],[[12104,12104],"mapped",[26352]],[[12105,12105],"mapped",[26376]],[[12106,12106],"mapped",[26408]],[[12107,12107],"mapped",[27424]],[[12108,12108],"mapped",[27490]],[[12109,12109],"mapped",[27513]],[[12110,12110],"mapped",[27571]],[[12111,12111],"mapped",[27595]],[[12112,12112],"mapped",[27604]],[[12113,12113],"mapped",[27611]],[[12114,12114],"mapped",[27663]],[[12115,12115],"mapped",[27668]],[[12116,12116],"mapped",[27700]],[[12117,12117],"mapped",[28779]],[[12118,12118],"mapped",[29226]],[[12119,12119],"mapped",[29238]],[[12120,12120],"mapped",[29243]],[[12121,12121],"mapped",[29247]],[[12122,12122],"mapped",[29255]],[[12123,12123],"mapped",[29273]],[[12124,12124],"mapped",[29275]],[[12125,12125],"mapped",[29356]],[[12126,12126],"mapped",[29572]],[[12127,12127],"mapped",[29577]],[[12128,12128],"mapped",[29916]],[[12129,12129],"mapped",[29926]],[[12130,12130],"mapped",[29976]],[[12131,12131],"mapped",[29983]],[[12132,12132],"mapped",[29992]],[[12133,12133],"mapped",[30000]],[[12134,12134],"mapped",[30091]],[[12135,12135],"mapped",[30098]],[[12136,12136],"mapped",[30326]],[[12137,12137],"mapped",[30333]],[[12138,12138],"mapped",[30382]],[[12139,12139],"mapped",[30399]],[[12140,12140],"mapped",[30446]],[[12141,12141],"mapped",[30683]],[[12142,12142],"mapped",[30690]],[[12143,12143],"mapped",[30707]],[[12144,12144],"mapped",[31034]],[[12145,12145],"mapped",[31160]],[[12146,12146],"mapped",[31166]],[[12147,12147],"mapped",[31348]],[[12148,12148],"mapped",[31435]],[[12149,12149],"mapped",[31481]],[[12150,12150],"mapped",[31859]],[[12151,12151],"mapped",[31992]],[[12152,12152],"mapped",[32566]],[[12153,12153],"mapped",[32593]],[[12154,12154],"mapped",[32650]],[[12155,12155],"mapped",[32701]],[[12156,12156],"mapped",[32769]],[[12157,12157],"mapped",[32780]],[[12158,12158],"mapped",[32786]],[[12159,12159],"mapped",[32819]],[[12160,12160],"mapped",[32895]],[[12161,12161],"mapped",[32905]],[[12162,12162],"mapped",[33251]],[[12163,12163],"mapped",[33258]],[[12164,12164],"mapped",[33267]],[[12165,12165],"mapped",[33276]],[[12166,12166],"mapped",[33292]],[[12167,12167],"mapped",[33307]],[[12168,12168],"mapped",[33311]],[[12169,12169],"mapped",[33390]],[[12170,12170],"mapped",[33394]],[[12171,12171],"mapped",[33400]],[[12172,12172],"mapped",[34381]],[[12173,12173],"mapped",[34411]],[[12174,12174],"mapped",[34880]],[[12175,12175],"mapped",[34892]],[[12176,12176],"mapped",[34915]],[[12177,12177],"mapped",[35198]],[[12178,12178],"mapped",[35211]],[[12179,12179],"mapped",[35282]],[[12180,12180],"mapped",[35328]],[[12181,12181],"mapped",[35895]],[[12182,12182],"mapped",[35910]],[[12183,12183],"mapped",[35925]],[[12184,12184],"mapped",[35960]],[[12185,12185],"mapped",[35997]],[[12186,12186],"mapped",[36196]],[[12187,12187],"mapped",[36208]],[[12188,12188],"mapped",[36275]],[[12189,12189],"mapped",[36523]],[[12190,12190],"mapped",[36554]],[[12191,12191],"mapped",[36763]],[[12192,12192],"mapped",[36784]],[[12193,12193],"mapped",[36789]],[[12194,12194],"mapped",[37009]],[[12195,12195],"mapped",[37193]],[[12196,12196],"mapped",[37318]],[[12197,12197],"mapped",[37324]],[[12198,12198],"mapped",[37329]],[[12199,12199],"mapped",[38263]],[[12200,12200],"mapped",[38272]],[[12201,12201],"mapped",[38428]],[[12202,12202],"mapped",[38582]],[[12203,12203],"mapped",[38585]],[[12204,12204],"mapped",[38632]],[[12205,12205],"mapped",[38737]],[[12206,12206],"mapped",[38750]],[[12207,12207],"mapped",[38754]],[[12208,12208],"mapped",[38761]],[[12209,12209],"mapped",[38859]],[[12210,12210],"mapped",[38893]],[[12211,12211],"mapped",[38899]],[[12212,12212],"mapped",[38913]],[[12213,12213],"mapped",[39080]],[[12214,12214],"mapped",[39131]],[[12215,12215],"mapped",[39135]],[[12216,12216],"mapped",[39318]],[[12217,12217],"mapped",[39321]],[[12218,12218],"mapped",[39340]],[[12219,12219],"mapped",[39592]],[[12220,12220],"mapped",[39640]],[[12221,12221],"mapped",[39647]],[[12222,12222],"mapped",[39717]],[[12223,12223],"mapped",[39727]],[[12224,12224],"mapped",[39730]],[[12225,12225],"mapped",[39740]],[[12226,12226],"mapped",[39770]],[[12227,12227],"mapped",[40165]],[[12228,12228],"mapped",[40565]],[[12229,12229],"mapped",[40575]],[[12230,12230],"mapped",[40613]],[[12231,12231],"mapped",[40635]],[[12232,12232],"mapped",[40643]],[[12233,12233],"mapped",[40653]],[[12234,12234],"mapped",[40657]],[[12235,12235],"mapped",[40697]],[[12236,12236],"mapped",[40701]],[[12237,12237],"mapped",[40718]],[[12238,12238],"mapped",[40723]],[[12239,12239],"mapped",[40736]],[[12240,12240],"mapped",[40763]],[[12241,12241],"mapped",[40778]],[[12242,12242],"mapped",[40786]],[[12243,12243],"mapped",[40845]],[[12244,12244],"mapped",[40860]],[[12245,12245],"mapped",[40864]],[[12246,12271],"disallowed"],[[12272,12283],"disallowed"],[[12284,12287],"disallowed"],[[12288,12288],"disallowed_STD3_mapped",[32]],[[12289,12289],"valid",[],"NV8"],[[12290,12290],"mapped",[46]],[[12291,12292],"valid",[],"NV8"],[[12293,12295],"valid"],[[12296,12329],"valid",[],"NV8"],[[12330,12333],"valid"],[[12334,12341],"valid",[],"NV8"],[[12342,12342],"mapped",[12306]],[[12343,12343],"valid",[],"NV8"],[[12344,12344],"mapped",[21313]],[[12345,12345],"mapped",[21316]],[[12346,12346],"mapped",[21317]],[[12347,12347],"valid",[],"NV8"],[[12348,12348],"valid"],[[12349,12349],"valid",[],"NV8"],[[12350,12350],"valid",[],"NV8"],[[12351,12351],"valid",[],"NV8"],[[12352,12352],"disallowed"],[[12353,12436],"valid"],[[12437,12438],"valid"],[[12439,12440],"disallowed"],[[12441,12442],"valid"],[[12443,12443],"disallowed_STD3_mapped",[32,12441]],[[12444,12444],"disallowed_STD3_mapped",[32,12442]],[[12445,12446],"valid"],[[12447,12447],"mapped",[12424,12426]],[[12448,12448],"valid",[],"NV8"],[[12449,12542],"valid"],[[12543,12543],"mapped",[12467,12488]],[[12544,12548],"disallowed"],[[12549,12588],"valid"],[[12589,12589],"valid"],[[12590,12592],"disallowed"],[[12593,12593],"mapped",[4352]],[[12594,12594],"mapped",[4353]],[[12595,12595],"mapped",[4522]],[[12596,12596],"mapped",[4354]],[[12597,12597],"mapped",[4524]],[[12598,12598],"mapped",[4525]],[[12599,12599],"mapped",[4355]],[[12600,12600],"mapped",[4356]],[[12601,12601],"mapped",[4357]],[[12602,12602],"mapped",[4528]],[[12603,12603],"mapped",[4529]],[[12604,12604],"mapped",[4530]],[[12605,12605],"mapped",[4531]],[[12606,12606],"mapped",[4532]],[[12607,12607],"mapped",[4533]],[[12608,12608],"mapped",[4378]],[[12609,12609],"mapped",[4358]],[[12610,12610],"mapped",[4359]],[[12611,12611],"mapped",[4360]],[[12612,12612],"mapped",[4385]],[[12613,12613],"mapped",[4361]],[[12614,12614],"mapped",[4362]],[[12615,12615],"mapped",[4363]],[[12616,12616],"mapped",[4364]],[[12617,12617],"mapped",[4365]],[[12618,12618],"mapped",[4366]],[[12619,12619],"mapped",[4367]],[[12620,12620],"mapped",[4368]],[[12621,12621],"mapped",[4369]],[[12622,12622],"mapped",[4370]],[[12623,12623],"mapped",[4449]],[[12624,12624],"mapped",[4450]],[[12625,12625],"mapped",[4451]],[[12626,12626],"mapped",[4452]],[[12627,12627],"mapped",[4453]],[[12628,12628],"mapped",[4454]],[[12629,12629],"mapped",[4455]],[[12630,12630],"mapped",[4456]],[[12631,12631],"mapped",[4457]],[[12632,12632],"mapped",[4458]],[[12633,12633],"mapped",[4459]],[[12634,12634],"mapped",[4460]],[[12635,12635],"mapped",[4461]],[[12636,12636],"mapped",[4462]],[[12637,12637],"mapped",[4463]],[[12638,12638],"mapped",[4464]],[[12639,12639],"mapped",[4465]],[[12640,12640],"mapped",[4466]],[[12641,12641],"mapped",[4467]],[[12642,12642],"mapped",[4468]],[[12643,12643],"mapped",[4469]],[[12644,12644],"disallowed"],[[12645,12645],"mapped",[4372]],[[12646,12646],"mapped",[4373]],[[12647,12647],"mapped",[4551]],[[12648,12648],"mapped",[4552]],[[12649,12649],"mapped",[4556]],[[12650,12650],"mapped",[4558]],[[12651,12651],"mapped",[4563]],[[12652,12652],"mapped",[4567]],[[12653,12653],"mapped",[4569]],[[12654,12654],"mapped",[4380]],[[12655,12655],"mapped",[4573]],[[12656,12656],"mapped",[4575]],[[12657,12657],"mapped",[4381]],[[12658,12658],"mapped",[4382]],[[12659,12659],"mapped",[4384]],[[12660,12660],"mapped",[4386]],[[12661,12661],"mapped",[4387]],[[12662,12662],"mapped",[4391]],[[12663,12663],"mapped",[4393]],[[12664,12664],"mapped",[4395]],[[12665,12665],"mapped",[4396]],[[12666,12666],"mapped",[4397]],[[12667,12667],"mapped",[4398]],[[12668,12668],"mapped",[4399]],[[12669,12669],"mapped",[4402]],[[12670,12670],"mapped",[4406]],[[12671,12671],"mapped",[4416]],[[12672,12672],"mapped",[4423]],[[12673,12673],"mapped",[4428]],[[12674,12674],"mapped",[4593]],[[12675,12675],"mapped",[4594]],[[12676,12676],"mapped",[4439]],[[12677,12677],"mapped",[4440]],[[12678,12678],"mapped",[4441]],[[12679,12679],"mapped",[4484]],[[12680,12680],"mapped",[4485]],[[12681,12681],"mapped",[4488]],[[12682,12682],"mapped",[4497]],[[12683,12683],"mapped",[4498]],[[12684,12684],"mapped",[4500]],[[12685,12685],"mapped",[4510]],[[12686,12686],"mapped",[4513]],[[12687,12687],"disallowed"],[[12688,12689],"valid",[],"NV8"],[[12690,12690],"mapped",[19968]],[[12691,12691],"mapped",[20108]],[[12692,12692],"mapped",[19977]],[[12693,12693],"mapped",[22235]],[[12694,12694],"mapped",[19978]],[[12695,12695],"mapped",[20013]],[[12696,12696],"mapped",[19979]],[[12697,12697],"mapped",[30002]],[[12698,12698],"mapped",[20057]],[[12699,12699],"mapped",[19993]],[[12700,12700],"mapped",[19969]],[[12701,12701],"mapped",[22825]],[[12702,12702],"mapped",[22320]],[[12703,12703],"mapped",[20154]],[[12704,12727],"valid"],[[12728,12730],"valid"],[[12731,12735],"disallowed"],[[12736,12751],"valid",[],"NV8"],[[12752,12771],"valid",[],"NV8"],[[12772,12783],"disallowed"],[[12784,12799],"valid"],[[12800,12800],"disallowed_STD3_mapped",[40,4352,41]],[[12801,12801],"disallowed_STD3_mapped",[40,4354,41]],[[12802,12802],"disallowed_STD3_mapped",[40,4355,41]],[[12803,12803],"disallowed_STD3_mapped",[40,4357,41]],[[12804,12804],"disallowed_STD3_mapped",[40,4358,41]],[[12805,12805],"disallowed_STD3_mapped",[40,4359,41]],[[12806,12806],"disallowed_STD3_mapped",[40,4361,41]],[[12807,12807],"disallowed_STD3_mapped",[40,4363,41]],[[12808,12808],"disallowed_STD3_mapped",[40,4364,41]],[[12809,12809],"disallowed_STD3_mapped",[40,4366,41]],[[12810,12810],"disallowed_STD3_mapped",[40,4367,41]],[[12811,12811],"disallowed_STD3_mapped",[40,4368,41]],[[12812,12812],"disallowed_STD3_mapped",[40,4369,41]],[[12813,12813],"disallowed_STD3_mapped",[40,4370,41]],[[12814,12814],"disallowed_STD3_mapped",[40,44032,41]],[[12815,12815],"disallowed_STD3_mapped",[40,45208,41]],[[12816,12816],"disallowed_STD3_mapped",[40,45796,41]],[[12817,12817],"disallowed_STD3_mapped",[40,46972,41]],[[12818,12818],"disallowed_STD3_mapped",[40,47560,41]],[[12819,12819],"disallowed_STD3_mapped",[40,48148,41]],[[12820,12820],"disallowed_STD3_mapped",[40,49324,41]],[[12821,12821],"disallowed_STD3_mapped",[40,50500,41]],[[12822,12822],"disallowed_STD3_mapped",[40,51088,41]],[[12823,12823],"disallowed_STD3_mapped",[40,52264,41]],[[12824,12824],"disallowed_STD3_mapped",[40,52852,41]],[[12825,12825],"disallowed_STD3_mapped",[40,53440,41]],[[12826,12826],"disallowed_STD3_mapped",[40,54028,41]],[[12827,12827],"disallowed_STD3_mapped",[40,54616,41]],[[12828,12828],"disallowed_STD3_mapped",[40,51452,41]],[[12829,12829],"disallowed_STD3_mapped",[40,50724,51204,41]],[[12830,12830],"disallowed_STD3_mapped",[40,50724,54980,41]],[[12831,12831],"disallowed"],[[12832,12832],"disallowed_STD3_mapped",[40,19968,41]],[[12833,12833],"disallowed_STD3_mapped",[40,20108,41]],[[12834,12834],"disallowed_STD3_mapped",[40,19977,41]],[[12835,12835],"disallowed_STD3_mapped",[40,22235,41]],[[12836,12836],"disallowed_STD3_mapped",[40,20116,41]],[[12837,12837],"disallowed_STD3_mapped",[40,20845,41]],[[12838,12838],"disallowed_STD3_mapped",[40,19971,41]],[[12839,12839],"disallowed_STD3_mapped",[40,20843,41]],[[12840,12840],"disallowed_STD3_mapped",[40,20061,41]],[[12841,12841],"disallowed_STD3_mapped",[40,21313,41]],[[12842,12842],"disallowed_STD3_mapped",[40,26376,41]],[[12843,12843],"disallowed_STD3_mapped",[40,28779,41]],[[12844,12844],"disallowed_STD3_mapped",[40,27700,41]],[[12845,12845],"disallowed_STD3_mapped",[40,26408,41]],[[12846,12846],"disallowed_STD3_mapped",[40,37329,41]],[[12847,12847],"disallowed_STD3_mapped",[40,22303,41]],[[12848,12848],"disallowed_STD3_mapped",[40,26085,41]],[[12849,12849],"disallowed_STD3_mapped",[40,26666,41]],[[12850,12850],"disallowed_STD3_mapped",[40,26377,41]],[[12851,12851],"disallowed_STD3_mapped",[40,31038,41]],[[12852,12852],"disallowed_STD3_mapped",[40,21517,41]],[[12853,12853],"disallowed_STD3_mapped",[40,29305,41]],[[12854,12854],"disallowed_STD3_mapped",[40,36001,41]],[[12855,12855],"disallowed_STD3_mapped",[40,31069,41]],[[12856,12856],"disallowed_STD3_mapped",[40,21172,41]],[[12857,12857],"disallowed_STD3_mapped",[40,20195,41]],[[12858,12858],"disallowed_STD3_mapped",[40,21628,41]],[[12859,12859],"disallowed_STD3_mapped",[40,23398,41]],[[12860,12860],"disallowed_STD3_mapped",[40,30435,41]],[[12861,12861],"disallowed_STD3_mapped",[40,20225,41]],[[12862,12862],"disallowed_STD3_mapped",[40,36039,41]],[[12863,12863],"disallowed_STD3_mapped",[40,21332,41]],[[12864,12864],"disallowed_STD3_mapped",[40,31085,41]],[[12865,12865],"disallowed_STD3_mapped",[40,20241,41]],[[12866,12866],"disallowed_STD3_mapped",[40,33258,41]],[[12867,12867],"disallowed_STD3_mapped",[40,33267,41]],[[12868,12868],"mapped",[21839]],[[12869,12869],"mapped",[24188]],[[12870,12870],"mapped",[25991]],[[12871,12871],"mapped",[31631]],[[12872,12879],"valid",[],"NV8"],[[12880,12880],"mapped",[112,116,101]],[[12881,12881],"mapped",[50,49]],[[12882,12882],"mapped",[50,50]],[[12883,12883],"mapped",[50,51]],[[12884,12884],"mapped",[50,52]],[[12885,12885],"mapped",[50,53]],[[12886,12886],"mapped",[50,54]],[[12887,12887],"mapped",[50,55]],[[12888,12888],"mapped",[50,56]],[[12889,12889],"mapped",[50,57]],[[12890,12890],"mapped",[51,48]],[[12891,12891],"mapped",[51,49]],[[12892,12892],"mapped",[51,50]],[[12893,12893],"mapped",[51,51]],[[12894,12894],"mapped",[51,52]],[[12895,12895],"mapped",[51,53]],[[12896,12896],"mapped",[4352]],[[12897,12897],"mapped",[4354]],[[12898,12898],"mapped",[4355]],[[12899,12899],"mapped",[4357]],[[12900,12900],"mapped",[4358]],[[12901,12901],"mapped",[4359]],[[12902,12902],"mapped",[4361]],[[12903,12903],"mapped",[4363]],[[12904,12904],"mapped",[4364]],[[12905,12905],"mapped",[4366]],[[12906,12906],"mapped",[4367]],[[12907,12907],"mapped",[4368]],[[12908,12908],"mapped",[4369]],[[12909,12909],"mapped",[4370]],[[12910,12910],"mapped",[44032]],[[12911,12911],"mapped",[45208]],[[12912,12912],"mapped",[45796]],[[12913,12913],"mapped",[46972]],[[12914,12914],"mapped",[47560]],[[12915,12915],"mapped",[48148]],[[12916,12916],"mapped",[49324]],[[12917,12917],"mapped",[50500]],[[12918,12918],"mapped",[51088]],[[12919,12919],"mapped",[52264]],[[12920,12920],"mapped",[52852]],[[12921,12921],"mapped",[53440]],[[12922,12922],"mapped",[54028]],[[12923,12923],"mapped",[54616]],[[12924,12924],"mapped",[52280,44256]],[[12925,12925],"mapped",[51452,51032]],[[12926,12926],"mapped",[50864]],[[12927,12927],"valid",[],"NV8"],[[12928,12928],"mapped",[19968]],[[12929,12929],"mapped",[20108]],[[12930,12930],"mapped",[19977]],[[12931,12931],"mapped",[22235]],[[12932,12932],"mapped",[20116]],[[12933,12933],"mapped",[20845]],[[12934,12934],"mapped",[19971]],[[12935,12935],"mapped",[20843]],[[12936,12936],"mapped",[20061]],[[12937,12937],"mapped",[21313]],[[12938,12938],"mapped",[26376]],[[12939,12939],"mapped",[28779]],[[12940,12940],"mapped",[27700]],[[12941,12941],"mapped",[26408]],[[12942,12942],"mapped",[37329]],[[12943,12943],"mapped",[22303]],[[12944,12944],"mapped",[26085]],[[12945,12945],"mapped",[26666]],[[12946,12946],"mapped",[26377]],[[12947,12947],"mapped",[31038]],[[12948,12948],"mapped",[21517]],[[12949,12949],"mapped",[29305]],[[12950,12950],"mapped",[36001]],[[12951,12951],"mapped",[31069]],[[12952,12952],"mapped",[21172]],[[12953,12953],"mapped",[31192]],[[12954,12954],"mapped",[30007]],[[12955,12955],"mapped",[22899]],[[12956,12956],"mapped",[36969]],[[12957,12957],"mapped",[20778]],[[12958,12958],"mapped",[21360]],[[12959,12959],"mapped",[27880]],[[12960,12960],"mapped",[38917]],[[12961,12961],"mapped",[20241]],[[12962,12962],"mapped",[20889]],[[12963,12963],"mapped",[27491]],[[12964,12964],"mapped",[19978]],[[12965,12965],"mapped",[20013]],[[12966,12966],"mapped",[19979]],[[12967,12967],"mapped",[24038]],[[12968,12968],"mapped",[21491]],[[12969,12969],"mapped",[21307]],[[12970,12970],"mapped",[23447]],[[12971,12971],"mapped",[23398]],[[12972,12972],"mapped",[30435]],[[12973,12973],"mapped",[20225]],[[12974,12974],"mapped",[36039]],[[12975,12975],"mapped",[21332]],[[12976,12976],"mapped",[22812]],[[12977,12977],"mapped",[51,54]],[[12978,12978],"mapped",[51,55]],[[12979,12979],"mapped",[51,56]],[[12980,12980],"mapped",[51,57]],[[12981,12981],"mapped",[52,48]],[[12982,12982],"mapped",[52,49]],[[12983,12983],"mapped",[52,50]],[[12984,12984],"mapped",[52,51]],[[12985,12985],"mapped",[52,52]],[[12986,12986],"mapped",[52,53]],[[12987,12987],"mapped",[52,54]],[[12988,12988],"mapped",[52,55]],[[12989,12989],"mapped",[52,56]],[[12990,12990],"mapped",[52,57]],[[12991,12991],"mapped",[53,48]],[[12992,12992],"mapped",[49,26376]],[[12993,12993],"mapped",[50,26376]],[[12994,12994],"mapped",[51,26376]],[[12995,12995],"mapped",[52,26376]],[[12996,12996],"mapped",[53,26376]],[[12997,12997],"mapped",[54,26376]],[[12998,12998],"mapped",[55,26376]],[[12999,12999],"mapped",[56,26376]],[[13000,13000],"mapped",[57,26376]],[[13001,13001],"mapped",[49,48,26376]],[[13002,13002],"mapped",[49,49,26376]],[[13003,13003],"mapped",[49,50,26376]],[[13004,13004],"mapped",[104,103]],[[13005,13005],"mapped",[101,114,103]],[[13006,13006],"mapped",[101,118]],[[13007,13007],"mapped",[108,116,100]],[[13008,13008],"mapped",[12450]],[[13009,13009],"mapped",[12452]],[[13010,13010],"mapped",[12454]],[[13011,13011],"mapped",[12456]],[[13012,13012],"mapped",[12458]],[[13013,13013],"mapped",[12459]],[[13014,13014],"mapped",[12461]],[[13015,13015],"mapped",[12463]],[[13016,13016],"mapped",[12465]],[[13017,13017],"mapped",[12467]],[[13018,13018],"mapped",[12469]],[[13019,13019],"mapped",[12471]],[[13020,13020],"mapped",[12473]],[[13021,13021],"mapped",[12475]],[[13022,13022],"mapped",[12477]],[[13023,13023],"mapped",[12479]],[[13024,13024],"mapped",[12481]],[[13025,13025],"mapped",[12484]],[[13026,13026],"mapped",[12486]],[[13027,13027],"mapped",[12488]],[[13028,13028],"mapped",[12490]],[[13029,13029],"mapped",[12491]],[[13030,13030],"mapped",[12492]],[[13031,13031],"mapped",[12493]],[[13032,13032],"mapped",[12494]],[[13033,13033],"mapped",[12495]],[[13034,13034],"mapped",[12498]],[[13035,13035],"mapped",[12501]],[[13036,13036],"mapped",[12504]],[[13037,13037],"mapped",[12507]],[[13038,13038],"mapped",[12510]],[[13039,13039],"mapped",[12511]],[[13040,13040],"mapped",[12512]],[[13041,13041],"mapped",[12513]],[[13042,13042],"mapped",[12514]],[[13043,13043],"mapped",[12516]],[[13044,13044],"mapped",[12518]],[[13045,13045],"mapped",[12520]],[[13046,13046],"mapped",[12521]],[[13047,13047],"mapped",[12522]],[[13048,13048],"mapped",[12523]],[[13049,13049],"mapped",[12524]],[[13050,13050],"mapped",[12525]],[[13051,13051],"mapped",[12527]],[[13052,13052],"mapped",[12528]],[[13053,13053],"mapped",[12529]],[[13054,13054],"mapped",[12530]],[[13055,13055],"disallowed"],[[13056,13056],"mapped",[12450,12497,12540,12488]],[[13057,13057],"mapped",[12450,12523,12501,12449]],[[13058,13058],"mapped",[12450,12531,12506,12450]],[[13059,13059],"mapped",[12450,12540,12523]],[[13060,13060],"mapped",[12452,12491,12531,12464]],[[13061,13061],"mapped",[12452,12531,12481]],[[13062,13062],"mapped",[12454,12457,12531]],[[13063,13063],"mapped",[12456,12473,12463,12540,12489]],[[13064,13064],"mapped",[12456,12540,12459,12540]],[[13065,13065],"mapped",[12458,12531,12473]],[[13066,13066],"mapped",[12458,12540,12512]],[[13067,13067],"mapped",[12459,12452,12522]],[[13068,13068],"mapped",[12459,12521,12483,12488]],[[13069,13069],"mapped",[12459,12525,12522,12540]],[[13070,13070],"mapped",[12460,12525,12531]],[[13071,13071],"mapped",[12460,12531,12510]],[[13072,13072],"mapped",[12462,12460]],[[13073,13073],"mapped",[12462,12491,12540]],[[13074,13074],"mapped",[12461,12517,12522,12540]],[[13075,13075],"mapped",[12462,12523,12480,12540]],[[13076,13076],"mapped",[12461,12525]],[[13077,13077],"mapped",[12461,12525,12464,12521,12512]],[[13078,13078],"mapped",[12461,12525,12513,12540,12488,12523]],[[13079,13079],"mapped",[12461,12525,12527,12483,12488]],[[13080,13080],"mapped",[12464,12521,12512]],[[13081,13081],"mapped",[12464,12521,12512,12488,12531]],[[13082,13082],"mapped",[12463,12523,12476,12452,12525]],[[13083,13083],"mapped",[12463,12525,12540,12493]],[[13084,13084],"mapped",[12465,12540,12473]],[[13085,13085],"mapped",[12467,12523,12490]],[[13086,13086],"mapped",[12467,12540,12509]],[[13087,13087],"mapped",[12469,12452,12463,12523]],[[13088,13088],"mapped",[12469,12531,12481,12540,12512]],[[13089,13089],"mapped",[12471,12522,12531,12464]],[[13090,13090],"mapped",[12475,12531,12481]],[[13091,13091],"mapped",[12475,12531,12488]],[[13092,13092],"mapped",[12480,12540,12473]],[[13093,13093],"mapped",[12487,12471]],[[13094,13094],"mapped",[12489,12523]],[[13095,13095],"mapped",[12488,12531]],[[13096,13096],"mapped",[12490,12494]],[[13097,13097],"mapped",[12494,12483,12488]],[[13098,13098],"mapped",[12495,12452,12484]],[[13099,13099],"mapped",[12497,12540,12475,12531,12488]],[[13100,13100],"mapped",[12497,12540,12484]],[[13101,13101],"mapped",[12496,12540,12524,12523]],[[13102,13102],"mapped",[12500,12450,12473,12488,12523]],[[13103,13103],"mapped",[12500,12463,12523]],[[13104,13104],"mapped",[12500,12467]],[[13105,13105],"mapped",[12499,12523]],[[13106,13106],"mapped",[12501,12449,12521,12483,12489]],[[13107,13107],"mapped",[12501,12451,12540,12488]],[[13108,13108],"mapped",[12502,12483,12471,12455,12523]],[[13109,13109],"mapped",[12501,12521,12531]],[[13110,13110],"mapped",[12504,12463,12479,12540,12523]],[[13111,13111],"mapped",[12506,12477]],[[13112,13112],"mapped",[12506,12491,12498]],[[13113,13113],"mapped",[12504,12523,12484]],[[13114,13114],"mapped",[12506,12531,12473]],[[13115,13115],"mapped",[12506,12540,12472]],[[13116,13116],"mapped",[12505,12540,12479]],[[13117,13117],"mapped",[12509,12452,12531,12488]],[[13118,13118],"mapped",[12508,12523,12488]],[[13119,13119],"mapped",[12507,12531]],[[13120,13120],"mapped",[12509,12531,12489]],[[13121,13121],"mapped",[12507,12540,12523]],[[13122,13122],"mapped",[12507,12540,12531]],[[13123,13123],"mapped",[12510,12452,12463,12525]],[[13124,13124],"mapped",[12510,12452,12523]],[[13125,13125],"mapped",[12510,12483,12495]],[[13126,13126],"mapped",[12510,12523,12463]],[[13127,13127],"mapped",[12510,12531,12471,12519,12531]],[[13128,13128],"mapped",[12511,12463,12525,12531]],[[13129,13129],"mapped",[12511,12522]],[[13130,13130],"mapped",[12511,12522,12496,12540,12523]],[[13131,13131],"mapped",[12513,12460]],[[13132,13132],"mapped",[12513,12460,12488,12531]],[[13133,13133],"mapped",[12513,12540,12488,12523]],[[13134,13134],"mapped",[12516,12540,12489]],[[13135,13135],"mapped",[12516,12540,12523]],[[13136,13136],"mapped",[12518,12450,12531]],[[13137,13137],"mapped",[12522,12483,12488,12523]],[[13138,13138],"mapped",[12522,12521]],[[13139,13139],"mapped",[12523,12500,12540]],[[13140,13140],"mapped",[12523,12540,12502,12523]],[[13141,13141],"mapped",[12524,12512]],[[13142,13142],"mapped",[12524,12531,12488,12466,12531]],[[13143,13143],"mapped",[12527,12483,12488]],[[13144,13144],"mapped",[48,28857]],[[13145,13145],"mapped",[49,28857]],[[13146,13146],"mapped",[50,28857]],[[13147,13147],"mapped",[51,28857]],[[13148,13148],"mapped",[52,28857]],[[13149,13149],"mapped",[53,28857]],[[13150,13150],"mapped",[54,28857]],[[13151,13151],"mapped",[55,28857]],[[13152,13152],"mapped",[56,28857]],[[13153,13153],"mapped",[57,28857]],[[13154,13154],"mapped",[49,48,28857]],[[13155,13155],"mapped",[49,49,28857]],[[13156,13156],"mapped",[49,50,28857]],[[13157,13157],"mapped",[49,51,28857]],[[13158,13158],"mapped",[49,52,28857]],[[13159,13159],"mapped",[49,53,28857]],[[13160,13160],"mapped",[49,54,28857]],[[13161,13161],"mapped",[49,55,28857]],[[13162,13162],"mapped",[49,56,28857]],[[13163,13163],"mapped",[49,57,28857]],[[13164,13164],"mapped",[50,48,28857]],[[13165,13165],"mapped",[50,49,28857]],[[13166,13166],"mapped",[50,50,28857]],[[13167,13167],"mapped",[50,51,28857]],[[13168,13168],"mapped",[50,52,28857]],[[13169,13169],"mapped",[104,112,97]],[[13170,13170],"mapped",[100,97]],[[13171,13171],"mapped",[97,117]],[[13172,13172],"mapped",[98,97,114]],[[13173,13173],"mapped",[111,118]],[[13174,13174],"mapped",[112,99]],[[13175,13175],"mapped",[100,109]],[[13176,13176],"mapped",[100,109,50]],[[13177,13177],"mapped",[100,109,51]],[[13178,13178],"mapped",[105,117]],[[13179,13179],"mapped",[24179,25104]],[[13180,13180],"mapped",[26157,21644]],[[13181,13181],"mapped",[22823,27491]],[[13182,13182],"mapped",[26126,27835]],[[13183,13183],"mapped",[26666,24335,20250,31038]],[[13184,13184],"mapped",[112,97]],[[13185,13185],"mapped",[110,97]],[[13186,13186],"mapped",[956,97]],[[13187,13187],"mapped",[109,97]],[[13188,13188],"mapped",[107,97]],[[13189,13189],"mapped",[107,98]],[[13190,13190],"mapped",[109,98]],[[13191,13191],"mapped",[103,98]],[[13192,13192],"mapped",[99,97,108]],[[13193,13193],"mapped",[107,99,97,108]],[[13194,13194],"mapped",[112,102]],[[13195,13195],"mapped",[110,102]],[[13196,13196],"mapped",[956,102]],[[13197,13197],"mapped",[956,103]],[[13198,13198],"mapped",[109,103]],[[13199,13199],"mapped",[107,103]],[[13200,13200],"mapped",[104,122]],[[13201,13201],"mapped",[107,104,122]],[[13202,13202],"mapped",[109,104,122]],[[13203,13203],"mapped",[103,104,122]],[[13204,13204],"mapped",[116,104,122]],[[13205,13205],"mapped",[956,108]],[[13206,13206],"mapped",[109,108]],[[13207,13207],"mapped",[100,108]],[[13208,13208],"mapped",[107,108]],[[13209,13209],"mapped",[102,109]],[[13210,13210],"mapped",[110,109]],[[13211,13211],"mapped",[956,109]],[[13212,13212],"mapped",[109,109]],[[13213,13213],"mapped",[99,109]],[[13214,13214],"mapped",[107,109]],[[13215,13215],"mapped",[109,109,50]],[[13216,13216],"mapped",[99,109,50]],[[13217,13217],"mapped",[109,50]],[[13218,13218],"mapped",[107,109,50]],[[13219,13219],"mapped",[109,109,51]],[[13220,13220],"mapped",[99,109,51]],[[13221,13221],"mapped",[109,51]],[[13222,13222],"mapped",[107,109,51]],[[13223,13223],"mapped",[109,8725,115]],[[13224,13224],"mapped",[109,8725,115,50]],[[13225,13225],"mapped",[112,97]],[[13226,13226],"mapped",[107,112,97]],[[13227,13227],"mapped",[109,112,97]],[[13228,13228],"mapped",[103,112,97]],[[13229,13229],"mapped",[114,97,100]],[[13230,13230],"mapped",[114,97,100,8725,115]],[[13231,13231],"mapped",[114,97,100,8725,115,50]],[[13232,13232],"mapped",[112,115]],[[13233,13233],"mapped",[110,115]],[[13234,13234],"mapped",[956,115]],[[13235,13235],"mapped",[109,115]],[[13236,13236],"mapped",[112,118]],[[13237,13237],"mapped",[110,118]],[[13238,13238],"mapped",[956,118]],[[13239,13239],"mapped",[109,118]],[[13240,13240],"mapped",[107,118]],[[13241,13241],"mapped",[109,118]],[[13242,13242],"mapped",[112,119]],[[13243,13243],"mapped",[110,119]],[[13244,13244],"mapped",[956,119]],[[13245,13245],"mapped",[109,119]],[[13246,13246],"mapped",[107,119]],[[13247,13247],"mapped",[109,119]],[[13248,13248],"mapped",[107,969]],[[13249,13249],"mapped",[109,969]],[[13250,13250],"disallowed"],[[13251,13251],"mapped",[98,113]],[[13252,13252],"mapped",[99,99]],[[13253,13253],"mapped",[99,100]],[[13254,13254],"mapped",[99,8725,107,103]],[[13255,13255],"disallowed"],[[13256,13256],"mapped",[100,98]],[[13257,13257],"mapped",[103,121]],[[13258,13258],"mapped",[104,97]],[[13259,13259],"mapped",[104,112]],[[13260,13260],"mapped",[105,110]],[[13261,13261],"mapped",[107,107]],[[13262,13262],"mapped",[107,109]],[[13263,13263],"mapped",[107,116]],[[13264,13264],"mapped",[108,109]],[[13265,13265],"mapped",[108,110]],[[13266,13266],"mapped",[108,111,103]],[[13267,13267],"mapped",[108,120]],[[13268,13268],"mapped",[109,98]],[[13269,13269],"mapped",[109,105,108]],[[13270,13270],"mapped",[109,111,108]],[[13271,13271],"mapped",[112,104]],[[13272,13272],"disallowed"],[[13273,13273],"mapped",[112,112,109]],[[13274,13274],"mapped",[112,114]],[[13275,13275],"mapped",[115,114]],[[13276,13276],"mapped",[115,118]],[[13277,13277],"mapped",[119,98]],[[13278,13278],"mapped",[118,8725,109]],[[13279,13279],"mapped",[97,8725,109]],[[13280,13280],"mapped",[49,26085]],[[13281,13281],"mapped",[50,26085]],[[13282,13282],"mapped",[51,26085]],[[13283,13283],"mapped",[52,26085]],[[13284,13284],"mapped",[53,26085]],[[13285,13285],"mapped",[54,26085]],[[13286,13286],"mapped",[55,26085]],[[13287,13287],"mapped",[56,26085]],[[13288,13288],"mapped",[57,26085]],[[13289,13289],"mapped",[49,48,26085]],[[13290,13290],"mapped",[49,49,26085]],[[13291,13291],"mapped",[49,50,26085]],[[13292,13292],"mapped",[49,51,26085]],[[13293,13293],"mapped",[49,52,26085]],[[13294,13294],"mapped",[49,53,26085]],[[13295,13295],"mapped",[49,54,26085]],[[13296,13296],"mapped",[49,55,26085]],[[13297,13297],"mapped",[49,56,26085]],[[13298,13298],"mapped",[49,57,26085]],[[13299,13299],"mapped",[50,48,26085]],[[13300,13300],"mapped",[50,49,26085]],[[13301,13301],"mapped",[50,50,26085]],[[13302,13302],"mapped",[50,51,26085]],[[13303,13303],"mapped",[50,52,26085]],[[13304,13304],"mapped",[50,53,26085]],[[13305,13305],"mapped",[50,54,26085]],[[13306,13306],"mapped",[50,55,26085]],[[13307,13307],"mapped",[50,56,26085]],[[13308,13308],"mapped",[50,57,26085]],[[13309,13309],"mapped",[51,48,26085]],[[13310,13310],"mapped",[51,49,26085]],[[13311,13311],"mapped",[103,97,108]],[[13312,19893],"valid"],[[19894,19903],"disallowed"],[[19904,19967],"valid",[],"NV8"],[[19968,40869],"valid"],[[40870,40891],"valid"],[[40892,40899],"valid"],[[40900,40907],"valid"],[[40908,40908],"valid"],[[40909,40917],"valid"],[[40918,40959],"disallowed"],[[40960,42124],"valid"],[[42125,42127],"disallowed"],[[42128,42145],"valid",[],"NV8"],[[42146,42147],"valid",[],"NV8"],[[42148,42163],"valid",[],"NV8"],[[42164,42164],"valid",[],"NV8"],[[42165,42176],"valid",[],"NV8"],[[42177,42177],"valid",[],"NV8"],[[42178,42180],"valid",[],"NV8"],[[42181,42181],"valid",[],"NV8"],[[42182,42182],"valid",[],"NV8"],[[42183,42191],"disallowed"],[[42192,42237],"valid"],[[42238,42239],"valid",[],"NV8"],[[42240,42508],"valid"],[[42509,42511],"valid",[],"NV8"],[[42512,42539],"valid"],[[42540,42559],"disallowed"],[[42560,42560],"mapped",[42561]],[[42561,42561],"valid"],[[42562,42562],"mapped",[42563]],[[42563,42563],"valid"],[[42564,42564],"mapped",[42565]],[[42565,42565],"valid"],[[42566,42566],"mapped",[42567]],[[42567,42567],"valid"],[[42568,42568],"mapped",[42569]],[[42569,42569],"valid"],[[42570,42570],"mapped",[42571]],[[42571,42571],"valid"],[[42572,42572],"mapped",[42573]],[[42573,42573],"valid"],[[42574,42574],"mapped",[42575]],[[42575,42575],"valid"],[[42576,42576],"mapped",[42577]],[[42577,42577],"valid"],[[42578,42578],"mapped",[42579]],[[42579,42579],"valid"],[[42580,42580],"mapped",[42581]],[[42581,42581],"valid"],[[42582,42582],"mapped",[42583]],[[42583,42583],"valid"],[[42584,42584],"mapped",[42585]],[[42585,42585],"valid"],[[42586,42586],"mapped",[42587]],[[42587,42587],"valid"],[[42588,42588],"mapped",[42589]],[[42589,42589],"valid"],[[42590,42590],"mapped",[42591]],[[42591,42591],"valid"],[[42592,42592],"mapped",[42593]],[[42593,42593],"valid"],[[42594,42594],"mapped",[42595]],[[42595,42595],"valid"],[[42596,42596],"mapped",[42597]],[[42597,42597],"valid"],[[42598,42598],"mapped",[42599]],[[42599,42599],"valid"],[[42600,42600],"mapped",[42601]],[[42601,42601],"valid"],[[42602,42602],"mapped",[42603]],[[42603,42603],"valid"],[[42604,42604],"mapped",[42605]],[[42605,42607],"valid"],[[42608,42611],"valid",[],"NV8"],[[42612,42619],"valid"],[[42620,42621],"valid"],[[42622,42622],"valid",[],"NV8"],[[42623,42623],"valid"],[[42624,42624],"mapped",[42625]],[[42625,42625],"valid"],[[42626,42626],"mapped",[42627]],[[42627,42627],"valid"],[[42628,42628],"mapped",[42629]],[[42629,42629],"valid"],[[42630,42630],"mapped",[42631]],[[42631,42631],"valid"],[[42632,42632],"mapped",[42633]],[[42633,42633],"valid"],[[42634,42634],"mapped",[42635]],[[42635,42635],"valid"],[[42636,42636],"mapped",[42637]],[[42637,42637],"valid"],[[42638,42638],"mapped",[42639]],[[42639,42639],"valid"],[[42640,42640],"mapped",[42641]],[[42641,42641],"valid"],[[42642,42642],"mapped",[42643]],[[42643,42643],"valid"],[[42644,42644],"mapped",[42645]],[[42645,42645],"valid"],[[42646,42646],"mapped",[42647]],[[42647,42647],"valid"],[[42648,42648],"mapped",[42649]],[[42649,42649],"valid"],[[42650,42650],"mapped",[42651]],[[42651,42651],"valid"],[[42652,42652],"mapped",[1098]],[[42653,42653],"mapped",[1100]],[[42654,42654],"valid"],[[42655,42655],"valid"],[[42656,42725],"valid"],[[42726,42735],"valid",[],"NV8"],[[42736,42737],"valid"],[[42738,42743],"valid",[],"NV8"],[[42744,42751],"disallowed"],[[42752,42774],"valid",[],"NV8"],[[42775,42778],"valid"],[[42779,42783],"valid"],[[42784,42785],"valid",[],"NV8"],[[42786,42786],"mapped",[42787]],[[42787,42787],"valid"],[[42788,42788],"mapped",[42789]],[[42789,42789],"valid"],[[42790,42790],"mapped",[42791]],[[42791,42791],"valid"],[[42792,42792],"mapped",[42793]],[[42793,42793],"valid"],[[42794,42794],"mapped",[42795]],[[42795,42795],"valid"],[[42796,42796],"mapped",[42797]],[[42797,42797],"valid"],[[42798,42798],"mapped",[42799]],[[42799,42801],"valid"],[[42802,42802],"mapped",[42803]],[[42803,42803],"valid"],[[42804,42804],"mapped",[42805]],[[42805,42805],"valid"],[[42806,42806],"mapped",[42807]],[[42807,42807],"valid"],[[42808,42808],"mapped",[42809]],[[42809,42809],"valid"],[[42810,42810],"mapped",[42811]],[[42811,42811],"valid"],[[42812,42812],"mapped",[42813]],[[42813,42813],"valid"],[[42814,42814],"mapped",[42815]],[[42815,42815],"valid"],[[42816,42816],"mapped",[42817]],[[42817,42817],"valid"],[[42818,42818],"mapped",[42819]],[[42819,42819],"valid"],[[42820,42820],"mapped",[42821]],[[42821,42821],"valid"],[[42822,42822],"mapped",[42823]],[[42823,42823],"valid"],[[42824,42824],"mapped",[42825]],[[42825,42825],"valid"],[[42826,42826],"mapped",[42827]],[[42827,42827],"valid"],[[42828,42828],"mapped",[42829]],[[42829,42829],"valid"],[[42830,42830],"mapped",[42831]],[[42831,42831],"valid"],[[42832,42832],"mapped",[42833]],[[42833,42833],"valid"],[[42834,42834],"mapped",[42835]],[[42835,42835],"valid"],[[42836,42836],"mapped",[42837]],[[42837,42837],"valid"],[[42838,42838],"mapped",[42839]],[[42839,42839],"valid"],[[42840,42840],"mapped",[42841]],[[42841,42841],"valid"],[[42842,42842],"mapped",[42843]],[[42843,42843],"valid"],[[42844,42844],"mapped",[42845]],[[42845,42845],"valid"],[[42846,42846],"mapped",[42847]],[[42847,42847],"valid"],[[42848,42848],"mapped",[42849]],[[42849,42849],"valid"],[[42850,42850],"mapped",[42851]],[[42851,42851],"valid"],[[42852,42852],"mapped",[42853]],[[42853,42853],"valid"],[[42854,42854],"mapped",[42855]],[[42855,42855],"valid"],[[42856,42856],"mapped",[42857]],[[42857,42857],"valid"],[[42858,42858],"mapped",[42859]],[[42859,42859],"valid"],[[42860,42860],"mapped",[42861]],[[42861,42861],"valid"],[[42862,42862],"mapped",[42863]],[[42863,42863],"valid"],[[42864,42864],"mapped",[42863]],[[42865,42872],"valid"],[[42873,42873],"mapped",[42874]],[[42874,42874],"valid"],[[42875,42875],"mapped",[42876]],[[42876,42876],"valid"],[[42877,42877],"mapped",[7545]],[[42878,42878],"mapped",[42879]],[[42879,42879],"valid"],[[42880,42880],"mapped",[42881]],[[42881,42881],"valid"],[[42882,42882],"mapped",[42883]],[[42883,42883],"valid"],[[42884,42884],"mapped",[42885]],[[42885,42885],"valid"],[[42886,42886],"mapped",[42887]],[[42887,42888],"valid"],[[42889,42890],"valid",[],"NV8"],[[42891,42891],"mapped",[42892]],[[42892,42892],"valid"],[[42893,42893],"mapped",[613]],[[42894,42894],"valid"],[[42895,42895],"valid"],[[42896,42896],"mapped",[42897]],[[42897,42897],"valid"],[[42898,42898],"mapped",[42899]],[[42899,42899],"valid"],[[42900,42901],"valid"],[[42902,42902],"mapped",[42903]],[[42903,42903],"valid"],[[42904,42904],"mapped",[42905]],[[42905,42905],"valid"],[[42906,42906],"mapped",[42907]],[[42907,42907],"valid"],[[42908,42908],"mapped",[42909]],[[42909,42909],"valid"],[[42910,42910],"mapped",[42911]],[[42911,42911],"valid"],[[42912,42912],"mapped",[42913]],[[42913,42913],"valid"],[[42914,42914],"mapped",[42915]],[[42915,42915],"valid"],[[42916,42916],"mapped",[42917]],[[42917,42917],"valid"],[[42918,42918],"mapped",[42919]],[[42919,42919],"valid"],[[42920,42920],"mapped",[42921]],[[42921,42921],"valid"],[[42922,42922],"mapped",[614]],[[42923,42923],"mapped",[604]],[[42924,42924],"mapped",[609]],[[42925,42925],"mapped",[620]],[[42926,42927],"disallowed"],[[42928,42928],"mapped",[670]],[[42929,42929],"mapped",[647]],[[42930,42930],"mapped",[669]],[[42931,42931],"mapped",[43859]],[[42932,42932],"mapped",[42933]],[[42933,42933],"valid"],[[42934,42934],"mapped",[42935]],[[42935,42935],"valid"],[[42936,42998],"disallowed"],[[42999,42999],"valid"],[[43000,43000],"mapped",[295]],[[43001,43001],"mapped",[339]],[[43002,43002],"valid"],[[43003,43007],"valid"],[[43008,43047],"valid"],[[43048,43051],"valid",[],"NV8"],[[43052,43055],"disallowed"],[[43056,43065],"valid",[],"NV8"],[[43066,43071],"disallowed"],[[43072,43123],"valid"],[[43124,43127],"valid",[],"NV8"],[[43128,43135],"disallowed"],[[43136,43204],"valid"],[[43205,43213],"disallowed"],[[43214,43215],"valid",[],"NV8"],[[43216,43225],"valid"],[[43226,43231],"disallowed"],[[43232,43255],"valid"],[[43256,43258],"valid",[],"NV8"],[[43259,43259],"valid"],[[43260,43260],"valid",[],"NV8"],[[43261,43261],"valid"],[[43262,43263],"disallowed"],[[43264,43309],"valid"],[[43310,43311],"valid",[],"NV8"],[[43312,43347],"valid"],[[43348,43358],"disallowed"],[[43359,43359],"valid",[],"NV8"],[[43360,43388],"valid",[],"NV8"],[[43389,43391],"disallowed"],[[43392,43456],"valid"],[[43457,43469],"valid",[],"NV8"],[[43470,43470],"disallowed"],[[43471,43481],"valid"],[[43482,43485],"disallowed"],[[43486,43487],"valid",[],"NV8"],[[43488,43518],"valid"],[[43519,43519],"disallowed"],[[43520,43574],"valid"],[[43575,43583],"disallowed"],[[43584,43597],"valid"],[[43598,43599],"disallowed"],[[43600,43609],"valid"],[[43610,43611],"disallowed"],[[43612,43615],"valid",[],"NV8"],[[43616,43638],"valid"],[[43639,43641],"valid",[],"NV8"],[[43642,43643],"valid"],[[43644,43647],"valid"],[[43648,43714],"valid"],[[43715,43738],"disallowed"],[[43739,43741],"valid"],[[43742,43743],"valid",[],"NV8"],[[43744,43759],"valid"],[[43760,43761],"valid",[],"NV8"],[[43762,43766],"valid"],[[43767,43776],"disallowed"],[[43777,43782],"valid"],[[43783,43784],"disallowed"],[[43785,43790],"valid"],[[43791,43792],"disallowed"],[[43793,43798],"valid"],[[43799,43807],"disallowed"],[[43808,43814],"valid"],[[43815,43815],"disallowed"],[[43816,43822],"valid"],[[43823,43823],"disallowed"],[[43824,43866],"valid"],[[43867,43867],"valid",[],"NV8"],[[43868,43868],"mapped",[42791]],[[43869,43869],"mapped",[43831]],[[43870,43870],"mapped",[619]],[[43871,43871],"mapped",[43858]],[[43872,43875],"valid"],[[43876,43877],"valid"],[[43878,43887],"disallowed"],[[43888,43888],"mapped",[5024]],[[43889,43889],"mapped",[5025]],[[43890,43890],"mapped",[5026]],[[43891,43891],"mapped",[5027]],[[43892,43892],"mapped",[5028]],[[43893,43893],"mapped",[5029]],[[43894,43894],"mapped",[5030]],[[43895,43895],"mapped",[5031]],[[43896,43896],"mapped",[5032]],[[43897,43897],"mapped",[5033]],[[43898,43898],"mapped",[5034]],[[43899,43899],"mapped",[5035]],[[43900,43900],"mapped",[5036]],[[43901,43901],"mapped",[5037]],[[43902,43902],"mapped",[5038]],[[43903,43903],"mapped",[5039]],[[43904,43904],"mapped",[5040]],[[43905,43905],"mapped",[5041]],[[43906,43906],"mapped",[5042]],[[43907,43907],"mapped",[5043]],[[43908,43908],"mapped",[5044]],[[43909,43909],"mapped",[5045]],[[43910,43910],"mapped",[5046]],[[43911,43911],"mapped",[5047]],[[43912,43912],"mapped",[5048]],[[43913,43913],"mapped",[5049]],[[43914,43914],"mapped",[5050]],[[43915,43915],"mapped",[5051]],[[43916,43916],"mapped",[5052]],[[43917,43917],"mapped",[5053]],[[43918,43918],"mapped",[5054]],[[43919,43919],"mapped",[5055]],[[43920,43920],"mapped",[5056]],[[43921,43921],"mapped",[5057]],[[43922,43922],"mapped",[5058]],[[43923,43923],"mapped",[5059]],[[43924,43924],"mapped",[5060]],[[43925,43925],"mapped",[5061]],[[43926,43926],"mapped",[5062]],[[43927,43927],"mapped",[5063]],[[43928,43928],"mapped",[5064]],[[43929,43929],"mapped",[5065]],[[43930,43930],"mapped",[5066]],[[43931,43931],"mapped",[5067]],[[43932,43932],"mapped",[5068]],[[43933,43933],"mapped",[5069]],[[43934,43934],"mapped",[5070]],[[43935,43935],"mapped",[5071]],[[43936,43936],"mapped",[5072]],[[43937,43937],"mapped",[5073]],[[43938,43938],"mapped",[5074]],[[43939,43939],"mapped",[5075]],[[43940,43940],"mapped",[5076]],[[43941,43941],"mapped",[5077]],[[43942,43942],"mapped",[5078]],[[43943,43943],"mapped",[5079]],[[43944,43944],"mapped",[5080]],[[43945,43945],"mapped",[5081]],[[43946,43946],"mapped",[5082]],[[43947,43947],"mapped",[5083]],[[43948,43948],"mapped",[5084]],[[43949,43949],"mapped",[5085]],[[43950,43950],"mapped",[5086]],[[43951,43951],"mapped",[5087]],[[43952,43952],"mapped",[5088]],[[43953,43953],"mapped",[5089]],[[43954,43954],"mapped",[5090]],[[43955,43955],"mapped",[5091]],[[43956,43956],"mapped",[5092]],[[43957,43957],"mapped",[5093]],[[43958,43958],"mapped",[5094]],[[43959,43959],"mapped",[5095]],[[43960,43960],"mapped",[5096]],[[43961,43961],"mapped",[5097]],[[43962,43962],"mapped",[5098]],[[43963,43963],"mapped",[5099]],[[43964,43964],"mapped",[5100]],[[43965,43965],"mapped",[5101]],[[43966,43966],"mapped",[5102]],[[43967,43967],"mapped",[5103]],[[43968,44010],"valid"],[[44011,44011],"valid",[],"NV8"],[[44012,44013],"valid"],[[44014,44015],"disallowed"],[[44016,44025],"valid"],[[44026,44031],"disallowed"],[[44032,55203],"valid"],[[55204,55215],"disallowed"],[[55216,55238],"valid",[],"NV8"],[[55239,55242],"disallowed"],[[55243,55291],"valid",[],"NV8"],[[55292,55295],"disallowed"],[[55296,57343],"disallowed"],[[57344,63743],"disallowed"],[[63744,63744],"mapped",[35912]],[[63745,63745],"mapped",[26356]],[[63746,63746],"mapped",[36554]],[[63747,63747],"mapped",[36040]],[[63748,63748],"mapped",[28369]],[[63749,63749],"mapped",[20018]],[[63750,63750],"mapped",[21477]],[[63751,63752],"mapped",[40860]],[[63753,63753],"mapped",[22865]],[[63754,63754],"mapped",[37329]],[[63755,63755],"mapped",[21895]],[[63756,63756],"mapped",[22856]],[[63757,63757],"mapped",[25078]],[[63758,63758],"mapped",[30313]],[[63759,63759],"mapped",[32645]],[[63760,63760],"mapped",[34367]],[[63761,63761],"mapped",[34746]],[[63762,63762],"mapped",[35064]],[[63763,63763],"mapped",[37007]],[[63764,63764],"mapped",[27138]],[[63765,63765],"mapped",[27931]],[[63766,63766],"mapped",[28889]],[[63767,63767],"mapped",[29662]],[[63768,63768],"mapped",[33853]],[[63769,63769],"mapped",[37226]],[[63770,63770],"mapped",[39409]],[[63771,63771],"mapped",[20098]],[[63772,63772],"mapped",[21365]],[[63773,63773],"mapped",[27396]],[[63774,63774],"mapped",[29211]],[[63775,63775],"mapped",[34349]],[[63776,63776],"mapped",[40478]],[[63777,63777],"mapped",[23888]],[[63778,63778],"mapped",[28651]],[[63779,63779],"mapped",[34253]],[[63780,63780],"mapped",[35172]],[[63781,63781],"mapped",[25289]],[[63782,63782],"mapped",[33240]],[[63783,63783],"mapped",[34847]],[[63784,63784],"mapped",[24266]],[[63785,63785],"mapped",[26391]],[[63786,63786],"mapped",[28010]],[[63787,63787],"mapped",[29436]],[[63788,63788],"mapped",[37070]],[[63789,63789],"mapped",[20358]],[[63790,63790],"mapped",[20919]],[[63791,63791],"mapped",[21214]],[[63792,63792],"mapped",[25796]],[[63793,63793],"mapped",[27347]],[[63794,63794],"mapped",[29200]],[[63795,63795],"mapped",[30439]],[[63796,63796],"mapped",[32769]],[[63797,63797],"mapped",[34310]],[[63798,63798],"mapped",[34396]],[[63799,63799],"mapped",[36335]],[[63800,63800],"mapped",[38706]],[[63801,63801],"mapped",[39791]],[[63802,63802],"mapped",[40442]],[[63803,63803],"mapped",[30860]],[[63804,63804],"mapped",[31103]],[[63805,63805],"mapped",[32160]],[[63806,63806],"mapped",[33737]],[[63807,63807],"mapped",[37636]],[[63808,63808],"mapped",[40575]],[[63809,63809],"mapped",[35542]],[[63810,63810],"mapped",[22751]],[[63811,63811],"mapped",[24324]],[[63812,63812],"mapped",[31840]],[[63813,63813],"mapped",[32894]],[[63814,63814],"mapped",[29282]],[[63815,63815],"mapped",[30922]],[[63816,63816],"mapped",[36034]],[[63817,63817],"mapped",[38647]],[[63818,63818],"mapped",[22744]],[[63819,63819],"mapped",[23650]],[[63820,63820],"mapped",[27155]],[[63821,63821],"mapped",[28122]],[[63822,63822],"mapped",[28431]],[[63823,63823],"mapped",[32047]],[[63824,63824],"mapped",[32311]],[[63825,63825],"mapped",[38475]],[[63826,63826],"mapped",[21202]],[[63827,63827],"mapped",[32907]],[[63828,63828],"mapped",[20956]],[[63829,63829],"mapped",[20940]],[[63830,63830],"mapped",[31260]],[[63831,63831],"mapped",[32190]],[[63832,63832],"mapped",[33777]],[[63833,63833],"mapped",[38517]],[[63834,63834],"mapped",[35712]],[[63835,63835],"mapped",[25295]],[[63836,63836],"mapped",[27138]],[[63837,63837],"mapped",[35582]],[[63838,63838],"mapped",[20025]],[[63839,63839],"mapped",[23527]],[[63840,63840],"mapped",[24594]],[[63841,63841],"mapped",[29575]],[[63842,63842],"mapped",[30064]],[[63843,63843],"mapped",[21271]],[[63844,63844],"mapped",[30971]],[[63845,63845],"mapped",[20415]],[[63846,63846],"mapped",[24489]],[[63847,63847],"mapped",[19981]],[[63848,63848],"mapped",[27852]],[[63849,63849],"mapped",[25976]],[[63850,63850],"mapped",[32034]],[[63851,63851],"mapped",[21443]],[[63852,63852],"mapped",[22622]],[[63853,63853],"mapped",[30465]],[[63854,63854],"mapped",[33865]],[[63855,63855],"mapped",[35498]],[[63856,63856],"mapped",[27578]],[[63857,63857],"mapped",[36784]],[[63858,63858],"mapped",[27784]],[[63859,63859],"mapped",[25342]],[[63860,63860],"mapped",[33509]],[[63861,63861],"mapped",[25504]],[[63862,63862],"mapped",[30053]],[[63863,63863],"mapped",[20142]],[[63864,63864],"mapped",[20841]],[[63865,63865],"mapped",[20937]],[[63866,63866],"mapped",[26753]],[[63867,63867],"mapped",[31975]],[[63868,63868],"mapped",[33391]],[[63869,63869],"mapped",[35538]],[[63870,63870],"mapped",[37327]],[[63871,63871],"mapped",[21237]],[[63872,63872],"mapped",[21570]],[[63873,63873],"mapped",[22899]],[[63874,63874],"mapped",[24300]],[[63875,63875],"mapped",[26053]],[[63876,63876],"mapped",[28670]],[[63877,63877],"mapped",[31018]],[[63878,63878],"mapped",[38317]],[[63879,63879],"mapped",[39530]],[[63880,63880],"mapped",[40599]],[[63881,63881],"mapped",[40654]],[[63882,63882],"mapped",[21147]],[[63883,63883],"mapped",[26310]],[[63884,63884],"mapped",[27511]],[[63885,63885],"mapped",[36706]],[[63886,63886],"mapped",[24180]],[[63887,63887],"mapped",[24976]],[[63888,63888],"mapped",[25088]],[[63889,63889],"mapped",[25754]],[[63890,63890],"mapped",[28451]],[[63891,63891],"mapped",[29001]],[[63892,63892],"mapped",[29833]],[[63893,63893],"mapped",[31178]],[[63894,63894],"mapped",[32244]],[[63895,63895],"mapped",[32879]],[[63896,63896],"mapped",[36646]],[[63897,63897],"mapped",[34030]],[[63898,63898],"mapped",[36899]],[[63899,63899],"mapped",[37706]],[[63900,63900],"mapped",[21015]],[[63901,63901],"mapped",[21155]],[[63902,63902],"mapped",[21693]],[[63903,63903],"mapped",[28872]],[[63904,63904],"mapped",[35010]],[[63905,63905],"mapped",[35498]],[[63906,63906],"mapped",[24265]],[[63907,63907],"mapped",[24565]],[[63908,63908],"mapped",[25467]],[[63909,63909],"mapped",[27566]],[[63910,63910],"mapped",[31806]],[[63911,63911],"mapped",[29557]],[[63912,63912],"mapped",[20196]],[[63913,63913],"mapped",[22265]],[[63914,63914],"mapped",[23527]],[[63915,63915],"mapped",[23994]],[[63916,63916],"mapped",[24604]],[[63917,63917],"mapped",[29618]],[[63918,63918],"mapped",[29801]],[[63919,63919],"mapped",[32666]],[[63920,63920],"mapped",[32838]],[[63921,63921],"mapped",[37428]],[[63922,63922],"mapped",[38646]],[[63923,63923],"mapped",[38728]],[[63924,63924],"mapped",[38936]],[[63925,63925],"mapped",[20363]],[[63926,63926],"mapped",[31150]],[[63927,63927],"mapped",[37300]],[[63928,63928],"mapped",[38584]],[[63929,63929],"mapped",[24801]],[[63930,63930],"mapped",[20102]],[[63931,63931],"mapped",[20698]],[[63932,63932],"mapped",[23534]],[[63933,63933],"mapped",[23615]],[[63934,63934],"mapped",[26009]],[[63935,63935],"mapped",[27138]],[[63936,63936],"mapped",[29134]],[[63937,63937],"mapped",[30274]],[[63938,63938],"mapped",[34044]],[[63939,63939],"mapped",[36988]],[[63940,63940],"mapped",[40845]],[[63941,63941],"mapped",[26248]],[[63942,63942],"mapped",[38446]],[[63943,63943],"mapped",[21129]],[[63944,63944],"mapped",[26491]],[[63945,63945],"mapped",[26611]],[[63946,63946],"mapped",[27969]],[[63947,63947],"mapped",[28316]],[[63948,63948],"mapped",[29705]],[[63949,63949],"mapped",[30041]],[[63950,63950],"mapped",[30827]],[[63951,63951],"mapped",[32016]],[[63952,63952],"mapped",[39006]],[[63953,63953],"mapped",[20845]],[[63954,63954],"mapped",[25134]],[[63955,63955],"mapped",[38520]],[[63956,63956],"mapped",[20523]],[[63957,63957],"mapped",[23833]],[[63958,63958],"mapped",[28138]],[[63959,63959],"mapped",[36650]],[[63960,63960],"mapped",[24459]],[[63961,63961],"mapped",[24900]],[[63962,63962],"mapped",[26647]],[[63963,63963],"mapped",[29575]],[[63964,63964],"mapped",[38534]],[[63965,63965],"mapped",[21033]],[[63966,63966],"mapped",[21519]],[[63967,63967],"mapped",[23653]],[[63968,63968],"mapped",[26131]],[[63969,63969],"mapped",[26446]],[[63970,63970],"mapped",[26792]],[[63971,63971],"mapped",[27877]],[[63972,63972],"mapped",[29702]],[[63973,63973],"mapped",[30178]],[[63974,63974],"mapped",[32633]],[[63975,63975],"mapped",[35023]],[[63976,63976],"mapped",[35041]],[[63977,63977],"mapped",[37324]],[[63978,63978],"mapped",[38626]],[[63979,63979],"mapped",[21311]],[[63980,63980],"mapped",[28346]],[[63981,63981],"mapped",[21533]],[[63982,63982],"mapped",[29136]],[[63983,63983],"mapped",[29848]],[[63984,63984],"mapped",[34298]],[[63985,63985],"mapped",[38563]],[[63986,63986],"mapped",[40023]],[[63987,63987],"mapped",[40607]],[[63988,63988],"mapped",[26519]],[[63989,63989],"mapped",[28107]],[[63990,63990],"mapped",[33256]],[[63991,63991],"mapped",[31435]],[[63992,63992],"mapped",[31520]],[[63993,63993],"mapped",[31890]],[[63994,63994],"mapped",[29376]],[[63995,63995],"mapped",[28825]],[[63996,63996],"mapped",[35672]],[[63997,63997],"mapped",[20160]],[[63998,63998],"mapped",[33590]],[[63999,63999],"mapped",[21050]],[[64000,64000],"mapped",[20999]],[[64001,64001],"mapped",[24230]],[[64002,64002],"mapped",[25299]],[[64003,64003],"mapped",[31958]],[[64004,64004],"mapped",[23429]],[[64005,64005],"mapped",[27934]],[[64006,64006],"mapped",[26292]],[[64007,64007],"mapped",[36667]],[[64008,64008],"mapped",[34892]],[[64009,64009],"mapped",[38477]],[[64010,64010],"mapped",[35211]],[[64011,64011],"mapped",[24275]],[[64012,64012],"mapped",[20800]],[[64013,64013],"mapped",[21952]],[[64014,64015],"valid"],[[64016,64016],"mapped",[22618]],[[64017,64017],"valid"],[[64018,64018],"mapped",[26228]],[[64019,64020],"valid"],[[64021,64021],"mapped",[20958]],[[64022,64022],"mapped",[29482]],[[64023,64023],"mapped",[30410]],[[64024,64024],"mapped",[31036]],[[64025,64025],"mapped",[31070]],[[64026,64026],"mapped",[31077]],[[64027,64027],"mapped",[31119]],[[64028,64028],"mapped",[38742]],[[64029,64029],"mapped",[31934]],[[64030,64030],"mapped",[32701]],[[64031,64031],"valid"],[[64032,64032],"mapped",[34322]],[[64033,64033],"valid"],[[64034,64034],"mapped",[35576]],[[64035,64036],"valid"],[[64037,64037],"mapped",[36920]],[[64038,64038],"mapped",[37117]],[[64039,64041],"valid"],[[64042,64042],"mapped",[39151]],[[64043,64043],"mapped",[39164]],[[64044,64044],"mapped",[39208]],[[64045,64045],"mapped",[40372]],[[64046,64046],"mapped",[37086]],[[64047,64047],"mapped",[38583]],[[64048,64048],"mapped",[20398]],[[64049,64049],"mapped",[20711]],[[64050,64050],"mapped",[20813]],[[64051,64051],"mapped",[21193]],[[64052,64052],"mapped",[21220]],[[64053,64053],"mapped",[21329]],[[64054,64054],"mapped",[21917]],[[64055,64055],"mapped",[22022]],[[64056,64056],"mapped",[22120]],[[64057,64057],"mapped",[22592]],[[64058,64058],"mapped",[22696]],[[64059,64059],"mapped",[23652]],[[64060,64060],"mapped",[23662]],[[64061,64061],"mapped",[24724]],[[64062,64062],"mapped",[24936]],[[64063,64063],"mapped",[24974]],[[64064,64064],"mapped",[25074]],[[64065,64065],"mapped",[25935]],[[64066,64066],"mapped",[26082]],[[64067,64067],"mapped",[26257]],[[64068,64068],"mapped",[26757]],[[64069,64069],"mapped",[28023]],[[64070,64070],"mapped",[28186]],[[64071,64071],"mapped",[28450]],[[64072,64072],"mapped",[29038]],[[64073,64073],"mapped",[29227]],[[64074,64074],"mapped",[29730]],[[64075,64075],"mapped",[30865]],[[64076,64076],"mapped",[31038]],[[64077,64077],"mapped",[31049]],[[64078,64078],"mapped",[31048]],[[64079,64079],"mapped",[31056]],[[64080,64080],"mapped",[31062]],[[64081,64081],"mapped",[31069]],[[64082,64082],"mapped",[31117]],[[64083,64083],"mapped",[31118]],[[64084,64084],"mapped",[31296]],[[64085,64085],"mapped",[31361]],[[64086,64086],"mapped",[31680]],[[64087,64087],"mapped",[32244]],[[64088,64088],"mapped",[32265]],[[64089,64089],"mapped",[32321]],[[64090,64090],"mapped",[32626]],[[64091,64091],"mapped",[32773]],[[64092,64092],"mapped",[33261]],[[64093,64094],"mapped",[33401]],[[64095,64095],"mapped",[33879]],[[64096,64096],"mapped",[35088]],[[64097,64097],"mapped",[35222]],[[64098,64098],"mapped",[35585]],[[64099,64099],"mapped",[35641]],[[64100,64100],"mapped",[36051]],[[64101,64101],"mapped",[36104]],[[64102,64102],"mapped",[36790]],[[64103,64103],"mapped",[36920]],[[64104,64104],"mapped",[38627]],[[64105,64105],"mapped",[38911]],[[64106,64106],"mapped",[38971]],[[64107,64107],"mapped",[24693]],[[64108,64108],"mapped",[148206]],[[64109,64109],"mapped",[33304]],[[64110,64111],"disallowed"],[[64112,64112],"mapped",[20006]],[[64113,64113],"mapped",[20917]],[[64114,64114],"mapped",[20840]],[[64115,64115],"mapped",[20352]],[[64116,64116],"mapped",[20805]],[[64117,64117],"mapped",[20864]],[[64118,64118],"mapped",[21191]],[[64119,64119],"mapped",[21242]],[[64120,64120],"mapped",[21917]],[[64121,64121],"mapped",[21845]],[[64122,64122],"mapped",[21913]],[[64123,64123],"mapped",[21986]],[[64124,64124],"mapped",[22618]],[[64125,64125],"mapped",[22707]],[[64126,64126],"mapped",[22852]],[[64127,64127],"mapped",[22868]],[[64128,64128],"mapped",[23138]],[[64129,64129],"mapped",[23336]],[[64130,64130],"mapped",[24274]],[[64131,64131],"mapped",[24281]],[[64132,64132],"mapped",[24425]],[[64133,64133],"mapped",[24493]],[[64134,64134],"mapped",[24792]],[[64135,64135],"mapped",[24910]],[[64136,64136],"mapped",[24840]],[[64137,64137],"mapped",[24974]],[[64138,64138],"mapped",[24928]],[[64139,64139],"mapped",[25074]],[[64140,64140],"mapped",[25140]],[[64141,64141],"mapped",[25540]],[[64142,64142],"mapped",[25628]],[[64143,64143],"mapped",[25682]],[[64144,64144],"mapped",[25942]],[[64145,64145],"mapped",[26228]],[[64146,64146],"mapped",[26391]],[[64147,64147],"mapped",[26395]],[[64148,64148],"mapped",[26454]],[[64149,64149],"mapped",[27513]],[[64150,64150],"mapped",[27578]],[[64151,64151],"mapped",[27969]],[[64152,64152],"mapped",[28379]],[[64153,64153],"mapped",[28363]],[[64154,64154],"mapped",[28450]],[[64155,64155],"mapped",[28702]],[[64156,64156],"mapped",[29038]],[[64157,64157],"mapped",[30631]],[[64158,64158],"mapped",[29237]],[[64159,64159],"mapped",[29359]],[[64160,64160],"mapped",[29482]],[[64161,64161],"mapped",[29809]],[[64162,64162],"mapped",[29958]],[[64163,64163],"mapped",[30011]],[[64164,64164],"mapped",[30237]],[[64165,64165],"mapped",[30239]],[[64166,64166],"mapped",[30410]],[[64167,64167],"mapped",[30427]],[[64168,64168],"mapped",[30452]],[[64169,64169],"mapped",[30538]],[[64170,64170],"mapped",[30528]],[[64171,64171],"mapped",[30924]],[[64172,64172],"mapped",[31409]],[[64173,64173],"mapped",[31680]],[[64174,64174],"mapped",[31867]],[[64175,64175],"mapped",[32091]],[[64176,64176],"mapped",[32244]],[[64177,64177],"mapped",[32574]],[[64178,64178],"mapped",[32773]],[[64179,64179],"mapped",[33618]],[[64180,64180],"mapped",[33775]],[[64181,64181],"mapped",[34681]],[[64182,64182],"mapped",[35137]],[[64183,64183],"mapped",[35206]],[[64184,64184],"mapped",[35222]],[[64185,64185],"mapped",[35519]],[[64186,64186],"mapped",[35576]],[[64187,64187],"mapped",[35531]],[[64188,64188],"mapped",[35585]],[[64189,64189],"mapped",[35582]],[[64190,64190],"mapped",[35565]],[[64191,64191],"mapped",[35641]],[[64192,64192],"mapped",[35722]],[[64193,64193],"mapped",[36104]],[[64194,64194],"mapped",[36664]],[[64195,64195],"mapped",[36978]],[[64196,64196],"mapped",[37273]],[[64197,64197],"mapped",[37494]],[[64198,64198],"mapped",[38524]],[[64199,64199],"mapped",[38627]],[[64200,64200],"mapped",[38742]],[[64201,64201],"mapped",[38875]],[[64202,64202],"mapped",[38911]],[[64203,64203],"mapped",[38923]],[[64204,64204],"mapped",[38971]],[[64205,64205],"mapped",[39698]],[[64206,64206],"mapped",[40860]],[[64207,64207],"mapped",[141386]],[[64208,64208],"mapped",[141380]],[[64209,64209],"mapped",[144341]],[[64210,64210],"mapped",[15261]],[[64211,64211],"mapped",[16408]],[[64212,64212],"mapped",[16441]],[[64213,64213],"mapped",[152137]],[[64214,64214],"mapped",[154832]],[[64215,64215],"mapped",[163539]],[[64216,64216],"mapped",[40771]],[[64217,64217],"mapped",[40846]],[[64218,64255],"disallowed"],[[64256,64256],"mapped",[102,102]],[[64257,64257],"mapped",[102,105]],[[64258,64258],"mapped",[102,108]],[[64259,64259],"mapped",[102,102,105]],[[64260,64260],"mapped",[102,102,108]],[[64261,64262],"mapped",[115,116]],[[64263,64274],"disallowed"],[[64275,64275],"mapped",[1396,1398]],[[64276,64276],"mapped",[1396,1381]],[[64277,64277],"mapped",[1396,1387]],[[64278,64278],"mapped",[1406,1398]],[[64279,64279],"mapped",[1396,1389]],[[64280,64284],"disallowed"],[[64285,64285],"mapped",[1497,1460]],[[64286,64286],"valid"],[[64287,64287],"mapped",[1522,1463]],[[64288,64288],"mapped",[1506]],[[64289,64289],"mapped",[1488]],[[64290,64290],"mapped",[1491]],[[64291,64291],"mapped",[1492]],[[64292,64292],"mapped",[1499]],[[64293,64293],"mapped",[1500]],[[64294,64294],"mapped",[1501]],[[64295,64295],"mapped",[1512]],[[64296,64296],"mapped",[1514]],[[64297,64297],"disallowed_STD3_mapped",[43]],[[64298,64298],"mapped",[1513,1473]],[[64299,64299],"mapped",[1513,1474]],[[64300,64300],"mapped",[1513,1468,1473]],[[64301,64301],"mapped",[1513,1468,1474]],[[64302,64302],"mapped",[1488,1463]],[[64303,64303],"mapped",[1488,1464]],[[64304,64304],"mapped",[1488,1468]],[[64305,64305],"mapped",[1489,1468]],[[64306,64306],"mapped",[1490,1468]],[[64307,64307],"mapped",[1491,1468]],[[64308,64308],"mapped",[1492,1468]],[[64309,64309],"mapped",[1493,1468]],[[64310,64310],"mapped",[1494,1468]],[[64311,64311],"disallowed"],[[64312,64312],"mapped",[1496,1468]],[[64313,64313],"mapped",[1497,1468]],[[64314,64314],"mapped",[1498,1468]],[[64315,64315],"mapped",[1499,1468]],[[64316,64316],"mapped",[1500,1468]],[[64317,64317],"disallowed"],[[64318,64318],"mapped",[1502,1468]],[[64319,64319],"disallowed"],[[64320,64320],"mapped",[1504,1468]],[[64321,64321],"mapped",[1505,1468]],[[64322,64322],"disallowed"],[[64323,64323],"mapped",[1507,1468]],[[64324,64324],"mapped",[1508,1468]],[[64325,64325],"disallowed"],[[64326,64326],"mapped",[1510,1468]],[[64327,64327],"mapped",[1511,1468]],[[64328,64328],"mapped",[1512,1468]],[[64329,64329],"mapped",[1513,1468]],[[64330,64330],"mapped",[1514,1468]],[[64331,64331],"mapped",[1493,1465]],[[64332,64332],"mapped",[1489,1471]],[[64333,64333],"mapped",[1499,1471]],[[64334,64334],"mapped",[1508,1471]],[[64335,64335],"mapped",[1488,1500]],[[64336,64337],"mapped",[1649]],[[64338,64341],"mapped",[1659]],[[64342,64345],"mapped",[1662]],[[64346,64349],"mapped",[1664]],[[64350,64353],"mapped",[1658]],[[64354,64357],"mapped",[1663]],[[64358,64361],"mapped",[1657]],[[64362,64365],"mapped",[1700]],[[64366,64369],"mapped",[1702]],[[64370,64373],"mapped",[1668]],[[64374,64377],"mapped",[1667]],[[64378,64381],"mapped",[1670]],[[64382,64385],"mapped",[1671]],[[64386,64387],"mapped",[1677]],[[64388,64389],"mapped",[1676]],[[64390,64391],"mapped",[1678]],[[64392,64393],"mapped",[1672]],[[64394,64395],"mapped",[1688]],[[64396,64397],"mapped",[1681]],[[64398,64401],"mapped",[1705]],[[64402,64405],"mapped",[1711]],[[64406,64409],"mapped",[1715]],[[64410,64413],"mapped",[1713]],[[64414,64415],"mapped",[1722]],[[64416,64419],"mapped",[1723]],[[64420,64421],"mapped",[1728]],[[64422,64425],"mapped",[1729]],[[64426,64429],"mapped",[1726]],[[64430,64431],"mapped",[1746]],[[64432,64433],"mapped",[1747]],[[64434,64449],"valid",[],"NV8"],[[64450,64466],"disallowed"],[[64467,64470],"mapped",[1709]],[[64471,64472],"mapped",[1735]],[[64473,64474],"mapped",[1734]],[[64475,64476],"mapped",[1736]],[[64477,64477],"mapped",[1735,1652]],[[64478,64479],"mapped",[1739]],[[64480,64481],"mapped",[1733]],[[64482,64483],"mapped",[1737]],[[64484,64487],"mapped",[1744]],[[64488,64489],"mapped",[1609]],[[64490,64491],"mapped",[1574,1575]],[[64492,64493],"mapped",[1574,1749]],[[64494,64495],"mapped",[1574,1608]],[[64496,64497],"mapped",[1574,1735]],[[64498,64499],"mapped",[1574,1734]],[[64500,64501],"mapped",[1574,1736]],[[64502,64504],"mapped",[1574,1744]],[[64505,64507],"mapped",[1574,1609]],[[64508,64511],"mapped",[1740]],[[64512,64512],"mapped",[1574,1580]],[[64513,64513],"mapped",[1574,1581]],[[64514,64514],"mapped",[1574,1605]],[[64515,64515],"mapped",[1574,1609]],[[64516,64516],"mapped",[1574,1610]],[[64517,64517],"mapped",[1576,1580]],[[64518,64518],"mapped",[1576,1581]],[[64519,64519],"mapped",[1576,1582]],[[64520,64520],"mapped",[1576,1605]],[[64521,64521],"mapped",[1576,1609]],[[64522,64522],"mapped",[1576,1610]],[[64523,64523],"mapped",[1578,1580]],[[64524,64524],"mapped",[1578,1581]],[[64525,64525],"mapped",[1578,1582]],[[64526,64526],"mapped",[1578,1605]],[[64527,64527],"mapped",[1578,1609]],[[64528,64528],"mapped",[1578,1610]],[[64529,64529],"mapped",[1579,1580]],[[64530,64530],"mapped",[1579,1605]],[[64531,64531],"mapped",[1579,1609]],[[64532,64532],"mapped",[1579,1610]],[[64533,64533],"mapped",[1580,1581]],[[64534,64534],"mapped",[1580,1605]],[[64535,64535],"mapped",[1581,1580]],[[64536,64536],"mapped",[1581,1605]],[[64537,64537],"mapped",[1582,1580]],[[64538,64538],"mapped",[1582,1581]],[[64539,64539],"mapped",[1582,1605]],[[64540,64540],"mapped",[1587,1580]],[[64541,64541],"mapped",[1587,1581]],[[64542,64542],"mapped",[1587,1582]],[[64543,64543],"mapped",[1587,1605]],[[64544,64544],"mapped",[1589,1581]],[[64545,64545],"mapped",[1589,1605]],[[64546,64546],"mapped",[1590,1580]],[[64547,64547],"mapped",[1590,1581]],[[64548,64548],"mapped",[1590,1582]],[[64549,64549],"mapped",[1590,1605]],[[64550,64550],"mapped",[1591,1581]],[[64551,64551],"mapped",[1591,1605]],[[64552,64552],"mapped",[1592,1605]],[[64553,64553],"mapped",[1593,1580]],[[64554,64554],"mapped",[1593,1605]],[[64555,64555],"mapped",[1594,1580]],[[64556,64556],"mapped",[1594,1605]],[[64557,64557],"mapped",[1601,1580]],[[64558,64558],"mapped",[1601,1581]],[[64559,64559],"mapped",[1601,1582]],[[64560,64560],"mapped",[1601,1605]],[[64561,64561],"mapped",[1601,1609]],[[64562,64562],"mapped",[1601,1610]],[[64563,64563],"mapped",[1602,1581]],[[64564,64564],"mapped",[1602,1605]],[[64565,64565],"mapped",[1602,1609]],[[64566,64566],"mapped",[1602,1610]],[[64567,64567],"mapped",[1603,1575]],[[64568,64568],"mapped",[1603,1580]],[[64569,64569],"mapped",[1603,1581]],[[64570,64570],"mapped",[1603,1582]],[[64571,64571],"mapped",[1603,1604]],[[64572,64572],"mapped",[1603,1605]],[[64573,64573],"mapped",[1603,1609]],[[64574,64574],"mapped",[1603,1610]],[[64575,64575],"mapped",[1604,1580]],[[64576,64576],"mapped",[1604,1581]],[[64577,64577],"mapped",[1604,1582]],[[64578,64578],"mapped",[1604,1605]],[[64579,64579],"mapped",[1604,1609]],[[64580,64580],"mapped",[1604,1610]],[[64581,64581],"mapped",[1605,1580]],[[64582,64582],"mapped",[1605,1581]],[[64583,64583],"mapped",[1605,1582]],[[64584,64584],"mapped",[1605,1605]],[[64585,64585],"mapped",[1605,1609]],[[64586,64586],"mapped",[1605,1610]],[[64587,64587],"mapped",[1606,1580]],[[64588,64588],"mapped",[1606,1581]],[[64589,64589],"mapped",[1606,1582]],[[64590,64590],"mapped",[1606,1605]],[[64591,64591],"mapped",[1606,1609]],[[64592,64592],"mapped",[1606,1610]],[[64593,64593],"mapped",[1607,1580]],[[64594,64594],"mapped",[1607,1605]],[[64595,64595],"mapped",[1607,1609]],[[64596,64596],"mapped",[1607,1610]],[[64597,64597],"mapped",[1610,1580]],[[64598,64598],"mapped",[1610,1581]],[[64599,64599],"mapped",[1610,1582]],[[64600,64600],"mapped",[1610,1605]],[[64601,64601],"mapped",[1610,1609]],[[64602,64602],"mapped",[1610,1610]],[[64603,64603],"mapped",[1584,1648]],[[64604,64604],"mapped",[1585,1648]],[[64605,64605],"mapped",[1609,1648]],[[64606,64606],"disallowed_STD3_mapped",[32,1612,1617]],[[64607,64607],"disallowed_STD3_mapped",[32,1613,1617]],[[64608,64608],"disallowed_STD3_mapped",[32,1614,1617]],[[64609,64609],"disallowed_STD3_mapped",[32,1615,1617]],[[64610,64610],"disallowed_STD3_mapped",[32,1616,1617]],[[64611,64611],"disallowed_STD3_mapped",[32,1617,1648]],[[64612,64612],"mapped",[1574,1585]],[[64613,64613],"mapped",[1574,1586]],[[64614,64614],"mapped",[1574,1605]],[[64615,64615],"mapped",[1574,1606]],[[64616,64616],"mapped",[1574,1609]],[[64617,64617],"mapped",[1574,1610]],[[64618,64618],"mapped",[1576,1585]],[[64619,64619],"mapped",[1576,1586]],[[64620,64620],"mapped",[1576,1605]],[[64621,64621],"mapped",[1576,1606]],[[64622,64622],"mapped",[1576,1609]],[[64623,64623],"mapped",[1576,1610]],[[64624,64624],"mapped",[1578,1585]],[[64625,64625],"mapped",[1578,1586]],[[64626,64626],"mapped",[1578,1605]],[[64627,64627],"mapped",[1578,1606]],[[64628,64628],"mapped",[1578,1609]],[[64629,64629],"mapped",[1578,1610]],[[64630,64630],"mapped",[1579,1585]],[[64631,64631],"mapped",[1579,1586]],[[64632,64632],"mapped",[1579,1605]],[[64633,64633],"mapped",[1579,1606]],[[64634,64634],"mapped",[1579,1609]],[[64635,64635],"mapped",[1579,1610]],[[64636,64636],"mapped",[1601,1609]],[[64637,64637],"mapped",[1601,1610]],[[64638,64638],"mapped",[1602,1609]],[[64639,64639],"mapped",[1602,1610]],[[64640,64640],"mapped",[1603,1575]],[[64641,64641],"mapped",[1603,1604]],[[64642,64642],"mapped",[1603,1605]],[[64643,64643],"mapped",[1603,1609]],[[64644,64644],"mapped",[1603,1610]],[[64645,64645],"mapped",[1604,1605]],[[64646,64646],"mapped",[1604,1609]],[[64647,64647],"mapped",[1604,1610]],[[64648,64648],"mapped",[1605,1575]],[[64649,64649],"mapped",[1605,1605]],[[64650,64650],"mapped",[1606,1585]],[[64651,64651],"mapped",[1606,1586]],[[64652,64652],"mapped",[1606,1605]],[[64653,64653],"mapped",[1606,1606]],[[64654,64654],"mapped",[1606,1609]],[[64655,64655],"mapped",[1606,1610]],[[64656,64656],"mapped",[1609,1648]],[[64657,64657],"mapped",[1610,1585]],[[64658,64658],"mapped",[1610,1586]],[[64659,64659],"mapped",[1610,1605]],[[64660,64660],"mapped",[1610,1606]],[[64661,64661],"mapped",[1610,1609]],[[64662,64662],"mapped",[1610,1610]],[[64663,64663],"mapped",[1574,1580]],[[64664,64664],"mapped",[1574,1581]],[[64665,64665],"mapped",[1574,1582]],[[64666,64666],"mapped",[1574,1605]],[[64667,64667],"mapped",[1574,1607]],[[64668,64668],"mapped",[1576,1580]],[[64669,64669],"mapped",[1576,1581]],[[64670,64670],"mapped",[1576,1582]],[[64671,64671],"mapped",[1576,1605]],[[64672,64672],"mapped",[1576,1607]],[[64673,64673],"mapped",[1578,1580]],[[64674,64674],"mapped",[1578,1581]],[[64675,64675],"mapped",[1578,1582]],[[64676,64676],"mapped",[1578,1605]],[[64677,64677],"mapped",[1578,1607]],[[64678,64678],"mapped",[1579,1605]],[[64679,64679],"mapped",[1580,1581]],[[64680,64680],"mapped",[1580,1605]],[[64681,64681],"mapped",[1581,1580]],[[64682,64682],"mapped",[1581,1605]],[[64683,64683],"mapped",[1582,1580]],[[64684,64684],"mapped",[1582,1605]],[[64685,64685],"mapped",[1587,1580]],[[64686,64686],"mapped",[1587,1581]],[[64687,64687],"mapped",[1587,1582]],[[64688,64688],"mapped",[1587,1605]],[[64689,64689],"mapped",[1589,1581]],[[64690,64690],"mapped",[1589,1582]],[[64691,64691],"mapped",[1589,1605]],[[64692,64692],"mapped",[1590,1580]],[[64693,64693],"mapped",[1590,1581]],[[64694,64694],"mapped",[1590,1582]],[[64695,64695],"mapped",[1590,1605]],[[64696,64696],"mapped",[1591,1581]],[[64697,64697],"mapped",[1592,1605]],[[64698,64698],"mapped",[1593,1580]],[[64699,64699],"mapped",[1593,1605]],[[64700,64700],"mapped",[1594,1580]],[[64701,64701],"mapped",[1594,1605]],[[64702,64702],"mapped",[1601,1580]],[[64703,64703],"mapped",[1601,1581]],[[64704,64704],"mapped",[1601,1582]],[[64705,64705],"mapped",[1601,1605]],[[64706,64706],"mapped",[1602,1581]],[[64707,64707],"mapped",[1602,1605]],[[64708,64708],"mapped",[1603,1580]],[[64709,64709],"mapped",[1603,1581]],[[64710,64710],"mapped",[1603,1582]],[[64711,64711],"mapped",[1603,1604]],[[64712,64712],"mapped",[1603,1605]],[[64713,64713],"mapped",[1604,1580]],[[64714,64714],"mapped",[1604,1581]],[[64715,64715],"mapped",[1604,1582]],[[64716,64716],"mapped",[1604,1605]],[[64717,64717],"mapped",[1604,1607]],[[64718,64718],"mapped",[1605,1580]],[[64719,64719],"mapped",[1605,1581]],[[64720,64720],"mapped",[1605,1582]],[[64721,64721],"mapped",[1605,1605]],[[64722,64722],"mapped",[1606,1580]],[[64723,64723],"mapped",[1606,1581]],[[64724,64724],"mapped",[1606,1582]],[[64725,64725],"mapped",[1606,1605]],[[64726,64726],"mapped",[1606,1607]],[[64727,64727],"mapped",[1607,1580]],[[64728,64728],"mapped",[1607,1605]],[[64729,64729],"mapped",[1607,1648]],[[64730,64730],"mapped",[1610,1580]],[[64731,64731],"mapped",[1610,1581]],[[64732,64732],"mapped",[1610,1582]],[[64733,64733],"mapped",[1610,1605]],[[64734,64734],"mapped",[1610,1607]],[[64735,64735],"mapped",[1574,1605]],[[64736,64736],"mapped",[1574,1607]],[[64737,64737],"mapped",[1576,1605]],[[64738,64738],"mapped",[1576,1607]],[[64739,64739],"mapped",[1578,1605]],[[64740,64740],"mapped",[1578,1607]],[[64741,64741],"mapped",[1579,1605]],[[64742,64742],"mapped",[1579,1607]],[[64743,64743],"mapped",[1587,1605]],[[64744,64744],"mapped",[1587,1607]],[[64745,64745],"mapped",[1588,1605]],[[64746,64746],"mapped",[1588,1607]],[[64747,64747],"mapped",[1603,1604]],[[64748,64748],"mapped",[1603,1605]],[[64749,64749],"mapped",[1604,1605]],[[64750,64750],"mapped",[1606,1605]],[[64751,64751],"mapped",[1606,1607]],[[64752,64752],"mapped",[1610,1605]],[[64753,64753],"mapped",[1610,1607]],[[64754,64754],"mapped",[1600,1614,1617]],[[64755,64755],"mapped",[1600,1615,1617]],[[64756,64756],"mapped",[1600,1616,1617]],[[64757,64757],"mapped",[1591,1609]],[[64758,64758],"mapped",[1591,1610]],[[64759,64759],"mapped",[1593,1609]],[[64760,64760],"mapped",[1593,1610]],[[64761,64761],"mapped",[1594,1609]],[[64762,64762],"mapped",[1594,1610]],[[64763,64763],"mapped",[1587,1609]],[[64764,64764],"mapped",[1587,1610]],[[64765,64765],"mapped",[1588,1609]],[[64766,64766],"mapped",[1588,1610]],[[64767,64767],"mapped",[1581,1609]],[[64768,64768],"mapped",[1581,1610]],[[64769,64769],"mapped",[1580,1609]],[[64770,64770],"mapped",[1580,1610]],[[64771,64771],"mapped",[1582,1609]],[[64772,64772],"mapped",[1582,1610]],[[64773,64773],"mapped",[1589,1609]],[[64774,64774],"mapped",[1589,1610]],[[64775,64775],"mapped",[1590,1609]],[[64776,64776],"mapped",[1590,1610]],[[64777,64777],"mapped",[1588,1580]],[[64778,64778],"mapped",[1588,1581]],[[64779,64779],"mapped",[1588,1582]],[[64780,64780],"mapped",[1588,1605]],[[64781,64781],"mapped",[1588,1585]],[[64782,64782],"mapped",[1587,1585]],[[64783,64783],"mapped",[1589,1585]],[[64784,64784],"mapped",[1590,1585]],[[64785,64785],"mapped",[1591,1609]],[[64786,64786],"mapped",[1591,1610]],[[64787,64787],"mapped",[1593,1609]],[[64788,64788],"mapped",[1593,1610]],[[64789,64789],"mapped",[1594,1609]],[[64790,64790],"mapped",[1594,1610]],[[64791,64791],"mapped",[1587,1609]],[[64792,64792],"mapped",[1587,1610]],[[64793,64793],"mapped",[1588,1609]],[[64794,64794],"mapped",[1588,1610]],[[64795,64795],"mapped",[1581,1609]],[[64796,64796],"mapped",[1581,1610]],[[64797,64797],"mapped",[1580,1609]],[[64798,64798],"mapped",[1580,1610]],[[64799,64799],"mapped",[1582,1609]],[[64800,64800],"mapped",[1582,1610]],[[64801,64801],"mapped",[1589,1609]],[[64802,64802],"mapped",[1589,1610]],[[64803,64803],"mapped",[1590,1609]],[[64804,64804],"mapped",[1590,1610]],[[64805,64805],"mapped",[1588,1580]],[[64806,64806],"mapped",[1588,1581]],[[64807,64807],"mapped",[1588,1582]],[[64808,64808],"mapped",[1588,1605]],[[64809,64809],"mapped",[1588,1585]],[[64810,64810],"mapped",[1587,1585]],[[64811,64811],"mapped",[1589,1585]],[[64812,64812],"mapped",[1590,1585]],[[64813,64813],"mapped",[1588,1580]],[[64814,64814],"mapped",[1588,1581]],[[64815,64815],"mapped",[1588,1582]],[[64816,64816],"mapped",[1588,1605]],[[64817,64817],"mapped",[1587,1607]],[[64818,64818],"mapped",[1588,1607]],[[64819,64819],"mapped",[1591,1605]],[[64820,64820],"mapped",[1587,1580]],[[64821,64821],"mapped",[1587,1581]],[[64822,64822],"mapped",[1587,1582]],[[64823,64823],"mapped",[1588,1580]],[[64824,64824],"mapped",[1588,1581]],[[64825,64825],"mapped",[1588,1582]],[[64826,64826],"mapped",[1591,1605]],[[64827,64827],"mapped",[1592,1605]],[[64828,64829],"mapped",[1575,1611]],[[64830,64831],"valid",[],"NV8"],[[64832,64847],"disallowed"],[[64848,64848],"mapped",[1578,1580,1605]],[[64849,64850],"mapped",[1578,1581,1580]],[[64851,64851],"mapped",[1578,1581,1605]],[[64852,64852],"mapped",[1578,1582,1605]],[[64853,64853],"mapped",[1578,1605,1580]],[[64854,64854],"mapped",[1578,1605,1581]],[[64855,64855],"mapped",[1578,1605,1582]],[[64856,64857],"mapped",[1580,1605,1581]],[[64858,64858],"mapped",[1581,1605,1610]],[[64859,64859],"mapped",[1581,1605,1609]],[[64860,64860],"mapped",[1587,1581,1580]],[[64861,64861],"mapped",[1587,1580,1581]],[[64862,64862],"mapped",[1587,1580,1609]],[[64863,64864],"mapped",[1587,1605,1581]],[[64865,64865],"mapped",[1587,1605,1580]],[[64866,64867],"mapped",[1587,1605,1605]],[[64868,64869],"mapped",[1589,1581,1581]],[[64870,64870],"mapped",[1589,1605,1605]],[[64871,64872],"mapped",[1588,1581,1605]],[[64873,64873],"mapped",[1588,1580,1610]],[[64874,64875],"mapped",[1588,1605,1582]],[[64876,64877],"mapped",[1588,1605,1605]],[[64878,64878],"mapped",[1590,1581,1609]],[[64879,64880],"mapped",[1590,1582,1605]],[[64881,64882],"mapped",[1591,1605,1581]],[[64883,64883],"mapped",[1591,1605,1605]],[[64884,64884],"mapped",[1591,1605,1610]],[[64885,64885],"mapped",[1593,1580,1605]],[[64886,64887],"mapped",[1593,1605,1605]],[[64888,64888],"mapped",[1593,1605,1609]],[[64889,64889],"mapped",[1594,1605,1605]],[[64890,64890],"mapped",[1594,1605,1610]],[[64891,64891],"mapped",[1594,1605,1609]],[[64892,64893],"mapped",[1601,1582,1605]],[[64894,64894],"mapped",[1602,1605,1581]],[[64895,64895],"mapped",[1602,1605,1605]],[[64896,64896],"mapped",[1604,1581,1605]],[[64897,64897],"mapped",[1604,1581,1610]],[[64898,64898],"mapped",[1604,1581,1609]],[[64899,64900],"mapped",[1604,1580,1580]],[[64901,64902],"mapped",[1604,1582,1605]],[[64903,64904],"mapped",[1604,1605,1581]],[[64905,64905],"mapped",[1605,1581,1580]],[[64906,64906],"mapped",[1605,1581,1605]],[[64907,64907],"mapped",[1605,1581,1610]],[[64908,64908],"mapped",[1605,1580,1581]],[[64909,64909],"mapped",[1605,1580,1605]],[[64910,64910],"mapped",[1605,1582,1580]],[[64911,64911],"mapped",[1605,1582,1605]],[[64912,64913],"disallowed"],[[64914,64914],"mapped",[1605,1580,1582]],[[64915,64915],"mapped",[1607,1605,1580]],[[64916,64916],"mapped",[1607,1605,1605]],[[64917,64917],"mapped",[1606,1581,1605]],[[64918,64918],"mapped",[1606,1581,1609]],[[64919,64920],"mapped",[1606,1580,1605]],[[64921,64921],"mapped",[1606,1580,1609]],[[64922,64922],"mapped",[1606,1605,1610]],[[64923,64923],"mapped",[1606,1605,1609]],[[64924,64925],"mapped",[1610,1605,1605]],[[64926,64926],"mapped",[1576,1582,1610]],[[64927,64927],"mapped",[1578,1580,1610]],[[64928,64928],"mapped",[1578,1580,1609]],[[64929,64929],"mapped",[1578,1582,1610]],[[64930,64930],"mapped",[1578,1582,1609]],[[64931,64931],"mapped",[1578,1605,1610]],[[64932,64932],"mapped",[1578,1605,1609]],[[64933,64933],"mapped",[1580,1605,1610]],[[64934,64934],"mapped",[1580,1581,1609]],[[64935,64935],"mapped",[1580,1605,1609]],[[64936,64936],"mapped",[1587,1582,1609]],[[64937,64937],"mapped",[1589,1581,1610]],[[64938,64938],"mapped",[1588,1581,1610]],[[64939,64939],"mapped",[1590,1581,1610]],[[64940,64940],"mapped",[1604,1580,1610]],[[64941,64941],"mapped",[1604,1605,1610]],[[64942,64942],"mapped",[1610,1581,1610]],[[64943,64943],"mapped",[1610,1580,1610]],[[64944,64944],"mapped",[1610,1605,1610]],[[64945,64945],"mapped",[1605,1605,1610]],[[64946,64946],"mapped",[1602,1605,1610]],[[64947,64947],"mapped",[1606,1581,1610]],[[64948,64948],"mapped",[1602,1605,1581]],[[64949,64949],"mapped",[1604,1581,1605]],[[64950,64950],"mapped",[1593,1605,1610]],[[64951,64951],"mapped",[1603,1605,1610]],[[64952,64952],"mapped",[1606,1580,1581]],[[64953,64953],"mapped",[1605,1582,1610]],[[64954,64954],"mapped",[1604,1580,1605]],[[64955,64955],"mapped",[1603,1605,1605]],[[64956,64956],"mapped",[1604,1580,1605]],[[64957,64957],"mapped",[1606,1580,1581]],[[64958,64958],"mapped",[1580,1581,1610]],[[64959,64959],"mapped",[1581,1580,1610]],[[64960,64960],"mapped",[1605,1580,1610]],[[64961,64961],"mapped",[1601,1605,1610]],[[64962,64962],"mapped",[1576,1581,1610]],[[64963,64963],"mapped",[1603,1605,1605]],[[64964,64964],"mapped",[1593,1580,1605]],[[64965,64965],"mapped",[1589,1605,1605]],[[64966,64966],"mapped",[1587,1582,1610]],[[64967,64967],"mapped",[1606,1580,1610]],[[64968,64975],"disallowed"],[[64976,65007],"disallowed"],[[65008,65008],"mapped",[1589,1604,1746]],[[65009,65009],"mapped",[1602,1604,1746]],[[65010,65010],"mapped",[1575,1604,1604,1607]],[[65011,65011],"mapped",[1575,1603,1576,1585]],[[65012,65012],"mapped",[1605,1581,1605,1583]],[[65013,65013],"mapped",[1589,1604,1593,1605]],[[65014,65014],"mapped",[1585,1587,1608,1604]],[[65015,65015],"mapped",[1593,1604,1610,1607]],[[65016,65016],"mapped",[1608,1587,1604,1605]],[[65017,65017],"mapped",[1589,1604,1609]],[[65018,65018],"disallowed_STD3_mapped",[1589,1604,1609,32,1575,1604,1604,1607,32,1593,1604,1610,1607,32,1608,1587,1604,1605]],[[65019,65019],"disallowed_STD3_mapped",[1580,1604,32,1580,1604,1575,1604,1607]],[[65020,65020],"mapped",[1585,1740,1575,1604]],[[65021,65021],"valid",[],"NV8"],[[65022,65023],"disallowed"],[[65024,65039],"ignored"],[[65040,65040],"disallowed_STD3_mapped",[44]],[[65041,65041],"mapped",[12289]],[[65042,65042],"disallowed"],[[65043,65043],"disallowed_STD3_mapped",[58]],[[65044,65044],"disallowed_STD3_mapped",[59]],[[65045,65045],"disallowed_STD3_mapped",[33]],[[65046,65046],"disallowed_STD3_mapped",[63]],[[65047,65047],"mapped",[12310]],[[65048,65048],"mapped",[12311]],[[65049,65049],"disallowed"],[[65050,65055],"disallowed"],[[65056,65059],"valid"],[[65060,65062],"valid"],[[65063,65069],"valid"],[[65070,65071],"valid"],[[65072,65072],"disallowed"],[[65073,65073],"mapped",[8212]],[[65074,65074],"mapped",[8211]],[[65075,65076],"disallowed_STD3_mapped",[95]],[[65077,65077],"disallowed_STD3_mapped",[40]],[[65078,65078],"disallowed_STD3_mapped",[41]],[[65079,65079],"disallowed_STD3_mapped",[123]],[[65080,65080],"disallowed_STD3_mapped",[125]],[[65081,65081],"mapped",[12308]],[[65082,65082],"mapped",[12309]],[[65083,65083],"mapped",[12304]],[[65084,65084],"mapped",[12305]],[[65085,65085],"mapped",[12298]],[[65086,65086],"mapped",[12299]],[[65087,65087],"mapped",[12296]],[[65088,65088],"mapped",[12297]],[[65089,65089],"mapped",[12300]],[[65090,65090],"mapped",[12301]],[[65091,65091],"mapped",[12302]],[[65092,65092],"mapped",[12303]],[[65093,65094],"valid",[],"NV8"],[[65095,65095],"disallowed_STD3_mapped",[91]],[[65096,65096],"disallowed_STD3_mapped",[93]],[[65097,65100],"disallowed_STD3_mapped",[32,773]],[[65101,65103],"disallowed_STD3_mapped",[95]],[[65104,65104],"disallowed_STD3_mapped",[44]],[[65105,65105],"mapped",[12289]],[[65106,65106],"disallowed"],[[65107,65107],"disallowed"],[[65108,65108],"disallowed_STD3_mapped",[59]],[[65109,65109],"disallowed_STD3_mapped",[58]],[[65110,65110],"disallowed_STD3_mapped",[63]],[[65111,65111],"disallowed_STD3_mapped",[33]],[[65112,65112],"mapped",[8212]],[[65113,65113],"disallowed_STD3_mapped",[40]],[[65114,65114],"disallowed_STD3_mapped",[41]],[[65115,65115],"disallowed_STD3_mapped",[123]],[[65116,65116],"disallowed_STD3_mapped",[125]],[[65117,65117],"mapped",[12308]],[[65118,65118],"mapped",[12309]],[[65119,65119],"disallowed_STD3_mapped",[35]],[[65120,65120],"disallowed_STD3_mapped",[38]],[[65121,65121],"disallowed_STD3_mapped",[42]],[[65122,65122],"disallowed_STD3_mapped",[43]],[[65123,65123],"mapped",[45]],[[65124,65124],"disallowed_STD3_mapped",[60]],[[65125,65125],"disallowed_STD3_mapped",[62]],[[65126,65126],"disallowed_STD3_mapped",[61]],[[65127,65127],"disallowed"],[[65128,65128],"disallowed_STD3_mapped",[92]],[[65129,65129],"disallowed_STD3_mapped",[36]],[[65130,65130],"disallowed_STD3_mapped",[37]],[[65131,65131],"disallowed_STD3_mapped",[64]],[[65132,65135],"disallowed"],[[65136,65136],"disallowed_STD3_mapped",[32,1611]],[[65137,65137],"mapped",[1600,1611]],[[65138,65138],"disallowed_STD3_mapped",[32,1612]],[[65139,65139],"valid"],[[65140,65140],"disallowed_STD3_mapped",[32,1613]],[[65141,65141],"disallowed"],[[65142,65142],"disallowed_STD3_mapped",[32,1614]],[[65143,65143],"mapped",[1600,1614]],[[65144,65144],"disallowed_STD3_mapped",[32,1615]],[[65145,65145],"mapped",[1600,1615]],[[65146,65146],"disallowed_STD3_mapped",[32,1616]],[[65147,65147],"mapped",[1600,1616]],[[65148,65148],"disallowed_STD3_mapped",[32,1617]],[[65149,65149],"mapped",[1600,1617]],[[65150,65150],"disallowed_STD3_mapped",[32,1618]],[[65151,65151],"mapped",[1600,1618]],[[65152,65152],"mapped",[1569]],[[65153,65154],"mapped",[1570]],[[65155,65156],"mapped",[1571]],[[65157,65158],"mapped",[1572]],[[65159,65160],"mapped",[1573]],[[65161,65164],"mapped",[1574]],[[65165,65166],"mapped",[1575]],[[65167,65170],"mapped",[1576]],[[65171,65172],"mapped",[1577]],[[65173,65176],"mapped",[1578]],[[65177,65180],"mapped",[1579]],[[65181,65184],"mapped",[1580]],[[65185,65188],"mapped",[1581]],[[65189,65192],"mapped",[1582]],[[65193,65194],"mapped",[1583]],[[65195,65196],"mapped",[1584]],[[65197,65198],"mapped",[1585]],[[65199,65200],"mapped",[1586]],[[65201,65204],"mapped",[1587]],[[65205,65208],"mapped",[1588]],[[65209,65212],"mapped",[1589]],[[65213,65216],"mapped",[1590]],[[65217,65220],"mapped",[1591]],[[65221,65224],"mapped",[1592]],[[65225,65228],"mapped",[1593]],[[65229,65232],"mapped",[1594]],[[65233,65236],"mapped",[1601]],[[65237,65240],"mapped",[1602]],[[65241,65244],"mapped",[1603]],[[65245,65248],"mapped",[1604]],[[65249,65252],"mapped",[1605]],[[65253,65256],"mapped",[1606]],[[65257,65260],"mapped",[1607]],[[65261,65262],"mapped",[1608]],[[65263,65264],"mapped",[1609]],[[65265,65268],"mapped",[1610]],[[65269,65270],"mapped",[1604,1570]],[[65271,65272],"mapped",[1604,1571]],[[65273,65274],"mapped",[1604,1573]],[[65275,65276],"mapped",[1604,1575]],[[65277,65278],"disallowed"],[[65279,65279],"ignored"],[[65280,65280],"disallowed"],[[65281,65281],"disallowed_STD3_mapped",[33]],[[65282,65282],"disallowed_STD3_mapped",[34]],[[65283,65283],"disallowed_STD3_mapped",[35]],[[65284,65284],"disallowed_STD3_mapped",[36]],[[65285,65285],"disallowed_STD3_mapped",[37]],[[65286,65286],"disallowed_STD3_mapped",[38]],[[65287,65287],"disallowed_STD3_mapped",[39]],[[65288,65288],"disallowed_STD3_mapped",[40]],[[65289,65289],"disallowed_STD3_mapped",[41]],[[65290,65290],"disallowed_STD3_mapped",[42]],[[65291,65291],"disallowed_STD3_mapped",[43]],[[65292,65292],"disallowed_STD3_mapped",[44]],[[65293,65293],"mapped",[45]],[[65294,65294],"mapped",[46]],[[65295,65295],"disallowed_STD3_mapped",[47]],[[65296,65296],"mapped",[48]],[[65297,65297],"mapped",[49]],[[65298,65298],"mapped",[50]],[[65299,65299],"mapped",[51]],[[65300,65300],"mapped",[52]],[[65301,65301],"mapped",[53]],[[65302,65302],"mapped",[54]],[[65303,65303],"mapped",[55]],[[65304,65304],"mapped",[56]],[[65305,65305],"mapped",[57]],[[65306,65306],"disallowed_STD3_mapped",[58]],[[65307,65307],"disallowed_STD3_mapped",[59]],[[65308,65308],"disallowed_STD3_mapped",[60]],[[65309,65309],"disallowed_STD3_mapped",[61]],[[65310,65310],"disallowed_STD3_mapped",[62]],[[65311,65311],"disallowed_STD3_mapped",[63]],[[65312,65312],"disallowed_STD3_mapped",[64]],[[65313,65313],"mapped",[97]],[[65314,65314],"mapped",[98]],[[65315,65315],"mapped",[99]],[[65316,65316],"mapped",[100]],[[65317,65317],"mapped",[101]],[[65318,65318],"mapped",[102]],[[65319,65319],"mapped",[103]],[[65320,65320],"mapped",[104]],[[65321,65321],"mapped",[105]],[[65322,65322],"mapped",[106]],[[65323,65323],"mapped",[107]],[[65324,65324],"mapped",[108]],[[65325,65325],"mapped",[109]],[[65326,65326],"mapped",[110]],[[65327,65327],"mapped",[111]],[[65328,65328],"mapped",[112]],[[65329,65329],"mapped",[113]],[[65330,65330],"mapped",[114]],[[65331,65331],"mapped",[115]],[[65332,65332],"mapped",[116]],[[65333,65333],"mapped",[117]],[[65334,65334],"mapped",[118]],[[65335,65335],"mapped",[119]],[[65336,65336],"mapped",[120]],[[65337,65337],"mapped",[121]],[[65338,65338],"mapped",[122]],[[65339,65339],"disallowed_STD3_mapped",[91]],[[65340,65340],"disallowed_STD3_mapped",[92]],[[65341,65341],"disallowed_STD3_mapped",[93]],[[65342,65342],"disallowed_STD3_mapped",[94]],[[65343,65343],"disallowed_STD3_mapped",[95]],[[65344,65344],"disallowed_STD3_mapped",[96]],[[65345,65345],"mapped",[97]],[[65346,65346],"mapped",[98]],[[65347,65347],"mapped",[99]],[[65348,65348],"mapped",[100]],[[65349,65349],"mapped",[101]],[[65350,65350],"mapped",[102]],[[65351,65351],"mapped",[103]],[[65352,65352],"mapped",[104]],[[65353,65353],"mapped",[105]],[[65354,65354],"mapped",[106]],[[65355,65355],"mapped",[107]],[[65356,65356],"mapped",[108]],[[65357,65357],"mapped",[109]],[[65358,65358],"mapped",[110]],[[65359,65359],"mapped",[111]],[[65360,65360],"mapped",[112]],[[65361,65361],"mapped",[113]],[[65362,65362],"mapped",[114]],[[65363,65363],"mapped",[115]],[[65364,65364],"mapped",[116]],[[65365,65365],"mapped",[117]],[[65366,65366],"mapped",[118]],[[65367,65367],"mapped",[119]],[[65368,65368],"mapped",[120]],[[65369,65369],"mapped",[121]],[[65370,65370],"mapped",[122]],[[65371,65371],"disallowed_STD3_mapped",[123]],[[65372,65372],"disallowed_STD3_mapped",[124]],[[65373,65373],"disallowed_STD3_mapped",[125]],[[65374,65374],"disallowed_STD3_mapped",[126]],[[65375,65375],"mapped",[10629]],[[65376,65376],"mapped",[10630]],[[65377,65377],"mapped",[46]],[[65378,65378],"mapped",[12300]],[[65379,65379],"mapped",[12301]],[[65380,65380],"mapped",[12289]],[[65381,65381],"mapped",[12539]],[[65382,65382],"mapped",[12530]],[[65383,65383],"mapped",[12449]],[[65384,65384],"mapped",[12451]],[[65385,65385],"mapped",[12453]],[[65386,65386],"mapped",[12455]],[[65387,65387],"mapped",[12457]],[[65388,65388],"mapped",[12515]],[[65389,65389],"mapped",[12517]],[[65390,65390],"mapped",[12519]],[[65391,65391],"mapped",[12483]],[[65392,65392],"mapped",[12540]],[[65393,65393],"mapped",[12450]],[[65394,65394],"mapped",[12452]],[[65395,65395],"mapped",[12454]],[[65396,65396],"mapped",[12456]],[[65397,65397],"mapped",[12458]],[[65398,65398],"mapped",[12459]],[[65399,65399],"mapped",[12461]],[[65400,65400],"mapped",[12463]],[[65401,65401],"mapped",[12465]],[[65402,65402],"mapped",[12467]],[[65403,65403],"mapped",[12469]],[[65404,65404],"mapped",[12471]],[[65405,65405],"mapped",[12473]],[[65406,65406],"mapped",[12475]],[[65407,65407],"mapped",[12477]],[[65408,65408],"mapped",[12479]],[[65409,65409],"mapped",[12481]],[[65410,65410],"mapped",[12484]],[[65411,65411],"mapped",[12486]],[[65412,65412],"mapped",[12488]],[[65413,65413],"mapped",[12490]],[[65414,65414],"mapped",[12491]],[[65415,65415],"mapped",[12492]],[[65416,65416],"mapped",[12493]],[[65417,65417],"mapped",[12494]],[[65418,65418],"mapped",[12495]],[[65419,65419],"mapped",[12498]],[[65420,65420],"mapped",[12501]],[[65421,65421],"mapped",[12504]],[[65422,65422],"mapped",[12507]],[[65423,65423],"mapped",[12510]],[[65424,65424],"mapped",[12511]],[[65425,65425],"mapped",[12512]],[[65426,65426],"mapped",[12513]],[[65427,65427],"mapped",[12514]],[[65428,65428],"mapped",[12516]],[[65429,65429],"mapped",[12518]],[[65430,65430],"mapped",[12520]],[[65431,65431],"mapped",[12521]],[[65432,65432],"mapped",[12522]],[[65433,65433],"mapped",[12523]],[[65434,65434],"mapped",[12524]],[[65435,65435],"mapped",[12525]],[[65436,65436],"mapped",[12527]],[[65437,65437],"mapped",[12531]],[[65438,65438],"mapped",[12441]],[[65439,65439],"mapped",[12442]],[[65440,65440],"disallowed"],[[65441,65441],"mapped",[4352]],[[65442,65442],"mapped",[4353]],[[65443,65443],"mapped",[4522]],[[65444,65444],"mapped",[4354]],[[65445,65445],"mapped",[4524]],[[65446,65446],"mapped",[4525]],[[65447,65447],"mapped",[4355]],[[65448,65448],"mapped",[4356]],[[65449,65449],"mapped",[4357]],[[65450,65450],"mapped",[4528]],[[65451,65451],"mapped",[4529]],[[65452,65452],"mapped",[4530]],[[65453,65453],"mapped",[4531]],[[65454,65454],"mapped",[4532]],[[65455,65455],"mapped",[4533]],[[65456,65456],"mapped",[4378]],[[65457,65457],"mapped",[4358]],[[65458,65458],"mapped",[4359]],[[65459,65459],"mapped",[4360]],[[65460,65460],"mapped",[4385]],[[65461,65461],"mapped",[4361]],[[65462,65462],"mapped",[4362]],[[65463,65463],"mapped",[4363]],[[65464,65464],"mapped",[4364]],[[65465,65465],"mapped",[4365]],[[65466,65466],"mapped",[4366]],[[65467,65467],"mapped",[4367]],[[65468,65468],"mapped",[4368]],[[65469,65469],"mapped",[4369]],[[65470,65470],"mapped",[4370]],[[65471,65473],"disallowed"],[[65474,65474],"mapped",[4449]],[[65475,65475],"mapped",[4450]],[[65476,65476],"mapped",[4451]],[[65477,65477],"mapped",[4452]],[[65478,65478],"mapped",[4453]],[[65479,65479],"mapped",[4454]],[[65480,65481],"disallowed"],[[65482,65482],"mapped",[4455]],[[65483,65483],"mapped",[4456]],[[65484,65484],"mapped",[4457]],[[65485,65485],"mapped",[4458]],[[65486,65486],"mapped",[4459]],[[65487,65487],"mapped",[4460]],[[65488,65489],"disallowed"],[[65490,65490],"mapped",[4461]],[[65491,65491],"mapped",[4462]],[[65492,65492],"mapped",[4463]],[[65493,65493],"mapped",[4464]],[[65494,65494],"mapped",[4465]],[[65495,65495],"mapped",[4466]],[[65496,65497],"disallowed"],[[65498,65498],"mapped",[4467]],[[65499,65499],"mapped",[4468]],[[65500,65500],"mapped",[4469]],[[65501,65503],"disallowed"],[[65504,65504],"mapped",[162]],[[65505,65505],"mapped",[163]],[[65506,65506],"mapped",[172]],[[65507,65507],"disallowed_STD3_mapped",[32,772]],[[65508,65508],"mapped",[166]],[[65509,65509],"mapped",[165]],[[65510,65510],"mapped",[8361]],[[65511,65511],"disallowed"],[[65512,65512],"mapped",[9474]],[[65513,65513],"mapped",[8592]],[[65514,65514],"mapped",[8593]],[[65515,65515],"mapped",[8594]],[[65516,65516],"mapped",[8595]],[[65517,65517],"mapped",[9632]],[[65518,65518],"mapped",[9675]],[[65519,65528],"disallowed"],[[65529,65531],"disallowed"],[[65532,65532],"disallowed"],[[65533,65533],"disallowed"],[[65534,65535],"disallowed"],[[65536,65547],"valid"],[[65548,65548],"disallowed"],[[65549,65574],"valid"],[[65575,65575],"disallowed"],[[65576,65594],"valid"],[[65595,65595],"disallowed"],[[65596,65597],"valid"],[[65598,65598],"disallowed"],[[65599,65613],"valid"],[[65614,65615],"disallowed"],[[65616,65629],"valid"],[[65630,65663],"disallowed"],[[65664,65786],"valid"],[[65787,65791],"disallowed"],[[65792,65794],"valid",[],"NV8"],[[65795,65798],"disallowed"],[[65799,65843],"valid",[],"NV8"],[[65844,65846],"disallowed"],[[65847,65855],"valid",[],"NV8"],[[65856,65930],"valid",[],"NV8"],[[65931,65932],"valid",[],"NV8"],[[65933,65935],"disallowed"],[[65936,65947],"valid",[],"NV8"],[[65948,65951],"disallowed"],[[65952,65952],"valid",[],"NV8"],[[65953,65999],"disallowed"],[[66000,66044],"valid",[],"NV8"],[[66045,66045],"valid"],[[66046,66175],"disallowed"],[[66176,66204],"valid"],[[66205,66207],"disallowed"],[[66208,66256],"valid"],[[66257,66271],"disallowed"],[[66272,66272],"valid"],[[66273,66299],"valid",[],"NV8"],[[66300,66303],"disallowed"],[[66304,66334],"valid"],[[66335,66335],"valid"],[[66336,66339],"valid",[],"NV8"],[[66340,66351],"disallowed"],[[66352,66368],"valid"],[[66369,66369],"valid",[],"NV8"],[[66370,66377],"valid"],[[66378,66378],"valid",[],"NV8"],[[66379,66383],"disallowed"],[[66384,66426],"valid"],[[66427,66431],"disallowed"],[[66432,66461],"valid"],[[66462,66462],"disallowed"],[[66463,66463],"valid",[],"NV8"],[[66464,66499],"valid"],[[66500,66503],"disallowed"],[[66504,66511],"valid"],[[66512,66517],"valid",[],"NV8"],[[66518,66559],"disallowed"],[[66560,66560],"mapped",[66600]],[[66561,66561],"mapped",[66601]],[[66562,66562],"mapped",[66602]],[[66563,66563],"mapped",[66603]],[[66564,66564],"mapped",[66604]],[[66565,66565],"mapped",[66605]],[[66566,66566],"mapped",[66606]],[[66567,66567],"mapped",[66607]],[[66568,66568],"mapped",[66608]],[[66569,66569],"mapped",[66609]],[[66570,66570],"mapped",[66610]],[[66571,66571],"mapped",[66611]],[[66572,66572],"mapped",[66612]],[[66573,66573],"mapped",[66613]],[[66574,66574],"mapped",[66614]],[[66575,66575],"mapped",[66615]],[[66576,66576],"mapped",[66616]],[[66577,66577],"mapped",[66617]],[[66578,66578],"mapped",[66618]],[[66579,66579],"mapped",[66619]],[[66580,66580],"mapped",[66620]],[[66581,66581],"mapped",[66621]],[[66582,66582],"mapped",[66622]],[[66583,66583],"mapped",[66623]],[[66584,66584],"mapped",[66624]],[[66585,66585],"mapped",[66625]],[[66586,66586],"mapped",[66626]],[[66587,66587],"mapped",[66627]],[[66588,66588],"mapped",[66628]],[[66589,66589],"mapped",[66629]],[[66590,66590],"mapped",[66630]],[[66591,66591],"mapped",[66631]],[[66592,66592],"mapped",[66632]],[[66593,66593],"mapped",[66633]],[[66594,66594],"mapped",[66634]],[[66595,66595],"mapped",[66635]],[[66596,66596],"mapped",[66636]],[[66597,66597],"mapped",[66637]],[[66598,66598],"mapped",[66638]],[[66599,66599],"mapped",[66639]],[[66600,66637],"valid"],[[66638,66717],"valid"],[[66718,66719],"disallowed"],[[66720,66729],"valid"],[[66730,66815],"disallowed"],[[66816,66855],"valid"],[[66856,66863],"disallowed"],[[66864,66915],"valid"],[[66916,66926],"disallowed"],[[66927,66927],"valid",[],"NV8"],[[66928,67071],"disallowed"],[[67072,67382],"valid"],[[67383,67391],"disallowed"],[[67392,67413],"valid"],[[67414,67423],"disallowed"],[[67424,67431],"valid"],[[67432,67583],"disallowed"],[[67584,67589],"valid"],[[67590,67591],"disallowed"],[[67592,67592],"valid"],[[67593,67593],"disallowed"],[[67594,67637],"valid"],[[67638,67638],"disallowed"],[[67639,67640],"valid"],[[67641,67643],"disallowed"],[[67644,67644],"valid"],[[67645,67646],"disallowed"],[[67647,67647],"valid"],[[67648,67669],"valid"],[[67670,67670],"disallowed"],[[67671,67679],"valid",[],"NV8"],[[67680,67702],"valid"],[[67703,67711],"valid",[],"NV8"],[[67712,67742],"valid"],[[67743,67750],"disallowed"],[[67751,67759],"valid",[],"NV8"],[[67760,67807],"disallowed"],[[67808,67826],"valid"],[[67827,67827],"disallowed"],[[67828,67829],"valid"],[[67830,67834],"disallowed"],[[67835,67839],"valid",[],"NV8"],[[67840,67861],"valid"],[[67862,67865],"valid",[],"NV8"],[[67866,67867],"valid",[],"NV8"],[[67868,67870],"disallowed"],[[67871,67871],"valid",[],"NV8"],[[67872,67897],"valid"],[[67898,67902],"disallowed"],[[67903,67903],"valid",[],"NV8"],[[67904,67967],"disallowed"],[[67968,68023],"valid"],[[68024,68027],"disallowed"],[[68028,68029],"valid",[],"NV8"],[[68030,68031],"valid"],[[68032,68047],"valid",[],"NV8"],[[68048,68049],"disallowed"],[[68050,68095],"valid",[],"NV8"],[[68096,68099],"valid"],[[68100,68100],"disallowed"],[[68101,68102],"valid"],[[68103,68107],"disallowed"],[[68108,68115],"valid"],[[68116,68116],"disallowed"],[[68117,68119],"valid"],[[68120,68120],"disallowed"],[[68121,68147],"valid"],[[68148,68151],"disallowed"],[[68152,68154],"valid"],[[68155,68158],"disallowed"],[[68159,68159],"valid"],[[68160,68167],"valid",[],"NV8"],[[68168,68175],"disallowed"],[[68176,68184],"valid",[],"NV8"],[[68185,68191],"disallowed"],[[68192,68220],"valid"],[[68221,68223],"valid",[],"NV8"],[[68224,68252],"valid"],[[68253,68255],"valid",[],"NV8"],[[68256,68287],"disallowed"],[[68288,68295],"valid"],[[68296,68296],"valid",[],"NV8"],[[68297,68326],"valid"],[[68327,68330],"disallowed"],[[68331,68342],"valid",[],"NV8"],[[68343,68351],"disallowed"],[[68352,68405],"valid"],[[68406,68408],"disallowed"],[[68409,68415],"valid",[],"NV8"],[[68416,68437],"valid"],[[68438,68439],"disallowed"],[[68440,68447],"valid",[],"NV8"],[[68448,68466],"valid"],[[68467,68471],"disallowed"],[[68472,68479],"valid",[],"NV8"],[[68480,68497],"valid"],[[68498,68504],"disallowed"],[[68505,68508],"valid",[],"NV8"],[[68509,68520],"disallowed"],[[68521,68527],"valid",[],"NV8"],[[68528,68607],"disallowed"],[[68608,68680],"valid"],[[68681,68735],"disallowed"],[[68736,68736],"mapped",[68800]],[[68737,68737],"mapped",[68801]],[[68738,68738],"mapped",[68802]],[[68739,68739],"mapped",[68803]],[[68740,68740],"mapped",[68804]],[[68741,68741],"mapped",[68805]],[[68742,68742],"mapped",[68806]],[[68743,68743],"mapped",[68807]],[[68744,68744],"mapped",[68808]],[[68745,68745],"mapped",[68809]],[[68746,68746],"mapped",[68810]],[[68747,68747],"mapped",[68811]],[[68748,68748],"mapped",[68812]],[[68749,68749],"mapped",[68813]],[[68750,68750],"mapped",[68814]],[[68751,68751],"mapped",[68815]],[[68752,68752],"mapped",[68816]],[[68753,68753],"mapped",[68817]],[[68754,68754],"mapped",[68818]],[[68755,68755],"mapped",[68819]],[[68756,68756],"mapped",[68820]],[[68757,68757],"mapped",[68821]],[[68758,68758],"mapped",[68822]],[[68759,68759],"mapped",[68823]],[[68760,68760],"mapped",[68824]],[[68761,68761],"mapped",[68825]],[[68762,68762],"mapped",[68826]],[[68763,68763],"mapped",[68827]],[[68764,68764],"mapped",[68828]],[[68765,68765],"mapped",[68829]],[[68766,68766],"mapped",[68830]],[[68767,68767],"mapped",[68831]],[[68768,68768],"mapped",[68832]],[[68769,68769],"mapped",[68833]],[[68770,68770],"mapped",[68834]],[[68771,68771],"mapped",[68835]],[[68772,68772],"mapped",[68836]],[[68773,68773],"mapped",[68837]],[[68774,68774],"mapped",[68838]],[[68775,68775],"mapped",[68839]],[[68776,68776],"mapped",[68840]],[[68777,68777],"mapped",[68841]],[[68778,68778],"mapped",[68842]],[[68779,68779],"mapped",[68843]],[[68780,68780],"mapped",[68844]],[[68781,68781],"mapped",[68845]],[[68782,68782],"mapped",[68846]],[[68783,68783],"mapped",[68847]],[[68784,68784],"mapped",[68848]],[[68785,68785],"mapped",[68849]],[[68786,68786],"mapped",[68850]],[[68787,68799],"disallowed"],[[68800,68850],"valid"],[[68851,68857],"disallowed"],[[68858,68863],"valid",[],"NV8"],[[68864,69215],"disallowed"],[[69216,69246],"valid",[],"NV8"],[[69247,69631],"disallowed"],[[69632,69702],"valid"],[[69703,69709],"valid",[],"NV8"],[[69710,69713],"disallowed"],[[69714,69733],"valid",[],"NV8"],[[69734,69743],"valid"],[[69744,69758],"disallowed"],[[69759,69759],"valid"],[[69760,69818],"valid"],[[69819,69820],"valid",[],"NV8"],[[69821,69821],"disallowed"],[[69822,69825],"valid",[],"NV8"],[[69826,69839],"disallowed"],[[69840,69864],"valid"],[[69865,69871],"disallowed"],[[69872,69881],"valid"],[[69882,69887],"disallowed"],[[69888,69940],"valid"],[[69941,69941],"disallowed"],[[69942,69951],"valid"],[[69952,69955],"valid",[],"NV8"],[[69956,69967],"disallowed"],[[69968,70003],"valid"],[[70004,70005],"valid",[],"NV8"],[[70006,70006],"valid"],[[70007,70015],"disallowed"],[[70016,70084],"valid"],[[70085,70088],"valid",[],"NV8"],[[70089,70089],"valid",[],"NV8"],[[70090,70092],"valid"],[[70093,70093],"valid",[],"NV8"],[[70094,70095],"disallowed"],[[70096,70105],"valid"],[[70106,70106],"valid"],[[70107,70107],"valid",[],"NV8"],[[70108,70108],"valid"],[[70109,70111],"valid",[],"NV8"],[[70112,70112],"disallowed"],[[70113,70132],"valid",[],"NV8"],[[70133,70143],"disallowed"],[[70144,70161],"valid"],[[70162,70162],"disallowed"],[[70163,70199],"valid"],[[70200,70205],"valid",[],"NV8"],[[70206,70271],"disallowed"],[[70272,70278],"valid"],[[70279,70279],"disallowed"],[[70280,70280],"valid"],[[70281,70281],"disallowed"],[[70282,70285],"valid"],[[70286,70286],"disallowed"],[[70287,70301],"valid"],[[70302,70302],"disallowed"],[[70303,70312],"valid"],[[70313,70313],"valid",[],"NV8"],[[70314,70319],"disallowed"],[[70320,70378],"valid"],[[70379,70383],"disallowed"],[[70384,70393],"valid"],[[70394,70399],"disallowed"],[[70400,70400],"valid"],[[70401,70403],"valid"],[[70404,70404],"disallowed"],[[70405,70412],"valid"],[[70413,70414],"disallowed"],[[70415,70416],"valid"],[[70417,70418],"disallowed"],[[70419,70440],"valid"],[[70441,70441],"disallowed"],[[70442,70448],"valid"],[[70449,70449],"disallowed"],[[70450,70451],"valid"],[[70452,70452],"disallowed"],[[70453,70457],"valid"],[[70458,70459],"disallowed"],[[70460,70468],"valid"],[[70469,70470],"disallowed"],[[70471,70472],"valid"],[[70473,70474],"disallowed"],[[70475,70477],"valid"],[[70478,70479],"disallowed"],[[70480,70480],"valid"],[[70481,70486],"disallowed"],[[70487,70487],"valid"],[[70488,70492],"disallowed"],[[70493,70499],"valid"],[[70500,70501],"disallowed"],[[70502,70508],"valid"],[[70509,70511],"disallowed"],[[70512,70516],"valid"],[[70517,70783],"disallowed"],[[70784,70853],"valid"],[[70854,70854],"valid",[],"NV8"],[[70855,70855],"valid"],[[70856,70863],"disallowed"],[[70864,70873],"valid"],[[70874,71039],"disallowed"],[[71040,71093],"valid"],[[71094,71095],"disallowed"],[[71096,71104],"valid"],[[71105,71113],"valid",[],"NV8"],[[71114,71127],"valid",[],"NV8"],[[71128,71133],"valid"],[[71134,71167],"disallowed"],[[71168,71232],"valid"],[[71233,71235],"valid",[],"NV8"],[[71236,71236],"valid"],[[71237,71247],"disallowed"],[[71248,71257],"valid"],[[71258,71295],"disallowed"],[[71296,71351],"valid"],[[71352,71359],"disallowed"],[[71360,71369],"valid"],[[71370,71423],"disallowed"],[[71424,71449],"valid"],[[71450,71452],"disallowed"],[[71453,71467],"valid"],[[71468,71471],"disallowed"],[[71472,71481],"valid"],[[71482,71487],"valid",[],"NV8"],[[71488,71839],"disallowed"],[[71840,71840],"mapped",[71872]],[[71841,71841],"mapped",[71873]],[[71842,71842],"mapped",[71874]],[[71843,71843],"mapped",[71875]],[[71844,71844],"mapped",[71876]],[[71845,71845],"mapped",[71877]],[[71846,71846],"mapped",[71878]],[[71847,71847],"mapped",[71879]],[[71848,71848],"mapped",[71880]],[[71849,71849],"mapped",[71881]],[[71850,71850],"mapped",[71882]],[[71851,71851],"mapped",[71883]],[[71852,71852],"mapped",[71884]],[[71853,71853],"mapped",[71885]],[[71854,71854],"mapped",[71886]],[[71855,71855],"mapped",[71887]],[[71856,71856],"mapped",[71888]],[[71857,71857],"mapped",[71889]],[[71858,71858],"mapped",[71890]],[[71859,71859],"mapped",[71891]],[[71860,71860],"mapped",[71892]],[[71861,71861],"mapped",[71893]],[[71862,71862],"mapped",[71894]],[[71863,71863],"mapped",[71895]],[[71864,71864],"mapped",[71896]],[[71865,71865],"mapped",[71897]],[[71866,71866],"mapped",[71898]],[[71867,71867],"mapped",[71899]],[[71868,71868],"mapped",[71900]],[[71869,71869],"mapped",[71901]],[[71870,71870],"mapped",[71902]],[[71871,71871],"mapped",[71903]],[[71872,71913],"valid"],[[71914,71922],"valid",[],"NV8"],[[71923,71934],"disallowed"],[[71935,71935],"valid"],[[71936,72383],"disallowed"],[[72384,72440],"valid"],[[72441,73727],"disallowed"],[[73728,74606],"valid"],[[74607,74648],"valid"],[[74649,74649],"valid"],[[74650,74751],"disallowed"],[[74752,74850],"valid",[],"NV8"],[[74851,74862],"valid",[],"NV8"],[[74863,74863],"disallowed"],[[74864,74867],"valid",[],"NV8"],[[74868,74868],"valid",[],"NV8"],[[74869,74879],"disallowed"],[[74880,75075],"valid"],[[75076,77823],"disallowed"],[[77824,78894],"valid"],[[78895,82943],"disallowed"],[[82944,83526],"valid"],[[83527,92159],"disallowed"],[[92160,92728],"valid"],[[92729,92735],"disallowed"],[[92736,92766],"valid"],[[92767,92767],"disallowed"],[[92768,92777],"valid"],[[92778,92781],"disallowed"],[[92782,92783],"valid",[],"NV8"],[[92784,92879],"disallowed"],[[92880,92909],"valid"],[[92910,92911],"disallowed"],[[92912,92916],"valid"],[[92917,92917],"valid",[],"NV8"],[[92918,92927],"disallowed"],[[92928,92982],"valid"],[[92983,92991],"valid",[],"NV8"],[[92992,92995],"valid"],[[92996,92997],"valid",[],"NV8"],[[92998,93007],"disallowed"],[[93008,93017],"valid"],[[93018,93018],"disallowed"],[[93019,93025],"valid",[],"NV8"],[[93026,93026],"disallowed"],[[93027,93047],"valid"],[[93048,93052],"disallowed"],[[93053,93071],"valid"],[[93072,93951],"disallowed"],[[93952,94020],"valid"],[[94021,94031],"disallowed"],[[94032,94078],"valid"],[[94079,94094],"disallowed"],[[94095,94111],"valid"],[[94112,110591],"disallowed"],[[110592,110593],"valid"],[[110594,113663],"disallowed"],[[113664,113770],"valid"],[[113771,113775],"disallowed"],[[113776,113788],"valid"],[[113789,113791],"disallowed"],[[113792,113800],"valid"],[[113801,113807],"disallowed"],[[113808,113817],"valid"],[[113818,113819],"disallowed"],[[113820,113820],"valid",[],"NV8"],[[113821,113822],"valid"],[[113823,113823],"valid",[],"NV8"],[[113824,113827],"ignored"],[[113828,118783],"disallowed"],[[118784,119029],"valid",[],"NV8"],[[119030,119039],"disallowed"],[[119040,119078],"valid",[],"NV8"],[[119079,119080],"disallowed"],[[119081,119081],"valid",[],"NV8"],[[119082,119133],"valid",[],"NV8"],[[119134,119134],"mapped",[119127,119141]],[[119135,119135],"mapped",[119128,119141]],[[119136,119136],"mapped",[119128,119141,119150]],[[119137,119137],"mapped",[119128,119141,119151]],[[119138,119138],"mapped",[119128,119141,119152]],[[119139,119139],"mapped",[119128,119141,119153]],[[119140,119140],"mapped",[119128,119141,119154]],[[119141,119154],"valid",[],"NV8"],[[119155,119162],"disallowed"],[[119163,119226],"valid",[],"NV8"],[[119227,119227],"mapped",[119225,119141]],[[119228,119228],"mapped",[119226,119141]],[[119229,119229],"mapped",[119225,119141,119150]],[[119230,119230],"mapped",[119226,119141,119150]],[[119231,119231],"mapped",[119225,119141,119151]],[[119232,119232],"mapped",[119226,119141,119151]],[[119233,119261],"valid",[],"NV8"],[[119262,119272],"valid",[],"NV8"],[[119273,119295],"disallowed"],[[119296,119365],"valid",[],"NV8"],[[119366,119551],"disallowed"],[[119552,119638],"valid",[],"NV8"],[[119639,119647],"disallowed"],[[119648,119665],"valid",[],"NV8"],[[119666,119807],"disallowed"],[[119808,119808],"mapped",[97]],[[119809,119809],"mapped",[98]],[[119810,119810],"mapped",[99]],[[119811,119811],"mapped",[100]],[[119812,119812],"mapped",[101]],[[119813,119813],"mapped",[102]],[[119814,119814],"mapped",[103]],[[119815,119815],"mapped",[104]],[[119816,119816],"mapped",[105]],[[119817,119817],"mapped",[106]],[[119818,119818],"mapped",[107]],[[119819,119819],"mapped",[108]],[[119820,119820],"mapped",[109]],[[119821,119821],"mapped",[110]],[[119822,119822],"mapped",[111]],[[119823,119823],"mapped",[112]],[[119824,119824],"mapped",[113]],[[119825,119825],"mapped",[114]],[[119826,119826],"mapped",[115]],[[119827,119827],"mapped",[116]],[[119828,119828],"mapped",[117]],[[119829,119829],"mapped",[118]],[[119830,119830],"mapped",[119]],[[119831,119831],"mapped",[120]],[[119832,119832],"mapped",[121]],[[119833,119833],"mapped",[122]],[[119834,119834],"mapped",[97]],[[119835,119835],"mapped",[98]],[[119836,119836],"mapped",[99]],[[119837,119837],"mapped",[100]],[[119838,119838],"mapped",[101]],[[119839,119839],"mapped",[102]],[[119840,119840],"mapped",[103]],[[119841,119841],"mapped",[104]],[[119842,119842],"mapped",[105]],[[119843,119843],"mapped",[106]],[[119844,119844],"mapped",[107]],[[119845,119845],"mapped",[108]],[[119846,119846],"mapped",[109]],[[119847,119847],"mapped",[110]],[[119848,119848],"mapped",[111]],[[119849,119849],"mapped",[112]],[[119850,119850],"mapped",[113]],[[119851,119851],"mapped",[114]],[[119852,119852],"mapped",[115]],[[119853,119853],"mapped",[116]],[[119854,119854],"mapped",[117]],[[119855,119855],"mapped",[118]],[[119856,119856],"mapped",[119]],[[119857,119857],"mapped",[120]],[[119858,119858],"mapped",[121]],[[119859,119859],"mapped",[122]],[[119860,119860],"mapped",[97]],[[119861,119861],"mapped",[98]],[[119862,119862],"mapped",[99]],[[119863,119863],"mapped",[100]],[[119864,119864],"mapped",[101]],[[119865,119865],"mapped",[102]],[[119866,119866],"mapped",[103]],[[119867,119867],"mapped",[104]],[[119868,119868],"mapped",[105]],[[119869,119869],"mapped",[106]],[[119870,119870],"mapped",[107]],[[119871,119871],"mapped",[108]],[[119872,119872],"mapped",[109]],[[119873,119873],"mapped",[110]],[[119874,119874],"mapped",[111]],[[119875,119875],"mapped",[112]],[[119876,119876],"mapped",[113]],[[119877,119877],"mapped",[114]],[[119878,119878],"mapped",[115]],[[119879,119879],"mapped",[116]],[[119880,119880],"mapped",[117]],[[119881,119881],"mapped",[118]],[[119882,119882],"mapped",[119]],[[119883,119883],"mapped",[120]],[[119884,119884],"mapped",[121]],[[119885,119885],"mapped",[122]],[[119886,119886],"mapped",[97]],[[119887,119887],"mapped",[98]],[[119888,119888],"mapped",[99]],[[119889,119889],"mapped",[100]],[[119890,119890],"mapped",[101]],[[119891,119891],"mapped",[102]],[[119892,119892],"mapped",[103]],[[119893,119893],"disallowed"],[[119894,119894],"mapped",[105]],[[119895,119895],"mapped",[106]],[[119896,119896],"mapped",[107]],[[119897,119897],"mapped",[108]],[[119898,119898],"mapped",[109]],[[119899,119899],"mapped",[110]],[[119900,119900],"mapped",[111]],[[119901,119901],"mapped",[112]],[[119902,119902],"mapped",[113]],[[119903,119903],"mapped",[114]],[[119904,119904],"mapped",[115]],[[119905,119905],"mapped",[116]],[[119906,119906],"mapped",[117]],[[119907,119907],"mapped",[118]],[[119908,119908],"mapped",[119]],[[119909,119909],"mapped",[120]],[[119910,119910],"mapped",[121]],[[119911,119911],"mapped",[122]],[[119912,119912],"mapped",[97]],[[119913,119913],"mapped",[98]],[[119914,119914],"mapped",[99]],[[119915,119915],"mapped",[100]],[[119916,119916],"mapped",[101]],[[119917,119917],"mapped",[102]],[[119918,119918],"mapped",[103]],[[119919,119919],"mapped",[104]],[[119920,119920],"mapped",[105]],[[119921,119921],"mapped",[106]],[[119922,119922],"mapped",[107]],[[119923,119923],"mapped",[108]],[[119924,119924],"mapped",[109]],[[119925,119925],"mapped",[110]],[[119926,119926],"mapped",[111]],[[119927,119927],"mapped",[112]],[[119928,119928],"mapped",[113]],[[119929,119929],"mapped",[114]],[[119930,119930],"mapped",[115]],[[119931,119931],"mapped",[116]],[[119932,119932],"mapped",[117]],[[119933,119933],"mapped",[118]],[[119934,119934],"mapped",[119]],[[119935,119935],"mapped",[120]],[[119936,119936],"mapped",[121]],[[119937,119937],"mapped",[122]],[[119938,119938],"mapped",[97]],[[119939,119939],"mapped",[98]],[[119940,119940],"mapped",[99]],[[119941,119941],"mapped",[100]],[[119942,119942],"mapped",[101]],[[119943,119943],"mapped",[102]],[[119944,119944],"mapped",[103]],[[119945,119945],"mapped",[104]],[[119946,119946],"mapped",[105]],[[119947,119947],"mapped",[106]],[[119948,119948],"mapped",[107]],[[119949,119949],"mapped",[108]],[[119950,119950],"mapped",[109]],[[119951,119951],"mapped",[110]],[[119952,119952],"mapped",[111]],[[119953,119953],"mapped",[112]],[[119954,119954],"mapped",[113]],[[119955,119955],"mapped",[114]],[[119956,119956],"mapped",[115]],[[119957,119957],"mapped",[116]],[[119958,119958],"mapped",[117]],[[119959,119959],"mapped",[118]],[[119960,119960],"mapped",[119]],[[119961,119961],"mapped",[120]],[[119962,119962],"mapped",[121]],[[119963,119963],"mapped",[122]],[[119964,119964],"mapped",[97]],[[119965,119965],"disallowed"],[[119966,119966],"mapped",[99]],[[119967,119967],"mapped",[100]],[[119968,119969],"disallowed"],[[119970,119970],"mapped",[103]],[[119971,119972],"disallowed"],[[119973,119973],"mapped",[106]],[[119974,119974],"mapped",[107]],[[119975,119976],"disallowed"],[[119977,119977],"mapped",[110]],[[119978,119978],"mapped",[111]],[[119979,119979],"mapped",[112]],[[119980,119980],"mapped",[113]],[[119981,119981],"disallowed"],[[119982,119982],"mapped",[115]],[[119983,119983],"mapped",[116]],[[119984,119984],"mapped",[117]],[[119985,119985],"mapped",[118]],[[119986,119986],"mapped",[119]],[[119987,119987],"mapped",[120]],[[119988,119988],"mapped",[121]],[[119989,119989],"mapped",[122]],[[119990,119990],"mapped",[97]],[[119991,119991],"mapped",[98]],[[119992,119992],"mapped",[99]],[[119993,119993],"mapped",[100]],[[119994,119994],"disallowed"],[[119995,119995],"mapped",[102]],[[119996,119996],"disallowed"],[[119997,119997],"mapped",[104]],[[119998,119998],"mapped",[105]],[[119999,119999],"mapped",[106]],[[120000,120000],"mapped",[107]],[[120001,120001],"mapped",[108]],[[120002,120002],"mapped",[109]],[[120003,120003],"mapped",[110]],[[120004,120004],"disallowed"],[[120005,120005],"mapped",[112]],[[120006,120006],"mapped",[113]],[[120007,120007],"mapped",[114]],[[120008,120008],"mapped",[115]],[[120009,120009],"mapped",[116]],[[120010,120010],"mapped",[117]],[[120011,120011],"mapped",[118]],[[120012,120012],"mapped",[119]],[[120013,120013],"mapped",[120]],[[120014,120014],"mapped",[121]],[[120015,120015],"mapped",[122]],[[120016,120016],"mapped",[97]],[[120017,120017],"mapped",[98]],[[120018,120018],"mapped",[99]],[[120019,120019],"mapped",[100]],[[120020,120020],"mapped",[101]],[[120021,120021],"mapped",[102]],[[120022,120022],"mapped",[103]],[[120023,120023],"mapped",[104]],[[120024,120024],"mapped",[105]],[[120025,120025],"mapped",[106]],[[120026,120026],"mapped",[107]],[[120027,120027],"mapped",[108]],[[120028,120028],"mapped",[109]],[[120029,120029],"mapped",[110]],[[120030,120030],"mapped",[111]],[[120031,120031],"mapped",[112]],[[120032,120032],"mapped",[113]],[[120033,120033],"mapped",[114]],[[120034,120034],"mapped",[115]],[[120035,120035],"mapped",[116]],[[120036,120036],"mapped",[117]],[[120037,120037],"mapped",[118]],[[120038,120038],"mapped",[119]],[[120039,120039],"mapped",[120]],[[120040,120040],"mapped",[121]],[[120041,120041],"mapped",[122]],[[120042,120042],"mapped",[97]],[[120043,120043],"mapped",[98]],[[120044,120044],"mapped",[99]],[[120045,120045],"mapped",[100]],[[120046,120046],"mapped",[101]],[[120047,120047],"mapped",[102]],[[120048,120048],"mapped",[103]],[[120049,120049],"mapped",[104]],[[120050,120050],"mapped",[105]],[[120051,120051],"mapped",[106]],[[120052,120052],"mapped",[107]],[[120053,120053],"mapped",[108]],[[120054,120054],"mapped",[109]],[[120055,120055],"mapped",[110]],[[120056,120056],"mapped",[111]],[[120057,120057],"mapped",[112]],[[120058,120058],"mapped",[113]],[[120059,120059],"mapped",[114]],[[120060,120060],"mapped",[115]],[[120061,120061],"mapped",[116]],[[120062,120062],"mapped",[117]],[[120063,120063],"mapped",[118]],[[120064,120064],"mapped",[119]],[[120065,120065],"mapped",[120]],[[120066,120066],"mapped",[121]],[[120067,120067],"mapped",[122]],[[120068,120068],"mapped",[97]],[[120069,120069],"mapped",[98]],[[120070,120070],"disallowed"],[[120071,120071],"mapped",[100]],[[120072,120072],"mapped",[101]],[[120073,120073],"mapped",[102]],[[120074,120074],"mapped",[103]],[[120075,120076],"disallowed"],[[120077,120077],"mapped",[106]],[[120078,120078],"mapped",[107]],[[120079,120079],"mapped",[108]],[[120080,120080],"mapped",[109]],[[120081,120081],"mapped",[110]],[[120082,120082],"mapped",[111]],[[120083,120083],"mapped",[112]],[[120084,120084],"mapped",[113]],[[120085,120085],"disallowed"],[[120086,120086],"mapped",[115]],[[120087,120087],"mapped",[116]],[[120088,120088],"mapped",[117]],[[120089,120089],"mapped",[118]],[[120090,120090],"mapped",[119]],[[120091,120091],"mapped",[120]],[[120092,120092],"mapped",[121]],[[120093,120093],"disallowed"],[[120094,120094],"mapped",[97]],[[120095,120095],"mapped",[98]],[[120096,120096],"mapped",[99]],[[120097,120097],"mapped",[100]],[[120098,120098],"mapped",[101]],[[120099,120099],"mapped",[102]],[[120100,120100],"mapped",[103]],[[120101,120101],"mapped",[104]],[[120102,120102],"mapped",[105]],[[120103,120103],"mapped",[106]],[[120104,120104],"mapped",[107]],[[120105,120105],"mapped",[108]],[[120106,120106],"mapped",[109]],[[120107,120107],"mapped",[110]],[[120108,120108],"mapped",[111]],[[120109,120109],"mapped",[112]],[[120110,120110],"mapped",[113]],[[120111,120111],"mapped",[114]],[[120112,120112],"mapped",[115]],[[120113,120113],"mapped",[116]],[[120114,120114],"mapped",[117]],[[120115,120115],"mapped",[118]],[[120116,120116],"mapped",[119]],[[120117,120117],"mapped",[120]],[[120118,120118],"mapped",[121]],[[120119,120119],"mapped",[122]],[[120120,120120],"mapped",[97]],[[120121,120121],"mapped",[98]],[[120122,120122],"disallowed"],[[120123,120123],"mapped",[100]],[[120124,120124],"mapped",[101]],[[120125,120125],"mapped",[102]],[[120126,120126],"mapped",[103]],[[120127,120127],"disallowed"],[[120128,120128],"mapped",[105]],[[120129,120129],"mapped",[106]],[[120130,120130],"mapped",[107]],[[120131,120131],"mapped",[108]],[[120132,120132],"mapped",[109]],[[120133,120133],"disallowed"],[[120134,120134],"mapped",[111]],[[120135,120137],"disallowed"],[[120138,120138],"mapped",[115]],[[120139,120139],"mapped",[116]],[[120140,120140],"mapped",[117]],[[120141,120141],"mapped",[118]],[[120142,120142],"mapped",[119]],[[120143,120143],"mapped",[120]],[[120144,120144],"mapped",[121]],[[120145,120145],"disallowed"],[[120146,120146],"mapped",[97]],[[120147,120147],"mapped",[98]],[[120148,120148],"mapped",[99]],[[120149,120149],"mapped",[100]],[[120150,120150],"mapped",[101]],[[120151,120151],"mapped",[102]],[[120152,120152],"mapped",[103]],[[120153,120153],"mapped",[104]],[[120154,120154],"mapped",[105]],[[120155,120155],"mapped",[106]],[[120156,120156],"mapped",[107]],[[120157,120157],"mapped",[108]],[[120158,120158],"mapped",[109]],[[120159,120159],"mapped",[110]],[[120160,120160],"mapped",[111]],[[120161,120161],"mapped",[112]],[[120162,120162],"mapped",[113]],[[120163,120163],"mapped",[114]],[[120164,120164],"mapped",[115]],[[120165,120165],"mapped",[116]],[[120166,120166],"mapped",[117]],[[120167,120167],"mapped",[118]],[[120168,120168],"mapped",[119]],[[120169,120169],"mapped",[120]],[[120170,120170],"mapped",[121]],[[120171,120171],"mapped",[122]],[[120172,120172],"mapped",[97]],[[120173,120173],"mapped",[98]],[[120174,120174],"mapped",[99]],[[120175,120175],"mapped",[100]],[[120176,120176],"mapped",[101]],[[120177,120177],"mapped",[102]],[[120178,120178],"mapped",[103]],[[120179,120179],"mapped",[104]],[[120180,120180],"mapped",[105]],[[120181,120181],"mapped",[106]],[[120182,120182],"mapped",[107]],[[120183,120183],"mapped",[108]],[[120184,120184],"mapped",[109]],[[120185,120185],"mapped",[110]],[[120186,120186],"mapped",[111]],[[120187,120187],"mapped",[112]],[[120188,120188],"mapped",[113]],[[120189,120189],"mapped",[114]],[[120190,120190],"mapped",[115]],[[120191,120191],"mapped",[116]],[[120192,120192],"mapped",[117]],[[120193,120193],"mapped",[118]],[[120194,120194],"mapped",[119]],[[120195,120195],"mapped",[120]],[[120196,120196],"mapped",[121]],[[120197,120197],"mapped",[122]],[[120198,120198],"mapped",[97]],[[120199,120199],"mapped",[98]],[[120200,120200],"mapped",[99]],[[120201,120201],"mapped",[100]],[[120202,120202],"mapped",[101]],[[120203,120203],"mapped",[102]],[[120204,120204],"mapped",[103]],[[120205,120205],"mapped",[104]],[[120206,120206],"mapped",[105]],[[120207,120207],"mapped",[106]],[[120208,120208],"mapped",[107]],[[120209,120209],"mapped",[108]],[[120210,120210],"mapped",[109]],[[120211,120211],"mapped",[110]],[[120212,120212],"mapped",[111]],[[120213,120213],"mapped",[112]],[[120214,120214],"mapped",[113]],[[120215,120215],"mapped",[114]],[[120216,120216],"mapped",[115]],[[120217,120217],"mapped",[116]],[[120218,120218],"mapped",[117]],[[120219,120219],"mapped",[118]],[[120220,120220],"mapped",[119]],[[120221,120221],"mapped",[120]],[[120222,120222],"mapped",[121]],[[120223,120223],"mapped",[122]],[[120224,120224],"mapped",[97]],[[120225,120225],"mapped",[98]],[[120226,120226],"mapped",[99]],[[120227,120227],"mapped",[100]],[[120228,120228],"mapped",[101]],[[120229,120229],"mapped",[102]],[[120230,120230],"mapped",[103]],[[120231,120231],"mapped",[104]],[[120232,120232],"mapped",[105]],[[120233,120233],"mapped",[106]],[[120234,120234],"mapped",[107]],[[120235,120235],"mapped",[108]],[[120236,120236],"mapped",[109]],[[120237,120237],"mapped",[110]],[[120238,120238],"mapped",[111]],[[120239,120239],"mapped",[112]],[[120240,120240],"mapped",[113]],[[120241,120241],"mapped",[114]],[[120242,120242],"mapped",[115]],[[120243,120243],"mapped",[116]],[[120244,120244],"mapped",[117]],[[120245,120245],"mapped",[118]],[[120246,120246],"mapped",[119]],[[120247,120247],"mapped",[120]],[[120248,120248],"mapped",[121]],[[120249,120249],"mapped",[122]],[[120250,120250],"mapped",[97]],[[120251,120251],"mapped",[98]],[[120252,120252],"mapped",[99]],[[120253,120253],"mapped",[100]],[[120254,120254],"mapped",[101]],[[120255,120255],"mapped",[102]],[[120256,120256],"mapped",[103]],[[120257,120257],"mapped",[104]],[[120258,120258],"mapped",[105]],[[120259,120259],"mapped",[106]],[[120260,120260],"mapped",[107]],[[120261,120261],"mapped",[108]],[[120262,120262],"mapped",[109]],[[120263,120263],"mapped",[110]],[[120264,120264],"mapped",[111]],[[120265,120265],"mapped",[112]],[[120266,120266],"mapped",[113]],[[120267,120267],"mapped",[114]],[[120268,120268],"mapped",[115]],[[120269,120269],"mapped",[116]],[[120270,120270],"mapped",[117]],[[120271,120271],"mapped",[118]],[[120272,120272],"mapped",[119]],[[120273,120273],"mapped",[120]],[[120274,120274],"mapped",[121]],[[120275,120275],"mapped",[122]],[[120276,120276],"mapped",[97]],[[120277,120277],"mapped",[98]],[[120278,120278],"mapped",[99]],[[120279,120279],"mapped",[100]],[[120280,120280],"mapped",[101]],[[120281,120281],"mapped",[102]],[[120282,120282],"mapped",[103]],[[120283,120283],"mapped",[104]],[[120284,120284],"mapped",[105]],[[120285,120285],"mapped",[106]],[[120286,120286],"mapped",[107]],[[120287,120287],"mapped",[108]],[[120288,120288],"mapped",[109]],[[120289,120289],"mapped",[110]],[[120290,120290],"mapped",[111]],[[120291,120291],"mapped",[112]],[[120292,120292],"mapped",[113]],[[120293,120293],"mapped",[114]],[[120294,120294],"mapped",[115]],[[120295,120295],"mapped",[116]],[[120296,120296],"mapped",[117]],[[120297,120297],"mapped",[118]],[[120298,120298],"mapped",[119]],[[120299,120299],"mapped",[120]],[[120300,120300],"mapped",[121]],[[120301,120301],"mapped",[122]],[[120302,120302],"mapped",[97]],[[120303,120303],"mapped",[98]],[[120304,120304],"mapped",[99]],[[120305,120305],"mapped",[100]],[[120306,120306],"mapped",[101]],[[120307,120307],"mapped",[102]],[[120308,120308],"mapped",[103]],[[120309,120309],"mapped",[104]],[[120310,120310],"mapped",[105]],[[120311,120311],"mapped",[106]],[[120312,120312],"mapped",[107]],[[120313,120313],"mapped",[108]],[[120314,120314],"mapped",[109]],[[120315,120315],"mapped",[110]],[[120316,120316],"mapped",[111]],[[120317,120317],"mapped",[112]],[[120318,120318],"mapped",[113]],[[120319,120319],"mapped",[114]],[[120320,120320],"mapped",[115]],[[120321,120321],"mapped",[116]],[[120322,120322],"mapped",[117]],[[120323,120323],"mapped",[118]],[[120324,120324],"mapped",[119]],[[120325,120325],"mapped",[120]],[[120326,120326],"mapped",[121]],[[120327,120327],"mapped",[122]],[[120328,120328],"mapped",[97]],[[120329,120329],"mapped",[98]],[[120330,120330],"mapped",[99]],[[120331,120331],"mapped",[100]],[[120332,120332],"mapped",[101]],[[120333,120333],"mapped",[102]],[[120334,120334],"mapped",[103]],[[120335,120335],"mapped",[104]],[[120336,120336],"mapped",[105]],[[120337,120337],"mapped",[106]],[[120338,120338],"mapped",[107]],[[120339,120339],"mapped",[108]],[[120340,120340],"mapped",[109]],[[120341,120341],"mapped",[110]],[[120342,120342],"mapped",[111]],[[120343,120343],"mapped",[112]],[[120344,120344],"mapped",[113]],[[120345,120345],"mapped",[114]],[[120346,120346],"mapped",[115]],[[120347,120347],"mapped",[116]],[[120348,120348],"mapped",[117]],[[120349,120349],"mapped",[118]],[[120350,120350],"mapped",[119]],[[120351,120351],"mapped",[120]],[[120352,120352],"mapped",[121]],[[120353,120353],"mapped",[122]],[[120354,120354],"mapped",[97]],[[120355,120355],"mapped",[98]],[[120356,120356],"mapped",[99]],[[120357,120357],"mapped",[100]],[[120358,120358],"mapped",[101]],[[120359,120359],"mapped",[102]],[[120360,120360],"mapped",[103]],[[120361,120361],"mapped",[104]],[[120362,120362],"mapped",[105]],[[120363,120363],"mapped",[106]],[[120364,120364],"mapped",[107]],[[120365,120365],"mapped",[108]],[[120366,120366],"mapped",[109]],[[120367,120367],"mapped",[110]],[[120368,120368],"mapped",[111]],[[120369,120369],"mapped",[112]],[[120370,120370],"mapped",[113]],[[120371,120371],"mapped",[114]],[[120372,120372],"mapped",[115]],[[120373,120373],"mapped",[116]],[[120374,120374],"mapped",[117]],[[120375,120375],"mapped",[118]],[[120376,120376],"mapped",[119]],[[120377,120377],"mapped",[120]],[[120378,120378],"mapped",[121]],[[120379,120379],"mapped",[122]],[[120380,120380],"mapped",[97]],[[120381,120381],"mapped",[98]],[[120382,120382],"mapped",[99]],[[120383,120383],"mapped",[100]],[[120384,120384],"mapped",[101]],[[120385,120385],"mapped",[102]],[[120386,120386],"mapped",[103]],[[120387,120387],"mapped",[104]],[[120388,120388],"mapped",[105]],[[120389,120389],"mapped",[106]],[[120390,120390],"mapped",[107]],[[120391,120391],"mapped",[108]],[[120392,120392],"mapped",[109]],[[120393,120393],"mapped",[110]],[[120394,120394],"mapped",[111]],[[120395,120395],"mapped",[112]],[[120396,120396],"mapped",[113]],[[120397,120397],"mapped",[114]],[[120398,120398],"mapped",[115]],[[120399,120399],"mapped",[116]],[[120400,120400],"mapped",[117]],[[120401,120401],"mapped",[118]],[[120402,120402],"mapped",[119]],[[120403,120403],"mapped",[120]],[[120404,120404],"mapped",[121]],[[120405,120405],"mapped",[122]],[[120406,120406],"mapped",[97]],[[120407,120407],"mapped",[98]],[[120408,120408],"mapped",[99]],[[120409,120409],"mapped",[100]],[[120410,120410],"mapped",[101]],[[120411,120411],"mapped",[102]],[[120412,120412],"mapped",[103]],[[120413,120413],"mapped",[104]],[[120414,120414],"mapped",[105]],[[120415,120415],"mapped",[106]],[[120416,120416],"mapped",[107]],[[120417,120417],"mapped",[108]],[[120418,120418],"mapped",[109]],[[120419,120419],"mapped",[110]],[[120420,120420],"mapped",[111]],[[120421,120421],"mapped",[112]],[[120422,120422],"mapped",[113]],[[120423,120423],"mapped",[114]],[[120424,120424],"mapped",[115]],[[120425,120425],"mapped",[116]],[[120426,120426],"mapped",[117]],[[120427,120427],"mapped",[118]],[[120428,120428],"mapped",[119]],[[120429,120429],"mapped",[120]],[[120430,120430],"mapped",[121]],[[120431,120431],"mapped",[122]],[[120432,120432],"mapped",[97]],[[120433,120433],"mapped",[98]],[[120434,120434],"mapped",[99]],[[120435,120435],"mapped",[100]],[[120436,120436],"mapped",[101]],[[120437,120437],"mapped",[102]],[[120438,120438],"mapped",[103]],[[120439,120439],"mapped",[104]],[[120440,120440],"mapped",[105]],[[120441,120441],"mapped",[106]],[[120442,120442],"mapped",[107]],[[120443,120443],"mapped",[108]],[[120444,120444],"mapped",[109]],[[120445,120445],"mapped",[110]],[[120446,120446],"mapped",[111]],[[120447,120447],"mapped",[112]],[[120448,120448],"mapped",[113]],[[120449,120449],"mapped",[114]],[[120450,120450],"mapped",[115]],[[120451,120451],"mapped",[116]],[[120452,120452],"mapped",[117]],[[120453,120453],"mapped",[118]],[[120454,120454],"mapped",[119]],[[120455,120455],"mapped",[120]],[[120456,120456],"mapped",[121]],[[120457,120457],"mapped",[122]],[[120458,120458],"mapped",[97]],[[120459,120459],"mapped",[98]],[[120460,120460],"mapped",[99]],[[120461,120461],"mapped",[100]],[[120462,120462],"mapped",[101]],[[120463,120463],"mapped",[102]],[[120464,120464],"mapped",[103]],[[120465,120465],"mapped",[104]],[[120466,120466],"mapped",[105]],[[120467,120467],"mapped",[106]],[[120468,120468],"mapped",[107]],[[120469,120469],"mapped",[108]],[[120470,120470],"mapped",[109]],[[120471,120471],"mapped",[110]],[[120472,120472],"mapped",[111]],[[120473,120473],"mapped",[112]],[[120474,120474],"mapped",[113]],[[120475,120475],"mapped",[114]],[[120476,120476],"mapped",[115]],[[120477,120477],"mapped",[116]],[[120478,120478],"mapped",[117]],[[120479,120479],"mapped",[118]],[[120480,120480],"mapped",[119]],[[120481,120481],"mapped",[120]],[[120482,120482],"mapped",[121]],[[120483,120483],"mapped",[122]],[[120484,120484],"mapped",[305]],[[120485,120485],"mapped",[567]],[[120486,120487],"disallowed"],[[120488,120488],"mapped",[945]],[[120489,120489],"mapped",[946]],[[120490,120490],"mapped",[947]],[[120491,120491],"mapped",[948]],[[120492,120492],"mapped",[949]],[[120493,120493],"mapped",[950]],[[120494,120494],"mapped",[951]],[[120495,120495],"mapped",[952]],[[120496,120496],"mapped",[953]],[[120497,120497],"mapped",[954]],[[120498,120498],"mapped",[955]],[[120499,120499],"mapped",[956]],[[120500,120500],"mapped",[957]],[[120501,120501],"mapped",[958]],[[120502,120502],"mapped",[959]],[[120503,120503],"mapped",[960]],[[120504,120504],"mapped",[961]],[[120505,120505],"mapped",[952]],[[120506,120506],"mapped",[963]],[[120507,120507],"mapped",[964]],[[120508,120508],"mapped",[965]],[[120509,120509],"mapped",[966]],[[120510,120510],"mapped",[967]],[[120511,120511],"mapped",[968]],[[120512,120512],"mapped",[969]],[[120513,120513],"mapped",[8711]],[[120514,120514],"mapped",[945]],[[120515,120515],"mapped",[946]],[[120516,120516],"mapped",[947]],[[120517,120517],"mapped",[948]],[[120518,120518],"mapped",[949]],[[120519,120519],"mapped",[950]],[[120520,120520],"mapped",[951]],[[120521,120521],"mapped",[952]],[[120522,120522],"mapped",[953]],[[120523,120523],"mapped",[954]],[[120524,120524],"mapped",[955]],[[120525,120525],"mapped",[956]],[[120526,120526],"mapped",[957]],[[120527,120527],"mapped",[958]],[[120528,120528],"mapped",[959]],[[120529,120529],"mapped",[960]],[[120530,120530],"mapped",[961]],[[120531,120532],"mapped",[963]],[[120533,120533],"mapped",[964]],[[120534,120534],"mapped",[965]],[[120535,120535],"mapped",[966]],[[120536,120536],"mapped",[967]],[[120537,120537],"mapped",[968]],[[120538,120538],"mapped",[969]],[[120539,120539],"mapped",[8706]],[[120540,120540],"mapped",[949]],[[120541,120541],"mapped",[952]],[[120542,120542],"mapped",[954]],[[120543,120543],"mapped",[966]],[[120544,120544],"mapped",[961]],[[120545,120545],"mapped",[960]],[[120546,120546],"mapped",[945]],[[120547,120547],"mapped",[946]],[[120548,120548],"mapped",[947]],[[120549,120549],"mapped",[948]],[[120550,120550],"mapped",[949]],[[120551,120551],"mapped",[950]],[[120552,120552],"mapped",[951]],[[120553,120553],"mapped",[952]],[[120554,120554],"mapped",[953]],[[120555,120555],"mapped",[954]],[[120556,120556],"mapped",[955]],[[120557,120557],"mapped",[956]],[[120558,120558],"mapped",[957]],[[120559,120559],"mapped",[958]],[[120560,120560],"mapped",[959]],[[120561,120561],"mapped",[960]],[[120562,120562],"mapped",[961]],[[120563,120563],"mapped",[952]],[[120564,120564],"mapped",[963]],[[120565,120565],"mapped",[964]],[[120566,120566],"mapped",[965]],[[120567,120567],"mapped",[966]],[[120568,120568],"mapped",[967]],[[120569,120569],"mapped",[968]],[[120570,120570],"mapped",[969]],[[120571,120571],"mapped",[8711]],[[120572,120572],"mapped",[945]],[[120573,120573],"mapped",[946]],[[120574,120574],"mapped",[947]],[[120575,120575],"mapped",[948]],[[120576,120576],"mapped",[949]],[[120577,120577],"mapped",[950]],[[120578,120578],"mapped",[951]],[[120579,120579],"mapped",[952]],[[120580,120580],"mapped",[953]],[[120581,120581],"mapped",[954]],[[120582,120582],"mapped",[955]],[[120583,120583],"mapped",[956]],[[120584,120584],"mapped",[957]],[[120585,120585],"mapped",[958]],[[120586,120586],"mapped",[959]],[[120587,120587],"mapped",[960]],[[120588,120588],"mapped",[961]],[[120589,120590],"mapped",[963]],[[120591,120591],"mapped",[964]],[[120592,120592],"mapped",[965]],[[120593,120593],"mapped",[966]],[[120594,120594],"mapped",[967]],[[120595,120595],"mapped",[968]],[[120596,120596],"mapped",[969]],[[120597,120597],"mapped",[8706]],[[120598,120598],"mapped",[949]],[[120599,120599],"mapped",[952]],[[120600,120600],"mapped",[954]],[[120601,120601],"mapped",[966]],[[120602,120602],"mapped",[961]],[[120603,120603],"mapped",[960]],[[120604,120604],"mapped",[945]],[[120605,120605],"mapped",[946]],[[120606,120606],"mapped",[947]],[[120607,120607],"mapped",[948]],[[120608,120608],"mapped",[949]],[[120609,120609],"mapped",[950]],[[120610,120610],"mapped",[951]],[[120611,120611],"mapped",[952]],[[120612,120612],"mapped",[953]],[[120613,120613],"mapped",[954]],[[120614,120614],"mapped",[955]],[[120615,120615],"mapped",[956]],[[120616,120616],"mapped",[957]],[[120617,120617],"mapped",[958]],[[120618,120618],"mapped",[959]],[[120619,120619],"mapped",[960]],[[120620,120620],"mapped",[961]],[[120621,120621],"mapped",[952]],[[120622,120622],"mapped",[963]],[[120623,120623],"mapped",[964]],[[120624,120624],"mapped",[965]],[[120625,120625],"mapped",[966]],[[120626,120626],"mapped",[967]],[[120627,120627],"mapped",[968]],[[120628,120628],"mapped",[969]],[[120629,120629],"mapped",[8711]],[[120630,120630],"mapped",[945]],[[120631,120631],"mapped",[946]],[[120632,120632],"mapped",[947]],[[120633,120633],"mapped",[948]],[[120634,120634],"mapped",[949]],[[120635,120635],"mapped",[950]],[[120636,120636],"mapped",[951]],[[120637,120637],"mapped",[952]],[[120638,120638],"mapped",[953]],[[120639,120639],"mapped",[954]],[[120640,120640],"mapped",[955]],[[120641,120641],"mapped",[956]],[[120642,120642],"mapped",[957]],[[120643,120643],"mapped",[958]],[[120644,120644],"mapped",[959]],[[120645,120645],"mapped",[960]],[[120646,120646],"mapped",[961]],[[120647,120648],"mapped",[963]],[[120649,120649],"mapped",[964]],[[120650,120650],"mapped",[965]],[[120651,120651],"mapped",[966]],[[120652,120652],"mapped",[967]],[[120653,120653],"mapped",[968]],[[120654,120654],"mapped",[969]],[[120655,120655],"mapped",[8706]],[[120656,120656],"mapped",[949]],[[120657,120657],"mapped",[952]],[[120658,120658],"mapped",[954]],[[120659,120659],"mapped",[966]],[[120660,120660],"mapped",[961]],[[120661,120661],"mapped",[960]],[[120662,120662],"mapped",[945]],[[120663,120663],"mapped",[946]],[[120664,120664],"mapped",[947]],[[120665,120665],"mapped",[948]],[[120666,120666],"mapped",[949]],[[120667,120667],"mapped",[950]],[[120668,120668],"mapped",[951]],[[120669,120669],"mapped",[952]],[[120670,120670],"mapped",[953]],[[120671,120671],"mapped",[954]],[[120672,120672],"mapped",[955]],[[120673,120673],"mapped",[956]],[[120674,120674],"mapped",[957]],[[120675,120675],"mapped",[958]],[[120676,120676],"mapped",[959]],[[120677,120677],"mapped",[960]],[[120678,120678],"mapped",[961]],[[120679,120679],"mapped",[952]],[[120680,120680],"mapped",[963]],[[120681,120681],"mapped",[964]],[[120682,120682],"mapped",[965]],[[120683,120683],"mapped",[966]],[[120684,120684],"mapped",[967]],[[120685,120685],"mapped",[968]],[[120686,120686],"mapped",[969]],[[120687,120687],"mapped",[8711]],[[120688,120688],"mapped",[945]],[[120689,120689],"mapped",[946]],[[120690,120690],"mapped",[947]],[[120691,120691],"mapped",[948]],[[120692,120692],"mapped",[949]],[[120693,120693],"mapped",[950]],[[120694,120694],"mapped",[951]],[[120695,120695],"mapped",[952]],[[120696,120696],"mapped",[953]],[[120697,120697],"mapped",[954]],[[120698,120698],"mapped",[955]],[[120699,120699],"mapped",[956]],[[120700,120700],"mapped",[957]],[[120701,120701],"mapped",[958]],[[120702,120702],"mapped",[959]],[[120703,120703],"mapped",[960]],[[120704,120704],"mapped",[961]],[[120705,120706],"mapped",[963]],[[120707,120707],"mapped",[964]],[[120708,120708],"mapped",[965]],[[120709,120709],"mapped",[966]],[[120710,120710],"mapped",[967]],[[120711,120711],"mapped",[968]],[[120712,120712],"mapped",[969]],[[120713,120713],"mapped",[8706]],[[120714,120714],"mapped",[949]],[[120715,120715],"mapped",[952]],[[120716,120716],"mapped",[954]],[[120717,120717],"mapped",[966]],[[120718,120718],"mapped",[961]],[[120719,120719],"mapped",[960]],[[120720,120720],"mapped",[945]],[[120721,120721],"mapped",[946]],[[120722,120722],"mapped",[947]],[[120723,120723],"mapped",[948]],[[120724,120724],"mapped",[949]],[[120725,120725],"mapped",[950]],[[120726,120726],"mapped",[951]],[[120727,120727],"mapped",[952]],[[120728,120728],"mapped",[953]],[[120729,120729],"mapped",[954]],[[120730,120730],"mapped",[955]],[[120731,120731],"mapped",[956]],[[120732,120732],"mapped",[957]],[[120733,120733],"mapped",[958]],[[120734,120734],"mapped",[959]],[[120735,120735],"mapped",[960]],[[120736,120736],"mapped",[961]],[[120737,120737],"mapped",[952]],[[120738,120738],"mapped",[963]],[[120739,120739],"mapped",[964]],[[120740,120740],"mapped",[965]],[[120741,120741],"mapped",[966]],[[120742,120742],"mapped",[967]],[[120743,120743],"mapped",[968]],[[120744,120744],"mapped",[969]],[[120745,120745],"mapped",[8711]],[[120746,120746],"mapped",[945]],[[120747,120747],"mapped",[946]],[[120748,120748],"mapped",[947]],[[120749,120749],"mapped",[948]],[[120750,120750],"mapped",[949]],[[120751,120751],"mapped",[950]],[[120752,120752],"mapped",[951]],[[120753,120753],"mapped",[952]],[[120754,120754],"mapped",[953]],[[120755,120755],"mapped",[954]],[[120756,120756],"mapped",[955]],[[120757,120757],"mapped",[956]],[[120758,120758],"mapped",[957]],[[120759,120759],"mapped",[958]],[[120760,120760],"mapped",[959]],[[120761,120761],"mapped",[960]],[[120762,120762],"mapped",[961]],[[120763,120764],"mapped",[963]],[[120765,120765],"mapped",[964]],[[120766,120766],"mapped",[965]],[[120767,120767],"mapped",[966]],[[120768,120768],"mapped",[967]],[[120769,120769],"mapped",[968]],[[120770,120770],"mapped",[969]],[[120771,120771],"mapped",[8706]],[[120772,120772],"mapped",[949]],[[120773,120773],"mapped",[952]],[[120774,120774],"mapped",[954]],[[120775,120775],"mapped",[966]],[[120776,120776],"mapped",[961]],[[120777,120777],"mapped",[960]],[[120778,120779],"mapped",[989]],[[120780,120781],"disallowed"],[[120782,120782],"mapped",[48]],[[120783,120783],"mapped",[49]],[[120784,120784],"mapped",[50]],[[120785,120785],"mapped",[51]],[[120786,120786],"mapped",[52]],[[120787,120787],"mapped",[53]],[[120788,120788],"mapped",[54]],[[120789,120789],"mapped",[55]],[[120790,120790],"mapped",[56]],[[120791,120791],"mapped",[57]],[[120792,120792],"mapped",[48]],[[120793,120793],"mapped",[49]],[[120794,120794],"mapped",[50]],[[120795,120795],"mapped",[51]],[[120796,120796],"mapped",[52]],[[120797,120797],"mapped",[53]],[[120798,120798],"mapped",[54]],[[120799,120799],"mapped",[55]],[[120800,120800],"mapped",[56]],[[120801,120801],"mapped",[57]],[[120802,120802],"mapped",[48]],[[120803,120803],"mapped",[49]],[[120804,120804],"mapped",[50]],[[120805,120805],"mapped",[51]],[[120806,120806],"mapped",[52]],[[120807,120807],"mapped",[53]],[[120808,120808],"mapped",[54]],[[120809,120809],"mapped",[55]],[[120810,120810],"mapped",[56]],[[120811,120811],"mapped",[57]],[[120812,120812],"mapped",[48]],[[120813,120813],"mapped",[49]],[[120814,120814],"mapped",[50]],[[120815,120815],"mapped",[51]],[[120816,120816],"mapped",[52]],[[120817,120817],"mapped",[53]],[[120818,120818],"mapped",[54]],[[120819,120819],"mapped",[55]],[[120820,120820],"mapped",[56]],[[120821,120821],"mapped",[57]],[[120822,120822],"mapped",[48]],[[120823,120823],"mapped",[49]],[[120824,120824],"mapped",[50]],[[120825,120825],"mapped",[51]],[[120826,120826],"mapped",[52]],[[120827,120827],"mapped",[53]],[[120828,120828],"mapped",[54]],[[120829,120829],"mapped",[55]],[[120830,120830],"mapped",[56]],[[120831,120831],"mapped",[57]],[[120832,121343],"valid",[],"NV8"],[[121344,121398],"valid"],[[121399,121402],"valid",[],"NV8"],[[121403,121452],"valid"],[[121453,121460],"valid",[],"NV8"],[[121461,121461],"valid"],[[121462,121475],"valid",[],"NV8"],[[121476,121476],"valid"],[[121477,121483],"valid",[],"NV8"],[[121484,121498],"disallowed"],[[121499,121503],"valid"],[[121504,121504],"disallowed"],[[121505,121519],"valid"],[[121520,124927],"disallowed"],[[124928,125124],"valid"],[[125125,125126],"disallowed"],[[125127,125135],"valid",[],"NV8"],[[125136,125142],"valid"],[[125143,126463],"disallowed"],[[126464,126464],"mapped",[1575]],[[126465,126465],"mapped",[1576]],[[126466,126466],"mapped",[1580]],[[126467,126467],"mapped",[1583]],[[126468,126468],"disallowed"],[[126469,126469],"mapped",[1608]],[[126470,126470],"mapped",[1586]],[[126471,126471],"mapped",[1581]],[[126472,126472],"mapped",[1591]],[[126473,126473],"mapped",[1610]],[[126474,126474],"mapped",[1603]],[[126475,126475],"mapped",[1604]],[[126476,126476],"mapped",[1605]],[[126477,126477],"mapped",[1606]],[[126478,126478],"mapped",[1587]],[[126479,126479],"mapped",[1593]],[[126480,126480],"mapped",[1601]],[[126481,126481],"mapped",[1589]],[[126482,126482],"mapped",[1602]],[[126483,126483],"mapped",[1585]],[[126484,126484],"mapped",[1588]],[[126485,126485],"mapped",[1578]],[[126486,126486],"mapped",[1579]],[[126487,126487],"mapped",[1582]],[[126488,126488],"mapped",[1584]],[[126489,126489],"mapped",[1590]],[[126490,126490],"mapped",[1592]],[[126491,126491],"mapped",[1594]],[[126492,126492],"mapped",[1646]],[[126493,126493],"mapped",[1722]],[[126494,126494],"mapped",[1697]],[[126495,126495],"mapped",[1647]],[[126496,126496],"disallowed"],[[126497,126497],"mapped",[1576]],[[126498,126498],"mapped",[1580]],[[126499,126499],"disallowed"],[[126500,126500],"mapped",[1607]],[[126501,126502],"disallowed"],[[126503,126503],"mapped",[1581]],[[126504,126504],"disallowed"],[[126505,126505],"mapped",[1610]],[[126506,126506],"mapped",[1603]],[[126507,126507],"mapped",[1604]],[[126508,126508],"mapped",[1605]],[[126509,126509],"mapped",[1606]],[[126510,126510],"mapped",[1587]],[[126511,126511],"mapped",[1593]],[[126512,126512],"mapped",[1601]],[[126513,126513],"mapped",[1589]],[[126514,126514],"mapped",[1602]],[[126515,126515],"disallowed"],[[126516,126516],"mapped",[1588]],[[126517,126517],"mapped",[1578]],[[126518,126518],"mapped",[1579]],[[126519,126519],"mapped",[1582]],[[126520,126520],"disallowed"],[[126521,126521],"mapped",[1590]],[[126522,126522],"disallowed"],[[126523,126523],"mapped",[1594]],[[126524,126529],"disallowed"],[[126530,126530],"mapped",[1580]],[[126531,126534],"disallowed"],[[126535,126535],"mapped",[1581]],[[126536,126536],"disallowed"],[[126537,126537],"mapped",[1610]],[[126538,126538],"disallowed"],[[126539,126539],"mapped",[1604]],[[126540,126540],"disallowed"],[[126541,126541],"mapped",[1606]],[[126542,126542],"mapped",[1587]],[[126543,126543],"mapped",[1593]],[[126544,126544],"disallowed"],[[126545,126545],"mapped",[1589]],[[126546,126546],"mapped",[1602]],[[126547,126547],"disallowed"],[[126548,126548],"mapped",[1588]],[[126549,126550],"disallowed"],[[126551,126551],"mapped",[1582]],[[126552,126552],"disallowed"],[[126553,126553],"mapped",[1590]],[[126554,126554],"disallowed"],[[126555,126555],"mapped",[1594]],[[126556,126556],"disallowed"],[[126557,126557],"mapped",[1722]],[[126558,126558],"disallowed"],[[126559,126559],"mapped",[1647]],[[126560,126560],"disallowed"],[[126561,126561],"mapped",[1576]],[[126562,126562],"mapped",[1580]],[[126563,126563],"disallowed"],[[126564,126564],"mapped",[1607]],[[126565,126566],"disallowed"],[[126567,126567],"mapped",[1581]],[[126568,126568],"mapped",[1591]],[[126569,126569],"mapped",[1610]],[[126570,126570],"mapped",[1603]],[[126571,126571],"disallowed"],[[126572,126572],"mapped",[1605]],[[126573,126573],"mapped",[1606]],[[126574,126574],"mapped",[1587]],[[126575,126575],"mapped",[1593]],[[126576,126576],"mapped",[1601]],[[126577,126577],"mapped",[1589]],[[126578,126578],"mapped",[1602]],[[126579,126579],"disallowed"],[[126580,126580],"mapped",[1588]],[[126581,126581],"mapped",[1578]],[[126582,126582],"mapped",[1579]],[[126583,126583],"mapped",[1582]],[[126584,126584],"disallowed"],[[126585,126585],"mapped",[1590]],[[126586,126586],"mapped",[1592]],[[126587,126587],"mapped",[1594]],[[126588,126588],"mapped",[1646]],[[126589,126589],"disallowed"],[[126590,126590],"mapped",[1697]],[[126591,126591],"disallowed"],[[126592,126592],"mapped",[1575]],[[126593,126593],"mapped",[1576]],[[126594,126594],"mapped",[1580]],[[126595,126595],"mapped",[1583]],[[126596,126596],"mapped",[1607]],[[126597,126597],"mapped",[1608]],[[126598,126598],"mapped",[1586]],[[126599,126599],"mapped",[1581]],[[126600,126600],"mapped",[1591]],[[126601,126601],"mapped",[1610]],[[126602,126602],"disallowed"],[[126603,126603],"mapped",[1604]],[[126604,126604],"mapped",[1605]],[[126605,126605],"mapped",[1606]],[[126606,126606],"mapped",[1587]],[[126607,126607],"mapped",[1593]],[[126608,126608],"mapped",[1601]],[[126609,126609],"mapped",[1589]],[[126610,126610],"mapped",[1602]],[[126611,126611],"mapped",[1585]],[[126612,126612],"mapped",[1588]],[[126613,126613],"mapped",[1578]],[[126614,126614],"mapped",[1579]],[[126615,126615],"mapped",[1582]],[[126616,126616],"mapped",[1584]],[[126617,126617],"mapped",[1590]],[[126618,126618],"mapped",[1592]],[[126619,126619],"mapped",[1594]],[[126620,126624],"disallowed"],[[126625,126625],"mapped",[1576]],[[126626,126626],"mapped",[1580]],[[126627,126627],"mapped",[1583]],[[126628,126628],"disallowed"],[[126629,126629],"mapped",[1608]],[[126630,126630],"mapped",[1586]],[[126631,126631],"mapped",[1581]],[[126632,126632],"mapped",[1591]],[[126633,126633],"mapped",[1610]],[[126634,126634],"disallowed"],[[126635,126635],"mapped",[1604]],[[126636,126636],"mapped",[1605]],[[126637,126637],"mapped",[1606]],[[126638,126638],"mapped",[1587]],[[126639,126639],"mapped",[1593]],[[126640,126640],"mapped",[1601]],[[126641,126641],"mapped",[1589]],[[126642,126642],"mapped",[1602]],[[126643,126643],"mapped",[1585]],[[126644,126644],"mapped",[1588]],[[126645,126645],"mapped",[1578]],[[126646,126646],"mapped",[1579]],[[126647,126647],"mapped",[1582]],[[126648,126648],"mapped",[1584]],[[126649,126649],"mapped",[1590]],[[126650,126650],"mapped",[1592]],[[126651,126651],"mapped",[1594]],[[126652,126703],"disallowed"],[[126704,126705],"valid",[],"NV8"],[[126706,126975],"disallowed"],[[126976,127019],"valid",[],"NV8"],[[127020,127023],"disallowed"],[[127024,127123],"valid",[],"NV8"],[[127124,127135],"disallowed"],[[127136,127150],"valid",[],"NV8"],[[127151,127152],"disallowed"],[[127153,127166],"valid",[],"NV8"],[[127167,127167],"valid",[],"NV8"],[[127168,127168],"disallowed"],[[127169,127183],"valid",[],"NV8"],[[127184,127184],"disallowed"],[[127185,127199],"valid",[],"NV8"],[[127200,127221],"valid",[],"NV8"],[[127222,127231],"disallowed"],[[127232,127232],"disallowed"],[[127233,127233],"disallowed_STD3_mapped",[48,44]],[[127234,127234],"disallowed_STD3_mapped",[49,44]],[[127235,127235],"disallowed_STD3_mapped",[50,44]],[[127236,127236],"disallowed_STD3_mapped",[51,44]],[[127237,127237],"disallowed_STD3_mapped",[52,44]],[[127238,127238],"disallowed_STD3_mapped",[53,44]],[[127239,127239],"disallowed_STD3_mapped",[54,44]],[[127240,127240],"disallowed_STD3_mapped",[55,44]],[[127241,127241],"disallowed_STD3_mapped",[56,44]],[[127242,127242],"disallowed_STD3_mapped",[57,44]],[[127243,127244],"valid",[],"NV8"],[[127245,127247],"disallowed"],[[127248,127248],"disallowed_STD3_mapped",[40,97,41]],[[127249,127249],"disallowed_STD3_mapped",[40,98,41]],[[127250,127250],"disallowed_STD3_mapped",[40,99,41]],[[127251,127251],"disallowed_STD3_mapped",[40,100,41]],[[127252,127252],"disallowed_STD3_mapped",[40,101,41]],[[127253,127253],"disallowed_STD3_mapped",[40,102,41]],[[127254,127254],"disallowed_STD3_mapped",[40,103,41]],[[127255,127255],"disallowed_STD3_mapped",[40,104,41]],[[127256,127256],"disallowed_STD3_mapped",[40,105,41]],[[127257,127257],"disallowed_STD3_mapped",[40,106,41]],[[127258,127258],"disallowed_STD3_mapped",[40,107,41]],[[127259,127259],"disallowed_STD3_mapped",[40,108,41]],[[127260,127260],"disallowed_STD3_mapped",[40,109,41]],[[127261,127261],"disallowed_STD3_mapped",[40,110,41]],[[127262,127262],"disallowed_STD3_mapped",[40,111,41]],[[127263,127263],"disallowed_STD3_mapped",[40,112,41]],[[127264,127264],"disallowed_STD3_mapped",[40,113,41]],[[127265,127265],"disallowed_STD3_mapped",[40,114,41]],[[127266,127266],"disallowed_STD3_mapped",[40,115,41]],[[127267,127267],"disallowed_STD3_mapped",[40,116,41]],[[127268,127268],"disallowed_STD3_mapped",[40,117,41]],[[127269,127269],"disallowed_STD3_mapped",[40,118,41]],[[127270,127270],"disallowed_STD3_mapped",[40,119,41]],[[127271,127271],"disallowed_STD3_mapped",[40,120,41]],[[127272,127272],"disallowed_STD3_mapped",[40,121,41]],[[127273,127273],"disallowed_STD3_mapped",[40,122,41]],[[127274,127274],"mapped",[12308,115,12309]],[[127275,127275],"mapped",[99]],[[127276,127276],"mapped",[114]],[[127277,127277],"mapped",[99,100]],[[127278,127278],"mapped",[119,122]],[[127279,127279],"disallowed"],[[127280,127280],"mapped",[97]],[[127281,127281],"mapped",[98]],[[127282,127282],"mapped",[99]],[[127283,127283],"mapped",[100]],[[127284,127284],"mapped",[101]],[[127285,127285],"mapped",[102]],[[127286,127286],"mapped",[103]],[[127287,127287],"mapped",[104]],[[127288,127288],"mapped",[105]],[[127289,127289],"mapped",[106]],[[127290,127290],"mapped",[107]],[[127291,127291],"mapped",[108]],[[127292,127292],"mapped",[109]],[[127293,127293],"mapped",[110]],[[127294,127294],"mapped",[111]],[[127295,127295],"mapped",[112]],[[127296,127296],"mapped",[113]],[[127297,127297],"mapped",[114]],[[127298,127298],"mapped",[115]],[[127299,127299],"mapped",[116]],[[127300,127300],"mapped",[117]],[[127301,127301],"mapped",[118]],[[127302,127302],"mapped",[119]],[[127303,127303],"mapped",[120]],[[127304,127304],"mapped",[121]],[[127305,127305],"mapped",[122]],[[127306,127306],"mapped",[104,118]],[[127307,127307],"mapped",[109,118]],[[127308,127308],"mapped",[115,100]],[[127309,127309],"mapped",[115,115]],[[127310,127310],"mapped",[112,112,118]],[[127311,127311],"mapped",[119,99]],[[127312,127318],"valid",[],"NV8"],[[127319,127319],"valid",[],"NV8"],[[127320,127326],"valid",[],"NV8"],[[127327,127327],"valid",[],"NV8"],[[127328,127337],"valid",[],"NV8"],[[127338,127338],"mapped",[109,99]],[[127339,127339],"mapped",[109,100]],[[127340,127343],"disallowed"],[[127344,127352],"valid",[],"NV8"],[[127353,127353],"valid",[],"NV8"],[[127354,127354],"valid",[],"NV8"],[[127355,127356],"valid",[],"NV8"],[[127357,127358],"valid",[],"NV8"],[[127359,127359],"valid",[],"NV8"],[[127360,127369],"valid",[],"NV8"],[[127370,127373],"valid",[],"NV8"],[[127374,127375],"valid",[],"NV8"],[[127376,127376],"mapped",[100,106]],[[127377,127386],"valid",[],"NV8"],[[127387,127461],"disallowed"],[[127462,127487],"valid",[],"NV8"],[[127488,127488],"mapped",[12411,12363]],[[127489,127489],"mapped",[12467,12467]],[[127490,127490],"mapped",[12469]],[[127491,127503],"disallowed"],[[127504,127504],"mapped",[25163]],[[127505,127505],"mapped",[23383]],[[127506,127506],"mapped",[21452]],[[127507,127507],"mapped",[12487]],[[127508,127508],"mapped",[20108]],[[127509,127509],"mapped",[22810]],[[127510,127510],"mapped",[35299]],[[127511,127511],"mapped",[22825]],[[127512,127512],"mapped",[20132]],[[127513,127513],"mapped",[26144]],[[127514,127514],"mapped",[28961]],[[127515,127515],"mapped",[26009]],[[127516,127516],"mapped",[21069]],[[127517,127517],"mapped",[24460]],[[127518,127518],"mapped",[20877]],[[127519,127519],"mapped",[26032]],[[127520,127520],"mapped",[21021]],[[127521,127521],"mapped",[32066]],[[127522,127522],"mapped",[29983]],[[127523,127523],"mapped",[36009]],[[127524,127524],"mapped",[22768]],[[127525,127525],"mapped",[21561]],[[127526,127526],"mapped",[28436]],[[127527,127527],"mapped",[25237]],[[127528,127528],"mapped",[25429]],[[127529,127529],"mapped",[19968]],[[127530,127530],"mapped",[19977]],[[127531,127531],"mapped",[36938]],[[127532,127532],"mapped",[24038]],[[127533,127533],"mapped",[20013]],[[127534,127534],"mapped",[21491]],[[127535,127535],"mapped",[25351]],[[127536,127536],"mapped",[36208]],[[127537,127537],"mapped",[25171]],[[127538,127538],"mapped",[31105]],[[127539,127539],"mapped",[31354]],[[127540,127540],"mapped",[21512]],[[127541,127541],"mapped",[28288]],[[127542,127542],"mapped",[26377]],[[127543,127543],"mapped",[26376]],[[127544,127544],"mapped",[30003]],[[127545,127545],"mapped",[21106]],[[127546,127546],"mapped",[21942]],[[127547,127551],"disallowed"],[[127552,127552],"mapped",[12308,26412,12309]],[[127553,127553],"mapped",[12308,19977,12309]],[[127554,127554],"mapped",[12308,20108,12309]],[[127555,127555],"mapped",[12308,23433,12309]],[[127556,127556],"mapped",[12308,28857,12309]],[[127557,127557],"mapped",[12308,25171,12309]],[[127558,127558],"mapped",[12308,30423,12309]],[[127559,127559],"mapped",[12308,21213,12309]],[[127560,127560],"mapped",[12308,25943,12309]],[[127561,127567],"disallowed"],[[127568,127568],"mapped",[24471]],[[127569,127569],"mapped",[21487]],[[127570,127743],"disallowed"],[[127744,127776],"valid",[],"NV8"],[[127777,127788],"valid",[],"NV8"],[[127789,127791],"valid",[],"NV8"],[[127792,127797],"valid",[],"NV8"],[[127798,127798],"valid",[],"NV8"],[[127799,127868],"valid",[],"NV8"],[[127869,127869],"valid",[],"NV8"],[[127870,127871],"valid",[],"NV8"],[[127872,127891],"valid",[],"NV8"],[[127892,127903],"valid",[],"NV8"],[[127904,127940],"valid",[],"NV8"],[[127941,127941],"valid",[],"NV8"],[[127942,127946],"valid",[],"NV8"],[[127947,127950],"valid",[],"NV8"],[[127951,127955],"valid",[],"NV8"],[[127956,127967],"valid",[],"NV8"],[[127968,127984],"valid",[],"NV8"],[[127985,127991],"valid",[],"NV8"],[[127992,127999],"valid",[],"NV8"],[[128000,128062],"valid",[],"NV8"],[[128063,128063],"valid",[],"NV8"],[[128064,128064],"valid",[],"NV8"],[[128065,128065],"valid",[],"NV8"],[[128066,128247],"valid",[],"NV8"],[[128248,128248],"valid",[],"NV8"],[[128249,128252],"valid",[],"NV8"],[[128253,128254],"valid",[],"NV8"],[[128255,128255],"valid",[],"NV8"],[[128256,128317],"valid",[],"NV8"],[[128318,128319],"valid",[],"NV8"],[[128320,128323],"valid",[],"NV8"],[[128324,128330],"valid",[],"NV8"],[[128331,128335],"valid",[],"NV8"],[[128336,128359],"valid",[],"NV8"],[[128360,128377],"valid",[],"NV8"],[[128378,128378],"disallowed"],[[128379,128419],"valid",[],"NV8"],[[128420,128420],"disallowed"],[[128421,128506],"valid",[],"NV8"],[[128507,128511],"valid",[],"NV8"],[[128512,128512],"valid",[],"NV8"],[[128513,128528],"valid",[],"NV8"],[[128529,128529],"valid",[],"NV8"],[[128530,128532],"valid",[],"NV8"],[[128533,128533],"valid",[],"NV8"],[[128534,128534],"valid",[],"NV8"],[[128535,128535],"valid",[],"NV8"],[[128536,128536],"valid",[],"NV8"],[[128537,128537],"valid",[],"NV8"],[[128538,128538],"valid",[],"NV8"],[[128539,128539],"valid",[],"NV8"],[[128540,128542],"valid",[],"NV8"],[[128543,128543],"valid",[],"NV8"],[[128544,128549],"valid",[],"NV8"],[[128550,128551],"valid",[],"NV8"],[[128552,128555],"valid",[],"NV8"],[[128556,128556],"valid",[],"NV8"],[[128557,128557],"valid",[],"NV8"],[[128558,128559],"valid",[],"NV8"],[[128560,128563],"valid",[],"NV8"],[[128564,128564],"valid",[],"NV8"],[[128565,128576],"valid",[],"NV8"],[[128577,128578],"valid",[],"NV8"],[[128579,128580],"valid",[],"NV8"],[[128581,128591],"valid",[],"NV8"],[[128592,128639],"valid",[],"NV8"],[[128640,128709],"valid",[],"NV8"],[[128710,128719],"valid",[],"NV8"],[[128720,128720],"valid",[],"NV8"],[[128721,128735],"disallowed"],[[128736,128748],"valid",[],"NV8"],[[128749,128751],"disallowed"],[[128752,128755],"valid",[],"NV8"],[[128756,128767],"disallowed"],[[128768,128883],"valid",[],"NV8"],[[128884,128895],"disallowed"],[[128896,128980],"valid",[],"NV8"],[[128981,129023],"disallowed"],[[129024,129035],"valid",[],"NV8"],[[129036,129039],"disallowed"],[[129040,129095],"valid",[],"NV8"],[[129096,129103],"disallowed"],[[129104,129113],"valid",[],"NV8"],[[129114,129119],"disallowed"],[[129120,129159],"valid",[],"NV8"],[[129160,129167],"disallowed"],[[129168,129197],"valid",[],"NV8"],[[129198,129295],"disallowed"],[[129296,129304],"valid",[],"NV8"],[[129305,129407],"disallowed"],[[129408,129412],"valid",[],"NV8"],[[129413,129471],"disallowed"],[[129472,129472],"valid",[],"NV8"],[[129473,131069],"disallowed"],[[131070,131071],"disallowed"],[[131072,173782],"valid"],[[173783,173823],"disallowed"],[[173824,177972],"valid"],[[177973,177983],"disallowed"],[[177984,178205],"valid"],[[178206,178207],"disallowed"],[[178208,183969],"valid"],[[183970,194559],"disallowed"],[[194560,194560],"mapped",[20029]],[[194561,194561],"mapped",[20024]],[[194562,194562],"mapped",[20033]],[[194563,194563],"mapped",[131362]],[[194564,194564],"mapped",[20320]],[[194565,194565],"mapped",[20398]],[[194566,194566],"mapped",[20411]],[[194567,194567],"mapped",[20482]],[[194568,194568],"mapped",[20602]],[[194569,194569],"mapped",[20633]],[[194570,194570],"mapped",[20711]],[[194571,194571],"mapped",[20687]],[[194572,194572],"mapped",[13470]],[[194573,194573],"mapped",[132666]],[[194574,194574],"mapped",[20813]],[[194575,194575],"mapped",[20820]],[[194576,194576],"mapped",[20836]],[[194577,194577],"mapped",[20855]],[[194578,194578],"mapped",[132380]],[[194579,194579],"mapped",[13497]],[[194580,194580],"mapped",[20839]],[[194581,194581],"mapped",[20877]],[[194582,194582],"mapped",[132427]],[[194583,194583],"mapped",[20887]],[[194584,194584],"mapped",[20900]],[[194585,194585],"mapped",[20172]],[[194586,194586],"mapped",[20908]],[[194587,194587],"mapped",[20917]],[[194588,194588],"mapped",[168415]],[[194589,194589],"mapped",[20981]],[[194590,194590],"mapped",[20995]],[[194591,194591],"mapped",[13535]],[[194592,194592],"mapped",[21051]],[[194593,194593],"mapped",[21062]],[[194594,194594],"mapped",[21106]],[[194595,194595],"mapped",[21111]],[[194596,194596],"mapped",[13589]],[[194597,194597],"mapped",[21191]],[[194598,194598],"mapped",[21193]],[[194599,194599],"mapped",[21220]],[[194600,194600],"mapped",[21242]],[[194601,194601],"mapped",[21253]],[[194602,194602],"mapped",[21254]],[[194603,194603],"mapped",[21271]],[[194604,194604],"mapped",[21321]],[[194605,194605],"mapped",[21329]],[[194606,194606],"mapped",[21338]],[[194607,194607],"mapped",[21363]],[[194608,194608],"mapped",[21373]],[[194609,194611],"mapped",[21375]],[[194612,194612],"mapped",[133676]],[[194613,194613],"mapped",[28784]],[[194614,194614],"mapped",[21450]],[[194615,194615],"mapped",[21471]],[[194616,194616],"mapped",[133987]],[[194617,194617],"mapped",[21483]],[[194618,194618],"mapped",[21489]],[[194619,194619],"mapped",[21510]],[[194620,194620],"mapped",[21662]],[[194621,194621],"mapped",[21560]],[[194622,194622],"mapped",[21576]],[[194623,194623],"mapped",[21608]],[[194624,194624],"mapped",[21666]],[[194625,194625],"mapped",[21750]],[[194626,194626],"mapped",[21776]],[[194627,194627],"mapped",[21843]],[[194628,194628],"mapped",[21859]],[[194629,194630],"mapped",[21892]],[[194631,194631],"mapped",[21913]],[[194632,194632],"mapped",[21931]],[[194633,194633],"mapped",[21939]],[[194634,194634],"mapped",[21954]],[[194635,194635],"mapped",[22294]],[[194636,194636],"mapped",[22022]],[[194637,194637],"mapped",[22295]],[[194638,194638],"mapped",[22097]],[[194639,194639],"mapped",[22132]],[[194640,194640],"mapped",[20999]],[[194641,194641],"mapped",[22766]],[[194642,194642],"mapped",[22478]],[[194643,194643],"mapped",[22516]],[[194644,194644],"mapped",[22541]],[[194645,194645],"mapped",[22411]],[[194646,194646],"mapped",[22578]],[[194647,194647],"mapped",[22577]],[[194648,194648],"mapped",[22700]],[[194649,194649],"mapped",[136420]],[[194650,194650],"mapped",[22770]],[[194651,194651],"mapped",[22775]],[[194652,194652],"mapped",[22790]],[[194653,194653],"mapped",[22810]],[[194654,194654],"mapped",[22818]],[[194655,194655],"mapped",[22882]],[[194656,194656],"mapped",[136872]],[[194657,194657],"mapped",[136938]],[[194658,194658],"mapped",[23020]],[[194659,194659],"mapped",[23067]],[[194660,194660],"mapped",[23079]],[[194661,194661],"mapped",[23000]],[[194662,194662],"mapped",[23142]],[[194663,194663],"mapped",[14062]],[[194664,194664],"disallowed"],[[194665,194665],"mapped",[23304]],[[194666,194667],"mapped",[23358]],[[194668,194668],"mapped",[137672]],[[194669,194669],"mapped",[23491]],[[194670,194670],"mapped",[23512]],[[194671,194671],"mapped",[23527]],[[194672,194672],"mapped",[23539]],[[194673,194673],"mapped",[138008]],[[194674,194674],"mapped",[23551]],[[194675,194675],"mapped",[23558]],[[194676,194676],"disallowed"],[[194677,194677],"mapped",[23586]],[[194678,194678],"mapped",[14209]],[[194679,194679],"mapped",[23648]],[[194680,194680],"mapped",[23662]],[[194681,194681],"mapped",[23744]],[[194682,194682],"mapped",[23693]],[[194683,194683],"mapped",[138724]],[[194684,194684],"mapped",[23875]],[[194685,194685],"mapped",[138726]],[[194686,194686],"mapped",[23918]],[[194687,194687],"mapped",[23915]],[[194688,194688],"mapped",[23932]],[[194689,194689],"mapped",[24033]],[[194690,194690],"mapped",[24034]],[[194691,194691],"mapped",[14383]],[[194692,194692],"mapped",[24061]],[[194693,194693],"mapped",[24104]],[[194694,194694],"mapped",[24125]],[[194695,194695],"mapped",[24169]],[[194696,194696],"mapped",[14434]],[[194697,194697],"mapped",[139651]],[[194698,194698],"mapped",[14460]],[[194699,194699],"mapped",[24240]],[[194700,194700],"mapped",[24243]],[[194701,194701],"mapped",[24246]],[[194702,194702],"mapped",[24266]],[[194703,194703],"mapped",[172946]],[[194704,194704],"mapped",[24318]],[[194705,194706],"mapped",[140081]],[[194707,194707],"mapped",[33281]],[[194708,194709],"mapped",[24354]],[[194710,194710],"mapped",[14535]],[[194711,194711],"mapped",[144056]],[[194712,194712],"mapped",[156122]],[[194713,194713],"mapped",[24418]],[[194714,194714],"mapped",[24427]],[[194715,194715],"mapped",[14563]],[[194716,194716],"mapped",[24474]],[[194717,194717],"mapped",[24525]],[[194718,194718],"mapped",[24535]],[[194719,194719],"mapped",[24569]],[[194720,194720],"mapped",[24705]],[[194721,194721],"mapped",[14650]],[[194722,194722],"mapped",[14620]],[[194723,194723],"mapped",[24724]],[[194724,194724],"mapped",[141012]],[[194725,194725],"mapped",[24775]],[[194726,194726],"mapped",[24904]],[[194727,194727],"mapped",[24908]],[[194728,194728],"mapped",[24910]],[[194729,194729],"mapped",[24908]],[[194730,194730],"mapped",[24954]],[[194731,194731],"mapped",[24974]],[[194732,194732],"mapped",[25010]],[[194733,194733],"mapped",[24996]],[[194734,194734],"mapped",[25007]],[[194735,194735],"mapped",[25054]],[[194736,194736],"mapped",[25074]],[[194737,194737],"mapped",[25078]],[[194738,194738],"mapped",[25104]],[[194739,194739],"mapped",[25115]],[[194740,194740],"mapped",[25181]],[[194741,194741],"mapped",[25265]],[[194742,194742],"mapped",[25300]],[[194743,194743],"mapped",[25424]],[[194744,194744],"mapped",[142092]],[[194745,194745],"mapped",[25405]],[[194746,194746],"mapped",[25340]],[[194747,194747],"mapped",[25448]],[[194748,194748],"mapped",[25475]],[[194749,194749],"mapped",[25572]],[[194750,194750],"mapped",[142321]],[[194751,194751],"mapped",[25634]],[[194752,194752],"mapped",[25541]],[[194753,194753],"mapped",[25513]],[[194754,194754],"mapped",[14894]],[[194755,194755],"mapped",[25705]],[[194756,194756],"mapped",[25726]],[[194757,194757],"mapped",[25757]],[[194758,194758],"mapped",[25719]],[[194759,194759],"mapped",[14956]],[[194760,194760],"mapped",[25935]],[[194761,194761],"mapped",[25964]],[[194762,194762],"mapped",[143370]],[[194763,194763],"mapped",[26083]],[[194764,194764],"mapped",[26360]],[[194765,194765],"mapped",[26185]],[[194766,194766],"mapped",[15129]],[[194767,194767],"mapped",[26257]],[[194768,194768],"mapped",[15112]],[[194769,194769],"mapped",[15076]],[[194770,194770],"mapped",[20882]],[[194771,194771],"mapped",[20885]],[[194772,194772],"mapped",[26368]],[[194773,194773],"mapped",[26268]],[[194774,194774],"mapped",[32941]],[[194775,194775],"mapped",[17369]],[[194776,194776],"mapped",[26391]],[[194777,194777],"mapped",[26395]],[[194778,194778],"mapped",[26401]],[[194779,194779],"mapped",[26462]],[[194780,194780],"mapped",[26451]],[[194781,194781],"mapped",[144323]],[[194782,194782],"mapped",[15177]],[[194783,194783],"mapped",[26618]],[[194784,194784],"mapped",[26501]],[[194785,194785],"mapped",[26706]],[[194786,194786],"mapped",[26757]],[[194787,194787],"mapped",[144493]],[[194788,194788],"mapped",[26766]],[[194789,194789],"mapped",[26655]],[[194790,194790],"mapped",[26900]],[[194791,194791],"mapped",[15261]],[[194792,194792],"mapped",[26946]],[[194793,194793],"mapped",[27043]],[[194794,194794],"mapped",[27114]],[[194795,194795],"mapped",[27304]],[[194796,194796],"mapped",[145059]],[[194797,194797],"mapped",[27355]],[[194798,194798],"mapped",[15384]],[[194799,194799],"mapped",[27425]],[[194800,194800],"mapped",[145575]],[[194801,194801],"mapped",[27476]],[[194802,194802],"mapped",[15438]],[[194803,194803],"mapped",[27506]],[[194804,194804],"mapped",[27551]],[[194805,194805],"mapped",[27578]],[[194806,194806],"mapped",[27579]],[[194807,194807],"mapped",[146061]],[[194808,194808],"mapped",[138507]],[[194809,194809],"mapped",[146170]],[[194810,194810],"mapped",[27726]],[[194811,194811],"mapped",[146620]],[[194812,194812],"mapped",[27839]],[[194813,194813],"mapped",[27853]],[[194814,194814],"mapped",[27751]],[[194815,194815],"mapped",[27926]],[[194816,194816],"mapped",[27966]],[[194817,194817],"mapped",[28023]],[[194818,194818],"mapped",[27969]],[[194819,194819],"mapped",[28009]],[[194820,194820],"mapped",[28024]],[[194821,194821],"mapped",[28037]],[[194822,194822],"mapped",[146718]],[[194823,194823],"mapped",[27956]],[[194824,194824],"mapped",[28207]],[[194825,194825],"mapped",[28270]],[[194826,194826],"mapped",[15667]],[[194827,194827],"mapped",[28363]],[[194828,194828],"mapped",[28359]],[[194829,194829],"mapped",[147153]],[[194830,194830],"mapped",[28153]],[[194831,194831],"mapped",[28526]],[[194832,194832],"mapped",[147294]],[[194833,194833],"mapped",[147342]],[[194834,194834],"mapped",[28614]],[[194835,194835],"mapped",[28729]],[[194836,194836],"mapped",[28702]],[[194837,194837],"mapped",[28699]],[[194838,194838],"mapped",[15766]],[[194839,194839],"mapped",[28746]],[[194840,194840],"mapped",[28797]],[[194841,194841],"mapped",[28791]],[[194842,194842],"mapped",[28845]],[[194843,194843],"mapped",[132389]],[[194844,194844],"mapped",[28997]],[[194845,194845],"mapped",[148067]],[[194846,194846],"mapped",[29084]],[[194847,194847],"disallowed"],[[194848,194848],"mapped",[29224]],[[194849,194849],"mapped",[29237]],[[194850,194850],"mapped",[29264]],[[194851,194851],"mapped",[149000]],[[194852,194852],"mapped",[29312]],[[194853,194853],"mapped",[29333]],[[194854,194854],"mapped",[149301]],[[194855,194855],"mapped",[149524]],[[194856,194856],"mapped",[29562]],[[194857,194857],"mapped",[29579]],[[194858,194858],"mapped",[16044]],[[194859,194859],"mapped",[29605]],[[194860,194861],"mapped",[16056]],[[194862,194862],"mapped",[29767]],[[194863,194863],"mapped",[29788]],[[194864,194864],"mapped",[29809]],[[194865,194865],"mapped",[29829]],[[194866,194866],"mapped",[29898]],[[194867,194867],"mapped",[16155]],[[194868,194868],"mapped",[29988]],[[194869,194869],"mapped",[150582]],[[194870,194870],"mapped",[30014]],[[194871,194871],"mapped",[150674]],[[194872,194872],"mapped",[30064]],[[194873,194873],"mapped",[139679]],[[194874,194874],"mapped",[30224]],[[194875,194875],"mapped",[151457]],[[194876,194876],"mapped",[151480]],[[194877,194877],"mapped",[151620]],[[194878,194878],"mapped",[16380]],[[194879,194879],"mapped",[16392]],[[194880,194880],"mapped",[30452]],[[194881,194881],"mapped",[151795]],[[194882,194882],"mapped",[151794]],[[194883,194883],"mapped",[151833]],[[194884,194884],"mapped",[151859]],[[194885,194885],"mapped",[30494]],[[194886,194887],"mapped",[30495]],[[194888,194888],"mapped",[30538]],[[194889,194889],"mapped",[16441]],[[194890,194890],"mapped",[30603]],[[194891,194891],"mapped",[16454]],[[194892,194892],"mapped",[16534]],[[194893,194893],"mapped",[152605]],[[194894,194894],"mapped",[30798]],[[194895,194895],"mapped",[30860]],[[194896,194896],"mapped",[30924]],[[194897,194897],"mapped",[16611]],[[194898,194898],"mapped",[153126]],[[194899,194899],"mapped",[31062]],[[194900,194900],"mapped",[153242]],[[194901,194901],"mapped",[153285]],[[194902,194902],"mapped",[31119]],[[194903,194903],"mapped",[31211]],[[194904,194904],"mapped",[16687]],[[194905,194905],"mapped",[31296]],[[194906,194906],"mapped",[31306]],[[194907,194907],"mapped",[31311]],[[194908,194908],"mapped",[153980]],[[194909,194910],"mapped",[154279]],[[194911,194911],"disallowed"],[[194912,194912],"mapped",[16898]],[[194913,194913],"mapped",[154539]],[[194914,194914],"mapped",[31686]],[[194915,194915],"mapped",[31689]],[[194916,194916],"mapped",[16935]],[[194917,194917],"mapped",[154752]],[[194918,194918],"mapped",[31954]],[[194919,194919],"mapped",[17056]],[[194920,194920],"mapped",[31976]],[[194921,194921],"mapped",[31971]],[[194922,194922],"mapped",[32000]],[[194923,194923],"mapped",[155526]],[[194924,194924],"mapped",[32099]],[[194925,194925],"mapped",[17153]],[[194926,194926],"mapped",[32199]],[[194927,194927],"mapped",[32258]],[[194928,194928],"mapped",[32325]],[[194929,194929],"mapped",[17204]],[[194930,194930],"mapped",[156200]],[[194931,194931],"mapped",[156231]],[[194932,194932],"mapped",[17241]],[[194933,194933],"mapped",[156377]],[[194934,194934],"mapped",[32634]],[[194935,194935],"mapped",[156478]],[[194936,194936],"mapped",[32661]],[[194937,194937],"mapped",[32762]],[[194938,194938],"mapped",[32773]],[[194939,194939],"mapped",[156890]],[[194940,194940],"mapped",[156963]],[[194941,194941],"mapped",[32864]],[[194942,194942],"mapped",[157096]],[[194943,194943],"mapped",[32880]],[[194944,194944],"mapped",[144223]],[[194945,194945],"mapped",[17365]],[[194946,194946],"mapped",[32946]],[[194947,194947],"mapped",[33027]],[[194948,194948],"mapped",[17419]],[[194949,194949],"mapped",[33086]],[[194950,194950],"mapped",[23221]],[[194951,194951],"mapped",[157607]],[[194952,194952],"mapped",[157621]],[[194953,194953],"mapped",[144275]],[[194954,194954],"mapped",[144284]],[[194955,194955],"mapped",[33281]],[[194956,194956],"mapped",[33284]],[[194957,194957],"mapped",[36766]],[[194958,194958],"mapped",[17515]],[[194959,194959],"mapped",[33425]],[[194960,194960],"mapped",[33419]],[[194961,194961],"mapped",[33437]],[[194962,194962],"mapped",[21171]],[[194963,194963],"mapped",[33457]],[[194964,194964],"mapped",[33459]],[[194965,194965],"mapped",[33469]],[[194966,194966],"mapped",[33510]],[[194967,194967],"mapped",[158524]],[[194968,194968],"mapped",[33509]],[[194969,194969],"mapped",[33565]],[[194970,194970],"mapped",[33635]],[[194971,194971],"mapped",[33709]],[[194972,194972],"mapped",[33571]],[[194973,194973],"mapped",[33725]],[[194974,194974],"mapped",[33767]],[[194975,194975],"mapped",[33879]],[[194976,194976],"mapped",[33619]],[[194977,194977],"mapped",[33738]],[[194978,194978],"mapped",[33740]],[[194979,194979],"mapped",[33756]],[[194980,194980],"mapped",[158774]],[[194981,194981],"mapped",[159083]],[[194982,194982],"mapped",[158933]],[[194983,194983],"mapped",[17707]],[[194984,194984],"mapped",[34033]],[[194985,194985],"mapped",[34035]],[[194986,194986],"mapped",[34070]],[[194987,194987],"mapped",[160714]],[[194988,194988],"mapped",[34148]],[[194989,194989],"mapped",[159532]],[[194990,194990],"mapped",[17757]],[[194991,194991],"mapped",[17761]],[[194992,194992],"mapped",[159665]],[[194993,194993],"mapped",[159954]],[[194994,194994],"mapped",[17771]],[[194995,194995],"mapped",[34384]],[[194996,194996],"mapped",[34396]],[[194997,194997],"mapped",[34407]],[[194998,194998],"mapped",[34409]],[[194999,194999],"mapped",[34473]],[[195000,195000],"mapped",[34440]],[[195001,195001],"mapped",[34574]],[[195002,195002],"mapped",[34530]],[[195003,195003],"mapped",[34681]],[[195004,195004],"mapped",[34600]],[[195005,195005],"mapped",[34667]],[[195006,195006],"mapped",[34694]],[[195007,195007],"disallowed"],[[195008,195008],"mapped",[34785]],[[195009,195009],"mapped",[34817]],[[195010,195010],"mapped",[17913]],[[195011,195011],"mapped",[34912]],[[195012,195012],"mapped",[34915]],[[195013,195013],"mapped",[161383]],[[195014,195014],"mapped",[35031]],[[195015,195015],"mapped",[35038]],[[195016,195016],"mapped",[17973]],[[195017,195017],"mapped",[35066]],[[195018,195018],"mapped",[13499]],[[195019,195019],"mapped",[161966]],[[195020,195020],"mapped",[162150]],[[195021,195021],"mapped",[18110]],[[195022,195022],"mapped",[18119]],[[195023,195023],"mapped",[35488]],[[195024,195024],"mapped",[35565]],[[195025,195025],"mapped",[35722]],[[195026,195026],"mapped",[35925]],[[195027,195027],"mapped",[162984]],[[195028,195028],"mapped",[36011]],[[195029,195029],"mapped",[36033]],[[195030,195030],"mapped",[36123]],[[195031,195031],"mapped",[36215]],[[195032,195032],"mapped",[163631]],[[195033,195033],"mapped",[133124]],[[195034,195034],"mapped",[36299]],[[195035,195035],"mapped",[36284]],[[195036,195036],"mapped",[36336]],[[195037,195037],"mapped",[133342]],[[195038,195038],"mapped",[36564]],[[195039,195039],"mapped",[36664]],[[195040,195040],"mapped",[165330]],[[195041,195041],"mapped",[165357]],[[195042,195042],"mapped",[37012]],[[195043,195043],"mapped",[37105]],[[195044,195044],"mapped",[37137]],[[195045,195045],"mapped",[165678]],[[195046,195046],"mapped",[37147]],[[195047,195047],"mapped",[37432]],[[195048,195048],"mapped",[37591]],[[195049,195049],"mapped",[37592]],[[195050,195050],"mapped",[37500]],[[195051,195051],"mapped",[37881]],[[195052,195052],"mapped",[37909]],[[195053,195053],"mapped",[166906]],[[195054,195054],"mapped",[38283]],[[195055,195055],"mapped",[18837]],[[195056,195056],"mapped",[38327]],[[195057,195057],"mapped",[167287]],[[195058,195058],"mapped",[18918]],[[195059,195059],"mapped",[38595]],[[195060,195060],"mapped",[23986]],[[195061,195061],"mapped",[38691]],[[195062,195062],"mapped",[168261]],[[195063,195063],"mapped",[168474]],[[195064,195064],"mapped",[19054]],[[195065,195065],"mapped",[19062]],[[195066,195066],"mapped",[38880]],[[195067,195067],"mapped",[168970]],[[195068,195068],"mapped",[19122]],[[195069,195069],"mapped",[169110]],[[195070,195071],"mapped",[38923]],[[195072,195072],"mapped",[38953]],[[195073,195073],"mapped",[169398]],[[195074,195074],"mapped",[39138]],[[195075,195075],"mapped",[19251]],[[195076,195076],"mapped",[39209]],[[195077,195077],"mapped",[39335]],[[195078,195078],"mapped",[39362]],[[195079,195079],"mapped",[39422]],[[195080,195080],"mapped",[19406]],[[195081,195081],"mapped",[170800]],[[195082,195082],"mapped",[39698]],[[195083,195083],"mapped",[40000]],[[195084,195084],"mapped",[40189]],[[195085,195085],"mapped",[19662]],[[195086,195086],"mapped",[19693]],[[195087,195087],"mapped",[40295]],[[195088,195088],"mapped",[172238]],[[195089,195089],"mapped",[19704]],[[195090,195090],"mapped",[172293]],[[195091,195091],"mapped",[172558]],[[195092,195092],"mapped",[172689]],[[195093,195093],"mapped",[40635]],[[195094,195094],"mapped",[19798]],[[195095,195095],"mapped",[40697]],[[195096,195096],"mapped",[40702]],[[195097,195097],"mapped",[40709]],[[195098,195098],"mapped",[40719]],[[195099,195099],"mapped",[40726]],[[195100,195100],"mapped",[40763]],[[195101,195101],"mapped",[173568]],[[195102,196605],"disallowed"],[[196606,196607],"disallowed"],[[196608,262141],"disallowed"],[[262142,262143],"disallowed"],[[262144,327677],"disallowed"],[[327678,327679],"disallowed"],[[327680,393213],"disallowed"],[[393214,393215],"disallowed"],[[393216,458749],"disallowed"],[[458750,458751],"disallowed"],[[458752,524285],"disallowed"],[[524286,524287],"disallowed"],[[524288,589821],"disallowed"],[[589822,589823],"disallowed"],[[589824,655357],"disallowed"],[[655358,655359],"disallowed"],[[655360,720893],"disallowed"],[[720894,720895],"disallowed"],[[720896,786429],"disallowed"],[[786430,786431],"disallowed"],[[786432,851965],"disallowed"],[[851966,851967],"disallowed"],[[851968,917501],"disallowed"],[[917502,917503],"disallowed"],[[917504,917504],"disallowed"],[[917505,917505],"disallowed"],[[917506,917535],"disallowed"],[[917536,917631],"disallowed"],[[917632,917759],"disallowed"],[[917760,917999],"ignored"],[[918000,983037],"disallowed"],[[983038,983039],"disallowed"],[[983040,1048573],"disallowed"],[[1048574,1048575],"disallowed"],[[1048576,1114109],"disallowed"],[[1114110,1114111],"disallowed"]]');
    }
};
var __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
        id: moduleId,
        loaded: false,
        exports: {}
    };
    __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    module.loaded = true;
    return module.exports;
}
__webpack_require__.m = __webpack_modules__;
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.f = {};
    __webpack_require__.e = (chunkId)=>Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key)=>{
            __webpack_require__.f[key](chunkId, promises);
            return promises;
        }, []));
})();
(()=>{
    __webpack_require__.u = (chunkId)=>"" + chunkId + ".js";
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
(()=>{
    __webpack_require__.nmd = (module)=>{
        module.paths = [];
        if (!module.children) module.children = [];
        return module;
    };
})();
(()=>{
    var installedChunks = {
        980: 1
    };
    var installChunk = (chunk)=>{
        var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
        for(var moduleId in moreModules)if (__webpack_require__.o(moreModules, moduleId)) __webpack_require__.m[moduleId] = moreModules[moduleId];
        if (runtime) runtime(__webpack_require__);
        for(var i = 0; i < chunkIds.length; i++)installedChunks[chunkIds[i]] = 1;
    };
    __webpack_require__.f.require = (chunkId, promises)=>{
        if (!installedChunks[chunkId]) installChunk(require("./" + __webpack_require__.u(chunkId)));
    };
})();
var __webpack_exports__ = {};
(()=>{
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    __webpack_require__.d(__webpack_exports__, {
        bootstrapCli: ()=>bootstrapCli
    });
    const external_events_namespaceObject = require("events");
    function toArr(any) {
        return null == any ? [] : Array.isArray(any) ? any : [
            any
        ];
    }
    function toVal(out, key, val, opts) {
        var x, old = out[key], nxt = ~opts.string.indexOf(key) ? null == val || true === val ? '' : String(val) : 'boolean' == typeof val ? val : ~opts.boolean.indexOf(key) ? 'false' === val ? false : 'true' === val || (out._.push((x = +val, 0 * x === 0) ? x : val), !!val) : (x = +val, 0 * x === 0) ? x : val;
        out[key] = null == old ? nxt : Array.isArray(old) ? old.concat(nxt) : [
            old,
            nxt
        ];
    }
    function mri2(args, opts) {
        args = args || [];
        opts = opts || {};
        var k, arr, arg, name, val, out = {
            _: []
        };
        var i = 0, j = 0, idx = 0, len = args.length;
        const alibi = void 0 !== opts.alias;
        const strict = void 0 !== opts.unknown;
        const defaults = void 0 !== opts.default;
        opts.alias = opts.alias || {};
        opts.string = toArr(opts.string);
        opts.boolean = toArr(opts.boolean);
        if (alibi) for(k in opts.alias){
            arr = opts.alias[k] = toArr(opts.alias[k]);
            for(i = 0; i < arr.length; i++)(opts.alias[arr[i]] = arr.concat(k)).splice(i, 1);
        }
        for(i = opts.boolean.length; i-- > 0;){
            arr = opts.alias[opts.boolean[i]] || [];
            for(j = arr.length; j-- > 0;)opts.boolean.push(arr[j]);
        }
        for(i = opts.string.length; i-- > 0;){
            arr = opts.alias[opts.string[i]] || [];
            for(j = arr.length; j-- > 0;)opts.string.push(arr[j]);
        }
        if (defaults) for(k in opts.default){
            name = typeof opts.default[k];
            arr = opts.alias[k] = opts.alias[k] || [];
            if (void 0 !== opts[name]) {
                opts[name].push(k);
                for(i = 0; i < arr.length; i++)opts[name].push(arr[i]);
            }
        }
        const keys = strict ? Object.keys(opts.alias) : [];
        for(i = 0; i < len; i++){
            arg = args[i];
            if ('--' === arg) {
                out._ = out._.concat(args.slice(++i));
                break;
            }
            for(j = 0; j < arg.length && 45 === arg.charCodeAt(j); j++);
            if (0 === j) out._.push(arg);
            else if ('no-' === arg.substring(j, j + 3)) {
                name = arg.substring(j + 3);
                if (strict && !~keys.indexOf(name)) return opts.unknown(arg);
                out[name] = false;
            } else {
                for(idx = j + 1; idx < arg.length && 61 !== arg.charCodeAt(idx); idx++);
                name = arg.substring(j, idx);
                val = arg.substring(++idx) || i + 1 === len || 45 === ('' + args[i + 1]).charCodeAt(0) || args[++i];
                arr = 2 === j ? [
                    name
                ] : name;
                for(idx = 0; idx < arr.length; idx++){
                    name = arr[idx];
                    if (strict && !~keys.indexOf(name)) return opts.unknown('-'.repeat(j) + name);
                    toVal(out, name, idx + 1 < arr.length || val, opts);
                }
            }
        }
        if (defaults) {
            for(k in opts.default)if (void 0 === out[k]) out[k] = opts.default[k];
        }
        if (alibi) for(k in out){
            arr = opts.alias[k] || [];
            while(arr.length > 0)out[arr.shift()] = out[k];
        }
        return out;
    }
    const removeBrackets = (v)=>v.replace(/[<[].+/, "").trim();
    const findAllBrackets = (v)=>{
        const ANGLED_BRACKET_RE_GLOBAL = /<([^>]+)>/g;
        const SQUARE_BRACKET_RE_GLOBAL = /\[([^\]]+)\]/g;
        const res = [];
        const parse = (match)=>{
            let variadic = false;
            let value = match[1];
            if (value.startsWith("...")) {
                value = value.slice(3);
                variadic = true;
            }
            return {
                required: match[0].startsWith("<"),
                value,
                variadic
            };
        };
        let angledMatch;
        while(angledMatch = ANGLED_BRACKET_RE_GLOBAL.exec(v))res.push(parse(angledMatch));
        let squareMatch;
        while(squareMatch = SQUARE_BRACKET_RE_GLOBAL.exec(v))res.push(parse(squareMatch));
        return res;
    };
    const getMriOptions = (options)=>{
        const result = {
            alias: {},
            boolean: []
        };
        for (const [index, option] of options.entries()){
            if (option.names.length > 1) result.alias[option.names[0]] = option.names.slice(1);
            if (option.isBoolean) if (option.negated) {
                const hasStringTypeOption = options.some((o, i)=>i !== index && o.names.some((name)=>option.names.includes(name)) && "boolean" == typeof o.required);
                if (!hasStringTypeOption) result.boolean.push(option.names[0]);
            } else result.boolean.push(option.names[0]);
        }
        return result;
    };
    const findLongest = (arr)=>arr.sort((a, b)=>a.length > b.length ? -1 : 1)[0];
    const padRight = (str, length)=>str.length >= length ? str : `${str}${" ".repeat(length - str.length)}`;
    const camelcase = (input)=>input.replace(/([a-z])-([a-z])/g, (_, p1, p2)=>p1 + p2.toUpperCase());
    const setDotProp = (obj, keys, val)=>{
        let i = 0;
        let length = keys.length;
        let t = obj;
        let x;
        for(; i < length; ++i){
            x = t[keys[i]];
            t = t[keys[i]] = i === length - 1 ? val : null != x ? x : !~keys[i + 1].indexOf(".") && +keys[i + 1] > -1 ? [] : {};
        }
    };
    const setByType = (obj, transforms)=>{
        for (const key of Object.keys(transforms)){
            const transform = transforms[key];
            if (transform.shouldTransform) {
                obj[key] = Array.prototype.concat.call([], obj[key]);
                if ("function" == typeof transform.transformFunction) obj[key] = obj[key].map(transform.transformFunction);
            }
        }
    };
    const getFileName = (input)=>{
        const m = /([^\\\/]+)$/.exec(input);
        return m ? m[1] : "";
    };
    const camelcaseOptionName = (name)=>name.split(".").map((v, i)=>0 === i ? camelcase(v) : v).join(".");
    class CACError extends Error {
        constructor(message){
            super(message);
            this.name = this.constructor.name;
            if ("function" == typeof Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
            else this.stack = new Error(message).stack;
        }
    }
    class Option {
        constructor(rawName, description, config){
            this.rawName = rawName;
            this.description = description;
            this.config = Object.assign({}, config);
            rawName = rawName.replace(/\.\*/g, "");
            this.negated = false;
            this.names = removeBrackets(rawName).split(",").map((v)=>{
                let name = v.trim().replace(/^-{1,2}/, "");
                if (name.startsWith("no-")) {
                    this.negated = true;
                    name = name.replace(/^no-/, "");
                }
                return camelcaseOptionName(name);
            }).sort((a, b)=>a.length > b.length ? 1 : -1);
            this.name = this.names[this.names.length - 1];
            if (this.negated && null == this.config.default) this.config.default = true;
            if (rawName.includes("<")) this.required = true;
            else if (rawName.includes("[")) this.required = false;
            else this.isBoolean = true;
        }
    }
    const processArgs = process.argv;
    const platformInfo = `${process.platform}-${process.arch} node-${process.version}`;
    class Command {
        constructor(rawName, description, config = {}, cli){
            this.rawName = rawName;
            this.description = description;
            this.config = config;
            this.cli = cli;
            this.options = [];
            this.aliasNames = [];
            this.name = removeBrackets(rawName);
            this.args = findAllBrackets(rawName);
            this.examples = [];
        }
        usage(text) {
            this.usageText = text;
            return this;
        }
        allowUnknownOptions() {
            this.config.allowUnknownOptions = true;
            return this;
        }
        ignoreOptionDefaultValue() {
            this.config.ignoreOptionDefaultValue = true;
            return this;
        }
        version(version, customFlags = "-v, --version") {
            this.versionNumber = version;
            this.option(customFlags, "Display version number");
            return this;
        }
        example(example) {
            this.examples.push(example);
            return this;
        }
        option(rawName, description, config) {
            const option = new Option(rawName, description, config);
            this.options.push(option);
            return this;
        }
        alias(name) {
            this.aliasNames.push(name);
            return this;
        }
        action(callback) {
            this.commandAction = callback;
            return this;
        }
        isMatched(name) {
            return this.name === name || this.aliasNames.includes(name);
        }
        get isDefaultCommand() {
            return "" === this.name || this.aliasNames.includes("!");
        }
        get isGlobalCommand() {
            return this instanceof GlobalCommand;
        }
        hasOption(name) {
            name = name.split(".")[0];
            return this.options.find((option)=>option.names.includes(name));
        }
        outputHelp() {
            const { name, commands } = this.cli;
            const { versionNumber, options: globalOptions, helpCallback } = this.cli.globalCommand;
            let sections = [
                {
                    body: `${name}${versionNumber ? `/${versionNumber}` : ""}`
                }
            ];
            sections.push({
                title: "Usage",
                body: `  $ ${name} ${this.usageText || this.rawName}`
            });
            const showCommands = (this.isGlobalCommand || this.isDefaultCommand) && commands.length > 0;
            if (showCommands) {
                const longestCommandName = findLongest(commands.map((command)=>command.rawName));
                sections.push({
                    title: "Commands",
                    body: commands.map((command)=>`  ${padRight(command.rawName, longestCommandName.length)}  ${command.description}`).join("\n")
                });
                sections.push({
                    title: "For more info, run any command with the `--help` flag",
                    body: commands.map((command)=>`  $ ${name}${"" === command.name ? "" : ` ${command.name}`} --help`).join("\n")
                });
            }
            let options = this.isGlobalCommand ? globalOptions : [
                ...this.options,
                ...globalOptions || []
            ];
            if (!this.isGlobalCommand && !this.isDefaultCommand) options = options.filter((option)=>"version" !== option.name);
            if (options.length > 0) {
                const longestOptionName = findLongest(options.map((option)=>option.rawName));
                sections.push({
                    title: "Options",
                    body: options.map((option)=>`  ${padRight(option.rawName, longestOptionName.length)}  ${option.description} ${void 0 === option.config.default ? "" : `(default: ${option.config.default})`}`).join("\n")
                });
            }
            if (this.examples.length > 0) sections.push({
                title: "Examples",
                body: this.examples.map((example)=>{
                    if ("function" == typeof example) return example(name);
                    return example;
                }).join("\n")
            });
            if (helpCallback) sections = helpCallback(sections) || sections;
            console.log(sections.map((section)=>section.title ? `${section.title}:
${section.body}` : section.body).join("\n\n"));
        }
        outputVersion() {
            const { name } = this.cli;
            const { versionNumber } = this.cli.globalCommand;
            if (versionNumber) console.log(`${name}/${versionNumber} ${platformInfo}`);
        }
        checkRequiredArgs() {
            const minimalArgsCount = this.args.filter((arg)=>arg.required).length;
            if (this.cli.args.length < minimalArgsCount) throw new CACError(`missing required args for command \`${this.rawName}\``);
        }
        checkUnknownOptions() {
            const { options, globalCommand } = this.cli;
            if (!this.config.allowUnknownOptions) {
                for (const name of Object.keys(options))if ("--" !== name && !this.hasOption(name) && !globalCommand.hasOption(name)) throw new CACError(`Unknown option \`${name.length > 1 ? `--${name}` : `-${name}`}\``);
            }
        }
        checkOptionValue() {
            const { options: parsedOptions, globalCommand } = this.cli;
            const options = [
                ...globalCommand.options,
                ...this.options
            ];
            for (const option of options){
                const value = parsedOptions[option.name.split(".")[0]];
                if (option.required) {
                    const hasNegated = options.some((o)=>o.negated && o.names.includes(option.name));
                    if (true === value || false === value && !hasNegated) throw new CACError(`option \`${option.rawName}\` value is missing`);
                }
            }
        }
    }
    class GlobalCommand extends Command {
        constructor(cli){
            super("@@global@@", "", {}, cli);
        }
    }
    var __assign = Object.assign;
    class CAC extends external_events_namespaceObject.EventEmitter {
        constructor(name = ""){
            super();
            this.name = name;
            this.commands = [];
            this.rawArgs = [];
            this.args = [];
            this.options = {};
            this.globalCommand = new GlobalCommand(this);
            this.globalCommand.usage("<command> [options]");
        }
        usage(text) {
            this.globalCommand.usage(text);
            return this;
        }
        command(rawName, description, config) {
            const command = new Command(rawName, description || "", config, this);
            command.globalCommand = this.globalCommand;
            this.commands.push(command);
            return command;
        }
        option(rawName, description, config) {
            this.globalCommand.option(rawName, description, config);
            return this;
        }
        help(callback) {
            this.globalCommand.option("-h, --help", "Display this message");
            this.globalCommand.helpCallback = callback;
            this.showHelpOnExit = true;
            return this;
        }
        version(version, customFlags = "-v, --version") {
            this.globalCommand.version(version, customFlags);
            this.showVersionOnExit = true;
            return this;
        }
        example(example) {
            this.globalCommand.example(example);
            return this;
        }
        outputHelp() {
            if (this.matchedCommand) this.matchedCommand.outputHelp();
            else this.globalCommand.outputHelp();
        }
        outputVersion() {
            this.globalCommand.outputVersion();
        }
        setParsedInfo({ args, options }, matchedCommand, matchedCommandName) {
            this.args = args;
            this.options = options;
            if (matchedCommand) this.matchedCommand = matchedCommand;
            if (matchedCommandName) this.matchedCommandName = matchedCommandName;
            return this;
        }
        unsetMatchedCommand() {
            this.matchedCommand = void 0;
            this.matchedCommandName = void 0;
        }
        parse(argv = processArgs, { run = true } = {}) {
            this.rawArgs = argv;
            if (!this.name) this.name = argv[1] ? getFileName(argv[1]) : "cli";
            let shouldParse = true;
            for (const command of this.commands){
                const parsed = this.mri(argv.slice(2), command);
                const commandName = parsed.args[0];
                if (command.isMatched(commandName)) {
                    shouldParse = false;
                    const parsedInfo = __assign(__assign({}, parsed), {
                        args: parsed.args.slice(1)
                    });
                    this.setParsedInfo(parsedInfo, command, commandName);
                    this.emit(`command:${commandName}`, command);
                }
            }
            if (shouldParse) {
                for (const command of this.commands)if ("" === command.name) {
                    shouldParse = false;
                    const parsed = this.mri(argv.slice(2), command);
                    this.setParsedInfo(parsed, command);
                    this.emit("command:!", command);
                }
            }
            if (shouldParse) {
                const parsed = this.mri(argv.slice(2));
                this.setParsedInfo(parsed);
            }
            if (this.options.help && this.showHelpOnExit) {
                this.outputHelp();
                run = false;
                this.unsetMatchedCommand();
            }
            if (this.options.version && this.showVersionOnExit && null == this.matchedCommandName) {
                this.outputVersion();
                run = false;
                this.unsetMatchedCommand();
            }
            const parsedArgv = {
                args: this.args,
                options: this.options
            };
            if (run) this.runMatchedCommand();
            if (!this.matchedCommand && this.args[0]) this.emit("command:*");
            return parsedArgv;
        }
        mri(argv, command) {
            const cliOptions = [
                ...this.globalCommand.options,
                ...command ? command.options : []
            ];
            const mriOptions = getMriOptions(cliOptions);
            let argsAfterDoubleDashes = [];
            const doubleDashesIndex = argv.indexOf("--");
            if (doubleDashesIndex > -1) {
                argsAfterDoubleDashes = argv.slice(doubleDashesIndex + 1);
                argv = argv.slice(0, doubleDashesIndex);
            }
            let parsed = mri2(argv, mriOptions);
            parsed = Object.keys(parsed).reduce((res, name)=>__assign(__assign({}, res), {
                    [camelcaseOptionName(name)]: parsed[name]
                }), {
                _: []
            });
            const args = parsed._;
            const options = {
                "--": argsAfterDoubleDashes
            };
            const ignoreDefault = command && command.config.ignoreOptionDefaultValue ? command.config.ignoreOptionDefaultValue : this.globalCommand.config.ignoreOptionDefaultValue;
            let transforms = Object.create(null);
            for (const cliOption of cliOptions){
                if (!ignoreDefault && void 0 !== cliOption.config.default) for (const name of cliOption.names)options[name] = cliOption.config.default;
                if (Array.isArray(cliOption.config.type)) {
                    if (void 0 === transforms[cliOption.name]) {
                        transforms[cliOption.name] = Object.create(null);
                        transforms[cliOption.name]["shouldTransform"] = true;
                        transforms[cliOption.name]["transformFunction"] = cliOption.config.type[0];
                    }
                }
            }
            for (const key of Object.keys(parsed))if ("_" !== key) {
                const keys = key.split(".");
                setDotProp(options, keys, parsed[key]);
                setByType(options, transforms);
            }
            return {
                args,
                options
            };
        }
        runMatchedCommand() {
            const { args, options, matchedCommand: command } = this;
            if (!command || !command.commandAction) return;
            command.checkUnknownOptions();
            command.checkOptionValue();
            command.checkRequiredArgs();
            const actionArgs = [];
            command.args.forEach((arg, index)=>{
                if (arg.variadic) actionArgs.push(args.slice(index));
                else actionArgs.push(args[index]);
            });
            actionArgs.push(options);
            return command.commandAction.apply(this, actionArgs);
        }
    }
    const cac = (name = "")=>new CAC(name);
    const dist = cac;
    const ANSI_BACKGROUND_OFFSET = 10;
    const wrapAnsi16 = (offset = 0)=>(code)=>`\u001B[${code + offset}m`;
    const wrapAnsi256 = (offset = 0)=>(code)=>`\u001B[${38 + offset};5;${code}m`;
    const wrapAnsi16m = (offset = 0)=>(red, green, blue)=>`\u001B[${38 + offset};2;${red};${green};${blue}m`;
    const styles = {
        modifier: {
            reset: [
                0,
                0
            ],
            bold: [
                1,
                22
            ],
            dim: [
                2,
                22
            ],
            italic: [
                3,
                23
            ],
            underline: [
                4,
                24
            ],
            overline: [
                53,
                55
            ],
            inverse: [
                7,
                27
            ],
            hidden: [
                8,
                28
            ],
            strikethrough: [
                9,
                29
            ]
        },
        color: {
            black: [
                30,
                39
            ],
            red: [
                31,
                39
            ],
            green: [
                32,
                39
            ],
            yellow: [
                33,
                39
            ],
            blue: [
                34,
                39
            ],
            magenta: [
                35,
                39
            ],
            cyan: [
                36,
                39
            ],
            white: [
                37,
                39
            ],
            blackBright: [
                90,
                39
            ],
            gray: [
                90,
                39
            ],
            grey: [
                90,
                39
            ],
            redBright: [
                91,
                39
            ],
            greenBright: [
                92,
                39
            ],
            yellowBright: [
                93,
                39
            ],
            blueBright: [
                94,
                39
            ],
            magentaBright: [
                95,
                39
            ],
            cyanBright: [
                96,
                39
            ],
            whiteBright: [
                97,
                39
            ]
        },
        bgColor: {
            bgBlack: [
                40,
                49
            ],
            bgRed: [
                41,
                49
            ],
            bgGreen: [
                42,
                49
            ],
            bgYellow: [
                43,
                49
            ],
            bgBlue: [
                44,
                49
            ],
            bgMagenta: [
                45,
                49
            ],
            bgCyan: [
                46,
                49
            ],
            bgWhite: [
                47,
                49
            ],
            bgBlackBright: [
                100,
                49
            ],
            bgGray: [
                100,
                49
            ],
            bgGrey: [
                100,
                49
            ],
            bgRedBright: [
                101,
                49
            ],
            bgGreenBright: [
                102,
                49
            ],
            bgYellowBright: [
                103,
                49
            ],
            bgBlueBright: [
                104,
                49
            ],
            bgMagentaBright: [
                105,
                49
            ],
            bgCyanBright: [
                106,
                49
            ],
            bgWhiteBright: [
                107,
                49
            ]
        }
    };
    Object.keys(styles.modifier);
    const foregroundColorNames = Object.keys(styles.color);
    const backgroundColorNames = Object.keys(styles.bgColor);
    [
        ...foregroundColorNames,
        ...backgroundColorNames
    ];
    function assembleStyles() {
        const codes = new Map();
        for (const [groupName, group] of Object.entries(styles)){
            for (const [styleName, style] of Object.entries(group)){
                styles[styleName] = {
                    open: `\u001B[${style[0]}m`,
                    close: `\u001B[${style[1]}m`
                };
                group[styleName] = styles[styleName];
                codes.set(style[0], style[1]);
            }
            Object.defineProperty(styles, groupName, {
                value: group,
                enumerable: false
            });
        }
        Object.defineProperty(styles, 'codes', {
            value: codes,
            enumerable: false
        });
        styles.color.close = '\u001B[39m';
        styles.bgColor.close = '\u001B[49m';
        styles.color.ansi = wrapAnsi16();
        styles.color.ansi256 = wrapAnsi256();
        styles.color.ansi16m = wrapAnsi16m();
        styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
        styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
        styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
        Object.defineProperties(styles, {
            rgbToAnsi256: {
                value (red, green, blue) {
                    if (red === green && green === blue) {
                        if (red < 8) return 16;
                        if (red > 248) return 231;
                        return Math.round((red - 8) / 247 * 24) + 232;
                    }
                    return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
                },
                enumerable: false
            },
            hexToRgb: {
                value (hex) {
                    const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
                    if (!matches) return [
                        0,
                        0,
                        0
                    ];
                    let [colorString] = matches;
                    if (3 === colorString.length) colorString = [
                        ...colorString
                    ].map((character)=>character + character).join('');
                    const integer = Number.parseInt(colorString, 16);
                    return [
                        integer >> 16 & 0xFF,
                        integer >> 8 & 0xFF,
                        0xFF & integer
                    ];
                },
                enumerable: false
            },
            hexToAnsi256: {
                value: (hex)=>styles.rgbToAnsi256(...styles.hexToRgb(hex)),
                enumerable: false
            },
            ansi256ToAnsi: {
                value (code) {
                    if (code < 8) return 30 + code;
                    if (code < 16) return 90 + (code - 8);
                    let red;
                    let green;
                    let blue;
                    if (code >= 232) {
                        red = ((code - 232) * 10 + 8) / 255;
                        green = red;
                        blue = red;
                    } else {
                        code -= 16;
                        const remainder = code % 36;
                        red = Math.floor(code / 36) / 5;
                        green = Math.floor(remainder / 6) / 5;
                        blue = remainder % 6 / 5;
                    }
                    const value = 2 * Math.max(red, green, blue);
                    if (0 === value) return 30;
                    let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
                    if (2 === value) result += 60;
                    return result;
                },
                enumerable: false
            },
            rgbToAnsi: {
                value: (red, green, blue)=>styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
                enumerable: false
            },
            hexToAnsi: {
                value: (hex)=>styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
                enumerable: false
            }
        });
        return styles;
    }
    const ansiStyles = assembleStyles();
    const ansi_styles = ansiStyles;
    var external_node_process_ = __webpack_require__("node:process");
    var external_node_os_ = __webpack_require__("node:os");
    var external_node_tty_ = __webpack_require__("node:tty");
    function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : external_node_process_.argv) {
        const prefix = flag.startsWith('-') ? '' : 1 === flag.length ? '-' : '--';
        const position = argv.indexOf(prefix + flag);
        const terminatorPosition = argv.indexOf('--');
        return -1 !== position && (-1 === terminatorPosition || position < terminatorPosition);
    }
    const { env: supports_color_env } = external_node_process_;
    let flagForceColor;
    if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) flagForceColor = 0;
    else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) flagForceColor = 1;
    function envForceColor() {
        if ('FORCE_COLOR' in supports_color_env) {
            if ('true' === supports_color_env.FORCE_COLOR) return 1;
            if ('false' === supports_color_env.FORCE_COLOR) return 0;
            return 0 === supports_color_env.FORCE_COLOR.length ? 1 : Math.min(Number.parseInt(supports_color_env.FORCE_COLOR, 10), 3);
        }
    }
    function translateLevel(level) {
        if (0 === level) return false;
        return {
            level,
            hasBasic: true,
            has256: level >= 2,
            has16m: level >= 3
        };
    }
    function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
        const noFlagForceColor = envForceColor();
        if (void 0 !== noFlagForceColor) flagForceColor = noFlagForceColor;
        const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
        if (0 === forceColor) return 0;
        if (sniffFlags) {
            if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) return 3;
            if (hasFlag('color=256')) return 2;
        }
        if ('TF_BUILD' in supports_color_env && 'AGENT_NAME' in supports_color_env) return 1;
        if (haveStream && !streamIsTTY && void 0 === forceColor) return 0;
        const min = forceColor || 0;
        if ('dumb' === supports_color_env.TERM) return min;
        if ('win32' === external_node_process_.platform) {
            const osRelease = external_node_os_.release().split('.');
            if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) return Number(osRelease[2]) >= 14931 ? 3 : 2;
            return 1;
        }
        if ('CI' in supports_color_env) {
            if ([
                'GITHUB_ACTIONS',
                'GITEA_ACTIONS',
                'CIRCLECI'
            ].some((key)=>key in supports_color_env)) return 3;
            if ([
                'TRAVIS',
                'APPVEYOR',
                'GITLAB_CI',
                'BUILDKITE',
                'DRONE'
            ].some((sign)=>sign in supports_color_env) || 'codeship' === supports_color_env.CI_NAME) return 1;
            return min;
        }
        if ('TEAMCITY_VERSION' in supports_color_env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(supports_color_env.TEAMCITY_VERSION) ? 1 : 0;
        if ('truecolor' === supports_color_env.COLORTERM) return 3;
        if ('xterm-kitty' === supports_color_env.TERM) return 3;
        if ('TERM_PROGRAM' in supports_color_env) {
            const version = Number.parseInt((supports_color_env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
            switch(supports_color_env.TERM_PROGRAM){
                case 'iTerm.app':
                    return version >= 3 ? 3 : 2;
                case 'Apple_Terminal':
                    return 2;
            }
        }
        if (/-256(color)?$/i.test(supports_color_env.TERM)) return 2;
        if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(supports_color_env.TERM)) return 1;
        if ('COLORTERM' in supports_color_env) return 1;
        return min;
    }
    function createSupportsColor(stream, options = {}) {
        const level = _supportsColor(stream, {
            streamIsTTY: stream && stream.isTTY,
            ...options
        });
        return translateLevel(level);
    }
    const supportsColor = {
        stdout: createSupportsColor({
            isTTY: external_node_tty_.isatty(1)
        }),
        stderr: createSupportsColor({
            isTTY: external_node_tty_.isatty(2)
        })
    };
    const supports_color = supportsColor;
    function stringReplaceAll(string, substring, replacer) {
        let index = string.indexOf(substring);
        if (-1 === index) return string;
        const substringLength = substring.length;
        let endIndex = 0;
        let returnValue = '';
        do {
            returnValue += string.slice(endIndex, index) + substring + replacer;
            endIndex = index + substringLength;
            index = string.indexOf(substring, endIndex);
        }while (-1 !== index);
        returnValue += string.slice(endIndex);
        return returnValue;
    }
    function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
        let endIndex = 0;
        let returnValue = '';
        do {
            const gotCR = '\r' === string[index - 1];
            returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
            endIndex = index + 1;
            index = string.indexOf('\n', endIndex);
        }while (-1 !== index);
        returnValue += string.slice(endIndex);
        return returnValue;
    }
    const { stdout: stdoutColor, stderr: stderrColor } = supports_color;
    const GENERATOR = Symbol('GENERATOR');
    const STYLER = Symbol('STYLER');
    const IS_EMPTY = Symbol('IS_EMPTY');
    const levelMapping = [
        'ansi',
        'ansi',
        'ansi256',
        'ansi16m'
    ];
    const source_styles = Object.create(null);
    const applyOptions = (object, options = {})=>{
        if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) throw new Error('The `level` option should be an integer from 0 to 3');
        const colorLevel = stdoutColor ? stdoutColor.level : 0;
        object.level = void 0 === options.level ? colorLevel : options.level;
    };
    const chalkFactory = (options)=>{
        const chalk = (...strings)=>strings.join(' ');
        applyOptions(chalk, options);
        Object.setPrototypeOf(chalk, createChalk.prototype);
        return chalk;
    };
    function createChalk(options) {
        return chalkFactory(options);
    }
    Object.setPrototypeOf(createChalk.prototype, Function.prototype);
    for (const [styleName, style] of Object.entries(ansi_styles))source_styles[styleName] = {
        get () {
            const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
            Object.defineProperty(this, styleName, {
                value: builder
            });
            return builder;
        }
    };
    source_styles.visible = {
        get () {
            const builder = createBuilder(this, this[STYLER], true);
            Object.defineProperty(this, 'visible', {
                value: builder
            });
            return builder;
        }
    };
    const getModelAnsi = (model, level, type, ...arguments_)=>{
        if ('rgb' === model) {
            if ('ansi16m' === level) return ansi_styles[type].ansi16m(...arguments_);
            if ('ansi256' === level) return ansi_styles[type].ansi256(ansi_styles.rgbToAnsi256(...arguments_));
            return ansi_styles[type].ansi(ansi_styles.rgbToAnsi(...arguments_));
        }
        if ('hex' === model) return getModelAnsi('rgb', level, type, ...ansi_styles.hexToRgb(...arguments_));
        return ansi_styles[type][model](...arguments_);
    };
    const usedModels = [
        'rgb',
        'hex',
        'ansi256'
    ];
    for (const model of usedModels){
        source_styles[model] = {
            get () {
                const { level } = this;
                return function(...arguments_) {
                    const styler = createStyler(getModelAnsi(model, levelMapping[level], 'color', ...arguments_), ansi_styles.color.close, this[STYLER]);
                    return createBuilder(this, styler, this[IS_EMPTY]);
                };
            }
        };
        const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
        source_styles[bgModel] = {
            get () {
                const { level } = this;
                return function(...arguments_) {
                    const styler = createStyler(getModelAnsi(model, levelMapping[level], 'bgColor', ...arguments_), ansi_styles.bgColor.close, this[STYLER]);
                    return createBuilder(this, styler, this[IS_EMPTY]);
                };
            }
        };
    }
    const source_proto = Object.defineProperties(()=>{}, {
        ...source_styles,
        level: {
            enumerable: true,
            get () {
                return this[GENERATOR].level;
            },
            set (level) {
                this[GENERATOR].level = level;
            }
        }
    });
    const createStyler = (open, close, parent)=>{
        let openAll;
        let closeAll;
        if (void 0 === parent) {
            openAll = open;
            closeAll = close;
        } else {
            openAll = parent.openAll + open;
            closeAll = close + parent.closeAll;
        }
        return {
            open,
            close,
            openAll,
            closeAll,
            parent
        };
    };
    const createBuilder = (self, _styler, _isEmpty)=>{
        const builder = (...arguments_)=>applyStyle(builder, 1 === arguments_.length ? '' + arguments_[0] : arguments_.join(' '));
        Object.setPrototypeOf(builder, source_proto);
        builder[GENERATOR] = self;
        builder[STYLER] = _styler;
        builder[IS_EMPTY] = _isEmpty;
        return builder;
    };
    const applyStyle = (self, string)=>{
        if (self.level <= 0 || !string) return self[IS_EMPTY] ? '' : string;
        let styler = self[STYLER];
        if (void 0 === styler) return string;
        const { openAll, closeAll } = styler;
        if (string.includes('\u001B')) while(void 0 !== styler){
            string = stringReplaceAll(string, styler.close, styler.open);
            styler = styler.parent;
        }
        const lfIndex = string.indexOf('\n');
        if (-1 !== lfIndex) string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
        return openAll + string + closeAll;
    };
    Object.defineProperties(createChalk.prototype, source_styles);
    const source_chalk = createChalk();
    createChalk({
        level: stderrColor ? stderrColor.level : 0
    });
    const chalk_source = source_chalk;
    function ansiRegex({ onlyFirst = false } = {}) {
        const ST = '(?:\\u0007|\\u001B\\u005C|\\u009C)';
        const pattern = [
            `[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?${ST})`,
            '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))'
        ].join('|');
        return new RegExp(pattern, onlyFirst ? void 0 : 'g');
    }
    const strip_ansi_regex = ansiRegex();
    function stripAnsi(string) {
        if ('string' != typeof string) throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
        return string.replace(strip_ansi_regex, '');
    }
    function isAmbiguous(x) {
        return 0xA1 === x || 0xA4 === x || 0xA7 === x || 0xA8 === x || 0xAA === x || 0xAD === x || 0xAE === x || x >= 0xB0 && x <= 0xB4 || x >= 0xB6 && x <= 0xBA || x >= 0xBC && x <= 0xBF || 0xC6 === x || 0xD0 === x || 0xD7 === x || 0xD8 === x || x >= 0xDE && x <= 0xE1 || 0xE6 === x || x >= 0xE8 && x <= 0xEA || 0xEC === x || 0xED === x || 0xF0 === x || 0xF2 === x || 0xF3 === x || x >= 0xF7 && x <= 0xFA || 0xFC === x || 0xFE === x || 0x101 === x || 0x111 === x || 0x113 === x || 0x11B === x || 0x126 === x || 0x127 === x || 0x12B === x || x >= 0x131 && x <= 0x133 || 0x138 === x || x >= 0x13F && x <= 0x142 || 0x144 === x || x >= 0x148 && x <= 0x14B || 0x14D === x || 0x152 === x || 0x153 === x || 0x166 === x || 0x167 === x || 0x16B === x || 0x1CE === x || 0x1D0 === x || 0x1D2 === x || 0x1D4 === x || 0x1D6 === x || 0x1D8 === x || 0x1DA === x || 0x1DC === x || 0x251 === x || 0x261 === x || 0x2C4 === x || 0x2C7 === x || x >= 0x2C9 && x <= 0x2CB || 0x2CD === x || 0x2D0 === x || x >= 0x2D8 && x <= 0x2DB || 0x2DD === x || 0x2DF === x || x >= 0x300 && x <= 0x36F || x >= 0x391 && x <= 0x3A1 || x >= 0x3A3 && x <= 0x3A9 || x >= 0x3B1 && x <= 0x3C1 || x >= 0x3C3 && x <= 0x3C9 || 0x401 === x || x >= 0x410 && x <= 0x44F || 0x451 === x || 0x2010 === x || x >= 0x2013 && x <= 0x2016 || 0x2018 === x || 0x2019 === x || 0x201C === x || 0x201D === x || x >= 0x2020 && x <= 0x2022 || x >= 0x2024 && x <= 0x2027 || 0x2030 === x || 0x2032 === x || 0x2033 === x || 0x2035 === x || 0x203B === x || 0x203E === x || 0x2074 === x || 0x207F === x || x >= 0x2081 && x <= 0x2084 || 0x20AC === x || 0x2103 === x || 0x2105 === x || 0x2109 === x || 0x2113 === x || 0x2116 === x || 0x2121 === x || 0x2122 === x || 0x2126 === x || 0x212B === x || 0x2153 === x || 0x2154 === x || x >= 0x215B && x <= 0x215E || x >= 0x2160 && x <= 0x216B || x >= 0x2170 && x <= 0x2179 || 0x2189 === x || x >= 0x2190 && x <= 0x2199 || 0x21B8 === x || 0x21B9 === x || 0x21D2 === x || 0x21D4 === x || 0x21E7 === x || 0x2200 === x || 0x2202 === x || 0x2203 === x || 0x2207 === x || 0x2208 === x || 0x220B === x || 0x220F === x || 0x2211 === x || 0x2215 === x || 0x221A === x || x >= 0x221D && x <= 0x2220 || 0x2223 === x || 0x2225 === x || x >= 0x2227 && x <= 0x222C || 0x222E === x || x >= 0x2234 && x <= 0x2237 || 0x223C === x || 0x223D === x || 0x2248 === x || 0x224C === x || 0x2252 === x || 0x2260 === x || 0x2261 === x || x >= 0x2264 && x <= 0x2267 || 0x226A === x || 0x226B === x || 0x226E === x || 0x226F === x || 0x2282 === x || 0x2283 === x || 0x2286 === x || 0x2287 === x || 0x2295 === x || 0x2299 === x || 0x22A5 === x || 0x22BF === x || 0x2312 === x || x >= 0x2460 && x <= 0x24E9 || x >= 0x24EB && x <= 0x254B || x >= 0x2550 && x <= 0x2573 || x >= 0x2580 && x <= 0x258F || x >= 0x2592 && x <= 0x2595 || 0x25A0 === x || 0x25A1 === x || x >= 0x25A3 && x <= 0x25A9 || 0x25B2 === x || 0x25B3 === x || 0x25B6 === x || 0x25B7 === x || 0x25BC === x || 0x25BD === x || 0x25C0 === x || 0x25C1 === x || x >= 0x25C6 && x <= 0x25C8 || 0x25CB === x || x >= 0x25CE && x <= 0x25D1 || x >= 0x25E2 && x <= 0x25E5 || 0x25EF === x || 0x2605 === x || 0x2606 === x || 0x2609 === x || 0x260E === x || 0x260F === x || 0x261C === x || 0x261E === x || 0x2640 === x || 0x2642 === x || 0x2660 === x || 0x2661 === x || x >= 0x2663 && x <= 0x2665 || x >= 0x2667 && x <= 0x266A || 0x266C === x || 0x266D === x || 0x266F === x || 0x269E === x || 0x269F === x || 0x26BF === x || x >= 0x26C6 && x <= 0x26CD || x >= 0x26CF && x <= 0x26D3 || x >= 0x26D5 && x <= 0x26E1 || 0x26E3 === x || 0x26E8 === x || 0x26E9 === x || x >= 0x26EB && x <= 0x26F1 || 0x26F4 === x || x >= 0x26F6 && x <= 0x26F9 || 0x26FB === x || 0x26FC === x || 0x26FE === x || 0x26FF === x || 0x273D === x || x >= 0x2776 && x <= 0x277F || x >= 0x2B56 && x <= 0x2B59 || x >= 0x3248 && x <= 0x324F || x >= 0xE000 && x <= 0xF8FF || x >= 0xFE00 && x <= 0xFE0F || 0xFFFD === x || x >= 0x1F100 && x <= 0x1F10A || x >= 0x1F110 && x <= 0x1F12D || x >= 0x1F130 && x <= 0x1F169 || x >= 0x1F170 && x <= 0x1F18D || 0x1F18F === x || 0x1F190 === x || x >= 0x1F19B && x <= 0x1F1AC || x >= 0xE0100 && x <= 0xE01EF || x >= 0xF0000 && x <= 0xFFFFD || x >= 0x100000 && x <= 0x10FFFD;
    }
    function lookup_isFullWidth(x) {
        return 0x3000 === x || x >= 0xFF01 && x <= 0xFF60 || x >= 0xFFE0 && x <= 0xFFE6;
    }
    function lookup_isWide(x) {
        return x >= 0x1100 && x <= 0x115F || 0x231A === x || 0x231B === x || 0x2329 === x || 0x232A === x || x >= 0x23E9 && x <= 0x23EC || 0x23F0 === x || 0x23F3 === x || 0x25FD === x || 0x25FE === x || 0x2614 === x || 0x2615 === x || x >= 0x2630 && x <= 0x2637 || x >= 0x2648 && x <= 0x2653 || 0x267F === x || x >= 0x268A && x <= 0x268F || 0x2693 === x || 0x26A1 === x || 0x26AA === x || 0x26AB === x || 0x26BD === x || 0x26BE === x || 0x26C4 === x || 0x26C5 === x || 0x26CE === x || 0x26D4 === x || 0x26EA === x || 0x26F2 === x || 0x26F3 === x || 0x26F5 === x || 0x26FA === x || 0x26FD === x || 0x2705 === x || 0x270A === x || 0x270B === x || 0x2728 === x || 0x274C === x || 0x274E === x || x >= 0x2753 && x <= 0x2755 || 0x2757 === x || x >= 0x2795 && x <= 0x2797 || 0x27B0 === x || 0x27BF === x || 0x2B1B === x || 0x2B1C === x || 0x2B50 === x || 0x2B55 === x || x >= 0x2E80 && x <= 0x2E99 || x >= 0x2E9B && x <= 0x2EF3 || x >= 0x2F00 && x <= 0x2FD5 || x >= 0x2FF0 && x <= 0x2FFF || x >= 0x3001 && x <= 0x303E || x >= 0x3041 && x <= 0x3096 || x >= 0x3099 && x <= 0x30FF || x >= 0x3105 && x <= 0x312F || x >= 0x3131 && x <= 0x318E || x >= 0x3190 && x <= 0x31E5 || x >= 0x31EF && x <= 0x321E || x >= 0x3220 && x <= 0x3247 || x >= 0x3250 && x <= 0xA48C || x >= 0xA490 && x <= 0xA4C6 || x >= 0xA960 && x <= 0xA97C || x >= 0xAC00 && x <= 0xD7A3 || x >= 0xF900 && x <= 0xFAFF || x >= 0xFE10 && x <= 0xFE19 || x >= 0xFE30 && x <= 0xFE52 || x >= 0xFE54 && x <= 0xFE66 || x >= 0xFE68 && x <= 0xFE6B || x >= 0x16FE0 && x <= 0x16FE4 || 0x16FF0 === x || 0x16FF1 === x || x >= 0x17000 && x <= 0x187F7 || x >= 0x18800 && x <= 0x18CD5 || x >= 0x18CFF && x <= 0x18D08 || x >= 0x1AFF0 && x <= 0x1AFF3 || x >= 0x1AFF5 && x <= 0x1AFFB || 0x1AFFD === x || 0x1AFFE === x || x >= 0x1B000 && x <= 0x1B122 || 0x1B132 === x || x >= 0x1B150 && x <= 0x1B152 || 0x1B155 === x || x >= 0x1B164 && x <= 0x1B167 || x >= 0x1B170 && x <= 0x1B2FB || x >= 0x1D300 && x <= 0x1D356 || x >= 0x1D360 && x <= 0x1D376 || 0x1F004 === x || 0x1F0CF === x || 0x1F18E === x || x >= 0x1F191 && x <= 0x1F19A || x >= 0x1F200 && x <= 0x1F202 || x >= 0x1F210 && x <= 0x1F23B || x >= 0x1F240 && x <= 0x1F248 || 0x1F250 === x || 0x1F251 === x || x >= 0x1F260 && x <= 0x1F265 || x >= 0x1F300 && x <= 0x1F320 || x >= 0x1F32D && x <= 0x1F335 || x >= 0x1F337 && x <= 0x1F37C || x >= 0x1F37E && x <= 0x1F393 || x >= 0x1F3A0 && x <= 0x1F3CA || x >= 0x1F3CF && x <= 0x1F3D3 || x >= 0x1F3E0 && x <= 0x1F3F0 || 0x1F3F4 === x || x >= 0x1F3F8 && x <= 0x1F43E || 0x1F440 === x || x >= 0x1F442 && x <= 0x1F4FC || x >= 0x1F4FF && x <= 0x1F53D || x >= 0x1F54B && x <= 0x1F54E || x >= 0x1F550 && x <= 0x1F567 || 0x1F57A === x || 0x1F595 === x || 0x1F596 === x || 0x1F5A4 === x || x >= 0x1F5FB && x <= 0x1F64F || x >= 0x1F680 && x <= 0x1F6C5 || 0x1F6CC === x || x >= 0x1F6D0 && x <= 0x1F6D2 || x >= 0x1F6D5 && x <= 0x1F6D7 || x >= 0x1F6DC && x <= 0x1F6DF || 0x1F6EB === x || 0x1F6EC === x || x >= 0x1F6F4 && x <= 0x1F6FC || x >= 0x1F7E0 && x <= 0x1F7EB || 0x1F7F0 === x || x >= 0x1F90C && x <= 0x1F93A || x >= 0x1F93C && x <= 0x1F945 || x >= 0x1F947 && x <= 0x1F9FF || x >= 0x1FA70 && x <= 0x1FA7C || x >= 0x1FA80 && x <= 0x1FA89 || x >= 0x1FA8F && x <= 0x1FAC6 || x >= 0x1FACE && x <= 0x1FADC || x >= 0x1FADF && x <= 0x1FAE9 || x >= 0x1FAF0 && x <= 0x1FAF8 || x >= 0x20000 && x <= 0x2FFFD || x >= 0x30000 && x <= 0x3FFFD;
    }
    function validate(codePoint) {
        if (!Number.isSafeInteger(codePoint)) throw new TypeError(`Expected a code point, got \`${typeof codePoint}\`.`);
    }
    function eastAsianWidth(codePoint, { ambiguousAsWide = false } = {}) {
        validate(codePoint);
        if (lookup_isFullWidth(codePoint) || lookup_isWide(codePoint) || ambiguousAsWide && isAmbiguous(codePoint)) return 2;
        return 1;
    }
    const emoji_regex = ()=>/[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
    const segmenter = new Intl.Segmenter();
    const defaultIgnorableCodePointRegex = /^\p{Default_Ignorable_Code_Point}$/u;
    function stringWidth(string, options = {}) {
        if ('string' != typeof string || 0 === string.length) return 0;
        const { ambiguousIsNarrow = true, countAnsiEscapeCodes = false } = options;
        if (!countAnsiEscapeCodes) string = stripAnsi(string);
        if (0 === string.length) return 0;
        let width = 0;
        const eastAsianWidthOptions = {
            ambiguousAsWide: !ambiguousIsNarrow
        };
        for (const { segment: character } of segmenter.segment(string)){
            const codePoint = character.codePointAt(0);
            if (codePoint <= 0x1F || codePoint >= 0x7F && codePoint <= 0x9F) continue;
            if (codePoint >= 0x200B && codePoint <= 0x200F || 0xFEFF === codePoint) continue;
            if (codePoint >= 0x300 && codePoint <= 0x36F || codePoint >= 0x1AB0 && codePoint <= 0x1AFF || codePoint >= 0x1DC0 && codePoint <= 0x1DFF || codePoint >= 0x20D0 && codePoint <= 0x20FF || codePoint >= 0xFE20 && codePoint <= 0xFE2F) continue;
            if (!(codePoint >= 0xD800) || !(codePoint <= 0xDFFF)) {
                if (!(codePoint >= 0xFE00) || !(codePoint <= 0xFE0F)) {
                    if (!defaultIgnorableCodePointRegex.test(character)) {
                        if (emoji_regex().test(character)) {
                            width += 2;
                            continue;
                        }
                        width += eastAsianWidth(codePoint, eastAsianWidthOptions);
                    }
                }
            }
        }
        return width;
    }
    function widestLine(string) {
        let lineWidth = 0;
        for (const line of string.split('\n'))lineWidth = Math.max(lineWidth, stringWidth(line));
        return lineWidth;
    }
    var cli_boxes = __webpack_require__("../node_modules/.pnpm/cli-boxes@3.0.0/node_modules/cli-boxes/index.js");
    const UPPERCASE = /[\p{Lu}]/u;
    const LOWERCASE = /[\p{Ll}]/u;
    const LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
    const IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
    const SEPARATORS = /[_.\- ]+/;
    const LEADING_SEPARATORS = new RegExp('^' + SEPARATORS.source);
    const SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, 'gu');
    const NUMBERS_AND_IDENTIFIER = new RegExp('\\d+' + IDENTIFIER.source, 'gu');
    const preserveCamelCase = (string, toLowerCase, toUpperCase, preserveConsecutiveUppercase)=>{
        let isLastCharLower = false;
        let isLastCharUpper = false;
        let isLastLastCharUpper = false;
        let isLastLastCharPreserved = false;
        for(let index = 0; index < string.length; index++){
            const character = string[index];
            isLastLastCharPreserved = index > 2 ? '-' === string[index - 3] : true;
            if (isLastCharLower && UPPERCASE.test(character)) {
                string = string.slice(0, index) + '-' + string.slice(index);
                isLastCharLower = false;
                isLastLastCharUpper = isLastCharUpper;
                isLastCharUpper = true;
                index++;
            } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character) && (!isLastLastCharPreserved || preserveConsecutiveUppercase)) {
                string = string.slice(0, index - 1) + '-' + string.slice(index - 1);
                isLastLastCharUpper = isLastCharUpper;
                isLastCharUpper = false;
                isLastCharLower = true;
            } else {
                isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
                isLastLastCharUpper = isLastCharUpper;
                isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
            }
        }
        return string;
    };
    const camelcase_preserveConsecutiveUppercase = (input, toLowerCase)=>{
        LEADING_CAPITAL.lastIndex = 0;
        return input.replaceAll(LEADING_CAPITAL, (match)=>toLowerCase(match));
    };
    const postProcess = (input, toUpperCase)=>{
        SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
        NUMBERS_AND_IDENTIFIER.lastIndex = 0;
        return input.replaceAll(NUMBERS_AND_IDENTIFIER, (match, pattern, offset)=>[
                '_',
                '-'
            ].includes(input.charAt(offset + match.length)) ? match : toUpperCase(match)).replaceAll(SEPARATORS_AND_IDENTIFIER, (_, identifier)=>toUpperCase(identifier));
    };
    function camelCase(input, options) {
        if (!('string' == typeof input || Array.isArray(input))) throw new TypeError('Expected the input to be `string | string[]`');
        options = {
            pascalCase: false,
            preserveConsecutiveUppercase: false,
            ...options
        };
        input = Array.isArray(input) ? input.map((x)=>x.trim()).filter((x)=>x.length).join('-') : input.trim();
        if (0 === input.length) return '';
        const toLowerCase = false === options.locale ? (string)=>string.toLowerCase() : (string)=>string.toLocaleLowerCase(options.locale);
        const toUpperCase = false === options.locale ? (string)=>string.toUpperCase() : (string)=>string.toLocaleUpperCase(options.locale);
        if (1 === input.length) {
            if (SEPARATORS.test(input)) return '';
            return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
        }
        const hasUpperCase = input !== toLowerCase(input);
        if (hasUpperCase) input = preserveCamelCase(input, toLowerCase, toUpperCase, options.preserveConsecutiveUppercase);
        input = input.replace(LEADING_SEPARATORS, '');
        input = options.preserveConsecutiveUppercase ? camelcase_preserveConsecutiveUppercase(input, toLowerCase) : toLowerCase(input);
        if (options.pascalCase) input = toUpperCase(input.charAt(0)) + input.slice(1);
        return postProcess(input, toUpperCase);
    }
    var ansi_align = __webpack_require__("../node_modules/.pnpm/ansi-align@3.0.1/node_modules/ansi-align/index.js");
    const ansi_styles_ANSI_BACKGROUND_OFFSET = 10;
    const ansi_styles_wrapAnsi16 = (offset = 0)=>(code)=>`\u001B[${code + offset}m`;
    const ansi_styles_wrapAnsi256 = (offset = 0)=>(code)=>`\u001B[${38 + offset};5;${code}m`;
    const ansi_styles_wrapAnsi16m = (offset = 0)=>(red, green, blue)=>`\u001B[${38 + offset};2;${red};${green};${blue}m`;
    const ansi_styles_styles = {
        modifier: {
            reset: [
                0,
                0
            ],
            bold: [
                1,
                22
            ],
            dim: [
                2,
                22
            ],
            italic: [
                3,
                23
            ],
            underline: [
                4,
                24
            ],
            overline: [
                53,
                55
            ],
            inverse: [
                7,
                27
            ],
            hidden: [
                8,
                28
            ],
            strikethrough: [
                9,
                29
            ]
        },
        color: {
            black: [
                30,
                39
            ],
            red: [
                31,
                39
            ],
            green: [
                32,
                39
            ],
            yellow: [
                33,
                39
            ],
            blue: [
                34,
                39
            ],
            magenta: [
                35,
                39
            ],
            cyan: [
                36,
                39
            ],
            white: [
                37,
                39
            ],
            blackBright: [
                90,
                39
            ],
            gray: [
                90,
                39
            ],
            grey: [
                90,
                39
            ],
            redBright: [
                91,
                39
            ],
            greenBright: [
                92,
                39
            ],
            yellowBright: [
                93,
                39
            ],
            blueBright: [
                94,
                39
            ],
            magentaBright: [
                95,
                39
            ],
            cyanBright: [
                96,
                39
            ],
            whiteBright: [
                97,
                39
            ]
        },
        bgColor: {
            bgBlack: [
                40,
                49
            ],
            bgRed: [
                41,
                49
            ],
            bgGreen: [
                42,
                49
            ],
            bgYellow: [
                43,
                49
            ],
            bgBlue: [
                44,
                49
            ],
            bgMagenta: [
                45,
                49
            ],
            bgCyan: [
                46,
                49
            ],
            bgWhite: [
                47,
                49
            ],
            bgBlackBright: [
                100,
                49
            ],
            bgGray: [
                100,
                49
            ],
            bgGrey: [
                100,
                49
            ],
            bgRedBright: [
                101,
                49
            ],
            bgGreenBright: [
                102,
                49
            ],
            bgYellowBright: [
                103,
                49
            ],
            bgBlueBright: [
                104,
                49
            ],
            bgMagentaBright: [
                105,
                49
            ],
            bgCyanBright: [
                106,
                49
            ],
            bgWhiteBright: [
                107,
                49
            ]
        }
    };
    Object.keys(ansi_styles_styles.modifier);
    const ansi_styles_foregroundColorNames = Object.keys(ansi_styles_styles.color);
    const ansi_styles_backgroundColorNames = Object.keys(ansi_styles_styles.bgColor);
    [
        ...ansi_styles_foregroundColorNames,
        ...ansi_styles_backgroundColorNames
    ];
    function ansi_styles_assembleStyles() {
        const codes = new Map();
        for (const [groupName, group] of Object.entries(ansi_styles_styles)){
            for (const [styleName, style] of Object.entries(group)){
                ansi_styles_styles[styleName] = {
                    open: `\u001B[${style[0]}m`,
                    close: `\u001B[${style[1]}m`
                };
                group[styleName] = ansi_styles_styles[styleName];
                codes.set(style[0], style[1]);
            }
            Object.defineProperty(ansi_styles_styles, groupName, {
                value: group,
                enumerable: false
            });
        }
        Object.defineProperty(ansi_styles_styles, 'codes', {
            value: codes,
            enumerable: false
        });
        ansi_styles_styles.color.close = '\u001B[39m';
        ansi_styles_styles.bgColor.close = '\u001B[49m';
        ansi_styles_styles.color.ansi = ansi_styles_wrapAnsi16();
        ansi_styles_styles.color.ansi256 = ansi_styles_wrapAnsi256();
        ansi_styles_styles.color.ansi16m = ansi_styles_wrapAnsi16m();
        ansi_styles_styles.bgColor.ansi = ansi_styles_wrapAnsi16(ansi_styles_ANSI_BACKGROUND_OFFSET);
        ansi_styles_styles.bgColor.ansi256 = ansi_styles_wrapAnsi256(ansi_styles_ANSI_BACKGROUND_OFFSET);
        ansi_styles_styles.bgColor.ansi16m = ansi_styles_wrapAnsi16m(ansi_styles_ANSI_BACKGROUND_OFFSET);
        Object.defineProperties(ansi_styles_styles, {
            rgbToAnsi256: {
                value: (red, green, blue)=>{
                    if (red === green && green === blue) {
                        if (red < 8) return 16;
                        if (red > 248) return 231;
                        return Math.round((red - 8) / 247 * 24) + 232;
                    }
                    return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
                },
                enumerable: false
            },
            hexToRgb: {
                value: (hex)=>{
                    const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
                    if (!matches) return [
                        0,
                        0,
                        0
                    ];
                    let [colorString] = matches;
                    if (3 === colorString.length) colorString = [
                        ...colorString
                    ].map((character)=>character + character).join('');
                    const integer = Number.parseInt(colorString, 16);
                    return [
                        integer >> 16 & 0xFF,
                        integer >> 8 & 0xFF,
                        0xFF & integer
                    ];
                },
                enumerable: false
            },
            hexToAnsi256: {
                value: (hex)=>ansi_styles_styles.rgbToAnsi256(...ansi_styles_styles.hexToRgb(hex)),
                enumerable: false
            },
            ansi256ToAnsi: {
                value: (code)=>{
                    if (code < 8) return 30 + code;
                    if (code < 16) return 90 + (code - 8);
                    let red;
                    let green;
                    let blue;
                    if (code >= 232) {
                        red = ((code - 232) * 10 + 8) / 255;
                        green = red;
                        blue = red;
                    } else {
                        code -= 16;
                        const remainder = code % 36;
                        red = Math.floor(code / 36) / 5;
                        green = Math.floor(remainder / 6) / 5;
                        blue = remainder % 6 / 5;
                    }
                    const value = 2 * Math.max(red, green, blue);
                    if (0 === value) return 30;
                    let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
                    if (2 === value) result += 60;
                    return result;
                },
                enumerable: false
            },
            rgbToAnsi: {
                value: (red, green, blue)=>ansi_styles_styles.ansi256ToAnsi(ansi_styles_styles.rgbToAnsi256(red, green, blue)),
                enumerable: false
            },
            hexToAnsi: {
                value: (hex)=>ansi_styles_styles.ansi256ToAnsi(ansi_styles_styles.hexToAnsi256(hex)),
                enumerable: false
            }
        });
        return ansi_styles_styles;
    }
    const ansi_styles_ansiStyles = ansi_styles_assembleStyles();
    const node_modules_ansi_styles = ansi_styles_ansiStyles;
    const ESCAPES = new Set([
        '\u001B',
        '\u009B'
    ]);
    const END_CODE = 39;
    const ANSI_ESCAPE_BELL = '\u0007';
    const ANSI_CSI = '[';
    const ANSI_OSC = ']';
    const ANSI_SGR_TERMINATOR = 'm';
    const ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;
    const wrapAnsiCode = (code)=>`${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;
    const wrapAnsiHyperlink = (url)=>`${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${url}${ANSI_ESCAPE_BELL}`;
    const wordLengths = (string)=>string.split(' ').map((character)=>stringWidth(character));
    const wrapWord = (rows, word, columns)=>{
        const characters = [
            ...word
        ];
        let isInsideEscape = false;
        let isInsideLinkEscape = false;
        let visible = stringWidth(stripAnsi(rows.at(-1)));
        for (const [index, character] of characters.entries()){
            const characterLength = stringWidth(character);
            if (visible + characterLength <= columns) rows[rows.length - 1] += character;
            else {
                rows.push(character);
                visible = 0;
            }
            if (ESCAPES.has(character)) {
                isInsideEscape = true;
                const ansiEscapeLinkCandidate = characters.slice(index + 1, index + 1 + ANSI_ESCAPE_LINK.length).join('');
                isInsideLinkEscape = ansiEscapeLinkCandidate === ANSI_ESCAPE_LINK;
            }
            if (isInsideEscape) {
                if (isInsideLinkEscape) {
                    if (character === ANSI_ESCAPE_BELL) {
                        isInsideEscape = false;
                        isInsideLinkEscape = false;
                    }
                } else if (character === ANSI_SGR_TERMINATOR) isInsideEscape = false;
                continue;
            }
            visible += characterLength;
            if (visible === columns && index < characters.length - 1) {
                rows.push('');
                visible = 0;
            }
        }
        if (!visible && rows.at(-1).length > 0 && rows.length > 1) rows[rows.length - 2] += rows.pop();
    };
    const stringVisibleTrimSpacesRight = (string)=>{
        const words = string.split(' ');
        let last = words.length;
        while(last > 0){
            if (stringWidth(words[last - 1]) > 0) break;
            last--;
        }
        if (last === words.length) return string;
        return words.slice(0, last).join(' ') + words.slice(last).join('');
    };
    const wrap_ansi_exec = (string, columns, options = {})=>{
        if (false !== options.trim && '' === string.trim()) return '';
        let returnValue = '';
        let escapeCode;
        let escapeUrl;
        const lengths = wordLengths(string);
        let rows = [
            ''
        ];
        for (const [index, word] of string.split(' ').entries()){
            if (false !== options.trim) rows[rows.length - 1] = rows.at(-1).trimStart();
            let rowLength = stringWidth(rows.at(-1));
            if (0 !== index) {
                if (rowLength >= columns && (false === options.wordWrap || false === options.trim)) {
                    rows.push('');
                    rowLength = 0;
                }
                if (rowLength > 0 || false === options.trim) {
                    rows[rows.length - 1] += ' ';
                    rowLength++;
                }
            }
            if (options.hard && lengths[index] > columns) {
                const remainingColumns = columns - rowLength;
                const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
                const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
                if (breaksStartingNextLine < breaksStartingThisLine) rows.push('');
                wrapWord(rows, word, columns);
                continue;
            }
            if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
                if (false === options.wordWrap && rowLength < columns) {
                    wrapWord(rows, word, columns);
                    continue;
                }
                rows.push('');
            }
            if (rowLength + lengths[index] > columns && false === options.wordWrap) {
                wrapWord(rows, word, columns);
                continue;
            }
            rows[rows.length - 1] += word;
        }
        if (false !== options.trim) rows = rows.map((row)=>stringVisibleTrimSpacesRight(row));
        const preString = rows.join('\n');
        const pre = [
            ...preString
        ];
        let preStringIndex = 0;
        for (const [index, character] of pre.entries()){
            returnValue += character;
            if (ESCAPES.has(character)) {
                const { groups } = new RegExp(`(?:\\${ANSI_CSI}(?<code>\\d+)m|\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(preString.slice(preStringIndex)) || {
                    groups: {}
                };
                if (void 0 !== groups.code) {
                    const code = Number.parseFloat(groups.code);
                    escapeCode = code === END_CODE ? void 0 : code;
                } else if (void 0 !== groups.uri) escapeUrl = 0 === groups.uri.length ? void 0 : groups.uri;
            }
            const code = node_modules_ansi_styles.codes.get(Number(escapeCode));
            if ('\n' === pre[index + 1]) {
                if (escapeUrl) returnValue += wrapAnsiHyperlink('');
                if (escapeCode && code) returnValue += wrapAnsiCode(code);
            } else if ('\n' === character) {
                if (escapeCode && code) returnValue += wrapAnsiCode(escapeCode);
                if (escapeUrl) returnValue += wrapAnsiHyperlink(escapeUrl);
            }
            preStringIndex += character.length;
        }
        return returnValue;
    };
    function wrapAnsi(string, columns, options) {
        return String(string).normalize().replaceAll('\r\n', '\n').split('\n').map((line)=>wrap_ansi_exec(line, columns, options)).join('\n');
    }
    const NEWLINE = '\n';
    const PAD = ' ';
    const NONE = 'none';
    const terminalColumns = ()=>{
        const { env, stdout, stderr } = external_node_process_;
        if (stdout?.columns) return stdout.columns;
        if (stderr?.columns) return stderr.columns;
        if (env.COLUMNS) return Number.parseInt(env.COLUMNS, 10);
        return 80;
    };
    const getObject = (detail)=>'number' == typeof detail ? {
            top: detail,
            right: 3 * detail,
            bottom: detail,
            left: 3 * detail
        } : {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            ...detail
        };
    const getBorderWidth = (borderStyle)=>borderStyle === NONE ? 0 : 2;
    const getBorderChars = (borderStyle)=>{
        const sides = [
            'topLeft',
            'topRight',
            'bottomRight',
            'bottomLeft',
            'left',
            'right',
            'top',
            'bottom'
        ];
        let characters;
        if (borderStyle === NONE) {
            borderStyle = {};
            for (const side of sides)borderStyle[side] = '';
        }
        if ('string' == typeof borderStyle) {
            characters = cli_boxes[borderStyle];
            if (!characters) throw new TypeError(`Invalid border style: ${borderStyle}`);
        } else {
            if ('string' == typeof borderStyle?.vertical) {
                borderStyle.left = borderStyle.vertical;
                borderStyle.right = borderStyle.vertical;
            }
            if ('string' == typeof borderStyle?.horizontal) {
                borderStyle.top = borderStyle.horizontal;
                borderStyle.bottom = borderStyle.horizontal;
            }
            for (const side of sides)if (null === borderStyle[side] || 'string' != typeof borderStyle[side]) throw new TypeError(`Invalid border style: ${side}`);
            characters = borderStyle;
        }
        return characters;
    };
    const makeTitle = (text, horizontal, alignment)=>{
        let title = '';
        const textWidth = stringWidth(text);
        switch(alignment){
            case 'left':
                title = text + horizontal.slice(textWidth);
                break;
            case 'right':
                title = horizontal.slice(textWidth) + text;
                break;
            default:
                horizontal = horizontal.slice(textWidth);
                if (horizontal.length % 2 === 1) {
                    horizontal = horizontal.slice(Math.floor(horizontal.length / 2));
                    title = horizontal.slice(1) + text + horizontal;
                } else {
                    horizontal = horizontal.slice(horizontal.length / 2);
                    title = horizontal + text + horizontal;
                }
                break;
        }
        return title;
    };
    const makeContentText = (text, { padding, width, textAlignment, height })=>{
        text = ansi_align(text, {
            align: textAlignment
        });
        let lines = text.split(NEWLINE);
        const textWidth = widestLine(text);
        const max = width - padding.left - padding.right;
        if (textWidth > max) {
            const newLines = [];
            for (const line of lines){
                const createdLines = wrapAnsi(line, max, {
                    hard: true
                });
                const alignedLines = ansi_align(createdLines, {
                    align: textAlignment
                });
                const alignedLinesArray = alignedLines.split('\n');
                const longestLength = Math.max(...alignedLinesArray.map((s)=>stringWidth(s)));
                for (const alignedLine of alignedLinesArray){
                    let paddedLine;
                    switch(textAlignment){
                        case 'center':
                            paddedLine = PAD.repeat((max - longestLength) / 2) + alignedLine;
                            break;
                        case 'right':
                            paddedLine = PAD.repeat(max - longestLength) + alignedLine;
                            break;
                        default:
                            paddedLine = alignedLine;
                            break;
                    }
                    newLines.push(paddedLine);
                }
            }
            lines = newLines;
        }
        if ('center' === textAlignment && textWidth < max) lines = lines.map((line)=>PAD.repeat((max - textWidth) / 2) + line);
        else if ('right' === textAlignment && textWidth < max) lines = lines.map((line)=>PAD.repeat(max - textWidth) + line);
        const paddingLeft = PAD.repeat(padding.left);
        const paddingRight = PAD.repeat(padding.right);
        lines = lines.map((line)=>{
            const newLine = paddingLeft + line + paddingRight;
            return newLine + PAD.repeat(width - stringWidth(newLine));
        });
        if (padding.top > 0) lines = [
            ...Array.from({
                length: padding.top
            }).fill(PAD.repeat(width)),
            ...lines
        ];
        if (padding.bottom > 0) lines = [
            ...lines,
            ...Array.from({
                length: padding.bottom
            }).fill(PAD.repeat(width))
        ];
        if (height && lines.length > height) lines = lines.slice(0, height);
        else if (height && lines.length < height) lines = [
            ...lines,
            ...Array.from({
                length: height - lines.length
            }).fill(PAD.repeat(width))
        ];
        return lines.join(NEWLINE);
    };
    const boxen_boxContent = (content, contentWidth, options)=>{
        const colorizeBorder = (border)=>{
            const newBorder = options.borderColor ? getColorFunction(options.borderColor)(border) : border;
            return options.dimBorder ? chalk_source.dim(newBorder) : newBorder;
        };
        const colorizeContent = (content)=>options.backgroundColor ? getBGColorFunction(options.backgroundColor)(content) : content;
        const chars = getBorderChars(options.borderStyle);
        const columns = terminalColumns();
        let marginLeft = PAD.repeat(options.margin.left);
        if ('center' === options.float) {
            const marginWidth = Math.max((columns - contentWidth - getBorderWidth(options.borderStyle)) / 2, 0);
            marginLeft = PAD.repeat(marginWidth);
        } else if ('right' === options.float) {
            const marginWidth = Math.max(columns - contentWidth - options.margin.right - getBorderWidth(options.borderStyle), 0);
            marginLeft = PAD.repeat(marginWidth);
        }
        let result = '';
        if (options.margin.top) result += NEWLINE.repeat(options.margin.top);
        if (options.borderStyle !== NONE || options.title) result += colorizeBorder(marginLeft + chars.topLeft + (options.title ? makeTitle(options.title, chars.top.repeat(contentWidth), options.titleAlignment) : chars.top.repeat(contentWidth)) + chars.topRight) + NEWLINE;
        const lines = content.split(NEWLINE);
        result += lines.map((line)=>marginLeft + colorizeBorder(chars.left) + colorizeContent(line) + colorizeBorder(chars.right)).join(NEWLINE);
        if (options.borderStyle !== NONE) result += NEWLINE + colorizeBorder(marginLeft + chars.bottomLeft + chars.bottom.repeat(contentWidth) + chars.bottomRight);
        if (options.margin.bottom) result += NEWLINE.repeat(options.margin.bottom);
        return result;
    };
    const sanitizeOptions = (options)=>{
        if (options.fullscreen && external_node_process_?.stdout) {
            let newDimensions = [
                external_node_process_.stdout.columns,
                external_node_process_.stdout.rows
            ];
            if ('function' == typeof options.fullscreen) newDimensions = options.fullscreen(...newDimensions);
            options.width ||= newDimensions[0];
            options.height ||= newDimensions[1];
        }
        options.width &&= Math.max(1, options.width - getBorderWidth(options.borderStyle));
        options.height &&= Math.max(1, options.height - getBorderWidth(options.borderStyle));
        return options;
    };
    const formatTitle = (title, borderStyle)=>borderStyle === NONE ? title : ` ${title} `;
    const determineDimensions = (text, options)=>{
        options = sanitizeOptions(options);
        const widthOverride = void 0 !== options.width;
        const columns = terminalColumns();
        const borderWidth = getBorderWidth(options.borderStyle);
        const maxWidth = columns - options.margin.left - options.margin.right - borderWidth;
        const widest = widestLine(wrapAnsi(text, columns - borderWidth, {
            hard: true,
            trim: false
        })) + options.padding.left + options.padding.right;
        if (options.title && widthOverride) {
            options.title = options.title.slice(0, Math.max(0, options.width - 2));
            options.title &&= formatTitle(options.title, options.borderStyle);
        } else if (options.title) {
            options.title = options.title.slice(0, Math.max(0, maxWidth - 2));
            if (options.title) {
                options.title = formatTitle(options.title, options.borderStyle);
                if (stringWidth(options.title) > widest) options.width = stringWidth(options.title);
            }
        }
        options.width ||= widest;
        if (!widthOverride) {
            if (options.margin.left && options.margin.right && options.width > maxWidth) {
                const spaceForMargins = columns - options.width - borderWidth;
                const multiplier = spaceForMargins / (options.margin.left + options.margin.right);
                options.margin.left = Math.max(0, Math.floor(options.margin.left * multiplier));
                options.margin.right = Math.max(0, Math.floor(options.margin.right * multiplier));
            }
            options.width = Math.min(options.width, columns - borderWidth - options.margin.left - options.margin.right);
        }
        if (options.width - (options.padding.left + options.padding.right) <= 0) {
            options.padding.left = 0;
            options.padding.right = 0;
        }
        if (options.height && options.height - (options.padding.top + options.padding.bottom) <= 0) {
            options.padding.top = 0;
            options.padding.bottom = 0;
        }
        return options;
    };
    const isHex = (color)=>color.match(/^#(?:[0-f]{3}){1,2}$/i);
    const isColorValid = (color)=>'string' == typeof color && (chalk_source[color] ?? isHex(color));
    const getColorFunction = (color)=>isHex(color) ? chalk_source.hex(color) : chalk_source[color];
    const getBGColorFunction = (color)=>isHex(color) ? chalk_source.bgHex(color) : chalk_source[camelCase([
            'bg',
            color
        ])];
    function boxen(text, options) {
        options = {
            padding: 0,
            borderStyle: 'single',
            dimBorder: false,
            textAlignment: 'left',
            float: 'left',
            titleAlignment: 'left',
            ...options
        };
        if (options.align) options.textAlignment = options.align;
        if (options.borderColor && !isColorValid(options.borderColor)) throw new Error(`${options.borderColor} is not a valid borderColor`);
        if (options.backgroundColor && !isColorValid(options.backgroundColor)) throw new Error(`${options.backgroundColor} is not a valid backgroundColor`);
        options.padding = getObject(options.padding);
        options.margin = getObject(options.margin);
        options = determineDimensions(text, options);
        text = makeContentText(text, options);
        return boxen_boxContent(text, options.width, options);
    }
    var gradient_string = __webpack_require__("../node_modules/.pnpm/gradient-string@2.0.2/node_modules/gradient-string/index.js");
    var gradient_string_default = /*#__PURE__*/ __webpack_require__.n(gradient_string);
    function printWelcomeLogo(version) {
        const brandColor1 = '#4d9de0';
        const brandColor2 = '#7289da';
        const brandGradient = gradient_string_default()(brandColor1, brandColor2);
        const logoGradient = gradient_string_default()('#888', '#fff');
        const agentArt = " █████  ██████  ███████ ███    ██ ████████\n██   ██ ██      ██      ████   ██    ██   \n███████ ██   ██ █████   ██ ██  ██    ██   \n██   ██ ██   ██ ██      ██  ██ ██    ██   \n██   ██ ███████ ███████ ██   ████    ██   ";
        const tarsArt = "████████  █████  ██████   ███████\n   ██    ██   ██ ██   ██  ██     \n   ██    ███████ ██████   ███████\n   ██    ██   ██ ██   ██       ██\n   ██    ██   ██ ██   ██  ███████";
        const logoContent = [
            brandGradient.multiline(agentArt, {
                interpolation: 'hsv'
            }),
            '',
            brandGradient.multiline(tarsArt, {
                interpolation: 'hsv'
            }),
            '',
            '',
            `${brandGradient('An open-source Multimodal AI Agent')} ${chalk_source.dim(`v${version}`)}`,
            '',
            chalk_source.dim(logoGradient('https://agent-tars.com'))
        ].join('\n');
        const boxedLogo = boxen(logoContent, {
            padding: 1,
            margin: {
                top: 1,
                bottom: 1
            },
            borderColor: brandColor2,
            borderStyle: 'classic',
            dimBorder: true
        });
        console.log(boxedLogo);
    }
    const core_namespaceObject = require("@agent-tars/core");
    var external_fs_ = __webpack_require__("fs");
    var external_fs_default = /*#__PURE__*/ __webpack_require__.n(external_fs_);
    var external_os_ = __webpack_require__("os");
    var external_os_default = /*#__PURE__*/ __webpack_require__.n(external_os_);
    var external_path_ = __webpack_require__("path");
    var external_path_default = /*#__PURE__*/ __webpack_require__.n(external_path_);
    const external_child_process_namespaceObject = require("child_process");
    var external_util_ = __webpack_require__("util");
    const logger = (0, core_namespaceObject.getLogger)('AgentTARS');
    function resolveValue(value, label = 'value') {
        if (!value) return;
        if (/^[A-Z][A-Z0-9_]*$/.test(value)) {
            const envValue = process.env[value];
            if (envValue) {
                logger.debug(`Using ${label} from environment variable: ${value}`);
                return envValue;
            }
            logger.warn(`Environment variable "${value}" not found, using as literal value`);
        }
        return value;
    }
    function toUserFriendlyPath(absolutePath) {
        const homedir = external_os_default().homedir();
        if (absolutePath.startsWith(homedir)) return absolutePath.replace(homedir, '~');
        return absolutePath;
    }
    function _define_property(obj, key, value) {
        if (key in obj) Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
        else obj[key] = value;
        return obj;
    }
    class ConsoleInterceptor {
        start() {
            if (this.options.debug) logger.debug('Starting console output interception');
            console.log = this.createInterceptor(this.originalConsole.log);
            console.info = this.createInterceptor(this.originalConsole.info);
            console.warn = this.createInterceptor(this.originalConsole.warn, process.stderr);
            console.error = this.createInterceptor(this.originalConsole.error, process.stderr);
            console.debug = this.createInterceptor(this.originalConsole.debug);
        }
        stop() {
            console.log = this.originalConsole.log;
            console.info = this.originalConsole.info;
            console.warn = this.originalConsole.warn;
            console.error = this.originalConsole.error;
            console.debug = this.originalConsole.debug;
            if (this.options.debug) logger.debug('Console output interception stopped');
        }
        getCapturedOutput() {
            return [
                ...this.buffer
            ];
        }
        getCapturedString() {
            return this.buffer.join('\n');
        }
        clearBuffer() {
            this.buffer = [];
        }
        createInterceptor(original, stream = process.stdout) {
            return (...args)=>{
                const message = args.map((arg)=>'string' == typeof arg ? arg : JSON.stringify(arg)).join(' ');
                if (this.options.filter && !this.options.filter(message)) return void original.apply(console, args);
                if (this.options.capture) this.buffer.push(message);
                if (this.options.debug) logger.debug(`[Intercepted]: ${message}`);
                if (!this.options.silent) original.apply(console, args);
            };
        }
        static async run(fn, options) {
            const interceptor = new ConsoleInterceptor(options);
            interceptor.start();
            try {
                const result = await fn();
                return {
                    result,
                    logs: interceptor.getCapturedOutput()
                };
            } finally{
                interceptor.stop();
            }
        }
        constructor(options = {}){
            _define_property(this, "originalConsole", void 0);
            _define_property(this, "buffer", []);
            _define_property(this, "options", void 0);
            this.options = {
                silent: true,
                capture: true,
                ...options
            };
            this.originalConsole = {
                log: console.log,
                info: console.info,
                warn: console.warn,
                error: console.error,
                debug: console.debug
            };
        }
    }
    var external_node_fs_ = __webpack_require__("node:fs");
    var external_node_fs_default = /*#__PURE__*/ __webpack_require__.n(external_node_fs_);
    var external_node_path_ = __webpack_require__("node:path");
    var external_node_path_default = /*#__PURE__*/ __webpack_require__.n(external_node_path_);
    var external_node_url_ = __webpack_require__("node:url");
    const isObject = (obj)=>null !== obj && 'object' == typeof obj && Object.getPrototypeOf(obj) === Object.prototype;
    const resolveConfigPath = (root, configFiles, customConfig)=>{
        if (customConfig) {
            const customConfigPath = external_node_path_default().isAbsolute(customConfig) ? customConfig : external_node_path_default().join(root, customConfig);
            if (external_node_fs_default().existsSync(customConfigPath)) return customConfigPath;
        }
        if (0 === configFiles.length) return null;
        for (const file of configFiles){
            const configFile = external_node_path_default().join(root, file);
            if (external_node_fs_default().existsSync(configFile)) return configFile;
        }
        return null;
    };
    async function loadConfig({ cwd = process.cwd(), path: configPath, meta = {}, envMode, loader = 'jiti', configFiles = [] } = {}) {
        const configFilePath = resolveConfigPath(cwd, configFiles, configPath);
        if (!configFilePath) return {
            content: {},
            filePath: configFilePath
        };
        let configExport;
        if (/\.json$/.test(configFilePath)) try {
            const content = await external_node_fs_default().promises.readFile(configFilePath, 'utf-8');
            configExport = JSON.parse(content);
        } catch (err) {
            console.error(`Failed to load JSON file: ${configFilePath}`);
            throw err;
        }
        else if (/\.ya?ml$/.test(configFilePath)) try {
            const { default: yaml } = await __webpack_require__.e("943").then(__webpack_require__.bind(__webpack_require__, "../node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/dist/js-yaml.mjs"));
            const content = await external_node_fs_default().promises.readFile(configFilePath, 'utf-8');
            configExport = yaml.load(content);
        } catch (err) {
            console.error(`Failed to load YAML file: ${configFilePath}`);
            throw err;
        }
        else if ('native' === loader || /\.(?:js|mjs|cjs)$/.test(configFilePath)) try {
            const configFileURL = (0, external_node_url_.pathToFileURL)(configFilePath).href;
            const exportModule = await import(`${configFileURL}?t=${Date.now()}`);
            configExport = exportModule.default ? exportModule.default : exportModule;
        } catch (err) {
            if ('native' === loader) {
                console.error(`Failed to load file with native loader: ${configFilePath}`);
                throw err;
            }
            console.debug(`Failed to load file with dynamic import: ${configFilePath}`);
        }
        try {
            if (void 0 === configExport) {
                const { createJiti } = await __webpack_require__.e("581").then(__webpack_require__.bind(__webpack_require__, "../node_modules/.pnpm/jiti@2.4.2/node_modules/jiti/lib/jiti.mjs"));
                const jiti = createJiti(__filename, {
                    moduleCache: false,
                    interopDefault: true
                });
                configExport = await jiti.import(configFilePath, {
                    default: true
                });
            }
        } catch (err) {
            console.error(`Failed to load file with jiti: ${configFilePath}`);
            throw err;
        }
        if ('function' == typeof configExport) {
            const nodeEnv = process.env.NODE_ENV || 'development';
            const configParams = {
                env: nodeEnv,
                envMode: envMode || nodeEnv,
                meta
            };
            const result = await configExport(configParams);
            if (void 0 === result) throw new Error('[loadConfig] The config function must return a config object.');
            return {
                content: result,
                filePath: configFilePath
            };
        }
        if (!isObject(configExport)) throw new Error(`[loadConfig] The config must be an object or a function that returns an object, got ${configExport}`);
        return {
            content: configExport,
            filePath: configFilePath
        };
    }
    const external_stream_namespaceObject = require("stream");
    const external_http_namespaceObject = require("http");
    var external_url_ = __webpack_require__("url");
    var public_api = __webpack_require__("../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js");
    const external_https_namespaceObject = require("https");
    const external_zlib_namespaceObject = require("zlib");
    const Readable = external_stream_namespaceObject.Readable;
    const BUFFER = Symbol('buffer');
    const TYPE = Symbol('type');
    class Blob {
        constructor(){
            this[TYPE] = '';
            const blobParts = arguments[0];
            const options = arguments[1];
            const buffers = [];
            if (blobParts) {
                const a = blobParts;
                const length = Number(a.length);
                for(let i = 0; i < length; i++){
                    const element = a[i];
                    let buffer;
                    buffer = element instanceof Buffer ? element : ArrayBuffer.isView(element) ? Buffer.from(element.buffer, element.byteOffset, element.byteLength) : element instanceof ArrayBuffer ? Buffer.from(element) : element instanceof Blob ? element[BUFFER] : Buffer.from('string' == typeof element ? element : String(element));
                    buffer.length;
                    buffers.push(buffer);
                }
            }
            this[BUFFER] = Buffer.concat(buffers);
            let type = options && void 0 !== options.type && String(options.type).toLowerCase();
            if (type && !/[^\u0020-\u007E]/.test(type)) this[TYPE] = type;
        }
        get size() {
            return this[BUFFER].length;
        }
        get type() {
            return this[TYPE];
        }
        text() {
            return Promise.resolve(this[BUFFER].toString());
        }
        arrayBuffer() {
            const buf = this[BUFFER];
            const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
            return Promise.resolve(ab);
        }
        stream() {
            const readable = new Readable();
            readable._read = function() {};
            readable.push(this[BUFFER]);
            readable.push(null);
            return readable;
        }
        toString() {
            return '[object Blob]';
        }
        slice() {
            const size = this.size;
            const start = arguments[0];
            const end = arguments[1];
            let relativeStart, relativeEnd;
            relativeStart = void 0 === start ? 0 : start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
            relativeEnd = void 0 === end ? size : end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
            const span = Math.max(relativeEnd - relativeStart, 0);
            const buffer = this[BUFFER];
            const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
            const blob = new Blob([], {
                type: arguments[2]
            });
            blob[BUFFER] = slicedBuffer;
            return blob;
        }
    }
    Object.defineProperties(Blob.prototype, {
        size: {
            enumerable: true
        },
        type: {
            enumerable: true
        },
        slice: {
            enumerable: true
        }
    });
    Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
        value: 'Blob',
        writable: false,
        enumerable: false,
        configurable: true
    });
    function FetchError(message, type, systemError) {
        Error.call(this, message);
        this.message = message;
        this.type = type;
        if (systemError) this.code = this.errno = systemError.code;
        Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = 'FetchError';
    let convert;
    try {
        convert = require('encoding').convert;
    } catch (e) {}
    const INTERNALS = Symbol('Body internals');
    const PassThrough = external_stream_namespaceObject.PassThrough;
    function Body(body) {
        var _this = this;
        var _ref = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, _ref$size = _ref.size;
        let size = void 0 === _ref$size ? 0 : _ref$size;
        var _ref$timeout = _ref.timeout;
        let timeout = void 0 === _ref$timeout ? 0 : _ref$timeout;
        if (null == body) body = null;
        else if (isURLSearchParams(body)) body = Buffer.from(body.toString());
        else if (isBlob(body)) ;
        else if (Buffer.isBuffer(body)) ;
        else if ('[object ArrayBuffer]' === Object.prototype.toString.call(body)) body = Buffer.from(body);
        else if (ArrayBuffer.isView(body)) body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        else body instanceof external_stream_namespaceObject || (body = Buffer.from(String(body)));
        this[INTERNALS] = {
            body,
            disturbed: false,
            error: null
        };
        this.size = size;
        this.timeout = timeout;
        if (body instanceof external_stream_namespaceObject) body.on('error', function(err) {
            const error = 'AbortError' === err.name ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
            _this[INTERNALS].error = error;
        });
    }
    Body.prototype = {
        get body () {
            return this[INTERNALS].body;
        },
        get bodyUsed () {
            return this[INTERNALS].disturbed;
        },
        arrayBuffer () {
            return consumeBody.call(this).then(function(buf) {
                return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
            });
        },
        blob () {
            let ct = this.headers && this.headers.get('content-type') || '';
            return consumeBody.call(this).then(function(buf) {
                return Object.assign(new Blob([], {
                    type: ct.toLowerCase()
                }), {
                    [BUFFER]: buf
                });
            });
        },
        json () {
            var _this2 = this;
            return consumeBody.call(this).then(function(buffer) {
                try {
                    return JSON.parse(buffer.toString());
                } catch (err) {
                    return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
                }
            });
        },
        text () {
            return consumeBody.call(this).then(function(buffer) {
                return buffer.toString();
            });
        },
        buffer () {
            return consumeBody.call(this);
        },
        textConverted () {
            var _this3 = this;
            return consumeBody.call(this).then(function(buffer) {
                return convertBody(buffer, _this3.headers);
            });
        }
    };
    Object.defineProperties(Body.prototype, {
        body: {
            enumerable: true
        },
        bodyUsed: {
            enumerable: true
        },
        arrayBuffer: {
            enumerable: true
        },
        blob: {
            enumerable: true
        },
        json: {
            enumerable: true
        },
        text: {
            enumerable: true
        }
    });
    Body.mixIn = function(proto) {
        for (const name of Object.getOwnPropertyNames(Body.prototype))if (!(name in proto)) {
            const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
            Object.defineProperty(proto, name, desc);
        }
    };
    function consumeBody() {
        var _this4 = this;
        if (this[INTERNALS].disturbed) return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
        this[INTERNALS].disturbed = true;
        if (this[INTERNALS].error) return Body.Promise.reject(this[INTERNALS].error);
        let body = this.body;
        if (null === body) return Body.Promise.resolve(Buffer.alloc(0));
        if (isBlob(body)) body = body.stream();
        if (Buffer.isBuffer(body)) return Body.Promise.resolve(body);
        if (!(body instanceof external_stream_namespaceObject)) return Body.Promise.resolve(Buffer.alloc(0));
        let accum = [];
        let accumBytes = 0;
        let abort = false;
        return new Body.Promise(function(resolve, reject) {
            let resTimeout;
            if (_this4.timeout) resTimeout = setTimeout(function() {
                abort = true;
                reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
            }, _this4.timeout);
            body.on('error', function(err) {
                if ('AbortError' === err.name) {
                    abort = true;
                    reject(err);
                } else reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
            });
            body.on('data', function(chunk) {
                if (abort || null === chunk) return;
                if (_this4.size && accumBytes + chunk.length > _this4.size) {
                    abort = true;
                    reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
                    return;
                }
                accumBytes += chunk.length;
                accum.push(chunk);
            });
            body.on('end', function() {
                if (abort) return;
                clearTimeout(resTimeout);
                try {
                    resolve(Buffer.concat(accum, accumBytes));
                } catch (err) {
                    reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
                }
            });
        });
    }
    function convertBody(buffer, headers) {
        if ('function' != typeof convert) throw new Error('The package `encoding` must be installed to use the textConverted() function');
        const ct = headers.get('content-type');
        let charset = 'utf-8';
        let res, str;
        if (ct) res = /charset=([^;]*)/i.exec(ct);
        str = buffer.slice(0, 1024).toString();
        if (!res && str) res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
        if (!res && str) {
            res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
            if (!res) {
                res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
                if (res) res.pop();
            }
            if (res) res = /charset=(.*)/i.exec(res.pop());
        }
        if (!res && str) res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
        if (res) {
            charset = res.pop();
            if ('gb2312' === charset || 'gbk' === charset) charset = 'gb18030';
        }
        return convert(buffer, 'UTF-8', charset).toString();
    }
    function isURLSearchParams(obj) {
        if ('object' != typeof obj || 'function' != typeof obj.append || 'function' != typeof obj.delete || 'function' != typeof obj.get || 'function' != typeof obj.getAll || 'function' != typeof obj.has || 'function' != typeof obj.set) return false;
        return 'URLSearchParams' === obj.constructor.name || '[object URLSearchParams]' === Object.prototype.toString.call(obj) || 'function' == typeof obj.sort;
    }
    function isBlob(obj) {
        return 'object' == typeof obj && 'function' == typeof obj.arrayBuffer && 'string' == typeof obj.type && 'function' == typeof obj.stream && 'function' == typeof obj.constructor && 'string' == typeof obj.constructor.name && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone(instance) {
        let p1, p2;
        let body = instance.body;
        if (instance.bodyUsed) throw new Error('cannot clone body after it is used');
        if (body instanceof external_stream_namespaceObject && 'function' != typeof body.getBoundary) {
            p1 = new PassThrough();
            p2 = new PassThrough();
            body.pipe(p1);
            body.pipe(p2);
            instance[INTERNALS].body = p1;
            body = p2;
        }
        return body;
    }
    function extractContentType(body) {
        if (null === body) return null;
        if ('string' == typeof body) return 'text/plain;charset=UTF-8';
        if (isURLSearchParams(body)) return 'application/x-www-form-urlencoded;charset=UTF-8';
        if (isBlob(body)) return body.type || null;
        if (Buffer.isBuffer(body)) return null;
        else if ('[object ArrayBuffer]' === Object.prototype.toString.call(body)) return null;
        else if (ArrayBuffer.isView(body)) return null;
        else if ('function' == typeof body.getBoundary) return `multipart/form-data;boundary=${body.getBoundary()}`;
        else if (body instanceof external_stream_namespaceObject) return null;
        else return 'text/plain;charset=UTF-8';
    }
    function getTotalBytes(instance) {
        const body = instance.body;
        if (null === body) return 0;
        if (isBlob(body)) return body.size;
        if (Buffer.isBuffer(body)) return body.length;
        if (!body || 'function' != typeof body.getLengthSync) return null;
        if (body._lengthRetrievers && 0 == body._lengthRetrievers.length || body.hasKnownLength && body.hasKnownLength()) return body.getLengthSync();
        return null;
    }
    function writeToStream(dest, instance) {
        const body = instance.body;
        if (null === body) dest.end();
        else if (isBlob(body)) body.stream().pipe(dest);
        else if (Buffer.isBuffer(body)) {
            dest.write(body);
            dest.end();
        } else body.pipe(dest);
    }
    Body.Promise = global.Promise;
    const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name) {
        name = `${name}`;
        if (invalidTokenRegex.test(name) || '' === name) throw new TypeError(`${name} is not a legal HTTP header name`);
    }
    function validateValue(value) {
        value = `${value}`;
        if (invalidHeaderCharRegex.test(value)) throw new TypeError(`${value} is not a legal HTTP header value`);
    }
    function find(map, name) {
        name = name.toLowerCase();
        for(const key in map)if (key.toLowerCase() === name) return key;
    }
    const MAP = Symbol('map');
    class Headers {
        constructor(){
            let init = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
            this[MAP] = Object.create(null);
            if (init instanceof Headers) {
                const rawHeaders = init.raw();
                const headerNames = Object.keys(rawHeaders);
                for (const headerName of headerNames)for (const value of rawHeaders[headerName])this.append(headerName, value);
                return;
            }
            if (null == init) ;
            else if ('object' == typeof init) {
                const method = init[Symbol.iterator];
                if (null != method) {
                    if ('function' != typeof method) throw new TypeError('Header pairs must be iterable');
                    const pairs = [];
                    for (const pair of init){
                        if ('object' != typeof pair || 'function' != typeof pair[Symbol.iterator]) throw new TypeError('Each header pair must be iterable');
                        pairs.push(Array.from(pair));
                    }
                    for (const pair of pairs){
                        if (2 !== pair.length) throw new TypeError('Each header pair must be a name/value tuple');
                        this.append(pair[0], pair[1]);
                    }
                } else for (const key of Object.keys(init)){
                    const value = init[key];
                    this.append(key, value);
                }
            } else throw new TypeError('Provided initializer must be an object');
        }
        get(name) {
            name = `${name}`;
            validateName(name);
            const key = find(this[MAP], name);
            if (void 0 === key) return null;
            return this[MAP][key].join(', ');
        }
        forEach(callback) {
            let thisArg = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0;
            let pairs = getHeaders(this);
            let i = 0;
            while(i < pairs.length){
                var _pairs$i = pairs[i];
                const name = _pairs$i[0], value = _pairs$i[1];
                callback.call(thisArg, value, name, this);
                pairs = getHeaders(this);
                i++;
            }
        }
        set(name, value) {
            name = `${name}`;
            value = `${value}`;
            validateName(name);
            validateValue(value);
            const key = find(this[MAP], name);
            this[MAP][void 0 !== key ? key : name] = [
                value
            ];
        }
        append(name, value) {
            name = `${name}`;
            value = `${value}`;
            validateName(name);
            validateValue(value);
            const key = find(this[MAP], name);
            if (void 0 !== key) this[MAP][key].push(value);
            else this[MAP][name] = [
                value
            ];
        }
        has(name) {
            name = `${name}`;
            validateName(name);
            return void 0 !== find(this[MAP], name);
        }
        delete(name) {
            name = `${name}`;
            validateName(name);
            const key = find(this[MAP], name);
            if (void 0 !== key) delete this[MAP][key];
        }
        raw() {
            return this[MAP];
        }
        keys() {
            return createHeadersIterator(this, 'key');
        }
        values() {
            return createHeadersIterator(this, 'value');
        }
        [Symbol.iterator]() {
            return createHeadersIterator(this, 'key+value');
        }
    }
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
        value: 'Headers',
        writable: false,
        enumerable: false,
        configurable: true
    });
    Object.defineProperties(Headers.prototype, {
        get: {
            enumerable: true
        },
        forEach: {
            enumerable: true
        },
        set: {
            enumerable: true
        },
        append: {
            enumerable: true
        },
        has: {
            enumerable: true
        },
        delete: {
            enumerable: true
        },
        keys: {
            enumerable: true
        },
        values: {
            enumerable: true
        },
        entries: {
            enumerable: true
        }
    });
    function getHeaders(headers) {
        let kind = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'key+value';
        const keys = Object.keys(headers[MAP]).sort();
        return keys.map('key' === kind ? function(k) {
            return k.toLowerCase();
        } : 'value' === kind ? function(k) {
            return headers[MAP][k].join(', ');
        } : function(k) {
            return [
                k.toLowerCase(),
                headers[MAP][k].join(', ')
            ];
        });
    }
    const INTERNAL = Symbol('internal');
    function createHeadersIterator(target, kind) {
        const iterator = Object.create(HeadersIteratorPrototype);
        iterator[INTERNAL] = {
            target,
            kind,
            index: 0
        };
        return iterator;
    }
    const HeadersIteratorPrototype = Object.setPrototypeOf({
        next () {
            if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) throw new TypeError('Value of `this` is not a HeadersIterator');
            var _INTERNAL = this[INTERNAL];
            const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
            const values = getHeaders(target, kind);
            const len = values.length;
            if (index >= len) return {
                value: void 0,
                done: true
            };
            this[INTERNAL].index = index + 1;
            return {
                value: values[index],
                done: false
            };
        }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
        value: 'HeadersIterator',
        writable: false,
        enumerable: false,
        configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
        const obj = Object.assign({
            __proto__: null
        }, headers[MAP]);
        const hostHeaderKey = find(headers[MAP], 'Host');
        if (void 0 !== hostHeaderKey) obj[hostHeaderKey] = obj[hostHeaderKey][0];
        return obj;
    }
    function createHeadersLenient(obj) {
        const headers = new Headers();
        for (const name of Object.keys(obj))if (!invalidTokenRegex.test(name)) {
            if (Array.isArray(obj[name])) {
                for (const val of obj[name])if (!invalidHeaderCharRegex.test(val)) if (void 0 === headers[MAP][name]) headers[MAP][name] = [
                    val
                ];
                else headers[MAP][name].push(val);
            } else if (!invalidHeaderCharRegex.test(obj[name])) headers[MAP][name] = [
                obj[name]
            ];
        }
        return headers;
    }
    const INTERNALS$1 = Symbol('Response internals');
    const STATUS_CODES = external_http_namespaceObject.STATUS_CODES;
    class Response {
        constructor(){
            let body = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
            let opts = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            Body.call(this, body, opts);
            const status = opts.status || 200;
            const headers = new Headers(opts.headers);
            if (null != body && !headers.has('Content-Type')) {
                const contentType = extractContentType(body);
                if (contentType) headers.append('Content-Type', contentType);
            }
            this[INTERNALS$1] = {
                url: opts.url,
                status,
                statusText: opts.statusText || STATUS_CODES[status],
                headers,
                counter: opts.counter
            };
        }
        get url() {
            return this[INTERNALS$1].url || '';
        }
        get status() {
            return this[INTERNALS$1].status;
        }
        get ok() {
            return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
        }
        get redirected() {
            return this[INTERNALS$1].counter > 0;
        }
        get statusText() {
            return this[INTERNALS$1].statusText;
        }
        get headers() {
            return this[INTERNALS$1].headers;
        }
        clone() {
            return new Response(clone(this), {
                url: this.url,
                status: this.status,
                statusText: this.statusText,
                headers: this.headers,
                ok: this.ok,
                redirected: this.redirected
            });
        }
    }
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
        url: {
            enumerable: true
        },
        status: {
            enumerable: true
        },
        ok: {
            enumerable: true
        },
        redirected: {
            enumerable: true
        },
        statusText: {
            enumerable: true
        },
        headers: {
            enumerable: true
        },
        clone: {
            enumerable: true
        }
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
        value: 'Response',
        writable: false,
        enumerable: false,
        configurable: true
    });
    const INTERNALS$2 = Symbol('Request internals');
    const lib_URL = external_url_.URL || public_api.URL;
    const parse_url = external_url_.parse;
    const format_url = external_url_.format;
    function parseURL(urlStr) {
        if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) urlStr = new lib_URL(urlStr).toString();
        return parse_url(urlStr);
    }
    const streamDestructionSupported = 'destroy' in external_stream_namespaceObject.Readable.prototype;
    function isRequest(input) {
        return 'object' == typeof input && 'object' == typeof input[INTERNALS$2];
    }
    function isAbortSignal(signal) {
        const proto = signal && 'object' == typeof signal && Object.getPrototypeOf(signal);
        return !!(proto && 'AbortSignal' === proto.constructor.name);
    }
    class Request {
        constructor(input){
            let init = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            let parsedURL;
            if (isRequest(input)) parsedURL = parseURL(input.url);
            else {
                parsedURL = input && input.href ? parseURL(input.href) : parseURL(`${input}`);
                input = {};
            }
            let method = init.method || input.method || 'GET';
            method = method.toUpperCase();
            if ((null != init.body || isRequest(input) && null !== input.body) && ('GET' === method || 'HEAD' === method)) throw new TypeError('Request with GET/HEAD method cannot have body');
            let inputBody = null != init.body ? init.body : isRequest(input) && null !== input.body ? clone(input) : null;
            Body.call(this, inputBody, {
                timeout: init.timeout || input.timeout || 0,
                size: init.size || input.size || 0
            });
            const headers = new Headers(init.headers || input.headers || {});
            if (null != inputBody && !headers.has('Content-Type')) {
                const contentType = extractContentType(inputBody);
                if (contentType) headers.append('Content-Type', contentType);
            }
            let signal = isRequest(input) ? input.signal : null;
            if ('signal' in init) signal = init.signal;
            if (null != signal && !isAbortSignal(signal)) throw new TypeError('Expected signal to be an instanceof AbortSignal');
            this[INTERNALS$2] = {
                method,
                redirect: init.redirect || input.redirect || 'follow',
                headers,
                parsedURL,
                signal
            };
            this.follow = void 0 !== init.follow ? init.follow : void 0 !== input.follow ? input.follow : 20;
            this.compress = void 0 !== init.compress ? init.compress : void 0 !== input.compress ? input.compress : true;
            this.counter = init.counter || input.counter || 0;
            this.agent = init.agent || input.agent;
        }
        get method() {
            return this[INTERNALS$2].method;
        }
        get url() {
            return format_url(this[INTERNALS$2].parsedURL);
        }
        get headers() {
            return this[INTERNALS$2].headers;
        }
        get redirect() {
            return this[INTERNALS$2].redirect;
        }
        get signal() {
            return this[INTERNALS$2].signal;
        }
        clone() {
            return new Request(this);
        }
    }
    Body.mixIn(Request.prototype);
    Object.defineProperty(Request.prototype, Symbol.toStringTag, {
        value: 'Request',
        writable: false,
        enumerable: false,
        configurable: true
    });
    Object.defineProperties(Request.prototype, {
        method: {
            enumerable: true
        },
        url: {
            enumerable: true
        },
        headers: {
            enumerable: true
        },
        redirect: {
            enumerable: true
        },
        clone: {
            enumerable: true
        },
        signal: {
            enumerable: true
        }
    });
    function getNodeRequestOptions(request) {
        const parsedURL = request[INTERNALS$2].parsedURL;
        const headers = new Headers(request[INTERNALS$2].headers);
        if (!headers.has('Accept')) headers.set('Accept', '*/*');
        if (!parsedURL.protocol || !parsedURL.hostname) throw new TypeError('Only absolute URLs are supported');
        if (!/^https?:$/.test(parsedURL.protocol)) throw new TypeError('Only HTTP(S) protocols are supported');
        if (request.signal && request.body instanceof external_stream_namespaceObject.Readable && !streamDestructionSupported) throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
        let contentLengthValue = null;
        if (null == request.body && /^(POST|PUT)$/i.test(request.method)) contentLengthValue = '0';
        if (null != request.body) {
            const totalBytes = getTotalBytes(request);
            if ('number' == typeof totalBytes) contentLengthValue = String(totalBytes);
        }
        if (contentLengthValue) headers.set('Content-Length', contentLengthValue);
        if (!headers.has('User-Agent')) headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
        if (request.compress && !headers.has('Accept-Encoding')) headers.set('Accept-Encoding', 'gzip,deflate');
        let agent = request.agent;
        if ('function' == typeof agent) agent = agent(parsedURL);
        return Object.assign({}, parsedURL, {
            method: request.method,
            headers: exportNodeCompatibleHeaders(headers),
            agent
        });
    }
    function AbortError(message) {
        Error.call(this, message);
        this.type = 'aborted';
        this.message = message;
        Error.captureStackTrace(this, this.constructor);
    }
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = 'AbortError';
    const URL$1 = external_url_.URL || public_api.URL;
    const PassThrough$1 = external_stream_namespaceObject.PassThrough;
    const lib_isDomainOrSubdomain = function(destination, original) {
        const orig = new URL$1(original).hostname;
        const dest = new URL$1(destination).hostname;
        return orig === dest || '.' === orig[orig.length - dest.length - 1] && orig.endsWith(dest);
    };
    const lib_isSameProtocol = function(destination, original) {
        const orig = new URL$1(original).protocol;
        const dest = new URL$1(destination).protocol;
        return orig === dest;
    };
    function lib_fetch(url, opts) {
        if (!lib_fetch.Promise) throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
        Body.Promise = lib_fetch.Promise;
        return new lib_fetch.Promise(function(resolve, reject) {
            const request = new Request(url, opts);
            const options = getNodeRequestOptions(request);
            const send = ('https:' === options.protocol ? external_https_namespaceObject : external_http_namespaceObject).request;
            const signal = request.signal;
            let response = null;
            const abort = function() {
                let error = new AbortError('The user aborted a request.');
                reject(error);
                if (request.body && request.body instanceof external_stream_namespaceObject.Readable) destroyStream(request.body, error);
                if (!response || !response.body) return;
                response.body.emit('error', error);
            };
            if (signal && signal.aborted) return void abort();
            const abortAndFinalize = function() {
                abort();
                finalize();
            };
            const req = send(options);
            let reqTimeout;
            if (signal) signal.addEventListener('abort', abortAndFinalize);
            function finalize() {
                req.abort();
                if (signal) signal.removeEventListener('abort', abortAndFinalize);
                clearTimeout(reqTimeout);
            }
            if (request.timeout) req.once('socket', function(socket) {
                reqTimeout = setTimeout(function() {
                    reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
                    finalize();
                }, request.timeout);
            });
            req.on('error', function(err) {
                reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
                if (response && response.body) destroyStream(response.body, err);
                finalize();
            });
            fixResponseChunkedTransferBadEnding(req, function(err) {
                if (signal && signal.aborted) return;
                if (response && response.body) destroyStream(response.body, err);
            });
            if (parseInt(process.version.substring(1)) < 14) req.on('socket', function(s) {
                s.addListener('close', function(hadError) {
                    const hasDataListener = s.listenerCount('data') > 0;
                    if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
                        const err = new Error('Premature close');
                        err.code = 'ERR_STREAM_PREMATURE_CLOSE';
                        response.body.emit('error', err);
                    }
                });
            });
            req.on('response', function(res) {
                clearTimeout(reqTimeout);
                const headers = createHeadersLenient(res.headers);
                if (lib_fetch.isRedirect(res.statusCode)) {
                    const location = headers.get('Location');
                    let locationURL = null;
                    try {
                        locationURL = null === location ? null : new URL$1(location, request.url).toString();
                    } catch (err) {
                        if ('manual' !== request.redirect) {
                            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));
                            finalize();
                            return;
                        }
                    }
                    switch(request.redirect){
                        case 'error':
                            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
                            finalize();
                            return;
                        case 'manual':
                            if (null !== locationURL) try {
                                headers.set('Location', locationURL);
                            } catch (err) {
                                reject(err);
                            }
                            break;
                        case 'follow':
                            if (null === locationURL) break;
                            if (request.counter >= request.follow) {
                                reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
                                finalize();
                                return;
                            }
                            const requestOpts = {
                                headers: new Headers(request.headers),
                                follow: request.follow,
                                counter: request.counter + 1,
                                agent: request.agent,
                                compress: request.compress,
                                method: request.method,
                                body: request.body,
                                signal: request.signal,
                                timeout: request.timeout,
                                size: request.size
                            };
                            if (!lib_isDomainOrSubdomain(request.url, locationURL) || !lib_isSameProtocol(request.url, locationURL)) for (const name of [
                                'authorization',
                                'www-authenticate',
                                'cookie',
                                'cookie2'
                            ])requestOpts.headers.delete(name);
                            if (303 !== res.statusCode && request.body && null === getTotalBytes(request)) {
                                reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
                                finalize();
                                return;
                            }
                            if (303 === res.statusCode || (301 === res.statusCode || 302 === res.statusCode) && 'POST' === request.method) {
                                requestOpts.method = 'GET';
                                requestOpts.body = void 0;
                                requestOpts.headers.delete('content-length');
                            }
                            resolve(lib_fetch(new Request(locationURL, requestOpts)));
                            finalize();
                            return;
                    }
                }
                res.once('end', function() {
                    if (signal) signal.removeEventListener('abort', abortAndFinalize);
                });
                let body = res.pipe(new PassThrough$1());
                const response_options = {
                    url: request.url,
                    status: res.statusCode,
                    statusText: res.statusMessage,
                    headers: headers,
                    size: request.size,
                    timeout: request.timeout,
                    counter: request.counter
                };
                const codings = headers.get('Content-Encoding');
                if (!request.compress || 'HEAD' === request.method || null === codings || 204 === res.statusCode || 304 === res.statusCode) {
                    response = new Response(body, response_options);
                    resolve(response);
                    return;
                }
                const zlibOptions = {
                    flush: external_zlib_namespaceObject.Z_SYNC_FLUSH,
                    finishFlush: external_zlib_namespaceObject.Z_SYNC_FLUSH
                };
                if ('gzip' == codings || 'x-gzip' == codings) {
                    body = body.pipe(external_zlib_namespaceObject.createGunzip(zlibOptions));
                    response = new Response(body, response_options);
                    resolve(response);
                    return;
                }
                if ('deflate' == codings || 'x-deflate' == codings) {
                    const raw = res.pipe(new PassThrough$1());
                    raw.once('data', function(chunk) {
                        body = (0x0F & chunk[0]) === 0x08 ? body.pipe(external_zlib_namespaceObject.createInflate()) : body.pipe(external_zlib_namespaceObject.createInflateRaw());
                        response = new Response(body, response_options);
                        resolve(response);
                    });
                    raw.on('end', function() {
                        if (!response) {
                            response = new Response(body, response_options);
                            resolve(response);
                        }
                    });
                    return;
                }
                if ('br' == codings && 'function' == typeof external_zlib_namespaceObject.createBrotliDecompress) {
                    body = body.pipe(external_zlib_namespaceObject.createBrotliDecompress());
                    response = new Response(body, response_options);
                    resolve(response);
                    return;
                }
                response = new Response(body, response_options);
                resolve(response);
            });
            writeToStream(req, request);
        });
    }
    function fixResponseChunkedTransferBadEnding(request, errorCallback) {
        let socket;
        request.on('socket', function(s) {
            socket = s;
        });
        request.on('response', function(response) {
            const headers = response.headers;
            if ('chunked' === headers['transfer-encoding'] && !headers['content-length']) response.once('close', function(hadError) {
                const hasDataListener = socket && socket.listenerCount('data') > 0;
                if (hasDataListener && !hadError) {
                    const err = new Error('Premature close');
                    err.code = 'ERR_STREAM_PREMATURE_CLOSE';
                    errorCallback(err);
                }
            });
        });
    }
    function destroyStream(stream, err) {
        if (stream.destroy) stream.destroy(err);
        else {
            stream.emit('error', err);
            stream.end();
        }
    }
    lib_fetch.isRedirect = function(code) {
        return 301 === code || 302 === code || 303 === code || 307 === code || 308 === code;
    };
    lib_fetch.Promise = global.Promise;
    const lib = lib_fetch;
    const CONFIG_FILES = [
        'agent-tars.config.ts',
        'agent-tars.config.yaml',
        'agent-tars.config.json'
    ];
    function buildConfigPaths({ cliConfigPaths = [], bootstrapRemoteConfig, useGlobalWorkspace, globalWorkspacePath, isDebug = false }) {
        const configPaths = [
            ...cliConfigPaths
        ];
        if (bootstrapRemoteConfig) configPaths.unshift(bootstrapRemoteConfig);
        if (useGlobalWorkspace && globalWorkspacePath) {
            let foundWorkspaceConfig = false;
            for (const file of CONFIG_FILES){
                const configPath = external_path_.join(globalWorkspacePath, file);
                if (external_fs_.existsSync(configPath)) {
                    logger.debug(`Load global workspace config: ${configPath}`);
                    configPaths.push(configPath);
                    foundWorkspaceConfig = true;
                    break;
                }
            }
            if (!foundWorkspaceConfig && isDebug) logger.debug(`No config file found in global workspace: ${globalWorkspacePath}`);
            if (isDebug) logger.debug(`Added global workspace configs: ${globalWorkspacePath}`);
        }
        return configPaths;
    }
    async function loadRemoteConfig(url, isDebug = false) {
        try {
            if (isDebug) logger.debug(`Loading remote config from: ${url}`);
            const response = await lib(url);
            if (!response.ok) throw new Error(`Failed to fetch remote config: ${response.statusText}`);
            const contentType = response.headers.get('content-type') || '';
            if (contentType.includes('application/json')) return await response.json();
            {
                console.warn(`Remote config has non-JSON content type: ${contentType}`);
                const text = await response.text();
                try {
                    return JSON.parse(text);
                } catch (error) {
                    throw new Error(`Failed to parse remote config as JSON: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
        } catch (error) {
            console.error(`Error loading remote config from ${url}: ${error instanceof Error ? error.message : String(error)}`);
            return {};
        }
    }
    function isUrl(str) {
        try {
            new URL(str);
            return true;
        } catch  {
            return false;
        }
    }
    async function loadTarsConfig(configPaths, isDebug = false) {
        if (!configPaths || 0 === configPaths.length) try {
            const { content, filePath } = await loadConfig({
                cwd: process.cwd(),
                configFiles: CONFIG_FILES
            });
            if (filePath && isDebug) logger.debug(`Loaded default config from: ${filePath}`);
            return content;
        } catch (err) {
            if (isDebug) logger.debug(`Failed to load default configuration: ${err instanceof Error ? err.message : String(err)}`);
            return {};
        }
        let mergedConfig = {};
        for (const path of configPaths){
            let config = {};
            if (isUrl(path)) config = await loadRemoteConfig(path, isDebug);
            else try {
                const { content, filePath } = await loadConfig({
                    cwd: process.cwd(),
                    path
                });
                if (filePath && isDebug) logger.debug(`Loaded config from: ${filePath}`);
                config = content;
            } catch (err) {
                console.error(`Failed to load configuration from ${path}: ${err instanceof Error ? err.message : String(err)}`);
                continue;
            }
            mergedConfig = deepMerge(mergedConfig, config);
        }
        return mergedConfig;
    }
    function deepMerge(target, source) {
        const output = {
            ...target
        };
        if (loader_isObject(target) && loader_isObject(source)) Object.keys(source).forEach((key)=>{
            if (loader_isObject(source[key])) if (key in target) output[key] = deepMerge(target[key], source[key]);
            else Object.assign(output, {
                [key]: source[key]
            });
            else Object.assign(output, {
                [key]: source[key]
            });
        });
        return output;
    }
    function loader_isObject(item) {
        return item && 'object' == typeof item && !Array.isArray(item);
    }
    __webpack_require__("../agent-interface/dist/agent.mjs");
    var types_LogLevel = /*#__PURE__*/ function(LogLevel) {
        LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
        LogLevel[LogLevel["INFO"] = 1] = "INFO";
        LogLevel[LogLevel["SUCCESS"] = 2] = "SUCCESS";
        LogLevel[LogLevel["WARN"] = 3] = "WARN";
        LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
        LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
        return LogLevel;
    }({});
    class BaseLogger {
        log(...args) {}
        info(...args) {}
        warn(...args) {}
        error(...args) {}
        debug(...args) {}
        success(message) {}
        infoWithData(message, data, transformer) {}
        spawn(subPrefix) {
            return new BaseLogger();
        }
        setLevel(level) {}
        getLevel() {
            return 1;
        }
    }
    new BaseLogger();
    var _process_stdout;
    const colorize_isBrowser = 'undefined' != typeof window && void 0 !== window.document;
    colorize_isBrowser || 'NO_COLOR' in process.env || '0' === process.env.FORCE_COLOR || void 0 !== process.env.FORCE_COLOR || null == (_process_stdout = process.stdout) || _process_stdout.isTTY;
    const CSS_COLOR_VALUES = {
        black: '#1E1E2E',
        red: '#F87171',
        green: '#10B981',
        yellow: '#FBBF24',
        blue: '#3B82F6',
        magenta: '#A78BFA',
        cyan: '#06B6D4',
        white: '#F3F4F6',
        gray: '#9CA3AF',
        reset: 'inherit'
    };
    const CSS_COLORS = {};
    Object.entries(CSS_COLOR_VALUES).forEach(([key, value])=>{
        CSS_COLORS[key] = `color: ${value}`;
    });
    var util_util;
    (function(util) {
        util.assertEqual = (_)=>{};
        function assertIs(_arg) {}
        util.assertIs = assertIs;
        function assertNever(_x) {
            throw new Error();
        }
        util.assertNever = assertNever;
        util.arrayToEnum = (items)=>{
            const obj = {};
            for (const item of items)obj[item] = item;
            return obj;
        };
        util.getValidEnumValues = (obj)=>{
            const validKeys = util.objectKeys(obj).filter((k)=>"number" != typeof obj[obj[k]]);
            const filtered = {};
            for (const k of validKeys)filtered[k] = obj[k];
            return util.objectValues(filtered);
        };
        util.objectValues = (obj)=>util.objectKeys(obj).map(function(e) {
                return obj[e];
            });
        util.objectKeys = "function" == typeof Object.keys ? (obj)=>Object.keys(obj) : (object)=>{
            const keys = [];
            for(const key in object)if (Object.prototype.hasOwnProperty.call(object, key)) keys.push(key);
            return keys;
        };
        util.find = (arr, checker)=>{
            for (const item of arr)if (checker(item)) return item;
        };
        util.isInteger = "function" == typeof Number.isInteger ? (val)=>Number.isInteger(val) : (val)=>"number" == typeof val && Number.isFinite(val) && Math.floor(val) === val;
        function joinValues(array, separator = " | ") {
            return array.map((val)=>"string" == typeof val ? `'${val}'` : val).join(separator);
        }
        util.joinValues = joinValues;
        util.jsonStringifyReplacer = (_, value)=>{
            if ("bigint" == typeof value) return value.toString();
            return value;
        };
    })(util_util || (util_util = {}));
    var util_objectUtil;
    (function(objectUtil) {
        objectUtil.mergeShapes = (first, second)=>({
                ...first,
                ...second
            });
    })(util_objectUtil || (util_objectUtil = {}));
    const ZodParsedType = util_util.arrayToEnum([
        "string",
        "nan",
        "number",
        "integer",
        "float",
        "boolean",
        "date",
        "bigint",
        "symbol",
        "function",
        "undefined",
        "null",
        "array",
        "object",
        "unknown",
        "promise",
        "void",
        "never",
        "map",
        "set"
    ]);
    const getParsedType = (data)=>{
        const t = typeof data;
        switch(t){
            case "undefined":
                return ZodParsedType.undefined;
            case "string":
                return ZodParsedType.string;
            case "number":
                return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
            case "boolean":
                return ZodParsedType.boolean;
            case "function":
                return ZodParsedType.function;
            case "bigint":
                return ZodParsedType.bigint;
            case "symbol":
                return ZodParsedType.symbol;
            case "object":
                if (Array.isArray(data)) return ZodParsedType.array;
                if (null === data) return ZodParsedType.null;
                if (data.then && "function" == typeof data.then && data.catch && "function" == typeof data.catch) return ZodParsedType.promise;
                if ("undefined" != typeof Map && data instanceof Map) return ZodParsedType.map;
                if ("undefined" != typeof Set && data instanceof Set) return ZodParsedType.set;
                if ("undefined" != typeof Date && data instanceof Date) return ZodParsedType.date;
                return ZodParsedType.object;
            default:
                return ZodParsedType.unknown;
        }
    };
    const ZodIssueCode = util_util.arrayToEnum([
        "invalid_type",
        "invalid_literal",
        "custom",
        "invalid_union",
        "invalid_union_discriminator",
        "invalid_enum_value",
        "unrecognized_keys",
        "invalid_arguments",
        "invalid_return_type",
        "invalid_date",
        "invalid_string",
        "too_small",
        "too_big",
        "invalid_intersection_types",
        "not_multiple_of",
        "not_finite"
    ]);
    class ZodError extends Error {
        get errors() {
            return this.issues;
        }
        constructor(issues){
            super();
            this.issues = [];
            this.addIssue = (sub)=>{
                this.issues = [
                    ...this.issues,
                    sub
                ];
            };
            this.addIssues = (subs = [])=>{
                this.issues = [
                    ...this.issues,
                    ...subs
                ];
            };
            const actualProto = new.target.prototype;
            if (Object.setPrototypeOf) Object.setPrototypeOf(this, actualProto);
            else this.__proto__ = actualProto;
            this.name = "ZodError";
            this.issues = issues;
        }
        format(_mapper) {
            const mapper = _mapper || function(issue) {
                return issue.message;
            };
            const fieldErrors = {
                _errors: []
            };
            const processError = (error)=>{
                for (const issue of error.issues)if ("invalid_union" === issue.code) issue.unionErrors.map(processError);
                else if ("invalid_return_type" === issue.code) processError(issue.returnTypeError);
                else if ("invalid_arguments" === issue.code) processError(issue.argumentsError);
                else if (0 === issue.path.length) fieldErrors._errors.push(mapper(issue));
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while(i < issue.path.length){
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (terminal) {
                            curr[el] = curr[el] || {
                                _errors: []
                            };
                            curr[el]._errors.push(mapper(issue));
                        } else curr[el] = curr[el] || {
                            _errors: []
                        };
                        curr = curr[el];
                        i++;
                    }
                }
            };
            processError(this);
            return fieldErrors;
        }
        static assert(value) {
            if (!(value instanceof ZodError)) throw new Error(`Not a ZodError: ${value}`);
        }
        toString() {
            return this.message;
        }
        get message() {
            return JSON.stringify(this.issues, util_util.jsonStringifyReplacer, 2);
        }
        get isEmpty() {
            return 0 === this.issues.length;
        }
        flatten(mapper = (issue)=>issue.message) {
            const fieldErrors = {};
            const formErrors = [];
            for (const sub of this.issues)if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            } else formErrors.push(mapper(sub));
            return {
                formErrors,
                fieldErrors
            };
        }
        get formErrors() {
            return this.flatten();
        }
    }
    ZodError.create = (issues)=>{
        const error = new ZodError(issues);
        return error;
    };
    const en_errorMap = (issue, _ctx)=>{
        let message;
        switch(issue.code){
            case ZodIssueCode.invalid_type:
                message = issue.received === ZodParsedType.undefined ? "Required" : `Expected ${issue.expected}, received ${issue.received}`;
                break;
            case ZodIssueCode.invalid_literal:
                message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_util.jsonStringifyReplacer)}`;
                break;
            case ZodIssueCode.unrecognized_keys:
                message = `Unrecognized key(s) in object: ${util_util.joinValues(issue.keys, ", ")}`;
                break;
            case ZodIssueCode.invalid_union:
                message = "Invalid input";
                break;
            case ZodIssueCode.invalid_union_discriminator:
                message = `Invalid discriminator value. Expected ${util_util.joinValues(issue.options)}`;
                break;
            case ZodIssueCode.invalid_enum_value:
                message = `Invalid enum value. Expected ${util_util.joinValues(issue.options)}, received '${issue.received}'`;
                break;
            case ZodIssueCode.invalid_arguments:
                message = "Invalid function arguments";
                break;
            case ZodIssueCode.invalid_return_type:
                message = "Invalid function return type";
                break;
            case ZodIssueCode.invalid_date:
                message = "Invalid date";
                break;
            case ZodIssueCode.invalid_string:
                if ("object" == typeof issue.validation) if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if ("number" == typeof issue.validation.position) message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                } else if ("startsWith" in issue.validation) message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                else if ("endsWith" in issue.validation) message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                else util_util.assertNever(issue.validation);
                else message = "regex" !== issue.validation ? `Invalid ${issue.validation}` : "Invalid";
                break;
            case ZodIssueCode.too_small:
                message = "array" === issue.type ? `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? "at least" : "more than"} ${issue.minimum} element(s)` : "string" === issue.type ? `String must contain ${issue.exact ? "exactly" : issue.inclusive ? "at least" : "over"} ${issue.minimum} character(s)` : "number" === issue.type ? `Number must be ${issue.exact ? "exactly equal to " : issue.inclusive ? "greater than or equal to " : "greater than "}${issue.minimum}` : "date" === issue.type ? `Date must be ${issue.exact ? "exactly equal to " : issue.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(issue.minimum))}` : "Invalid input";
                break;
            case ZodIssueCode.too_big:
                message = "array" === issue.type ? `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? "at most" : "less than"} ${issue.maximum} element(s)` : "string" === issue.type ? `String must contain ${issue.exact ? "exactly" : issue.inclusive ? "at most" : "under"} ${issue.maximum} character(s)` : "number" === issue.type ? `Number must be ${issue.exact ? "exactly" : issue.inclusive ? "less than or equal to" : "less than"} ${issue.maximum}` : "bigint" === issue.type ? `BigInt must be ${issue.exact ? "exactly" : issue.inclusive ? "less than or equal to" : "less than"} ${issue.maximum}` : "date" === issue.type ? `Date must be ${issue.exact ? "exactly" : issue.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(issue.maximum))}` : "Invalid input";
                break;
            case ZodIssueCode.custom:
                message = "Invalid input";
                break;
            case ZodIssueCode.invalid_intersection_types:
                message = "Intersection results could not be merged";
                break;
            case ZodIssueCode.not_multiple_of:
                message = `Number must be a multiple of ${issue.multipleOf}`;
                break;
            case ZodIssueCode.not_finite:
                message = "Number must be finite";
                break;
            default:
                message = _ctx.defaultError;
                util_util.assertNever(issue);
        }
        return {
            message
        };
    };
    const en = en_errorMap;
    let overrideErrorMap = en;
    function getErrorMap() {
        return overrideErrorMap;
    }
    const makeIssue = (params)=>{
        const { data, path, errorMaps, issueData } = params;
        const fullPath = [
            ...path,
            ...issueData.path || []
        ];
        const fullIssue = {
            ...issueData,
            path: fullPath
        };
        if (void 0 !== issueData.message) return {
            ...issueData,
            path: fullPath,
            message: issueData.message
        };
        let errorMessage = "";
        const maps = errorMaps.filter((m)=>!!m).slice().reverse();
        for (const map of maps)errorMessage = map(fullIssue, {
            data,
            defaultError: errorMessage
        }).message;
        return {
            ...issueData,
            path: fullPath,
            message: errorMessage
        };
    };
    function addIssueToContext(ctx, issueData) {
        const overrideMap = getErrorMap();
        const issue = makeIssue({
            issueData: issueData,
            data: ctx.data,
            path: ctx.path,
            errorMaps: [
                ctx.common.contextualErrorMap,
                ctx.schemaErrorMap,
                overrideMap,
                overrideMap === en ? void 0 : en
            ].filter((x)=>!!x)
        });
        ctx.common.issues.push(issue);
    }
    class ParseStatus {
        constructor(){
            this.value = "valid";
        }
        dirty() {
            if ("valid" === this.value) this.value = "dirty";
        }
        abort() {
            if ("aborted" !== this.value) this.value = "aborted";
        }
        static mergeArray(status, results) {
            const arrayValue = [];
            for (const s of results){
                if ("aborted" === s.status) return parseUtil_INVALID;
                if ("dirty" === s.status) status.dirty();
                arrayValue.push(s.value);
            }
            return {
                status: status.value,
                value: arrayValue
            };
        }
        static async mergeObjectAsync(status, pairs) {
            const syncPairs = [];
            for (const pair of pairs){
                const key = await pair.key;
                const value = await pair.value;
                syncPairs.push({
                    key,
                    value
                });
            }
            return ParseStatus.mergeObjectSync(status, syncPairs);
        }
        static mergeObjectSync(status, pairs) {
            const finalObject = {};
            for (const pair of pairs){
                const { key, value } = pair;
                if ("aborted" === key.status) return parseUtil_INVALID;
                if ("aborted" === value.status) return parseUtil_INVALID;
                if ("dirty" === key.status) status.dirty();
                if ("dirty" === value.status) status.dirty();
                if ("__proto__" !== key.value && (void 0 !== value.value || pair.alwaysSet)) finalObject[key.value] = value.value;
            }
            return {
                status: status.value,
                value: finalObject
            };
        }
    }
    const parseUtil_INVALID = Object.freeze({
        status: "aborted"
    });
    const DIRTY = (value)=>({
            status: "dirty",
            value
        });
    const OK = (value)=>({
            status: "valid",
            value
        });
    const isAborted = (x)=>"aborted" === x.status;
    const isDirty = (x)=>"dirty" === x.status;
    const isValid = (x)=>"valid" === x.status;
    const isAsync = (x)=>"undefined" != typeof Promise && x instanceof Promise;
    var errorUtil_errorUtil;
    (function(errorUtil) {
        errorUtil.errToObj = (message)=>"string" == typeof message ? {
                message
            } : message || {};
        errorUtil.toString = (message)=>"string" == typeof message ? message : message?.message;
    })(errorUtil_errorUtil || (errorUtil_errorUtil = {}));
    class ParseInputLazyPath {
        constructor(parent, value, path, key){
            this._cachedPath = [];
            this.parent = parent;
            this.data = value;
            this._path = path;
            this._key = key;
        }
        get path() {
            if (!this._cachedPath.length) if (Array.isArray(this._key)) this._cachedPath.push(...this._path, ...this._key);
            else this._cachedPath.push(...this._path, this._key);
            return this._cachedPath;
        }
    }
    const handleResult = (ctx, result)=>{
        if (isValid(result)) return {
            success: true,
            data: result.value
        };
        if (!ctx.common.issues.length) throw new Error("Validation failed but no issues detected.");
        return {
            success: false,
            get error () {
                if (this._error) return this._error;
                const error = new ZodError(ctx.common.issues);
                this._error = error;
                return this._error;
            }
        };
    };
    function processCreateParams(params) {
        if (!params) return {};
        const { errorMap, invalid_type_error, required_error, description } = params;
        if (errorMap && (invalid_type_error || required_error)) throw new Error('Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.');
        if (errorMap) return {
            errorMap: errorMap,
            description
        };
        const customMap = (iss, ctx)=>{
            const { message } = params;
            if ("invalid_enum_value" === iss.code) return {
                message: message ?? ctx.defaultError
            };
            if (void 0 === ctx.data) return {
                message: message ?? required_error ?? ctx.defaultError
            };
            if ("invalid_type" !== iss.code) return {
                message: ctx.defaultError
            };
            return {
                message: message ?? invalid_type_error ?? ctx.defaultError
            };
        };
        return {
            errorMap: customMap,
            description
        };
    }
    class ZodType {
        get description() {
            return this._def.description;
        }
        _getType(input) {
            return getParsedType(input.data);
        }
        _getOrReturnCtx(input, ctx) {
            return ctx || {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent
            };
        }
        _processInputParams(input) {
            return {
                status: new ParseStatus(),
                ctx: {
                    common: input.parent.common,
                    data: input.data,
                    parsedType: getParsedType(input.data),
                    schemaErrorMap: this._def.errorMap,
                    path: input.path,
                    parent: input.parent
                }
            };
        }
        _parseSync(input) {
            const result = this._parse(input);
            if (isAsync(result)) throw new Error("Synchronous parse encountered promise.");
            return result;
        }
        _parseAsync(input) {
            const result = this._parse(input);
            return Promise.resolve(result);
        }
        parse(data, params) {
            const result = this.safeParse(data, params);
            if (result.success) return result.data;
            throw result.error;
        }
        safeParse(data, params) {
            const ctx = {
                common: {
                    issues: [],
                    async: params?.async ?? false,
                    contextualErrorMap: params?.errorMap
                },
                path: params?.path || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data,
                parsedType: getParsedType(data)
            };
            const result = this._parseSync({
                data,
                path: ctx.path,
                parent: ctx
            });
            return handleResult(ctx, result);
        }
        "~validate"(data) {
            const ctx = {
                common: {
                    issues: [],
                    async: !!this["~standard"].async
                },
                path: [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data,
                parsedType: getParsedType(data)
            };
            if (!this["~standard"].async) try {
                const result = this._parseSync({
                    data,
                    path: [],
                    parent: ctx
                });
                return isValid(result) ? {
                    value: result.value
                } : {
                    issues: ctx.common.issues
                };
            } catch (err) {
                if (err?.message?.toLowerCase()?.includes("encountered")) this["~standard"].async = true;
                ctx.common = {
                    issues: [],
                    async: true
                };
            }
            return this._parseAsync({
                data,
                path: [],
                parent: ctx
            }).then((result)=>isValid(result) ? {
                    value: result.value
                } : {
                    issues: ctx.common.issues
                });
        }
        async parseAsync(data, params) {
            const result = await this.safeParseAsync(data, params);
            if (result.success) return result.data;
            throw result.error;
        }
        async safeParseAsync(data, params) {
            const ctx = {
                common: {
                    issues: [],
                    contextualErrorMap: params?.errorMap,
                    async: true
                },
                path: params?.path || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data,
                parsedType: getParsedType(data)
            };
            const maybeAsyncResult = this._parse({
                data,
                path: ctx.path,
                parent: ctx
            });
            const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
            return handleResult(ctx, result);
        }
        refine(check, message) {
            const getIssueProperties = (val)=>{
                if ("string" == typeof message || void 0 === message) return {
                    message
                };
                if ("function" == typeof message) return message(val);
                return message;
            };
            return this._refinement((val, ctx)=>{
                const result = check(val);
                const setError = ()=>ctx.addIssue({
                        code: ZodIssueCode.custom,
                        ...getIssueProperties(val)
                    });
                if ("undefined" != typeof Promise && result instanceof Promise) return result.then((data)=>{
                    if (data) return true;
                    setError();
                    return false;
                });
                if (result) return true;
                setError();
                return false;
            });
        }
        refinement(check, refinementData) {
            return this._refinement((val, ctx)=>{
                if (check(val)) return true;
                ctx.addIssue("function" == typeof refinementData ? refinementData(val, ctx) : refinementData);
                return false;
            });
        }
        _refinement(refinement) {
            return new ZodEffects({
                schema: this,
                typeName: types_ZodFirstPartyTypeKind.ZodEffects,
                effect: {
                    type: "refinement",
                    refinement
                }
            });
        }
        superRefine(refinement) {
            return this._refinement(refinement);
        }
        constructor(def){
            this.spa = this.safeParseAsync;
            this._def = def;
            this.parse = this.parse.bind(this);
            this.safeParse = this.safeParse.bind(this);
            this.parseAsync = this.parseAsync.bind(this);
            this.safeParseAsync = this.safeParseAsync.bind(this);
            this.spa = this.spa.bind(this);
            this.refine = this.refine.bind(this);
            this.refinement = this.refinement.bind(this);
            this.superRefine = this.superRefine.bind(this);
            this.optional = this.optional.bind(this);
            this.nullable = this.nullable.bind(this);
            this.nullish = this.nullish.bind(this);
            this.array = this.array.bind(this);
            this.promise = this.promise.bind(this);
            this.or = this.or.bind(this);
            this.and = this.and.bind(this);
            this.transform = this.transform.bind(this);
            this.brand = this.brand.bind(this);
            this.default = this.default.bind(this);
            this.catch = this.catch.bind(this);
            this.describe = this.describe.bind(this);
            this.pipe = this.pipe.bind(this);
            this.readonly = this.readonly.bind(this);
            this.isNullable = this.isNullable.bind(this);
            this.isOptional = this.isOptional.bind(this);
            this["~standard"] = {
                version: 1,
                vendor: "zod",
                validate: (data)=>this["~validate"](data)
            };
        }
        optional() {
            return ZodOptional.create(this, this._def);
        }
        nullable() {
            return ZodNullable.create(this, this._def);
        }
        nullish() {
            return this.nullable().optional();
        }
        array() {
            return ZodArray.create(this);
        }
        promise() {
            return ZodPromise.create(this, this._def);
        }
        or(option) {
            return ZodUnion.create([
                this,
                option
            ], this._def);
        }
        and(incoming) {
            return ZodIntersection.create(this, incoming, this._def);
        }
        transform(transform) {
            return new ZodEffects({
                ...processCreateParams(this._def),
                schema: this,
                typeName: types_ZodFirstPartyTypeKind.ZodEffects,
                effect: {
                    type: "transform",
                    transform
                }
            });
        }
        default(def) {
            const defaultValueFunc = "function" == typeof def ? def : ()=>def;
            return new ZodDefault({
                ...processCreateParams(this._def),
                innerType: this,
                defaultValue: defaultValueFunc,
                typeName: types_ZodFirstPartyTypeKind.ZodDefault
            });
        }
        brand() {
            return new ZodBranded({
                typeName: types_ZodFirstPartyTypeKind.ZodBranded,
                type: this,
                ...processCreateParams(this._def)
            });
        }
        catch(def) {
            const catchValueFunc = "function" == typeof def ? def : ()=>def;
            return new ZodCatch({
                ...processCreateParams(this._def),
                innerType: this,
                catchValue: catchValueFunc,
                typeName: types_ZodFirstPartyTypeKind.ZodCatch
            });
        }
        describe(description) {
            const This = this.constructor;
            return new This({
                ...this._def,
                description
            });
        }
        pipe(target) {
            return ZodPipeline.create(this, target);
        }
        readonly() {
            return ZodReadonly.create(this);
        }
        isOptional() {
            return this.safeParse(void 0).success;
        }
        isNullable() {
            return this.safeParse(null).success;
        }
    }
    const cuidRegex = /^c[^\s-]{8,}$/i;
    const cuid2Regex = /^[0-9a-z]+$/;
    const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
    const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    const nanoidRegex = /^[a-z0-9_-]{21}$/i;
    const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
    const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    const _emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
    let emojiRegex;
    const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
    const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
    const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
    const dateRegexSource = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))";
    const dateRegex = new RegExp(`^${dateRegexSource}$`);
    function timeRegexSource(args) {
        let secondsRegexSource = "[0-5]\\d";
        if (args.precision) secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
        else if (null == args.precision) secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
        const secondsQuantifier = args.precision ? "+" : "?";
        return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
    }
    function timeRegex(args) {
        return new RegExp(`^${timeRegexSource(args)}$`);
    }
    function datetimeRegex(args) {
        let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
        const opts = [];
        opts.push(args.local ? "Z?" : "Z");
        if (args.offset) opts.push("([+-]\\d{2}:?\\d{2})");
        regex = `${regex}(${opts.join("|")})`;
        return new RegExp(`^${regex}$`);
    }
    function isValidIP(ip, version) {
        if (("v4" === version || !version) && ipv4Regex.test(ip)) return true;
        if (("v6" === version || !version) && ipv6Regex.test(ip)) return true;
        return false;
    }
    function isValidJWT(jwt, alg) {
        if (!jwtRegex.test(jwt)) return false;
        try {
            const [header] = jwt.split(".");
            const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
            const decoded = JSON.parse(atob(base64));
            if ("object" != typeof decoded || null === decoded) return false;
            if ("typ" in decoded && decoded?.typ !== "JWT") return false;
            if (!decoded.alg) return false;
            if (alg && decoded.alg !== alg) return false;
            return true;
        } catch  {
            return false;
        }
    }
    function isValidCidr(ip, version) {
        if (("v4" === version || !version) && ipv4CidrRegex.test(ip)) return true;
        if (("v6" === version || !version) && ipv6CidrRegex.test(ip)) return true;
        return false;
    }
    class ZodString extends ZodType {
        _parse(input) {
            if (this._def.coerce) input.data = String(input.data);
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.string) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.string,
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
            const status = new ParseStatus();
            let ctx;
            for (const check of this._def.checks)if ("min" === check.kind) {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("max" === check.kind) {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("length" === check.kind) {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: true,
                        message: check.message
                    });
                    else if (tooSmall) addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: true,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("email" === check.kind) {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "email",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("emoji" === check.kind) {
                if (!emojiRegex) emojiRegex = new RegExp(_emojiRegex, "u");
                if (!emojiRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "emoji",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("uuid" === check.kind) {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "uuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("nanoid" === check.kind) {
                if (!nanoidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "nanoid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("cuid" === check.kind) {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("cuid2" === check.kind) {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid2",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("ulid" === check.kind) {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ulid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("url" === check.kind) try {
                new URL(input.data);
            } catch  {
                ctx = this._getOrReturnCtx(input, ctx);
                addIssueToContext(ctx, {
                    validation: "url",
                    code: ZodIssueCode.invalid_string,
                    message: check.message
                });
                status.dirty();
            }
            else if ("regex" === check.kind) {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "regex",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("trim" === check.kind) input.data = input.data.trim();
            else if ("includes" === check.kind) {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: {
                            includes: check.value,
                            position: check.position
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("toLowerCase" === check.kind) input.data = input.data.toLowerCase();
            else if ("toUpperCase" === check.kind) input.data = input.data.toUpperCase();
            else if ("startsWith" === check.kind) {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: {
                            startsWith: check.value
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("endsWith" === check.kind) {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: {
                            endsWith: check.value
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("datetime" === check.kind) {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("date" === check.kind) {
                const regex = dateRegex;
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "date",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("time" === check.kind) {
                const regex = timeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "time",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("duration" === check.kind) {
                if (!durationRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "duration",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("ip" === check.kind) {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ip",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("jwt" === check.kind) {
                if (!isValidJWT(input.data, check.alg)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "jwt",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("cidr" === check.kind) {
                if (!isValidCidr(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cidr",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("base64" === check.kind) {
                if (!base64Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "base64",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("base64url" === check.kind) {
                if (!base64urlRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "base64url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else util_util.assertNever(check);
            return {
                status: status.value,
                value: input.data
            };
        }
        _regex(regex, validation, message) {
            return this.refinement((data)=>regex.test(data), {
                validation,
                code: ZodIssueCode.invalid_string,
                ...errorUtil_errorUtil.errToObj(message)
            });
        }
        _addCheck(check) {
            return new ZodString({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    check
                ]
            });
        }
        email(message) {
            return this._addCheck({
                kind: "email",
                ...errorUtil_errorUtil.errToObj(message)
            });
        }
        url(message) {
            return this._addCheck({
                kind: "url",
                ...errorUtil_errorUtil.errToObj(message)
            });
        }
        emoji(message) {
            return this._addCheck({
                kind: "emoji",
                ...errorUtil_errorUtil.errToObj(message)
            });
        }
        uuid(message) {
            return this._addCheck({
                kind: "uuid",
                ...errorUtil_errorUtil.errToObj(message)
            });
        }
        nanoid(message) {
            return this._addCheck({
                kind: "nanoid",
                ...errorUtil_errorUtil.errToObj(message)
            });
        }
        cuid(message) {
            return this._addCheck({
                kind: "cuid",
                ...errorUtil_errorUtil.errToObj(message)
            });
        }
        cuid2(message) {
            return this._addCheck({
                kind: "cuid2",
                ...errorUtil_errorUtil.errToObj(message)
            });
        }
        ulid(message) {
            return this._addCheck({
                kind: "ulid",
                ...errorUtil_errorUtil.errToObj(message)
            });
        }
        base64(message) {
            return this._addCheck({
                kind: "base64",
                ...errorUtil_errorUtil.errToObj(message)
            });
        }
        base64url(message) {
            return this._addCheck({
                kind: "base64url",
                ...errorUtil_errorUtil.errToObj(message)
            });
        }
        jwt(options) {
            return this._addCheck({
                kind: "jwt",
                ...errorUtil_errorUtil.errToObj(options)
            });
        }
        ip(options) {
            return this._addCheck({
                kind: "ip",
                ...errorUtil_errorUtil.errToObj(options)
            });
        }
        cidr(options) {
            return this._addCheck({
                kind: "cidr",
                ...errorUtil_errorUtil.errToObj(options)
            });
        }
        datetime(options) {
            if ("string" == typeof options) return this._addCheck({
                kind: "datetime",
                precision: null,
                offset: false,
                local: false,
                message: options
            });
            return this._addCheck({
                kind: "datetime",
                precision: void 0 === options?.precision ? null : options?.precision,
                offset: options?.offset ?? false,
                local: options?.local ?? false,
                ...errorUtil_errorUtil.errToObj(options?.message)
            });
        }
        date(message) {
            return this._addCheck({
                kind: "date",
                message
            });
        }
        time(options) {
            if ("string" == typeof options) return this._addCheck({
                kind: "time",
                precision: null,
                message: options
            });
            return this._addCheck({
                kind: "time",
                precision: void 0 === options?.precision ? null : options?.precision,
                ...errorUtil_errorUtil.errToObj(options?.message)
            });
        }
        duration(message) {
            return this._addCheck({
                kind: "duration",
                ...errorUtil_errorUtil.errToObj(message)
            });
        }
        regex(regex, message) {
            return this._addCheck({
                kind: "regex",
                regex: regex,
                ...errorUtil_errorUtil.errToObj(message)
            });
        }
        includes(value, options) {
            return this._addCheck({
                kind: "includes",
                value: value,
                position: options?.position,
                ...errorUtil_errorUtil.errToObj(options?.message)
            });
        }
        startsWith(value, message) {
            return this._addCheck({
                kind: "startsWith",
                value: value,
                ...errorUtil_errorUtil.errToObj(message)
            });
        }
        endsWith(value, message) {
            return this._addCheck({
                kind: "endsWith",
                value: value,
                ...errorUtil_errorUtil.errToObj(message)
            });
        }
        min(minLength, message) {
            return this._addCheck({
                kind: "min",
                value: minLength,
                ...errorUtil_errorUtil.errToObj(message)
            });
        }
        max(maxLength, message) {
            return this._addCheck({
                kind: "max",
                value: maxLength,
                ...errorUtil_errorUtil.errToObj(message)
            });
        }
        length(len, message) {
            return this._addCheck({
                kind: "length",
                value: len,
                ...errorUtil_errorUtil.errToObj(message)
            });
        }
        nonempty(message) {
            return this.min(1, errorUtil_errorUtil.errToObj(message));
        }
        trim() {
            return new ZodString({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind: "trim"
                    }
                ]
            });
        }
        toLowerCase() {
            return new ZodString({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind: "toLowerCase"
                    }
                ]
            });
        }
        toUpperCase() {
            return new ZodString({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind: "toUpperCase"
                    }
                ]
            });
        }
        get isDatetime() {
            return !!this._def.checks.find((ch)=>"datetime" === ch.kind);
        }
        get isDate() {
            return !!this._def.checks.find((ch)=>"date" === ch.kind);
        }
        get isTime() {
            return !!this._def.checks.find((ch)=>"time" === ch.kind);
        }
        get isDuration() {
            return !!this._def.checks.find((ch)=>"duration" === ch.kind);
        }
        get isEmail() {
            return !!this._def.checks.find((ch)=>"email" === ch.kind);
        }
        get isURL() {
            return !!this._def.checks.find((ch)=>"url" === ch.kind);
        }
        get isEmoji() {
            return !!this._def.checks.find((ch)=>"emoji" === ch.kind);
        }
        get isUUID() {
            return !!this._def.checks.find((ch)=>"uuid" === ch.kind);
        }
        get isNANOID() {
            return !!this._def.checks.find((ch)=>"nanoid" === ch.kind);
        }
        get isCUID() {
            return !!this._def.checks.find((ch)=>"cuid" === ch.kind);
        }
        get isCUID2() {
            return !!this._def.checks.find((ch)=>"cuid2" === ch.kind);
        }
        get isULID() {
            return !!this._def.checks.find((ch)=>"ulid" === ch.kind);
        }
        get isIP() {
            return !!this._def.checks.find((ch)=>"ip" === ch.kind);
        }
        get isCIDR() {
            return !!this._def.checks.find((ch)=>"cidr" === ch.kind);
        }
        get isBase64() {
            return !!this._def.checks.find((ch)=>"base64" === ch.kind);
        }
        get isBase64url() {
            return !!this._def.checks.find((ch)=>"base64url" === ch.kind);
        }
        get minLength() {
            let min = null;
            for (const ch of this._def.checks)if ("min" === ch.kind) {
                if (null === min || ch.value > min) min = ch.value;
            }
            return min;
        }
        get maxLength() {
            let max = null;
            for (const ch of this._def.checks)if ("max" === ch.kind) {
                if (null === max || ch.value < max) max = ch.value;
            }
            return max;
        }
    }
    ZodString.create = (params)=>new ZodString({
            checks: [],
            typeName: types_ZodFirstPartyTypeKind.ZodString,
            coerce: params?.coerce ?? false,
            ...processCreateParams(params)
        });
    function floatSafeRemainder(val, step) {
        const valDecCount = (val.toString().split(".")[1] || "").length;
        const stepDecCount = (step.toString().split(".")[1] || "").length;
        const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
        const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
        const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
        return valInt % stepInt / 10 ** decCount;
    }
    class ZodNumber extends ZodType {
        constructor(){
            super(...arguments);
            this.min = this.gte;
            this.max = this.lte;
            this.step = this.multipleOf;
        }
        _parse(input) {
            if (this._def.coerce) input.data = Number(input.data);
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.number) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.number,
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
            let ctx;
            const status = new ParseStatus();
            for (const check of this._def.checks)if ("int" === check.kind) {
                if (!util_util.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("min" === check.kind) {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("max" === check.kind) {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("multipleOf" === check.kind) {
                if (0 !== floatSafeRemainder(input.data, check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("finite" === check.kind) {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_finite,
                        message: check.message
                    });
                    status.dirty();
                }
            } else util_util.assertNever(check);
            return {
                status: status.value,
                value: input.data
            };
        }
        gte(value, message) {
            return this.setLimit("min", value, true, errorUtil_errorUtil.toString(message));
        }
        gt(value, message) {
            return this.setLimit("min", value, false, errorUtil_errorUtil.toString(message));
        }
        lte(value, message) {
            return this.setLimit("max", value, true, errorUtil_errorUtil.toString(message));
        }
        lt(value, message) {
            return this.setLimit("max", value, false, errorUtil_errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
            return new ZodNumber({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind,
                        value,
                        inclusive,
                        message: errorUtil_errorUtil.toString(message)
                    }
                ]
            });
        }
        _addCheck(check) {
            return new ZodNumber({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    check
                ]
            });
        }
        int(message) {
            return this._addCheck({
                kind: "int",
                message: errorUtil_errorUtil.toString(message)
            });
        }
        positive(message) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: false,
                message: errorUtil_errorUtil.toString(message)
            });
        }
        negative(message) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: false,
                message: errorUtil_errorUtil.toString(message)
            });
        }
        nonpositive(message) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: true,
                message: errorUtil_errorUtil.toString(message)
            });
        }
        nonnegative(message) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: true,
                message: errorUtil_errorUtil.toString(message)
            });
        }
        multipleOf(value, message) {
            return this._addCheck({
                kind: "multipleOf",
                value: value,
                message: errorUtil_errorUtil.toString(message)
            });
        }
        finite(message) {
            return this._addCheck({
                kind: "finite",
                message: errorUtil_errorUtil.toString(message)
            });
        }
        safe(message) {
            return this._addCheck({
                kind: "min",
                inclusive: true,
                value: Number.MIN_SAFE_INTEGER,
                message: errorUtil_errorUtil.toString(message)
            })._addCheck({
                kind: "max",
                inclusive: true,
                value: Number.MAX_SAFE_INTEGER,
                message: errorUtil_errorUtil.toString(message)
            });
        }
        get minValue() {
            let min = null;
            for (const ch of this._def.checks)if ("min" === ch.kind) {
                if (null === min || ch.value > min) min = ch.value;
            }
            return min;
        }
        get maxValue() {
            let max = null;
            for (const ch of this._def.checks)if ("max" === ch.kind) {
                if (null === max || ch.value < max) max = ch.value;
            }
            return max;
        }
        get isInt() {
            return !!this._def.checks.find((ch)=>"int" === ch.kind || "multipleOf" === ch.kind && util_util.isInteger(ch.value));
        }
        get isFinite() {
            let max = null;
            let min = null;
            for (const ch of this._def.checks)if ("finite" === ch.kind || "int" === ch.kind || "multipleOf" === ch.kind) return true;
            else if ("min" === ch.kind) {
                if (null === min || ch.value > min) min = ch.value;
            } else if ("max" === ch.kind) {
                if (null === max || ch.value < max) max = ch.value;
            }
            return Number.isFinite(min) && Number.isFinite(max);
        }
    }
    ZodNumber.create = (params)=>new ZodNumber({
            checks: [],
            typeName: types_ZodFirstPartyTypeKind.ZodNumber,
            coerce: params?.coerce || false,
            ...processCreateParams(params)
        });
    class ZodBigInt extends ZodType {
        constructor(){
            super(...arguments);
            this.min = this.gte;
            this.max = this.lte;
        }
        _parse(input) {
            if (this._def.coerce) try {
                input.data = BigInt(input.data);
            } catch  {
                return this._getInvalidInput(input);
            }
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.bigint) return this._getInvalidInput(input);
            let ctx;
            const status = new ParseStatus();
            for (const check of this._def.checks)if ("min" === check.kind) {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("max" === check.kind) {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if ("multipleOf" === check.kind) {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message
                    });
                    status.dirty();
                }
            } else util_util.assertNever(check);
            return {
                status: status.value,
                value: input.data
            };
        }
        _getInvalidInput(input) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.bigint,
                received: ctx.parsedType
            });
            return parseUtil_INVALID;
        }
        gte(value, message) {
            return this.setLimit("min", value, true, errorUtil_errorUtil.toString(message));
        }
        gt(value, message) {
            return this.setLimit("min", value, false, errorUtil_errorUtil.toString(message));
        }
        lte(value, message) {
            return this.setLimit("max", value, true, errorUtil_errorUtil.toString(message));
        }
        lt(value, message) {
            return this.setLimit("max", value, false, errorUtil_errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
            return new ZodBigInt({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind,
                        value,
                        inclusive,
                        message: errorUtil_errorUtil.toString(message)
                    }
                ]
            });
        }
        _addCheck(check) {
            return new ZodBigInt({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    check
                ]
            });
        }
        positive(message) {
            return this._addCheck({
                kind: "min",
                value: BigInt(0),
                inclusive: false,
                message: errorUtil_errorUtil.toString(message)
            });
        }
        negative(message) {
            return this._addCheck({
                kind: "max",
                value: BigInt(0),
                inclusive: false,
                message: errorUtil_errorUtil.toString(message)
            });
        }
        nonpositive(message) {
            return this._addCheck({
                kind: "max",
                value: BigInt(0),
                inclusive: true,
                message: errorUtil_errorUtil.toString(message)
            });
        }
        nonnegative(message) {
            return this._addCheck({
                kind: "min",
                value: BigInt(0),
                inclusive: true,
                message: errorUtil_errorUtil.toString(message)
            });
        }
        multipleOf(value, message) {
            return this._addCheck({
                kind: "multipleOf",
                value,
                message: errorUtil_errorUtil.toString(message)
            });
        }
        get minValue() {
            let min = null;
            for (const ch of this._def.checks)if ("min" === ch.kind) {
                if (null === min || ch.value > min) min = ch.value;
            }
            return min;
        }
        get maxValue() {
            let max = null;
            for (const ch of this._def.checks)if ("max" === ch.kind) {
                if (null === max || ch.value < max) max = ch.value;
            }
            return max;
        }
    }
    ZodBigInt.create = (params)=>new ZodBigInt({
            checks: [],
            typeName: types_ZodFirstPartyTypeKind.ZodBigInt,
            coerce: params?.coerce ?? false,
            ...processCreateParams(params)
        });
    class ZodBoolean extends ZodType {
        _parse(input) {
            if (this._def.coerce) input.data = Boolean(input.data);
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.boolean) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.boolean,
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
            return OK(input.data);
        }
    }
    ZodBoolean.create = (params)=>new ZodBoolean({
            typeName: types_ZodFirstPartyTypeKind.ZodBoolean,
            coerce: params?.coerce || false,
            ...processCreateParams(params)
        });
    class ZodDate extends ZodType {
        _parse(input) {
            if (this._def.coerce) input.data = new Date(input.data);
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.date) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.date,
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
            if (Number.isNaN(input.data.getTime())) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_date
                });
                return parseUtil_INVALID;
            }
            const status = new ParseStatus();
            let ctx;
            for (const check of this._def.checks)if ("min" === check.kind) {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date"
                    });
                    status.dirty();
                }
            } else if ("max" === check.kind) {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date"
                    });
                    status.dirty();
                }
            } else util_util.assertNever(check);
            return {
                status: status.value,
                value: new Date(input.data.getTime())
            };
        }
        _addCheck(check) {
            return new ZodDate({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    check
                ]
            });
        }
        min(minDate, message) {
            return this._addCheck({
                kind: "min",
                value: minDate.getTime(),
                message: errorUtil_errorUtil.toString(message)
            });
        }
        max(maxDate, message) {
            return this._addCheck({
                kind: "max",
                value: maxDate.getTime(),
                message: errorUtil_errorUtil.toString(message)
            });
        }
        get minDate() {
            let min = null;
            for (const ch of this._def.checks)if ("min" === ch.kind) {
                if (null === min || ch.value > min) min = ch.value;
            }
            return null != min ? new Date(min) : null;
        }
        get maxDate() {
            let max = null;
            for (const ch of this._def.checks)if ("max" === ch.kind) {
                if (null === max || ch.value < max) max = ch.value;
            }
            return null != max ? new Date(max) : null;
        }
    }
    ZodDate.create = (params)=>new ZodDate({
            checks: [],
            coerce: params?.coerce || false,
            typeName: types_ZodFirstPartyTypeKind.ZodDate,
            ...processCreateParams(params)
        });
    class ZodSymbol extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.symbol) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.symbol,
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
            return OK(input.data);
        }
    }
    ZodSymbol.create = (params)=>new ZodSymbol({
            typeName: types_ZodFirstPartyTypeKind.ZodSymbol,
            ...processCreateParams(params)
        });
    class ZodUndefined extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.undefined) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.undefined,
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
            return OK(input.data);
        }
    }
    ZodUndefined.create = (params)=>new ZodUndefined({
            typeName: types_ZodFirstPartyTypeKind.ZodUndefined,
            ...processCreateParams(params)
        });
    class ZodNull extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType["null"]) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType["null"],
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
            return OK(input.data);
        }
    }
    ZodNull.create = (params)=>new ZodNull({
            typeName: types_ZodFirstPartyTypeKind.ZodNull,
            ...processCreateParams(params)
        });
    class ZodAny extends ZodType {
        constructor(){
            super(...arguments);
            this._any = true;
        }
        _parse(input) {
            return OK(input.data);
        }
    }
    ZodAny.create = (params)=>new ZodAny({
            typeName: types_ZodFirstPartyTypeKind.ZodAny,
            ...processCreateParams(params)
        });
    class ZodUnknown extends ZodType {
        constructor(){
            super(...arguments);
            this._unknown = true;
        }
        _parse(input) {
            return OK(input.data);
        }
    }
    ZodUnknown.create = (params)=>new ZodUnknown({
            typeName: types_ZodFirstPartyTypeKind.ZodUnknown,
            ...processCreateParams(params)
        });
    class ZodNever extends ZodType {
        _parse(input) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.never,
                received: ctx.parsedType
            });
            return parseUtil_INVALID;
        }
    }
    ZodNever.create = (params)=>new ZodNever({
            typeName: types_ZodFirstPartyTypeKind.ZodNever,
            ...processCreateParams(params)
        });
    class ZodVoid extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.undefined) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType["void"],
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
            return OK(input.data);
        }
    }
    ZodVoid.create = (params)=>new ZodVoid({
            typeName: types_ZodFirstPartyTypeKind.ZodVoid,
            ...processCreateParams(params)
        });
    class ZodArray extends ZodType {
        _parse(input) {
            const { ctx, status } = this._processInputParams(input);
            const def = this._def;
            if (ctx.parsedType !== ZodParsedType.array) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.array,
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
            if (null !== def.exactLength) {
                const tooBig = ctx.data.length > def.exactLength.value;
                const tooSmall = ctx.data.length < def.exactLength.value;
                if (tooBig || tooSmall) {
                    addIssueToContext(ctx, {
                        code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                        minimum: tooSmall ? def.exactLength.value : void 0,
                        maximum: tooBig ? def.exactLength.value : void 0,
                        type: "array",
                        inclusive: true,
                        exact: true,
                        message: def.exactLength.message
                    });
                    status.dirty();
                }
            }
            if (null !== def.minLength) {
                if (ctx.data.length < def.minLength.value) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: def.minLength.value,
                        type: "array",
                        inclusive: true,
                        exact: false,
                        message: def.minLength.message
                    });
                    status.dirty();
                }
            }
            if (null !== def.maxLength) {
                if (ctx.data.length > def.maxLength.value) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: def.maxLength.value,
                        type: "array",
                        inclusive: true,
                        exact: false,
                        message: def.maxLength.message
                    });
                    status.dirty();
                }
            }
            if (ctx.common.async) return Promise.all([
                ...ctx.data
            ].map((item, i)=>def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i)))).then((result)=>ParseStatus.mergeArray(status, result));
            const result = [
                ...ctx.data
            ].map((item, i)=>def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i)));
            return ParseStatus.mergeArray(status, result);
        }
        get element() {
            return this._def.type;
        }
        min(minLength, message) {
            return new ZodArray({
                ...this._def,
                minLength: {
                    value: minLength,
                    message: errorUtil_errorUtil.toString(message)
                }
            });
        }
        max(maxLength, message) {
            return new ZodArray({
                ...this._def,
                maxLength: {
                    value: maxLength,
                    message: errorUtil_errorUtil.toString(message)
                }
            });
        }
        length(len, message) {
            return new ZodArray({
                ...this._def,
                exactLength: {
                    value: len,
                    message: errorUtil_errorUtil.toString(message)
                }
            });
        }
        nonempty(message) {
            return this.min(1, message);
        }
    }
    ZodArray.create = (schema, params)=>new ZodArray({
            type: schema,
            minLength: null,
            maxLength: null,
            exactLength: null,
            typeName: types_ZodFirstPartyTypeKind.ZodArray,
            ...processCreateParams(params)
        });
    function deepPartialify(schema) {
        if (schema instanceof ZodObject) {
            const newShape = {};
            for(const key in schema.shape){
                const fieldSchema = schema.shape[key];
                newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
            }
            return new ZodObject({
                ...schema._def,
                shape: ()=>newShape
            });
        }
        if (schema instanceof ZodArray) return new ZodArray({
            ...schema._def,
            type: deepPartialify(schema.element)
        });
        if (schema instanceof ZodOptional) return ZodOptional.create(deepPartialify(schema.unwrap()));
        if (schema instanceof ZodNullable) return ZodNullable.create(deepPartialify(schema.unwrap()));
        if (schema instanceof ZodTuple) return ZodTuple.create(schema.items.map((item)=>deepPartialify(item)));
        else return schema;
    }
    class ZodObject extends ZodType {
        constructor(){
            super(...arguments);
            this._cached = null;
            this.nonstrict = this.passthrough;
            this.augment = this.extend;
        }
        _getCached() {
            if (null !== this._cached) return this._cached;
            const shape = this._def.shape();
            const keys = util_util.objectKeys(shape);
            this._cached = {
                shape,
                keys
            };
            return this._cached;
        }
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.object) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.object,
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
            const { status, ctx } = this._processInputParams(input);
            const { shape, keys: shapeKeys } = this._getCached();
            const extraKeys = [];
            if (!(this._def.catchall instanceof ZodNever && "strip" === this._def.unknownKeys)) {
                for(const key in ctx.data)if (!shapeKeys.includes(key)) extraKeys.push(key);
            }
            const pairs = [];
            for (const key of shapeKeys){
                const keyValidator = shape[key];
                const value = ctx.data[key];
                pairs.push({
                    key: {
                        status: "valid",
                        value: key
                    },
                    value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                    alwaysSet: key in ctx.data
                });
            }
            if (this._def.catchall instanceof ZodNever) {
                const unknownKeys = this._def.unknownKeys;
                if ("passthrough" === unknownKeys) for (const key of extraKeys)pairs.push({
                    key: {
                        status: "valid",
                        value: key
                    },
                    value: {
                        status: "valid",
                        value: ctx.data[key]
                    }
                });
                else if ("strict" === unknownKeys) {
                    if (extraKeys.length > 0) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.unrecognized_keys,
                            keys: extraKeys
                        });
                        status.dirty();
                    }
                } else if ("strip" === unknownKeys) ;
                else throw new Error("Internal ZodObject error: invalid unknownKeys value.");
            } else {
                const catchall = this._def.catchall;
                for (const key of extraKeys){
                    const value = ctx.data[key];
                    pairs.push({
                        key: {
                            status: "valid",
                            value: key
                        },
                        value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                        alwaysSet: key in ctx.data
                    });
                }
            }
            if (ctx.common.async) return Promise.resolve().then(async ()=>{
                const syncPairs = [];
                for (const pair of pairs){
                    const key = await pair.key;
                    const value = await pair.value;
                    syncPairs.push({
                        key,
                        value,
                        alwaysSet: pair.alwaysSet
                    });
                }
                return syncPairs;
            }).then((syncPairs)=>ParseStatus.mergeObjectSync(status, syncPairs));
            return ParseStatus.mergeObjectSync(status, pairs);
        }
        get shape() {
            return this._def.shape();
        }
        strict(message) {
            errorUtil_errorUtil.errToObj;
            return new ZodObject({
                ...this._def,
                unknownKeys: "strict",
                ...void 0 !== message ? {
                    errorMap: (issue, ctx)=>{
                        const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
                        if ("unrecognized_keys" === issue.code) return {
                            message: errorUtil_errorUtil.errToObj(message).message ?? defaultError
                        };
                        return {
                            message: defaultError
                        };
                    }
                } : {}
            });
        }
        strip() {
            return new ZodObject({
                ...this._def,
                unknownKeys: "strip"
            });
        }
        passthrough() {
            return new ZodObject({
                ...this._def,
                unknownKeys: "passthrough"
            });
        }
        extend(augmentation) {
            return new ZodObject({
                ...this._def,
                shape: ()=>({
                        ...this._def.shape(),
                        ...augmentation
                    })
            });
        }
        merge(merging) {
            const merged = new ZodObject({
                unknownKeys: merging._def.unknownKeys,
                catchall: merging._def.catchall,
                shape: ()=>({
                        ...this._def.shape(),
                        ...merging._def.shape()
                    }),
                typeName: types_ZodFirstPartyTypeKind.ZodObject
            });
            return merged;
        }
        setKey(key, schema) {
            return this.augment({
                [key]: schema
            });
        }
        catchall(index) {
            return new ZodObject({
                ...this._def,
                catchall: index
            });
        }
        pick(mask) {
            const shape = {};
            for (const key of util_util.objectKeys(mask))if (mask[key] && this.shape[key]) shape[key] = this.shape[key];
            return new ZodObject({
                ...this._def,
                shape: ()=>shape
            });
        }
        omit(mask) {
            const shape = {};
            for (const key of util_util.objectKeys(this.shape))if (!mask[key]) shape[key] = this.shape[key];
            return new ZodObject({
                ...this._def,
                shape: ()=>shape
            });
        }
        deepPartial() {
            return deepPartialify(this);
        }
        partial(mask) {
            const newShape = {};
            for (const key of util_util.objectKeys(this.shape)){
                const fieldSchema = this.shape[key];
                if (mask && !mask[key]) newShape[key] = fieldSchema;
                else newShape[key] = fieldSchema.optional();
            }
            return new ZodObject({
                ...this._def,
                shape: ()=>newShape
            });
        }
        required(mask) {
            const newShape = {};
            for (const key of util_util.objectKeys(this.shape))if (mask && !mask[key]) newShape[key] = this.shape[key];
            else {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while(newField instanceof ZodOptional)newField = newField._def.innerType;
                newShape[key] = newField;
            }
            return new ZodObject({
                ...this._def,
                shape: ()=>newShape
            });
        }
        keyof() {
            return createZodEnum(util_util.objectKeys(this.shape));
        }
    }
    ZodObject.create = (shape, params)=>new ZodObject({
            shape: ()=>shape,
            unknownKeys: "strip",
            catchall: ZodNever.create(),
            typeName: types_ZodFirstPartyTypeKind.ZodObject,
            ...processCreateParams(params)
        });
    ZodObject.strictCreate = (shape, params)=>new ZodObject({
            shape: ()=>shape,
            unknownKeys: "strict",
            catchall: ZodNever.create(),
            typeName: types_ZodFirstPartyTypeKind.ZodObject,
            ...processCreateParams(params)
        });
    ZodObject.lazycreate = (shape, params)=>new ZodObject({
            shape,
            unknownKeys: "strip",
            catchall: ZodNever.create(),
            typeName: types_ZodFirstPartyTypeKind.ZodObject,
            ...processCreateParams(params)
        });
    class ZodUnion extends ZodType {
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            const options = this._def.options;
            function handleResults(results) {
                for (const result of results)if ("valid" === result.result.status) return result.result;
                for (const result of results)if ("dirty" === result.result.status) {
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
                const unionErrors = results.map((result)=>new ZodError(result.ctx.common.issues));
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_union,
                    unionErrors
                });
                return parseUtil_INVALID;
            }
            if (ctx.common.async) return Promise.all(options.map(async (option)=>{
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: []
                    },
                    parent: null
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx
                    }),
                    ctx: childCtx
                };
            })).then(handleResults);
            {
                let dirty;
                const issues = [];
                for (const option of options){
                    const childCtx = {
                        ...ctx,
                        common: {
                            ...ctx.common,
                            issues: []
                        },
                        parent: null
                    };
                    const result = option._parseSync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx
                    });
                    if ("valid" === result.status) return result;
                    if ("dirty" === result.status && !dirty) dirty = {
                        result,
                        ctx: childCtx
                    };
                    if (childCtx.common.issues.length) issues.push(childCtx.common.issues);
                }
                if (dirty) {
                    ctx.common.issues.push(...dirty.ctx.common.issues);
                    return dirty.result;
                }
                const unionErrors = issues.map((issues)=>new ZodError(issues));
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_union,
                    unionErrors
                });
                return parseUtil_INVALID;
            }
        }
        get options() {
            return this._def.options;
        }
    }
    ZodUnion.create = (types, params)=>new ZodUnion({
            options: types,
            typeName: types_ZodFirstPartyTypeKind.ZodUnion,
            ...processCreateParams(params)
        });
    const getDiscriminator = (type)=>{
        if (type instanceof ZodLazy) return getDiscriminator(type.schema);
        if (type instanceof ZodEffects) return getDiscriminator(type.innerType());
        if (type instanceof ZodLiteral) return [
            type.value
        ];
        if (type instanceof ZodEnum) return type.options;
        if (type instanceof ZodNativeEnum) return util_util.objectValues(type.enum);
        else if (type instanceof ZodDefault) return getDiscriminator(type._def.innerType);
        else if (type instanceof ZodUndefined) return [
            void 0
        ];
        else if (type instanceof ZodNull) return [
            null
        ];
        else if (type instanceof ZodOptional) return [
            void 0,
            ...getDiscriminator(type.unwrap())
        ];
        else if (type instanceof ZodNullable) return [
            null,
            ...getDiscriminator(type.unwrap())
        ];
        else if (type instanceof ZodBranded) return getDiscriminator(type.unwrap());
        else if (type instanceof ZodReadonly) return getDiscriminator(type.unwrap());
        else if (type instanceof ZodCatch) return getDiscriminator(type._def.innerType);
        else return [];
    };
    class ZodDiscriminatedUnion extends ZodType {
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.object) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.object,
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
            const discriminator = this.discriminator;
            const discriminatorValue = ctx.data[discriminator];
            const option = this.optionsMap.get(discriminatorValue);
            if (!option) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_union_discriminator,
                    options: Array.from(this.optionsMap.keys()),
                    path: [
                        discriminator
                    ]
                });
                return parseUtil_INVALID;
            }
            if (ctx.common.async) return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            });
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            });
        }
        get discriminator() {
            return this._def.discriminator;
        }
        get options() {
            return this._def.options;
        }
        get optionsMap() {
            return this._def.optionsMap;
        }
        static create(discriminator, options, params) {
            const optionsMap = new Map();
            for (const type of options){
                const discriminatorValues = getDiscriminator(type.shape[discriminator]);
                if (!discriminatorValues.length) throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
                for (const value of discriminatorValues){
                    if (optionsMap.has(value)) throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                    optionsMap.set(value, type);
                }
            }
            return new ZodDiscriminatedUnion({
                typeName: types_ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
                discriminator,
                options,
                optionsMap,
                ...processCreateParams(params)
            });
        }
    }
    function mergeValues(a, b) {
        const aType = getParsedType(a);
        const bType = getParsedType(b);
        if (a === b) return {
            valid: true,
            data: a
        };
        if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
            const bKeys = util_util.objectKeys(b);
            const sharedKeys = util_util.objectKeys(a).filter((key)=>-1 !== bKeys.indexOf(key));
            const newObj = {
                ...a,
                ...b
            };
            for (const key of sharedKeys){
                const sharedValue = mergeValues(a[key], b[key]);
                if (!sharedValue.valid) return {
                    valid: false
                };
                newObj[key] = sharedValue.data;
            }
            return {
                valid: true,
                data: newObj
            };
        }
        if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
            if (a.length !== b.length) return {
                valid: false
            };
            const newArray = [];
            for(let index = 0; index < a.length; index++){
                const itemA = a[index];
                const itemB = b[index];
                const sharedValue = mergeValues(itemA, itemB);
                if (!sharedValue.valid) return {
                    valid: false
                };
                newArray.push(sharedValue.data);
            }
            return {
                valid: true,
                data: newArray
            };
        }
        if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) return {
            valid: true,
            data: a
        };
        return {
            valid: false
        };
    }
    class ZodIntersection extends ZodType {
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            const handleParsed = (parsedLeft, parsedRight)=>{
                if (isAborted(parsedLeft) || isAborted(parsedRight)) return parseUtil_INVALID;
                const merged = mergeValues(parsedLeft.value, parsedRight.value);
                if (!merged.valid) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_intersection_types
                    });
                    return parseUtil_INVALID;
                }
                if (isDirty(parsedLeft) || isDirty(parsedRight)) status.dirty();
                return {
                    status: status.value,
                    value: merged.data
                };
            };
            if (ctx.common.async) return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                })
            ]).then(([left, right])=>handleParsed(left, right));
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            }));
        }
    }
    ZodIntersection.create = (left, right, params)=>new ZodIntersection({
            left: left,
            right: right,
            typeName: types_ZodFirstPartyTypeKind.ZodIntersection,
            ...processCreateParams(params)
        });
    class ZodTuple extends ZodType {
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.array) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.array,
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
            if (ctx.data.length < this._def.items.length) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: this._def.items.length,
                    inclusive: true,
                    exact: false,
                    type: "array"
                });
                return parseUtil_INVALID;
            }
            const rest = this._def.rest;
            if (!rest && ctx.data.length > this._def.items.length) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: this._def.items.length,
                    inclusive: true,
                    exact: false,
                    type: "array"
                });
                status.dirty();
            }
            const items = [
                ...ctx.data
            ].map((item, itemIndex)=>{
                const schema = this._def.items[itemIndex] || this._def.rest;
                if (!schema) return null;
                return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
            }).filter((x)=>!!x);
            if (ctx.common.async) return Promise.all(items).then((results)=>ParseStatus.mergeArray(status, results));
            return ParseStatus.mergeArray(status, items);
        }
        get items() {
            return this._def.items;
        }
        rest(rest) {
            return new ZodTuple({
                ...this._def,
                rest
            });
        }
    }
    ZodTuple.create = (schemas, params)=>{
        if (!Array.isArray(schemas)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
        return new ZodTuple({
            items: schemas,
            typeName: types_ZodFirstPartyTypeKind.ZodTuple,
            rest: null,
            ...processCreateParams(params)
        });
    };
    class ZodRecord extends ZodType {
        get keySchema() {
            return this._def.keyType;
        }
        get valueSchema() {
            return this._def.valueType;
        }
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.object) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.object,
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
            const pairs = [];
            const keyType = this._def.keyType;
            const valueType = this._def.valueType;
            for(const key in ctx.data)pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
                alwaysSet: key in ctx.data
            });
            if (ctx.common.async) return ParseStatus.mergeObjectAsync(status, pairs);
            return ParseStatus.mergeObjectSync(status, pairs);
        }
        get element() {
            return this._def.valueType;
        }
        static create(first, second, third) {
            if (second instanceof ZodType) return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: types_ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third)
            });
            return new ZodRecord({
                keyType: ZodString.create(),
                valueType: first,
                typeName: types_ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(second)
            });
        }
    }
    class ZodMap extends ZodType {
        get keySchema() {
            return this._def.keyType;
        }
        get valueSchema() {
            return this._def.valueType;
        }
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.map) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.map,
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
            const keyType = this._def.keyType;
            const valueType = this._def.valueType;
            const pairs = [
                ...ctx.data.entries()
            ].map(([key, value], index)=>({
                    key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [
                        index,
                        "key"
                    ])),
                    value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [
                        index,
                        "value"
                    ]))
                }));
            if (ctx.common.async) {
                const finalMap = new Map();
                return Promise.resolve().then(async ()=>{
                    for (const pair of pairs){
                        const key = await pair.key;
                        const value = await pair.value;
                        if ("aborted" === key.status || "aborted" === value.status) return parseUtil_INVALID;
                        if ("dirty" === key.status || "dirty" === value.status) status.dirty();
                        finalMap.set(key.value, value.value);
                    }
                    return {
                        status: status.value,
                        value: finalMap
                    };
                });
            }
            {
                const finalMap = new Map();
                for (const pair of pairs){
                    const key = pair.key;
                    const value = pair.value;
                    if ("aborted" === key.status || "aborted" === value.status) return parseUtil_INVALID;
                    if ("dirty" === key.status || "dirty" === value.status) status.dirty();
                    finalMap.set(key.value, value.value);
                }
                return {
                    status: status.value,
                    value: finalMap
                };
            }
        }
    }
    ZodMap.create = (keyType, valueType, params)=>new ZodMap({
            valueType,
            keyType,
            typeName: types_ZodFirstPartyTypeKind.ZodMap,
            ...processCreateParams(params)
        });
    class ZodSet extends ZodType {
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.set) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.set,
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
            const def = this._def;
            if (null !== def.minSize) {
                if (ctx.data.size < def.minSize.value) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: def.minSize.value,
                        type: "set",
                        inclusive: true,
                        exact: false,
                        message: def.minSize.message
                    });
                    status.dirty();
                }
            }
            if (null !== def.maxSize) {
                if (ctx.data.size > def.maxSize.value) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: def.maxSize.value,
                        type: "set",
                        inclusive: true,
                        exact: false,
                        message: def.maxSize.message
                    });
                    status.dirty();
                }
            }
            const valueType = this._def.valueType;
            function finalizeSet(elements) {
                const parsedSet = new Set();
                for (const element of elements){
                    if ("aborted" === element.status) return parseUtil_INVALID;
                    if ("dirty" === element.status) status.dirty();
                    parsedSet.add(element.value);
                }
                return {
                    status: status.value,
                    value: parsedSet
                };
            }
            const elements = [
                ...ctx.data.values()
            ].map((item, i)=>valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
            if (ctx.common.async) return Promise.all(elements).then((elements)=>finalizeSet(elements));
            return finalizeSet(elements);
        }
        min(minSize, message) {
            return new ZodSet({
                ...this._def,
                minSize: {
                    value: minSize,
                    message: errorUtil_errorUtil.toString(message)
                }
            });
        }
        max(maxSize, message) {
            return new ZodSet({
                ...this._def,
                maxSize: {
                    value: maxSize,
                    message: errorUtil_errorUtil.toString(message)
                }
            });
        }
        size(size, message) {
            return this.min(size, message).max(size, message);
        }
        nonempty(message) {
            return this.min(1, message);
        }
    }
    ZodSet.create = (valueType, params)=>new ZodSet({
            valueType,
            minSize: null,
            maxSize: null,
            typeName: types_ZodFirstPartyTypeKind.ZodSet,
            ...processCreateParams(params)
        });
    class ZodFunction extends ZodType {
        constructor(){
            super(...arguments);
            this.validate = this.implement;
        }
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType["function"]) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType["function"],
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
            function makeArgsIssue(args, error) {
                return makeIssue({
                    data: args,
                    path: ctx.path,
                    errorMaps: [
                        ctx.common.contextualErrorMap,
                        ctx.schemaErrorMap,
                        getErrorMap(),
                        en
                    ].filter((x)=>!!x),
                    issueData: {
                        code: ZodIssueCode.invalid_arguments,
                        argumentsError: error
                    }
                });
            }
            function makeReturnsIssue(returns, error) {
                return makeIssue({
                    data: returns,
                    path: ctx.path,
                    errorMaps: [
                        ctx.common.contextualErrorMap,
                        ctx.schemaErrorMap,
                        getErrorMap(),
                        en
                    ].filter((x)=>!!x),
                    issueData: {
                        code: ZodIssueCode.invalid_return_type,
                        returnTypeError: error
                    }
                });
            }
            const params = {
                errorMap: ctx.common.contextualErrorMap
            };
            const fn = ctx.data;
            if (this._def.returns instanceof ZodPromise) {
                const me = this;
                return OK(async function(...args) {
                    const error = new ZodError([]);
                    const parsedArgs = await me._def.args.parseAsync(args, params).catch((e)=>{
                        error.addIssue(makeArgsIssue(args, e));
                        throw error;
                    });
                    const result = await Reflect.apply(fn, this, parsedArgs);
                    const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e)=>{
                        error.addIssue(makeReturnsIssue(result, e));
                        throw error;
                    });
                    return parsedReturns;
                });
            }
            {
                const me = this;
                return OK(function(...args) {
                    const parsedArgs = me._def.args.safeParse(args, params);
                    if (!parsedArgs.success) throw new ZodError([
                        makeArgsIssue(args, parsedArgs.error)
                    ]);
                    const result = Reflect.apply(fn, this, parsedArgs.data);
                    const parsedReturns = me._def.returns.safeParse(result, params);
                    if (!parsedReturns.success) throw new ZodError([
                        makeReturnsIssue(result, parsedReturns.error)
                    ]);
                    return parsedReturns.data;
                });
            }
        }
        parameters() {
            return this._def.args;
        }
        returnType() {
            return this._def.returns;
        }
        args(...items) {
            return new ZodFunction({
                ...this._def,
                args: ZodTuple.create(items).rest(ZodUnknown.create())
            });
        }
        returns(returnType) {
            return new ZodFunction({
                ...this._def,
                returns: returnType
            });
        }
        implement(func) {
            const validatedFunc = this.parse(func);
            return validatedFunc;
        }
        strictImplement(func) {
            const validatedFunc = this.parse(func);
            return validatedFunc;
        }
        static create(args, returns, params) {
            return new ZodFunction({
                args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
                returns: returns || ZodUnknown.create(),
                typeName: types_ZodFirstPartyTypeKind.ZodFunction,
                ...processCreateParams(params)
            });
        }
    }
    class ZodLazy extends ZodType {
        get schema() {
            return this._def.getter();
        }
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            const lazySchema = this._def.getter();
            return lazySchema._parse({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            });
        }
    }
    ZodLazy.create = (getter, params)=>new ZodLazy({
            getter: getter,
            typeName: types_ZodFirstPartyTypeKind.ZodLazy,
            ...processCreateParams(params)
        });
    class ZodLiteral extends ZodType {
        _parse(input) {
            if (input.data !== this._def.value) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    received: ctx.data,
                    code: ZodIssueCode.invalid_literal,
                    expected: this._def.value
                });
                return parseUtil_INVALID;
            }
            return {
                status: "valid",
                value: input.data
            };
        }
        get value() {
            return this._def.value;
        }
    }
    ZodLiteral.create = (value, params)=>new ZodLiteral({
            value: value,
            typeName: types_ZodFirstPartyTypeKind.ZodLiteral,
            ...processCreateParams(params)
        });
    function createZodEnum(values, params) {
        return new ZodEnum({
            values,
            typeName: types_ZodFirstPartyTypeKind.ZodEnum,
            ...processCreateParams(params)
        });
    }
    class ZodEnum extends ZodType {
        _parse(input) {
            if ("string" != typeof input.data) {
                const ctx = this._getOrReturnCtx(input);
                const expectedValues = this._def.values;
                addIssueToContext(ctx, {
                    expected: util_util.joinValues(expectedValues),
                    received: ctx.parsedType,
                    code: ZodIssueCode.invalid_type
                });
                return parseUtil_INVALID;
            }
            if (!this._cache) this._cache = new Set(this._def.values);
            if (!this._cache.has(input.data)) {
                const ctx = this._getOrReturnCtx(input);
                const expectedValues = this._def.values;
                addIssueToContext(ctx, {
                    received: ctx.data,
                    code: ZodIssueCode.invalid_enum_value,
                    options: expectedValues
                });
                return parseUtil_INVALID;
            }
            return OK(input.data);
        }
        get options() {
            return this._def.values;
        }
        get enum() {
            const enumValues = {};
            for (const val of this._def.values)enumValues[val] = val;
            return enumValues;
        }
        get Values() {
            const enumValues = {};
            for (const val of this._def.values)enumValues[val] = val;
            return enumValues;
        }
        get Enum() {
            const enumValues = {};
            for (const val of this._def.values)enumValues[val] = val;
            return enumValues;
        }
        extract(values, newDef = this._def) {
            return ZodEnum.create(values, {
                ...this._def,
                ...newDef
            });
        }
        exclude(values, newDef = this._def) {
            return ZodEnum.create(this.options.filter((opt)=>!values.includes(opt)), {
                ...this._def,
                ...newDef
            });
        }
    }
    ZodEnum.create = createZodEnum;
    class ZodNativeEnum extends ZodType {
        _parse(input) {
            const nativeEnumValues = util_util.getValidEnumValues(this._def.values);
            const ctx = this._getOrReturnCtx(input);
            if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
                const expectedValues = util_util.objectValues(nativeEnumValues);
                addIssueToContext(ctx, {
                    expected: util_util.joinValues(expectedValues),
                    received: ctx.parsedType,
                    code: ZodIssueCode.invalid_type
                });
                return parseUtil_INVALID;
            }
            if (!this._cache) this._cache = new Set(util_util.getValidEnumValues(this._def.values));
            if (!this._cache.has(input.data)) {
                const expectedValues = util_util.objectValues(nativeEnumValues);
                addIssueToContext(ctx, {
                    received: ctx.data,
                    code: ZodIssueCode.invalid_enum_value,
                    options: expectedValues
                });
                return parseUtil_INVALID;
            }
            return OK(input.data);
        }
        get enum() {
            return this._def.values;
        }
    }
    ZodNativeEnum.create = (values, params)=>new ZodNativeEnum({
            values: values,
            typeName: types_ZodFirstPartyTypeKind.ZodNativeEnum,
            ...processCreateParams(params)
        });
    class ZodPromise extends ZodType {
        unwrap() {
            return this._def.type;
        }
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.promise && false === ctx.common.async) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.promise,
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
            const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
            return OK(promisified.then((data)=>this._def.type.parseAsync(data, {
                    path: ctx.path,
                    errorMap: ctx.common.contextualErrorMap
                })));
        }
    }
    ZodPromise.create = (schema, params)=>new ZodPromise({
            type: schema,
            typeName: types_ZodFirstPartyTypeKind.ZodPromise,
            ...processCreateParams(params)
        });
    class ZodEffects extends ZodType {
        innerType() {
            return this._def.schema;
        }
        sourceType() {
            return this._def.schema._def.typeName === types_ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
        }
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            const effect = this._def.effect || null;
            const checkCtx = {
                addIssue: (arg)=>{
                    addIssueToContext(ctx, arg);
                    if (arg.fatal) status.abort();
                    else status.dirty();
                },
                get path () {
                    return ctx.path;
                }
            };
            checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
            if ("preprocess" === effect.type) {
                const processed = effect.transform(ctx.data, checkCtx);
                if (ctx.common.async) return Promise.resolve(processed).then(async (processed)=>{
                    if ("aborted" === status.value) return parseUtil_INVALID;
                    const result = await this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx
                    });
                    if ("aborted" === result.status) return parseUtil_INVALID;
                    if ("dirty" === result.status) return DIRTY(result.value);
                    if ("dirty" === status.value) return DIRTY(result.value);
                    return result;
                });
                {
                    if ("aborted" === status.value) return parseUtil_INVALID;
                    const result = this._def.schema._parseSync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx
                    });
                    if ("aborted" === result.status) return parseUtil_INVALID;
                    if ("dirty" === result.status) return DIRTY(result.value);
                    if ("dirty" === status.value) return DIRTY(result.value);
                    return result;
                }
            }
            if ("refinement" === effect.type) {
                const executeRefinement = (acc)=>{
                    const result = effect.refinement(acc, checkCtx);
                    if (ctx.common.async) return Promise.resolve(result);
                    if (result instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                    return acc;
                };
                if (false !== ctx.common.async) return this._def.schema._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }).then((inner)=>{
                    if ("aborted" === inner.status) return parseUtil_INVALID;
                    if ("dirty" === inner.status) status.dirty();
                    return executeRefinement(inner.value).then(()=>({
                            status: status.value,
                            value: inner.value
                        }));
                });
                {
                    const inner = this._def.schema._parseSync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    });
                    if ("aborted" === inner.status) return parseUtil_INVALID;
                    if ("dirty" === inner.status) status.dirty();
                    executeRefinement(inner.value);
                    return {
                        status: status.value,
                        value: inner.value
                    };
                }
            }
            if ("transform" === effect.type) if (false !== ctx.common.async) return this._def.schema._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            }).then((base)=>{
                if (!isValid(base)) return parseUtil_INVALID;
                return Promise.resolve(effect.transform(base.value, checkCtx)).then((result)=>({
                        status: status.value,
                        value: result
                    }));
            });
            else {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if (!isValid(base)) return parseUtil_INVALID;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                return {
                    status: status.value,
                    value: result
                };
            }
            util_util.assertNever(effect);
        }
    }
    ZodEffects.create = (schema, effect, params)=>new ZodEffects({
            schema,
            typeName: types_ZodFirstPartyTypeKind.ZodEffects,
            effect,
            ...processCreateParams(params)
        });
    ZodEffects.createWithPreprocess = (preprocess, schema, params)=>new ZodEffects({
            schema,
            effect: {
                type: "preprocess",
                transform: preprocess
            },
            typeName: types_ZodFirstPartyTypeKind.ZodEffects,
            ...processCreateParams(params)
        });
    class ZodOptional extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType === ZodParsedType.undefined) return OK(void 0);
            return this._def.innerType._parse(input);
        }
        unwrap() {
            return this._def.innerType;
        }
    }
    ZodOptional.create = (type, params)=>new ZodOptional({
            innerType: type,
            typeName: types_ZodFirstPartyTypeKind.ZodOptional,
            ...processCreateParams(params)
        });
    class ZodNullable extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType === ZodParsedType["null"]) return OK(null);
            return this._def.innerType._parse(input);
        }
        unwrap() {
            return this._def.innerType;
        }
    }
    ZodNullable.create = (type, params)=>new ZodNullable({
            innerType: type,
            typeName: types_ZodFirstPartyTypeKind.ZodNullable,
            ...processCreateParams(params)
        });
    class ZodDefault extends ZodType {
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            let data = ctx.data;
            if (ctx.parsedType === ZodParsedType.undefined) data = this._def.defaultValue();
            return this._def.innerType._parse({
                data,
                path: ctx.path,
                parent: ctx
            });
        }
        removeDefault() {
            return this._def.innerType;
        }
    }
    ZodDefault.create = (type, params)=>new ZodDefault({
            innerType: type,
            typeName: types_ZodFirstPartyTypeKind.ZodDefault,
            defaultValue: "function" == typeof params.default ? params.default : ()=>params.default,
            ...processCreateParams(params)
        });
    class ZodCatch extends ZodType {
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            const newCtx = {
                ...ctx,
                common: {
                    ...ctx.common,
                    issues: []
                }
            };
            const result = this._def.innerType._parse({
                data: newCtx.data,
                path: newCtx.path,
                parent: {
                    ...newCtx
                }
            });
            if (isAsync(result)) return result.then((result)=>({
                    status: "valid",
                    value: "valid" === result.status ? result.value : this._def.catchValue({
                        get error () {
                            return new ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data
                    })
                }));
            return {
                status: "valid",
                value: "valid" === result.status ? result.value : this._def.catchValue({
                    get error () {
                        return new ZodError(newCtx.common.issues);
                    },
                    input: newCtx.data
                })
            };
        }
        removeCatch() {
            return this._def.innerType;
        }
    }
    ZodCatch.create = (type, params)=>new ZodCatch({
            innerType: type,
            typeName: types_ZodFirstPartyTypeKind.ZodCatch,
            catchValue: "function" == typeof params.catch ? params.catch : ()=>params.catch,
            ...processCreateParams(params)
        });
    class ZodNaN extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.nan) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.nan,
                    received: ctx.parsedType
                });
                return parseUtil_INVALID;
            }
            return {
                status: "valid",
                value: input.data
            };
        }
    }
    ZodNaN.create = (params)=>new ZodNaN({
            typeName: types_ZodFirstPartyTypeKind.ZodNaN,
            ...processCreateParams(params)
        });
    Symbol("zod_brand");
    class ZodBranded extends ZodType {
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            const data = ctx.data;
            return this._def.type._parse({
                data,
                path: ctx.path,
                parent: ctx
            });
        }
        unwrap() {
            return this._def.type;
        }
    }
    class ZodPipeline extends ZodType {
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            if (ctx.common.async) {
                const handleAsync = async ()=>{
                    const inResult = await this._def.in._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx
                    });
                    if ("aborted" === inResult.status) return parseUtil_INVALID;
                    if ("dirty" !== inResult.status) return this._def.out._parseAsync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx
                    });
                    status.dirty();
                    return DIRTY(inResult.value);
                };
                return handleAsync();
            }
            {
                const inResult = this._def.in._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if ("aborted" === inResult.status) return parseUtil_INVALID;
                if ("dirty" !== inResult.status) return this._def.out._parseSync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx
                });
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value
                };
            }
        }
        static create(a, b) {
            return new ZodPipeline({
                in: a,
                out: b,
                typeName: types_ZodFirstPartyTypeKind.ZodPipeline
            });
        }
    }
    class ZodReadonly extends ZodType {
        _parse(input) {
            const result = this._def.innerType._parse(input);
            const freeze = (data)=>{
                if (isValid(data)) data.value = Object.freeze(data.value);
                return data;
            };
            return isAsync(result) ? result.then((data)=>freeze(data)) : freeze(result);
        }
        unwrap() {
            return this._def.innerType;
        }
    }
    ZodReadonly.create = (type, params)=>new ZodReadonly({
            innerType: type,
            typeName: types_ZodFirstPartyTypeKind.ZodReadonly,
            ...processCreateParams(params)
        });
    ZodObject.lazycreate;
    var types_ZodFirstPartyTypeKind;
    (function(ZodFirstPartyTypeKind) {
        ZodFirstPartyTypeKind["ZodString"] = "ZodString";
        ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
        ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
        ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
        ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
        ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
        ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
        ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
        ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
        ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
        ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
        ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
        ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
        ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
        ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
        ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
        ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
        ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
        ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
        ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
        ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
        ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
        ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
        ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
        ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
        ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
        ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
        ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
        ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
        ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
        ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
        ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
        ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
        ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
        ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
        ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
    })(types_ZodFirstPartyTypeKind || (types_ZodFirstPartyTypeKind = {}));
    ZodString.create;
    ZodNumber.create;
    ZodNaN.create;
    ZodBigInt.create;
    ZodBoolean.create;
    ZodDate.create;
    ZodSymbol.create;
    ZodUndefined.create;
    ZodNull.create;
    ZodAny.create;
    ZodUnknown.create;
    ZodNever.create;
    ZodVoid.create;
    ZodArray.create;
    ZodObject.create;
    ZodObject.strictCreate;
    ZodUnion.create;
    ZodDiscriminatedUnion.create;
    ZodIntersection.create;
    ZodTuple.create;
    ZodRecord.create;
    ZodMap.create;
    ZodSet.create;
    ZodFunction.create;
    ZodLazy.create;
    ZodLiteral.create;
    ZodEnum.create;
    ZodNativeEnum.create;
    ZodPromise.create;
    ZodEffects.create;
    ZodOptional.create;
    ZodNullable.create;
    ZodEffects.createWithPreprocess;
    ZodPipeline.create;
    class ConfigBuilder {
        static buildAppConfig(cliArgs, userConfig) {
            const { workspace, config: configPath, debug, quiet, port, stream, provider, apiKey, baseURL, browserControl, shareProvider, ...cliConfigProps } = cliArgs;
            this.handleDeprecatedOptions(cliConfigProps, {
                provider,
                apiKey,
                baseURL,
                browserControl,
                shareProvider
            });
            this.resolveModelSecrets(cliConfigProps);
            const config = (0, core_namespaceObject.deepMerge)(userConfig, cliConfigProps);
            this.handleWorkspaceOptions(config, workspace);
            this.applyLoggingShortcuts(config, {
                debug,
                quiet
            });
            this.applyServerConfiguration(config, {
                port
            });
            return config;
        }
        static handleWorkspaceOptions(config, workspace) {
            const workspaceConfig = {};
            if ('string' == typeof workspace) workspaceConfig.workingDirectory = workspace;
            else if ('object' == typeof workspace) Object.assign(workspaceConfig, workspace);
            if (!config.workspace) config.workspace = {};
            Object.assign(config.workspace, workspaceConfig);
        }
        static handleDeprecatedOptions(config, deprecated) {
            const { provider, apiKey, baseURL, browserControl, shareProvider } = deprecated;
            if (provider || apiKey || baseURL) {
                if (config.model) {
                    if ('string' == typeof config.model) config.model = {
                        id: config.model
                    };
                } else config.model = {};
                if (provider) {
                    if (!config.model.provider) config.model.provider = provider;
                }
                if (apiKey) {
                    if (!config.model.apiKey) config.model.apiKey = apiKey;
                }
                if (baseURL) {
                    if (!config.model.baseURL) config.model.baseURL = baseURL;
                }
            }
            if (browserControl) {
                if (!config.browser) config.browser = {};
                if (!config.browser.control) config.browser.control = browserControl;
            }
            if (shareProvider) {
                if (!config.share) config.share = {};
                if (!config.share.provider) config.share.provider = shareProvider;
            }
        }
        static applyLoggingShortcuts(config, shortcuts) {
            if (config.logLevel) config.logLevel = this.parseLogLevel(config.logLevel);
            if (shortcuts.quiet) config.logLevel = types_LogLevel.SILENT;
            if (shortcuts.debug) config.logLevel = types_LogLevel.DEBUG;
        }
        static parseLogLevel(level) {
            const upperLevel = level.toUpperCase();
            if ('DEBUG' === upperLevel) return types_LogLevel.DEBUG;
            if ('INFO' === upperLevel) return types_LogLevel.INFO;
            if ('WARN' === upperLevel || 'WARNING' === upperLevel) return types_LogLevel.WARN;
            if ('ERROR' === upperLevel) return types_LogLevel.ERROR;
            console.warn(`Unknown log level: ${level}, using default log level`);
        }
        static applyServerConfiguration(config, serverOptions) {
            if (!config.server) config.server = {
                port: 8888
            };
            if (!config.server.storage || !config.server.storage.type) config.server.storage = {
                type: 'sqlite'
            };
            if (serverOptions.port) config.server.port = serverOptions.port;
        }
        static resolveModelSecrets(cliConfigProps) {
            if (cliConfigProps.model) {
                if (cliConfigProps.model.apiKey) cliConfigProps.model.apiKey = resolveValue(cliConfigProps.model.apiKey, 'API key');
                if (cliConfigProps.model.baseURL) cliConfigProps.model.baseURL = resolveValue(cliConfigProps.model.baseURL, 'base URL');
            }
        }
    }
    const globalBootstrapCliOptions = {};
    function setBootstrapCliOptions(options) {
        Object.assign(globalBootstrapCliOptions, options);
    }
    function getBootstrapCliOptions() {
        return globalBootstrapCliOptions;
    }
    var external_node_util_ = __webpack_require__("node:util");
    var src = __webpack_require__("../node_modules/.pnpm/sisteransi@1.0.5/node_modules/sisteransi/src/index.js");
    const external_node_readline_namespaceObject = require("node:readline");
    const external_node_stream_namespaceObject = require("node:stream");
    var picocolors = __webpack_require__("../node_modules/.pnpm/picocolors@1.1.1/node_modules/picocolors/picocolors.js");
    function DD({ onlyFirst: e = !1 } = {}) {
        const t = "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))";
        return new RegExp(t, e ? void 0 : "g");
    }
    const uD = DD();
    function P(e) {
        if ("string" != typeof e) throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
        return e.replace(uD, "");
    }
    function L(e) {
        return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
    }
    var W = {
        exports: {}
    };
    (function(e) {
        var u = {};
        e.exports = u, u.eastAsianWidth = function(F) {
            var s = F.charCodeAt(0), i = 2 == F.length ? F.charCodeAt(1) : 0, D = s;
            return 55296 <= s && s <= 56319 && 56320 <= i && i <= 57343 && (s &= 1023, i &= 1023, D = s << 10 | i, D += 65536), 12288 == D || 65281 <= D && D <= 65376 || 65504 <= D && D <= 65510 ? "F" : 8361 == D || 65377 <= D && D <= 65470 || 65474 <= D && D <= 65479 || 65482 <= D && D <= 65487 || 65490 <= D && D <= 65495 || 65498 <= D && D <= 65500 || 65512 <= D && D <= 65518 ? "H" : 4352 <= D && D <= 4447 || 4515 <= D && D <= 4519 || 4602 <= D && D <= 4607 || 9001 <= D && D <= 9002 || 11904 <= D && D <= 11929 || 11931 <= D && D <= 12019 || 12032 <= D && D <= 12245 || 12272 <= D && D <= 12283 || 12289 <= D && D <= 12350 || 12353 <= D && D <= 12438 || 12441 <= D && D <= 12543 || 12549 <= D && D <= 12589 || 12593 <= D && D <= 12686 || 12688 <= D && D <= 12730 || 12736 <= D && D <= 12771 || 12784 <= D && D <= 12830 || 12832 <= D && D <= 12871 || 12880 <= D && D <= 13054 || 13056 <= D && D <= 19903 || 19968 <= D && D <= 42124 || 42128 <= D && D <= 42182 || 43360 <= D && D <= 43388 || 44032 <= D && D <= 55203 || 55216 <= D && D <= 55238 || 55243 <= D && D <= 55291 || 63744 <= D && D <= 64255 || 65040 <= D && D <= 65049 || 65072 <= D && D <= 65106 || 65108 <= D && D <= 65126 || 65128 <= D && D <= 65131 || 110592 <= D && D <= 110593 || 127488 <= D && D <= 127490 || 127504 <= D && D <= 127546 || 127552 <= D && D <= 127560 || 127568 <= D && D <= 127569 || 131072 <= D && D <= 194367 || 177984 <= D && D <= 196605 || 196608 <= D && D <= 262141 ? "W" : 32 <= D && D <= 126 || 162 <= D && D <= 163 || 165 <= D && D <= 166 || 172 == D || 175 == D || 10214 <= D && D <= 10221 || 10629 <= D && D <= 10630 ? "Na" : 161 == D || 164 == D || 167 <= D && D <= 168 || 170 == D || 173 <= D && D <= 174 || 176 <= D && D <= 180 || 182 <= D && D <= 186 || 188 <= D && D <= 191 || 198 == D || 208 == D || 215 <= D && D <= 216 || 222 <= D && D <= 225 || 230 == D || 232 <= D && D <= 234 || 236 <= D && D <= 237 || 240 == D || 242 <= D && D <= 243 || 247 <= D && D <= 250 || 252 == D || 254 == D || 257 == D || 273 == D || 275 == D || 283 == D || 294 <= D && D <= 295 || 299 == D || 305 <= D && D <= 307 || 312 == D || 319 <= D && D <= 322 || 324 == D || 328 <= D && D <= 331 || 333 == D || 338 <= D && D <= 339 || 358 <= D && D <= 359 || 363 == D || 462 == D || 464 == D || 466 == D || 468 == D || 470 == D || 472 == D || 474 == D || 476 == D || 593 == D || 609 == D || 708 == D || 711 == D || 713 <= D && D <= 715 || 717 == D || 720 == D || 728 <= D && D <= 731 || 733 == D || 735 == D || 768 <= D && D <= 879 || 913 <= D && D <= 929 || 931 <= D && D <= 937 || 945 <= D && D <= 961 || 963 <= D && D <= 969 || 1025 == D || 1040 <= D && D <= 1103 || 1105 == D || 8208 == D || 8211 <= D && D <= 8214 || 8216 <= D && D <= 8217 || 8220 <= D && D <= 8221 || 8224 <= D && D <= 8226 || 8228 <= D && D <= 8231 || 8240 == D || 8242 <= D && D <= 8243 || 8245 == D || 8251 == D || 8254 == D || 8308 == D || 8319 == D || 8321 <= D && D <= 8324 || 8364 == D || 8451 == D || 8453 == D || 8457 == D || 8467 == D || 8470 == D || 8481 <= D && D <= 8482 || 8486 == D || 8491 == D || 8531 <= D && D <= 8532 || 8539 <= D && D <= 8542 || 8544 <= D && D <= 8555 || 8560 <= D && D <= 8569 || 8585 == D || 8592 <= D && D <= 8601 || 8632 <= D && D <= 8633 || 8658 == D || 8660 == D || 8679 == D || 8704 == D || 8706 <= D && D <= 8707 || 8711 <= D && D <= 8712 || 8715 == D || 8719 == D || 8721 == D || 8725 == D || 8730 == D || 8733 <= D && D <= 8736 || 8739 == D || 8741 == D || 8743 <= D && D <= 8748 || 8750 == D || 8756 <= D && D <= 8759 || 8764 <= D && D <= 8765 || 8776 == D || 8780 == D || 8786 == D || 8800 <= D && D <= 8801 || 8804 <= D && D <= 8807 || 8810 <= D && D <= 8811 || 8814 <= D && D <= 8815 || 8834 <= D && D <= 8835 || 8838 <= D && D <= 8839 || 8853 == D || 8857 == D || 8869 == D || 8895 == D || 8978 == D || 9312 <= D && D <= 9449 || 9451 <= D && D <= 9547 || 9552 <= D && D <= 9587 || 9600 <= D && D <= 9615 || 9618 <= D && D <= 9621 || 9632 <= D && D <= 9633 || 9635 <= D && D <= 9641 || 9650 <= D && D <= 9651 || 9654 <= D && D <= 9655 || 9660 <= D && D <= 9661 || 9664 <= D && D <= 9665 || 9670 <= D && D <= 9672 || 9675 == D || 9678 <= D && D <= 9681 || 9698 <= D && D <= 9701 || 9711 == D || 9733 <= D && D <= 9734 || 9737 == D || 9742 <= D && D <= 9743 || 9748 <= D && D <= 9749 || 9756 == D || 9758 == D || 9792 == D || 9794 == D || 9824 <= D && D <= 9825 || 9827 <= D && D <= 9829 || 9831 <= D && D <= 9834 || 9836 <= D && D <= 9837 || 9839 == D || 9886 <= D && D <= 9887 || 9918 <= D && D <= 9919 || 9924 <= D && D <= 9933 || 9935 <= D && D <= 9953 || 9955 == D || 9960 <= D && D <= 9983 || 10045 == D || 10071 == D || 10102 <= D && D <= 10111 || 11093 <= D && D <= 11097 || 12872 <= D && D <= 12879 || 57344 <= D && D <= 63743 || 65024 <= D && D <= 65039 || 65533 == D || 127232 <= D && D <= 127242 || 127248 <= D && D <= 127277 || 127280 <= D && D <= 127337 || 127344 <= D && D <= 127386 || 917760 <= D && D <= 917999 || 983040 <= D && D <= 1048573 || 1048576 <= D && D <= 1114109 ? "A" : "N";
        }, u.characterLength = function(F) {
            var s = this.eastAsianWidth(F);
            return "F" == s || "W" == s || "A" == s ? 2 : 1;
        };
        function t(F) {
            return F.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
        }
        u.length = function(F) {
            for(var s = t(F), i = 0, D = 0; D < s.length; D++)i += this.characterLength(s[D]);
            return i;
        }, u.slice = function(F, s, i) {
            textLen = u.length(F), s = s || 0, i = i || 1, s < 0 && (s = textLen + s), i < 0 && (i = textLen + i);
            for(var D = "", C = 0, n = t(F), E = 0; E < n.length; E++){
                var a = n[E], o = u.length(a);
                if (C >= s - (2 == o ? 1 : 0)) if (C + o <= i) D += a;
                else break;
                C += o;
            }
            return D;
        };
    })(W);
    var tD = W.exports;
    const eD = L(tD);
    var FD = function() {
        return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };
    const sD = L(FD);
    function dist_p(e, u = {}) {
        if ("string" != typeof e || 0 === e.length || (u = {
            ambiguousIsNarrow: !0,
            ...u
        }, e = P(e), 0 === e.length)) return 0;
        e = e.replace(sD(), "  ");
        const t = u.ambiguousIsNarrow ? 1 : 2;
        let F = 0;
        for (const s of e){
            const i = s.codePointAt(0);
            if (!(i <= 31) && (!(i >= 127) || !(i <= 159)) && (!(i >= 768) || !(i <= 879))) switch(eD.eastAsianWidth(s)){
                case "F":
                case "W":
                    F += 2;
                    break;
                case "A":
                    F += t;
                    break;
                default:
                    F += 1;
            }
        }
        return F;
    }
    const dist_w = 10, dist_N = (e = 0)=>(u)=>`\x1B[${u + e}m`, dist_I = (e = 0)=>(u)=>`\x1B[${38 + e};5;${u}m`, dist_R = (e = 0)=>(u, t, F)=>`\x1B[${38 + e};2;${u};${t};${F}m`, dist_r = {
        modifier: {
            reset: [
                0,
                0
            ],
            bold: [
                1,
                22
            ],
            dim: [
                2,
                22
            ],
            italic: [
                3,
                23
            ],
            underline: [
                4,
                24
            ],
            overline: [
                53,
                55
            ],
            inverse: [
                7,
                27
            ],
            hidden: [
                8,
                28
            ],
            strikethrough: [
                9,
                29
            ]
        },
        color: {
            black: [
                30,
                39
            ],
            red: [
                31,
                39
            ],
            green: [
                32,
                39
            ],
            yellow: [
                33,
                39
            ],
            blue: [
                34,
                39
            ],
            magenta: [
                35,
                39
            ],
            cyan: [
                36,
                39
            ],
            white: [
                37,
                39
            ],
            blackBright: [
                90,
                39
            ],
            gray: [
                90,
                39
            ],
            grey: [
                90,
                39
            ],
            redBright: [
                91,
                39
            ],
            greenBright: [
                92,
                39
            ],
            yellowBright: [
                93,
                39
            ],
            blueBright: [
                94,
                39
            ],
            magentaBright: [
                95,
                39
            ],
            cyanBright: [
                96,
                39
            ],
            whiteBright: [
                97,
                39
            ]
        },
        bgColor: {
            bgBlack: [
                40,
                49
            ],
            bgRed: [
                41,
                49
            ],
            bgGreen: [
                42,
                49
            ],
            bgYellow: [
                43,
                49
            ],
            bgBlue: [
                44,
                49
            ],
            bgMagenta: [
                45,
                49
            ],
            bgCyan: [
                46,
                49
            ],
            bgWhite: [
                47,
                49
            ],
            bgBlackBright: [
                100,
                49
            ],
            bgGray: [
                100,
                49
            ],
            bgGrey: [
                100,
                49
            ],
            bgRedBright: [
                101,
                49
            ],
            bgGreenBright: [
                102,
                49
            ],
            bgYellowBright: [
                103,
                49
            ],
            bgBlueBright: [
                104,
                49
            ],
            bgMagentaBright: [
                105,
                49
            ],
            bgCyanBright: [
                106,
                49
            ],
            bgWhiteBright: [
                107,
                49
            ]
        }
    };
    Object.keys(dist_r.modifier);
    const iD = Object.keys(dist_r.color), CD = Object.keys(dist_r.bgColor);
    [
        ...iD,
        ...CD
    ];
    function rD() {
        const e = new Map;
        for (const [u, t] of Object.entries(dist_r)){
            for (const [F, s] of Object.entries(t))dist_r[F] = {
                open: `\x1B[${s[0]}m`,
                close: `\x1B[${s[1]}m`
            }, t[F] = dist_r[F], e.set(s[0], s[1]);
            Object.defineProperty(dist_r, u, {
                value: t,
                enumerable: !1
            });
        }
        return Object.defineProperty(dist_r, "codes", {
            value: e,
            enumerable: !1
        }), dist_r.color.close = "\x1B[39m", dist_r.bgColor.close = "\x1B[49m", dist_r.color.ansi = dist_N(), dist_r.color.ansi256 = dist_I(), dist_r.color.ansi16m = dist_R(), dist_r.bgColor.ansi = dist_N(dist_w), dist_r.bgColor.ansi256 = dist_I(dist_w), dist_r.bgColor.ansi16m = dist_R(dist_w), Object.defineProperties(dist_r, {
            rgbToAnsi256: {
                value: (u, t, F)=>u === t && t === F ? u < 8 ? 16 : u > 248 ? 231 : Math.round((u - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(u / 255 * 5) + 6 * Math.round(t / 255 * 5) + Math.round(F / 255 * 5),
                enumerable: !1
            },
            hexToRgb: {
                value: (u)=>{
                    const t = /[a-f\d]{6}|[a-f\d]{3}/i.exec(u.toString(16));
                    if (!t) return [
                        0,
                        0,
                        0
                    ];
                    let [F] = t;
                    3 === F.length && (F = [
                        ...F
                    ].map((i)=>i + i).join(""));
                    const s = Number.parseInt(F, 16);
                    return [
                        s >> 16 & 255,
                        s >> 8 & 255,
                        255 & s
                    ];
                },
                enumerable: !1
            },
            hexToAnsi256: {
                value: (u)=>dist_r.rgbToAnsi256(...dist_r.hexToRgb(u)),
                enumerable: !1
            },
            ansi256ToAnsi: {
                value: (u)=>{
                    if (u < 8) return 30 + u;
                    if (u < 16) return 90 + (u - 8);
                    let t, F, s;
                    if (u >= 232) t = ((u - 232) * 10 + 8) / 255, F = t, s = t;
                    else {
                        u -= 16;
                        const C = u % 36;
                        t = Math.floor(u / 36) / 5, F = Math.floor(C / 6) / 5, s = C % 6 / 5;
                    }
                    const i = 2 * Math.max(t, F, s);
                    if (0 === i) return 30;
                    let D = 30 + (Math.round(s) << 2 | Math.round(F) << 1 | Math.round(t));
                    return 2 === i && (D += 60), D;
                },
                enumerable: !1
            },
            rgbToAnsi: {
                value: (u, t, F)=>dist_r.ansi256ToAnsi(dist_r.rgbToAnsi256(u, t, F)),
                enumerable: !1
            },
            hexToAnsi: {
                value: (u)=>dist_r.ansi256ToAnsi(dist_r.hexToAnsi256(u)),
                enumerable: !1
            }
        }), dist_r;
    }
    const ED = rD(), d = new Set([
        "\x1B",
        "\x9B"
    ]), oD = 39, y = "\x07", V = "[", nD = "]", G = "m", dist_ = `${nD}8;;`, dist_z = (e)=>`${d.values().next().value}${V}${e}${G}`, K = (e)=>`${d.values().next().value}${dist_}${e}${y}`, aD = (e)=>e.split(" ").map((u)=>dist_p(u)), dist_k = (e, u, t)=>{
        const F = [
            ...u
        ];
        let s = !1, i = !1, D = dist_p(P(e[e.length - 1]));
        for (const [C, n] of F.entries()){
            const E = dist_p(n);
            if (D + E <= t ? e[e.length - 1] += n : (e.push(n), D = 0), d.has(n) && (s = !0, i = F.slice(C + 1).join("").startsWith(dist_)), s) {
                i ? n === y && (s = !1, i = !1) : n === G && (s = !1);
                continue;
            }
            D += E, D === t && C < F.length - 1 && (e.push(""), D = 0);
        }
        !D && e[e.length - 1].length > 0 && e.length > 1 && (e[e.length - 2] += e.pop());
    }, hD = (e)=>{
        const u = e.split(" ");
        let t = u.length;
        for(; t > 0 && !(dist_p(u[t - 1]) > 0);)t--;
        return t === u.length ? e : u.slice(0, t).join(" ") + u.slice(t).join("");
    }, lD = (e, u, t = {})=>{
        if (!1 !== t.trim && "" === e.trim()) return "";
        let F = "", s, i;
        const D = aD(e);
        let C = [
            ""
        ];
        for (const [E, a] of e.split(" ").entries()){
            !1 !== t.trim && (C[C.length - 1] = C[C.length - 1].trimStart());
            let o = dist_p(C[C.length - 1]);
            if (0 !== E && (o >= u && (!1 === t.wordWrap || !1 === t.trim) && (C.push(""), o = 0), (o > 0 || !1 === t.trim) && (C[C.length - 1] += " ", o++)), t.hard && D[E] > u) {
                const c = u - o, f = 1 + Math.floor((D[E] - c - 1) / u);
                Math.floor((D[E] - 1) / u) < f && C.push(""), dist_k(C, a, u);
                continue;
            }
            if (o + D[E] > u && o > 0 && D[E] > 0) {
                if (!1 === t.wordWrap && o < u) {
                    dist_k(C, a, u);
                    continue;
                }
                C.push("");
            }
            if (o + D[E] > u && !1 === t.wordWrap) {
                dist_k(C, a, u);
                continue;
            }
            C[C.length - 1] += a;
        }
        !1 !== t.trim && (C = C.map((E)=>hD(E)));
        const n = [
            ...C.join(`
`)
        ];
        for (const [E, a] of n.entries()){
            if (F += a, d.has(a)) {
                const { groups: c } = new RegExp(`(?:\\${V}(?<code>\\d+)m|\\${dist_}(?<uri>.*)${y})`).exec(n.slice(E).join("")) || {
                    groups: {}
                };
                if (void 0 !== c.code) {
                    const f = Number.parseFloat(c.code);
                    s = f === oD ? void 0 : f;
                } else void 0 !== c.uri && (i = 0 === c.uri.length ? void 0 : c.uri);
            }
            const o = ED.codes.get(Number(s));
            n[E + 1] === `
` ? (i && (F += K("")), s && o && (F += dist_z(o))) : a === `
` && (s && o && (F += dist_z(s)), i && (F += K(i)));
        }
        return F;
    };
    function Y(e, u, t) {
        return String(e).normalize().replace(/\r\n/g, `
`).split(`
`).map((F)=>lD(F, u, t)).join(`
`);
    }
    const xD = [
        "up",
        "down",
        "left",
        "right",
        "space",
        "enter",
        "cancel"
    ], dist_B = {
        actions: new Set(xD),
        aliases: new Map([
            [
                "k",
                "up"
            ],
            [
                "j",
                "down"
            ],
            [
                "h",
                "left"
            ],
            [
                "l",
                "right"
            ],
            [
                "",
                "cancel"
            ],
            [
                "escape",
                "cancel"
            ]
        ])
    };
    function dist_$(e, u) {
        if ("string" == typeof e) return dist_B.aliases.get(e) === u;
        for (const t of e)if (void 0 !== t && dist_$(t, u)) return !0;
        return !1;
    }
    function BD(e, u) {
        if (e === u) return;
        const t = e.split(`
`), F = u.split(`
`), s = [];
        for(let i = 0; i < Math.max(t.length, F.length); i++)t[i] !== F[i] && s.push(i);
        return s;
    }
    const AD = globalThis.process.platform.startsWith("win"), dist_S = Symbol("clack:cancel");
    function pD(e) {
        return e === dist_S;
    }
    function dist_m(e, u) {
        const t = e;
        t.isTTY && t.setRawMode(u);
    }
    function fD({ input: e = external_node_process_.stdin, output: u = external_node_process_.stdout, overwrite: t = !0, hideCursor: F = !0 } = {}) {
        const s = external_node_readline_namespaceObject.createInterface({
            input: e,
            output: u,
            prompt: "",
            tabSize: 1
        });
        external_node_readline_namespaceObject.emitKeypressEvents(e, s), e.isTTY && e.setRawMode(!0);
        const i = (D, { name: C, sequence: n })=>{
            const E = String(D);
            if (dist_$([
                E,
                C,
                n
            ], "cancel")) {
                F && u.write(src.cursor.show), process.exit(0);
                return;
            }
            if (!t) return;
            const a = "return" === C ? 0 : -1, o = "return" === C ? -1 : 0;
            external_node_readline_namespaceObject.moveCursor(u, a, o, ()=>{
                external_node_readline_namespaceObject.clearLine(u, 1, ()=>{
                    e.once("keypress", i);
                });
            });
        };
        return F && u.write(src.cursor.hide), e.once("keypress", i), ()=>{
            e.off("keypress", i), F && u.write(src.cursor.show), e.isTTY && !AD && e.setRawMode(!1), s.terminal = !1, s.close();
        };
    }
    var gD = Object.defineProperty, vD = (e, u, t)=>u in e ? gD(e, u, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: t
        }) : e[u] = t, dist_h = (e, u, t)=>(vD(e, "symbol" != typeof u ? u + "" : u, t), t);
    class dist_x {
        constructor(u, t = !0){
            dist_h(this, "input"), dist_h(this, "output"), dist_h(this, "_abortSignal"), dist_h(this, "rl"), dist_h(this, "opts"), dist_h(this, "_render"), dist_h(this, "_track", !1), dist_h(this, "_prevFrame", ""), dist_h(this, "_subscribers", new Map), dist_h(this, "_cursor", 0), dist_h(this, "state", "initial"), dist_h(this, "error", ""), dist_h(this, "value");
            const { input: F = external_node_process_.stdin, output: s = external_node_process_.stdout, render: i, signal: D, ...C } = u;
            this.opts = C, this.onKeypress = this.onKeypress.bind(this), this.close = this.close.bind(this), this.render = this.render.bind(this), this._render = i.bind(this), this._track = t, this._abortSignal = D, this.input = F, this.output = s;
        }
        unsubscribe() {
            this._subscribers.clear();
        }
        setSubscriber(u, t) {
            const F = this._subscribers.get(u) ?? [];
            F.push(t), this._subscribers.set(u, F);
        }
        on(u, t) {
            this.setSubscriber(u, {
                cb: t
            });
        }
        once(u, t) {
            this.setSubscriber(u, {
                cb: t,
                once: !0
            });
        }
        emit(u, ...t) {
            const F = this._subscribers.get(u) ?? [], s = [];
            for (const i of F)i.cb(...t), i.once && s.push(()=>F.splice(F.indexOf(i), 1));
            for (const i of s)i();
        }
        prompt() {
            return new Promise((u, t)=>{
                if (this._abortSignal) {
                    if (this._abortSignal.aborted) return this.state = "cancel", this.close(), u(dist_S);
                    this._abortSignal.addEventListener("abort", ()=>{
                        this.state = "cancel", this.close();
                    }, {
                        once: !0
                    });
                }
                const F = new external_node_stream_namespaceObject.Writable;
                F._write = (s, i, D)=>{
                    this._track && (this.value = this.rl?.line.replace(/\t/g, ""), this._cursor = this.rl?.cursor ?? 0, this.emit("value", this.value)), D();
                }, this.input.pipe(F), this.rl = external_node_readline_namespaceObject.createInterface({
                    input: this.input,
                    output: F,
                    tabSize: 2,
                    prompt: "",
                    escapeCodeTimeout: 50,
                    terminal: !0
                }), external_node_readline_namespaceObject.emitKeypressEvents(this.input, this.rl), this.rl.prompt(), void 0 !== this.opts.initialValue && this._track && this.rl.write(this.opts.initialValue), this.input.on("keypress", this.onKeypress), dist_m(this.input, !0), this.output.on("resize", this.render), this.render(), this.once("submit", ()=>{
                    this.output.write(src.cursor.show), this.output.off("resize", this.render), dist_m(this.input, !1), u(this.value);
                }), this.once("cancel", ()=>{
                    this.output.write(src.cursor.show), this.output.off("resize", this.render), dist_m(this.input, !1), u(dist_S);
                });
            });
        }
        onKeypress(u, t) {
            if ("error" === this.state && (this.state = "active"), t?.name && (!this._track && dist_B.aliases.has(t.name) && this.emit("cursor", dist_B.aliases.get(t.name)), dist_B.actions.has(t.name) && this.emit("cursor", t.name)), u && ("y" === u.toLowerCase() || "n" === u.toLowerCase()) && this.emit("confirm", "y" === u.toLowerCase()), "	" === u && this.opts.placeholder && (this.value || (this.rl?.write(this.opts.placeholder), this.emit("value", this.opts.placeholder))), u && this.emit("key", u.toLowerCase()), t?.name === "return") {
                if (this.opts.validate) {
                    const F = this.opts.validate(this.value);
                    F && (this.error = F instanceof Error ? F.message : F, this.state = "error", this.rl?.write(this.value));
                }
                "error" !== this.state && (this.state = "submit");
            }
            dist_$([
                u,
                t?.name,
                t?.sequence
            ], "cancel") && (this.state = "cancel"), ("submit" === this.state || "cancel" === this.state) && this.emit("finalize"), this.render(), ("submit" === this.state || "cancel" === this.state) && this.close();
        }
        close() {
            this.input.unpipe(), this.input.removeListener("keypress", this.onKeypress), this.output.write(`
`), dist_m(this.input, !1), this.rl?.close(), this.rl = void 0, this.emit(`${this.state}`, this.value), this.unsubscribe();
        }
        restoreCursor() {
            const u = Y(this._prevFrame, process.stdout.columns, {
                hard: !0
            }).split(`
`).length - 1;
            this.output.write(src.cursor.move(-999, -1 * u));
        }
        render() {
            const u = Y(this._render(this) ?? "", process.stdout.columns, {
                hard: !0
            });
            if (u !== this._prevFrame) {
                if ("initial" === this.state) this.output.write(src.cursor.hide);
                else {
                    const t = BD(this._prevFrame, u);
                    if (this.restoreCursor(), t && t?.length === 1) {
                        const F = t[0];
                        this.output.write(src.cursor.move(0, F)), this.output.write(src.erase.lines(1));
                        const s = u.split(`
`);
                        this.output.write(s[F]), this._prevFrame = u, this.output.write(src.cursor.move(0, s.length - F - 1));
                        return;
                    }
                    if (t && t?.length > 1) {
                        const F = t[0];
                        this.output.write(src.cursor.move(0, F)), this.output.write(src.erase.down());
                        const s = u.split(`
`).slice(F);
                        this.output.write(s.join(`
`)), this._prevFrame = u;
                        return;
                    }
                    this.output.write(src.erase.down());
                }
                this.output.write(u), "initial" === this.state && (this.state = "active"), this._prevFrame = u;
            }
        }
    }
    class dD extends dist_x {
        get cursor() {
            return this.value ? 0 : 1;
        }
        get _value() {
            return 0 === this.cursor;
        }
        constructor(u){
            super(u, !1), this.value = !!u.initialValue, this.on("value", ()=>{
                this.value = this._value;
            }), this.on("confirm", (t)=>{
                this.output.write(src.cursor.move(0, -1)), this.value = t, this.state = "submit", this.close();
            }), this.on("cursor", ()=>{
                this.value = !this.value;
            });
        }
    }
    new WeakMap;
    var OD = Object.defineProperty, PD = (e, u, t)=>u in e ? OD(e, u, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: t
        }) : e[u] = t, J = (e, u, t)=>(PD(e, "symbol" != typeof u ? u + "" : u, t), t);
    class LD extends dist_x {
        constructor(u){
            super(u, !1), J(this, "options"), J(this, "cursor", 0), this.options = u.options, this.cursor = this.options.findIndex(({ value: t })=>t === u.initialValue), -1 === this.cursor && (this.cursor = 0), this.changeValue(), this.on("cursor", (t)=>{
                switch(t){
                    case "left":
                    case "up":
                        this.cursor = 0 === this.cursor ? this.options.length - 1 : this.cursor - 1;
                        break;
                    case "down":
                    case "right":
                        this.cursor = this.cursor === this.options.length - 1 ? 0 : this.cursor + 1;
                        break;
                }
                this.changeValue();
            });
        }
        get _value() {
            return this.options[this.cursor];
        }
        changeValue() {
            this.value = this._value.value;
        }
    }
    function ce() {
        return "win32" !== external_node_process_.platform ? "linux" !== external_node_process_.env.TERM : !!external_node_process_.env.CI || !!external_node_process_.env.WT_SESSION || !!external_node_process_.env.TERMINUS_SUBLIME || "{cmd::Cmder}" === external_node_process_.env.ConEmuTask || "Terminus-Sublime" === external_node_process_.env.TERM_PROGRAM || "vscode" === external_node_process_.env.TERM_PROGRAM || "xterm-256color" === external_node_process_.env.TERM || "alacritty" === external_node_process_.env.TERM || "JetBrains-JediTerm" === external_node_process_.env.TERMINAL_EMULATOR;
    }
    const dist_V = ce(), dist_u = (t, n)=>dist_V ? t : n, le = dist_u("\u25C6", "*"), dist_L = dist_u("\u25A0", "x"), dist_W = dist_u("\u25B2", "x"), dist_C = dist_u("\u25C7", "o"), ue = dist_u("\u250C", "T"), dist_o = dist_u("\u2502", "|"), dist_d = dist_u("\u2514", "\u2014"), prompts_dist_k = dist_u("\u25CF", ">"), dist_P = dist_u("\u25CB", " "), dist_b = (dist_u("\u25FB", "[\u2022]"), dist_u("\u25FC", "[+]"), dist_u("\u25FB", "[ ]"), dist_u("\u25AA", "\u2022"), dist_u("\u2500", "-"), dist_u("\u256E", "+"), dist_u("\u251C", "+"), dist_u("\u256F", "+"), dist_u("\u25CF", "\u2022"), dist_u("\u25C6", "*"), dist_u("\u25B2", "!"), dist_u("\u25A0", "x"), (t)=>{
        switch(t){
            case "initial":
            case "active":
                return picocolors.cyan(le);
            case "cancel":
                return picocolors.red(dist_L);
            case "error":
                return picocolors.yellow(dist_W);
            case "submit":
                return picocolors.green(dist_C);
        }
    }), dist_G = (t)=>{
        const { cursor: n, options: r, style: i } = t, s = t.maxItems ?? Number.POSITIVE_INFINITY, c = Math.max(process.stdout.rows - 4, 0), a = Math.min(c, Math.max(s, 5));
        let l = 0;
        n >= l + a - 3 ? l = Math.max(Math.min(n - a + 3, r.length - a), 0) : n < l + 2 && (l = Math.max(n - 2, 0));
        const $ = a < r.length && l > 0, g = a < r.length && l + a < r.length;
        return r.slice(l, l + a).map((p, v, f)=>{
            const j = 0 === v && $, E = v === f.length - 1 && g;
            return j || E ? picocolors.dim("...") : i(p, v + l === n);
        });
    }, ye = (t)=>{
        const n = t.active ?? "Yes", r = t.inactive ?? "No";
        return new dD({
            active: n,
            inactive: r,
            initialValue: t.initialValue ?? !0,
            render () {
                const i = `${picocolors.gray(dist_o)}
${dist_b(this.state)}  ${t.message}
`, s = this.value ? n : r;
                switch(this.state){
                    case "submit":
                        return `${i}${picocolors.gray(dist_o)}  ${picocolors.dim(s)}`;
                    case "cancel":
                        return `${i}${picocolors.gray(dist_o)}  ${picocolors.strikethrough(picocolors.dim(s))}
${picocolors.gray(dist_o)}`;
                    default:
                        return `${i}${picocolors.cyan(dist_o)}  ${this.value ? `${picocolors.green(prompts_dist_k)} ${n}` : `${picocolors.dim(dist_P)} ${picocolors.dim(n)}`} ${picocolors.dim("/")} ${this.value ? `${picocolors.dim(dist_P)} ${picocolors.dim(r)}` : `${picocolors.green(prompts_dist_k)} ${r}`}
${picocolors.cyan(dist_d)}
`;
                }
            }
        }).prompt();
    }, ve = (t)=>{
        const n = (r, i)=>{
            const s = r.label ?? String(r.value);
            switch(i){
                case "selected":
                    return `${picocolors.dim(s)}`;
                case "active":
                    return `${picocolors.green(prompts_dist_k)} ${s} ${r.hint ? picocolors.dim(`(${r.hint})`) : ""}`;
                case "cancelled":
                    return `${picocolors.strikethrough(picocolors.dim(s))}`;
                default:
                    return `${picocolors.dim(dist_P)} ${picocolors.dim(s)}`;
            }
        };
        return new LD({
            options: t.options,
            initialValue: t.initialValue,
            render () {
                const r = `${picocolors.gray(dist_o)}
${dist_b(this.state)}  ${t.message}
`;
                switch(this.state){
                    case "submit":
                        return `${r}${picocolors.gray(dist_o)}  ${n(this.options[this.cursor], "selected")}`;
                    case "cancel":
                        return `${r}${picocolors.gray(dist_o)}  ${n(this.options[this.cursor], "cancelled")}
${picocolors.gray(dist_o)}`;
                    default:
                        return `${r}${picocolors.cyan(dist_o)}  ${dist_G({
                            cursor: this.cursor,
                            options: this.options,
                            maxItems: t.maxItems,
                            style: (i, s)=>n(i, s ? "active" : "inactive")
                        }).join(`
${picocolors.cyan(dist_o)}  `)}
${picocolors.cyan(dist_d)}
`;
                }
            }
        }).prompt();
    }, xe = (t = "")=>{
        process.stdout.write(`${picocolors.gray(dist_d)}  ${picocolors.red(t)}

`);
    }, Ie = (t = "")=>{
        process.stdout.write(`${picocolors.gray(ue)}  ${t}
`);
    }, Se = (t = "")=>{
        process.stdout.write(`${picocolors.gray(dist_o)}
${picocolors.gray(dist_d)}  ${t}

`);
    }, dist_Y = (picocolors.gray(dist_o), ({ indicator: t = "dots" } = {})=>{
        const n = dist_V ? [
            "\u25D2",
            "\u25D0",
            "\u25D3",
            "\u25D1"
        ] : [
            "\u2022",
            "o",
            "O",
            "0"
        ], r = dist_V ? 80 : 120, i = "true" === process.env.CI;
        let s, c, a = !1, l = "", $, g = performance.now();
        const p = (m)=>{
            const h = m > 1 ? "Something went wrong" : "Canceled";
            a && N(h, m);
        }, v = ()=>p(2), f = ()=>p(1), j = ()=>{
            process.on("uncaughtExceptionMonitor", v), process.on("unhandledRejection", v), process.on("SIGINT", f), process.on("SIGTERM", f), process.on("exit", p);
        }, E = ()=>{
            process.removeListener("uncaughtExceptionMonitor", v), process.removeListener("unhandledRejection", v), process.removeListener("SIGINT", f), process.removeListener("SIGTERM", f), process.removeListener("exit", p);
        }, B = ()=>{
            if (void 0 === $) return;
            i && process.stdout.write(`
`);
            const m = $.split(`
`);
            process.stdout.write(src.cursor.move(-999, m.length - 1)), process.stdout.write(src.erase.down(m.length));
        }, R = (m)=>m.replace(/\.+$/, ""), O = (m)=>{
            const h = (performance.now() - m) / 1e3, w = Math.floor(h / 60), I = Math.floor(h % 60);
            return w > 0 ? `[${w}m ${I}s]` : `[${I}s]`;
        }, H = (m = "")=>{
            a = !0, s = fD(), l = R(m), g = performance.now(), process.stdout.write(`${picocolors.gray(dist_o)}
`);
            let h = 0, w = 0;
            j(), c = setInterval(()=>{
                if (i && l === $) return;
                B(), $ = l;
                const I = picocolors.magenta(n[h]);
                if (i) process.stdout.write(`${I}  ${l}...`);
                else if ("timer" === t) process.stdout.write(`${I}  ${l} ${O(g)}`);
                else {
                    const z = ".".repeat(Math.floor(w)).slice(0, 3);
                    process.stdout.write(`${I}  ${l}${z}`);
                }
                h = h + 1 < n.length ? h + 1 : 0, w = w < n.length ? w + .125 : 0;
            }, r);
        }, N = (m = "", h = 0)=>{
            a = !1, clearInterval(c), B();
            const w = 0 === h ? picocolors.green(dist_C) : 1 === h ? picocolors.red(dist_L) : picocolors.red(dist_W);
            l = R(m ?? l), "timer" === t ? process.stdout.write(`${w}  ${l} ${O(g)}
`) : process.stdout.write(`${w}  ${l}
`), E(), s();
        };
        return {
            start: H,
            stop: N,
            message: (m = "")=>{
                l = R(m ?? l);
            }
        };
    });
    var external_node_crypto_ = __webpack_require__("node:crypto");
    var external_node_assert_ = __webpack_require__("node:assert");
    const dot_prop_isObject = (value)=>{
        const type = typeof value;
        return null !== value && ('object' === type || 'function' === type);
    };
    const disallowedKeys = new Set([
        '__proto__',
        'prototype',
        'constructor'
    ]);
    const digits = new Set('0123456789');
    function getPathSegments(path) {
        const parts = [];
        let currentSegment = '';
        let currentPart = 'start';
        let isIgnoring = false;
        for (const character of path)switch(character){
            case '\\':
                if ('index' === currentPart) throw new Error('Invalid character in an index');
                if ('indexEnd' === currentPart) throw new Error('Invalid character after an index');
                if (isIgnoring) currentSegment += character;
                currentPart = 'property';
                isIgnoring = !isIgnoring;
                break;
            case '.':
                if ('index' === currentPart) throw new Error('Invalid character in an index');
                if ('indexEnd' === currentPart) {
                    currentPart = 'property';
                    break;
                }
                if (isIgnoring) {
                    isIgnoring = false;
                    currentSegment += character;
                    break;
                }
                if (disallowedKeys.has(currentSegment)) return [];
                parts.push(currentSegment);
                currentSegment = '';
                currentPart = 'property';
                break;
            case '[':
                if ('index' === currentPart) throw new Error('Invalid character in an index');
                if ('indexEnd' === currentPart) {
                    currentPart = 'index';
                    break;
                }
                if (isIgnoring) {
                    isIgnoring = false;
                    currentSegment += character;
                    break;
                }
                if ('property' === currentPart) {
                    if (disallowedKeys.has(currentSegment)) return [];
                    parts.push(currentSegment);
                    currentSegment = '';
                }
                currentPart = 'index';
                break;
            case ']':
                if ('index' === currentPart) {
                    parts.push(Number.parseInt(currentSegment, 10));
                    currentSegment = '';
                    currentPart = 'indexEnd';
                    break;
                }
                if ('indexEnd' === currentPart) throw new Error('Invalid character after an index');
            default:
                if ('index' === currentPart && !digits.has(character)) throw new Error('Invalid character in an index');
                if ('indexEnd' === currentPart) throw new Error('Invalid character after an index');
                if ('start' === currentPart) currentPart = 'property';
                if (isIgnoring) {
                    isIgnoring = false;
                    currentSegment += '\\';
                }
                currentSegment += character;
        }
        if (isIgnoring) currentSegment += '\\';
        switch(currentPart){
            case 'property':
                if (disallowedKeys.has(currentSegment)) return [];
                parts.push(currentSegment);
                break;
            case 'index':
                throw new Error('Index was not closed');
            case 'start':
                parts.push('');
                break;
        }
        return parts;
    }
    function isStringIndex(object, key) {
        if ('number' != typeof key && Array.isArray(object)) {
            const index = Number.parseInt(key, 10);
            return Number.isInteger(index) && object[index] === object[key];
        }
        return false;
    }
    function assertNotStringIndex(object, key) {
        if (isStringIndex(object, key)) throw new Error('Cannot use string index');
    }
    function getProperty(object, path, value) {
        if (!dot_prop_isObject(object) || 'string' != typeof path) return void 0 === value ? object : value;
        const pathArray = getPathSegments(path);
        if (0 === pathArray.length) return value;
        for(let index = 0; index < pathArray.length; index++){
            const key = pathArray[index];
            object = isStringIndex(object, key) ? index === pathArray.length - 1 ? void 0 : null : object[key];
            if (null == object) {
                if (index !== pathArray.length - 1) return value;
                break;
            }
        }
        return void 0 === object ? value : object;
    }
    function setProperty(object, path, value) {
        if (!dot_prop_isObject(object) || 'string' != typeof path) return object;
        const root = object;
        const pathArray = getPathSegments(path);
        for(let index = 0; index < pathArray.length; index++){
            const key = pathArray[index];
            assertNotStringIndex(object, key);
            if (index === pathArray.length - 1) object[key] = value;
            else if (!dot_prop_isObject(object[key])) object[key] = 'number' == typeof pathArray[index + 1] ? [] : {};
            object = object[key];
        }
        return root;
    }
    function deleteProperty(object, path) {
        if (!dot_prop_isObject(object) || 'string' != typeof path) return false;
        const pathArray = getPathSegments(path);
        for(let index = 0; index < pathArray.length; index++){
            const key = pathArray[index];
            assertNotStringIndex(object, key);
            if (index === pathArray.length - 1) {
                delete object[key];
                return true;
            }
            object = object[key];
            if (!dot_prop_isObject(object)) return false;
        }
    }
    function hasProperty(object, path) {
        if (!dot_prop_isObject(object) || 'string' != typeof path) return false;
        const pathArray = getPathSegments(path);
        if (0 === pathArray.length) return false;
        for (const key of pathArray){
            if (!dot_prop_isObject(object) || !(key in object) || isStringIndex(object, key)) return false;
            object = object[key];
        }
        return true;
    }
    const env_paths_homedir = external_node_os_.homedir();
    const tmpdir = external_node_os_.tmpdir();
    const { env: env_paths_env } = external_node_process_;
    const macos = (name)=>{
        const library = external_node_path_.join(env_paths_homedir, 'Library');
        return {
            data: external_node_path_.join(library, 'Application Support', name),
            config: external_node_path_.join(library, 'Preferences', name),
            cache: external_node_path_.join(library, 'Caches', name),
            log: external_node_path_.join(library, 'Logs', name),
            temp: external_node_path_.join(tmpdir, name)
        };
    };
    const windows = (name)=>{
        const appData = env_paths_env.APPDATA || external_node_path_.join(env_paths_homedir, 'AppData', 'Roaming');
        const localAppData = env_paths_env.LOCALAPPDATA || external_node_path_.join(env_paths_homedir, 'AppData', 'Local');
        return {
            data: external_node_path_.join(localAppData, name, 'Data'),
            config: external_node_path_.join(appData, name, 'Config'),
            cache: external_node_path_.join(localAppData, name, 'Cache'),
            log: external_node_path_.join(localAppData, name, 'Log'),
            temp: external_node_path_.join(tmpdir, name)
        };
    };
    const linux = (name)=>{
        const username = external_node_path_.basename(env_paths_homedir);
        return {
            data: external_node_path_.join(env_paths_env.XDG_DATA_HOME || external_node_path_.join(env_paths_homedir, '.local', 'share'), name),
            config: external_node_path_.join(env_paths_env.XDG_CONFIG_HOME || external_node_path_.join(env_paths_homedir, '.config'), name),
            cache: external_node_path_.join(env_paths_env.XDG_CACHE_HOME || external_node_path_.join(env_paths_homedir, '.cache'), name),
            log: external_node_path_.join(env_paths_env.XDG_STATE_HOME || external_node_path_.join(env_paths_homedir, '.local', 'state'), name),
            temp: external_node_path_.join(tmpdir, username, name)
        };
    };
    function envPaths(name, { suffix = 'nodejs' } = {}) {
        if ('string' != typeof name) throw new TypeError(`Expected a string, got ${typeof name}`);
        if (suffix) name += `-${suffix}`;
        if ('darwin' === external_node_process_.platform) return macos(name);
        if ('win32' === external_node_process_.platform) return windows(name);
        return linux(name);
    }
    const attemptifyAsync = (fn, onError)=>function(...args) {
            return fn.apply(void 0, args).catch(onError);
        };
    const attemptifySync = (fn, onError)=>function(...args) {
            try {
                return fn.apply(void 0, args);
            } catch (error) {
                return onError(error);
            }
        };
    const IS_USER_ROOT = external_node_process_.getuid ? !external_node_process_.getuid() : false;
    const LIMIT_FILES_DESCRIPTORS = 10000;
    const NOOP = ()=>void 0;
    const Handlers = {
        isChangeErrorOk: (error)=>{
            if (!Handlers.isNodeError(error)) return false;
            const { code } = error;
            if ('ENOSYS' === code) return true;
            if (!IS_USER_ROOT && ('EINVAL' === code || 'EPERM' === code)) return true;
            return false;
        },
        isNodeError: (error)=>error instanceof Error,
        isRetriableError: (error)=>{
            if (!Handlers.isNodeError(error)) return false;
            const { code } = error;
            if ('EMFILE' === code || 'ENFILE' === code || 'EAGAIN' === code || 'EBUSY' === code || 'EACCESS' === code || 'EACCES' === code || 'EACCS' === code || 'EPERM' === code) return true;
            return false;
        },
        onChangeError: (error)=>{
            if (!Handlers.isNodeError(error)) throw error;
            if (Handlers.isChangeErrorOk(error)) return;
            throw error;
        }
    };
    const handlers = Handlers;
    class RetryfyQueue {
        constructor(){
            this.interval = 25;
            this.intervalId = void 0;
            this.limit = LIMIT_FILES_DESCRIPTORS;
            this.queueActive = new Set();
            this.queueWaiting = new Set();
            this.init = ()=>{
                if (this.intervalId) return;
                this.intervalId = setInterval(this.tick, this.interval);
            };
            this.reset = ()=>{
                if (!this.intervalId) return;
                clearInterval(this.intervalId);
                delete this.intervalId;
            };
            this.add = (fn)=>{
                this.queueWaiting.add(fn);
                if (this.queueActive.size < this.limit / 2) this.tick();
                else this.init();
            };
            this.remove = (fn)=>{
                this.queueWaiting.delete(fn);
                this.queueActive.delete(fn);
            };
            this.schedule = ()=>new Promise((resolve)=>{
                    const cleanup = ()=>this.remove(resolver);
                    const resolver = ()=>resolve(cleanup);
                    this.add(resolver);
                });
            this.tick = ()=>{
                if (this.queueActive.size >= this.limit) return;
                if (!this.queueWaiting.size) return this.reset();
                for (const fn of this.queueWaiting){
                    if (this.queueActive.size >= this.limit) break;
                    this.queueWaiting.delete(fn);
                    this.queueActive.add(fn);
                    fn();
                }
            };
        }
    }
    const retryify_queue = new RetryfyQueue();
    const retryifyAsync = (fn, isRetriableError)=>function(timestamp) {
            return function attempt(...args) {
                return retryify_queue.schedule().then((cleanup)=>{
                    const onResolve = (result)=>{
                        cleanup();
                        return result;
                    };
                    const onReject = (error)=>{
                        cleanup();
                        if (Date.now() >= timestamp) throw error;
                        if (isRetriableError(error)) {
                            const delay = Math.round(100 * Math.random());
                            const delayPromise = new Promise((resolve)=>setTimeout(resolve, delay));
                            return delayPromise.then(()=>attempt.apply(void 0, args));
                        }
                        throw error;
                    };
                    return fn.apply(void 0, args).then(onResolve, onReject);
                });
            };
        };
    const retryifySync = (fn, isRetriableError)=>function(timestamp) {
            return function attempt(...args) {
                try {
                    return fn.apply(void 0, args);
                } catch (error) {
                    if (Date.now() > timestamp) throw error;
                    if (isRetriableError(error)) return attempt.apply(void 0, args);
                    throw error;
                }
            };
        };
    const FS = {
        attempt: {
            chmod: attemptifyAsync((0, external_node_util_.promisify)(external_node_fs_.chmod), handlers.onChangeError),
            chown: attemptifyAsync((0, external_node_util_.promisify)(external_node_fs_.chown), handlers.onChangeError),
            close: attemptifyAsync((0, external_node_util_.promisify)(external_node_fs_.close), NOOP),
            fsync: attemptifyAsync((0, external_node_util_.promisify)(external_node_fs_.fsync), NOOP),
            mkdir: attemptifyAsync((0, external_node_util_.promisify)(external_node_fs_.mkdir), NOOP),
            realpath: attemptifyAsync((0, external_node_util_.promisify)(external_node_fs_.realpath), NOOP),
            stat: attemptifyAsync((0, external_node_util_.promisify)(external_node_fs_.stat), NOOP),
            unlink: attemptifyAsync((0, external_node_util_.promisify)(external_node_fs_.unlink), NOOP),
            chmodSync: attemptifySync(external_node_fs_.chmodSync, handlers.onChangeError),
            chownSync: attemptifySync(external_node_fs_.chownSync, handlers.onChangeError),
            closeSync: attemptifySync(external_node_fs_.closeSync, NOOP),
            existsSync: attemptifySync(external_node_fs_.existsSync, NOOP),
            fsyncSync: attemptifySync(external_node_fs_.fsync, NOOP),
            mkdirSync: attemptifySync(external_node_fs_.mkdirSync, NOOP),
            realpathSync: attemptifySync(external_node_fs_.realpathSync, NOOP),
            statSync: attemptifySync(external_node_fs_.statSync, NOOP),
            unlinkSync: attemptifySync(external_node_fs_.unlinkSync, NOOP)
        },
        retry: {
            close: retryifyAsync((0, external_node_util_.promisify)(external_node_fs_.close), handlers.isRetriableError),
            fsync: retryifyAsync((0, external_node_util_.promisify)(external_node_fs_.fsync), handlers.isRetriableError),
            open: retryifyAsync((0, external_node_util_.promisify)(external_node_fs_.open), handlers.isRetriableError),
            readFile: retryifyAsync((0, external_node_util_.promisify)(external_node_fs_.readFile), handlers.isRetriableError),
            rename: retryifyAsync((0, external_node_util_.promisify)(external_node_fs_.rename), handlers.isRetriableError),
            stat: retryifyAsync((0, external_node_util_.promisify)(external_node_fs_.stat), handlers.isRetriableError),
            write: retryifyAsync((0, external_node_util_.promisify)(external_node_fs_.write), handlers.isRetriableError),
            writeFile: retryifyAsync((0, external_node_util_.promisify)(external_node_fs_.writeFile), handlers.isRetriableError),
            closeSync: retryifySync(external_node_fs_.closeSync, handlers.isRetriableError),
            fsyncSync: retryifySync(external_node_fs_.fsyncSync, handlers.isRetriableError),
            openSync: retryifySync(external_node_fs_.openSync, handlers.isRetriableError),
            readFileSync: retryifySync(external_node_fs_.readFileSync, handlers.isRetriableError),
            renameSync: retryifySync(external_node_fs_.renameSync, handlers.isRetriableError),
            statSync: retryifySync(external_node_fs_.statSync, handlers.isRetriableError),
            writeSync: retryifySync(external_node_fs_.writeSync, handlers.isRetriableError),
            writeFileSync: retryifySync(external_node_fs_.writeFileSync, handlers.isRetriableError)
        }
    };
    const stubborn_fs_dist = FS;
    const constants_DEFAULT_ENCODING = 'utf8';
    const constants_DEFAULT_FILE_MODE = 438;
    const constants_DEFAULT_FOLDER_MODE = 511;
    const constants_DEFAULT_WRITE_OPTIONS = {};
    const constants_DEFAULT_USER_UID = external_node_os_.userInfo().uid;
    const constants_DEFAULT_USER_GID = external_node_os_.userInfo().gid;
    const constants_DEFAULT_TIMEOUT_SYNC = 1000;
    const constants_IS_POSIX = !!external_node_process_.getuid;
    external_node_process_.getuid && external_node_process_.getuid();
    const LIMIT_BASENAME_LENGTH = 128;
    const lang_isException = (value)=>value instanceof Error && 'code' in value;
    const lang_isString = (value)=>'string' == typeof value;
    const lang_isUndefined = (value)=>void 0 === value;
    const IS_LINUX = 'linux' === external_node_process_.platform;
    const IS_WINDOWS = 'win32' === external_node_process_.platform;
    const Signals = [
        'SIGABRT',
        'SIGALRM',
        'SIGHUP',
        'SIGINT',
        'SIGTERM'
    ];
    if (!IS_WINDOWS) Signals.push('SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT');
    if (IS_LINUX) Signals.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT', 'SIGUNUSED');
    const signals = Signals;
    class Interceptor {
        constructor(){
            this.callbacks = new Set();
            this.exited = false;
            this.exit = (signal)=>{
                if (this.exited) return;
                this.exited = true;
                for (const callback of this.callbacks)callback();
                if (signal) if (IS_WINDOWS && 'SIGINT' !== signal && 'SIGTERM' !== signal && 'SIGKILL' !== signal) external_node_process_.kill(external_node_process_.pid, 'SIGTERM');
                else external_node_process_.kill(external_node_process_.pid, signal);
            };
            this.hook = ()=>{
                external_node_process_.once('exit', ()=>this.exit());
                for (const signal of signals)try {
                    external_node_process_.once(signal, ()=>this.exit(signal));
                } catch  {}
            };
            this.register = (callback)=>{
                this.callbacks.add(callback);
                return ()=>{
                    this.callbacks.delete(callback);
                };
            };
            this.hook();
        }
    }
    const node_interceptor = new Interceptor();
    const whenExit = node_interceptor.register;
    const node = whenExit;
    const temp_Temp = {
        store: {},
        create: (filePath)=>{
            const randomness = `000000${Math.floor(16777215 * Math.random()).toString(16)}`.slice(-6);
            const timestamp = Date.now().toString().slice(-10);
            const prefix = 'tmp-';
            const suffix = `.${prefix}${timestamp}${randomness}`;
            const tempPath = `${filePath}${suffix}`;
            return tempPath;
        },
        get: (filePath, creator, purge = true)=>{
            const tempPath = temp_Temp.truncate(creator(filePath));
            if (tempPath in temp_Temp.store) return temp_Temp.get(filePath, creator, purge);
            temp_Temp.store[tempPath] = purge;
            const disposer = ()=>delete temp_Temp.store[tempPath];
            return [
                tempPath,
                disposer
            ];
        },
        purge: (filePath)=>{
            if (!temp_Temp.store[filePath]) return;
            delete temp_Temp.store[filePath];
            stubborn_fs_dist.attempt.unlink(filePath);
        },
        purgeSync: (filePath)=>{
            if (!temp_Temp.store[filePath]) return;
            delete temp_Temp.store[filePath];
            stubborn_fs_dist.attempt.unlinkSync(filePath);
        },
        purgeSyncAll: ()=>{
            for(const filePath in temp_Temp.store)temp_Temp.purgeSync(filePath);
        },
        truncate: (filePath)=>{
            const basename = external_node_path_.basename(filePath);
            if (basename.length <= LIMIT_BASENAME_LENGTH) return filePath;
            const truncable = /^(\.?)(.*?)((?:\.[^.]+)?(?:\.tmp-\d{10}[a-f0-9]{6})?)$/.exec(basename);
            if (!truncable) return filePath;
            const truncationLength = basename.length - LIMIT_BASENAME_LENGTH;
            return `${filePath.slice(0, -basename.length)}${truncable[1]}${truncable[2].slice(0, -truncationLength)}${truncable[3]}`;
        }
    };
    node(temp_Temp.purgeSyncAll);
    const temp = temp_Temp;
    function writeFileSync(filePath, data, options = constants_DEFAULT_WRITE_OPTIONS) {
        if (lang_isString(options)) return writeFileSync(filePath, data, {
            encoding: options
        });
        const timeout = Date.now() + ((options.timeout ?? constants_DEFAULT_TIMEOUT_SYNC) || -1);
        let tempDisposer = null;
        let tempPath = null;
        let fd = null;
        try {
            const filePathReal = stubborn_fs_dist.attempt.realpathSync(filePath);
            const filePathExists = !!filePathReal;
            filePath = filePathReal || filePath;
            [tempPath, tempDisposer] = temp.get(filePath, options.tmpCreate || temp.create, false !== options.tmpPurge);
            const useStatChown = constants_IS_POSIX && lang_isUndefined(options.chown);
            const useStatMode = lang_isUndefined(options.mode);
            if (filePathExists && (useStatChown || useStatMode)) {
                const stats = stubborn_fs_dist.attempt.statSync(filePath);
                if (stats) {
                    options = {
                        ...options
                    };
                    if (useStatChown) options.chown = {
                        uid: stats.uid,
                        gid: stats.gid
                    };
                    if (useStatMode) options.mode = stats.mode;
                }
            }
            if (!filePathExists) {
                const parentPath = external_node_path_.dirname(filePath);
                stubborn_fs_dist.attempt.mkdirSync(parentPath, {
                    mode: constants_DEFAULT_FOLDER_MODE,
                    recursive: true
                });
            }
            fd = stubborn_fs_dist.retry.openSync(timeout)(tempPath, 'w', options.mode || constants_DEFAULT_FILE_MODE);
            if (options.tmpCreated) options.tmpCreated(tempPath);
            if (lang_isString(data)) stubborn_fs_dist.retry.writeSync(timeout)(fd, data, 0, options.encoding || constants_DEFAULT_ENCODING);
            else if (!lang_isUndefined(data)) stubborn_fs_dist.retry.writeSync(timeout)(fd, data, 0, data.length, 0);
            if (false !== options.fsync) if (false !== options.fsyncWait) stubborn_fs_dist.retry.fsyncSync(timeout)(fd);
            else stubborn_fs_dist.attempt.fsync(fd);
            stubborn_fs_dist.retry.closeSync(timeout)(fd);
            fd = null;
            if (options.chown && (options.chown.uid !== constants_DEFAULT_USER_UID || options.chown.gid !== constants_DEFAULT_USER_GID)) stubborn_fs_dist.attempt.chownSync(tempPath, options.chown.uid, options.chown.gid);
            if (options.mode && options.mode !== constants_DEFAULT_FILE_MODE) stubborn_fs_dist.attempt.chmodSync(tempPath, options.mode);
            try {
                stubborn_fs_dist.retry.renameSync(timeout)(tempPath, filePath);
            } catch (error) {
                if (!lang_isException(error)) throw error;
                if ('ENAMETOOLONG' !== error.code) throw error;
                stubborn_fs_dist.retry.renameSync(timeout)(tempPath, temp.truncate(filePath));
            }
            tempDisposer();
            tempPath = null;
        } finally{
            if (fd) stubborn_fs_dist.attempt.closeSync(fd);
            if (tempPath) temp.purge(tempPath);
        }
    }
    var _2020 = __webpack_require__("../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/2020.js");
    var ajv_formats_dist = __webpack_require__("../node_modules/.pnpm/ajv-formats@3.0.1_ajv@8.17.1/node_modules/ajv-formats/dist/index.js");
    const copyProperty = (to, from, property, ignoreNonConfigurable)=>{
        if ('length' === property || 'prototype' === property) return;
        if ('arguments' === property || 'caller' === property) return;
        const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
        const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
        if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) return;
        Object.defineProperty(to, property, fromDescriptor);
    };
    const canCopyProperty = function(toDescriptor, fromDescriptor) {
        return void 0 === toDescriptor || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
    };
    const changePrototype = (to, from)=>{
        const fromPrototype = Object.getPrototypeOf(from);
        if (fromPrototype === Object.getPrototypeOf(to)) return;
        Object.setPrototypeOf(to, fromPrototype);
    };
    const wrappedToString = (withName, fromBody)=>`/* Wrapped ${withName}*/\n${fromBody}`;
    const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');
    const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');
    const changeToString = (to, from, name)=>{
        const withName = '' === name ? '' : `with ${name.trim()}() `;
        const newToString = wrappedToString.bind(null, withName, from.toString());
        Object.defineProperty(newToString, 'name', toStringName);
        const { writable, enumerable, configurable } = toStringDescriptor;
        Object.defineProperty(to, 'toString', {
            value: newToString,
            writable,
            enumerable,
            configurable
        });
    };
    function mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {
        const { name } = to;
        for (const property of Reflect.ownKeys(from))copyProperty(to, from, property, ignoreNonConfigurable);
        changePrototype(to, from);
        changeToString(to, from, name);
        return to;
    }
    const debounceFunction = (inputFunction, options = {})=>{
        if ('function' != typeof inputFunction) throw new TypeError(`Expected the first argument to be a function, got \`${typeof inputFunction}\``);
        const { wait = 0, maxWait = Number.POSITIVE_INFINITY, before = false, after = true } = options;
        if (wait < 0 || maxWait < 0) throw new RangeError('`wait` and `maxWait` must not be negative.');
        if (!before && !after) throw new Error('Both `before` and `after` are false, function wouldn\'t be called.');
        let timeout;
        let maxTimeout;
        let result;
        const debouncedFunction = function(...arguments_) {
            const context = this;
            const later = ()=>{
                timeout = void 0;
                if (maxTimeout) {
                    clearTimeout(maxTimeout);
                    maxTimeout = void 0;
                }
                if (after) result = inputFunction.apply(context, arguments_);
            };
            const maxLater = ()=>{
                maxTimeout = void 0;
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = void 0;
                }
                if (after) result = inputFunction.apply(context, arguments_);
            };
            const shouldCallNow = before && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (maxWait > 0 && maxWait !== Number.POSITIVE_INFINITY && !maxTimeout) maxTimeout = setTimeout(maxLater, maxWait);
            if (shouldCallNow) result = inputFunction.apply(context, arguments_);
            return result;
        };
        mimicFunction(debouncedFunction, inputFunction);
        debouncedFunction.cancel = ()=>{
            if (timeout) {
                clearTimeout(timeout);
                timeout = void 0;
            }
            if (maxTimeout) {
                clearTimeout(maxTimeout);
                maxTimeout = void 0;
            }
        };
        return debouncedFunction;
    };
    const debounce_fn = debounceFunction;
    var semver = __webpack_require__("../node_modules/.pnpm/semver@7.7.2/node_modules/semver/index.js");
    const objectToString = Object.prototype.toString;
    const uint8ArrayStringified = '[object Uint8Array]';
    const arrayBufferStringified = '[object ArrayBuffer]';
    function isType(value, typeConstructor, typeStringified) {
        if (!value) return false;
        if (value.constructor === typeConstructor) return true;
        return objectToString.call(value) === typeStringified;
    }
    function isUint8Array(value) {
        return isType(value, Uint8Array, uint8ArrayStringified);
    }
    function isArrayBuffer(value) {
        return isType(value, ArrayBuffer, arrayBufferStringified);
    }
    function isUint8ArrayOrArrayBuffer(value) {
        return isUint8Array(value) || isArrayBuffer(value);
    }
    function assertUint8Array(value) {
        if (!isUint8Array(value)) throw new TypeError(`Expected \`Uint8Array\`, got \`${typeof value}\``);
    }
    function assertUint8ArrayOrArrayBuffer(value) {
        if (!isUint8ArrayOrArrayBuffer(value)) throw new TypeError(`Expected \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof value}\``);
    }
    function concatUint8Arrays(arrays, totalLength) {
        if (0 === arrays.length) return new Uint8Array(0);
        totalLength ??= arrays.reduce((accumulator, currentValue)=>accumulator + currentValue.length, 0);
        const returnValue = new Uint8Array(totalLength);
        let offset = 0;
        for (const array of arrays){
            assertUint8Array(array);
            returnValue.set(array, offset);
            offset += array.length;
        }
        return returnValue;
    }
    const cachedDecoders = {
        utf8: new globalThis.TextDecoder('utf8')
    };
    function uint8ArrayToString(array, encoding = 'utf8') {
        assertUint8ArrayOrArrayBuffer(array);
        cachedDecoders[encoding] ??= new globalThis.TextDecoder(encoding);
        return cachedDecoders[encoding].decode(array);
    }
    function assertString(value) {
        if ('string' != typeof value) throw new TypeError(`Expected \`string\`, got \`${typeof value}\``);
    }
    const cachedEncoder = new globalThis.TextEncoder();
    function stringToUint8Array(string) {
        assertString(string);
        return cachedEncoder.encode(string);
    }
    Array.from({
        length: 256
    }, (_, index)=>index.toString(16).padStart(2, '0'));
    const ajvFormats = ajv_formats_dist["default"];
    const encryptionAlgorithm = 'aes-256-cbc';
    const createPlainObject = ()=>Object.create(null);
    const isExist = (data)=>null != data;
    const checkValueType = (key, value)=>{
        const nonJsonTypes = new Set([
            'undefined',
            'symbol',
            'function'
        ]);
        const type = typeof value;
        if (nonJsonTypes.has(type)) throw new TypeError(`Setting a value of type \`${type}\` for key \`${key}\` is not allowed as it's not supported by JSON`);
    };
    const INTERNAL_KEY = '__internal__';
    const MIGRATION_KEY = `${INTERNAL_KEY}.migrations.version`;
    class Conf {
        path;
        events;
        #validator;
        #encryptionKey;
        #options;
        #defaultValues = {};
        constructor(partialOptions = {}){
            const options = {
                configName: 'config',
                fileExtension: 'json',
                projectSuffix: 'nodejs',
                clearInvalidConfig: false,
                accessPropertiesByDotNotation: true,
                configFileMode: 438,
                ...partialOptions
            };
            if (!options.cwd) {
                if (!options.projectName) throw new Error('Please specify the `projectName` option.');
                options.cwd = envPaths(options.projectName, {
                    suffix: options.projectSuffix
                }).config;
            }
            this.#options = options;
            if (options.schema ?? options.ajvOptions ?? options.rootSchema) {
                if (options.schema && 'object' != typeof options.schema) throw new TypeError('The `schema` option must be an object.');
                const ajv = new _2020.Ajv2020({
                    allErrors: true,
                    useDefaults: true,
                    ...options.ajvOptions
                });
                ajvFormats(ajv);
                const schema = {
                    ...options.rootSchema,
                    type: 'object',
                    properties: options.schema
                };
                this.#validator = ajv.compile(schema);
                for (const [key, value] of Object.entries(options.schema ?? {}))if (value?.default) this.#defaultValues[key] = value.default;
            }
            if (options.defaults) this.#defaultValues = {
                ...this.#defaultValues,
                ...options.defaults
            };
            if (options.serialize) this._serialize = options.serialize;
            if (options.deserialize) this._deserialize = options.deserialize;
            this.events = new EventTarget();
            this.#encryptionKey = options.encryptionKey;
            const fileExtension = options.fileExtension ? `.${options.fileExtension}` : '';
            this.path = external_node_path_.resolve(options.cwd, `${options.configName ?? 'config'}${fileExtension}`);
            const fileStore = this.store;
            const store = Object.assign(createPlainObject(), options.defaults, fileStore);
            if (options.migrations) {
                if (!options.projectVersion) throw new Error('Please specify the `projectVersion` option.');
                this._migrate(options.migrations, options.projectVersion, options.beforeEachMigration);
            }
            this._validate(store);
            try {
                external_node_assert_.deepEqual(fileStore, store);
            } catch  {
                this.store = store;
            }
            if (options.watch) this._watch();
        }
        get(key, defaultValue) {
            if (this.#options.accessPropertiesByDotNotation) return this._get(key, defaultValue);
            const { store } = this;
            return key in store ? store[key] : defaultValue;
        }
        set(key, value) {
            if ('string' != typeof key && 'object' != typeof key) throw new TypeError(`Expected \`key\` to be of type \`string\` or \`object\`, got ${typeof key}`);
            if ('object' != typeof key && void 0 === value) throw new TypeError('Use `delete()` to clear values');
            if (this._containsReservedKey(key)) throw new TypeError(`Please don't use the ${INTERNAL_KEY} key, as it's used to manage this module internal operations.`);
            const { store } = this;
            const set = (key, value)=>{
                checkValueType(key, value);
                if (this.#options.accessPropertiesByDotNotation) setProperty(store, key, value);
                else store[key] = value;
            };
            if ('object' == typeof key) {
                const object = key;
                for (const [key, value] of Object.entries(object))set(key, value);
            } else set(key, value);
            this.store = store;
        }
        has(key) {
            if (this.#options.accessPropertiesByDotNotation) return hasProperty(this.store, key);
            return key in this.store;
        }
        reset(...keys) {
            for (const key of keys)if (isExist(this.#defaultValues[key])) this.set(key, this.#defaultValues[key]);
        }
        delete(key) {
            const { store } = this;
            if (this.#options.accessPropertiesByDotNotation) deleteProperty(store, key);
            else delete store[key];
            this.store = store;
        }
        clear() {
            this.store = createPlainObject();
            for (const key of Object.keys(this.#defaultValues))this.reset(key);
        }
        onDidChange(key, callback) {
            if ('string' != typeof key) throw new TypeError(`Expected \`key\` to be of type \`string\`, got ${typeof key}`);
            if ('function' != typeof callback) throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
            return this._handleChange(()=>this.get(key), callback);
        }
        onDidAnyChange(callback) {
            if ('function' != typeof callback) throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
            return this._handleChange(()=>this.store, callback);
        }
        get size() {
            return Object.keys(this.store).length;
        }
        get store() {
            try {
                const data = external_node_fs_.readFileSync(this.path, this.#encryptionKey ? null : 'utf8');
                const dataString = this._encryptData(data);
                const deserializedData = this._deserialize(dataString);
                this._validate(deserializedData);
                return Object.assign(createPlainObject(), deserializedData);
            } catch (error) {
                if (error?.code === 'ENOENT') {
                    this._ensureDirectory();
                    return createPlainObject();
                }
                if (this.#options.clearInvalidConfig && 'SyntaxError' === error.name) return createPlainObject();
                throw error;
            }
        }
        set store(value) {
            this._ensureDirectory();
            this._validate(value);
            this._write(value);
            this.events.dispatchEvent(new Event('change'));
        }
        *[Symbol.iterator]() {
            for (const [key, value] of Object.entries(this.store))yield [
                key,
                value
            ];
        }
        _encryptData(data) {
            if (!this.#encryptionKey) return 'string' == typeof data ? data : uint8ArrayToString(data);
            try {
                const initializationVector = data.slice(0, 16);
                const password = external_node_crypto_.pbkdf2Sync(this.#encryptionKey, initializationVector.toString(), 10000, 32, 'sha512');
                const decipher = external_node_crypto_.createDecipheriv(encryptionAlgorithm, password, initializationVector);
                const slice = data.slice(17);
                const dataUpdate = 'string' == typeof slice ? stringToUint8Array(slice) : slice;
                return uint8ArrayToString(concatUint8Arrays([
                    decipher.update(dataUpdate),
                    decipher.final()
                ]));
            } catch  {}
            return data.toString();
        }
        _handleChange(getter, callback) {
            let currentValue = getter();
            const onChange = ()=>{
                const oldValue = currentValue;
                const newValue = getter();
                if ((0, external_node_util_.isDeepStrictEqual)(newValue, oldValue)) return;
                currentValue = newValue;
                callback.call(this, newValue, oldValue);
            };
            this.events.addEventListener('change', onChange);
            return ()=>{
                this.events.removeEventListener('change', onChange);
            };
        }
        _deserialize = (value)=>JSON.parse(value);
        _serialize = (value)=>JSON.stringify(value, void 0, '\t');
        _validate(data) {
            if (!this.#validator) return;
            const valid = this.#validator(data);
            if (valid || !this.#validator.errors) return;
            const errors = this.#validator.errors.map(({ instancePath, message = '' })=>`\`${instancePath.slice(1)}\` ${message}`);
            throw new Error('Config schema violation: ' + errors.join('; '));
        }
        _ensureDirectory() {
            external_node_fs_.mkdirSync(external_node_path_.dirname(this.path), {
                recursive: true
            });
        }
        _write(value) {
            let data = this._serialize(value);
            if (this.#encryptionKey) {
                const initializationVector = external_node_crypto_.randomBytes(16);
                const password = external_node_crypto_.pbkdf2Sync(this.#encryptionKey, initializationVector.toString(), 10000, 32, 'sha512');
                const cipher = external_node_crypto_.createCipheriv(encryptionAlgorithm, password, initializationVector);
                data = concatUint8Arrays([
                    initializationVector,
                    stringToUint8Array(':'),
                    cipher.update(stringToUint8Array(data)),
                    cipher.final()
                ]);
            }
            if (external_node_process_.env.SNAP) external_node_fs_.writeFileSync(this.path, data, {
                mode: this.#options.configFileMode
            });
            else try {
                writeFileSync(this.path, data, {
                    mode: this.#options.configFileMode
                });
            } catch (error) {
                if (error?.code === 'EXDEV') return void external_node_fs_.writeFileSync(this.path, data, {
                    mode: this.#options.configFileMode
                });
                throw error;
            }
        }
        _watch() {
            this._ensureDirectory();
            if (!external_node_fs_.existsSync(this.path)) this._write(createPlainObject());
            if ('win32' === external_node_process_.platform) external_node_fs_.watch(this.path, {
                persistent: false
            }, debounce_fn(()=>{
                this.events.dispatchEvent(new Event('change'));
            }, {
                wait: 100
            }));
            else external_node_fs_.watchFile(this.path, {
                persistent: false
            }, debounce_fn(()=>{
                this.events.dispatchEvent(new Event('change'));
            }, {
                wait: 5000
            }));
        }
        _migrate(migrations, versionToMigrate, beforeEachMigration) {
            let previousMigratedVersion = this._get(MIGRATION_KEY, '0.0.0');
            const newerVersions = Object.keys(migrations).filter((candidateVersion)=>this._shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate));
            let storeBackup = {
                ...this.store
            };
            for (const version of newerVersions)try {
                if (beforeEachMigration) beforeEachMigration(this, {
                    fromVersion: previousMigratedVersion,
                    toVersion: version,
                    finalVersion: versionToMigrate,
                    versions: newerVersions
                });
                const migration = migrations[version];
                migration?.(this);
                this._set(MIGRATION_KEY, version);
                previousMigratedVersion = version;
                storeBackup = {
                    ...this.store
                };
            } catch (error) {
                this.store = storeBackup;
                throw new Error(`Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${error}`);
            }
            if (this._isVersionInRangeFormat(previousMigratedVersion) || !semver.eq(previousMigratedVersion, versionToMigrate)) this._set(MIGRATION_KEY, versionToMigrate);
        }
        _containsReservedKey(key) {
            if ('object' == typeof key) {
                const firstKey = Object.keys(key)[0];
                if (firstKey === INTERNAL_KEY) return true;
            }
            if ('string' != typeof key) return false;
            if (this.#options.accessPropertiesByDotNotation) {
                if (key.startsWith(`${INTERNAL_KEY}.`)) return true;
            }
            return false;
        }
        _isVersionInRangeFormat(version) {
            return null === semver.clean(version);
        }
        _shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate) {
            if (this._isVersionInRangeFormat(candidateVersion)) {
                if ('0.0.0' !== previousMigratedVersion && semver.satisfies(previousMigratedVersion, candidateVersion)) return false;
                return semver.satisfies(versionToMigrate, candidateVersion);
            }
            if (semver.lte(candidateVersion, previousMigratedVersion)) return false;
            if (semver.gt(candidateVersion, versionToMigrate)) return false;
            return true;
        }
        _get(key, defaultValue) {
            return getProperty(this.store, key, defaultValue);
        }
        _set(key, value) {
            const { store } = this;
            setProperty(store, key, value);
            this.store = store;
        }
    }
    const configStore = new Conf({
        projectName: 'agent-tars-cli',
        defaults: {
            globalWorkspaceCreated: false,
            globalWorkspaceEnabled: true
        }
    });
    async function initWorkspace() {
        const workspacePath = external_path_.join(external_os_.homedir(), '.agent-tars-workspace');
        Ie(`${chalk_source.blue('Agent TARS')} workspace initialization`);
        if (external_fs_.existsSync(workspacePath)) {
            const shouldContinue = await ye({
                message: 'Workspace already exists. Config files will be overwritten, but other files will be preserved. Continue?',
                initialValue: false
            });
            if (!shouldContinue) return void Se('Workspace initialization cancelled.');
        } else external_fs_.mkdirSync(workspacePath, {
            recursive: true
        });
        const configFormat = await ve({
            message: 'Select configuration format:',
            options: [
                {
                    value: 'ts',
                    label: 'TypeScript (recommended)'
                },
                {
                    value: 'json',
                    label: 'JSON'
                },
                {
                    value: 'yaml',
                    label: 'YAML'
                }
            ]
        });
        if (pD(configFormat)) return void xe('Workspace initialization cancelled');
        const modelProvider = await ve({
            message: 'Select default model provider:',
            options: [
                {
                    value: 'volcengine',
                    label: 'Volcengine'
                },
                {
                    value: 'anthropic',
                    label: 'Anthropic'
                },
                {
                    value: 'openai',
                    label: 'OpenAI'
                },
                {
                    value: 'azure-openai',
                    label: 'Azure OpenAI'
                }
            ]
        });
        if (pD(modelProvider)) return void xe('Workspace initialization cancelled');
        const initGit = await ye({
            message: 'Initialize git repository? (Recommended for version control)',
            initialValue: true
        });
        if (pD(initGit)) return void xe('Workspace initialization cancelled');
        const s = dist_Y();
        s.start('Creating workspace...');
        try {
            switch(configFormat){
                case 'ts':
                    await createTypeScriptConfig(workspacePath, modelProvider);
                    break;
                case 'json':
                    await createJsonConfig(workspacePath, modelProvider);
                    break;
                case 'yaml':
                    await createYamlConfig(workspacePath, modelProvider);
                    break;
            }
            if (initGit) {
                s.message('Initializing git repository...');
                await initGitRepo(workspacePath);
            }
            configStore.set('globalWorkspaceCreated', true);
            s.stop('Workspace created successfully!');
            Se([
                '\n',
                `${chalk_source.green("\u2713")} Workspace created at ${chalk_source.blue(workspacePath)}`,
                `${chalk_source.green("\u2713")} Configuration format: ${chalk_source.blue(configFormat)}`,
                `${chalk_source.green("\u2713")} Default model provider: ${chalk_source.blue(modelProvider)}`,
                `${chalk_source.green("\u2713")} To see all configiurations, check: ${chalk_source.blue('https://beta.agent-tars.com/api/config/agent.html')}`,
                `${chalk_source.green("\u2713")} To open your workspace, run: ${chalk_source.blue('agent-tars workspace --open')}`
            ].join('\n'));
        } catch (error) {
            s.stop('Failed to create workspace');
            Se(`${chalk_source.red("\u2717")} Error: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async function createTypeScriptConfig(workspacePath, modelProvider) {
        const packageJson = {
            name: 'my-agent-tars-global-workspace',
            version: '0.1.0',
            private: true,
            dependencies: {
                '@agent-tars/interface': getBootstrapCliOptions().version || 'latest'
            }
        };
        external_fs_.writeFileSync(external_path_.join(workspacePath, 'package.json'), JSON.stringify(packageJson, null, 2));
        const tsConfig = {
            compilerOptions: {
                target: 'es2022',
                module: 'commonjs',
                esModuleInterop: true,
                skipLibCheck: true,
                forceConsistentCasingInFileNames: true,
                strict: true
            }
        };
        external_fs_.writeFileSync(external_path_.join(workspacePath, 'tsconfig.json'), JSON.stringify(tsConfig, null, 2));
        const configContent = `import { defineConfig } from '@agent-tars/interface';

/**
 * @see {@link https://beta.agent-tars.com/api/config/agent.html}
 */
export default defineConfig({
  model: {
    provider: '${modelProvider}'
  }
});
`;
        external_fs_.writeFileSync(external_path_.join(workspacePath, 'agent-tars.config.ts'), configContent);
        await installDependencies(workspacePath);
    }
    function createJsonConfig(workspacePath, modelProvider) {
        const config = {
            model: {
                provider: modelProvider
            }
        };
        external_fs_.writeFileSync(external_path_.join(workspacePath, 'agent-tars.config.json'), JSON.stringify(config, null, 2));
        return Promise.resolve();
    }
    function createYamlConfig(workspacePath, modelProvider) {
        const configContent = `model:
  provider: ${modelProvider}
`;
        external_fs_.writeFileSync(external_path_.join(workspacePath, 'agent-tars.config.yaml'), configContent);
        return Promise.resolve();
    }
    async function installDependencies(workspacePath) {
        return new Promise((resolve, reject)=>{
            const npm = (0, external_child_process_namespaceObject.spawn)('npm', [
                'install'
            ], {
                cwd: workspacePath,
                stdio: 'ignore',
                shell: true
            });
            npm.on('close', (code)=>{
                if (0 === code) resolve();
                else reject(new Error(`npm install failed with code ${code}`));
            });
            npm.on('error', reject);
        });
    }
    async function initGitRepo(workspacePath) {
        return new Promise((resolve, reject)=>{
            const git = (0, external_child_process_namespaceObject.spawn)('git', [
                'init'
            ], {
                cwd: workspacePath,
                stdio: 'ignore',
                shell: true
            });
            git.on('close', (code)=>{
                if (0 === code) {
                    const gitignore = `node_modules/
.DS_Store
`;
                    external_fs_.writeFileSync(external_path_.join(workspacePath, '.gitignore'), gitignore);
                    resolve();
                } else reject(new Error(`git init failed with code ${code}`));
            });
            git.on('error', reject);
        });
    }
    async function openWorkspace() {
        const workspacePath = external_path_.join(external_os_.homedir(), '.agent-tars-workspace');
        if (!external_fs_.existsSync(workspacePath)) return void logger.error(`Workspace not found at ${workspacePath}. Please run 'agent-tars workspace --init' first.`);
        const execPromise = (0, external_util_.promisify)(external_child_process_namespaceObject.exec);
        try {
            await execPromise('code --version');
            (0, external_child_process_namespaceObject.exec)(`code "${workspacePath}"`, (error)=>{
                if (error) logger.error(`Failed to open workspace: ${error.message}`);
            });
            logger.info(`Opening workspace at ${workspacePath}`);
        } catch (error) {
            logger.warn('VSCode not found. Please install VSCode or manually open the workspace:');
            logger.info(`Workspace path: ${workspacePath}`);
        }
    }
    async function enableGlobalWorkspace() {
        const workspacePath = external_path_.join(external_os_.homedir(), '.agent-tars-workspace');
        if (!external_fs_.existsSync(workspacePath)) return void console.error(boxen(chalk_source.red('ERROR: Global workspace not found!') + '\n\n' + `Please run ${chalk_source.blue('agent-tars workspace --init')} first.`, {
            padding: 1,
            borderColor: 'red',
            borderStyle: 'round'
        }));
        configStore.set('globalWorkspaceEnabled', true);
        console.log(boxen(`${chalk_source.green('SUCCESS:')} Global workspace has been enabled!\n\n${chalk_source.gray('Location:')} ${chalk_source.blue(workspacePath)}\n${chalk_source.gray('Status:')} ${chalk_source.green('ACTIVE')}`, {
            padding: 1,
            borderColor: 'green',
            borderStyle: 'round'
        }));
    }
    async function disableGlobalWorkspace() {
        const workspacePath = external_path_.join(external_os_.homedir(), '.agent-tars-workspace');
        if (!external_fs_.existsSync(workspacePath)) console.error(boxen(chalk_source.yellow('WARNING: Global workspace directory not found.') + '\n\n' + `Workspace will be disabled, but you may want to run ${chalk_source.blue('agent-tars workspace --init')} to recreate it.`, {
            padding: 1,
            borderColor: 'yellow',
            borderStyle: 'round'
        }));
        configStore.set('globalWorkspaceEnabled', false);
        console.log(boxen(`${chalk_source.yellow('NOTICE:')} Global workspace has been disabled.\n\n${chalk_source.gray('Location:')} ${chalk_source.blue(workspacePath)}\n${chalk_source.gray('Status:')} ${chalk_source.yellow('DISABLED')}\n\nYou'll need to specify a workspace directory explicitly with ${chalk_source.blue('--workspace')} when running agent-tars.`, {
            padding: 1,
            borderColor: 'yellow',
            borderStyle: 'round'
        }));
    }
    async function showWorkspaceStatus() {
        const workspacePath = getGlobalWorkspacePath();
        const isCreated = isGlobalWorkspaceCreated();
        const isEnabled = isGlobalWorkspaceEnabled();
        const statusText = isEnabled ? 'ENABLED' : 'DISABLED';
        const statusColor = isEnabled ? 'green' : 'yellow';
        const workspaceExists = external_fs_.existsSync(workspacePath);
        const pathStatusText = workspaceExists ? 'EXISTS' : 'NOT FOUND';
        const pathStatusColor = workspaceExists ? 'green' : 'red';
        const boxContent = [
            `${chalk_source.bold('Global Workspace Status')}`,
            '',
            `${chalk_source.gray('Path:')} ${chalk_source.blue(workspacePath)}  ${chalk_source[pathStatusColor](`[${pathStatusText}]`)}`,
            `${chalk_source.gray('Status:')} ${chalk_source[statusColor](statusText)}`,
            `${chalk_source.gray('Created:')} ${isCreated ? chalk_source.green('YES') : chalk_source.red('NO')}`
        ].join('\n');
        console.log(boxen(boxContent, {
            padding: 1,
            margin: {
                top: 1,
                bottom: 1
            },
            borderColor: 'blue',
            borderStyle: 'round',
            dimBorder: true
        }));
        if (isCreated) if (isEnabled) {
            if (!workspaceExists) console.log(`The workspace directory was deleted. Run ${chalk_source.blue('agent-tars workspace --init')} to recreate it.`);
        } else console.log(`Run ${chalk_source.blue('agent-tars workspace --enable')} to enable the workspace.`);
        else console.log(`Run ${chalk_source.blue('agent-tars workspace --init')} to initialize your workspace.`);
    }
    async function processWorkspaceCommand(options) {
        try {
            if (options.init) await initWorkspace();
            else if (options.open) await openWorkspace();
            else if (options.enable) await enableGlobalWorkspace();
            else if (options.disable) await disableGlobalWorkspace();
            else if (options.status) await showWorkspaceStatus();
            else logger.error('Please specify a command: --init, --open, --enable, --disable, or --status');
        } catch (err) {
            logger.error(`Workspace command failed: ${err instanceof Error ? err.message : String(err)}`);
        }
    }
    function registerWorkspaceCommand(cli) {
        cli.command('workspace', 'Manage Agent TARS global workspace').option('--init', 'Initialize a new workspace').option('--open', 'Open workspace in VSCode').option('--enable', 'Enable global workspace').option('--disable', 'Disable global workspace').option('--status', 'Show current workspace status').action(async (options = {})=>{
            await processWorkspaceCommand(options);
        });
    }
    function isGlobalWorkspaceCreated() {
        return configStore.get('globalWorkspaceCreated');
    }
    function isGlobalWorkspaceEnabled() {
        return configStore.get('globalWorkspaceEnabled');
    }
    function getGlobalWorkspacePath() {
        return external_path_.join(external_os_.homedir(), '.agent-tars-workspace');
    }
    const shouldUseGlobalWorkspace = isGlobalWorkspaceCreated() && isGlobalWorkspaceEnabled();
    const DEFAULT_PORT = 8888;
    function addCommonOptions(command) {
        return command.option('--port <port>', 'Port to run the server on', {
            default: DEFAULT_PORT
        }).option('--open', 'Open the web UI in the default browser on server start').option('--config, -c <path>', `Path to configuration file(s) or URL(s)

                            Specify one or more configuration files or URLs. Multiple values are merged sequentially,
                            with later files overriding earlier ones. Supports local paths or remote URLs.

                            Examples:
                              --config ./my-config.json
                              --config https://example.com/config.json
                              --config ./base-config.yml --config ./override.json

                            Supported file formats: .ts, .js, .json, .yml, .yaml

                            If not specified, looks for agent-tars.config.{ts,js,json,yml,yaml} in current directory.
      `, {
            type: [
                String
            ]
        }).option('--logLevel <level>', 'Log level (debug, info, warn, error)').option('--debug', 'Enable debug mode (show tool calls and system events), highest priority').option('--quiet', 'Reduce startup logging to minimum').option('--model <model>', 'model provider config').option('--model.provider [provider]', 'LLM provider name').option('--provider [provider]', 'LLM provider name (deprecated, replaced by `--model.provider`)').option('--model.id [model]', 'Model identifier').option('--model.apiKey [apiKey]', 'Model API key').option('--apiKey [apiKey]', 'Model API key (deprecated, replaced by `--model.apiKey`)').option('--model.baseURL [baseURL]', 'Model base URL').option('--baseURL [baseURL]', 'Model Base URL (deprecated, replaced by `--model.baseURL`)').option('--stream', 'Enable streaming mode for LLM responses').option('--thinking', 'Used to control the reasoning content.').option('--thinking.type [type]', 'Enable reasoning mode for compatible models (enabled)').option('--toolCallEngine [engine]', 'Tool call engine type (native, prompt_engineering, structured_outputs)').option('--workspace <workspace>', 'workspace config').option('--workspace.workingDirectory <path>', 'Path to workspace directory').option('--browser <browser>', 'browser config').option('--browser.control [mode]', 'Browser control mode (mixed, browser-use-only, gui-agent-only)').option('--browser-control [mode]', 'Browser control mode (deprecated, replaced by `--browser.control`)').option('--browser.cdpEndpoint <endpoint>', 'CDP endpoint to connect to, for example "http://127.0.0.1:9222/json/version').option('--planner <planner>', 'Planner config').option('--planner.enable', 'Enable planning functionality for complex tasks').option('--share <share>', 'Share config').option('--share.provider [url]', 'Share provider URL').option('--share-provider [url]', 'Share provider URL (deprecated, replaced by `--share.provider`)').option('--snapshot <snapshot>', 'Snapshot config').option('--snapshot.enable', 'Enable agent snapshot functionality').option('--snapshot.snapshotPath <path>', 'Path for storing agent snapshots');
    }
    async function processCommonOptions(options) {
        var _appConfig_workspace;
        const bootstrapCliOptions = getBootstrapCliOptions();
        const isDebug = !!options.debug;
        const configPaths = buildConfigPaths({
            cliConfigPaths: options.config,
            bootstrapRemoteConfig: bootstrapCliOptions.remoteConfig,
            useGlobalWorkspace: shouldUseGlobalWorkspace,
            globalWorkspacePath: shouldUseGlobalWorkspace ? getGlobalWorkspacePath() : void 0,
            isDebug
        });
        const userConfig = await loadTarsConfig(configPaths, isDebug);
        const appConfig = ConfigBuilder.buildAppConfig(options, userConfig);
        if (appConfig.logLevel) logger.setLevel(appConfig.logLevel);
        if (shouldUseGlobalWorkspace && !(null == (_appConfig_workspace = appConfig.workspace) ? void 0 : _appConfig_workspace.workingDirectory)) {
            if (!appConfig.workspace) appConfig.workspace = {};
            appConfig.workspace.workingDirectory = getGlobalWorkspacePath();
            logger.debug(`Using global workspace directory: ${appConfig.workspace.workingDirectory}`);
        }
        logger.debug('Application configuration built from CLI and config files');
        return {
            appConfig,
            isDebug
        };
    }
    const server_namespaceObject = require("@agent-tars/server");
    async function startHeadlessServer(options) {
        const { appConfig, isDebug } = options;
        if (!appConfig.server) appConfig.server = {
            port: 8888
        };
        if (!appConfig.workspace) appConfig.workspace = {};
        const tarsServer = new server_namespaceObject.AgentTARSServer(appConfig, {
            agioProvider: getBootstrapCliOptions().agioProvider
        });
        const server = await tarsServer.start();
        const port = appConfig.server.port;
        const serverUrl = `http://localhost:${port}`;
        if (appConfig.logLevel !== types_LogLevel.SILENT) {
            const boxContent = [
                `${chalk_source.bold('Agent TARS Headless Server')}`,
                '',
                `${chalk_source.cyan('API URL:')} ${chalk_source.underline(serverUrl)}`,
                '',
                `${chalk_source.cyan('Mode:')} ${chalk_source.yellow('Headless (API only)')}`
            ].join('\n');
            console.log(boxen(boxContent, {
                padding: 1,
                margin: {
                    top: 1,
                    bottom: 1
                },
                borderColor: 'yellow',
                borderStyle: 'classic',
                dimBorder: true
            }));
        }
        return server;
    }
    function registerServeCommand(cli) {
        const serveCommand = cli.command('serve', 'Launch a headless Agent TARS Server.');
        addCommonOptions(serveCommand).action(async (options = {})=>{
            printWelcomeLogo(getBootstrapCliOptions().version);
            try {
                const { appConfig, isDebug } = await processCommonOptions(options);
                await startHeadlessServer({
                    appConfig,
                    isDebug
                });
            } catch (err) {
                console.error('Failed to start server:', err);
                process.exit(1);
            }
        });
    }
    async function startInteractiveWebUI(options) {
        const { appConfig, isDebug } = options;
        if (!appConfig.server) appConfig.server = {
            port: 8888
        };
        if (!appConfig.workspace) appConfig.workspace = {};
        if (void 0 === appConfig.workspace.isolateSessions) appConfig.workspace.isolateSessions = false;
        const staticPath = external_path_default().resolve(__dirname, '../static');
        if (!external_fs_default().existsSync(staticPath)) throw new Error('Interactive UI not found. Make sure agent-tars-web-ui is built and static files are available.');
        if (!appConfig.ui) appConfig.ui = {};
        appConfig.ui.staticPath = staticPath;
        const tarsServer = new server_namespaceObject.AgentTARSServer(appConfig, {
            agioProvider: getBootstrapCliOptions().agioProvider
        });
        const server = await tarsServer.start();
        const app = tarsServer.getApp();
        setupUI(app, appConfig.server.port, isDebug, staticPath);
        const port = appConfig.server.port;
        const serverUrl = `http://localhost:${port}`;
        if (appConfig.logLevel !== types_LogLevel.SILENT) {
            var _appConfig_workspace, _appConfig_model, _appConfig_model1, _appConfig_model2;
            const brandColor1 = '#4d9de0';
            const brandColor2 = '#7289da';
            const brandGradient = gradient_string_default()(brandColor1, brandColor2);
            const workspaceDir = (null == (_appConfig_workspace = appConfig.workspace) ? void 0 : _appConfig_workspace.workingDirectory) ? toUserFriendlyPath(appConfig.workspace.workingDirectory) : 'Not specified';
            const provider = null == (_appConfig_model = appConfig.model) ? void 0 : _appConfig_model.provider;
            const modelId = null == (_appConfig_model1 = appConfig.model) ? void 0 : _appConfig_model1.id;
            const boxContent = [
                brandGradient.multiline(`\u{1F389} Agent TARS is available at: `, {
                    interpolation: 'hsv'
                }) + chalk_source.underline(brandGradient(serverUrl)),
                '',
                `\u{1F4C1} ${chalk_source.gray('Workspace:')} ${brandGradient(workspaceDir)}`,
                '',
                `\u{1F916} ${chalk_source.gray('Model:')} ${(null == (_appConfig_model2 = appConfig.model) ? void 0 : _appConfig_model2.provider) ? brandGradient(`${provider} | ${modelId}`) : chalk_source.gray('Not specified')}`
            ].join('\n');
            console.log(boxen(boxContent, {
                padding: 1,
                margin: {
                    top: 1,
                    bottom: 1
                },
                borderColor: brandColor2,
                borderStyle: 'classic',
                dimBorder: true
            }));
            if (options.open) {
                const url = `http://localhost:${port}`;
                const command = 'darwin' === process.platform ? 'open' : 'win32' === process.platform ? 'start' : 'xdg-open';
                (0, external_child_process_namespaceObject.exec)(`${command} ${url}`, (err)=>{
                    if (err) console.error(`Failed to open browser: ${err.message}`);
                });
            }
        }
        return server;
    }
    function setupUI(app, port, isDebug = false, staticPath) {
        if (isDebug) logger.debug(`Using static files from: ${staticPath}`);
        const injectBaseURL = (req, res, next)=>{
            if (!req.path.endsWith('.html') && '/' !== req.path && !req.path.match(/^\/[^.]*$/)) return next();
            const indexPath = external_path_default().join(staticPath, 'index.html');
            let htmlContent = external_fs_default().readFileSync(indexPath, 'utf8');
            const scriptTag = `<script>
      window.AGENT_TARS_BASE_URL = "";
      console.log("AGENT_TARS: Using API baseURL:", window.AGENT_TARS_BASE_URL);
    </script>`;
            htmlContent = htmlContent.replace('</head>', `${scriptTag}\n</head>`);
            res.send(htmlContent);
        };
        app.get('/', injectBaseURL);
        app.get(/^\/[^.]*$/, injectBaseURL);
        app.use(server_namespaceObject.express["static"](staticPath));
        app.use((req, res, next)=>{
            if ('GET' === req.method && !req.path.includes('.')) return injectBaseURL(req, res, next);
            next();
        });
    }
    function registerInteractiveUICommand(cli) {
        const interactiveUIStartCommand = cli.command('[start]', 'Run Agent TARS in interactive UI');
        addCommonOptions(interactiveUIStartCommand).action(async (_, options = {})=>{
            printWelcomeLogo(getBootstrapCliOptions().version);
            try {
                const { appConfig, isDebug } = await processCommonOptions(options);
                await startInteractiveWebUI({
                    appConfig,
                    isDebug
                });
            } catch (err) {
                console.error('Failed to start server:', err);
                process.exit(1);
            }
        });
    }
    const colors = {
        reset: '\x1b[0m',
        bold: '\x1b[1m',
        dim: '\x1b[2m',
        red: '\x1b[31m',
        green: '\x1b[32m',
        yellow: '\x1b[33m',
        blue: '\x1b[34m',
        magenta: '\x1b[35m',
        cyan: '\x1b[36m',
        gray: '\x1b[90m'
    };
    function request_colorize(text, color) {
        return colors[color] + text + colors.reset;
    }
    async function processRequestCommand(options) {
        const { provider, model, body, stream, thinking, format = 'raw' } = options;
        const apiKey = resolveValue(options.apiKey, 'API key');
        const baseURL = resolveValue(options.baseURL, 'base URL');
        if (!provider) {
            console.error(request_colorize('Error: --provider is required', 'red'));
            process.exit(1);
        }
        if (!model) {
            console.error(request_colorize('Error: --model is required', 'red'));
            process.exit(1);
        }
        if (!body) {
            console.error(request_colorize('Error: --body is required', 'red'));
            process.exit(1);
        }
        if ('raw' !== format && 'semantic' !== format) {
            console.error(request_colorize('Error: --format must be either "raw" or "semantic"', 'red'));
            process.exit(1);
        }
        try {
            const requester = new core_namespaceObject.LLMRequester();
            console.log(request_colorize("\uD83D\uDE80 Sending request to ", 'cyan') + request_colorize(provider, 'bold') + request_colorize('/', 'dim') + request_colorize(model, 'bold'));
            let resolvedBody = body;
            if (!body.startsWith('/') && !body.startsWith('{')) resolvedBody = external_path_default().resolve(process.cwd(), body);
            const response = await requester.request({
                provider,
                model,
                body: resolvedBody,
                apiKey,
                baseURL,
                stream,
                thinking
            });
            console.log('\n' + request_colorize('Response:', 'bold'));
            console.log(request_colorize("\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500", 'gray'));
            if (response[Symbol.asyncIterator]) {
                console.log(request_colorize("\uD83D\uDD04 Processing streaming response...", 'magenta'));
                for await (const chunk of response)if ('raw' === format) console.log(JSON.stringify(chunk));
                else {
                    var _chunk_choices__delta, _chunk_choices_, _chunk_choices_1;
                    const content = null == (_chunk_choices_ = chunk.choices[0]) ? void 0 : null == (_chunk_choices__delta = _chunk_choices_.delta) ? void 0 : _chunk_choices__delta.content;
                    if (content) process.stdout.write(content);
                    const delta = null == (_chunk_choices_1 = chunk.choices[0]) ? void 0 : _chunk_choices_1.delta;
                    if (null == delta ? void 0 : delta.reasoning_content) process.stdout.write(request_colorize(`[Reasoning]: ${delta.reasoning_content}`, 'cyan'));
                    if (null == delta ? void 0 : delta.tool_calls) console.log('\n' + request_colorize('[Tool Call]:', 'magenta') + JSON.stringify(delta.tool_calls));
                }
            } else if ('raw' === format) console.log(JSON.stringify(response, null, 2));
            else {
                var _response_choices_;
                const message = null == (_response_choices_ = response.choices[0]) ? void 0 : _response_choices_.message;
                if (message) {
                    if (message.content) console.log(request_colorize('[Content]: ', 'green') + message.content);
                    if (message.tool_calls) {
                        console.log('\n' + request_colorize('[Tool Calls]:', 'magenta'));
                        message.tool_calls.forEach((call, index)=>{
                            var _call_function, _call_function1;
                            console.log('  ' + request_colorize(`${index + 1}.`, 'cyan') + ' ' + request_colorize((null == (_call_function = call.function) ? void 0 : _call_function.name) || 'Unknown', 'bold'));
                            console.log('     ' + request_colorize('Arguments:', 'dim') + ' ' + (null == (_call_function1 = call.function) ? void 0 : _call_function1.arguments) || '{}');
                        });
                    }
                    if (message.reasoning_content) console.log('\n' + request_colorize('[Reasoning]: ', 'cyan') + message.reasoning_content);
                } else console.log('No message content in response');
            }
            console.log(request_colorize("\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500", 'gray'));
        } catch (error) {
            console.error('\n' + request_colorize("\u274C Request failed:", 'red'));
            console.error(error);
            process.exit(1);
        }
    }
    function registerRequestCommand(cli) {
        cli.command('request', 'Send a direct request to an model provider').option('--provider <provider>', 'LLM provider name (required)').option('--model <model>', 'Model name (required)').option('--body <body>', 'Path to request body JSON file or JSON string (required)').option('--apiKey [apiKey]', 'Custom API key').option('--baseURL [baseURL]', 'Custom base URL').option('--stream', 'Enable streaming mode').option('--thinking', 'Enable reasoning mode').option('--format [format]', 'Output format: "raw" (default) or "semantic"', {
            default: 'raw'
        }).action(async (options = {})=>{
            try {
                await processRequestCommand(options);
            } catch (err) {
                console.error('Failed to process request:', err);
                process.exit(1);
            }
        });
    }
    async function processSilentRun(options) {
        const { appConfig, input, format = 'text', includeLogs = false } = options;
        if (!appConfig.workspace) appConfig.workspace = {};
        const isDebugMode = appConfig.logLevel === types_LogLevel.DEBUG;
        const shouldCaptureLogs = includeLogs || isDebugMode;
        const shouldSilenceLogs = !isDebugMode;
        const { result, logs } = await ConsoleInterceptor.run(async ()=>{
            const agent = new core_namespaceObject.AgentTARS(appConfig);
            try {
                return await agent.run(input);
            } finally{
                await agent.cleanup();
            }
        }, {
            silent: shouldSilenceLogs,
            capture: shouldCaptureLogs,
            debug: isDebugMode
        });
        if ('json' === format) {
            const output = {
                ...result,
                ...shouldCaptureLogs ? {
                    logs
                } : {}
            };
            process.stdout.write(JSON.stringify(output, null, 2));
        } else {
            if (result.content) process.stdout.write(result.content);
            else process.stdout.write(JSON.stringify(result, null, 2));
            if (shouldCaptureLogs && logs.length > 0 && !isDebugMode) {
                process.stdout.write('\n\n--- Logs ---\n');
                process.stdout.write(logs.join('\n'));
            }
        }
    }
    async function processServerRun(options) {
        const { appConfig, input, format = 'text', includeLogs = false, isDebug = false } = options;
        if (!appConfig.workspace) appConfig.workspace = {};
        appConfig.server = {
            ...appConfig.server || {},
            port: 8899
        };
        const { result, logs } = await ConsoleInterceptor.run(async ()=>{
            let server;
            try {
                server = new server_namespaceObject.AgentTARSServer(appConfig, {
                    agioProvider: getBootstrapCliOptions().agioProvider
                });
                await server.start();
                const response = await fetch(`http://localhost:${server.port}/api/v1/oneshot/query`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        query: input,
                        sessionName: input,
                        sessionTags: [
                            'run'
                        ]
                    })
                });
                if (!response.ok) throw new Error(`Server request failed: ${response.statusText}`);
                return await response.json();
            } finally{
                if (server) try {
                    await server.stop();
                } catch (stopError) {
                    if (isDebug) console.error(`Error stopping server: ${stopError}`);
                }
            }
        }, {
            silent: !isDebug,
            capture: includeLogs || isDebug,
            debug: isDebug
        });
        if ('json' === format) {
            const output = {
                ...result,
                ...includeLogs ? {
                    logs
                } : {}
            };
            process.stdout.write(JSON.stringify(output, null, 2));
        } else {
            var _result_result;
            if (null == (_result_result = result.result) ? void 0 : _result_result.content) process.stdout.write(result.result.content);
            else process.stdout.write(JSON.stringify(result, null, 2));
            if (includeLogs && logs.length > 0) {
                process.stdout.write('\n\n--- Logs ---\n');
                process.stdout.write(logs.join('\n'));
            }
        }
    }
    async function readFromStdin() {
        return new Promise((resolve)=>{
            const chunks = [];
            if (process.stdin.isTTY) return resolve('');
            process.stdin.on('data', (chunk)=>chunks.push(Buffer.from(chunk)));
            process.stdin.on('end', ()=>{
                resolve(Buffer.concat(chunks).toString().trim());
            });
            process.stdin.resume();
        });
    }
    function registerRunCommand(cli) {
        const runCommand = cli.command('run', 'Run Agent TARS in silent mode and output results to stdout');
        runCommand.option('--input [...query]', 'Input query to process (can be omitted when using pipe)').option('--format [format]', 'Output format: "json" or "text" (default: "text")', {
            default: 'text'
        }).option('--include-logs', 'Include captured logs in the output (for debugging)', {
            default: false
        }).option('--cache [cache]', 'Cache results in server storage (requires server mode)', {
            default: true
        });
        addCommonOptions(runCommand).action(async (options = {})=>{
            try {
                let input;
                if (options.input && (Array.isArray(options.input) ? options.input.length > 0 : true)) input = Array.isArray(options.input) ? options.input.join(' ') : options.input;
                else {
                    const stdinInput = await readFromStdin();
                    if (!stdinInput) {
                        console.error('Error: No input provided. Use --input parameter or pipe content to stdin');
                        process.exit(1);
                    }
                    input = stdinInput;
                }
                const quietMode = !options.debug;
                const { appConfig, isDebug } = await processCommonOptions({
                    ...options,
                    quiet: quietMode
                });
                const useCache = false !== options.cache;
                if (useCache) await processServerRun({
                    appConfig,
                    input,
                    format: options.format,
                    includeLogs: options.includeLogs || !!options.debug,
                    isDebug
                });
                else await processSilentRun({
                    appConfig,
                    input,
                    format: options.format,
                    includeLogs: options.includeLogs || !!options.debug
                });
            } catch (err) {
                console.error('Error:', err instanceof Error ? err.message : String(err));
                process.exit(1);
            }
        });
    }
    function registerCommands(cli) {
        registerServeCommand(cli);
        registerInteractiveUICommand(cli);
        registerRequestCommand(cli);
        registerRunCommand(cli);
        registerWorkspaceCommand(cli);
    }
    function bootstrapCli(options) {
        const { version, binName } = options;
        setBootstrapCliOptions({
            ...options,
            version
        });
        const cli = dist(binName ?? 'tars');
        cli.version(version);
        cli.help(()=>{
            printWelcomeLogo(version);
        });
        registerCommands(cli);
        cli.parse();
    }
})();
exports.bootstrapCli = __webpack_exports__.bootstrapCli;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "bootstrapCli"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
